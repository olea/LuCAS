<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>

<articleinfo>

<title>Grabadoras de CD - Como</title>

<author>
<firstname>Leandro Terrés, <ulink
url="mailto:lord_lt@retemail.es"
>lord_lt@retemail.es</ulink
>
 y Francisco J. Montilla, <ulink
url="mailto:pacopepe@insflug.org"
>pacopepe@insflug.org</ulink
></firstname>
</author>

<pubdate>v1.6.1, 21 de Noviembre de 1999</pubdate>

<abstract>

<para>
Introducción al uso de Grabadoras de CD-R, CD-RW y DVD bajo Linux, así
como descripción del uso de los programas necesarios. Este documento se
diferencia del Creación-CDRoms-Como por su enfoque, más centrado en el uso
de distintos tipos de grabadoras, y las últimas novedades software. Es conveniente que también lea el Creacion-CDRoms-Como, enfocado más en la
plataforma SCSI, que profundiza más en los aspectos técnicos de la
tecnología CD-R y en sus posibilidades. 
</para>

</abstract>

</articleinfo>

<sect1>
<title>Introducción</title>

<para>
Este documento pretende guiar al usuario, de forma que sepan qué tienen
que hacer y cómo solucionar los posibles problemas que puedan plantearse a
lo largo del camino de la grabación de CDRoms.
</para>

<para>
Se da una pequeña explicación sobre los sistemas de ficheros para
los CDs (todo a su tiempo) y de cómo se usan los programas más utilizados
para grabar en Linux. Por supuesto, y en último lugar, la omnipresente
<emphasis remap="it">PUF</emphasis> (<emphasis remap="it">Preguntas de Uso Frecuente</emphasis>) por si se escapa algo.
</para>

<para>
Recomiendo leer todos los apartados, uno detrás de otro, para ampliar
conocimientos, que resultará beneficioso a la hora de buscar posibles
irregularidades, fallos o errores en la elaboración de este documento o en
lo que se refiere a conceptos en Linux en sí.
</para>

<para>
Y ya por último indicar que hasta la versión <literal remap="tt">1</literal> de este documento
explicaremos cómo se graban CDs normales, pero para la siguiente versión,
la <literal remap="tt">2.0</literal> intentaremos ir mas allá, a las grabadoras DVD, momento que
bajo mi punto de vista no tardará en llegar. 
</para>

<sect2 id="Aportaciones">
<title>Aportaciones
</title>

<para>
Recuerde que este documento está en desarrollo y cualquiera que pueda
aportar su granito de arena con sus problemas y soluciones, correcciones
(ya que seguro que me he equivocado en algún sitio) o adición de detalles;
siendo además amablemente incluido como colaborador. (Ver sección <xref linkend="creditos"/>)
</para>

<para>
Para hacerlo sólo tiene que o bien utilizar el sistema en línea de
Insflug, <literal remap="tt">
<ulink url="http://www.insflug.org/comos/comos.php3" >
http://www.insflug.org/comos/comos.php3</ulink>
</literal> de adición al sistema
de fe de erratas, o sugerencias, para que inmediatamente esté disponible
para todos, y enviar un mail a <literal remap="tt"><ulink
url="mailto:lord_lt@retemail.es"
>lord_lt@retemail.es</ulink
></literal>
</para>

<para>
Animo a leer este documento con paciencia, sin reparos en participar con
correcciones o añadiduras al mismo, para que toda la comunidad Linux se
beneficie de él. Las felicitaciones y enhorabuenas también son bien
recibidas ;-).
</para>

</sect2>

</sect1>

<sect1 id="soportadas">
<title>Grabadoras soportadas
</title>

<para>
Podemos dividir el soporte a una grabadora bajo LiNUX en tres aspectos:
</para>

<para>

<orderedlist>
<listitem>

<para>
Que Linux tenga soporte genérico para el bus del que <emphasis remap="it">cuelga</emphasis>
la grabadora.

</para>
</listitem>
<listitem>

<para>
Que el software específico de grabación soporte la utilización de dicho 
bus para grabar.

</para>
</listitem>
<listitem>

<para>
Que además de lo anterior, el software específico de grabación
soporte la grabadora en concreto.
</para>
</listitem>

</orderedlist>

</para>

<para>
Respecto al punto 1, Linux soporta genéricamente grabadoras CD-R, CD-RW, DVD-R,
DVD-RW y DVD-RAM con interfaces:
</para>

<para>

<itemizedlist>
<listitem>

<para>
SCSI
</para>
</listitem>
<listitem>

<para>
IDE/ATAPI
</para>
</listitem>
<listitem>

<para>
IDE/ATAPI por puerto paralelo.
</para>
</listitem>

</itemizedlist>
 
</para>

<para>
Podemos decir por tanto que, a excepción de las grabadoras SCSI, con las
que <emphasis remap="bf">además</emphasis> es preciso que la <emphasis remap="bf">controladora SCSI</emphasis> esté soportada por
Linux, hoy en día la capacidad de utilizar una grabadora en concreto
reside enteramente en el programa utilizado para grabar.
</para>

<para>
En la actualidad, el único programa con desarrollo activo es
<literal remap="tt">cdrecord</literal>; por lo que la cuestión dependerá enteramente de que
<literal remap="tt">cdrecord</literal> la soporte o no; a grosso modo, podemos afirmar que casi
todas las grabadoras están soportadas.
</para>

<para>
En <literal remap="tt"><ulink
url="http://www.guug.de:8080/cgi-bin/winni/lsc.pl"
>http://www.guug.de:8080/cgi-bin/winni/lsc.pl</ulink
></literal> Winfried
Truemper mantiene un listado de las soportadas. Si entre ellas
está la suya, hay un 99% de posibilidades de que pueda utilizarla
bajo Linux sin problemas.
</para>

<para>
No obstante, la última palabra la tiene siempre la documentación de
<literal remap="tt">cdrecord</literal>:  vea la sección <xref linkend="cdrecord"/>.
</para>

<para>
Aun en el caso de que su grabadora no estuviera soportada, le quedaría la
opción de crear las imágenes bajo Linux, y grabarlas bajo cualquier otro
sistema operativo. 
</para>

</sect1>

<sect1>
<title>Configuración del Kernel</title>

<para>
El primer paso es configurar el kernel para que Linux vea nuestras
grabadoras y/o lectores correctamente, tanto si son SCSI como IDE o ATAPI
por puerto paralelo.
</para>

<para>
En los dos últimos casos hay que hacer ciertos «chanchullos», aunque el
que más pueda resultar dificultoso sea configurar el kernel para
grabadoras IDE, ya que no basta conectarla, decirle que es un dispositivo
IDE/ATAPI CD-ROM y directo a grabar como un poseso; hay que recompilar el
kernel con una serie de opciones y modificaciones que se describen y
explican en su apartado correspondiente. 
</para>

<para>
Hay que saber cómo configurar el kernel, para ello entramos en el
directorio <literal remap="tt">/usr/src/linux</literal>, donde normalmente se encuentran los
fuentes. Para asegurarnos de que nada raro pueda pasar, ejecutaremos
<literal remap="tt">make mrproper</literal> lo que elimina todos los binarios, incluso las
configuraciones; es decir, una limpieza exhaustiva que asegure que no haya
ninguna interferencia de nada de lo anterior que pueda hacer que el nuevo
kernel no compile o nos dé errores. 
</para>

<para>
Una vez hecho esto, teclearemos <literal remap="tt">make menuconfig</literal> si queremos interfaz
ncurses para el shell o <literal remap="tt">make xconfig</literal> desde un terminal de X-Window
para hacer lo mismo en X con interfaz TCL/TK, lo que quiere decir que si
no tiene dichas librerías no podrá compilar los programas respectivos. 
</para>

<para>
Podrá recurrir en última instancia al viejo programa de configuración, un
script que se invoca desde la consola con <literal remap="tt">make config</literal> y en el que
tendrá que poner <literal remap="tt">y (si)</literal>, <literal remap="tt">n (no)</literal> y/o <literal remap="tt">m (módulo)</literal> el los
lugares en donde corresponda en el prompt, ya que éste no permite volver
hacia atrás; si quiere hacerlo tiene dos opciones, una pulsar
<literal remap="tt">Control+C</literal> y cancelar la configuración volviendo a empezar, o terminar
de configurar y volver a empezar, (lo configurado anteriormente se
mantiene), y rectificar lo que haya dejado o haya puesto mal. 
</para>

<para>
Si tiene mas dudas sobre cómo configurar el núcleo del sistema le remito
al documento <emphasis remap="it">Kernel Como</emphasis> que se encuentra en <literal remap="tt"><ulink
url="http://www.insflug.org"
>http://www.insflug.org</ulink
></literal>. 
</para>

<sect2 id="scsi">
<title>Configurar el Kernel para grabadoras SCSI </title>

<para>
Voy a suponer que no tiene ni la más remota idea de qué es el sistema
SCSI, cosa en la que tampoco voy a profundizar, ya que para eso hay un
hermoso documento llamado <emphasis remap="it">SCSI-HOWTO</emphasis> al cual puede referirse en caso
de dudas y o problemas de configuración del dispositivo SCSI.
</para>

<para>
El caso es que se ha comprado un equipo cuya placa madre trae SCSI
integrada, o una controladora SCSI en la que ha puesto el CD, y el dichoso
windows lo ha configurado a la primera o los amables chicos de la tienda
de informática en donde acaba de comprarlo han instalado y configurado
todo.
</para>

<para>
Lo primero es saber qué tipo de controladora SCSI es, me refiero a su chip
principal; las controladoras más comunes son <emphasis remap="it">Adaptec</emphasis>, <emphasis remap="it">Advansys</emphasis> y
las basadas en los chip <emphasis remap="it">Symbios 53c8xx</emphasis> (<emphasis remap="it">NCR</emphasis>), pero si no tiene
ninguna de éstas no se preocupe, el kernel lleva soporte para muchas más.
Puede saber qué controladora tiene mirando simplemente los manuales,
mirando el chip principal de la tarjeta o el nombre del controlador de
windows (sólo en última instancia). 
</para>

<para>
Si el controlador no corresponde exactamente al modelo que aparece en el
kernel, seguramente funcionará con alguno de los que lleva genéricos para
varios tipos de controladoras con las mismas características. Puede
compilar como módulo las que más se parezcan al suyo y luego ir probando
los módulos hasta que dé con el que corresponda. Si al cargar algún módulo
nota que se le ha quedado el ordenador colgado, no lo vuelva a intentar
con ese, ya que algunos controladores que no corresponden al hardware
instalado son cargados de todos modos produciendo estas desagradables
situaciones. 
</para>

<para>
Acto seguido nos vamos a la configuración del kernel y entramos en
<literal remap="tt">SCSI Support</literal>, lo que luego nos dejará señalar las demás opciones que
son para dar soporte genérico, y a unidades de CD-ROM, Discos Duros y
cintas, de las cuales nos interesa el soporte genérico, <literal remap="tt">SCSI generic
support</literal>, que proporciona el interfaz ASPI, (para poder grabar) y el
<literal remap="tt">SCSI CD-ROM support</literal>, para leer unidades de CD-ROM, incluidas
grabadoras y DVDs.  Si dispone de un disco duro, ZIP o JAZ SCSI deberá
responder <literal remap="tt">y</literal> también si quiere poder usarlo. 
</para>

<para>
Si por casualidad tiene la grabadora como unidad externa, y la
controladora SCSI dedicada en <emphasis remap="it">exclusiva</emphasis> a ella, recomiendo que ponga
el driver de la controladora como módulo, es decir, poniendo <literal remap="tt">m</literal> en
lugar de <literal remap="tt">y</literal>, ya que le permitirá cargar/descargar a voluntad todos los
módulos de soporte SCSI cuando no los necesite, y apagar la unidad externa
cuando no la esté usando (cosa que con windows no es posible hasta el W98) 
ya que al cargar su módulo, la controladora inicializará y escaneará los
dispositivos de nuevo sin necesidad de reiniciar el ordenador para
detectarlos; si la tiene interna, añada el soporte directamente en el
kernel y se ahorra trabajo en cargar los módulos. 
</para>

<para>
Tenga en cuenta no obstante, que si carga, descarga, y vuelve a cargar el
módulo sin reiniciar el equipo, la controladora recibirá un número de host
distinto, y los parámetros que tengamos para <literal remap="tt">cdrecord</literal> configurados no
serán válidos. 
</para>

<para>
Si no puede descargar el soporte SCSI por tener otros dispositivos
dependiendo de él (porque su disco duro raíz sea SCSI, por ejemplo, o por
no poder tenerlo como módulo por las razones que sean) también puede
activar y desactivar dispositivos a voluntad, incluidas grabadoras,
cintas, escáneres, etc. sin necesidad de descargar el módulo. vea la
sección <xref linkend="alvuelo"/>.
</para>

<para>
Así que una vez hecho esto pase al apartado siguiente para especificar el
driver de su controladora. Si le ha dicho antes, en soporte SCSI, que lo
compile como módulo solo le dejará seleccionar como módulo el driver del
controlador. 
</para>

<para>
Espero que no se equivoque en escoger el driver para su controladora,
porque si es así le tocará elegir otro y recompilar solo los módulos.  Una
vez recompilados los nuevos módulos, previa configuración, sólo tendrá que
probarlos; si ha incluido soporte SCSI en el kernel junto a un
controlador, éste detectará el dispositivo y podrá accederse a él desde
los ficheros de dispositivo <literal remap="tt">/dev/scdX</literal> o <literal remap="tt">/dev/srX</literal> (estos
últimos se crean, si no lo están ya, a través de un script que se puede
encontrar junto a los programas de grabación, así como con el script
<literal remap="tt">/dev/MAKEDEV</literal>, o bien el que trae el <literal remap="tt">X-CD-Roast</literal> (sección <xref linkend="xcdroast"/>) o bien <emphasis remap="it">a mano</emphasis> con el comando
<literal remap="tt">mknod</literal> con este bucle:
</para>

<para>

<screen>
for i in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; 
    do mknod /dev/sr$i b 11 $i;
done
</screen>

</para>

<para>
Del mismo modo, si lo ha hecho como módulo, sólo tendrá que cargar los
módulos SCSI en el siguiente orden: 
</para>

<para>

<orderedlist>
<listitem>

<para>
Módulo <literal remap="tt">scsi_mod.o</literal> que es el driver principal del que cuelgan
todos:


<screen>
insmod scsi_mod
</screen>


</para>
</listitem>
<listitem>

<para>
Seguido del módulo de soporte para SCSI genérico (proporciona el interfaz
ASPI <emphasis remap="it">Advanced SCSI Programming Interface</emphasis>, para poder grabar CDs, o
usar algunos programas con unidades de cinta, escáneres, etc) <literal remap="tt">sg.o</literal> y
el de soporte de CD-ROMs SCSI, <literal remap="tt">sr_mod.o</literal>: 
	

<screen>
insmod sg
insmod sr_mod
</screen>


</para>
</listitem>
<listitem>

<para>
Por último, hacer un <literal remap="tt">insmod</literal> al driver que corresponda a su
controladora, el cual sacará un debug de lo que encuentre, de tal forma
que las unidades de CD corresponderán a <literal remap="tt">/dev/sr0</literal> para el primer
dispositivo CD-ROM SCSI, <literal remap="tt">/dev/sr1</literal> para el segundo, etc,
independientemente del bus o ID SCSI en el que estén. 

</para>
</listitem>

</orderedlist>

</para>

<para>
De todas maneras si hace un <literal remap="tt">cat</literal> al archivo <literal remap="tt">/proc/scsi/scsi</literal>
podrá ver qué ID SCSI se tienen sus dispositivos, dato indispensable para
determinar los interfaces genéricos <literal remap="tt">/dev/sgX</literal>. 
</para>

<para>
Si instala <literal remap="tt">X-CD-Roast</literal> podrá usar los dispositivos <literal remap="tt">/dev/sr0</literal>
hasta <literal remap="tt">/dev/sr15</literal>; también puede usarlos en lugar de los
dispositivos <literal remap="tt">/dev/scdX</literal>, que usan otros programas, como
<literal remap="tt">cdrecord</literal>. Estos son los nuevos dispositivos que se usarán a partir de
ahora para referirse a las unidades de discos ópticos tipo ROM como los
CD-ROM y DVD-ROM.
</para>

<para>
Recomiendo que active el soporte <literal remap="tt">kerneld</literal>, e introduzca el alias
apropiado a la controladora en <literal remap="tt">/etc/conf.modules</literal>, para que la
carga de los módulos sea automática. Si tiene dudas sobre esto, lea el
<emphasis remap="it">Kernel-Como</emphasis> para mejor referencia. Si ya tiene una distribución con
el kernel <literal remap="tt">2.2.XX</literal> no se cargará el <literal remap="tt">kerneld</literal>, el propio kernel hace
las funciones del <literal remap="tt">kerneld</literal>. 
</para>

<para>
Lea también la sección <xref linkend="IDE"/> porque explico algunas cosas más que pueden servir para
solucionar posibles problemas que puedan ocurrir y que son comunes tanto
para IDE como para SCSI. Y porqué no, para cuando un amigo se instale una
grabadora IDE... 
</para>

<sect3 id="alvuelo">
<title>Activación y desactivación de dispositivos SCSI <emphasis remap="it">al vuelo</emphasis> </title>

<para>
La forma más limpia de hacer que el kernel active o desactive sin
necesidad de resetear el sistema, o cargar/descargar módulos, dando igual
si está compilado el soporte como módulo o no, es mediante el siguiente
método. 
</para>

<para>
El activar o desactivar dispositivos SCSI a voluntad sin necesidad de
demasiados aspavientos puede ser más práctico de lo que parece: suponga
que su grabadora es externa, y la mantiene apagada mientras no la usa, lo
mismo sucede con un scanner, unidad ZIP, JAZ, CDROMs o unidades de cinta
externa, dando por supuesto que son SCSI, claro está.
</para>

<para>
<emphasis remap="bf">Advertencia</emphasis>: Cuando hablamos de activar, nos referimos al caso en que
el dispositivo está <emphasis remap="it">conectado</emphasis> externamente a la controladora, pero en
un principio apagado, y una vez encendido, deseamos activar; no que
cualquier controladora SCSI mediante este método soporte
<emphasis remap="it">conexión/desconexión en caliente de dispositivos</emphasis>, tenga cuidado o
puede desde corromper datos a estropear definitivamente dispositivos del
bus SCSI.
</para>

<para>
Supongamos que la grabadora está en la primera o única controladora SCSI
del sistema, y que la grabadora tiene asignado el ID SCSI 4. 
</para>

<para>
si ejecutamos el comando:
</para>

<para>

<screen>
echo "scsi add-single-device 0 0 4 0" &#62; /proc/scsi/scsi
</screen>

</para>

<para>
El kernel activará la grabadora.
</para>

<para>
En este caso, el primer <literal remap="tt">0</literal> especifica la primera controladora, el
segundo el canal de la controladora (a menos que tenga una Wide o UW SCSI. 
siempre será <literal remap="tt">0</literal>, ya que sólo tiene uno; no confundir canal con
conector) el <literal remap="tt">4</literal> especifica el ID SCSI, y el último <literal remap="tt">0</literal> el LUN. (Ver
sección <xref linkend="notacion"/>)
</para>

<para>
y si ejecutamos
</para>

<para>

<screen>
echo "scsi remove-single-device 0 0 4 0" &#62; /proc/scsi/scsi
</screen>

</para>

<para>
La desactivaremos.
</para>

</sect3>

</sect2>

<sect2 id="IDE">
<title>Configurar el Kernel para grabadoras IDE </title>

<para>
El problema de las grabadoras IDE es que no hay software específico que
detecte y grabe en estos dispositivos, ya que todos los programas se basan
en la interfaz SCSI <emphasis remap="it">(ASPI)</emphasis> del kernel para acceder a éstos. 
</para>

<para>
Por esta razón, no es tan sencillo configurar del Kernel para las
grabadoras IDE. Lo primero es aplicar una pequeña modificación al Kernel,
sólo necesario si tiene una grabadora Regrabable <emphasis remap="it">HP</emphasis> como las
<emphasis remap="it">7100</emphasis> o <emphasis remap="it">7110</emphasis> o superiores. 
</para>

<para>
La modificación, que consiste en aumentarle el tiempo de espera del IRQ,
es absolutamente necesaria ya que si no lo hacemos no cerrará los CDs, o
al intentar cerrarlos, es decir, al escribir la <emphasis remap="it">Tabla de Contenidos</emphasis>,
se detendrá con un error y habremos perdido el CD sin forma de
recuperarlo.
</para>

<para>
Para efectuarla, vamos al archivo <literal remap="tt">ide.h</literal> que se encuentra en
<literal remap="tt">/usr/src/linux/drivers/block</literal>, y buscamos la siguiente línea:
</para>

<para>

<screen>
#define WAIT_CMD	(10*HZ)	/* 10sec  - maximum wait for an IRQ to happen */
</screen>

</para>

<para>
que tenemos que modificar de modo que quede así:
</para>

<para>

<screen>
#define WAIT_CMD	(1000*HZ)	/* 1000sec  - maximum wait for an IRQ to happen */
</screen>
 
</para>

<para>
Con lo cual solucionamos el problema. Parece ser que con poner <literal remap="tt">400</literal> en
vez de <literal remap="tt">1000</literal> funciona, pero no lo he probado personalmente. De todas
formas, con el paquete de los fuentes del <literal remap="tt">cdrecord</literal> viene un archivo
llamado <literal remap="tt">README.ATAPI</literal>, en que se dice que haga exactamente esto, así
como cómo hacer funcionar estas grabadoras con la versión antigua de
<literal remap="tt">cdrecord</literal>, es decir, la <literal remap="tt">1.5</literal>, aplicándole un serie de parches al
programa y al kernel.
</para>

<para>
Una vez realizada la modificación debe configurar el kernel, ir al menú
<literal remap="tt">Floppy, IDE and other block devices</literal>, desactivar el soporte para
<literal remap="tt">IDE/ATAPI CD-ROM</literal> (¡OJO, <emphasis remap="bf">NO</emphasis> el <literal remap="tt">Enhanced IDE/MFM/RLL
disk/cdrom/tape/floppy support</literal>!) y activar la emulación SCSI que sólo
hay en los últimos kernel, versiones <literal remap="tt">2.0.31</literal> en adelante y <literal remap="tt">2.2.XX</literal>,
para que así los programas detecten nuestra grabadora IDE como SCSI y
funcione como tal.
</para>

<para>
Si activamos el soporte IDE/ATAPI para las unidades de CD-ROM el kernel no
detectará nuestra grabadora como un dispositivo SCSI y habremos perdido el
tiempo. Hacer que a nuestra grabadora la vean los programas como si fuera
SCSI es muy sencillo, y se basa en que las grabadoras reciben comandos
estandarizados (pertenecientes al interfaz <emphasis remap="it">ASPI</emphasis>, <emphasis remap="it">Advanced SCSI
Programming Interface</emphasis>) para grabar que por casualidad son específicos de
los SCSI; de esta forma, con la emulación lo que hacemos es que se puedan
enviar este tipo de comandos a través del bus IDE de nuestra grabadora. 
</para>

<para>
Hasta el momento que he tenido para probarlo, funciona perfectamente, tan
bien, que se consigue un rendimiento similar al de una SCSI auténtica.
</para>

<para>
De la misma forma, windows lo que hace es emular SCSI con las IDE, lo que
le trae una pequeña serie de inconvenientes como cierto software que no
funciona bien o el excesivo consumo de recursos del sistema. 
</para>

<para>
Por lo visto las grabadoras IDE consumen muchos recursos, más que las
SCSI, pero en linux con la emulación la carga parece menor, o al menos no
se nota de forma excesiva; lo único recomendable es dejar un puerto IDE
para ella sola, según recomiendan los fabricantes; lo mas común suele ser
el secundario.
</para>

<para>
Con esto nos aseguramos de que no haya cualquier posible interferencia del
otro dispositivo que haya conectado al puerto de la grabadora (solo por
seguridad); yo he probado a tener el lector y la grabadora en el mismo
interfaz, esto se puede hacer pero recomiendo que desmonte la unidad
lectora de CD para que no haya interferencias; se puede usar, por ejemplo,
para escuchar CDs de música mientras se graba el CD, si tiene botón de
reproducción, claro esta ;).
</para>

<para>
He recibido noticias de que hay gente que tiene la grabadora y la unidad
lectora colocadas en la misma interfaz haciendo copias directas sin muchos
problemas. Antes de ponerlo así, recomiendo realizar muchas pruebas antes
de dejarlo de forma fija.
</para>

<para>
El último paso para configurar el kernel es ir a la sección <literal remap="tt">SCSI
support</literal> e incluir el soporte SCSI en el kernel, junto al <literal remap="tt">SCSI
generic</literal> y el soporte SCSI para los CD-ROM (Ojo, no lo haga como módulo,
hay un fallo en la configuración para la emulación SCSI a la hora de
incluir el soporte genérico SCSI en el kernel, por lo que si no lo
incluimos manualmente en él no podremos compilar el nuevo kernel y es
posible que se pase un buen rato dándole vueltas a lo mismo). 
</para>

<para>
Gracias a este procedimiento ahora nuestra grabadora y/o lectora/as
aparecerán como dispositivos SCSI en vez de IDE. 
</para>

<para>
No es nada recomendable hacer cosas con el disco duro «origen» mientras se
está grabando, si lee datos de un disco secundario podrá trabajar con el
principal, pero no recomiendo abusar de su uso ya que es posible que pueda
haber alguna pequeña interferencia con el DMA, aunque no suele ser muy
común. Es decir, deje el disco duro sólo para la grabación. 
</para>

<para>
Otra cosa a tener en cuenta es que si no tiene un disco con extracción por
DMA como un Fast ATA o Ultra DMA desactive del kernel el soporte para el
chip Intel Tritón (I/II), ya que si hará interferencia el DMA con la
emulación y dejará el controlador colgado, obligándole a resetear el
ordenador con ese botón que se tiene algo olvidado la gente de linux. 
(Mirar en el apartado <xref linkend="PUF"/>)
para más detalles).
</para>

</sect2>

<sect2 id="parport">
<title>Configurar el Kernel para grabadoras IDE-ATAPI por puerto paralelo
</title>

<para>
¿Grabadoras por puerto paralelo? ¿De verdad eso existe? Pues sí, existe, y
cómo Linux es capaz de usarlas, ¿Cómo? Gracias <literal remap="tt">cdrecord</literal> y a los
desarrolladores del kernel que han introducido como novedad de los núcleos
<emphasis remap="it">2.1.x</emphasis>: (de desarrollo) el soporte para unidades ATAPI por puerto
paralelo como unidades de CD-ROM y discos duros. 
</para>

<para>
Para esto deberemos tener el kernel <literal remap="tt">2.0.35</literal> o superior con la
configuración necesaria para que reconozca nuestra unidad externa, que se
describe a continuación: 
</para>

<para>
Lo primero de todo es reiniciar el ordenador y entrar en la configuración
de la <emphasis remap="it">BIOS</emphasis>, y, normalmente, en el menú <literal remap="tt">Integrated Peripherals</literal>,
si tiene la controladora del puerto paralelo integrada en la placa base,
como en las últimas placas de 486 y en todas las placas de Pentium y
Pentium Pro/II. Configuraremos el puerto de impresora en modo <emphasis remap="it">EPP</emphasis>, si
no lo establecemos así, no habrá forma de que funcione.
</para>

<para>
Seguidamente, una vez arrancado nuestro sistema entrar en la configuración
del kernel en <literal remap="tt">Floppy, IDE, and other block devices</literal> y seleccionar como
módulo el parámetro <literal remap="tt">Parallel port IDE device support</literal>. Seguidamente
seleccionar, al menos, también como módulos los siguientes:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">Parallel port ATAPI CD-ROMs</literal>
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">Parallel port generic ATAPI devices</literal>
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">Shuttle EPAT/EPEZ protocol</literal>
</para>
</listitem>

</itemizedlist>

</para>

<para>
De esta forma ya tenemos los módulos para hacer funcionar la grabadora
como unidad lectora; si lo prefiere puede incluirlo en el kernel, pero
primero asegúrese de que funciona bien como módulo antes. 
</para>

<para>
Seguidamente procedemos a la recompilación e instalación de los módulos en
su lugar, y sin necesidad de reiniciar (a no ser que se actualice partes
no compiladas como módulos)  ejecute <literal remap="tt">depmod -a</literal> para crear las
dependencias de los módulos a fin de poder cargarlos con <literal remap="tt">modprobe</literal>,
<literal remap="tt">kerneld</literal> o <literal remap="tt">kmod</literal>.
</para>

<para>
Comenzamos por cargar el modulo <literal remap="tt">paride</literal>, el <literal remap="tt">epat</literal>, y por último el
módulo del driver que vayamos a usar; como nos interesa poder usar nuestra
grabadora tenemos que cargar el <literal remap="tt">pg</literal> para que nos reconozca la
grabadora <literal remap="tt">cdrecord</literal> (equivalente al módulo <literal remap="tt">sg</literal> en SCSI) y el
<literal remap="tt">pcd</literal> para usar la grabadora como unidad lectora (el equivalente a
<literal remap="tt">sr</literal> en SCSI).
</para>

<para>
Para usar nuestra unidad como lectora debemos montar la unidad con la orden:
</para>

<para>

<screen>
mount /dev/pcd0 /cdrom
</screen>

</para>

<para>
No obstante, si piensa utilizar su grabadora como lector, o para
extracción de audio asiduamente, le recomiendo que lea la sección <xref linkend="mtbf"/>, su bolsillo lo acabará agradeciendo.
</para>

<para>
Si no existe el dispositivo <literal remap="tt">/dev/pcd0</literal> puede crearlo con el
siguiente bucle:
</para>

<para>

<screen>
for i in 0 1 2 3 ; do mknod /dev/pcd$i b 46 $i ; done
</screen>

</para>

<para>
Si dispone del un kernel de la serie <literal remap="tt">2.1.x</literal> o <literal remap="tt">2.2.x</literal> antes de usar
los controladores de cualquier dispositivo de puerto paralelo ha de cargar
el módulo <literal remap="tt">parport.o</literal>, el cual hace de interfaz para poder tener
cargados y operativos varios dispositivos de puerto paralelo al mismo
tiempo como unidades ZIP, discos y lectores/grabadores de CD e impresoras
y scanners simultáneamente (genial ¿¿¿no??? ;-)). 
</para>

<para>
Como todavía no ha caído en mis manos una grabadora de este tipo no he
podido hacer pruebas ni nada por el estilo, los detalles de la
configuración del kernel los he elaborado a partir de lo que he podido
recopilar leyendo por la Web y la ayuda prestada por colaboradores.
</para>

<para>
Apelo a la colaboración de la comunidad linuxera a fin de completar este
apartado con lo que más le vaya haciendo falta, para estar a la altura de
los anteriores; bien se lo merece el esfuerzo mostrado por las personas
que hacen posible que dispositivos tan raros y minoritarios sean capaces
de ser utilizados por Linux.
</para>

</sect2>

<sect2 id="otraskernel">
<title>Otras opciones del kernel recomendables
</title>

<para>
En linux (y en unix) existe la posibilidad de poder acceder, leer y
escribir en sistemas de archivos que no se encuentren en una partición o
en un disco, sino, en un fichero. ¿Cómo? ¿En un fichero? Si, así es, y
para eso solo necesitamos dos cosas, un dispositivo <literal remap="tt">loopback</literal> y el
comando <literal remap="tt">mount</literal>.
</para>

<para>
Para asegurarnos de que incluimos esta opción en el kernel como módulo
entramos en la configuración del kernel mediante <literal remap="tt">make menuconfig</literal>, y
accedemos al menú <literal remap="tt">Floppy, IDE, and other block devices</literal>; justo tras
<literal remap="tt">Additional Block Devices</literal> se encuentra la opción <literal remap="tt">Loopback device
support</literal> la cual recomiendo seleccionar como módulo, y si en el menú
principal <emphasis remap="it">Filesystems</emphasis> tiene seleccionada la opción <literal remap="tt">Kernel
automounter support</literal> al montar el archivo, este módulo se cargará
automáticamente; si la opción anterior está como módulo deberá cargarlo a
mano, sino no se cargará automáticamente ningún modulo y nos dará error.
Para cargarla manualmente deberemos teclear: <literal remap="tt">insmod loop</literal>. 
</para>

<para>
También debemos asegurarnos que en <literal remap="tt">dev</literal> existan los ficheros
especiales de dispositivo <literal remap="tt">loopX</literal>: 
</para>

<para>

<screen>
brw-rw----   1 root     disk       7,   0 Jul  1  1996 /dev/loop0
brw-rw----   1 root     disk       7,   1 Jul  1  1996 /dev/loop1
brw-rw----   1 root     disk       7,   2 Jul  1  1996 /dev/loop2
...
</screen>

</para>

<para>
si no los tiene, créelos con el siguiente bucle:
</para>

<para>

<screen>
for i in 0 1 2 3 4 5 6 7; do mknod /dev/loop$i b 7 $i ; done
</screen>

</para>

<para>
así, para montar una imagen para revisarla, en el directorio
<literal remap="tt">/mnt/imagenesCD</literal> haremos: 
</para>

<para>

<screen>
mount -o loop imagenCD.iso /mnt/imagenesCD
</screen>

</para>

<para>
Una vez hecho esto, acceda al directorio <literal remap="tt">/mnt/imagenesCD</literal> y podrá
ver los contenidos de la imagen. Las imágenes ISO9660 son de sólo lectura,
por lo que no podrá modificarlas de ninguna manera, claro, a menos que
genere otra imagen nueva.
</para>

<para>
Como puede observar no he puesto el comando <literal remap="tt">-t iso9660</literal> para
especificarle que es una imagen ISO9660, ya que automáticamente lo debe
detectar.
</para>

<para>
Si tiene pensado hacer imágenes Joliet, le recomiendo que cargue en el
kernel el soporte para <emphasis remap="it">Joliet</emphasis>, en el menú principal <literal remap="tt">Filesystems</literal>,
activar el soporte para <emphasis remap="it">ISO9660</emphasis> en los kernels <literal remap="tt">2.0.33</literal> en
adelante, y en los superiores a <literal remap="tt">2.0.37</literal>, o <literal remap="tt">2.1.x</literal> o <literal remap="tt">2.2.x</literal>
activar <literal remap="tt">Microsoft Joliet CD-ROM extensions</literal>; y dentro del submenú
<literal remap="tt">Native Language Support</literal> activar <literal remap="tt">Codepage 437</literal>, <literal remap="tt">850</literal> y <literal remap="tt">NLS
ISO 8859-1</literal>.
</para>

<para>
Recomiendo al menos incluir esto como parte del kernel de arranque, aunque
si no le sobra mucha memoria inclúyalos como módulos, que el kernel se
ocupará de cargarlos cuando sea necesario. El resto de <emphasis remap="it">Codepages</emphasis> y
<emphasis remap="it">NLS</emphasis>s recomiendo que los ponga como módulos si decide activarlos,
aunque los más utilizados son los mencionados anteriormente. 
</para>

</sect2>

</sect1>

<sect1>
<title>Nomenclatura de dispositivos SCSI</title>

<para>
Este es un tema para el que convendría que leyera el <emphasis remap="it">SCSI-Howto</emphasis>, pero
como no hay disponible traducción, haré una breve introducción, necesaria
para poder especificar parámetros necesarios al software que usaremos.
</para>

<para>
Básicamente, para lo que necesitamos, hemos de saber de la existencia de
los dispositivos de bloque, <literal remap="tt">/dev/scdX</literal> o <literal remap="tt">/dev/srX</literal>, y los
dispositivos genéricos, <literal remap="tt">/dev/sgX</literal>: 
</para>

<sect2 id="gener">
<title>Dispositivos genéricos  </title>

<para>
En lo que a nosotros atañe, tanto para extraer audio, como para grabar
bajo Linux, el kernel ha de tener activado <literal remap="tt">Generic SCSI Support</literal>, que
proporciona la interfaz <emphasis remap="it">ASPI</emphasis> necesaria. 
</para>

<para>
Pero, ¿de qué manera determina Linux cómo ha de tratar un mismo
dispositivo? dependiendo de a qué fichero de dispositivo le hagamos
referencia; si es un fichero de dispositivo de bloques, lo tratará como
tal, y si es genérico, utilizará comandos <emphasis remap="it">ASPI</emphasis>.
</para>

<para>
El dispositivo genérico de cada unidad conectada al bus SCSI se determina
mediante su ID SCSI, haga <literal remap="tt">cat /proc/scsi/scsi</literal> para ver un listado
de los disponibles en su sistema, por ejemplo:
</para>

<para>

<screen>
Attached devices:
Host: scsi0 Channel: 00 Id: 00 Lun: 00
  Vendor: QUANTUM  Model: FIREBALL1280S    Rev: 630G
  Type:   Direct-Access                    ANSI SCSI revision: 02
Host: scsi0 Channel: 00 Id: 01 Lun: 00
  Vendor: QUANTUM  Model: FIREBALL ST4.3S  Rev: 0F0C
  Type:   Direct-Access                    ANSI SCSI revision: 02
Host: scsi0 Channel: 00 Id: 02 Lun: 00
  Vendor: PIONEER  Model: CD-ROM DR-U06S   Rev: 1.05
  Type:   CD-ROM                           ANSI SCSI revision: 02  
Host: scsi0 Channel: 00 Id: 04 Lun: 00
  Vendor: YAMAHA   Model: CDR102           Rev: 1.01
  Type:   WORM                             ANSI SCSI revision: 02  
</screen>

</para>

<para>
Lo que nos interesa es la línea <literal remap="tt">Host: scsi0 Channel: XX Id: XX Lun: XX</literal> de cada dispositivo; concretamente <literal remap="tt">Id:</literal>.
</para>

<para>
El sistema asigna <emphasis remap="it">dinámicamente</emphasis> dispositivos <literal remap="tt">sgX</literal> por orden de ID 
a los <emphasis remap="bf">presentes en ese mismo instante</emphasis>; en el ejemplo anterior:
</para>

<para>

<screen>
00 ---&#62; /dev/sga
01 ---&#62; /dev/sgb 
02 ---&#62; /dev/sgc
04 ---&#62; /dev/sgd
</screen>

</para>

<para>
cuando decimos <emphasis remap="it">dinámicamente</emphasis>, nos referimos a que si por ejemplo, tiene
una unidad externa magneto óptica, un zip, o similar, en el ID 03, la enciende,
y hace que el kernel reescanee el bus, los dispositivos ahora serían:
</para>

<para>

<screen>
00 ---&#62; /dev/sga
01 ---&#62; /dev/sgb
02 ---&#62; /dev/sgc
03 ---&#62; /dev/sgd
04 ---&#62; /dev/sge
</screen>

</para>

<para>
Ahora, la grabadora sería <literal remap="tt">/dev/sge</literal> en lugar de <literal remap="tt">/dev/sgd</literal>
como antes.
</para>

<para>
Con lo que queremos decir que hay que tener <emphasis remap="bf">mucho cuidado</emphasis> con 
la adición de 
dispositivos SCSI «al vuelo» y el uso de los <literal remap="tt">sgX</literal>.
</para>

</sect2>

<sect2 id="bloque">
<title>Dispositivos de bloque </title>

<para>
En el caso concreto que nos ocupa, nos interesan los dispositivos ROM: 
<literal remap="tt">/dev/scdX</literal> o la nomenclatura nueva, <literal remap="tt">/dev/srX</literal>.
</para>

<para>
Aquí el primer fichero de dispositivo corresponderá al primer CDROM SCSI
(incluyendo grabadoras) SCSI disponible en el sistema, <literal remap="tt">/dev/sr0</literal>,
<literal remap="tt">/dev/sr1</literal> será el segundo, etc; da igual el ID SCSI que tenga, o
en el bus SCSI que esté. 
</para>

</sect2>

<sect2 id="notacion">
<title>Notación <emphasis remap="it">estándar</emphasis> </title>

<para>
En entornos *nix existe cierta notación para identificar dispositivos
SCSI:
</para>

<para>

<screen>
Numero_Bus_SCSI,ID_SCSI_dispositivo,LUN_dispositivo
</screen>

</para>

<para>
El <emphasis remap="it">LUN</emphasis> es un parámetro que siempre va a ser <literal remap="tt">0</literal>, menos en el caso
improbable de que Vd disponga de un cargador de CDs, o un robot cambiador
de magneto-ópticos o de cintas.
</para>

<para>
Por tanto, un dispositivo que tuviese el ID <literal remap="tt">4</literal> en la primera
controladora SCSI del sistema sería el dispositivo SCSI del sistema
<literal remap="tt">0,4,0</literal>. 
</para>

</sect2>

</sect1>

<sect1>
<title>Sistemas de ficheros</title>

<para>
Este apartado está dedicado a explicar algunas cosas para familiarizarle
con la grabación de CDs, de modo que le sea mas fácil y rápido
elaborarlos.
</para>

<para>
Una breve explicación sobre los sistemas de ficheros de los CD-ROMs, para
que pueda elegir cuál es el más conveniente en cada momento o CD: como ya
sabrá, se sigue un estándar para que todos los ordenadores puedan leer los
CD-ROMs sin ningún problema, para eso se creó el ISO9660 que especifica el
estándar.
</para>

<para>
Pero dentro de ese estándar existen algunas variantes, o más concretamente
<emphasis remap="it">extensiones</emphasis>, que permiten ampliar las posibilidades originales del
<emphasis remap="it">ISO9660</emphasis>, como son los nombres largos o incluso sistemas de arranque y
ciertas cosas más. 
</para>

<sect2>
<title>Joliet y Romeo</title>

<para>
Estos sistemas fueron diseñados por Microsoft para su plataforma Windows
95/NT. Permiten sistemas de archivos tipo <emphasis remap="it">VFAT</emphasis> pero con la limitación
de longitud a 64 caracteres, en <emphasis remap="it">Joliet</emphasis>, y de 128 para <emphasis remap="it">Romeo</emphasis>. 
</para>

<para>
Para que Linux sea capaz de ver estos sistemas de ficheros ---por ahora
sólo <emphasis remap="it">Joliet</emphasis>--- Necesita tener dicho soporte en el kernel: hasta el
kernel <literal remap="tt">2.0.34</literal> no lo había, aunque es posible tenerlo gracias a
parches para el kernel que se encuentran en Internet. Estos mismos parches
permiten ver también particiones con FAT32, el sistema de archivos que usa
la <emphasis remap="it">OSR2</emphasis> de Windows 95 que le posibilita tener particiones de hasta 4
TeraBytes, limitación inexistente en el sistema de ficheros de Linux,
<emphasis remap="it">ext2</emphasis>, que desde su aparición soporta precisamente 4 TeraBytes ;) 
</para>

<para>
Para los que estén usando un kernel de la serie <literal remap="tt">2.2.x</literal>, decirles que
tanto el soporte <emphasis remap="it">Joliet</emphasis> como de <emphasis remap="it">FAT32</emphasis> vienen «de serie», y no
tienen más que compilar o cargar módulos cuando se necesite si el kernel
no los carga automáticamente. 
</para>

</sect2>

<sect2>
<title>Rock Ridge (High Sierra)</title>

<para>
Esta extensión se ideó para la plataforma UNIX, por lo que recoge una
serie de características y ventajas de las que nos podemos beneficiar más
que con los otros.
</para>

<para>
La primera ventaja es la de poder tener un sistema de ficheros con
atributos propios del UNIX en él, es decir, puede haber archivos
ejecutables, de acceso restringido a un usuario, enlaces simbólicos y
demás aspectos típicos de un sistema de archivos UNIX, en el CD. Otra de
las ventajas es que podemos tener nombres de hasta 128 caracteres, a
diferencia del Joliet. 
</para>

<para>
Por otra parte hay un sistema de compatibilidad que permite a otros
sistemas operativos ver nombres de hasta 32 caracteres; no es mucho, pero
de algo sirve. Para aquellos que no ven este sistema de ficheros tenemos
la posibilidad de crear unas tablas de transcripción en forma de ficheros
llamados <literal remap="tt">TRANS.TBL</literal>, que aparecerán en cada directorio del CD,
transcribiendo el nombre visible por el que de verdad se encuentra en él. 
</para>

<para>
En algunos casos puede ayudar, pero unas veces por fallo del sistema
operativo foráneo, otras por sus controladores, la transcripción no
funciona muy bien, llegando incluso al reseteo sin previo aviso. 
</para>

</sect2>

<sect2>
<title>HFS (Hierarchical Filesystem)</title>

<para>
No sé mucho sobre este sistema de ficheros, sé que es el que utilizan los
Macintosh y es incompatible con el de los PC, por lo menos windows no sabe
lo que es. Como es habitual Linux se adapta y por supuesto hay un parche
para el kernel para ver este tipo de sistema de ficheros y también hay un
programa para crear imágenes con este sistema de ficheros para que podamos
grabar CDs a nuestros amigos los del mac.
</para>

<para>
Sobre las características de este sistema de ficheros no puedo decir nada,
puesto que de momento no las sé. Si alguien conoce las características de
este sistema por favor, envíemelas a mi dirección de correo y amablemente
le incluiré como colaborador.
</para>

</sect2>

<sect2>
<title>UDF (Universal Disk Format)</title>

<para>
Este es el sistema de archivos que usan los DVD y también se puede usar en
los CD-ROM normales, de hecho el Adaptec DirectCD usa este sistema de
ficheros. Las características son muy interesantes, hasta 256 caracteres
en ASCII y 128 en unicodes, posibilidad de grabar los discos en modo
<emphasis remap="it">packet writing</emphasis>, lo cual elimina la posibilidad de un <emphasis remap="it">buffer
underrun</emphasis> (muy común cuando no llegan los datos de forma constante al CD y
acabamos por tirarlo a la basura). Es el sistema de ficheros que acabará
por estandarizarse. En Linux este sistema de ficheros aun está algo verde,
aunque ya se ha conseguido leer discos grabados con DirectCD con ciertas
limitaciones. 
</para>

<para>
Hasta la fecha el parche para el kernel de Linux soporta hasta la versión
<emphasis remap="it">1.5</emphasis> del sistema <emphasis remap="it">UDF</emphasis> .
</para>

<para>
Para más información, consulte estas páginas web:  <literal remap="tt"><ulink
url="http://www.osta.org"
>http://www.osta.org</ulink
></literal> para obtener
toda la información sobre el sistema UDF y <literal remap="tt"><ulink
url="http://trylinux.com/projects/udf"
>http://trylinux.com/projects/udf</ulink
></literal> desde donde podemos acceder
a los parches para que el kernel vea este sistema de ficheros y no solo
eso, también hay utilidades para crear CDs con el sistema UDF. 
</para>

<para>
Lo que todavía no he conseguido es copiar un sistema UDF a mi regrabable y
poder grabar en él. Si alguien sabe cómo hacerlo, por favor, me lo
comunique con explicaciones claras, si no es mucha molestia. 
</para>

</sect2>

<sect2>
<title>EXT2 (Extended Filesystem II)</title>

<para>
Sí, en efecto, <emphasis remap="bf">no</emphasis> se trata de un formato de ficheros típico de CDRoms,
lo cual no significa que no pueda hacerse.
</para>

<para>
Consulte la sección <xref linkend="mke2fs"/>.
</para>

</sect2>

<sect2>
<title>El Torito</title>

<para>
El nombre en castellano puede llevar a confusiones pero es el nombre que se
le ha puesto al sistema para incluir un sistema de arranque en el CD.
La explicación de cómo hacer un CD arrancable con este sistema se describe
en la sección del <xref linkend="mkisofs"/>
</para>

</sect2>

</sect1>

<sect1>
<title>Programas necesarios para grabar</title>

<para>
Casi todos los programas que aquí vamos a mencionar pueden obtenerse de
<literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/utils/disk-management/"
>ftp://sunsite.unc.edu/pub/Linux/utils/disk-management/</ulink
></literal>; no
obstante, es posible que no estén las últimas versiones de desarrollo, por
ello procuro además dar en la sección de cada uno la dirección origen. 
</para>

<para>
Aquí hago una descripción de los programas que vamos a necesitar para
elaborar nuestros propios CDs, con ellos haremos las imágenes y las
grabaremos; podremos comprobar la diversidad que hay y las ventajas que
nos proporcionan.
</para>

<para>
Sólo voy a describir las últimas versiones de estos programas, que aunque
en algunos casos están en fase alpha o de desarrollo (sólo algunos)
funcionan perfectamente.
</para>

<para>
En el caso concreto de <literal remap="tt">cdrecord</literal>, resulta imprescindible para poder
usar grabadoras IDE, IDE-ATAPI de puerto paralelo y las regrabables, al
ser el único que de momento las soporta. 
</para>

<sect2>
<title>Programas para creación de las imágenes</title>

<para>
La parte más importante es hacer una imagen, pero ¿porqué hay que hacer
una imagen? Muy sencillo, la imagen es el <emphasis remap="it">molde</emphasis> con el que se crea el
futuro CD; y no sólo eso, la imagen nos permite comprobar que el CD va a
salir como nosotros queremos, pudiendo evitar errores y ciertas cosas más,
difícilmente detectables en el momento de la grabación si la generamos al
tiempo de grabar.
</para>

<para>
Además, podemos montar las imágenes para comprobar cómo han quedado, como
se explica en el apartado <xref linkend="otraskernel"/>
</para>

<para>
Sí, ya lo sé, en windows puedo hacer CDs <emphasis remap="it">perfectamente</emphasis> sin necesidad
de hacer imágenes, si continúa leyendo, luego explico cómo podrá hacer CDs
sin necesidad de hacer imágenes. 
</para>

<sect3 id="mkisofs">
<title><literal remap="tt">mkisofs</literal>
</title>

<para>
Puede obtener este programa de <literal remap="tt"><ulink
url="ftp://tsx-11.mit.edu/pub/linux/packages/mkisofs"
>ftp://tsx-11.mit.edu/pub/linux/packages/mkisofs</ulink
></literal>. 
</para>

<para>
La última versión estable disponible es la <literal remap="tt">1.11</literal> y la de desarrollo
es la <literal remap="tt">1.12b5</literal>.
</para>

<para>
Este es el principal programa que usaremos para crear nuestras imágenes,
ya que está hecho especialmente para hacer imágenes ISO9660 a las que
añadir extensiones Rock Ridge, o imágenes Joliet (sólo versiones
<literal remap="tt">1.12</literal>).
</para>

<para>
Puede también combinar las dos, es decir, en un solo CD tener los dos
sistemas, <emphasis remap="it">Rock Ridge</emphasis> y <emphasis remap="it">Joliet</emphasis>, de tal forma que el CD sea
portable entre los sistemas operativos que usen uno u otro, manteniendo
los nombres largos (sólo versión <literal remap="tt">1.12</literal>).
</para>

<para>
Esta explicación está basada en la versión <literal remap="tt">1.12a5</literal>, de la cual sólo
voy a indicar los parámetros que son más utilizados.
</para>

<para>
La sintaxis de este programa y su uso se explica a continuación: 
</para>

<para>
<variablelist>

<varlistentry>
<term>-a o -all-file</term>
<listitem>
<para>
Este parámetro indica que queremos incluir todos los
archivos que se encuentran en el directorio especificado, ya que el
programa no incluye por defecto los archivos que contengan caracteres
<literal remap="tt">&tilde;</literal> y <literal remap="tt">#</literal> que son generalmente copias de seguridad creados
por la mayoría de editores *nix.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-A o -appid</term>
<listitem>
<para>
Este parámetro indica un comentario sobre la aplicación
a la que va dirigido el CD, puede ser definido en un archivo
<literal remap="tt">.mkisofsrc</literal> que se puede crear en el directorio raíz de cada usuario,
con el que poder definir por defecto varias cosas. En concreto este
parámetro se identifica como <literal remap="tt">APPI=</literal> especificando lo que quiera poner
mientras tenga una extensión no superior a 128 caracteres. En versiones
anteriores a la <literal remap="tt">1.12</literal> se debe especificar en la línea de comandos con
el comentario entre comillas. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-b o -eltorito-boot</term>
<listitem>
<para>
Este parámetro sirve para indicarle el nombre y
la ruta del archivo que contiene la imagen de arranque que será usada para
hacer un CD arrancable según el estándar <emphasis remap="it">El Torito</emphasis>. De esta forma
creamos un CD arrancable para aquellas BIOS que acepten arrancar desde
CD-ROM. La imagen debe tener un tamaño de 720, 1.44 o 2.88 Mbs, la de un
diskette de arranque, que contenga por ejemplo el LILO. Ojo que esto no
funciona muy bien con CDs SCSI aunque la controladora SCSI lo soporte
teóricamente, por culpa generalmente de la controladora, no del estándar.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-c o -eltorito-catalog</term>
<listitem>
<para>
Con este parámetro, que está ligado al
anterior para hacer CDs arrancable, se especifica dónde se creará en
el CDROM el archivo del catálogo para el arranque del CD-ROM. Por defecto
lo crea en el directorio raíz de la imagen
</para>
</listitem></varlistentry>
<varlistentry>
<term>-f o -follow-links</term>
<listitem>
<para>
Con este parámetro hacemos que los enlaces que se
encuentren dentro del directorio <emphasis remap="it">maestro</emphasis> especificado no sean tomados
como tales, sino como ficheros o directorios reales, lo cual nos permite
incluir en el CD cosas que no estén en el mismo sistema de ficheros donde
tenemos el <emphasis remap="it">master</emphasis>, es decir, le especificamos que <emphasis remap="it">siga</emphasis> los
enlaces que contenga.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-help</term>
<listitem>
<para>
Nos muestra la ayuda del programa, muy útil si no nos
acordamos de alguno de los parámetros.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-i</term>
<listitem>
<para>
Sirve para añadir archivos que no estén en el directorio o
subdirectorio que hayamos indicado para hacer la imagen, para su adición a
la imagen del CD. Esta opción está temporalmente deshabilitada, y parece
ser que da problemas, por lo que está en espera de ser reescrita. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-J</term>
<listitem>
<para>
Gracias a esta opción podremos crear CDs con sistema de ficheros
Joliet. No incluida en versiones anteriores a la <literal remap="tt">1.12</literal>. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-l</term>
<listitem>
<para>
Gracias a este parámetro podremos establecer el modo de
compatibilidad de ficheros de 32 caracteres para aquellos sistemas que no
aceptan la longitud de los ficheros para los que está grabado el CD. Usar
con cuidado.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-m o -exclude</term>
<listitem>
<para>
Con este parámetro indicamos un patrón de archivos que
no queramos incluir en el CD, que puedan encontrarse dentro de algún
subdirectorio en la ruta desde la que vamos a hacer la imagen (ficheros
<literal remap="tt">core</literal> etc...) Se pueden usar comodines o nombre completo. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-o o -output</term>
<listitem>
<para>
Con esta opción indicamos el nombre que le queremos dar
al fichero, incluida su ruta, que contendrá la imagen, o el fichero de
dispositivo correspondiente a la partición donde queremos volcarla. 
</para>

<para>
El volcar las imágenes (sólo de datos) a partición es muy recomendable
para equipos lentos; dicha partición no ha de tener formato alguno, por
ello la lectura es más rápida, ocurre como con la partición de swap. 
</para>

<para>
Si utilizamos volcado a partición, conviene «resetearla» antes de generar
una imagen nueva con el comando:
</para>

<para>

<screen>
dd if=/dev/zero of=/dev/sda1
</screen>

</para>

<para>
Suponiendo que <literal remap="tt">sda1</literal> sea donde queremos volcar la imagen;  <emphasis remap="bf">OJO</emphasis>
con especificar una partición equivocada, o se irá a hacer gárgaras...
</para>
</listitem></varlistentry>
<varlistentry>
<term>-p o -preparer</term>
<listitem>
<para>
Este es complementario al parámetro <literal remap="tt">-A</literal>, con él
podremos indicar el autor del CD, Tiene una extensión máxima de 128
caracteres.  Corresponde al parámetro <literal remap="tt">PREP=</literal> en el archivo
<literal remap="tt">.mkisofsrc</literal>. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-print-size</term>
<listitem>
<para>
Muestra por pantalla el tamaño estimado que ocupará la
imagen, sin hacer nada más.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-P o -publisher</term>
<listitem>
<para>
Especifica el editor del CD. Su longitud máxima son
128 caracteres. En el archivo <literal remap="tt">.mkisofsrc</literal> se identifica como
<literal remap="tt">PUBL=</literal>. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-quiet</term>
<listitem>
<para>
No muestra mensajes por pantalla.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-R</term>
<listitem>
<para>
Genera un sistema de ficheros con extensiones Rock Ridge. Esta es
la opción principal para generarlo, manteniendo los permisos tal y como
estén.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-r</term>
<listitem>
<para>
Esta opción es como la anterior pero resetea los permisos de modo
que todos los usuarios puedan acceder al CD por completo. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-T o -translation-table</term>
<listitem>
<para>
Con esta opción generamos los archivos de
transcripción, llamados <literal remap="tt">TRANS.TBL</literal> en cada directorio del CD-ROM, que
contendrán todas las transcripciones de los nombres de fichero para que se
puedan ver por ejemplo en un sistema DOS (de tipo de nombres de fichero
8+3) y con su longitud correspondiente en el sistema Rock Ridge. Cuando
utilizamos la opción <literal remap="tt">-l</literal> los archivos tendrán nombres de 32 caracteres
y no de 8+3. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-v</term>
<listitem>
<para>
Nos muestra la ayuda y la versión del programa. Y mientras se
genera la imagen nos va mostrando el porcentaje de la imagen generada y
una estimación de tiempo para terminar. Muy útil.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-V</term>
<listitem>
<para>
Esta opción nos permite darle un nombre de volumen al CD para
identificarlo. En el archivo <literal remap="tt">.mkisofsrc</literal> se especifica con el
parámetro <literal remap="tt">VOLI=</literal> con una extensión máxima de 32 caracteres.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-x</term>
<listitem>
<para>
Esta opción nos permite excluir un directorio específico que se
encuentre dentro de la ruta de origen. Puede excluir hasta un máximo de
1000 directorios, ojo que hay que especificar el parámetro antes de cada
directorio, tantas veces como directorios a excluir haya: 
</para>

<para>

<screen>
mkisofs ... -x estedirectoriono -x yestetampoco -x nieste
</screen>

</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Estos son los parámetros más utilizados, si quiere más información o más
posibilidades siempre puede consultar la página del manual. Ahora unos
pocos ejemplos de cómo funcionan algunos parámetros: 
</para>

<para>
Para generar un sistema de ficheros Rock Ridge simplemente tenemos hacer
esto:
</para>

<para>

<screen>
mkisofs -a -r -T -o /cd/imagen.iso /ficheros
</screen>

</para>

<para>
Aquí se indica un sistema de ficheros Rock Ridge al que se le incluyen
todos los archivos que se encuentren en el directorio <literal remap="tt">/ficheros</literal>,
generando archivos <literal remap="tt">TRANS.TBL</literal>, para el archivo de imagen
<literal remap="tt">/cd/imagen.iso</literal>.
</para>

<para>
Para que al crear la imagen se establezca el nombre de volumen, la
identificación, el editor y la aplicación del CD, hay dos métodos, uno
consiste en crear un archivo llamado <literal remap="tt">.mkisofsrc</literal> en nuestro directorio
personal.  Recuerdo que este archivo sólo sirve para la versión <literal remap="tt">1.12</literal>,
con una sintaxis como ésta:
</para>

<para>
<variablelist>

<varlistentry>
<term>VOLI=</term>
<listitem>
<para>
El nombre de volumen.
</para>
</listitem></varlistentry>
<varlistentry>
<term>PUBL=</term>
<listitem>
<para>
Cualquier cosa que quiera poner, normalmente un pequeña
descripción del CD.
</para>
</listitem></varlistentry>
<varlistentry>
<term>PREP=</term>
<listitem>
<para>
Aquí puede poner sus datos o cualquier cosa para identificar el
CD como suyo. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>APPI=</term>
<listitem>
<para>
Aquí puede poner una descripción del objetivo de este CD o su
destino. 
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
O bien puede especificarlo en la línea de comandos así:
</para>

<para>

<screen>
mkisofs -a -R -l -T -V "Volumen" -P "descripción CD" -p  "preparador" \
 -A "Aplicación" -o imagen.iso /ficheros
</screen>

</para>

<para>
Este único comando se ha introducido en dos líneas, detrás del carácter
<literal remap="tt">&bsol;</literal> hay que teclear <literal remap="tt">Enter</literal>, y teclear el resto. Se ha hecho
así por motivos de formato de este documento.
</para>

<para>
En él podemos observar, aparte de cómo poner el nombre de volumen al CD y
otras cosas, que estamos haciendo un CD con el modo de compatibilidad para
otros sistemas de 32 caracteres, tomando los permisos y la identificación
que tiene cada archivo en el disco. 
</para>

<para>
Un ejemplo de cómo crear un sistema de ficheros con Joliet es:
</para>

<para>

<screen>
mkisofs -a -J -f -m '*.o' -m core -x /master/excluir -o /cd/imagen.iso /master
</screen>

</para>

<para>
En este sistema de ficheros Joliet hemos excluido todos los archivos que
correspondan con la descripción <literal remap="tt">*.o</literal> y <literal remap="tt">core</literal> con la opción
<literal remap="tt">-m</literal>, la opción <literal remap="tt">-f</literal> indica que los enlaces que se encuentren serán
tomados como los archivos o directorios a los que apuntan. Por último,
excluimos el directorio <literal remap="tt">excluir</literal> que se encuentra en la ruta de origen
desde donde queremos hacer la imagen.
</para>

<para>
Y por último un sistema de ficheros con Rock Ridge y Joliet, que recuerdo
que sólo se puede hacer en la versión <literal remap="tt">1.12</literal>: 
</para>

<para>

<screen>
mkisofs -a -J -f -R -m '*.o' -m core -x /master/excluir -o /cd/imagen.iso /master
</screen>

</para>

<para>
Para hacer un CD arrancable (para arrancar con él es necesario que la BIOS
soporte arranque desde unidades CD-ROM) necesitamos la imagen de un
disquete de arranque de 720KB, 1.44MB o 2.88MB, de MS-DOS o Linux según
queramos, que podemos encontrar en varios sitios ya hechos o hacernos
nosotros mismos. Una vez tenemos la imagen, la ponemos dentro del
directorio en donde se encuentran los archivos desde los que vamos a hacer
la imagen y procedemos a lo siguiente:
</para>

<para>

<screen>
mkisofs -a -b /cdboot/eltorito.img -c /cdboot/catalogo -R -T -o imagen.iso /master
</screen>

</para>

<para>
Nótese que a los parámetros <literal remap="tt">-b</literal> y <literal remap="tt">-c</literal> le especificamos lo que
parece un path absoluto, pero el directorio <literal remap="tt">/cdboot</literal> no se
encuentra en el directorio raíz de su disco duro, sino que en realidad es
un subdirectorio de <literal remap="tt">/master</literal>;  esto es así porque <literal remap="tt">mkisofs</literal>
para este parámetro se sitúa como si estuviera ya dentro del CD.
</para>

</sect3>

<sect3>
<title><literal remap="tt">mkhfs</literal></title>

<para>
Puede obtener este programa de <literal remap="tt"><ulink
url="ftp://ftp.ge.ucl.ac.uk/pub/mkhfs"
>ftp://ftp.ge.ucl.ac.uk/pub/mkhfs</ulink
></literal>. 
</para>

<para>
Es su homólogo para el sistema de ficheros de los mac, HFS, no lo he
llegado a probar todavía pero seguro que funciona bien. Su uso es muy
sencillo y no tiene mucha complicación. 
</para>

</sect3>

<sect3>
<title><literal remap="tt">mkhybrid</literal></title>

<para>
Puede obtener este programa de <literal remap="tt"><ulink
url="ftp://ftp.ge.ucl.ac.uk/pub/mkhfs"
>ftp://ftp.ge.ucl.ac.uk/pub/mkhfs</ulink
></literal>. 
</para>

<para>
Es la mezcla de los dos anteriores, la ultima versión usa código del
<literal remap="tt">mkisofs 1.12</literal> para mejor soporte de Joliet. La ayuda parece
exactamente la del <literal remap="tt">mkisofs</literal>, salvo que incluye las siguientes opciones
para añadir el sistema de ficheros de los mac: 
</para>

<para>
<variablelist>

<varlistentry>
<term>-g o -apple</term>
<listitem>
<para>
Añade la extensión ISO9660 de Apple, para la
compatibilidad con el estándar.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-h o -hfs</term>
<listitem>
<para>
Crea el sistema HFS híbrido para la extensión ISO9660. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-probe</term>
<listitem>
<para>
Prueba todos los archivos para el sistema Unix/HFS. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-mac-name</term>
<listitem>
<para>
Crea todos los nombres según el estilo de los mac para
ISO9660/Joliet/Rock Ridge
</para>
</listitem></varlistentry>
<varlistentry>
<term>-no-mac-name</term>
<listitem>
<para>
Evita lo anterior para los archivos Unix/Mac
</para>
</listitem></varlistentry>
</variablelist>
</para>

</sect3>

<sect3 id="mke2fs">
<title><literal remap="tt">mke2fs</literal>
</title>

<para>
¿Cómo? ¡Pero si este programa sirve para crear sistemas de ficheros en el
formato nativo de Linux, el <literal remap="tt">ext2</literal>!
</para>

<para>
Pues sí, es posible crear CD-Roms en formato <literal remap="tt">ext2</literal>, que por supuesto
no podrán leerse en sistemas que no dispongan de algún tipo de soporte
para leer este tipo de sistema de archivos, básicamente Linux. 
</para>

<para>
Su utilidad dependerá de la creatividad de cada uno ;)
</para>

<para>
Para ello, hay que seguir el siguiente procedimiento:
</para>

<para>

<orderedlist>
<listitem>

<para>
Primero hay que calcular el tamaño máximo que podemos usar en una
imagen para aprovechar la mayor cantidad de datos en el CD es fácil y es
una operación sencilla en la que intervienen dos programas y en la que no
hay ni que sacar la calculadora.

Primero utilizamos el <literal remap="tt">cdrecord</literal> en su versión de desarrollo <literal remap="tt">1.8</literal>
de la siguiente forma: 


<screen>
# cdrecord -v dev=3,0 -atip
Cdrecord release 1.8a29 Copyright (C) 1995-1999 Jörg Schilling
TOC Type: 1 = CD-ROM
scsidev: '3,0'
scsibus: 0 target: 3 lun: 0
Using libscg version 'schily-0.1'
atapi: 0
Device type    : Removable CD-ROM
Version        : 2
Response Format: 2
Capabilities   :
Vendor_info    : 'YAMAHA  '
Identifikation : 'CRW4260         '
Revision       : '1.0q'
Device seems to be: Generic mmc CD-RW.
Using generic SCSI-3/mmc CD-R driver (mmc_cdr).
Driver flags   : SWABAUDIO
Drive buf size : 1176000 = 1148 KB
Current Secsize: 512
ATIP info from disk:
  Indicated writing power: 5
  Is not unrestricted
  Is not erasable
  ATIP start of lead in:  -11324 (97:31/01)
  ATIP start of lead out: 359849 (79:59/74)
Disk type: Long strategy type (Cyanine, AZO or similar)
Manuf. index: 22
Manufacturer: Ritek Co.
</screen>


Una vez obtenida esta información nos fijamos en la siguiente linea:


<screen>
  ATIP start of lead out: 359849 (79:59/74)
</screen>


de la que nos interesa el numero <literal remap="tt">359849</literal> el cual al multiplicarse por
<literal remap="tt">2048</literal> nos dará el tamaño máximo de la imagen que puede ser grabada en
el CD. Si se fijan el tamaño concuerda con un CD 80 minutos que corresponde
exactamente a 702 MegaBytes absolutos del tamaño de la imagen.

</para>
</listitem>
<listitem>

<para>
Crear un fichero imagen vacío; con los datos anteriores:


<screen>
dd if=/dev/zero of=imagen-vacia.ext2 bs=2048 count=359849
</screen>


</para>
</listitem>
<listitem>

<para>
Formatearlo:


<screen>
mke2fs -m 0 -b 2048 imagen-vacia.ext2
</screen>


<literal remap="tt">mke2fs</literal> advertirá de que <literal remap="tt">imagen-vacia.ext2</literal> no es un fichero de
dispositivo de bloque, y le pedirá confirmación:


<screen>
imagen-vacia.ext2 is not a block special device.
Proceed anyway? (y,n) y
</screen>


</para>
</listitem>
<listitem>

<para>
Montarlo, mediante <literal remap="tt">loopback</literal>, en lo que va a ser nuestro
directorio «maestro»: 


<screen>
mount -o loop imagen-vacia.ext2 /mnt/master
</screen>


</para>
</listitem>
<listitem>

<para>
Copiamos a él los ficheros que queramos, si por ejemplo queremos
hacer una réplica de <literal remap="tt">/etc</literal> : 


<screen>
cd /etc
find | cpio -pdamvu /mnt/master
</screen>
 

</para>
</listitem>
<listitem>

<para>
Lo desmontamos, y grabamos normalmente.
</para>
</listitem>

</orderedlist>

</para>

<para>
Si queremos montar un CD-Rom de este tipo, habrá que especificarle a
<literal remap="tt">mount</literal> que el tipo de sistema de ficheros es <literal remap="tt">ext2</literal>, y de sólo
lectura:
</para>

<para>

<screen>
mount -t ext2 -o ro /dev/cdrom /mnt/cdrom
</screen>

</para>

<para>
si queremos incluirlo en <literal remap="tt">/etc/fstab</literal>, habrá que indicar además de
su tipo de sistema de ficheros, y de ser sólo lectura, que no sea
comprobado:
</para>

<para>

<screen>
/dev/cdrom      /mnt/cdrom      ext2    defaults,ro     0 0
</screen>

</para>

<para>
El último <literal remap="tt">0</literal> es el que hace que <literal remap="tt">fsck</literal> no lo compruebe en cada
arranque.
</para>

</sect3>

</sect2>

<sect2 id="audio">
<title>Software de extracción de audio </title>

<para>
<emphasis remap="bf">Aviso</emphasis>: La mayoría de las grabadoras requieren que el orden de palabra
de los ficheros de audio en formato CDDA o PCM raw sea <emphasis remap="it">Big Endian</emphasis>,
salvo las Yamaha, Sony y recientemente las últimas grabadoras que cumplen
el estándar <emphasis remap="it">SCSI-3/MMC</emphasis>, que lo necesitan <emphasis remap="it">Little Endian</emphasis>.
</para>

<para>
Casi todos los programas extractores de CD-Audio extraen por defecto en
<emphasis remap="it">Big Endian</emphasis>. 
</para>

<para>
Si graba ficheros de audio con el orden de palabra equivocado para su
grabadora, cuando intente escuchar ese CD no oirá más que un horripilante
ruido, similar al sonido de una televisión sin sintonizar.
</para>

<para>
Dependiendo del software que utilice para grabar, esto se puede abordar de
dos maneras: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">cdrecord</literal>: Indistintamente de la grabadora que tenga, y del
software de extracción que use, extraiga <emphasis remap="bf">siempre</emphasis> en <emphasis remap="it">Big Endian</emphasis>,
el formato por defecto. 

<literal remap="tt">cdrecord</literal> sabe qué formato necesita cada grabadora, e invertirá el
orden de palabra si es necesario;  notará si lo invierte porque aparecerá
la palabra <literal remap="tt">swab</literal> en el listado de pistas de audio a grabar. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">cdwrite</literal>: Aquí no hay error posible, ha de saber qué orden
necesita su grabadora, y tener los ficheros CDDA con el orden apropiado. 
</para>
</listitem>

</itemizedlist>

</para>

<para>
Otro concepto, que aunque es mencionado más veces posteriormente a lo
largo del documento, quiero recalcar, y que necesitará especialmente con
los extractores, es el del dispositivo genérico SCSI, que es explicado en
la sección <xref linkend="gener"/>.
</para>

<sect3>
<title><literal remap="tt">readcdda</literal></title>

<para>
Este programa es un poco difícil de encontrar, ya que las versiones
disponibles son modificaciones o <emphasis remap="it">portings</emphasis> del original a Linux.
</para>

<para>
Uno de los paquetes que lo trae modificado es el X-CDRoast, que es de
donde lo he obtenido, ver sección <xref linkend="xcdroast"/>.
</para>

<para>
No hay página man disponible, y tampoco certifico que los comandos que
aquí explico correspondan a la versión que Vd. pueda conseguir; no
obstante lo expongo aquí por su excepcional calidad y fiabilidad. Eso sí,
sólo funciona con dispositivos SCSI. 
</para>

<para>
Su sintaxis es un poco pesada, pero como decía antes, vale la pena. 
</para>

<para>
El orden de palabra de los ficheros cdda creados con <literal remap="tt">readcdda</literal> es
<emphasis remap="it">Big Endian</emphasis> por defecto.
</para>

<para>
<variablelist>

<varlistentry>
<term>-D dispositivo</term>
<listitem>
<para>
Para especificar el dispositivo genérico de la unidad
con la que vamos a extraer. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-B dispositivo</term>
<listitem>
<para>
Dispositivo de bloque de la unidad con la que vamos a
extraer, son válidos tanto dispositivos <literal remap="tt">/dev/srX</literal> como
<literal remap="tt">/dev/scdX</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-t</term>
<listitem>
<para>
Desde qué pista a extraer
</para>
</listitem></varlistentry>
<varlistentry>
<term>-z</term>
<listitem>
<para>
Hasta qué pista extraer (inclusive)
</para>
</listitem></varlistentry>
<varlistentry>
<term>-o</term>
<listitem>
<para>
desplazamiento del principio de la pista
</para>
</listitem></varlistentry>
<varlistentry>
<term>-s</term>
<listitem>
<para>
desplazamiento del final de la pista
</para>
</listitem></varlistentry>
<varlistentry>
<term>-d</term>
<listitem>
<para>
Tiempo total de grabación
</para>
</listitem></varlistentry>
<varlistentry>
<term>-S</term>
<listitem>
<para>
Velocidad de extracción.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-v</term>
<listitem>
<para>
imprimir información sobre el CD.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-x</term>
<listitem>
<para>
Formato de salida <emphasis remap="it">Little Endian</emphasis>
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Así que un ejemplo, utilizando el CDROM SCSI que estuviera en el ID SCSI
<literal remap="tt">3</literal>, que fuese el primer CDROM disponible, extrayendo de la pista
<literal remap="tt">1</literal> a la <literal remap="tt">15</literal>, a velocidad 6x en un solo fichero <literal remap="tt">.cdr</literal>, sería: 
</para>

<para>

<screen>
readcdda -D /dev/sgd -B /dev/scd0 -t 1 -z 15 -o 0 -s 0 -S 6 audio.cdr
</screen>

</para>

<para>
Esto es un poco latoso si queremos que cada pista tenga su fichero, para
ello podemos utilizar un bucle: 
</para>

<para>

<screen>
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
readcdda -D /dev/sgd -B /dev/scd0 -t $i -z $i -o 0 -s 0 -S 6 audio.$i.cdr ;
done
</screen>

</para>

</sect3>

<sect3>
<title><literal remap="tt">cdda2wav</literal></title>

<para>
Este programa es más reciente, y permite extraer de CDROMs IDE si éstos
soportan extracción. Puede obtenerlo de <literal remap="tt"><ulink
url="ftp://ftp.gwdg.de/pub/linux/misc/cdda2wav/"
>ftp://ftp.gwdg.de/pub/linux/misc/cdda2wav/</ulink
></literal>. También se puede
encontrar incluido en el mismo paquete de las últimas versiones de
<literal remap="tt">cdrecord</literal>. 
</para>

<para>
Comentaré sólo las opciones más habituales:
</para>

<para>
<variablelist>

<varlistentry>
<term>-D</term>
<listitem>
<para>
Dispositivo genérico de la unidad lectora; <literal remap="tt">/dev/sgX</literal> o 
<literal remap="tt">0,1,0</literal> si es SCSI; si es IDE, con el fichero de dispositivo de bloque
correspondiente: <literal remap="tt">/dev/hdb</literal> por ejemplo para un CD esclavo del bus
primario, o el enlace simbólico que apunte al apropiado. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-A</term>
<listitem>
<para>
Dispositivo auxiliar: será un <literal remap="tt">/dev/scdX</literal> si el lector es
SCSI o el mismo que le especificamos en <literal remap="tt">-D</literal> si es IDE. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-I</term>
<listitem>
<para>
Tipo de interfaz; <literal remap="tt">generic_scsi</literal> para dispositivos SCSI o 
<literal remap="tt">cooked_ioctl</literal> para IDE.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-x</term>
<listitem>
<para>
Extracción a calidad CD: muestreo a 44100Hz, 16 bits estéreo. Esta
es la opción por defecto, asi que si quiere estas opciones no tendrá que
volver a ponerlas.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-t primera+ultima</term>
<listitem>
<para>
Especificamos la pista o rango de pistas a
extraer.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-O</term>
<listitem>
<para>
Formato del fichero de salida, opciones validas útiles pueden ser
<literal remap="tt">raw</literal> para formato cdr (CDDA)  o <literal remap="tt">wav</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-E</term>
<listitem>
<para>
Orden de la palabra binaria: <literal remap="tt">big</literal> para <emphasis remap="it">Big Endian</emphasis>,
<literal remap="tt">little</literal> para <emphasis remap="it">Little Endian</emphasis>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-B</term>
<listitem>
<para>
Extraer cada pista a un fichero separado.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-S número</term>
<listitem>
<para>
Velocidad de extracción.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-P</term>
<listitem>
<para>
Desactivar overlap (utilizar si se obtienen mensajes de error
tipo <literal remap="tt">increase overlap (X) or decrease SYNC_SIZE (X)</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-H</term>
<listitem>
<para>
No crear ficheros informativos (<literal remap="tt">.inf</literal>) por cada fichero de
audio creado.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-e</term>
<listitem>
<para>
Permite la salida directa al dispositivo de audio del ordenador.
Por defecto <emphasis remap="it">/dev/dsp</emphasis>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-K dispositivo</term>
<listitem>
<para>
Cambia el dispositivo de audio por defecto
<emphasis remap="it">/dev/dsp</emphasis> por que se le especifique.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-q</term>
<listitem>
<para>
No muesta información alguna mientras se realiza el proceso de
extracción.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Supongamos que usamos un lector SCSI, que tiene el ID 2 del bus SCSI, que
queremos extraer las pistas de la 3 a la 8, en formato CDDA, <emphasis remap="it">Big
Endian</emphasis> (por defecto), en ficheros con el patrón <literal remap="tt">audio_*.cdr</literal>
separados, con sus correspondientes ficheros informativos:
</para>

<para>

<screen>
cdda2wav -D /dev/sgb -A /dev/scd0 -I generic_scsi -x -t 3+8 -B -O cdr -S 10 audio
</screen>

</para>

<para>
tambien se puede escribir de forma más abreviada de la siguiente forma:
</para>

<para>

<screen>
cdda2wav -D 0,2,0 -I generic_scsi -x -t 3+8 -B -O cdr
</screen>

</para>

<para>
Si extraemos las pistas con la opción <literal remap="tt">-O wav</literal> por defecto serán
<emphasis remap="it">Little Endian</emphasis>.
</para>

<para>
En la versión <literal remap="tt">1.0</literal> de <emphasis remap="it">cdda2wav</emphasis> y en adelante para extraer las
pistas de audio directamente, aunque hayan otros tipos de pistas en el
disco, como por ejemplo una de datos al principio o al final, se ha de
poner tan sólo esto:
</para>

<para>

<screen>
cdda2wav -D 0,2,0 -I generic_scsi -B
</screen>

</para>

<para>
al mismo tiempo, esto nos puede servir de ejemplo de como se pueden
extraer pistas para la sección <xref linkend="cdrecorddao"/>.
</para>

<para>
Existe una variante del <literal remap="tt">cdda2wav</literal>, llamada <literal remap="tt">cdparanoia</literal>, de
rendimiento muchísimo menor, pero que como su nombre indica, es muy
<emphasis remap="it">paranoica</emphasis> con la calidad de las pistas extraídas, puede resultar útil
con CDs muy estropeados. 
</para>

</sect3>

</sect2>

<sect2>
<title>Software de grabación</title>

<sect3 id="cdrecord">
<title><literal remap="tt">cdrecord</literal>
</title>

<para>
La página principal de <literal remap="tt">cdrecord</literal> es 
  <literal remap="tt"><ulink
url="http://www.fokus.gmd.de/research/cc/glone/employees/joerg.schilling/private/cdrecord.html"
>http://www.fokus.gmd.de/research/cc/glone/employees/joerg.schilling/private/cdrecord.html</ulink
></literal>
</para>

<para>
Puede obtenerlo por FTP de <literal remap="tt"><ulink
url="ftp://ftp.fokus.gmd.de/pub/unix/cdrecord/"
>ftp://ftp.fokus.gmd.de/pub/unix/cdrecord/</ulink
></literal>. 
</para>

<para>
Este programa es más avanzado y actual que <literal remap="tt">cdwrite</literal>, al estar en
desarrollo e incorporar soporte para las novedades del mercado actual, a
pesar de no soportar algunas unidades antiguas que sí lo hace
<literal remap="tt">cdwrite</literal>.
</para>

<para>
La mayor ventaja de este programa es que funciona perfectamente con las
grabadoras IDE (con emulación SCSI activada, por supuesto) y SCSI,
incluyendo más opciones como el soporte para regrabables y sus comandos
específicos, como borrar un CD-RW, una partición, etc.
</para>

<para>
Permite visualizar las tablas de contenido (<emphasis remap="it">TOC</emphasis>, <emphasis remap="it">Table Of
Contents</emphasis>), que es donde se almacena la información sobre las pistas y el
tamaño de las mismas.
</para>

<para>
Esta tabla la genera el programa y se tiene que grabar para que se pueda
leer el CD, ya sea cuando haga un CD multisesión o al hacer un CD normal o
de CD-Audio.
</para>

<para>
También puede grabar pistas CDI, en modo normal de datos <emphasis remap="it">data 1</emphasis> y
<emphasis remap="it">data 2</emphasis>, <emphasis remap="it">multisesión xa1</emphasis> y <emphasis remap="it">xa2</emphasis> de datos, y audio. 
</para>

<para>
Otra función muy útil es que puede realizar ciertas pruebas a la unidad
para comprobar sus capacidades y compatibilidad, etc.
</para>

<para>
Los comandos que más nos pueden interesar se detallan a continuación:
</para>

<para>
<variablelist>

<varlistentry>
<term>-version</term>
<listitem>
<para>
Muestra la versión del programa. Recomendada la versión
<literal remap="tt">1.6.1 final</literal>, las que llevan <literal remap="tt">a</literal> despues del número son alphas y no
es recomendable usarlas. Para unidades tanto IDE como SCSI se recomienda la
<literal remap="tt">1.8aXX</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-v</term>
<listitem>
<para>
Muestra información mientras se ejecuta el programa para conocer
el estado de la grabación (Muy recomendable ya que indica los Mb grabados
y el porcentaje de llenado del buffer). 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-V</term>
<listitem>
<para>
Muestra los comandos SCSI mientras se ejecuta el programa. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-debug</term>
<listitem>
<para>
Muestra mensajes para encontrar posibles fallos.
</para>
</listitem></varlistentry>
<varlistentry>
<term>dev=destino</term>
<listitem>
<para>
Especifica la situación de la grabadora en el sistema
SCSI. Hay que especificarle el bus scsi, el ID SCSI del dispositivo, y el
<emphasis remap="it">LUN</emphasis> SCSI (<emphasis remap="it">Logical Unit Number</emphasis>, valor variable sólo si se emplea
por ejemplo un lector múltiple de CDs, en donde <literal remap="tt">0</literal> identificaría a la
primera bandeja, <literal remap="tt">1</literal> a la segunda, etc).
</para>

<para>
Un ejemplo frecuente sería <literal remap="tt">0,4,0</literal> para el primer bus SCSI, el ID SCSI
<literal remap="tt">4</literal> y el LUN de todo dispositivo no múltiple, <literal remap="tt">0</literal>.  Si usamos la
emulación SCSI o una unidad de puerto paralelo, siempre será <literal remap="tt">0,0,0</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-dummy</term>
<listitem>
<para>
Con este parámetro indicamos que vamos a hacer un test de la
unidad y del sistema, simulando una grabación para comprobar si se realiza
adecuadamente. Durante este test el láser de la grabadora está desactivado
por lo que no correremos el riesgo de perder un CD.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-multi</term>
<listitem>
<para>
Esta opción es para indicar que vamos a hacer un CD
multisesión, es decir con varias pistas de datos. Este parámetro no puede
ser usado en unidades Sony ya que no llevan soporte hardware para CD-ROM
modo <emphasis remap="it">XA 2</emphasis> por lo que se deberá de usar el parámetro <literal remap="tt">-data</literal> para
este fin.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-msinfo</term>
<listitem>
<para>
Esta opción nos permite ver la información que hay grabada
en un CD multisesión o con al menos una pista, mientras el CD no se haya
cerrado. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-toc</term>
<listitem>
<para>
Muestra información sobre la tabla de contenidos del CD, este
parámetro puede ser usado tanto en las grabadoras como en los lectores.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-fix</term>
<listitem>
<para>
Esta opción es para cerrar un CD que no se haya cerrado antes,
si después de haber grabado los datos no se ha escrito la tabla de
contenidos. De momento esto no funciona con las unidades TEAC.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-nofix</term>
<listitem>
<para>
Esta opción, usada en la línea de comandos es para que al
grabar un CD no se escriba la tabla de contenidos, para que no lo
<emphasis remap="it">cierre</emphasis>. Puede ser útil para grabar un CD por pasos o para grabar un
CD-Audio ya que hay lectores de CD-Audio que pueden leer CDs sin cerrar,
siempre y cuando no contengan además datos. Los CDs de datos sin cerrar no
pueden ser usados por unidades lectoras. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-load</term>
<listitem>
<para>
Esta opción es para cerrar la bandeja, luego sale del
programa. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-eject</term>
<listitem>
<para>
Esta opción permite expulsar el CD una vez grabado, hay
unidades como las Philips o las Yamaha que deben hacer esto. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>speed=X</term>
<listitem>
<para>
Esta opción es para indicarle a la unidad la velocidad a la
que debe grabar. El número especifica el multiplicador de 150Kb/s para
datos y 172Kb/s para audio. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>blank=opcion</term>
<listitem>
<para>
Esta opción borra un CD-RW y sale, o bien borra antes
de continuar con una grabación. Sólo puede ser usada por unidades
regrabables y con discos CD-RW. Las opciones se describen a continuación:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">help</literal> Muestra la ayuda.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">all</literal> Borra totalmente un disco. Esta opción tarda bastante tiempo.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">disc</literal> o <literal remap="tt">disk</literal> Borra un disco totalmente.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">fast</literal> o <literal remap="tt">minimal</literal> Borrado rápido del disco: Solo borra el TOC,
los pregaps y el PMA.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">track</literal> Borra una sola pista.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">unreserve</literal> Activa una pista reservada.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">trtail</literal> Borra la cola de una pista.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">unclose</literal> Abre una pista cerrada.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">session</literal> Borra la ultima sesión.
</para>
</listitem>

</itemizedlist>

</para>
</listitem></varlistentry>
<varlistentry>
<term>fs=</term>
<listitem>
<para>
Esta opción especifica el buffer fifo para almacenamiento
intermedio de los datos, a fin de hacerlos llegar a la grabadora sin
retraso.  Para facilitar las cosas puede especificar este buffer con un
número seguido de <literal remap="tt">b</literal> para indicarle bytes, <literal remap="tt">k</literal> para kilobytes,
<literal remap="tt">m</literal> para megabytes. 
</para>

<para>
Por defecto tiene un buffer de 4 Mb. La recomendación para el tamaño del
buffer es de entre 4 y 32 Megas, debiendo ser como mínimo igual al tamaño
de buffer interno de la grabadora y como máximo no superior a la mitad de
la RAM física del ordenador. 
</para>

<para>
Lo normal es que no necesite poner más de 8 MB que es lo que yo
recomiendo. Si aún así aparecen mensajes como <literal remap="tt">fifo empty count</literal>, tiene
problemas de configuración o hardware. Ej: <literal remap="tt">fs=8m</literal>. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>driver=</term>
<listitem>
<para>
Esta opción es para especificarle un driver concreto; para
ver la lista de todos los drivers simplemente especifique
<literal remap="tt">driver=help</literal>. Si no se indica opción, <literal remap="tt">cdrecord</literal> tratará de
encontrar el driver más apropiado para la unidad. Si no lo consigue,
tendrá que indicárselo; sepa que si el driver no es absolutamente
compatible corre un riesgo muy grande de perder el CD.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-checkdrive</term>
<listitem>
<para>
Esta opción busca el driver que corresponda a su unidad
y termina la ejecución.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-prcap</term>
<listitem>
<para>
Esta opción imprime las posibilidades de las unidades que
cumplan el estándar <emphasis remap="it">SCSI-3/mmc</emphasis> y sale. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-inq</term>
<listitem>
<para>
Esta opción hace un examen de la unidad, imprime los resultados
en pantalla y sale. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-scanbus</term>
<listitem>
<para>
Esta opción examina el bus SCSI en busca de unidades. Sirve
para buscar nuestra unidad.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-reset</term>
<listitem>
<para>
Esta opción resetea el bus SCSI donde se esté nuestra
grabadora. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-audio</term>
<listitem>
<para>
Detrás de esta opción se indican los nombres de los archivos
de sonido que serán grabados como pistas de audio, siempre y cuando los
archivos tengan una calidad de muestreo 44.100 Khz a 16 Bits, estéreo en
alguna variante PCM; si no son así, serán rechazados por <literal remap="tt">cdrecord</literal>.
Acepta formato CDDA (tanto <literal remap="tt">.cdda</literal> como <literal remap="tt">.cdr</literal> son extensiones
válidas), <literal remap="tt">.wav</literal>, <literal remap="tt">.au</literal> y <literal remap="tt">.raw</literal>. 
</para>

<para>
<literal remap="tt">cdrecord</literal>, si no se le especifica lo contrario, asume que el orden de
palabra es <emphasis remap="it">Big Endian</emphasis>, y convertirá automáticamente a <emphasis remap="it">Little
Endian</emphasis> si detecta que la grabadora lo necesita. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-data</term>
<listitem>
<para>
Tras de esta opción se indica el nombre del archivo que
corresponde a la imagen ISO9660 que anteriormente hemos creado con
<literal remap="tt">mkisofs</literal> u otro de los anteriormente descritos. Esta opción viene por
defecto, lo que quiere decir que si no la indicamos grabaremos de esta
forma.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-mode2</term>
<listitem>
<para>
Si esta opción esta presente, todas las pistas de datos que
la sigan se grabarán en modo 2. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-xa1</term>
<listitem>
<para>
Si esta opción esta presente, todas las pistas que la sigan se
grabarán en modo XA 1. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-xa2</term>
<listitem>
<para>
Si esta opción esta presente, todas las pistas que la sigan se
grabaran en modo XA 2. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-cdi</term>
<listitem>
<para>
Si esta opción esta presente, todas las pistas que la sigan se
grabaran en CDI. 
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Estos son los comandos que más se usan, para ampliar información puede
acudir al manual. Ahora unos ejemplos para que la cosa quede mas clara: 
</para>

<para>

<screen>
cdrecord -scanbus
cdrecord dev=0,0,0 -checkdrive
cdrecord dev=0,0,0 -prcap
cdrecord dev=0,0,0 -inq
cdrecord dev=0,0,0 -toc
cdrecord dev=0,0,0 -msinfo
</screen>

</para>

<para>
Así se realizan los test; en el primero se escanea el bus SCSI para ver
nuestra unidad, en los demás se toma que tenemos la unidad en el
dispositivo que corresponde al bus 0, id 0 y lun 0 para hacerle los test a
los que corresponde la explicación anterior. 
</para>

<para>

<screen>
cdrecord dev=0,0,0 fs=8m speed=2 -nofix -eject -xa1 imagen.iso -audio audio1.wav audio2.cdda audio3.au
</screen>

</para>

<para>
Aquí podemos ver que le hemos puesto 8 Mb al buffer fifo, especificado que
grabe a doble velocidad, que expulse el CD una vez terminado, que la
primera pista es una imagen de datos en formato multisesión XA 1 y las
siguientes pistas serán de audio (este programa puede grabar varios
formatos de audio como el <literal remap="tt">.wav</literal> de Microsoft, el <literal remap="tt">.cdda</literal>, el PCM en
bruto o <literal remap="tt">.raw</literal> y el <literal remap="tt">.au</literal> siempre y cuando tengan una calidad de
muestreo de 44100 Hz a 16 bits, en estéreo). Y al final no será escrita la
TOC por lo que para hacerlo tenemos la siguiente línea: 
</para>

<para>

<screen>
cdrecord dev=0,0,0 -fix
</screen>

</para>

<para>
Para grabar una sola pista de datos podemos usar esto:
</para>

<para>

<screen>
cdrecord dev=0,0,0 fs=8m speed=2 -eject imagen.iso
</screen>

</para>

<para>
Ya que como se dijo antes no hacía falta especificar el parámetro
<literal remap="tt">-data</literal>, que es el asumido por defecto.
</para>

<para>
Las nuevas opciones que incluye el <xref linkend="cdrecorddao"/>
se describen en su sección.
</para>

<sect4>
<title>Parámetros configurables permanentemente de <emphasis remap="bf"><literal remap="tt">cdrecord</literal></emphasis></title>

<para>
Como puede observar, es un poco <emphasis remap="it">latoso</emphasis> el tener que especificar datos
no cambiantes una y otra vez, como por ejemplo dónde se encuentra la
grabadora, o la velocidad de grabación ya que generalmente grabará casi
siempre al máximo de velocidad.
</para>

<para>
Para no tener que especificarlo siempre en la línea de comandos,
<literal remap="tt">cdrecord</literal> provee la posibilidad de establecer dichos parámetros por
defecto, mediante las variables de entorno <literal remap="tt">CDR_DEVICE</literal>, <literal remap="tt">CDR_SPEED</literal>
y <literal remap="tt">CDR_FIFOSIZE</literal>.
</para>

<para>
Supongamos que su grabadora está en el primer bus SCSI, y tiene el ID 4. 
(El LUN siempre va a ser 0). Y que quiere que la velocidad de grabación
por defecto, a menos de que se especifique lo contrario mediante
parámetros de la línea de comandos, va a ser a doble velocidad (2x) y
el <emphasis remap="it">buffer</emphasis> de datos FIFO sea de 16 megabytes. 
</para>

<para>
Estableceríamos dichas variables de entorno mediante la inserción,
generalmente en el fichero <literal remap="tt">/etc/profile</literal>, de las siguientes
líneas, suponiendo que utilice <literal remap="tt">bash</literal> como intérprete de comandos: 
</para>

<para>

<screen>
CDR_SPEED=2
CDR_DEVICE=0,4,0
CDR_FIFOSIZE=16m
export CDR_SPEED CDR_DEVICE CDR_FIFOSIZE
</screen>

</para>

<para>
Dichas variables no estarán disponibles hasta que el sistema relea el
fichero <literal remap="tt">/etc/profile</literal>, lo mejor es reiniciar el terminal con un
<emphasis remap="it">logout</emphasis> o bien recargando el archivo con <emphasis remap="it">source /etc/profile</emphasis>.
Si esto no funciona, reinicie el sistema para salir de dudas.
</para>

</sect4>

<sect4>
<title>Grabacion sin imagen</title>

<para>
Ahora viene algo que puede interesar a más de uno, hacer un CD
directamente desde el disco sin necesidad de hacer una imagen previa. 
</para>

<para>
He de advertir sobre este procedimiento y es que no se debe, por ninguna
circunstancia, acceder al disco que contenga el directorio maestro con los
ficheros a partir de los que se está generando una imagen directa al CD,
ya que cualquier mínimo retraso en la transferencia de datos puede
ocasionar que no se grabe el CD correctamente a pesar de que durante la
grabación no aparezcan errores. 
</para>

<para>
El problema de que no se genere correctamente la imagen puede no radicar
necesariamente en que su disco duro sea lento, hay otros factores como la
memoria disponible: tenga en cuenta que por ejemplo <literal remap="tt">mkisofs</literal> necesita
al menos 12MB de memoria para generar las extensiones Rock Ridge. 
</para>

<para>
Repito, no acceda al disco duro maestro durante la grabación, peligro de
hacer un CD desde el que no se pueda leer ningún dato sano, aunque
aparentemente se haya grabado bien; esto se puede comprobar editando un
archivo de texto y viendo como parte del archivo anterior o los gaps se
han introducido en ellos. 
</para>

<para>
Así mismo recomiendo realizar esta operación sólo con versiones de
<literal remap="tt">cdrecord</literal> superiores o iguales a la <literal remap="tt">1.6.1</literal>, y <literal remap="tt">1.12b5</literal> de
<literal remap="tt">mkisofs</literal> , ya que he comprobado que funcionan y se entienden mucho
mejor, con mucho menor peligro de realizar CDs corruptos.
</para>

<para>
Antes de grabar el CD debe realizar primero la siguiente
operación:
</para>

<para>

<screen>
mkisofs -r -T -l -print-size -f /files
</screen>

</para>

<para>
la cual nos facilitará un número, este número se lo deberemos de pasar en
un parámetro al <literal remap="tt">cdrecord</literal> para que nos reconozca el tamaño de la
imagen a grabar, ya que si no, <literal remap="tt">cdrecord</literal> no tiene forma de saber cuál
es el tamaño de la imagen. De esta forma, si por ejemplo, <literal remap="tt">mkisofs</literal> nos
mostrará la siguiente línea:
</para>

<para>

<screen>
Total extents scheduled to be written = 290699
</screen>

</para>

<para>
Para que <literal remap="tt">cdrecord</literal> reconozca el tamaño
de la imagen a grabar:
</para>

<para>

<screen>
nice --20 mkisofs -r -T -l -f /files | nice --20 cdrecord fs=16m \
tsize=290699*2048 -eject -
</screen>

</para>

<para>
O bien para multisesión:
</para>

<para>

<screen>
nice --20 mkisofs -r -T -l -f /files | nice --20 cdrecord fs=16m \
tsize=290699*2048 -eject -multi - -audio audio1.wav audio2.wav audio3.au
</screen>

</para>

<para>
Nótese que no especificamos ni la localización SCSI de la grabadora, ni la
velocidad de grabación, ya que la hemos establecido con las variables de
entorno mencionadas anteriormente. 
</para>

<para>
Seguramente se preguntará el porqué del <literal remap="tt">nice --20</literal> que hay delante de
cada uno de los programas. El comando <literal remap="tt">nice</literal> sirve para asignar la
prioridad de ejecución, y en este caso concreto establecemos la máxima
posible. 
</para>

<para>
Se preguntará por qué en la opción <literal remap="tt">tsize</literal> del <emphasis remap="it">cdrecord</emphasis> multiplico
por <literal remap="tt">2048</literal> la cantidad dada por el <emphasis remap="it">mkisofs</emphasis>. La razón es muy
simple, a partir de la version <literal remap="tt">1.6.1</literal> y <literal remap="tt">1.8</literal> de <emphasis remap="it">cdrecord</emphasis>, hay
que pasarle el tamaño en bytes de la imagen, y debido a que realiza la
multiplicación él mismo, sólo lo tenemos que multiplicar por el tamaño de
cada sector de un CD y listo. 
</para>

<para>
Use esto con cuidado.
</para>

<para>
Y para terminar voy a indicar cómo usar el programa con las grabadoras
IDE/ATAPI y de puerto paralelo, que por ejemplo al ejecutar la siguiente
linea nos muestre algo como lo siguiente:
</para>

<para>

<screen>
# cdrecord -scanbus
Cdrecord release 1.6 Copyright (C) 1995-1998 Jörg Schilling
scsibus0:
                  0) 'HP      ' 'CD-Writer+ 7200 ' '3.01' Removable CD-ROM
                  1) *
                  2) *
                  3) *
                  4) *
                  5) *
                  6) *
                  7) *
</screen>

</para>

<para>
Así es como ve <literal remap="tt">cdrecord</literal> nuestra grabadora, ya sea interna o externa,
por lo que para indicarle cómo acceder a nuestra grabadora tendremos que
especificar el parámetro <literal remap="tt">dev=0,0,0</literal>. 
</para>

<para>

<screen>
cdrecord dev=0,0,0 speed=2 fs=16m -v -dummy image.raw
</screen>

</para>

<para>
Recomiendo usar la grabadora con una version de <literal remap="tt">cdrecord 1.6.1</literal>,
aunque como se aprecia en el escaneado de muestra anterior hecho con la
versión <literal remap="tt">1.6</literal>, esta última es capaz de usarla. También es muy
recomendable hacer pruebas de grabación para comprobar que no haya falta
velocidad en el puerto paralelo antes de proceder a la grabación final de
CD-ROMs.
</para>

</sect4>

</sect3>

<sect3>
<title><literal remap="tt">cdwrite</literal></title>

<para>
Puede obtener este programa (y casi todos los relativos a creación de CDs) 
de <literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/utils/disk-management/"
>ftp://sunsite.unc.edu/pub/Linux/utils/disk-management/</ulink
></literal>. 
</para>

<para>
Este programa era el más utilizado hasta hace un par de años mas o menos,
(y el único que había). Está en actual desuso, ya que ha dejado de
desarrollarse y se ha quedado algo anticuado; de todas formas funciona
perfectamente en grabadoras SCSI a excepción de las <emphasis remap="it">Sony</emphasis>.
</para>

<para>
Si ha comprendido los comandos del <literal remap="tt">cdrecord</literal> no tendrá problemas en
entender los de este programa ya que no tiene muchos. Una diferencia que
sí hay entre uno y otro es que para identificar la unidad grabadora
utiliza los dispositivos <literal remap="tt">/dev/srX</literal> y no va directamente al bus
SCSI, lo cual puede resultar mas fácil de usar. 
</para>

<para>
Por defecto <literal remap="tt">cdwrite</literal> busca <literal remap="tt">/dev/cdwriter</literal> como dispositivo por
defecto de la grabadora, por lo que si hace un enlace simbólico del
dispositivo <literal remap="tt">/dev/sgX</literal> a <literal remap="tt">/dev/cdwriter</literal> con el dispositivo
de acceso genérico correspondiente, (vea sección <xref linkend="gener"/>) se ahorrará un parámetro más que poner.
</para>

<para>
<literal remap="tt">cdwrite</literal> necesita que se le especifique el tamaño en bytes de la
imagen que va a grabarse; para saberlo, usamos el programa <literal remap="tt">isosize</literal>
(lo podemos encontrar dentro del paquete de distribución de <literal remap="tt">cdwrite</literal>
con otras utilidades extra que nos pueden venir muy bien); si nuestra
imagen se llama <literal remap="tt">imagen.iso</literal>: 
</para>

<para>

<screen>
# isosize imagen.iso
382060544
</screen>

</para>

<para>
nos informa de que el tamaño es <literal remap="tt">382060544</literal>, parámetro que le
especificaremos posteriormente con <literal remap="tt">-b</literal>. 
</para>

<para>
podemos usarlo también con CD-Roms o particiones, si hemos generado la
imagen directa a una partición en lugar de a fichero: 
</para>

<para>

<screen>
isosize /dev/sda1
634986355
</screen>

</para>

<para>
Si hemos volcado la imagen generada por <literal remap="tt">mkisofs</literal> en la primera
partición del primer disco SCSI (con la opción <literal remap="tt">-o /dev/sda1</literal>). 
</para>

<para>
Algunos ejemplos de cómo se usa <literal remap="tt">cdwrite</literal> son: 
</para>

<para>

<screen>
cdwrite -ve -s 2 -b 382060544 -D /dev/sgd -data /dev/scd0
</screen>

</para>

<para>
Copiará directamente el CD que esté en el primer CD-Rom SCSI del sistema a
la grabadora, expulsará el CD una vez listo, e irá informando del
transcurso de la grabación; <literal remap="tt">382060544</literal> es el tamaño del CD en
cuestión, que hemos averiguado previamente mediante <literal remap="tt">isosize</literal>. 
</para>

<para>

<screen>
cdwrite -s 2 -e -D /dev/sgd -b 382060544 -data image.iso -audio *.cdr
</screen>

</para>

<para>
Grabará un CD mixto de datos y audio, en donde el parámetro <literal remap="tt">-s</literal> indica
la velocidad de grabación (equivale al <literal remap="tt">speed=2</literal> del <literal remap="tt">cdrecord</literal>), el
parámetro <literal remap="tt">-e</literal> expulsa el CD al terminar (equivalente al <literal remap="tt">-eject</literal>),
el <literal remap="tt">-D</literal> indica la unidad grabadora, aunque si ha hecho un link de
<literal remap="tt">/dev/sgd</literal> (por ejemplo) a <literal remap="tt">/dev/cdwriter</literal> no hace falta que
lo especifique; y por último igual que en el anterior están los parámetros
<literal remap="tt">-data</literal> y <literal remap="tt">-audio</literal>, estando el formato de los ficheros de sonido en
<emphasis remap="it">Compact Disc Digital Audio</emphasis> (extensiones <literal remap="tt">.cdda</literal> o <literal remap="tt">.cdr</literal>);
podemos pasarlo de otros formatos a éste mediante el programa <literal remap="tt">sox</literal>. 
</para>

<para>
<literal remap="tt">cdwrite</literal> necesita que el orden de la palabra del fichero de audio sea
el apropiado para su grabadora, u obtendrá un CD en el que sólo se escuche
un desagradable <emphasis remap="it">ruido</emphasis>.
</para>

<para>
Consulte la sección <xref linkend="audio"/>.
</para>

<para>
No podrá hacer CDs multisesión con este programa. Para hacer CDs
multisesión tendrá que usar las opciones que lleva el <literal remap="tt">mkisofs</literal> para
este fin, generando una imagen multisesión. 
</para>

</sect3>

<sect3>
<title><literal remap="tt">cdrdao</literal></title>

<para>
Parece ser que se ha conseguido que este programa haga lo que se quería, copiar
CDs al vuelo, incluso los mixtos, de música, y ohhhhhhh, de ¡Playstation!.  No
dejéis de ver la sección dedicada a este programa porque merece la pena.  
</para>

</sect3>

</sect2>

<sect2>
<title>Entornos Integrados</title>

<sect3 id="xcdroast">
<title>X-CD-Roast </title>

<para>
Puede obtener este programa de <literal remap="tt"><ulink
url="http://www.fh-muenchen.de/rz/xcdroast/"
>http://www.fh-muenchen.de/rz/xcdroast/</ulink
></literal>. 
</para>

<para>
Este programa es el más sencillo de usar ya que está hecho para las X con
un interfaz TCL/TK y se basa en modificaciones del <literal remap="tt">cdrecord</literal> y
<literal remap="tt">mkisofs</literal> para su funcionamiento. En versiones anteriores utilizaba un
derivado del <literal remap="tt">cdwrite</literal>, pero tuvo que dejarlo ya que <literal remap="tt">cdwrite</literal> ha
dejado de desarrollarse. 
</para>

<para>
La mayor ventaja que tiene este programa es su facilidad de uso y que
detecta y configura los dispositivos automáticamente, además de funcionar
correctamente y sin problemas. Con él puede configurar y hacer las
imágenes de CD fácilmente sin necesidad de ir a la línea de comandos, así
como extraer pistas de audio y volver a grabarlas gracias a sus
modificaciones del <literal remap="tt">readcdda</literal> y <literal remap="tt">playcdda</literal> (que sólo se pueden usar
con dispositivos SCSI). 
</para>

<para>
Si quiere sacar pistas de audio con un lector IDE lector ha de usar el
<literal remap="tt">cdda2wav</literal>, aunque no todas la unidades lectoras soportan la extracción
de pistas CDDA o de CD-Audio. 
</para>

<para>
Puede hacer una copia directa de CD a CD, siempre que sean sólo de datos,
y que las dos unidades, la grabadora y la lectora, sean dispositivos SCSI,
ya que con las IDE no funciona muy bien, debido no al programa en sí, sino
mas bien por las características de las unidades IDE, ya que no suelen
satisfacer las capacidades de carga de las grabadoras. Aun así he llegado
a comprobar como unidades del tipo Philips IDE de 32x en adelante
funcionaban perfectamente.
</para>

<para>
Lo normal es que no tenga problemas para grabar con este programa siempre
y cuando su grabadora sea SCSI, cuando sea IDE o usa la ultima versión
<literal remap="tt">0.96d final</literal> o superior o no conseguirá que salga ni un solo CD bien. 
</para>

</sect3>

<sect3>
<title>Burn-It</title>

<para>
Este entorno utiliza las últimas versiones de <literal remap="tt">cdrecord</literal>, <literal remap="tt">mkisofs</literal>
y <literal remap="tt">cdda2wav</literal>, lo más peculiar sin duda es que esta escrito íntegramente
en java; su desarrollo es muy rápido.
</para>

<para>
Puede obtenerlo de <literal remap="tt"><ulink
url="http://www.imada.ou.dk/&#732;jews/BurnIT/"
>http://www.imada.ou.dk/&#732;jews/BurnIT/</ulink
></literal>. 
</para>

</sect3>

<sect3>
<title>CDR</title>

<para>
CDR son las siglas de <emphasis remap="it">Create/Duplicate/Rip</emphasis>
(<emphasis remap="it">Crear/Duplicar/Extraer</emphasis>). 
</para>

<para>
Su utilidad actualmente es más que nada para la preparación de audio que
posteriormente va a ser grabado con <literal remap="tt">cdrecord</literal> o <literal remap="tt">cdwrite</literal> desde la
línea de comandos. Provee una interfaz tipo <emphasis remap="it">ncurses</emphasis>. Sólo extrae de
unidades SCSI. 
</para>

<para>
Puede obtenerlo de <literal remap="tt"><ulink
url="http://www.burdell.org/cdr.shtml"
>http://www.burdell.org/cdr.shtml</ulink
></literal>.
</para>

</sect3>

</sect2>

<sect2>
<title>Otros programas y utilidades</title>

<para>
Hay varias utilidades entre las que tengo que destacar <literal remap="tt">sdir</literal>,
<literal remap="tt">isovfy</literal>, <literal remap="tt">cdinfo</literal> y <literal remap="tt">isodetect</literal>, que son pequeñas, de consola,
pero muy útiles a la hora de comprobar y verificar CDs. Estas pequeñas
utilidades se pueden encontrar en el FTP de sunsite <literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/utils/disk-management/"
>ftp://sunsite.unc.edu/pub/Linux/utils/disk-management/</ulink
></literal> y
otras que se pueden encontrar tanto en el paquete de X-CD-Roast (sección
<xref linkend="xcdroast"/>) como en el de <literal remap="tt">cdrecord</literal> (<xref linkend="cdrecord"/>).
</para>

<para>
Por ejemplo, <literal remap="tt">sdir</literal> nos puede ayudar a saber el tamaño total de un
directorio y sus subdirectorios lo cual resulta muy útil cuando queremos
evaluar y calcular el tamaño del CD a copiar al vuelo; <literal remap="tt">isovfy</literal> nos
sirve para verificar que no hayan errores en una imagen creada en el disco
duro; <literal remap="tt">cdinfo</literal> nos puede ayudar a comprobar que se han copiado bien los
CDs y no sólo eso, este pequeño programa muestra la estructura de un CD en
minutos y segundos, nos dice si es arrancable, los sistemas de ficheros
que contiene, si lleva pistas de audio o es un vídeo CD, etc; por último,
con <literal remap="tt">isodetect</literal> podemos ver la etiqueta del volumen de un CD así como
los comentarios de los mismos. 
</para>

<para>
Descripción de las utilidades:
</para>

<para>
<variablelist>

<varlistentry>
<term>sdir</term>
<listitem>
<para>
este programa muestra la capacidad de un directorio con
sus subdirectorios. Los parámetros a pasarle son directorios. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>isodetect</term>
<listitem>
<para>
programa para ver el volumen, el editor, el publicador y
la aplicación de una imagen. Su sintaxis es la siguiente:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">-h</literal> Muestra la ayuda.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">-d</literal> y un nombre de un archivo de imagen o de un dispositivo le
indican en dónde realizar la búsqueda; por defecto busca en
<emphasis remap="it">/dev/cdrom</emphasis>. Si no se indican mas parámetros indicará el tipo de
imagen que es, iso9660 o HFS.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">-V</literal> muestra el nombre del volumen de la imagen o CD.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">-P</literal> muestra el comentario que hay como publicador.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">-p</literal> muestra el comentario que hay como preparador.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">-A</literal> muestra el comentario que hay como aplicación.
</para>
</listitem>

</itemizedlist>

</para>

<para>
Sólo se puede indicar un comando a la vez con <literal remap="tt">-d</literal>. Este programa se
puede encontrar en el paquete <literal remap="tt">X-CD-Roast</literal> (sección <xref linkend="xcdroast"/>).
</para>
</listitem></varlistentry>
<varlistentry>
<term>cdinfo</term>
<listitem>
<para>
excelente y pequeña utilidad que nos muestra la estructura de
un CD; en lo que a pistas se refiere, identifica CDs mixtos, arrancables,
con sistema HFS, CD Plus, etc. (Altamente recomendada y muy útil). La
última versión se puede descargar desde <literal remap="tt"><ulink
url="http://www.in-berlin.de/User/kraxel/dl/cdinfo.c"
>http://www.in-berlin.de/User/kraxel/dl/cdinfo.c</ulink
></literal>
</para>

<para>
Desgraciadamente, parece ser que se ha abandonado su desarrollo.
</para>
</listitem></varlistentry>
<varlistentry>
<term>isovfy</term>
<listitem>
<para>
Esta pequeña utilidad nos servirá para encontrar posibles
errores en las imágenes. Su sintaxis es muy sencilla, solamente se le ha
de indicar un dispositivo de bloque o el nombre del fichero imagen.  Este
programa viene en el paquete de <literal remap="tt">X-CD-Roast</literal> (sección <xref linkend="xcdroast"/>).
</para>
</listitem></varlistentry>
</variablelist>
</para>

</sect2>

</sect1>

<sect1>
<title>Software DAO y generadores de subcódigos.</title>

<sect2 id="cdrecorddao">
<title><literal remap="tt">cdrecord 1.8</literal>
</title>

<para>
Puede obtener la última alpha del servidor FTP <literal remap="tt"><ulink
url="ftp://ftp.fokus.gmd.de/pub/unix/cdrecord/alpha/"
>ftp://ftp.fokus.gmd.de/pub/unix/cdrecord/alpha/</ulink
></literal>. 
</para>

<para>
Descripción de los nuevos comandos para la nueva versión:
</para>

<para>
<variablelist>

<varlistentry>
<term>-useinfo</term>
<listitem>
<para>
Utiliza los archivos de extensión .inf sobreescribiendo las
opciones por defecto.
</para>
</listitem></varlistentry>
<varlistentry>
<term>-atip</term>
<listitem>
<para>
Muestra la información referente al CD y sale. Esta
información tambien la ofrecia la version anterior pero sólo cuando se
disponia a grabar. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>-dao</term>
<listitem>
<para>
Graba el medio en Disc-At-Once.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Ejemplo de como se usa la opción <literal remap="tt">-atip</literal> se tiene en la sección referente
a crear un sistema <emphasis remap="it">ext2</emphasis> con el <xref linkend="mke2fs"/> en un
archivo.
</para>

<para>
Para usar la opción <literal remap="tt">-useinfo</literal> necesitamos primero haber extraido con el
<literal remap="tt">cdda2wav</literal> un CD-Audio al disco duro sin poner la opción <literal remap="tt">-H</literal>.
</para>

<para>

<screen>
cdrecord -v dev=0,3,0 fs=16m speed=4 -useinfo *.wav
</screen>

</para>

<para>
Pues sí, <literal remap="tt">cdrecord</literal> tambien graba en <emphasis remap="it">DAO</emphasis>, pero sólo a partir de la
versión de desarrollo <literal remap="tt">1.8a20</literal>. La forma de usar <literal remap="tt">cdrecord</literal> es
prácticamente la misma solo que para usar las características de la
grabación en DAO ha de tener una grabadora que soporte <emphasis remap="it">MMC</emphasis> y utilizar
la opción <literal remap="tt">-dao</literal>; salvo esto, puede usarlo como haría normalmente.
</para>

<para>
Cuando utilizemos esta opción notaremos una forma distinta de grabar los CDs.
En primer lugar veremos una nueva frase que nos muestra el <emphasis remap="it">cdrecord</emphasis>,
<literal remap="tt">Sending CUE Sheet.</literal> que nos indica que lo primero que está haciendo es
escribir las separaciones de las pistas, los gaps y pregap para luego grabar
todo, incluida la TOC sin desactivar el laser de grabación. Gracias a esta
opción se puede ahorrar unos segundos o minutos si se tiene que grabar un CD
con muchas pistas de audio.
</para>

<para>
Un ejemplo podria ser:
</para>

<para>

<screen>
cdrecord -v dev=3,0 fs=16m speed=4 -dao /imagen.iso /audio/*.wav
</screen>

</para>

<para>
y tambien si se pretende copiar directemente desde un CD
</para>

<para>

<screen>
cdrecord dev=3,0 speed=4 fs=16m -v -dao -isosize /dev/sr0 -audio /wavs/*.wav
</screen>
 
</para>

</sect2>

<sect2>
<title>CD Builder</title>

<para>
Prometedora aplicación, con entorno gráfico en X-Window, que permitirá
generar escaletas (<emphasis remap="it">cue sheets</emphasis> para la creación de CDs, así como de
subcódigos, como CD-G, CD-TEXT, etc.
</para>

<para>
En la actualidad está en su primera etapa (<emphasis remap="it">alpha</emphasis> de desarrollo,
aunque dotado de cierta funcionalidad.
</para>

<para>
Puede obtenerlo de <literal remap="tt"><ulink
url="http://www.ccs.neu.edu/home/bchafy/cdb/cdb.html"
>http://www.ccs.neu.edu/home/bchafy/cdb/cdb.html</ulink
></literal>. 
</para>

<para>
Al parecer se ha abandonado el desarrollo de este programa.
</para>

</sect2>

<sect2 id="cdrdao">
<title><literal remap="tt">cdrdao</literal>
</title>

<para>
Este programa ha evolucionado tanto que la copia en <emphasis remap="it">DAO</emphasis> y al vuelo está
empezando a dar sus frutos. Es posible copiar CDs al vuelo sin volcar los datos
al disco duro incluso con las pistas de audio; el problema en este último
aspecto es que no soporta todas las unidades lectoras a pesar de incorporar
código del <emphasis remap="it">CDParanoia</emphasis> para realizar la extracción de audio.  
</para>

<para>
Echándole un vistazo a la documentación se puede ver qué unidades están
soportadas; tanto unidades grabadoras, incluyendo modelos SCSI e IDE, como 
unidades lectoras que hayan sido probadas sin problema. 
</para>

<para>
También se pide que si su unidad está soportada para extraer Audio con
<emphasis remap="it">cdparanoia</emphasis>, pero no con <literal remap="tt">cdrdao</literal>, le envíe la información que se
obitene de ejecutar el comando <literal remap="tt">cdparanoia -v</literal> a la dirección de correo del
autor, que tratará de incorporarar su unidad lo antes posible.
</para>

<para>
Todo lo referente a las unidades soportadas se encuentra en el archivo
<literal remap="tt">README</literal> del paquete del código fuente. En el mismo paquete se encuentran
otras utilidades bastante interesantes que comentaré seguidamente una vez
explicados los comandos de esta utilidad. 
</para>

<para>
La última versión, recomendada y realmente funcional, la <literal remap="tt">1.1.3</literal>, se puede
obtener de <literal remap="tt"><ulink
url="http://www.ping.de/sites/daneb/cdrdao.html"
>http://www.ping.de/sites/daneb/cdrdao.html</ulink
></literal>. 
</para>

<para>
Descripción de los comandos del programa:
</para>

<para>
<variablelist>

<varlistentry>
<term>Utilización del programa:</term>
<listitem>
<para>

<screen>
cdrdao comando [opciones] archivo-toc
</screen>

</para>
</listitem></varlistentry>
<varlistentry>
<term>comando</term>
<listitem>
<para>
indicamos al programa qué es lo que queremos hacer.  Los comandos
disponibles son:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">show-toc</literal> Muestra la TOC y sale.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">toc-info</literal> Muestra una pequeña descripcion de la información del
archivo TOC extraido previamente.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">toc-size</literal> Muestra el número total de bloques para la TOC.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">read-toc</literal> Crea un archivo TOC desde un CD.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">read-cd</literal> Crea el archivo TOC y extrae el contenido del CD.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">show-data</literal> Muestra el contenido de los datos y sale.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">read-test</literal> Realiza una prueba de lectura de todas las pistas y
sale.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">disk-info</literal> Mustra información sobre el disco que hay en unidad.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">unlock</literal> Desbloquea la unidad despues de un fallo de escritura.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">simulate</literal> Ya no se utiliza, ahora es <literal remap="tt">write --simulate</literal>.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">write</literal> Graba un CD.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">copy</literal> Copia, esto se utiliza para la copia <emphasis remap="it">al vuelo</emphasis>.
</para>
</listitem>

</itemizedlist>
 
</para>
</listitem></varlistentry>
<varlistentry>
<term>opciones</term>
<listitem>
<para>
Aqui se describen las diferentes opciones que soporta el
programa.
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">--device (x,y,z)</literal> Especifica el dipositivo de la grabadora.  Se
puede suprimir si existe un enlace simbólico del dispositivo correspondiente a
su grabadora a <literal remap="tt">/dev/cdrecorder</literal>. Se puede indicar tanto la del
dispositivo directo como el identificador SCSI, ejemplo: <literal remap="tt">0,3,0</literal> o
<literal remap="tt">/dev/sr1</literal>

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--source-device (x,y,z)</literal> Aquí especificamos la unidad desde la
cual tomaremos los datos para realizar la copia. Se puede especificar tanto un
dispositivo como un identificador SCSI. Es necesaria si usamos el comando
<emphasis remap="it">copy</emphasis>.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--driver (id)</literal> Forzamos al programa a usar un controlador
específico para la grabadora.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--source-driver (id)</literal> Forzamos al programa a usar un controlador
específico para la unidad lectora. Es necesaria si usamos el comando <literal remap="tt">copy</literal>,
aunque no si el programa identifica correctamente esta unidad.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--simulate</literal> Para realizar una copia con el láser desactivado, en
modo de simulación o prueba. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--multi</literal> No cierra el CD, para poder crear un CD multisesión.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--eject</literal> Expulsa el CD una vez grabado.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--swap</literal> Invierte el orden de palabra de las pistas de audio.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--on-the-fly</literal> Realiza una copia al vuelo, no crea imagen.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--datafile (archivo)</literal> Nombre del archivo de datos en donde se
encuentran los datos a los que hace referencia el archivo TOC. Usado por
<literal remap="tt">read-cd</literal>, <literal remap="tt">read-toc</literal> y <literal remap="tt">copy</literal>.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--buffers (número)</literal> Expecifica el tamaño del buffer (min. 10).
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--session (número)</literal> Selecciona la sesión para <literal remap="tt">read-toc/read-cd</literal>.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--fast-toc</literal> No extrae los <emphasis remap="it">pre-gaps</emphasis> ni las marcas índice.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--read-raw</literal> Lee los sectores <emphasis remap="it">raw</emphasis> para <emphasis remap="it">read-cd</emphasis>.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--paranoia-mode (número)</literal> nivel de <emphasis remap="it">paranoia</emphasis> para la
extracción de audio <emphasis remap="it">(0..3)</emphasis>.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--reload</literal> Relee el disco si es necesario para grabar.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">--force</literal> Fuerza la ejecución de la operación.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">-v (número)</literal> Expecifica el nivel de muestra de datos.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">-n (número)</literal> No hace una pausa después de grabar.
</para>
</listitem>

</itemizedlist>

</para>
</listitem></varlistentry>
</variablelist> 
</para>

<para>
De aqui hay que comentar que el comando <literal remap="tt">copy</literal> sólo se usa para copiar un CD
directamente, si tenemos una imagen y la queremos copiar hay que usar el
comando <emphasis remap="it">write</emphasis>. Un tamaño muy recomendado del buffer es 64, y de ahí en
adelante, aunque con 64 creo que es más que suficiente.
</para>

<sect3>
<title>Copia al vuelo de CD-ROMs.</title>

<para>
Ahora una breve descripción de lo que más nos interesa del programa, la copia
directa (al vuelo) sin imagen.
</para>

<para>

<screen>
cdrdao copy -v 2 --device 0,3,0 --source-device 0,1,0 --speed 4 --buffers 64 \
--reload --eject --on-the-fly --fast-toc
</screen>

</para>

<para>
Este es el comando que utilizo para duplicar cualquier tipo de CD al vuelo.  Al
ponerle la opción <emphasis remap="it">--fast-toc</emphasis> realiza una lectura rápida de la tabla de
contenidos del CD, de lo contrario primero leerá y comprobará el CD fuente, lo
que tardará lo que necesite su lector, y luego lo copiará. Si le indicamos el
susodicho parámetro, leerá la TOC de forma rápida y empezará enseguida a
copiar. El resto de parámetros no necesitan de una explicacion más detallada.
</para>

<para>
Es recomendable que cuando se copie un CD de música o mixto se utilice de la
siguiente manera con la opción <literal remap="tt">--paranoia-mode</literal>: 
</para>

<para>

<screen>
cdrdao copy -v 2 --device 0,3,0 --source-device 0,1,0 --speed 4 --buffers 64 \
--reload --eject --on-the-fly --fast-toc --paranoia-mode 0
</screen>

</para>

<para>
Con la opción <literal remap="tt">--paranoia-mode</literal> le especificamos en que modo ha de ser
paranoico a la hora de extraer las pistas de audio, si le especificamos <literal remap="tt">0</literal>,
será lo menos posible y es el que se recomienda a la hora de grabar al vuelo ya
que se desactiva la verificacion de errores, que como es normal, reduce la
transeferencia de datos ya que la unidad lectora se dedica más tiempo a
comprobar los posibles defectos de las pistas e intentar corregirlos que a
pasarle los datos a la grabadora, por lo que si no le ponemos este modo es muy
posible que se produzca un <emphasis remap="it">buffer underrun</emphasis> y perder el CD. 
</para>

<para>
Si lo que queremos es que los verifique le indicamos modo <literal remap="tt">3</literal> y será tan
paranoico que para extraer una pista de audio en un lector 32X SCSI (como mi
TEAC) tardará más tiempo que dura la misma cancion al reproducirla; con esto el
programa se asegura de que no pierda calidad y de correguir posibles errores en
el CD.  Este modo es recomendable cuando tengamos algun CD en mal estado y la
única forma de poder grabarlo sea volcando primero a disco duro.
</para>

</sect3>

<sect3>
<title>Extracción y grabación de imágenes DAO con cdrdao.</title>

<para>
Otra de las funciones que nos puede interesar muchisimo es la de extraer una
imagen al disco duro, como por ejemplo para lo dicho anteriormente, para cuando
tengamos algun CD que no podamos grabar al vuelo por estar defectuoso, o bien,
para grabarlo mas tarde. El comando a utilizar es el siguiente:
</para>

<para>

<screen>
cdrdao read-cd -v 2 --device 0,1,0 --read-raw --datafile imagen.bin imagen.toc
</screen>

</para>

<para>
De esta forma conseguimos extraer una imagen en el archivo <literal remap="tt">imagen.bin</literal> del
contenido del CD-ROM fuente y el en archivo <literal remap="tt">imagen.toc</literal> almacenamos la
información que nos servirá posteriormente para poder grabar y dejar el nuevo
CD tal y como estaba el original. El comando a utilizar es el siguiente:
</para>

<para>

<screen>
cdrdao write -v 2 --device 0,3,0 --speed 4 --buffers 64 imagen.toc
</screen>

</para>

<para>
Como habrá notado, no hemos indicado el nombre de la imagen ya que la toma del
archivo que contiene la información TOC. El indicarle la opción <literal remap="tt">--datafile</literal>
con el nombre de la imagen es sólo para identificarla, por si tenemos más de
una extraida en el disco duro; sino, por defecto la imagen se llamará
<literal remap="tt">data.bin</literal>.  Si diese la casualidad de que ya hubiera un archivo con el
mismo nombre, el programa detendrá el proceso mostrando una advertencia,
indicando de que ya existe el archivo.
</para>

<para>
También se puede usar el <literal remap="tt">cdrdao</literal> para copiar una imagen de datos que
hayamos hecho, pero no lo recomiendo; ya que primero tenemos que crear un
archivo TOC, cosa que resulta más laborioso que copiarla con el <emphasis remap="it">cdrecord</emphasis>.
</para>

</sect3>

<sect3>
<title>Scripts que acompañan a cdrdao.</title>

<para>
Se puede usar <literal remap="tt">cdrdao</literal> para copiar archivo <literal remap="tt">.wav</literal>, y que gracias a un
script en PERL que incluye en el directorio <literal remap="tt">/contrib/wav2dao/</literal> del
paquete del código fuente podamos copiar dichas pistas sin que al final de las
mismas nos ponga 2 segundos de silencio.
</para>

<para>
Para obtener la ayuda del programa ponemos:
</para>

<para>

<screen>
 
wav2dao.pl -H
</screen>

</para>

<para>
Deberia funcionar simplemente con
</para>

<para>

<screen>
wav2dao.pl -d /dev/sr0 -w -n *.wav
</screen>

</para>

<para>
En el directorio de los fuentes <literal remap="tt">/contrib/mp32dao/</literal> encontramos otro
script en PERL para realizar de forma automática la extracción de los archivo
<literal remap="tt">.mp3</literal> a <literal remap="tt">.wav</literal>, nos crea la TOC y nos graba el CD, interesante, ¿no?.
Debido a la falta de algunos archivos en la distribución del PERL en mi sistema
no he podido probarlo.  Este script hace uso del programa <emphasis remap="it">mpg123</emphasis> que se
encuentra en la mayoria de distribuciones del mercado o bien por internet.
</para>

<para>
Puede que necesite completar su distribución perl con módulos del CPAN
(<emphasis remap="it">Comprehensive Perl Archive Network</emphasis>) <literal remap="tt"><ulink
url="http://www.cpan.org"
>http://www.cpan.org</ulink
></literal> para hacer uso de
este script.
</para>

</sect3>

<sect3>
<title>Duplicado de CD-ROMs de PlayStation con CDRDAO.</title>

<para>
 
</para>

<para>
Por último tenemos en el directorio <literal remap="tt">/contrib/psxcopy-x.y/</literal> dos
programas y dos scripts para la extracción y copia de los dichosos CDs de
PlayStation. Lo siento por aquellos que quieran copiar dichos CDs al vuelo,
pero de momento no soportan dicha función, tal vez mas adelante, pero hay que
reconocer que ya es un comienzo que por lo menos se puedan grabar, ¿no?.
</para>

<para>
Pues bien, lo primero es compilar los dos programas que son necesarios y luego
instalarlos. Una vez compilados sin errores hacemos que los scripts
<literal remap="tt">read-psx</literal> y <literal remap="tt">write-psx</literal> sean ejecutables. Como son dos scripts normales,
habrá que editarlos y modicicar los parámetros para que apunten a nuestra
unidad lectora y grabadora respectivamente en cada archivo. Una vez hecho eso
simplemente introducimos el CD fuente en la unidad lectora, tecleamos:
</para>

<para>

<screen>
read-psx cd1
</screen>

</para>

<para>
y una vez extraído
</para>

<para>

<screen>
write-psx cd1
</screen>

</para>

</sect3>

<sect3>
<title>A tener en cuenta</title>

<para>
Hay más posibilidades pero las descritas anteriormente son las que son más
faciles de usar y que más nos pueden interesar. En próximas versiones
ampliaremos el contenido dedicado a este fabuloso programa.
</para>

<para>
Tambien indicar que en el mismo paquete de las fuentes se encuentra un interfaz
para X, el problema es que no soporta la grabación al vuelo.
</para>

<para>
<emphasis remap="bf">ATENCION</emphasis>: Durante la utilización del programa para la duplicación de
un CD-ROM al vuelo, no se podrá acceder de ninguna de las maneras a la unidad.
Si se intenta montar la unidad fuente, por ejemplo, el proceso de grabación
terminará con errores y el CD origen no se completará, perdiedo un disco. Esto
se puede comprobar grabando un disco en modo de pruebas o de simulación y
accediendo a la unidad desde donde se obtienen los datos.
</para>

</sect3>

</sect2>

</sect1>

<sect1 id="PUF">
<title>Preguntas de Uso Frecuente
</title>

<sect2>
<title>Cuando grabo con <literal remap="tt">cdrdao</literal>, muestra una capacidad de casi 750
megas para un CD 74 minutos. ¿Esto a que se debe?</title>

<para>
Una curiosidad que se observa mientras se está grabando un CD con el programa
es que en lugar de decirnos el tamaño de cada pista que se está grabando nos
muestra una capacidad abismal del borde de los 750 megas para un CD 74 minutos
completo.
</para>

<para>
Esto se debe a que la grabación que ofrece este programa no es en megas reales
de ordenador sino en megas de CD, que en lugar de ser de 8/16/32 bits es de
12'5 bits, de ahí el tamaño.  No tiene porque asustarse, es completamente       normal. Otra de las ventajas que he podido apreciar es que ofrece mucha
información sobre el CD antes de realizar el proceso de grabación. 
</para>

</sect2>

<sect2 id="fallos">
<title>Me sale un mensaje muy parecido al siguiente después de que el
disco duro deje de funcionar durante unos segundos. </title>

<para>
Me sale este mensaje después de que el disco duro deje de funcionar
durante unos segundos:
</para>

<para>

<screen>
hda: irq timeout: status=0x58 { DriveReady SeekComplete DataRequest}
hda: disabled DMA
ide0: reset: success
</screen>

</para>

<para>
Tiene que recompilar el kernel y desactivar el soporte para el chip Intel
Tritón (I/II) DMA, ya que su disco duro no soporta extracción por DMA. 
</para>

<para>
Esto puede ocasionar problemas a la hora de estar grabando un CD, puesto
que el disco duro se puede parar durante 6 a 9 segundos, hasta que el
kernel se da cuenta, resetea el IDE y desactiva la extracción DMA para ese
disco, (con las unidades de CD-ROM que no lo soporten también) tiempo
suficiente para que el CD pueda salir dañado al no llegarle constantemente
los datos.
</para>

<para>
En el caso de estar emulando dispositivos SCSI es rotundamente necesario
desactivar dicha opción en el kernel ya que en el momento en que pase, el
bus se quedará colgado al hacer interferencia el controlador IDE y la
emulación SCSI, haciendo que no pueda leer de las unidades al estar
literalmente bloqueadas, por lo que el único remedio suele ser apagar el
ordenador. 
</para>

</sect2>

<sect2>
<title>¿Hay alguna forma de hacer una imagen exacta de un CD al disco duro que no sea copiar los ficheros del CD al disco y luego sacar la imagen?</title>

<para>
Sí. Hay una forma de transferir una copia binaria de un CD directamente a
disco duro, haciendo simplemente un <literal remap="tt">cat</literal> o <literal remap="tt">dd</literal> del dispositivo
donde tenga la unidad lectora de CD (normalmente el enlace
<literal remap="tt">/dev/cdrom</literal>) y redireccionando a un archivo o partición libre en
el disco duro; de esta forma podremos hacer una imagen exacta del CD si no
tenemos una unidad secundaria desde donde copiarlo, o si queremos
comprobar la legibilidad del CD.
</para>

<para>
Un ejemplo de cómo se hace es 
</para>

<para>

<screen>
cat /dev/cdrom &#62; imagenCD.iso
</screen>
    
</para>

<para>
o
</para>

<para>

<screen>
dd if=/dev/cdrom of=imagenCD.iso
</screen>

</para>

<para>
una vez hecho esto sólo tenemos que usar esa imagen para grabar y
obtendremos una copia exacta del CD original. Si el CD lleva pistas de
audio tendrá que extraer las pistas de audio primero a disco con un
extractor digital como <literal remap="tt">cdda2wav</literal>, o <literal remap="tt">readcdda</literal>, suponiendo que su
lector lo soporte, sino puede hacerlo desde la grabadora (ver sección <xref linkend="mtbf"/>).
</para>

</sect2>

<sect2>
<title>¿Se puede copiar de CD a CD (sólo de datos) directamente sin ningún problema? </title>

<para>
Efectivamente se puede copiar de CD a CD sólo de datos sin ningún
problema, pero eso sí, (el típico pero) no es nada recomendable hacer la
copia desde un CD IDE y sobre todo si la unidad lectora se para o hace
cosas raras. Para las grabadoras IDE no recomiendo (como ya dije
anteriormente) que ponga la unidad lectora en el mismo puerto IDE que la
grabadora. Si lo hace así, hágale muchas pruebas antes de proceder.
</para>

<para>
Para grabar directamente de CD a CD basta con indicarle al programa
grabador que la imagen la obtenga del dispositivo lector, es decir
<literal remap="tt">/dev/scdX</literal>.
</para>

<para>

<screen>
cdrecord -v dev=0,0,0 speed=2 fs=8M -isosize -eject /dev/sr1
</screen>

</para>

<para>
En este ejemplo podemos ver cómo se hace una copia directa desde la unidad
lectora a la grabadora (IDE en este caso), y si se da cuenta, el parámetro
<literal remap="tt">-isosize</literal> es para forzar al programa grabador a que determine primero
el tamaño del CD imagen ya que por sí solo no lo hace, e intenta leer los
dos ultimos bloques, pudiendo resultar un CD defectuoso. 
</para>

</sect2>

<sect2 id="DAO">
<title>¿Puedo duplicar directamente un CD mixto o de audio? </title>

<para>
Actualmente, solo un programas para grabación de CDs bajo Linux permite
duplicar directamente un CD mixto (1 o varias pistas de datos y una o varias de
audio) sin extraer al menos las de audio a disco duro gracias a que soporta
duplicación de tipo <emphasis remap="it">DAO</emphasis> (<emphasis remap="it">Disk At Once</emphasis>) y <emphasis remap="it">OTH</emphasis> (<emphasis remap="it">On The Fly</emphasis>).
Por supuesto, la unidad grabadora ha de soportarlo, además del programa;
además, el lector de CDRom ha de estar soportado por el programa para poder
extraer las pistas. 
</para>

<para>
Ver sección <xref linkend="cdrdao"/>.
</para>

</sect2>

<sect2>
<title>¿Puedo duplicar CDs en formato xa2? (Por ejemplo, de PlayStation)</title>

<para>
La respuesta a si se puede duplicar un CD en mode xa2 es <emphasis remap="bf">sí</emphasis>.
</para>

<para>
SI. ¿Cómo? ¿Ahora sí? Pues sí, gracias al <emphasis remap="it">cdrdao</emphasis> ahora es posible duplicar
CDs de PlayStation.  
</para>

<para>
El problema de los CD-ROM de PlayStation es que incorporan un sistema de
grabación basado en la pista 0. Esta pista está grabada como de datos y es
errónea desde el punto de vista del estándar <emphasis remap="it">ISO9660</emphasis>. No obstante,
con las extensiones de nuestros sistemas somos capaces de leerlas. Al
copiar con <literal remap="tt">cdrecord</literal> la pista 0 pasa a ser pista 1; la PlayStation no
coge el CD, ya que el busca la pista 0 sin encontrarla.  Esa es la razón
de usar un programa tipo <emphasis remap="it">DAO</emphasis>/<emphasis remap="it">OTH</emphasis> para hacer este tipo de
copias. 
</para>

<para>
software/grabadora/lector que soportase duplicación DAO, como ahora lo hay.
Ver sección <xref linkend="DAO"/>.
</para>

</sect2>

<sect2>
<title>¿Hay alguna FAQ genérica sobre CD-R o CD-RW?</title>

<para>
Sí. En ella puede consultar desde qué tipo de CD-R vírgenes son mejor para
qué cosa hasta qué grabadora es la más recomendable, o cuáles son en
realidad productos OEM basados en marcas conocidas.
</para>

<para>
Su autor es Andy McFadden, puede consultarla en <literal remap="tt"><ulink
url="http://www.fadden.com/cdrfaq/"
>http://www.fadden.com/cdrfaq/</ulink
></literal>
</para>

<para>
Eso sí, está en inglés, aunque puede aprovechar el traductor de Altavista: 
<literal remap="tt"><ulink
url="http://babelfish.altavista.digital.com/cgi-bin/translate"
>http://babelfish.altavista.digital.com/cgi-bin/translate</ulink
></literal>.
</para>

<para>
La traducción es un poco burda, pero menos da una piedra... <literal remap="tt">:)</literal>.
</para>

</sect2>

<sect2>
<title>He grabado un CD de Audio, pero al escucharlo sólo se oye un
zumbido horripilante... </title>

<para>
Consulte la sección <xref linkend="audio"/>, Ha utilizado el orden de palabra binaria <emphasis remap="it">endian</emphasis> equivocado
para grabar ficheros de audio.
</para>

</sect2>

<sect2>
<title>Problemas con más de un dispositivo en controladoras SCSI NCR</title>

<para>
Poseo una controladora Ultra-SCSI NCR 53c810a a la cual tenia conectada la
grabadora, y en las opciones de configuración del kernel me aparecen una
serie de parametros opcionales que no recomiendan ellos mismos que se
activen, a no ser que los dispositivos den problemas o cuelguen el
sistema. 
</para>

<para>
Pues bien, cuando tenía sólo la grabadora y estos tres parámetros
activados efectivamente el sistema se colgaba.  Posteriormente adquirí una
unidad lectora SCSI para poder realizar duplicaciones directas, pero en
las duplicaciones aparecían errores por todos sitios. 
</para>

<para>
Me di cuenta de que la unidad lectora no funcionaba a todo su rendimiento,
asi que activé todas las opciones del kernel para mi controladora,
solucionando el problema y comprobando que mi sistema no se caía.
</para>

<para>
Pero los problemas no acabaron ahí, cuando intentaba extraer audio la
controladora se me colgaba, teniendo que resetear, así que me puse a
recompilar el kernel de nuevo y cuál fue mi sorpresa al ver que no sólo
había ese controlador para las tarjetas NCR de la serie 53c8xx. 
</para>

<para>
El problema no era de la controladora sino del controlador que estaba
usando. Por lo tanto cambié de controlador al más novedoso y recomendable,
el <literal remap="tt">ncr53c8xx</literal>, solucionando el problema y dejando de tener todos los
inconvenientes anteriormente citados, funcionando todo a la primera. 
</para>

<para>
De aquí deduzco que hay que fijarse mucho en todos los controladores
disponibles, ya que por ejemplo para las controladoras NCR hay más de uno;
familiarícese con su controladora.
</para>

<para>
Esto es un ejemplo de lo que puede pasar si el controlador de su
dispositivo SCSI no corresponde lo mas recientemente con su controladora
SCSI.
</para>

</sect2>

<sect2>
<title>¿Como se crea un CD Mixto?</title>

<para>
Para crear un CD en modo mixto, es decir, con una primera pista de datos y
las siguientes de audio hemos de crear una imagen de datos con el
<literal remap="tt">mkisofs</literal> y tener las pistas de audio listas en algún directorio,
procediendo con <literal remap="tt">cdrecord</literal> de la siguiente manera:
</para>

<para>

<screen>
cdrecord -v dev=4,0 speed=2 fs=16m -eject image.raw -audio /wavs/*.wav
</screen>

</para>

<para>
y si lo que queremos es copiar una CD de este tipo, lo primero es extraer
las pistas de audio al disco duro con, por ejemplo, el <literal remap="tt">cdda2wav</literal> y
luego usar el <literal remap="tt">cdrecord</literal> de esta forma: 
</para>

<para>

<screen>
cdda2wav -D 0,2,0 -B -t 2+9
cdrecord -v dev=1,0 speed=4 fs=16m -nopad defpregap=0 pregap=0 -isosize \
/dev/cdrom -audio *.wav
</screen>

</para>

<para>
Las opciones que he incluido <literal remap="tt">-nopad defpregap=0 pregap=0</literal> nos
sirven para que el CD ocupe un poco menos al ser grabado y no grabar
espacios entre las imágenes. Recomiendo usarlas en las copias de CD mixtos
y CD Plus.
</para>

</sect2>

<sect2 id="cdmix">
<title>¿Como se graba un CD multisesión?
</title>

<para>
ATENCION: No es posible crear CDs Multisesion con formato Joliet.
</para>

<para>
El asunto de un CD multisesión es complicadillo. Si comenzamos con que
hemos grabado una imagen digamos de 200 MB y también queremos grabar otra
de otros 200 MB a continuación no podremos, es decir, primero tendremos
que grabar una, y después crear la segunda imagen con unas opciones que
tenemos que sacar de <literal remap="tt">cdrecord</literal>, pasándoselas a <literal remap="tt">mkisofs</literal> como
muestra el ejemplo:
</para>

<para>

<screen>
cdrecord dev=4,0 -msinfo
</screen>

</para>

<para>
Para obtener el número que hace falta, es decir, la información
multisesión del CD. Sólo funciona con CDs que hayan sido grabados con la
opción <literal remap="tt">-multi</literal>. Entonces le pasamos a <literal remap="tt">mkisofs</literal> el número que
puede ser: <literal remap="tt">0,131456</literal> de la siguiente forma:
</para>

<para>

<screen>
mkisofs -v -a -C 0,131456 -r -R -T -V "CDROM" -N /imagen1.iso -o /imagen2.iso /files/.
</screen>

</para>

<para>
Como se puede observar, también se ha incluido el parámetro <literal remap="tt">-N</literal>
con el nombre de la imagen anteriormente copiada al CD, aunque si la hemos
copiado podemos indicarle el nombre del dispositivo en el que se
encuentra, si bien no he comprobado esto último.
</para>

<para>
Luego procedemos a copiar la imagen con el <literal remap="tt">cdrecord</literal> de forma normal
con el parámetro <literal remap="tt">-multi</literal> para que sea multisesión.
</para>

</sect2>

<sect2>
<title>¿Como se crea un CD Plus?</title>

<para>
¿Pero qué es un CD Plus? Un CD Plus contiene primero pistas de audio y al
final una pista de datos. ¿Qué raro no? ¿Y para qué sirve?  Se usa de
forma común para usar este tipo de CDs con lectores de CD-Audio normales,
¿Ha probado a escuchar un CD de datos en un lector de CD-Audio normal?
Para crear este tipo de CDs lo primero es crear una imagen sin archivos en
ella, es decir, hacer una imagen básica desde un directorio en el que no
hayan archivos. Grabamos las pistas de audio y la imagen básica que hemos
creado con la siguiente sentencia:
</para>

<para>

<screen>
cdrecord -v dev=4,0 speed=4 fs=16m -multi -audio *.wav -data imagen.iso
</screen>

</para>

<para>
una vez grabada, obtenemos la información de multisesión del CD y hacemos
la imagen y la grabamos de la misma forma que está explicada en la sección
<xref linkend="cdmix"/>.
</para>

</sect2>

<sect2 id="mtbf">
<title>¿Se puede usar la grabadora para leer o extraer?
</title>

<para>
Sí, pero es algo altamente <emphasis remap="bf">desancosejable</emphasis>. Las razones: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
<emphasis remap="it">MTBF</emphasis> de una grabadora (su tiempo de vida útil) suele ser muy
bajo (unas 30000 horas)  comparado con el de un lector de CD (unas
150000).

</para>
</listitem>
<listitem>

<para>
El precio de un lector de CD IDE decente es aproximadamente de un
15% a un 20% respecto al de una grabadora, y entre un
20% y un 25% si es SCSI. 

</para>
</listitem>
<listitem>

<para>
Las velocidades de lectura de los lectores suelen ser de 40x o
incluso 50x. Las de las grabadoras, no pasan de 10x. 
</para>
</listitem>

</itemizedlist>

</para>

<para>
De lo cual se deduce que no es nada rentable, por no decir efectivo,
malgastar la vida útil de una grabadora en emplearla como lector. 
</para>

</sect2>

<sect2>
<title>Tengo una grabadora HP-7500, y <literal remap="tt">cdrecord</literal> me hace cosas raras...</title>

<para>
Como por ejemplo, en un <literal remap="tt">-scanbus</literal>:
</para>

<para>

<screen>
bus, target: 0, ,0,0      0  'PIONEER ' 'CD-ROM DR-A02S  ' '1.08' Removable CD-ROM

bus, target: 0, ,1,0      1  'HP      ' 'CD-Writer+ 7500 ' '1.0a' Removable CD-ROM
0,,1,0    1,0 ('HP      ' 'CD-Writer+ 7500 ' '1.0a' Removable CD-ROM) == 0,,1,0
1,0 ('HP      ' 'CD-Writer+ 7500 ' '1.0a' Removable CD-ROM)
</screen>

</para>

<para>
O fallos continuos...
</para>

<para>
Necesita aplicar un parche a <literal remap="tt">cdrecord</literal>, y recompilarlo para que soporte
adecuadamente su grabadora.
</para>

<para>
En <literal remap="tt"><ulink
url="http://www.guug.de:8080/cgi-bin/winni/lsc.pl"
>http://www.guug.de:8080/cgi-bin/winni/lsc.pl</ulink
></literal> puede obtenerlo.  
</para>

</sect2>

<sect2>
<title>CDRDAO no detecta bien mi unidad</title>

<para>
La única solución es leer bien el archivo <literal remap="tt">README</literal> que acompaña al programa
y comprobar si su unidad está realmente soportada en la lista que acompaña.  Si
realmente no está tiene la posibilidad de enviar un mail al autor para que
añada soporte para ella. Pero antes de hacer eso, pruebe con todos los
controladores de unidades que soporta el programa, a lo mejor alguno de ellos
funciona. 
</para>

</sect2>

<sect2>
<title>Sugerencias y peticiones</title>

<para>
NOTA: Dejo este apartado tal y como está para que se siga aportado ayuda a
otros programas que lo necesiten. Si bien el que mas promete en este aspecto es
<literal remap="tt">cdrdao</literal> pido que el que pueda ayudar en su desarrollo no deje de lado tal
programa que nos ayudará mucho si lo aprendemos a utilizar. Referirse al
apartado del programa <xref linkend="cdrdao"/>
</para>

<para>
Desde este documento pido la ayuda, dedicación que cada uno pueda aportar
a la creación/desarrollo de algún programa DAO (Disk-At-Once) para la
duplicación de CD-ROMs, ya que es muy costoso y trabajoso la creación o
duplicación de CD Mixtos y de Audio, para que linux esté a la altura de
hacer las cosas como lo hacen programas de este tipo para otras
plataformas, como los conocidos <emphasis remap="it">DAO</emphasis>/<emphasis remap="it">CDRWIN</emphasis> de MS-DOS/Windows
respectivamente de la empresa Golden Hawk y Adaptec Easy CD/Pro. 
</para>

</sect2>

</sect1>

<sect1 id="creditos">
<title>Créditos
</title>

<para>
Éste documento ha sido escrito por Leandro Terrés <literal remap="tt"><ulink
url="mailto:lord_lt@retemail.es"
>lord_lt@retemail.es</ulink
></literal> tras leer varios documentos en
inglés, tanto el CDWriters-HOWTO como los manuales de varios programas que
he comentado y gracias a la experiencia obtenida en este campo.
</para>

<para>
Otras partes de este documento son de incorporación propia y pruebas que
he ido haciendo, a base de perder algún que otro CD con grabadoras IDE,
que es la parte más actual por la que se ha hecho éste documento. 
</para>

<para>
Éste documento es propiedad intelectual de Leandro Terrés como parte del
Insflug, y del LDP (<emphasis remap="it">Linux Documentation Proyect</emphasis>). Para cualquier
modificación, añadidura, traducción, etc. póngase en contacto con el
autor. 
</para>

<para>
Colaboraciones, añadiduras y correcciones: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
Jorge de Diego Rodríguez, <literal remap="tt"><ulink
url="mailto:toke@toke.net"
>toke@toke.net</ulink
></literal> por su inestimable ayuda en la finalización del
apartado sobre las grabadoras IDE/ATAPI por puerto paralelo.

</para>
</listitem>
<listitem>

<para>

Revisión, reestructuración, formateo y ampliación (SCSI, extracción de
audio), Francisco J.  Montilla, <literal remap="tt"><ulink
url="mailto:pacopepe@insflug.org"
>pacopepe@insflug.org</ulink
></literal>
</para>
</listitem>

</itemizedlist>

</para>

<para>
a los que desde aqui doy mis más sinceras gracias por la ayuda prestada. 
</para>

</sect1>

<sect1 id="Insflug">
<title>Anexo: El INSFLUG </title>

<para>
El <emphasis>INSFLUG</emphasis> forma parte del grupo internacional <emphasis remap="it">Linux
Documentation Project</emphasis>, encargándose de las traducciones al castellano de
los Howtos (Comos), así como la producción de documentos originales en
aquellos casos en los que no existe análogo en inglés. 
</para>

<para>
En el <emphasis remap="bf">INSFLUG</emphasis> se orienta preferentemente a la traducción de
documentos breves, como los <emphasis>COMOs</emphasis> y <emphasis>PUFs</emphasis> (<emphasis remap="bf">P</emphasis>reguntas de
<emphasis remap="bf">U</emphasis>so <emphasis remap="bf">F</emphasis>recuente, las <emphasis remap="it">FAQs</emphasis>. <literal remap="tt">:)</literal> ), etc.
</para>

<para>
Diríjase a la sede del INSFLUG para más información al respecto.
</para>

<para>
En la sede del INSFLUG encontrará siempre las <emphasis remap="bf">últimas</emphasis> versiones de
las traducciones «oficiales»:  <literal remap="tt"><ulink
url="http://www.insflug.org"
>www.insflug.org</ulink
></literal>. Asegúrese de comprobar cuál es la última
versión disponible en el Insflug antes de bajar un documento de un
servidor réplica.
</para>

<para>
Además, cuenta con un sistema interactivo de gestión de fe de erratas y
sugerencias en línea, motor de búsqueda específico, y más servicios que
estamos trabajando incesantemente para añadir.  
</para>

<para>
Se proporcionará también una lista de los servidores réplica (<emphasis remap="it">mirror</emphasis>)
del Insflug más cercanos a Vd., e información relativa a otros recursos en
castellano.
</para>

<para>
En <literal remap="tt"><ulink
url="http://www.insflug.org/insflug/creditos.php3"
>http://www.insflug.org/insflug/creditos.php3</ulink
></literal> cuenta con una
detallada relación de las personas que hacen posible tanto esto como las
traducciones.
</para>

<para>
¡Diríjase a <literal remap="tt"><ulink
url="http://www.insflug.org/colaboracion/index.php3"
>http://www.insflug.org/colaboracion/index.php3</ulink
></literal> si desea
unirse a nosotros!.
</para>

<para>
Francisco José Montilla, <literal remap="tt"><ulink
url="mailto:pacopepe@insflug.org"
>pacopepe@insflug.org</ulink
></literal>. 
</para>

</sect1>

</article>
