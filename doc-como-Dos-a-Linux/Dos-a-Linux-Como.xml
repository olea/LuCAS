<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>

<articleinfo>

<title>Cómo pasar de DOS a Linux.</title>

<author>
<firstname>Por Guido Gonzato<ulink
url="mailto:guido@ibogfs.df.unibo.it"
>guido@ibogfs.df.unibo.it</ulink
>
 Traducido por David Martín
Carreño, <ulink
url="mailto:davefx@bigfoot.com"
>davefx@bigfoot.com</ulink
></firstname>
</author>

<pubdate>v1.0, 11 de diciembre de 1996. Traducción: 8 de marzo de 1998.</pubdate>

<abstract>

<para>
 Este documento Como está dedicado a todos los (¿próximamente
anticuados?) usuarios de DOS que acaban de decidir pasarse a Linux, el
clónico gratuito de UNIX para ordenadores x86. Dadas las similitudes
entre DOS y Unix, el propósito de este documento es ayudar al lector a
traducir su conocimiento de DOS al entorno Linux, con todo lo que ello
lleva de productivo. 
</para>

</abstract>

</articleinfo>

<sect1>
<title>Introducción</title>

<sect2>
<title>¿Es Linux adecuado para usted?</title>

<para>
¿Quiere pasar de DOS a Linux? Buena idea, pero cuidado: puede no serle
útil. Quiero decir: no hay nada que sea <emphasis remap="it">el mejor ordenador</emphasis> o <emphasis remap="it">el
mejor sistema operativo</emphasis>: depende de a lo que se dedique, por lo que no
creo que Linux sea la mejor solución para todos, incluso aunque sea
técnicamente superior a muchos sistemas operativos comerciales. Usted se
beneficiará inmensamente de Linux si lo que necesita es software para
programar, Internet, TeX... software técnico en general. Pero si necesita
software comercial, o si no le apetece aprender y escribir comandos, deje
Linux y busque en otra parte.
</para>

<para>
Linux no es (por ahora) tan fácil de usar y configurar como Windows o el
Mac, así que prepárese para trastear un poco. Después de estos avisos,
déjeme decir que confío al 100% en que usted pertenece a la clase de
usuario que encontrará en Linux el Nirvana informático. Está hecho para
usted. Y recuerde que, de todos modos, Linux y DOS/Windows pueden
coexistir en la misma máquina. 
</para>

</sect2>

<sect2>
<title>Requisitos previos para la lectura de este Como</title>

<para>
 
</para>

<para>
Asumiré que:
</para>

<para>

<itemizedlist>
<listitem>

<para>
conoce los comandos y conceptos básicos del DOS;

</para>
</listitem>
<listitem>

<para>
Linux, posiblemente con el sistema X Window, está adecuadamente
instalado en su ordenador;

</para>
</listitem>
<listitem>

<para>
su shell ---el equivalente de <literal remap="tt">COMMAND.COM</literal>--- es <literal remap="tt">bash</literal>; 

</para>
</listitem>
<listitem>

<para>
usted comprende que esta guía es sólo un paso incompleto. Para más
información, busque en el <emphasis remap="it">Linux, Instalación y Primeros Pasos</emphasis> de Matt
Welsh y en la <emphasis remap="it">Guía del Usuario de Linux</emphasis> de Larry Greenfield. Ambas,
en versión inglesa, disponibles en <literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/docs/LDP"
>ftp://sunsite.unc.edu/pub/Linux/docs/LDP</ulink
></literal> y, traducidos al
castellano, en la página del proyecto LuCAS: <literal remap="tt"><ulink
url="http://www.infor.es/LuCAS"
>http://www.infor.es/LuCAS</ulink
></literal>
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Ya está. Ahora cuénteme más.</title>

<para>
Supongo que acaba de instalar Linux y los programas que necesita en su
ordenador, que ya tiene una cuenta propia (si no la tiene aún, ¡teclee
<literal remap="tt">adduser</literal> ahora mismo!) y que Linux está ejecutándose. Acaba de
introducir su nombre y su clave, y ahora está mirando a la pantalla
pensando... <emphasis remap="it">¿Y ahora qué?</emphasis>
</para>

<para>
Bien, no se desespere. Puede hacer casi las mismas cosas que solía hacer
con DOS, y muchas más. Si estuviera ejecutando DOS en lugar de Linux,
estaría realizando alguna de las siguientes tareas: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
ejecutar programas y crear, copiar, ver, borrar, imprimir, renombrar
ficheros; 

</para>
</listitem>
<listitem>

<para>
cambiar de directorio, crearlos, borrarlos y listar sus contenidos; 

</para>
</listitem>
<listitem>

<para>
formatear disquetes y copiar ficheros de/hacia ellos;

</para>
</listitem>
<listitem>

<para>
editar el <literal remap="tt">AUTOEXEC.BAT</literal> y el <literal remap="tt">CONFIG.SYS</literal>;

</para>
</listitem>
<listitem>

<para>
escribir sus propios ficheros <literal remap="tt">.BAT</literal> y/o programas Qbasic;

</para>
</listitem>
<listitem>

<para>
el restante 1%.
</para>
</listitem>

</itemizedlist>

</para>

<para>
Estará contento al saber que todas esas tareas pueden llevarse a cabo bajo
Linux de una manera similar a como se hacen bajo DOS. Bajo DOS, el usuario
medio usa muy pocos de los más de 100 comandos disponibles: lo mismo,
hasta cierto punto, sucede con el Linux.
</para>

<para>
Unas pocas cosas que señalar antes de continuar:
</para>

<para>

<itemizedlist>
<listitem>

<para>
primero, cómo salir. Para apagar Linux: si ve una pantalla en modo
texto, pulse Ctrl-Alt-Supr, espere a que el sistema realice unas tareas y
le diga que todo está bien, y entonces apague el ordenador. Si está
trabajando bajo el sistema X Window, pulse primero Ctrl-Alt-Del, y
después Ctrl-Alt-Supr. Nunca apague o reinicie el ordenador directamente:
el sistema de ficheros podría dañarse. 

</para>
</listitem>
<listitem>

<para>
al contrario que en DOS, Linux tiene mecanismos de seguridad
intrínsecos, debido a su naturaleza multiusuario. Los ficheros y los
directorios tienen permisos asociados a ellos, y por lo tanto el usuario
normal puede no tener acceso a alguno de ellos; (ver la Sección <xref linkend="Permisos"/>). Sólo el usuario cuyo nombre de acceso sea <literal remap="tt">root</literal>
tiene el poder absoluto. (Esta persona es el administrador del sistema. Si
trabaja en un ordenador propio, usted también será root). DOS, por el
contrario le dejaría machacar todos los contenidos de su disco duro.
</para>
</listitem>
<listitem>

<para>
si está realmente animado a experimentar, inténtelo usted mismo:
seguramente no podrá hacer ningún daño. Puede conseguir alguna ayuda
escribiendo en la línea de comandos ($ es el símbolo de la línea de
comandos estándar, # es el de root);


<screen>
$ help
</screen>


Esto le porporcionará ayuda acerca de <literal remap="tt">bash</literal>; puede conseguir
información acerca de un comando concreto escribiendo: 


<screen>
$ man comando
</screen>


el cual, si tiene instaladas las páginas man, ejecutará la página de
manual <literal remap="tt">man</literal> asociada al comando. También puede probar con:


<screen>
$ apropos comando
$ whatis comando
</screen>


y presionar <literal remap="tt">q</literal> para salir;

</para>
</listitem>
<listitem>

<para>
la mayor parte del poder y la flexibilidad de Unix viene de los
conceptos simples de redirección y <emphasis remap="it">piping</emphasis>, o entubamiento, más
potentes que bajo DOS.  Los comandos simples pueden agruparse para
realizar tareas complejas. ¡Use estas características! 

</para>
</listitem>
<listitem>

<para>
<emphasis remap="bf">Convenciones</emphasis>: <literal remap="tt">&lt;...&gt;</literal> significa algo que debe ser
especificado, mientras que <literal remap="tt">[...]</literal> es algo opcional. Ejemplo: 


<screen>
$ tar -tf &#60;fichero.tar&#62; [&#62; fichero_redir]
</screen>


<literal remap="tt">fichero.tar</literal> debe ser indicado, pero la redirección a
<literal remap="tt">fichero_redir</literal> es opcional.

</para>
</listitem>
<listitem>

<para>
desde ahora <emphasis remap="it">LPM</emphasis> significa <emphasis remap="it">para más información Lea las
Páginas del Manual</emphasis>.

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Para el Impaciente</title>

<para>
¿Quiere empezar ya? Eche un vistazo a esto: 
</para>

<para>

<screen>
DOS                     Linux                          Notas

BACKUP                  tar -Mcvf dispositivo dir/     completamente distinto
CD nombredir\           cd nombredir/                  casi la misma sintaxis
COPY fich1 fich2        cp fich1 fich2                 idem
DEL fichero             rm fichero                     cuidado no hay undelete
DELTREE directorio      rm -R directorio/              idem
DIR                     ls                             no exactamente la misma sintaxis
EDIT fichero            vi fichero                     creo que no le gustara
                        emacs fichero                  este es mejor
                        joe fichero                    mas parecido al edit del DOS
FORMAT                  fdformat
                        mount, umount                  sintaxis bastante distinta
HELP comando            man comando                    misma filosofia
MD directorio           mkdir directorio/              casi la misma sintaxis
MOVE fich1 fich2        mv fich1 fich2                 idem
NUL                     /dev/null                      idem
PRINT fichero           lpr fichero                    idem
PRN                     /dev/lp0,
                        /dev/lp1                       idem
RD directorio           rmdir directorio/              idem
REN fich1 fich2         mv fich1 fich2                 no para varios ficheros
RESTORE                 tar -Mxpvf device              sintaxis distinta
TYPE fichero            less fichero                   mucho mejor
WIN                     startx                         ¡mundos aparte!
</screen>

</para>

<para>
Si necesita más que una tabla de comandos, continúe con las secciones
siguientes. 
</para>

</sect2>

</sect1>

<sect1>
<title>Ficheros y Programas</title>

<sect2>
<title>Ficheros: Nociones preliminares</title>

<para>
Linux tiene un sistema de ficheros ---la estructura de directorios y los
ficheros que contienen--- muy similar al del DOS. Los ficheros tienen
nombres que obedecen unas normas especiales, están guardados en
directorios y algunos son ejecutables, y entre éstos , la mayoría tiene
opciones en la línea de comandos. Incluso puede utilizar comodines,
redirección y tuberías como en DOS. Sólo hay unas pocas diferencias: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
bajo DOS, los nombres de ficheros están en el llamado formato 8.3; 
por ejemplo <literal remap="tt">NOTENOUG.TXT</literal>. Bajo Linux podemos hacerlo mejor. Si
instaló Linux usando un sistema de ficheros tal como <emphasis remap="it">ext2</emphasis> o
<emphasis remap="it">umsdos</emphasis>, puede utilizar nombres más largos (hasta 255 caracteres), y
con más de un punto en ellos: por ejemplo,
<literal remap="tt">Este.es.un.nombre.de.fichero.MUY.largo</literal>.  Dése cuenta de que he
utilizado tanto mayúsculas como minúsculas: en efecto... 
</para>
</listitem>
<listitem>

<para>
Linux es sensible a las mayúsculas y las minúsculas en los nombres
de ficheros o comandos. De hecho, <literal remap="tt">FICHERO.tar.gz</literal> ,
<literal remap="tt">Fichero.tar.gz</literal> y <literal remap="tt">fichero.tar.gz</literal> son tres ficheros distintos.
<literal remap="tt">ls</literal> es un comando, <literal remap="tt">LS</literal> sería un error; 

</para>
</listitem>
<listitem>

<para>
no hay extensiones obligadas como <literal remap="tt">.COM</literal> y <literal remap="tt">.EXE</literal> para los
programas, o <literal remap="tt">.BAT</literal> para los ficheros de procesamiento por lotes. Los
ficheros ejecutables se marcan con un asterisco. Por ejemplo: 


<screen>
$ ls -F
cindy.jpg    cjpg*    Soy_un_directorio/  mi_1er_script*  old~
</screen>


Los ficheros <literal remap="tt">cjpg*</literal> y <literal remap="tt">mi_1er_script*</literal> son "programas" 
ejecutables. Bajo DOS, las copias de seguridad de los ficheros suelen
acabar en <literal remap="tt">.BAK</literal>, mientras que bajo Linux acaban con un gurruño
&tilde;. Un fichero cuyo nombre empieza con un punto es considerado como
oculto. Ejemplo: el fichero <literal remap="tt">.Soy.un.fichero.oculto</literal> no se mostrará
a un comando <literal remap="tt">ls</literal>; 

</para>
</listitem>
<listitem>

<para>
Las opciones de los programas bajo DOS se obtienen con
<literal remap="tt">/opción</literal>. En Linux se obtienen con <literal remap="tt">-opción</literal> o <literal remap="tt">--opción</literal>. 
Ejemplo: <literal remap="tt">dir /s</literal> se convierte en <literal remap="tt">ls -R</literal>. Fíjese en que
muchos programas DOS (como <literal remap="tt">PKZIP</literal> o <literal remap="tt">ARJ</literal>) utilizan opciones de
tipo Unix.

</para>
</listitem>

</itemizedlist>

</para>

<para>
Puede ahora saltar a las Sección <xref linkend="Traduciendo"/>, pero yo de usted
seguiría leyendo.
</para>

</sect2>

<sect2>
<title>Enlaces simbólicos</title>

<para>
Unix tiene un tipo de fichero que no existe bajo DOS: el enlace simbólico. 
Puede pensar que es un puntero o enlace a un fichero o a un directorio y
que puede utilizarse en lugar del fichero o del directorio al que apunta;
es similar a los "Accesos Directos" de Windows 95. Ejemplos de enlaces
simbólicos son <literal remap="tt">/usr/X11</literal>, que apunta a <literal remap="tt">/usr/X11R6</literal>; 
<literal remap="tt">/dev/modem</literal>, que apunta a <literal remap="tt">/dev/cua0</literal> o a
<literal remap="tt">/dev/cua1</literal>, según donde esté el módem.
</para>

<para>
Para crear un enlace simbólico:
</para>

<para>

<screen>
$ ln -s &#60;fichero_o_directorio&#62; &#60;nombre_del_enlace&#62;
</screen>

</para>

<para>
Ejemplo:
</para>

<para>

<screen>
$ ln -s /usr/doc/g77/DOC g77manual.txt
</screen>

</para>

<para>
Ahora puede referirse a <literal remap="tt">g77manual.txt</literal> en lugar de
<literal remap="tt">/usr/doc/g77/DOC</literal>. 
</para>

</sect2>

<sect2 id="Permisos">
<title>Permisos y Propiedades</title>

<para>
Los ficheros y directorios de DOS tienen los siguientes atributos: <literal remap="tt">A</literal>
(fichero), <literal remap="tt">H</literal> (oculto), <literal remap="tt">R</literal> (sólo-lectura), y <literal remap="tt">S</literal> (sistema). 
Sólo <literal remap="tt">H</literal> y <literal remap="tt">R</literal> tienen sentido bajo Linux: los ficheros ocultos
comienzan con un punto, y los de sólo lectura, tienen activado el permiso
"<literal remap="tt">r</literal>". 
</para>

<para>
Bajo Unix un fichero tiene <emphasis remap="it">permisos</emphasis> y un propietario, que pertenece a
un grupo. Mire este ejemplo:
</para>

<para>

<screen>
$ ls -l /bin/ls
-rwxr-xr-x  1  root  bin  27281 Aug 15 1995 /bin/ls*
</screen>

</para>

<para>
El primer campo contiene los permisos del fichero <literal remap="tt">/bin/ls</literal>, que
pertenece a <literal remap="tt">root</literal>, del grupo <literal remap="tt">bin</literal>. Dejando la información restante
a un lado (el libro de Matt esta ahí para ese propósito), sólo recordaré
lo que significa <literal remap="tt">-rwxr-xr-x</literal> (de izquierda a derecha):
</para>

<para>
<literal remap="tt">-</literal> es el tipo de fichero (<literal remap="tt">-</literal> = fichero normal, <literal remap="tt">d</literal> =
directorio, <literal remap="tt">l</literal> = enlace, etc.); <literal remap="tt">rwx</literal> son los permisos del
propietario del fichero (leer, escribir, ejecutar); <literal remap="tt">r-x</literal> son los
permisos para el grupo del propietario del fichero (leer y ejecutar); (no
tocaré el concepto de grupo, puede pasar sin él mientras sea un novato ;-)
<literal remap="tt">r-x</literal> son los permisos para todos los demás usuarios (leer, ejecutar).
</para>

<para>
A eso se debe el porqué no puede borrar el fichero <literal remap="tt">/bin/ls</literal> a
menos que sea root:  no tiene el permiso de escritura para hacer eso. Para
cambiar los permisos de un fichero, el comando es: 
</para>

<para>

<screen>
	
$ chmod &#60;quienXperm&#62; &#60;fichero&#62;
</screen>

</para>

<para>
donde <literal remap="tt">quien</literal> podría ser:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">u</literal> usuario, que es el propietario,
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">g</literal> (grupo), 
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">o</literal> (otros).
</para>
</listitem>

</itemizedlist>

</para>

<para>
<literal remap="tt">X</literal> puede ser tanto <literal remap="tt">+</literal> como <literal remap="tt">-</literal>, y  <literal remap="tt">perm</literal> puede ser:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">r</literal> (lectura),
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">w</literal> (escritura)
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">x</literal> (ejecución). 
</para>
</listitem>

</itemizedlist>

</para>

<para>
Ejemplos: 
</para>

<para>

<screen>
$ chmod u+x fichero
</screen>

</para>

<para>
esto habilita el permiso de ejecución para el propietario del fichero.
Atajo: <literal remap="tt">chmod +x fichero</literal>. 
</para>

<para>

<screen>
$ chmod go-wx fichero
</screen>

</para>

<para>
esto quita el permiso de escritura y de ejecución para todo el mundo menos
al usuario.
</para>

<para>

<screen>
$ chmod ugo+rwx fichero
</screen>

</para>

<para>
esto le da a todo el mundo el permiso de lectura, escritura y ejecución. 
</para>

<para>

<screen>
$ chmod +s fichero
</screen>

</para>

<para>
esto convierte al fichero en <emphasis remap="it">setuid</emphasis> o <emphasis remap="it">suid</emphasis>, esto es, un fichero
que al ejecutarse lo hace con privilegios de root. 
</para>

<para>
Una manera más corta de referirse a los permisos es con números: 
<literal remap="tt">rwxr-xr-x</literal> puede ser expresado como <literal remap="tt">755</literal> (cada letra corresponde a
un bit: <literal remap="tt">---</literal> es <literal remap="tt">0</literal>, <literal remap="tt">--x</literal> es <literal remap="tt">1</literal>, <literal remap="tt">-w-</literal> es <literal remap="tt">2</literal>,
<literal remap="tt">-wx</literal> es <literal remap="tt">3</literal>...). Parece difícil, pero con algo de práctica el
concepto se domina.
</para>

<para>
<literal remap="tt">root</literal>, al ser superusuario, puede cambiar los permisos de los ficheros
de todo el mundo. Hay mucha más información acerca de esto:  LPM. 
</para>

</sect2>

<sect2 id="Traduciendo">
<title>Traduciendo comandos de DOS a Linux</title>

<para>
A la izquierda, los comandos de DOS; a la derecha, sus correspondientes de
Linux. 
</para>

<para>

<screen>
COPY:         cp
DEL:          rm
MOVE:         mv
REN:          mv
TYPE:         more, less, cat
</screen>

</para>

<para>
Operadores de redirección y de tuberías: 
</para>

<para>
<literal remap="tt">&lt; &gt; &gt;&gt;  |</literal>
</para>

<para>
Comodines: <literal remap="tt">* ?</literal>
</para>

<para>

<screen>
nul: /dev/null

prn, lpt1:  /dev/lp0 o /dev/lp1; lpr
</screen>

</para>

<para>
EJEMPLOS
</para>

<para>

<screen>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO&#62;copy joe.txt joe.doc           $ cp joe.txt joe.doc
C:\GUIDO&#62;copy *.* total                 $ cat * &#62; total
C:\GUIDO&#62;copy fractals.doc prn          $ lpr fractals.doc
C:\GUIDO&#62;del temp                       $ rm temp
C:\GUIDO&#62;del *.bak                      $ rm *~
C:\GUIDO&#62;move paper.txt tmp\            $ mv paper.txt tmp/
C:\GUIDO&#62;ren paper.txt paper.asc        $ mv paper.txt paper.asc
C:\GUIDO&#62;print letter.txt               $ lpr letter.txt
C:\GUIDO&#62;type letter.txt                $ more letter.txt
C:\GUIDO&#62;type letter.txt                $ less letter.txt
       idem                             $ more *.txt *.asc
       idem                             $ cat section*.txt | less
C:\GUIDO&#62;type letter.txt &#62; nul          $ cat letter.txt &#62; /dev/null
</screen>

Notas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">*</literal> es más inteligente bajo Linux: <literal remap="tt">*</literal> equivale a todos los
ficheros excepto los ocultos; <literal remap="tt">.*</literal> equivale a todos los ficheros
ocultos;  <literal remap="tt">*.*</literal> equivale sólo a aquellos ficheros que tienen un punto
en medio del nombre, seguido de otros caracteres; <literal remap="tt">p*r</literal> equivaldría
tanto a <literal remap="tt">peor</literal> como a <literal remap="tt">por</literal>;  <literal remap="tt">*c*</literal> equivaldría tanto a
<literal remap="tt">pecado</literal> como a <literal remap="tt">peca</literal>. 

</para>
</listitem>
<listitem>

<para>
cuando se usa <literal remap="tt">more</literal>, pulse espacio para ir leyendo a través del
fichero, <literal remap="tt">q</literal> o Ctrl-C para salir. <literal remap="tt">less</literal> es más intuitivo y permite
utilizar las teclas del cursor;

</para>
</listitem>
<listitem>

<para>
no hay <literal remap="tt">UNDELETE</literal>, así que piénselo dos veces antes de borrar
cualquier cosa;

</para>
</listitem>
<listitem>

<para>
además de los &lt; &gt; &gt;&gt; del DOS, Linux tiene el operador
<literal remap="tt">2&gt;</literal> para redirigir los mensajes de error (stderr); más aún, el
operador <literal remap="tt">2&gt;&amp;1</literal> redirige stderr a stdout (la salida estándar),
mientras que <literal remap="tt">1&gt;&amp;2</literal> redirige stdout a stderr;

</para>
</listitem>
<listitem>

<para>
Linux tiene otro comodín: los corchetes <literal remap="tt">[]</literal>. Usar <literal remap="tt">[abc]*</literal>
equivale a los ficheros que empiezan por <literal remap="tt">a</literal>, por <literal remap="tt">b</literal> o por <literal remap="tt">c</literal>; 
<literal remap="tt">*[I-N,1,2,3]</literal> equivale a los ficheros que acaban por <literal remap="tt">I, J, K, L,
M, N, 1, 2, 3</literal>;

</para>
</listitem>
<listitem>

<para>
no hay un <literal remap="tt">RENAME</literal> como en DOS; esto es, <literal remap="tt">mv *.xxx *.yyy</literal> no
funciona;

</para>
</listitem>
<listitem>

<para>
use <literal remap="tt">cp -i</literal> y <literal remap="tt">mv -i</literal> para ser avisado cuando un fichero vaya
a ser sobreescrito. 
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Ejecución de programas: Multitarea y Sesiones</title>

<para>
Para ejecutar un programa, escriba su nombre tal y como lo haría bajo DOS. 
Si el directorio (Sección <xref linkend="Directorios"/>) donde el programa está
guardado está incluido en la variable de entorno <literal remap="tt">PATH</literal> (Sección <xref linkend="Inicializacion"/>), el programa comenzará a ejecutarse. Excepción: al
contrario que bajo DOS, en Linux un programa localizado en el directorio
actual no se ejecutará a manos que el directorio actual (simbolizado por
``<literal remap="tt">.</literal>'') esté incluido en el PATH. Para evitarlo, suponiendo que el
programa se llame <literal remap="tt">prog</literal>, teclee <literal remap="tt">./prog</literal>.
</para>

<para>
Éste es el aspecto típico de una línea de comandos:
</para>

<para>

<screen>
$ comando -o1 -o2 ... -on par1 par2 ... parn  &#60; input &#62; output
</screen>

</para>

<para>
donde <literal remap="tt">-o1</literal>, ..., <literal remap="tt">-on</literal> son las opciones del programa, <literal remap="tt">par1</literal>,
..., <literal remap="tt">parn</literal> son los parámetros del programa. Puede encadenar varios
comandos en la línea de comandos: 
</para>

<para>

<screen>
$ comando1 ; comando2 ; ... ; comandoN
</screen>

</para>

<para>
Esto es todo acerca de ejecutar comandos, pero es fácil ir un paso más
allá. Una de las principales razones para usar Linux es que es un sistema
operativo multitarea ---puede ejecutar varios programas (a partir de
ahora, procesos) a la vez---. Puede lanzar procesos en segundo plano
(<emphasis remap="it">background</emphasis>)  y seguir trabajando inmediatamente. Más aún, Linux
permite tener varias sesiones abiertas simultáneamente: es como tener
muchos ordenadores en los que trabajar a la vez. 
</para>

<para>

<itemizedlist>
<listitem>

<para>
Para cambiar a la sesión 1..6:


<screen>
$ Alt-F1 ... Alt-F6
</screen>


</para>
</listitem>
<listitem>

<para>
Para comenzar una nueva sesión sin dejar la actual:


<screen>
$ su - &#60;mi_nombre_de_usuario&#62;
</screen>


Ejemplo:


<screen>
$ su - root
</screen>


Esto es útil, por ejemplo, cuando se necesita montar un disco (Sección
<xref linkend="Disquetes"/>): normalmente, sólo <literal remap="tt">root</literal> puede hacer eso.

</para>
</listitem>
<listitem>

<para>
Para acabar una sesión:


<screen>
$ exit
</screen>


Si hay trabajos parados (ver más abajo), será avisado.

</para>
</listitem>
<listitem>

<para>
Para lanzar un proceso en primer plano:


<screen>
$ nomprog [-opciones] [parametros] [&#60; input] [&#62; output]
</screen>


</para>
</listitem>
<listitem>

<para>
Para lanzar un proceso en segundo plano, añada un <emphasis remap="it">ampersand</emphasis>:
<literal remap="tt">&amp;</literal>, al final de la línea de comandos:

<screen>
$ nomprog [-opciones] [parametros] [&#60; input] [&#62; output] &#38;
[1] 123
</screen>

</para>
<para>
el shell o intérprete de comandos identifica el proceso con un número de
trabajo (p.e.1&rsqb;; ver más abajo), y con un PID (123 en nuestro ejemplo).
</para>
</listitem>
<listitem>
<para>
Para ver cuántos procesos hay:

<screen>
$ ps -a
</screen>

Esto generará una lista de procesos actualmente en ejecución.
</para>
</listitem>
<listitem>

<para>
Para matar un proceso:

<screen>
$ kill &#60;PID&#62;
</screen>

Puede necesitar matar un proceso cuando no sabe cómo cerrarlo de la manera
correcta... ;-). A veces, un proceso solo podrá ser matado con alguna de
las siguientes instrucciones:

<screen>
$ kill -15 &#60;PID&#62;
$ kill -9 &#60;PID&#62;
</screen>

</para>
</listitem>
</itemizedlist>

</para>

<para>
Además, el intérprete de comandos permite suspender temporalmente (parar) 
un proceso, mandar un proceso al segundo plano, y traer un proceso del
segundo plano al primer plano. En este contexto, los procesos son
denominados <emphasis remap="it">trabajos</emphasis>. 
</para>

<para>

<itemizedlist>
<listitem>

<para>
Para ver cuántos trabajos hay:


<screen>
$ jobs
</screen>


aquí los trabajos son identificados por su número de trabajo, no por su
PID. 

</para>
</listitem>
<listitem>

<para>
Para parar un proceso ejecutándose en primer plano (no siempre
funciona): 


<screen>
$ Ctrl-C
</screen>


</para>
</listitem>
<listitem>

<para>
Para suspender un proceso ejecutándose en primer plano:


<screen>
$ Ctrl-Z
</screen>


</para>
</listitem>
<listitem>

<para>
Para mandar un proceso suspendido al segundo plano (convirtiéndolo
en trabajo): 


<screen>
$ bg &#60;trabajo&#62;
</screen>


</para>
</listitem>
<listitem>

<para>
Para traer un trabajo al primer plano:


<screen>
$ fg &#60;trabajo&#62;
</screen>


</para>
</listitem>
<listitem>

<para>
Para matar un trabajo:


<screen>
$ kill &#60;%trabajo&#62;
</screen>


donde <literal remap="tt">trabajo</literal> puede ser 1, 2, 3; el <literal remap="tt">%</literal> indica que nos
referimos a un número de trabajo, y no a un PID. Usando estos comandos
puede formatear un disco, comprimir un puñado de ficheros, compilar un
programa, y descomprimir un fichero simultáneamente, y todavía tener la
línea de comandos a su disposición. Inténtelo con el DOS. Inténtelo con
Windows, sólo para ver la diferencia de prestaciones (siempre que no se le
cuelgue, claro). 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Ejecutando Programas en Ordenadores Remotos</title>

<para>
Para ejecutar un programa en una máquina remota cuya dirección IP es
<literal remap="tt">remote.bigone.edu</literal>, teclee: 
</para>

<para>

<screen>
$ slogin remote.bigone.edu -l &#60;login_en_maquina_remota&#62;
</screen>

</para>

<para>
Tras meter su password, arranque su programa favorito. Obviamente, debe
tener una cuenta en la máquina remota. 
</para>

<para>
Si tiene X11, puede incluso ejecutar una aplicación X en un ordenador
remoto, mostrándolo en su pantalla de X. Supongamos <literal remap="tt">remote.bigone.edu</literal>
la máquina X remota y <literal remap="tt">local.linux.box</literal> su máquina Linux. Para ejecutar
desde <literal remap="tt">local.linux.box</literal> un programa X que reside en
<literal remap="tt">remote.bigone.edu</literal>, haga lo siguiente: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
arranque las X, arranque un xterm o un emulador de terminal
equivalente, y entonces teclee:


<screen>
$ xhost +remote.bigone.edu
$ slogin remote.bigone.edu -l &#60;login_en_maquina_remota&#62;
</screen>


</para>
</listitem>
<listitem>

<para>
tras meter su password, teclee:


<screen>
remote:$ DISPLAY=local.linux.box:0.0
remote:$ programa &#38;
</screen>


(en vez de <literal remap="tt">DISPLAY...</literal>, puede que tenga que escribir <literal remap="tt">setenv
DISPLAY local.linux.box:0.0</literal>. Depende del shell remoto).

</para>
</listitem>

</itemizedlist>

</para>

<para>
Ahora <literal remap="tt">programa</literal> comenzará en <literal remap="tt">remote.bigone.edu</literal> y se mostrará en
su máquina. Aunque mejor no intente esto en una línea ppp.
</para>

</sect2>

</sect1>

<sect1 id="Directorios">
<title>Gestión de Directorios</title>

<sect2>
<title>Directorios: Nociones preliminares</title>

<para>
Hemos visto las diferencias entre los ficheros de DOS y Linux. Entre
directorios, bajo DOS el directorio raíz es <literal remap="tt">&bsol;</literal> y bajo Linux es
<literal remap="tt">/</literal> . De manera similar, los directorios anidados se separan
mediante <literal remap="tt">&bsol;</literal> en DOS y mediante <literal remap="tt">/</literal> en Linux. Ejemplo de
rutas de fichero: 
</para>

<para>
DOS:    <literal remap="tt">C:&bsol;PAPERS&bsol;GEOLOGY&bsol;MID_EOC.TEX</literal>
</para>

<para>
Linux:  <literal remap="tt">/home/guido/papers/geology/mid_eocene.tex</literal>
</para>

<para>
Como bajo DOS, <literal remap="tt">..</literal> es el directorio padre y <literal remap="tt">.</literal> es el directorio
actual.  Recuerde que el sistema no le dejará hacer <literal remap="tt">cd</literal>, <literal remap="tt">rd</literal> o
<literal remap="tt">md</literal> donde usted quiera. Cada usuario comienza desde su propio
directorio llamado <literal remap="tt">&tilde;/</literal>. En el ejemplo anterior, éste es
<literal remap="tt">/home/guido</literal>. 
</para>

</sect2>

<sect2>
<title>Permisos en los directorios.</title>

<para>
Los directorios también tienen permisos. Lo que hemos visto en la Sección
<xref linkend="Permisos"/> también rige para los directorios (usuario, grupo, y
otros). Para un directorio, <literal remap="tt">rx</literal> significa que puede cambiar a ese
directorio, y <literal remap="tt">w</literal> significa que puede crear o borrar ficheros en el
directorio (según los permisos de los ficheros, por supuesto), o el
directorio mismo. 
</para>

<para>
Por ejemplo, para prevenir que otros usuarios husmeen en
<literal remap="tt">/home/guido/text</literal>:
</para>

<para>

<screen>
$ chmod o-rwx /home/guido/text
</screen>

</para>

</sect2>

<sect2>
<title>Equivalencia de comandos de DOS a Linux</title>

<para>

<screen>
DIR:            ls, find, du
CD:             cd, pwd
MD:             mkdir
RD:             rmdir
DELTREE:        rm -R
MOVE:           mv
</screen>

</para>

<para>
EJEMPLOS
</para>

<para>

<screen>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO&#62;dir                            $ ls
C:\GUIDO&#62;dir file.txt                   $ ls file.txt
C:\GUIDO&#62;dir *.h *.c                    $ ls *.h *.c
C:\GUIDO&#62;dir/p                          $ ls | more
C:\GUIDO&#62;dir/a                          $ ls -l
C:\GUIDO&#62;dir *.tmp /s                   $ find / -name "*.tmp"
C:\GUIDO&#62;cd                             $ pwd
        n/a - ver nota                  $ cd
        idem                            $ cd ~
        idem                            $ cd ~/temp
C:\GUIDO&#62;cd \otros                      $ cd /otros
C:\GUIDO&#62;cd ..\temp\trash               $ cd ../temp/trash
C:\GUIDO&#62;md newprogs                    $ mkdir newprogs
C:\GUIDO&#62;move prog ..                   $ mv prog ..
C:\GUIDO&#62;md \progs\turbo                $ mkdir /progs/turbo
C:\GUIDO&#62;deltree temp\trash             $ rm -R temp/trash
C:\GUIDO&#62;rd newprogs                    $ rmdir newprogs
C:\GUIDO&#62;rd \progs\turbo                $ rmdir /progs/turbo
</screen>

</para>

<para>
Notas:
</para>

<para>

<orderedlist>
<listitem>

<para>
 cuando se use <literal remap="tt">rmdir</literal>, el directorio a borrar debe estar vacío.
Para borrar un directorio y todos sus contenidos, use <literal remap="tt">rm -R</literal> (bajo su
propia responsabilidad). 

</para>
</listitem>
<listitem>

<para>
 el carácter <literal remap="tt">&tilde;</literal> es un atajo para el nombre de su
directorio de usuario. Los comandos <literal remap="tt">cd</literal> o <literal remap="tt">cd &tilde;</literal> le llevarán
a su directorio personal desde dondequiera que esté; el comando <literal remap="tt">cd
&tilde;/tmp</literal> le llevará a <literal remap="tt">/home/su_directorio_de_usuario/tmp</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">cd -</literal> "deshace" el último cd.
</para>
</listitem>

</orderedlist>

</para>

</sect2>

</sect1>

<sect1 id="Disquetes">
<title>Disquetes, discos duros y otros métodos de almacenamiento.</title>

<sect2>
<title>Administración de dispositivos</title>

<para>
Nunca habrá pensado acerca de ello, pero el comando de DOS <literal remap="tt">FORMAT A:</literal>
hace mucho más de lo que parece. De hecho, cuando ordene el comando
<literal remap="tt">FORMAT</literal>: 
</para>

<para>

<orderedlist>
<listitem>

<para>
Formateará físicamente el disco
</para>
</listitem>
<listitem>

<para>
Creará el directorio <literal remap="tt">A:</literal> (creará un sistema de ficheros)
</para>
</listitem>
<listitem>

<para>
Pondrá el disco disponible para el usuario (montará el disco).
</para>
</listitem>

</orderedlist>

</para>

<para>
Estos tres pasos se ordenan separadamente bajo Linux. Puede usar disquetes
con formato MS-DOS, aunque haya otros formatos disponibles y sean mejores
(el formato MS-DOS no le dejará usar nombres de fichero largos). A
continuación se explica cómo preparar un disco (necesitará iniciar una
sesión como root): 
</para>

<para>

<itemizedlist>
<listitem>

<para>
Para formatear un disquete estándar de 1.44 megas (A:):


<screen>
# fdformat /dev/fd0H1440
</screen>


</para>
</listitem>
<listitem>

<para>
Para crear un sistema de ficheros:


<screen>
# mkfs -t ext2 -c /dev/fd0H1440
</screen>


o para crear un sistema de ficheros MS-DOS:


<screen>
# mformat a:
</screen>


Antes de usar el disco, debe montarlo.

</para>
</listitem>
<listitem>

<para>
Para montar el disco:


<screen>
# mount -t ext2 /dev/fd0 /mnt
</screen>


o


<screen>
# mount -t msdos /dev/fd0 /mnt
</screen>


Ahora puede dirigirse a los ficheros del disquete. Cuando haya acabado,
antes de sacar el disco deberá desmontarlo. 

</para>
</listitem>
<listitem>

<para>
Para desmontar el disco:


<screen>
# umount /mnt
</screen>


Ahora puede extraer el disco. Obviamente, debe hacer un <literal remap="tt">fdformat</literal> y un
<literal remap="tt">mkfs</literal> sólo a los discos no formateados, que no han sido usados nunca. 
Si quiere utilizar la unidad B:, ponga <literal remap="tt">fd1H1440</literal> y <literal remap="tt">fd1</literal> en lugar
de <literal remap="tt">fd0H1440</literal> y <literal remap="tt">fd0</literal> en los ejemplos anteriores. 
</para>
</listitem>

</itemizedlist>

</para>

<para>
Todo lo que solía hacer con A: y B: se hace ahora utilizando <literal remap="tt">/mnt</literal>
en su lugar.  Ejemplos: 
</para>

<para>

<screen>
DOS                                     Linux
--------------------------------------------------------------------

C:\GUIDO&#62;dir a:                         $ ls /mnt
C:\GUIDO&#62;copy a:*.*                     $ cp /mnt/* /docs/temp
C:\GUIDO&#62;copy *.zip a:                  $ cp *.zip /mnt/zip
C:\GUIDO&#62;a:                             $ cd /mnt
A:&#62;_                                    /mnt/$ _
</screen>

</para>

<para>
No hace falta decir que la manera de proceder con los disquetes también
funciona con otros dispositivos, como por ejemplo, otro disco duro o una
unidad CD-ROM. Esto es para montar el CD-ROM: 
</para>

<para>

<screen>
# mount -t iso9660 /dev/cdrom /mnt
</screen>

</para>

<para>
Ésta era la manera ``oficial'' de montar discos, pero hay un truco. Como
es algo incómodo tener que ser root para montar un disquete o un CD-ROM,
puede darse permisos a cada usuario de esta manera:
</para>

<para>

<itemizedlist>
<listitem>

<para>
como root, crear los directorios <literal remap="tt">/mnt/floppy</literal>,
<literal remap="tt">mnt/a:</literal>, y <literal remap="tt">/mnt/cdrom</literal>
</para>
</listitem>
<listitem>

<para>
añadir en <literal remap="tt">/etc/fstab</literal> las siguientes líneas:


<screen>
/dev/cdrom        /mnt/cdrom    iso9660   ro,user,noauto          0       0
/dev/fd0          /mnt/a:       msdos     user,noauto             0       0
/dev/fd0          /mnt/floppy   ext2      user,noauto             0       0
</screen>

</para>
</listitem>

</itemizedlist>

</para>

<para>
Ahora, para montar un disquete MS-DOS, un disquete ext2, y un CD-ROM:
</para>

<para>

<screen>
$ mount /mnt/a:
$ mount /mnt/floppy
$ mount /mnt/cdrom
</screen>

</para>

<para>
Cualquier usuario puede acceder a <literal remap="tt">/mnt/floppy</literal>, <literal remap="tt">/mnt/a:</literal>,
y <literal remap="tt">/mnt/cdrom</literal>. Para escribir en <literal remap="tt">/mnt/floppy</literal> sin ser root,
después de preparar el floppy es necesario hacer: 
</para>

<para>

<screen>
# mount /mnt/floppy
# chmod 777 /mnt/floppy
# umount /mnt/floppy
</screen>

</para>

<para>
Recuerde que si considera importante la seguridad, dejar que todo el mundo
pueda montar discos de esta manera constituye un buen agujero en la misma.
</para>

</sect2>

<sect2>
<title>Copias de Seguridad</title>

<para>
Ahora que sabe cómo se manejan disquetes, etc. un par de líneas bastan
para ver cómo hacer una copia de seguridad. Hay muchos paquetes que pueden
servirle, pero lo más simple para hacer una copia de seguridad
multivolumen (como root) es: 
</para>

<para>

<screen>
# tar -M -cvf /dev/fd0H1440 /directorio_a_guardar
</screen>

</para>

<para>
Asegúrese de tener un disquete formateado en la unidad, y otros ya
preparados. Para restaurar sus ficheros, inserte el primer disquete en la
unidad y utilice: 
</para>

<para>

<screen>
# tar -M -xpvf /dev/fd0H1440
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>Personalización del Sistema</title>

<sect2 id="Inicializacion">
<title>Ficheros de inicialización del sistema</title>

<para>
Dos ficheros importantes bajo DOS son el <literal remap="tt">AUTOEXEC.BAT</literal> y el
<literal remap="tt">CONFIG.SYS</literal>, los cuales se utilizan al rearrancar el sistema para
inicializarlo, dar valores a algunas variables de entorno como <literal remap="tt">PATH</literal> y
<literal remap="tt">FILES</literal>, y posiblemente lanzar un programa o fichero de procesamiento
por lotes. Bajo Linux hay varios ficheros de inicialización, algunos de
los cuales no deberían ser modificados hasta que usted supiese con
seguridad lo que está haciendo. De todos modos, estos son los más
importantes: 
</para>

<para>

<screen>
FICHEROS             NOTAS
/etc/inittab         ¡no tocar por ahora!
/etc/rc.d/*          idem
</screen>

</para>

<para>
Si todo lo que necesita es establecer el <literal remap="tt">PATH</literal> y otras variables de
entorno, o desea cambiar los mensajes del login o ejecutar automáticamente
un programa tras iniciar una sesión, eche un vistazo a los siguientes
ficheros: 
</para>

<para>

<screen>
FICHEROS                        NOTAS
/etc/issue                      establece el mensaje de antes del login
/etc/motd                       establece el mensaje de despues del login
/etc/profile                    establece el PATH y otras variables, etc.
/etc/bashrc                     define alias y funciones, etc. (ver mas abajo)
/home/su_home/.bashrc           define sus alias y sus funciones
/home/su_home/.bash_profile     establece el entorno y ejecuta sus programas
/home/su_home/.profile          idem
</screen>

</para>

<para>
Si el último fichero existe (fíjese en que es un fichero oculto), se leerá
tras el inicio de sesión y se ejecutarán los comandos en él almacenados.
</para>

<para>
Ejemplo; mire este <literal remap="tt">.profile</literal>:
</para>

<para>

<screen>
# Soy un comentario
echo Entorno:
printenv | less   # equivalente del comando SET bajo DOS
alias d='ls -l'   # es facil comprender lo que es un alias
alias up='cd ..'
echo "Recuerde que su path es "$PATH
echo "Hoy es `date`"  # usa la salida del comando 'date'
echo "Que tenga un buen dia, "$LOGNAME
# Lo siguiente es una funcion del shell
ctgz() # Lista los contenidos de un fichero .tar.gz 
{
  for file in $*
  do
    gzip -dc ${file} | tar tf -
  done
}
# fin de .profile
</screen>

</para>

<para>
<literal remap="tt">PATH</literal> y <literal remap="tt">LOGNAME</literal>, lo adivinó, son variables de entorno. Hay muchas
otras accesibles; para buscar ejemplos, LPM de aplicaciones como
<literal remap="tt">less</literal>.
</para>

</sect2>

</sect1>

<sect1>
<title>Ficheros de Inicialización de Programas</title>

<para>
Bajo Linux, casi todo puede ser configurado de acuerdo con sus
necesidades. La mayoría de los programas tienen uno o más ficheros de
inicialización con los que puede trastear, a menudo llamados
<literal remap="tt">.nombreprogramarc</literal>, situados en su directorio <literal remap="tt">home</literal>. Los primeros
que querrá modificar son los de configuración del gestor de ventanas para
X-Window.  Si utiliza el <literal remap="tt">fvwm2</literal> serán:
</para>

<para>

<screen>
/usr/X11/lib/X11/fvwm2/system.fvwmrc2 
</screen>

</para>

<para>
Para el resto de programas con el que se encontrará tarde o temprano, LPM. 
</para>

</sect1>

<sect1>
<title>Un poco de Programación</title>

<sect2>
<title>Los Scripts del Shell: Ficheros <literal remap="tt">.BAT</literal> con esteroides</title>

<para>
Si ha utilizado ficheros <literal remap="tt">.BAT</literal> para crear atajos de largas líneas de
comando (yo suelo hacerlo), el objetivo puede ser obtenido insertando las
líneas de alias convenientes (ver ejemplo de más arriba) en el
<literal remap="tt">profile</literal> o en el <literal remap="tt">.profile</literal>. Pero si sus ficheros <literal remap="tt">.BAT</literal> son más
complicados, le encantará el lenguaje de Script que el shell pone a su
disposición: es tan potente como el Qbasic (o más). Tiene variables,
estructuras como <literal remap="tt">while</literal>, <literal remap="tt">for</literal>, <literal remap="tt">case</literal>, <literal remap="tt">if-then-else</literal>, y
montones de nuevas características: puede ser una buena alternativa a un
lenguaje de programación "de verdad". 
</para>

<para>
Para escribir un script ---el equivalente a un fichero <literal remap="tt">.BAT</literal> bajo DOS---
todo lo que tiene que hacer es escribir un fichero ASCII estándar que
contenga las instrucciones, guardarlo, y entonces hacerlo ejecutable con
el comando <literal remap="tt">chmod +x fichero</literal>. Para ejecutarlo, teclee su nombre. 
</para>

<para>
Aviso: el editor del sistema se llama <literal remap="tt">vi</literal>, y es un hecho probado que
la mayor parte de los nuevos usuarios lo encuentran muy difícil de usar. 
No voy a explicar cómo usarlo, porque no me gusta y no lo uso. Vea el
manual "<emphasis remap="it">Linux: Instalación y Primeros Pasos</emphasis>" de Matt Welsh (aunque sería
mejor utilizar otro editor tal como <literal remap="tt">joe</literal> o <literal remap="tt">emacs</literal> para X).
Baste decir aquí unos comandos muy básicos: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
para insertar texto, pulse <literal remap="tt">i</literal> y después el texto;

</para>
</listitem>
<listitem>

<para>
para salir de <literal remap="tt">vi</literal> sin guardar, pulse <literal remap="tt">ESC</literal> y después <literal remap="tt">:q!</literal>

</para>
</listitem>
<listitem>

<para>
para guardar y salir, pulse <literal remap="tt">ESC</literal> y luego <literal remap="tt">:wq</literal>
</para>
</listitem>

</itemizedlist>

</para>

<para>
Escribir scripts bajo bash es una materia tan extensa que requeriría un
libro para abarcarla toda, y no voy a profundizar más allá en este tema.
Sólo daré un ejemplo de script, del cual se pueden extraer las reglas
básicas: 
</para>

<para>

<screen>
#!/bin/sh
# ejemplo.sh
# Soy un comentario
# no cambie la primera linea: debe estar ahi
echo "Este sistema es: `uname -a`" # usa la salida del comando
echo "Me llamo $0" # variables intrinsecas
echo "Usted me dio $# parametros: "$*
echo "El primer parametro es: "$1
echo -n "¿Como se llama? " ; read su_nombre
echo fijese en la diferencia: "Hola, $su_nombre" # entrecomillando con "
echo fijese en la diferencia: 'Hola, $su_nombre' # entrecomillando con '
DIRS=0 ; FILES=0
for fichero in `ls .` ; do
  if [ -d ${fichero} ] ; then # si el fichero esta en el directorio
    DIRS=`expr $DIRS + 1`  # DIRS = DIRS + 1
  else if [ -f ${fichero} ] ; then
   FILES=`expr $FILES + 1`
  fi
  case ${fichero} in
    gif|*jpg) echo "${fichero}: fichero grafico" ;;
    *.txt|*.tex) echo "${fichero}: fichero de texto" ;;
    *.c|*.f|*.for) echo "${fichero}: fichero de codigo fuente" ;;
    *) echo "${fichero}: fichero generico" ;;
  esac
done
echo "Hay ${DIRS} directorios y ${FILES} ficheros"
ls | grep "ZxY--!!!WKW"
if [ $? != 0 ] ; then # Sacar el codigo del ultimo comando
  echo "ZxY--!!!WKW no encontrado"
fi
echo "ya es suficiente... Para mas informacion teclee 'man bash'." 
</screen>

</para>

</sect2>

<sect2>
<title>Sus programas en C</title>

<para>
Bajo Unix, el lenguaje del sistema es C, le guste o no. Pero otros
lenguajes como FORTRAN, Pascal, Lisp, Basic, Perl, awk... también están
disponibles. 
</para>

<para>
Suponiendo que usted sepa C, hay un par de guías para aquellos que han
utilizado Turbo C++ o uno de sus hermanos bajo DOS. El compilador de C se
denomina gcc y carece de todas las florituras que normalmente acompañan a
sus análogos bajo DOS: no tiene IDE, ni ayuda en línea, ni debugger
integrado, etc... Es sólo un rústico compilador de línea de comandos, muy
potente y eficiente. Para compilar el típico programa <literal remap="tt">hello.c</literal> esto es
lo que debe teclear: 
</para>

<para>

<screen>
$ gcc hello.c
</screen>

</para>

<para>
lo que creará un fichero ejecutable llamado <literal remap="tt">a.out</literal>. Para cambiar el
nombre del ejecutable a otro nombre: 
</para>

<para>

<screen>
$ gcc -o hola hello.c
</screen>

</para>

<para>
Para enlazar una librería al programa, añada la opción
<literal remap="tt">-lnombre_de_librería</literal>. Por ejemplo, para enlazar la librería
<literal remap="tt">math</literal>:
</para>

<para>

<screen>
$ gcc -o mathprog mathprog.c -lm
</screen>

</para>

<para>
(<literal remap="tt">-lnombre_libreria</literal> fuerza a gcc a enlazar la librería
<literal remap="tt">/usr/lib/libnombre_librería.a</literal>; por lo tanto <literal remap="tt">-lm</literal> enlaza
<literal remap="tt">/usr/lib/libm.a</literal>). 
</para>

<para>
Bien. Pero cuando su programa está compuesto por varios ficheros de código
fuente, necesitará usar la utilidad <literal remap="tt">make</literal>. Supongamos que ha escrito
un evaluador de expresiones: su código fuente se denomina <literal remap="tt">parser.c</literal> e
tiene un <literal remap="tt">#include</literal> de dos ficheros en su cabecera: <literal remap="tt">parser.h</literal> y
<literal remap="tt">xy.h</literal>. Entonces, desea utilizar las rutinas de <literal remap="tt">parser.c</literal> en otro
programa, <literal remap="tt">calc.c</literal>, que hace un <literal remap="tt">#include</literal> de <literal remap="tt">parser.h</literal>. ¡Vaya
lío! ¿Cómo se puede compilar <literal remap="tt">calc.c</literal>? 
</para>

<para>
Debe escribir un fichero llamado <literal remap="tt">makefile</literal>, el cual muestra al
compilador las dependencias entre los ficheros de código fuente y los
ficheros de código objeto. En nuestro ejemplo: 
</para>

<para>

<screen>
# Este es el makefile, utilizado para compilar calc.c
# ¡Pulse la tecla &#60;TAB&#62; en las posiciones marcadas!

calc: calc.o parser.o
&#60;TAB&#62;gcc -o calc calc.o parser.o -lm
# calc depende de dos ficheros de codigo objeto: calc.o and parser.o

calc.o: calc.c parser.h
&#60;TAB&#62;gcc -c calc.c
# calc.o depende de dos ficheros de codigo fuente

parser.o:  parser.c parser.h xy.h
&#60;TAB&#62;gcc -c parser.c
# parser.o depende de tres ficheros de codigo fuente

# fin de makefile.
</screen>

</para>

<para>
Guarde esto como <literal remap="tt">makefile</literal> y teclee
</para>

<para>

<screen>
$ make
</screen>

</para>

<para>
para compilar su programa; alternativamente, guárdelo como <literal remap="tt">calc.mak</literal> y
teclee
</para>

<para>

<screen>
$ make -f calc.mak
</screen>

</para>

<para>
Y, por supuesto, LPM.
</para>

<para>
Puede pedir ayuda acerca de las funciones de C, que se encuentra en las
páginas <literal remap="tt">man</literal>, sección 3; por ejemplo:
</para>

<para>

<screen>
$ man 3 printf
</screen>

</para>

<para>
Hay muchas librerías disponibles por ahí; entre las primeras que deseará
usar están las <literal remap="tt">ncurses</literal>, para manejar efectos en modo de texto, y
<literal remap="tt">svgalib</literal>, para hacer gráficos. Si se siente suficientemente valiente
para atacar la programación de las X, consiga XForms (<literal remap="tt"><ulink
url="ftp://bloch.phys.uwm.edu/pub/xforms"
>bloch.phys.uwm.edu/pub/xforms</ulink
></literal>) y/o MGUI (<literal remap="tt"><ulink
url="http://www.volftp.vol.it/IT/IT/ITALIANI/MORELLO/index.htm"
>http://www.volftp.vol.it/IT/IT/ITALIANI/MORELLO/index.htm</ulink
></literal>),
dos fantásticas librerías que hacen de la programación bajo X algo
realmente fácil. Más aún, si no puede vivir sin un IDE al estilo Borland,
consiga el paquete <literal remap="tt">xwpe</literal> de <literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/apps/editors/"
>ftp://sunsite.unc.edu/pub/Linux/apps/editors/</ulink
></literal>. Posiblemente
sea de su agrado.
</para>

</sect2>

</sect1>

<sect1>
<title>El restante 1%</title>

<sect2>
<title>Gestión de Memoria Virtual</title>

<para>
Aunque Linux puede ejecutarse en teoría con sólo 2 megas de RAM, cuanto
más se tenga, más se puede hacer. El sistema X Window no se ejecutará a
menos que tenga 8 megas. Para crear una memoria virtual de 8 megas
adicionales, teclee como root: 
</para>

<para>

<screen>
# dd if=/dev/zero of=/swapfile bs=1024 count=8192
# mkswap /swapfile 8192
# sync
# swapon /swapfile
</screen>

</para>

<para>
Añada la última línea en <literal remap="tt">/etc/rc.d/rc.local</literal> para hacer que el
fichero de memoria virtual esté disponible la siguiente vez que arranque,
o añada esta línea en <literal remap="tt">/etc/fstab</literal>:
</para>

<para>

<screen>
/swapfile   swap   swap   defaults
</screen>

</para>

</sect2>

<sect2>
<title>Utilización de <literal remap="tt">tar</literal> y <literal remap="tt">gzip</literal></title>

<para>
Bajo Unix hay algunas aplicaciones ampliamente utilizadas para archivar y
comprimir ficheros. <literal remap="tt">tar</literal> se utiliza para archivar varios ficheros en
uno ---es como PKZIP o ARJ, pero no comprime, sólo archiva. Para archivar
varios ficheros en uno (que llamaremos archivo de ahora en adelante):
</para>

<para>

<screen>
$ tar -cvf &#60;nombre_fichero_final.tar&#62; &#60;fichero1&#62; [fichero2...]
</screen>

</para>

<para>
Para extraer ficheros de un archivo:
</para>

<para>

<screen>
$ tar -xpvf &#60;nombre_fichero.tar&#62; [fichero]
</screen>

</para>

<para>
Para listar los ficheros contenidos de un archivo:
</para>

<para>

<screen>
$ tar -tf &#60;nombre_fichero.tar&#62; | less
</screen>

</para>

<para>
Puede comprimir los ficheros usando <literal remap="tt">compress</literal>, el cual es obsoleto y no
debería ser utilizado nunca más, o usando <literal remap="tt">gzip</literal>: 
</para>

<para>

<screen>
$ compress &#60;fichero&#62;
$ gzip &#60;fichero&#62;
</screen>

</para>

<para>
eso crea un fichero comprimido con la extensión <literal remap="tt">.Z</literal> (compress) o
<literal remap="tt">.gz</literal> (gzip). Estos programas sólo pueden comprimir un fichero cada
vez. Para descomprimir, use:
</para>

<para>

<screen>
$ compress -d &#60;fichero.Z&#62;
$ gzip -d &#60;fichero.gz&#62;
</screen>

</para>

<para>
LPM.
</para>

<para>
Las utilidades <literal remap="tt">unarj</literal>, <literal remap="tt">zip</literal> y <literal remap="tt">unzip</literal> (compatibles con ARJ y
PK??ZIP) también están disponibles. Los ficheros con la extensión
<literal remap="tt">.tar.gz</literal> o <literal remap="tt">tgz</literal> (archivados con <literal remap="tt">tar</literal>, posteriormente
comprimidos con <literal remap="tt">gzip</literal>) son tan comunes en el mundo Unix como los
ficheros <literal remap="tt">.ZIP</literal> bajo DOS. Para listar los contenidos de un fichero
<literal remap="tt">.tar.gz</literal> utilice:
</para>

<para>

<screen>
$ gzip -dc &#60;fichero.tar.gz&#62; | tar tf - | less
</screen>

</para>

<para>
o también:
</para>

<para>

<screen>
$ tar -cvzf &#60;fichero.tar.gz&#62;
</screen>

</para>

</sect2>

<sect2>
<title>Instalación de aplicaciones</title>

<para>
Antes de nada: instalar paquetes es trabajo del root. Algunas aplicaciones
Linux se distribuyen como ficheros <literal remap="tt">.tar.gz</literal> o <literal remap="tt">.tgz</literal>, preparadas
específicamente para que sean descomprimidas desde el directorio raíz
<literal remap="tt">/</literal> escribiendo el siguiente comando: 
</para>

<para>

<screen>
# gzip -dc &#60;fichero.tar.gz&#62; | tar xvf -
</screen>

</para>

<para>
Los ficheros se descomprimirán en el directorio adecuado, el cual será
creado ``al vuelo''. Los usuarios de la distribución Slackware tienen un
programa gestor de paquetes amigable para el usuario; otro programa es
<literal remap="tt">rpm</literal>, el cual está disponible para todas las distribuciones gracias a
Red Hat. 
</para>

<para>
Los demás paquetes no deberían ser instalados desde <literal remap="tt">/</literal>; 
típicamente, el paquete contendrá un directorio llamado
<literal remap="tt">nombrepaquete/</literal> y un montón de ficheros y/o subdirectorios dentro
de <literal remap="tt">nombrepaquete/</literal>. Una buena regla es instalar todos esos
paquetes bajo <literal remap="tt">/usr/local</literal>. 
</para>

<para>
Además, otros paquetes se distribuyen con sus fuentes en C o C++, los
cuales han de ser compilados para crear los programas binarios. En la
mayor parte de los casos, todo lo que debe hacer es ejecutar <literal remap="tt">make</literal>.
Obviamente, necesitará el compilador <literal remap="tt">gcc</literal>. 
</para>

</sect2>

<sect2>
<title>Trucos imprescindibles</title>

<para>

<itemizedlist>
<listitem>

<para>
<emphasis remap="bf">Terminación de comandos</emphasis>: presionando <literal remap="tt">TAB</literal>
mientras teclea un comando completará la línea por usted. Ejemplo: tiene
que teclear <literal remap="tt">gcc este_es_un_nombre_de_fichero_largo.c</literal>; con teclear
<literal remap="tt">gcc este TAB</literal> bastará. (Si tiene otros ficheros que comienzan con los
mismos caracteres, proporcione los caracteres suficientes para resolver
cualquier ambigüedad.) 

</para>
</listitem>
<listitem>

<para>
<emphasis remap="bf">Visión de pantallas anteriores</emphasis>: presionar <literal remap="tt">MAYÚS + RE PÁG</literal>
(la tecla gris) le permite volver atrás unas cuantas páginas, dependiendo
de la memoria de vídeo que posea. 

</para>
</listitem>
<listitem>

<para>
<emphasis remap="bf">Resetear la pantalla</emphasis>: si por un casual hace un <literal remap="tt">cat</literal> o un
<literal remap="tt">more</literal> de un fichero binario, su pantalla puede acabar llena de basura.
Para arreglar las cosas, teclee <literal remap="tt">reset</literal> a ciegas o pulse esta secuencia
de caracteres: <literal remap="tt">echo CTRL-V ESC c RETURN</literal>.

</para>
</listitem>
<listitem>

<para>
<emphasis remap="bf">Pegar texto</emphasis>: en consola, ver más abajo; en las X, haga click y
arrastre para seleccionar el texto en una ventana xterm, después haga
click en el botón central (o con los dos a la vez si tiene un ratón de dos
botones) para pegar. También hay un <literal remap="tt">xclipboard</literal> (portapapeles de X) 
(de momento, sólo para texto); no se confunda por su muy baja velocidad de
respuesta. 

</para>
</listitem>
<listitem>

<para>
<emphasis remap="bf">Usar el ratón</emphasis>: instale <literal remap="tt">gpm</literal>, el controlador de ratón para
la consola. Haga click y arrastre para seleccionar texto, entonces haga un
click con el botón derecho para pegar el texto seleccionado. Funciona a
través de diferentes consolas virtuales. 

</para>
</listitem>
<listitem>

<para>
<emphasis remap="bf">Mensajes del kernel</emphasis>: échele un vistazo a
<literal remap="tt">/var/adm/messages</literal> o <literal remap="tt">/var/log/messages</literal> como root para ver
lo que el kernel le dice, incluyendo los mensajes de inicio. 
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Programas y comandos útiles</title>

<para>
Esta lista refleja mis preferencias y necesidades personales, por
supuesto. En primer lugar, dónde encontrarlas. Ya que usted sabe cómo
navegar por la red y cómo utilizar <literal remap="tt">archie</literal> y <literal remap="tt">ftp</literal>, sólo le daré
tres de las más importantes direcciones para Linux: <literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/"
>ftp://sunsite.unc.edu/</ulink
></literal>,
<literal remap="tt"><ulink
url="ftp://tsx-11.mit.edu/"
>ftp://tsx-11.mit.edu/</ulink
></literal>, y <literal remap="tt"><ulink
url="ftp://nic.funet.fi/"
>ftp://nic.funet.fi/</ulink
></literal>. Por favor, use
el mirror más cercano. 
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">at</literal> le permite ejecutar programas a una hora y fecha
especificados. 

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">awk</literal> es un lenguaje simple pero potente de manipulación de
ficheros de datos (entre otras cosas). Por ejemplo, siendo <literal remap="tt">datos.dat</literal>
su fichero de datos multicampo,


<screen>
$ awk '$2 ~ "abc" {print $1, "\t", $4}' datos.dat
</screen>


imprime los campos 1 y 4 de cada linea de <literal remap="tt">datos.dat</literal> cuyo segundo
campo contenga ``<literal remap="tt">abc</literal>''.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">delete-undelete</literal> borran y recuperan ficheros; 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">df</literal> da información acerca de los discos montados;

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">dosemu</literal> permite ejecutar bastantes (no todos) programas DOS
---incluyendo Windows 3.x--- con un poco de trasteo;

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">file nombrefichero</literal> le dice qué tipo de fichero es
<literal remap="tt">nombrefichero</literal> (texto ASCII, ejecutable, comprimido, etc.);

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">find</literal> (ver también la sección <xref linkend="Directorios"/>) es uno de
los comandos más potentes y útiles. Se utiliza para buscar ficheros que se
ajusten a unas determinadas características, y realizar acciones sobre
ellos. El uso general de <literal remap="tt">find</literal> es:


<screen>
$ find &#60;directorio&#62; &#60;expresion&#62;
</screen>


donde <literal remap="tt">expresion</literal> incluye criterios de búsqueda y acciones. Ejemplos:


<screen>
$ find . -type l -exec ls -l {} \;
</screen>


busca todos los ficheros que son enlaces simbólicos y dice a dónde
apuntan. 


<screen>
$ find / -name "*.old" -ok rm {} \;
</screen>


busca todos los ficheros que se ajusten a lo especificado y los borra,
pidiéndole antes confirmación. 


<screen>
$ find . -perm +111
</screen>


busca todos los ficheros cuyos permisos sean <literal remap="tt">111</literal> (ejecutables para
todos).


<screen>
$ find . -user root
</screen>


busca todos los ficheros que pertenecen al root. Hay muchas
posibilidades: LPM. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">gnuplot</literal> es un brillante programa para dibujos científicos; 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">grep</literal> busca cadenas de texto en ficheros. Por ejemplo: 


<screen>
$ grep -l "geologia" *.tex
</screen>


lista todos los ficheros <literal remap="tt">*.tex</literal> que contienen la palabra
<literal remap="tt">geologia</literal>. La variante <literal remap="tt">zgrep</literal> trabaja en ficheros comprimidos con
gzip. LPM;

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">gzexe</literal> comprime binarios ejecutables manteniéndolos ejecutables
(similar a PKLITE); 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">joe</literal> es un excelente editor. Invocándolo tecleando <literal remap="tt">jstar</literal>
conseguirá los mismos caracteres de teclado que WordStar y sus
descendientes, incluyendo DOS y los editores Turbo... de Borland; 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">less</literal> es, probablemente, el mejor navegador de texto, y si está
adecuadamente configurado, permite navegar por ficheros <literal remap="tt">zip</literal>, <literal remap="tt">tar</literal>
o <literal remap="tt">gzip</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">lpr fichero</literal> imprime un fichero en segundo plano. Para comprobar
el estado de la cola de impresión, use <literal remap="tt">lpq</literal>; para quitar un fichero de
la cola de impresión, use <literal remap="tt">lprm</literal>;

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">mc</literal> es un maravilloso gestor de ficheros, clon del
<emphasis remap="it">comandante norton</emphasis>;

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">pine</literal> es un simpático programa gestor de correo electrónico; 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">script fichero_script</literal> copia a <literal remap="tt">fichero_script</literal> lo que
aparece en pantalla antes de ejecutar el comando exit. Util para
depuración;

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">sudo</literal> permite a los usuarios ejecutar algunas funciones del root
(p.e. formatear y montar discos; LPM); 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">uname -a</literal> da información acerca del sistema;

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">zcat</literal> y <literal remap="tt">zless</literal> son útiles para ver ficheros de texto
comprimidos con <literal remap="tt">gzip</literal> sin descomprimirlos. Un posible uso es: 


<screen>
$ zless ficherotexto.gz
$ zcat ficherotexto.gz | lpr
</screen>


</para>
</listitem>
<listitem>

<para>
 Los siguientes comandos son a menudo utilizados: <literal remap="tt">bc, cal, chsh,
cmp, cut, fmt, head, hexdump, nl, passwd, printf, sort, split, strings,
tac, tail, tee, touch, uniq, w, wall, wc, whereis, write, xargs, znew</literal>.
LPM. 
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Extensiones comunes y programas relacionados</title>

<para>
Se podrá encontrar con una gran variedad de extensiones de ficheros. 
Excluyendo los más exóticos (como los de fuentes, etc.), aquí tenemos una
lista de los más usuales: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">1 ... 8</literal>: páginas de manual. En el extraño caso en que aún
no lo tenga, consiga <literal remap="tt">man</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">arj</literal>: archivo hecho con <literal remap="tt">arj</literal>. Use <literal remap="tt">unarj</literal> para
descomprimirlo. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">dvi</literal>: fichero de salida producido por TeX (ver más abajo).
Use <literal remap="tt">xdvi</literal> para visualizarlo; Use <literal remap="tt">dvips</literal> para transformarlo en un
fichero PostScript (<literal remap="tt">.ps</literal>). 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">gif</literal>: fichero gráfico. Consiga <literal remap="tt">seejpeg</literal>, <literal remap="tt">xpaint</literal> o
<literal remap="tt">zgv</literal> para visualizarlo. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">gz</literal>: archivo comprimido con <literal remap="tt">gzip</literal>.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">info</literal>: archivo <emphasis>info</emphasis> (Algo así como una alternativa a
las páginas de manual). Consiga <literal remap="tt">info</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">jpg, jpeg</literal>: fichero gráfico. Consiga <literal remap="tt">seejpeg</literal> o
<literal remap="tt">zgv</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">lsm</literal>: Fichero <emphasis>Linux Software Map</emphasis>. Es un fichero de
texto ASCII plano que contiene la descripción de un paquete. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">ps</literal>: Fichero PostScript. Para visualizarlo o imprimirlo
consiga <literal remap="tt">gs</literal> y, opcionalmente, <literal remap="tt">ghostview</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">rpm</literal>: Paquete de Red Hat. Puede instalarlo en cualquier
sistema utilizando el gestor de paquetes <literal remap="tt">rpm</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">taz, tar.Z</literal>: archivo hecho con <literal remap="tt">tar</literal> y posteriormente
comprimido con <literal remap="tt">compress</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">tgz, tar.gz</literal>: archivo hecho con <literal remap="tt">tar</literal> y posteriormente
comprimido con <literal remap="tt">gzip</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">tex</literal>: fichero de texto para utilizar con TeX, un poderoso
formateador de textos. Consiga el paquete <literal remap="tt">tex</literal>, disponible en muchas
distribuciones; pero tenga cuidado con NTeX, el cual tenía fuentes
corruptas y estaba incluido en algunas versiones de la distribución
Slackware. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">texi</literal>: fichero texinfo, a partir del cual se pueden producir
tanto archivos TeX como info. Consiga <literal remap="tt">texinfo</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">xbm, xpm, xwd</literal>: fichero gráfico. Consiga <literal remap="tt">xpaint</literal>.

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">Z</literal>: archivo hecho con <literal remap="tt">compress</literal>.

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">zip</literal>: archivo hecho con <literal remap="tt">zip</literal>. Consiga <literal remap="tt">zip</literal> y <literal remap="tt">unzip</literal>.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

</sect1>

<sect1>
<title>Fin, por ahora</title>

<para>
¡Felicidades! Se ha iniciado un poco en el Unix y está preparado para
comenzar a trabajar. Recuerde que su conocimiento del sistema es aún
limitado, y que se espera que practique más con Linux para usarlo
cómodamente. Pero si todo lo que quería hacer era conseguir un puñado de
aplicaciones y empezar a trabajar con ellas, apuesto a que lo que se
incluyó aquí fue suficiente. 
</para>

<para>
Estoy seguro de que habrá disfrutado de usar Linux y seguirá aprendiendo
más acerca de él ---todo el mundo lo hace---. Apuesto, también, que nunca
volverá al DOS. Espero haberme hecho entender y haber realizado un buen
servicio a mis 3 o 4 lectores. 
</para>

<sect2>
<title>Copyright</title>

<para>
A menos que se establezca lo contrario, los documentos COMO de Linux
tienen copyright de sus respectivos autores. Los documentos COMO de Linux
pueden ser reproducidos y distribuidos de manera completa o en parte, en
cualquier medio físico o electrónico, siempre y cuando este aviso de
copyright se mantenga en todas las copias. Se permite y se anima a la
redistribución comercial; sin embargo, al autor le gustaría ser notificado
de cualquier distribución. 
</para>

<para>
Todas las traducciones, trabajos derivados o agregados que incorporen
cualquier documento COMO de Linux debe ser mantenido bajo este aviso de
Copyright. Esto es, no puede producir un trabajo derivado de un documento
COMO e imponer restricciones adicionales a su distribución. Excepciones a
estas reglas pueden ser concedidas bajo ciertas condiciones;  por favor,
contacte con el coordinador de los COMO de Linux en la dirección dada más
abajo. 
</para>

<para>
En resumen, deseamos promocionar la dispersión de esta información a través
de cuantos canales sea posible. Sin embargo, deseamos retener el copyright
de los documentos COMO, y nos gustaría tener noticias de cualquier plan de
redistribuir los COMOs. 
</para>

<para>
Si tiene dudas, contacte con Greg Hankins, el coordinador de Linux HOWTO,
en <literal remap="tt"><ulink
url="mailto:gregh@sunsite.unc.edu"
>gregh@sunsite.unc.edu</ulink
></literal> vía e-mail.
</para>

</sect2>

</sect1>

<sect1>
<title>Agradecimientos</title>

<para>
"DOS-to-Linux-HOWTO" fue escrito por Guido Gonzato, <literal remap="tt"><ulink
url="mailto:guido@ibogfs.df.unibo.it"
>guido@ibogfs.df.unibo.it</ulink
></literal>. Muchas gracias a Matt Welsh, el
autor de "<emphasis remap="it">Linux: Instalación y Primeros Pasos</emphasis>", a Ian Jackson, el
autor de "<emphasis remap="it">Linux frequently asked questions with answers</emphasis>", a Giuseppe
Zanetti, el autor de "Linux", a todos los amigos que me enviaron
sugerencias, y especialmente a Linus Torvalds y GNU que nos trajeron
Linux. 
</para>

<para>
Este documento se distribuye "tal cual". He puesto un gran esfuerzo en
escribirlo tan correctamente como he podido. Pese a ello, la información
contenida en el mismo debe ser utilizada bajo su propia responsabilidad. 
En ningún caso el autor será responsable de cualquier daño resultante del
uso de este documento. 
</para>

<para>
El correo es bienvenido. Para cualquier duda, sugerencia, crítica, etc.,
siéntase libre de contactar conmigo. 
</para>

<para>
Disfrute de Linux y de la vida,
</para>

<para>
Guido   <literal remap="tt">=8-)</literal>					
</para>

<sect2>
<title>Traducción</title>

<para>
"<emphasis remap="it">CÓMO pasar de DOS a LINUX</emphasis>" fue traducido por David Martín Carreño,
<literal remap="tt"><ulink
url="mailto:davefx@bigfoot.com"
>davefx@bigfoot.com</ulink
></literal>, como un pequeño grano de arena más dentro
del Proyecto INSFLUG. Para más información, vea la sección <xref linkend="Grupos"/>.
</para>

<para>
He intentado una traducción fidedigna del documento original de Guido,
aunque en algunos lugares haya actualizado información o cambiado algunas
expresiones por otras más adecuadas a la jerga en nuestro idioma. 
</para>

<para>
Si desea plantear alguna duda, sugerencia o crítica, pues tampoco dude en
contactar conmigo. 
</para>

<para>
David!! 3B-)
</para>

</sect2>

</sect1>

<sect1 id="Grupos">
<title>Anexo: El INSFLUG </title>

<para>
El <emphasis>INSFLUG</emphasis> forma parte del grupo internacional 
<emphasis remap="it">Linux Documentation Project</emphasis>, 
encargándose de las traducciones al castellano de los Howtos (Comos),
así como la producción de documentos originales en aquellos casos
en los que no existe análogo en inglés.
</para>

<para>
En el <emphasis remap="bf">INSFLUG</emphasis> se orienta preferentemente a la traducción de documentos
breves, como los <emphasis>COMOs</emphasis> y <emphasis>PUFs</emphasis> (<emphasis remap="bf">P</emphasis>reguntas de
<emphasis remap="bf">U</emphasis>so <emphasis remap="bf">F</emphasis>recuente, las <emphasis remap="it">FAQs</emphasis>. <literal remap="tt">:)</literal> ), etc.
</para>

<para>
Diríjase a la sede del INSFLUG para más información al respecto.
</para>

<para>
En la sede del INSFLUG encontrará siempre las <emphasis remap="bf">últimas</emphasis> versiones 
de las traducciones:  <literal remap="tt"><ulink
url="http://www.insflug.org"
>www.insflug.org</ulink
></literal>. Asegúrese de comprobar cuál es la última versión 
disponible en el Insflug antes de bajar un documento de un servidor réplica.
</para>

<para>
Se proporciona también una lista de los servidores
réplica (<emphasis remap="it">mirror</emphasis>) del Insflug más cercanos a Vd.,  
e información relativa a otros recursos en castellano.
</para>

<para>
Francisco José Montilla, <literal remap="tt"><ulink
url="mailto:pacopepe@insflug.org"
>pacopepe@insflug.org</ulink
></literal>.
</para>

</sect1>

</article>
