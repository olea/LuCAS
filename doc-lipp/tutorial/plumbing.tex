% \linux: Instalación y primeros pasos    -*- TeX -*-
% plumbing.tex
% Copyright (c) 1992, 1993 by Matt Welsh, Larry Greenfield and Karl Fogel
%
% Este fichero puede redistribuirse libremente, pero debe conservarse este distintivo 
% de copyright en todas las copias, y sólo debe ser distribuido como parte de 
% "\linux: Instalación y primeros pasos". El uso de este archvi está cubierto por el 
% copyright para todo el documento, en el fichero "copyright.tex".
%
% Copyright (c) 1998 by Specialized Systems Consultants Inc. 
% <ligs@ssc.com>
%Revisión 1 por Francisco Javier Fernández
%Revisión 2 por Fco. J Fernández  el 9 de septiembre de 2002
%\section{\linux plumbing.} \label{sec-plumbing}
\section{Fontanería \linux} 
\label{sec-plumbing}
\markboth{Tutorial de  {\linux} }{Fontanería {\linux}}

%\subsection{Standard input and standard output.}
\subsection{Entrada y salida estándar.}
\index{standard input|(}
\index{standard output|(}
\index{stdin}
\index{stdout}
\index{entrada estándar}
\index{salida estándar}

Muchas instrucciones de {\linux} toman la entrada de lo que se llama {\bf standard input}
y mandan su salida a  {\bf standard output} (a menudo abreviados como
{\tt stdin} y {\tt stdout}). El intérprete de órdenes arregla las cosas de forma que la entrada
estándar es su teclado y la salida estándar es la pantalla.

He aquí un ejemplo en el que se usa la orden {\tt cat}. Normalmente, 
{\tt cat} lee datos de todos los argumentos especificados por la línea de 
órdenes y manda estos datos directamente a {\tt stdout}. Por tanto 
usando la orden 
\begin{tscreen}
/home/larry/papers\# cat history-final masters-thesis
\end{tscreen}
se muestra el contenido del fichero {\tt history-final} seguido por 
{\tt masters-thesis}. 

Sin embargo, si no especifica un nombre de fichero, {\tt cat} lee datos 
de {\tt stdin} y los devuelve a {\tt stdout}. Aquí hay un ejemplo:
\begin{tscreen}
/home/larry/papers\# cat \\
Hello there. \\
Hello there. \\
Bye. \\
Bye. \\
\key{Ctrl-D} \\
/home/larry/papers\# 
\end{tscreen}
\index{señal de fin-de-texto}
\index{EOT!señal}
Cada línea que escriba será repetida inmediatamente por {\tt cat}. Cuando 
se lee de la entrada estándar, se le indica que la entrada ha "finalizado" 
enviando una señal EOT (end-of-text , final de texto), que se genera 
pulsando \key{Ctrl-D}.

% By the way, guys, there's no such thing as an EOF character in UNIX. The
% terminal signal to signal EOT (end of text) is usually ^D. Files on
% disk don't have a terminating EOF as MS-DOS files do. The data just
% ends, and the read() call signals the end of data. :) --mdw

He aquí otro ejemplo. La orden {\tt sort} lee líneas de texto (de nuevo, 
de stdin, a no ser que le especifique uno o más nombres de ficheros) y manda
la salida ordenada a stdout. Pruebe lo siguiente.

\begin{tscreen}
/home/larry/papers\# sort \\
bananas \\
zanahorias \\
manzanas \\
\key{Ctrl-D} \\
bananas \\
manzanas \\
zanahorias \\
/home/larry/papers\# 
\end{tscreen}
Ahora ya podemos ordenar por orden alfabético la lista de la compra, 
¿verdad que {\linux} es útil?

%subsection{Redirecting input and output.}
\subsection{Redireción de la  entrada y la salida}
\index{redirección!entrada estándar}
\index{redirección!salida estándar}
\index{salida!redirección}
\index{salida estándar!redirección}
\index{>@{\tt \verb'>'}}
Ahora, digamos que quiere mandar la salida de {\tt sort} a un fichero, 
para guardar nuestra lista de la compra en el disco. El intérprete de órdenes le permite 
{\bf redireccionar} la salida estándar a un nombre de fichero, usando el 
símbolo ``{\tt {\verb'>'}}''. Aquí está cómo funciona:
\begin{tscreen}
/home/larry/papers\# sort $>$ listacompra \\
bananas \\
zanahorias \\
manzanas \\
\key{Ctrl-D} \\
/home/larry/papers\# 
\end{tscreen}
Como puede ver, el resultado de la orden {\tt sort} no se visualiza, 
pero se guarda en el fichero llamado {\tt listacompra}.
Veamos este fichero:
\begin{tscreen}
/home/larry/papers\# cat listacompra \\
bananas \\
manzanas \\
zanahorias \\
/home/larry/papers\# 
\end{tscreen}
Ahora puede ordenar su lista de la compra ¡y guardarla también!. Pero 
supongamos que está guardando la lista de la compra original sin ordenar 
en el fichero {\tt items}. Un modo de ordenar la información y guardarla 
en un fichero sería darle a {\tt sort} el nombre del fichero a ser leído, 
en lugar de la entrada estándar, y redireccionar la salida estándar como 
lo hicimos arriba, como sigue:
\begin{tscreen}
/home/larry/papers\# sort items $>$ listacompra \\
/home/larry/papers\# cat listacompra \\
bananas \\
manzanas \\
zanahorias \\
/home/larry/papers\# 
\end{tscreen}
\index{entrada!redirección}
\index{entrada estándar!redirección}
\index{<@{\tt \verb'<'}}
Sin embargo, hay otra forma de hacer esto. No sólo puede 
redireccionar la salida estándar, también puede redireccionar la 
{\em entrada} estándar, usando el símbolo ``{\tt \verb'<'}''.
\begin{tscreen}
/home/larry/papers\# sort $<$ items \\
bananas \\
manzanas \\
zanahorias \\
/home/larry/papers\# 
\end{tscreen}
Técnicamente, {\tt sort \verb'<' items} es equivalente a {\tt sort items}, pero
vamos a demostrar lo siguiente: {\tt sort \verb'<' items} se comporta como si los
datos del fichero {\tt items} fueran tecleados a la entrada estándar. El intérprete de órdenes 
maneja el redireccionamiento. A {\tt sort} no se le dió el nombre del fichero 
({\tt items}) a leer; en lo que concierne a {\tt sort}, él todavía lee de la 
entrada estándar como si hubiera tecleado los datos desde su teclado.

\index{filtros!definición}

Esto introduce el concepto de {\bf filtro}. Un filtro es un programa que 
lee datos de la entrada estándar, los procesa de alguna forma, y manda 
los datos procesados a la salida estándar. Usando la redirección, la
entrada y salida estándar pueden ser referenciadas desde ficheros. Como se 
mencionó más arriba {\tt stdin} y {\tt stdout} son por omisión el teclado 
y la pantalla respectivamente. El programa {\tt sort} es un filtro simple. Ordena 
los datos entrantes y manda el resultado a la salida estándar. Más sencillo 
aún es {\tt cat}. No hace nada con los datos entrantes,  sólo devuelve
todo lo que se le entrega.

%\subsection{Using pipes.}
\subsection{Uso de tuberías}

\index{tuberías (pipes)!uso|(}
Ya mostramos como usar {\tt sort} como un filtro. Sin embargo, 
estos ejemplos dan por hecho que usted tiene los datos guardados en
alguna parte o que tecleará los datos desde la entrada estándar. ¿Qué
pasa si los datos que quiere ordenar vienen de la salida de otro programa,
como {\tt ls}? 

La opción {\tt -r} de {\tt sort} ordena los datos en orden alfabético 
inverso. Si quiere listar los ficheros de su directorio actual en orden 
inverso una forma de hacerlo es como sigue:
\begin{tscreen}
/home/larry/papers\# ls \\
english-list \\
history-final \\
masters-thesis \\
notes \\
\end{tscreen}
Ahora el redireccionamiento envía la salida de la orden {\tt ls} a un fichero llamado 
{\tt file-list}:
\begin{tscreen}
/home/larry/papers\# ls $>$ file-list \\
/home/larry/papers\# sort -r file-list \\
notes \\
masters-thesis \\
history-final \\
english-list \\
/home/larry/papers\# 
\end{tscreen}
Aquí, usted guarda la salida de un {\tt ls} en un fichero, y luego ejecuta 
{\tt sort -r} con ese fichero. Pero esto es incómodo y usa un fichero 
temporal para guardar los datos de {\tt ls}.

\index{pipelining!definición}
\index{canales!creación}
\index{canalización!definición}
La solución es la {\bf canalización}\NT{pipelining}. Ésta es una posibilidad del intérprete de órdenes, 
que conecta una serie de órdenes mediante una ``tubería.''  La 
{\tt stdout} del primer programa se envía a la {\tt stdin} del segundo 
programa. En este caso, queremos enviar la {\tt stdout} de {\tt ls} a la {\tt
stdin} de {\tt sort}.  Se utiliza el símbolo ``{\tt |}'' para crear una tubería, 
como sigue:
\begin{tscreen} 
/home/larry/papers\# ls $\mid$ sort -r \\
notes \\
masters-thesis \\
history-final \\
english-list \\
/home/larry/papers\# 
\end{tscreen}
Este programa es más corto y más fácil de teclear.

He aquí otro útil ejemplo, la orden
\begin{tscreen}
/home/larry/papers\# ls /usr/bin 
\end{tscreen}
muestra una lista larga de ficheros, la mayoría de los cuáles
salen de la pantalla demasiado rápido como para que lo pueda leer.
Así que, usamos {\tt more} para mostrar la lista de ficheros de 
{\tt /usr/bin}.
\begin{tscreen}
/home/larry/papers\# ls /usr/bin $\mid$ more 
\end{tscreen}
Ahora ya puede paginar las lista de ficheros cómodamente.

¡Pero lo mejor no termina aquí! Puede hacer canalizaciones entre más de dos 
programas juntos. El programa {\tt head} es un filtro que muestra las 
primeras líneas de un flujo entrante (en este caso, entrada de una 
canalización). Si quiere mostrar el último nombre de fichero en orden 
alfabético del directorio actual, use estas órdenes:
\begin{tscreen}
/home/larry/papers\# ls $\mid$ sort -r $\mid$ head -1 \\
notes \\
/home/larry/papers\# 
\end{tscreen}
donde {\tt head -1} muestra la primera línea de entrada que recibe (en 
este caso, el flujo de datos ordenados inversamente de {\tt ls}). 
\index{tuberías (pipes)!uso|)}

%\subsection{Non-destructive redirection of output.}
\subsection{Redirección no destructiva de la salida}
\index{ficheros!añadiendo a}
\index{redirección!no destructiva}
Usar ``{\tt {\verb'>'}}'' para redireccionar la salida a un fichero es destructivo: 
en otras palabras, la orden:
\begin{tscreen}
/home/larry/papers\# ls $>$ file-list
\end{tscreen}
sobreescribe el contenido del fichero {\tt file-list}. Si en su lugar, 
redirecciona con el símbolo ``{\tt {\verb'>>'}}'', la salida será concatenada 
al final del fichero, en vez de sobreescribirlo. Por ejemplo,
\begin{tscreen}
/home/larry/papers\# ls $>>$ file-list
\end{tscreen}
añade la salida de la orden {\tt ls} a {\tt file-list}.

Tenga presente que el redireccionamiento y las canalizaciones son características 
del intérprete de órdenes, que da soporte al uso de ``{\tt {\verb'>'}}'', ``{\tt {\verb'>>'}}'' y 
``{\tt {\verb'|'}}''. No tiene nada que ver con las órdenes propiamente dichas.

\index{estrada estándar|)}
\index{salida estándar|)}
% Need to cover use of << and possibly use of stderr. Problem with 
% covering stderr is that it's different in different shells. Maybe later.

