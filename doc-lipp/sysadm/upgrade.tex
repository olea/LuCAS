% Linux Installation and Getting Started    -*- TeX -*-
% upgrade.tex
% Copyright (c) 1992, 1993 by Matt Welsh <mdw@sunsite.unc.edu>
%
% This file is freely redistributable, but you must preserve this copyright 
% notice on all copies, and it must be distributed only as part of "Linux 
% Installation and Getting Started". This file's use is covered by the 
% copyright for the entire document, in the file "copyright.tex".
%
% Copyright (c) 1998 by Specialized Systems Consultants Inc. 
% <ligs@ssc.com>
%
% Traducción al español:
% Sebastián Gurin, <Cancerbero>, anon@adinet.com.uy
% Traducido el 28/02/01  
% Revisado el 7/7/2002 por Francisco Javier Fernandez <serrador@arrakis.es>
% La revisión exige la contrastación intensiva con los originales para resolver ciertos pasajes dudosos o de difícil solución.

\section{Actualizando e instalando software nuevo}
\markboth{Administración del sistema}{Actualizando e instalando software nuevo}
\label{sec-sysadm-upgrade}

\index{software!actualizar|(}
\index{software!instalar|(}
Otra de las responsabilidades  del administrador del sistema, es la actualización e instalación de nuevo software. 

El desarrollo del sistema {\linux} es rápido. Cada pocas semanas aparecen versiones nuevas del
núcleo, y los demás programas se actualizan casi tan a menudo. Por esto, los usuarios nuevos de {\linux},
sienten la necesidad de actualizar sus sistemas constantemente, para
mantenerse, así, al rápido paso de los cambios. Esto es innecesario y
una pérdida de tiempo: si estuvieras todo el tiempo siguiendo el ritmo
de los cambios que ocurren en el mundo de GNU/Linux, se gastaría todo el
tiempo actualizando y nada del tiempo usando el sistema. 

Algunas personas consideran que se debería actualizar el sistema,
solamente cuando una nueva distribución es mostrada al público; por
ejemplo, cuando se presenta una nueva versión de Slackware. Entonces,
muchos usuarios de {\linux}, a la hora de actualizar sus sistemas,
reinstalan todo el software, usando la distribución Slackware más nueva. 

La mejor manera de actualizar el sistema, depende del tipo de
distribución que se posea. Debian\tm, S.u.S.E.\tm, Caldera\tm y Red Hat
Linux\tm tienen, todos, gestores inteligentes de paquetes de software,
los cuales permiten realizar las actualizaciones mucho más fácilmente,
instalando paquetes nuevos. Por ejemplo, el compilador de C, {\tt gcc},
viene en un paquete binario, pre-compilado. Cuando se instala,
todos los ficheros de la versión antigua se sobreecriben o se eliminan. 

Como casi siempre pasa, actualizar insensatamente para "mantenerse a
la moda", no es importante en absoluto. ¡Esto no es MS-DOS o Microsoft
Windows!. No existe ninguna razón importante, para usar la versión más
reciente de todo el software. Ahora bien, si se siente que se quieren o 
necesitan características que una versión nueva ofrece, entonces hay 
que actualizar. Si no, no actualice. En otras palabras, actualizar sólo
lo que se deba, cuando se deba. No actualizar sólo por actualizar. 
Esto consume mucho tiempo y esfuerzo. 

\subsection{Actualizando el núcleo}
\index{núcleo!actualizar}

Actualizar el núcleo es sólo un asunto de obtener las fuentes del núcleo y
compilarlas. Esto es generalmente un proceso sin dificultad; 
sin embargo, uno puede tener problemas si trata de actualizar a
un núcleo en desarrollo, o actualizarlo a una nueva versión. 
La versión de un núcleo tiene dos partes: la
versión del núcleo, y el nivel del parche. Cuando esto fue escrito, la
última versión estable del núcleo era la {\tt 2.0.33}. Los números
{\tt 2.0} representan la versión del núcleo, y los números {\tt 33} es
el nivel del parche. Las versiones del núcleo señaladas con números
impares, por ejemplo {\tt 2.1} son núcleos en desarrollo. Manténgase
lejos de este tipo de núcleos, ¡a menos que quiera vivir peligrosamente!
Como regla general, uno debería ser capaz
de actualizar su núcleo fácilmente a otro nivel de parche; sin
embargo, actualizar a una nueva versión requiere, a su vez, la
actualización de las utilidades del sistema  que interactúan íntimamente con el núcleo. 

\index{núcleo!fuentes del}
El código fuente del núcleo Linux puede ser obtenido de cualquiera
de los servidores FTP de {\linux}, (ver la página~\pageref{app-ftp} para una lista de ellos).
En {\tt sunsite.unc.edu}, por ejemplo, las fuentes del núcleo se encuentran en 
{\tt /pub/Linux/kernel}, organizado
en subdirectorios por número de versión. 

El código fuente del núcleo es publicado en un fichero tar comprimido
con gzip. Por ejemplo, el fichero que contiene el código fuente del
núcleo 2.0.33 es {\tt linux-2.0.33.tar.gz}

Las fuentes del núcleo deberán descomprimirse y desempaquetarse en
el directorio {\tt /usr/src}, creando el directorio {\tt
  /usr/src/linux}. Es una costumbre común que, {\tt /usr/src/linux} sea
un enlace blando a otro directorio que contenga el número de versión
del núcleo, tal como {\tt /usr/src/GNU/Linux-2.0.33}. De esta manera, se
podrán instalar nuevos códigos fuente y verificar su correcto
funcionamiento, antes de eliminar los fuentes del núcleo antiguo. Las
ordenes para crear el enlace al directorio donde se aloja el código
fuente del núcleo son:

\begin{tscreen}
\# cd /usr/src \\
\# mkdir linux-2.0.33 \\
\# rm -r linux \\
\# ln -s linux-2.0.33 linux \\
\# tar xzf linux-2.0.33.tar.gz
\end{tscreen}

Cuando se actualiza a un nuevo nivel de parche de la misma versión del
núcleo, un fichero de nivel de parche puede resultar en un ahorro de 
tiempo en la transferencia de ficheros, puesto que las fuentes del 
núcleo tienen un tamaño alrededor de los 7 Mb. tras ser comprimidas 
con {\tt gzip}. Para actualizar del
núcleo 2.0.31 al núcleo 2.0.33, habría que descargar los parches
{\tt patch-2.0.32.gz} y {\tt patch-2.0.33.gz}, los cuales pueden encontrarse 
en el mismo servidor FTP de las fuentes del núcleo. Tras haber
ubicado los parches en el directorio {\tt /usr/src/}, se deben
aplicar en las fuentes del núcleo, uno tras otro para actualizar el
código fuente. Una forma de hacer esto sería

\begin{tscreen}
\# cd /usr/src \\
\# gzip -cd patch-2.0.32.gz $\mid$ patch -p0 \\
\# gzip -cd patch-2.0.33.gz $\mid$ patch -p0
\end{tscreen}

Después de desempaquetar los fuentes y de aplicar los parches,
necesitará asegurarse de que existan tres enlaces
simbólicos en {\tt /usr/include}, los cuáles son justo los que
necesita el núcleo de su distribución. Para crear dichos enlaces,
se podrán usar las órdenes
\begin{tscreen}
\# cd /usr/include \\
\# rm -rf asm linux scsi \\
\# ln -s /usr/src/linux/include/asm-i386 asm \\
\# ln -s /usr/src/linux/include/linux linux \\
\# ln -s /usr/src/linux/include/scsi scsi
\end{tscreen}

Después de que haya creado los enlaces, no existe ninguna razón para
que deba crearlos nuevamente la próxima vez que se instale el siguiente
parche, o una nueva versión del núcleo. (Para más información sobre
enlaces simbólicos: ver sección~\ref{sec-manage-links})


\index{núcleo!compilación}
A fin de compilar el núcleo, habrá que tener el compilador de C {\tt
  gcc} instalado en su sistema. Para compilar la versión 2.0 del
núcleo, se requiere el {\tt gcc}, versión 2.6.3 o más reciente. 

Primero cambie de directorio a  {\tt /usr/src/linux}. La orden
{\tt make config} irá preguntando por un número de opciones de
configuración. Éste es el paso dónde se selecciona el hardware al que
el núcleo podrá dar soporte. La equivocación más grande a evitar, es
no incluir soporte parar el/los controlador/es del/los disco/s
duro/s. Sin el correcto soporte para el disco duro en el núcleo, el
sistema ni siquiera se iniciará. Si en el proceso, se siente inseguro
sobre lo que significa una de las opciones del núcleo, está disponible
una corta descripción pulsando \key{?} y \key{Enter}

Lo siguiente será ejecutar la orden {\tt make dep} para actualizar
todas las dependencias del código fuente. Éste es, también, un paso
importante. {\tt make clean} eliminará los ficheros binarios antiguos
del árbol del núcleo. 

\index{núcleo!compilando una imagen comprimida}

La instrucción {\tt make zImage} compila el núcleo y lo escribe en el
fichero {\tt /usr/src/linux/arch/i386/boot/zImage}. Los núcleos de
Linux en los sistemas Intel, están siempre comprimidos. Algunas veces,
el núcleo que se desea compilar es demasiado grande para ser comprimido
por el sistema de compresión que usa {\tt make zImage}. Un núcleo
excesivamente grande para dicho sistema de compresión, retornará
del proceso de compilación del núcleo con el siguiente mensaje de
error: {\tt Kernel Image Too Large}. Si esto llegara a pasar, se
debe tratar con la orden {\tt make bzImage}. Esta orden usa un
sistema de compresión que soporta los núcleos grandes. El núcleo será
escrito en {\tt /usr/src/linux/arch/i386/boot/bzImage}.

Una vez que se tenga el núcleo compilado, se podrá copiar a un disquete
de arranque, (por ejemplo, con la orden ``{\tt cp zImage
  /dev/fd0}''), o se podrá instalar la imagen, y así, LILO iniciará el
sistema desde el disco duro. Para más información, ver la página~\pageref{sec-lilo}. 

\subsection{Agregando un controlador de dispositivo al núcleo}
\label{kernel-ppa-driver}
\index{núcleo!arraglar controlador de dispositivo}

La página~\pageref{sec-zip-backup} describe cómo usar una unidad Zip
Iomega, para efectuar copias de seguridad. El soporte para este tipo
de unidades, como para muchos otros dispositivos, no son generalmente
compilados en los núcleos comunes y corrientes de las distribuciones {\linux}
---la variedad de dispositivos es simplemente demasiado extensa como
para poder respaldarlos a todos en un sólo núcleo utilizable. No
obstante, el código fuente para el dispositivo de la unidad Zip en
puerto paralelo, está incluido como una parte de código fuente del
núcleo de la distribución. Esta sección describe cómo agregar el
soporte para una unidad de puerto paralelo Iomega Zip, y cómo hacer
para que conviva con una impresora conectada a otro puerto paralelo.

Para esto, usted deberá tener instalado, y haber construido
exitosamente un núcleo, como el descrito en la sección anterior. 

El poder elegir un dispositivo unidad Zip {\tt ppa}, como una de las
opciones del núcleo, requiere que se conteste {\tt Y} a las
respuestas apropiadas, durante el proceso {\tt make config}, o sea,
cuando se determina la configuración del núcleo a construir. En
particular, el dispositivo {\tt ppa}, requiere que se conteste
``{\tt Y}'' a tres opciones:

\begin{tscreen}
SCSI support? [Y/n/m] Y \\
SCSI disk support? [Y/n/m] Y \\
IOMEGA Parallel Port Zip Drive SCSI support? [Y/n/m] Y
\end{tscreen}

Después de haber ejecutado exitosamente {\tt make config}, con todas
las opciones que quiere incluir en su núcleo, ejecutar {\tt make dep},
{\tt make clean}, y {\tt make zImage}, para construirlo. Además, hay que
decirle al núcleo, de qué manera instalar el controlador. Esto se
efectúa a través de una línea de ordenes al LILO. Como se ha
descrito en la sección~\ref{sec-lilo}, el archivo de configuración
del LILO {\tt /etc/lilo.conf} tiene ``estrofas'', una para cada
sistema operativo que domina y también directivas para ofrecer al
usuario estas opciones, en el momento de arrancar el sistema. 

Una de las directivas que LILO acepta es ``{\tt append=}'', la cual
permite añadir información requerida por varios controladores a la
línea de ordenes. En este caso, el controlador de la unidad Iomega
Zip {\tt ppa}, requiere de una interrupción y una dirección del puerto
de entrada/salida, sin uso. Esto es exactamente análogo a especificar
dispositivos de impresoras separados, como {\tt LPT1:} y {\tt LPT2:}
en MS-DOS. 

Por ejemplo, si la impresora usa la dirección del puerto hexadecimal
(en base 16), {\tt 0x378} (ver el manual de instalación de la tarjeta
del puerto paralelo, si no se sabe cuál es la dirección), y está
sondeada\NT{``polled'' en el original,}, (esto
es, no requiere de una línea IRQ, una configuración común de {\linux},
se debería colocar la siguiente línea, en el archivo {\tt
  /etc/lilo.conf} del sistema:

\begin{tscreen}
append="lp=0x378,0"
\end{tscreen}

Es digno de observar que Linux reconoce automáticamente un puerto {\tt
  /dev/lp} al arrancar el sistema, pero al especificar algunas otras
configuraciones para los puertos, las instrucciónes al inicio del
  sistema, son requeridas. 

El ``{\tt 0}'' que se encuentra después de la dirección del puerto, le
dice al núcleo que {\em no} use una línea IRQ (pedido de
interrupción), para la impresora. Esto es generalmente aceptable, ya
que las impresoras son mucho más lentas que la CPU, y tan así que un
método más lento de acceso a los dispositivos E/S, conocido como {\bf
  sondeo}\footnote{``polling'' en el original, (Nota del T.)}, en el
cual el núcleo comprueba, periódicamente, el estado de la impresora,
todavía permite al computador supervisar este dispositivo.

Sin embargo, los dispositivos que operan a mayores velocidades, como
las líneas en serie y los discos, requieren, cada uno, de una línea
{\bf IRQ,} o {\bf petición de interrupción (Interrupt ReQuest)}. Esta,
es una señal del hardware, enviada por el dispositivo hacia el
microprocesador, cada vez que dicho dispositivo requiere la atención
del procesador; por ejemplo: si el dispositivo tiene datos esperando a
ser despachados por el procesador. El procesador, interrumpe lo que
esté haciendo en ese momento para obedecer al pedido de interrupción
del dispositivo. El dispositivo unidad Zip {\bf ppa}, exige una
línea de interrupción libre, la cual debe corresponder con la de la tarjeta de la
impresora a la cual se conecta la unidad Zip. En el momento en que
esto se escribía, el controlador del dispositivo {\bf ppa} para GNU/Linux,
no soportaba ``sucesiones'' de puertos paralelos, y se debían emplear
puertos paralelos separados para usar el dispositivo Zip {\bf ppa} y
cada impresora. 

Para saber qué interrupciones están actualmente utilizadas por su
sistema, la orden

\begin{tscreen}
\# cat /proc/interrupt
\end{tscreen}

muestra una lista de dispositivos y las líneas IRQ que usan. Sin
embargo, también se deberá tener cuidado de no usar ninguna interrupción
de ningún puerto en serie configurada automáticamente; la cual puede
no estar listada en el archivo {\tt /proc/interrupt}. El Proyecto de
Documentación de Linux, serial HOWTO, el cual está disponible en los
recursos listados en el Apéndice~\ref{app-sources-num}, describe
detalladamente, la configuración de los puertos en serie. 

\blackdiamond Uno también debería realizar un chequeo de la
configuración de la interfaz de varias tarjetas, abriendo la carcasa
de su máquina y verificando visualmente la configuración de los
puentes si es necesario, para asegurarse, así, de no estar asociando
una línea IRQ usada por otro dispositivo. La lucha de múltiples
dispositivos por una línea de interrupción es quizá el problema más
sencillo y común que causa que los sistemas GNU/Linux no funcionen. 

Un típico archivo {\tt /proc/interrupt} suele ser como
\begin{tscreen}
 0:    6091646   timer \\
 1:      40691   keyboard \\
 2:          0   cascade \\
 4:     284686 + serial \\
13:          1   math error \\
14:     192560 + ide0 \\
\end{tscreen}

Aquí, la primera columna nos es de interés. Estos son los números de
las líneas IRQ usadas por el sistema. Para el controlador {\tt ppa},
necesitamos escoger una línea que {\tt no} esté listada. La línea IRQ
7 es, a menudo, una buena elección ya que rara vez es usada en las
configuraciones predeterminadas del sistema. También necesitamos
especificar la dirección del puerto que usará el dispositivo {\tt
  ppa}. Esta dirección necesita estar configurada físicamente con la
interfaz de la tarjeta. A los puertos paralelos de E/S se les deben
asignar direcciones específicas, por lo que usted tendrá que leer la
documentación de la tarjeta de su puerto paralelo. En este ejemplo
usaremos, para el puerto de E/S, la dirección {\tt 0x278}, la cual
corresponde al puerto {\tt LPT2:} de la impresora, en MS-DOS. Para
añadir la línea IRQ y la dirección del puerto en una línea de ordenes
cuando arranca el sistema, necesitamos agregar la siguiente
expresión a la ``estrofa'' apropiada del archivo {\tt /etc/lilo.conf}:

\begin{tscreen}
append="lp=0x378,0 ppa=0x278,7"
\end{tscreen}

Estas expresiones son añadidas a los parámetros de arranque del
núcleo, cuando se inicia el sistema. Aseguran que cualquier impresora
conectada al sistema no interfiera con el funcionamiento de la unidad
Zip. Por supuesto, si el sistema no tiene ninguna impresora instalada
la directiva ``{\tt lp=}'' puede y debería ser omitida. 

Después de que haya instalado el núcleo, como se describió en la
sección~\ref{sec-lilo}, y antes de reiniciar el sistema, hay que
asegurarse de ejecutar la instrucción
\begin{tscreen}
\# /sbin/lilo
\end{tscreen}
para así, instalar la nueva configuración de LILO en el sector de arranque del disco duro. 

\subsection{Instalando controladores en módulos}
\label{ftape-module}

La página~\pageref{sec-tape-backups} describe cómo realizar copias de
seguridad en un accionador de cinta magnética. Linux da soporte a una
gran variedad de accionadores de cinta con interfaces IDE, SCSI y
algunas interfaces del propietario. Otro tipo corriente de
accionadores de cinta son aquellos que se conectan directamente al
controlador de la disquetera. Linux suministra el controlador para la
unidad ftape como un módulo. 

Cuando esto se estaba escribiendo, la versión más reciente de ftape
era la 3.04d. Se puede obtener el controlador en el servidor FTP
{\tt sunsite.unc.edu}, (para más información, ver el
Apéndice~\ref{app-ftp}). El archivo ftape se encuentra en el
directorio {\tt /pub/Linux/núcleo/tapes}. Hay que asegurarse de
procurarse la versión más reciente, la cual, cuando este documento se estaba
editando, era {\tt ftape-3.04d.tar.gz}.

Después de desempaquetar el archivo ftape en el directorio {\tt
  /usr/src}, al escribir {\tt make install} en el directorio padre de
ftape, se compilarán el módulo del controlador ftape y sus utilidades,
si son necesarias, y luego se instalarán. Si experimenta problemas de
compatibilidad entre los ficheros de la distribución ejecutable ftape
y su núcleo o las bibliotecas de su sistema, ejecute las órdenes {\tt
  make~clean} y {\tt make~install}, y se asegurará, de que los módulos
sean compilados en su sistema. 

\blackdiamond Para usar esta versión del controlador ftape, usted
deberá tener el soporte para módulos en el núcleo, como también
soporte para el demonio {\tt núcleod}. Sin embargo, {\em no} deberá
incluir el código interno del núcleo para ftape como una opción del
núcleo, ya que las versiónes más recientes del módulo ftape remplazan
completamente este código. 

{\tt make install}, también instalará el controlador del dispositivo
en el directorio correcto. En un sistema GNU/Linux estándar, los módulos
se encuentran en el directorio
\begin{tscreen}
/lib/modules/\cparam{núcleo-version}
\end{tscreen}
Si la versión de tu núcleo es 2.0.30, los módulos de su sistema se
encuentran en el directorio {\tt /lib/modules/2.0.30}. {\tt make
  install} también asegura que estos módulos puedan ser localizados en
cualquier momento, agregando las expresiónes apropiadas en el archivo
{\tt modules.dep}, que se encuentra en el directorio raíz de los
ficheros módulo, en este caso, {\tt /lib/modules/2.0.30}. La
instalación de ftape, añade los siguientes módulos a su sistema,
(usando, en este ejemplo, la versión 2.0.30 del núcleo):
\begin{tscreen}
/lib/modules/2.0.30/misc/ftape.o \\
/lib/modules/2.0.30/misc/zft-compressor.o \\
/lib/modules/2.0.30/misc/zftape.o
\end{tscreen}
También se necesitan agregar las instrucciones para cargar los módulos
al archivo de la configuración de módulos de su sistema. En muchos
sistemas, este es el archivo {\tt /etc/conf.modules}. Para cargar
automáticamente los módulos ftape a pedido, agregue las siguientes
líneas en el archivo {\tt /etc/conf.modules}:
\begin{tscreen}
alias char-major-27 zftape \\
pre-install ftape /sbin/swapout 5
\end{tscreen}

La primera declaración carga los módulos relacionados con ftape cuando
un dispositivo con el número principal 27\NT{``majornumber 27''
  en el original} (el dispositivo ftape), es accedido
por el núcleo. Debido a que el módulo de soporte para zftape, (el cual
provee compresión automática para los dispositivos ftape) requiere el
soporte de los demás módulos ftape, todos ellos son cargados en el
momento en que el núcleo efectúa la demanda. La segunda línea
especifica los parámetros que serán dados a los módulos al iniciarse
el sistema. En este caso, la utilidad {\tt /sbin/swapout}, la cual
viene incorporada en el paquete de software ftape, asegura que hay
suficiente memoria DMA, para el correcto funcionamiento del
controlador ftape. 

Para tener acceso al dispositivo ftape driver se deberá primero, colocar
una cinta formateada en la unidad. Las instrucciónes para formatear
cintas y operar correctamente la unidad de cintas son dadas en la sección~\ref{sec-tape-backups}.


\subsection{Actualizando las bibliotecas compartidas}\label{sec-upgrade-libs}
\index{bibliotecas!actualización}

Como se mencionó antes, la mayor parte del software del sistema está
compilado para que utilice las bibliotecas compartidas, las cuales
contienen subrutinas comunes compartidas entre distintos programas.
Si aparece el mensaje

\begin{tscreen}
Incompatible library version
\end{tscreen}

cuando se intenta ejecutar un programa, entonces necesita actualizar a
la versión de las bibliotecas que el programa requiere. Las bibliotecas
son compatible-ascendentes; esto es, un programa compilado para
utilizar una versión antigua de las bibliotecas, debería ser capaz de
trabajar con la nueva versión de las bibliotecas instalada. Sin embargo,
esto no se da en sentido contrario. 

La ultima versión de las bibliotecas se puede encontrar en los
servidores FTP de GNU/Linux. En {\tt sunsite.unc.edu}, están disponibles
en {\tt /pub/GNU/Linux/GCC}. Los ficheros a descargar deberían explicar
qué ficheros se necesita obtener y como instalarlos. Debería ser
capaz de coger rápidamente los ficheros {\tt image-{\em
    versión}.tar.gz} e {\tt inc-{\em versión}.tar.gz}, donde {\em
  versión} es la versión de las bibliotecas a instalar, por ejemplo {\tt
  4.4.1}. Estos son ficheros tar, comprimidos con {\tt gzip}. El
fichero {\tt imagen} contiene las imágenes de las bibliotecas a instalar
en {\tt /lib} y {\tt /usr/lib}. El fichero {\tt inc} contiene los
ficheros de inclusión, a instalar en {\tt /usr/include}.

El fichero {\tt release-}{\em versión}{\tt .tar.gz} debería explicar
el procedimiento de instalación en detalle (las instrucciónes exactas
cambian según la versión). Generalmente se necesitará instalar los
ficheros de bibliotecas {\tt .a} y {\tt .sa} en {\tt /usr/lib}. Estas
son las utilizadas al compilar.

Además, los ficheros imagen de las bibliotecas compartidas {\tt
  lib.so.}{\em versión} se instalan en {\tt /lib}. Estas son las
imágenes de las bibliotecas compartidas que son cargadas en tiempo de
ejecución por los programas que las utilizan. Cada biblioteca tiene un
enlace simbólico utilizando el numero de versión
principal \NT{``major version number'' en el original.} de la biblioteca en {\tt /lib}.

La versión 4.4.1 de la biblioteca {\tt libc} tiene un número de
versión principal {\tt 4}. El archivo que contiene a la
biblioteca es el {\tt libc.so.4.4.1}. Existe un enlace simbólico con
el nombre {\tt libc.so.4} en {\tt/lib} apuntando a este fichero. Es
por esto que se debe cambiar estos enlaces simbólicos cuando se
actualizan las bibliotecas. Por ejemplo, cuando se actualiza de {\tt
  libc.so.4.4} a {\tt libc.so.4.4.1}, se debe cambiar el enlace simbólico
de tal modo que apunte a la nueva versión. 

\blackdiamond Se deberá cambiar el enlace simbólico de un solo paso, como
se describirá más abajo. Si se borra el enlace simbólico {\tt libc.so.4},
los programas que dependen de él (incluyendo utilidades básicas como
{\tt ls} y {\tt cat}), dejarán de funcionar. Por lo tanto, es
recomendable usar la siguiente orden para actualizar el enlace
simbólico {\tt libc.so.4} y hacer que apunte al archivo {\tt libc.so.4.4.1}:

\begin{tscreen}
\# ln -sf /lib/libc.so.4.4.1 /lib/libc.so.4
\end{tscreen}

También se necesitará cambiar el enlace simbólico {\tt libm.so.}{\em
  versión} de la misma manera. Si se está actualizando a una
versión de biblioteca diferente, substituir apropiadamente los nombres
de arriba. Las notas que vienen con el paquete de la biblioteca,
deberían explicar los detalles. (Mirar en la
página~\pageref{sec-manage-links} para más información sobre los
enlaces simbólicos.) 

\subsection{Actualizando el {\tt gcc}}
\label{sec-upgrade-gcc}
\index{gcc@{\tt gcc}!actualización}

El compilador de C y C++ {\tt gcc}, es usado para compilar el software
de su sistema, siendo lo más importante, el núcleo. La última versión
del {\tt gcc} se puede obtener en los servidores de GNU/Linux FTP. En {\tt
  sunsite.unc.edu}, se encuentra en el directorio {\tt
  /pub/GNU/Linux/GCC} (junto con las bibliotecas). Debería de haber un
{\tt fichero de entrega}\footnote{``release file'' en el
  original. Nota del T. } en la distribución del {\tt gcc}, el cual
explique qué ficheros necesita obtener y cómo instalarlos. 

La mayoría de las distribuciónes de GNU/Linux tienen versiones para
actualizar el {\tt gcc} que trabajan con su propia gestión de paquetes
de software. En general, estos paquetes son mucho más fáciles de
instalar que las distribuciónes ``genéricas''. 

\subsection{Actualizando otro software}

Actualizar otro software suele ser simplemente materia de obtener los
ficheros apropiados e instalarlos. La mayor parte del software de
GNU/Linux se distribuye bajo la forma de ficheros tar comprimidos que
pueden incluir los fuentes, los binarios, o ambos. Si los binarios no
están incluidos en ese paquete, puede que sea necesario que usted los
compile. Esto significa que, por lo menos, tenga que teclear {\tt
  make} dentro del directorio donde se encuentran los ficheros fuente. 

\index{software!dónde encontrar versiones}
Leer el grupo de noticias de Usenet {\tt comp.os.GNU/Linux.announce} en
busca de anuncios de nuevas versiónes de software, es la manera más
simple para enterarse de la aparición de nuevo software. Cada vez que
se busque software en un servidor FTP, obtener el fichero de
índice {\tt ls-lR} del servidor FTP y utilizar {\tt grep} para
encontrar los ficheros en cuestión, es la forma mas simple de
localizar software. Si se dispone de {\tt archie}, este puede servir de
ayuda; o de otra manera \footnote{Si no se tiene {\tt archie}}, es posible
conectarse vía telnet a un servidor {\tt archie} como puede ser
archie.rutgers.edu, identificarse como ``{\tt archie}'' y utilizar la
orden "help". También se puede encontrar otros recursos en Internet,
los cuales son consagrados específicamente para GNU/Linux. Mirar el
Apéndice~\ref{app-info} para obtener información más detallada.

%% One handy source of GNU/Linux software is the Slackware distribution disk
%% images. Each disk contains a number of {\tt .tgz} files which are
%% simply gzipped tar files. Instead of downloading the disks, you can
%% download the desired {\tt .tgz} files from the Slackware directories
%% on the FTP site and install them directly. If you run the Slackware
%% distribution, the {\tt setup} command can be used to automatically
%% load and install a complete series of disks. 

%% Again, it's usually not a good idea to upgrade by reinstalling with
%% the newest version of Slackware, or another distribution. If you reinstall 
%% in this way, you will no doubt wreck your current installation, including 
%% user directories and all of your customized configuration. The best way
%% to upgrade software is piecewise; that is, if there is a program that
%% you use often that has a new version, upgrade it. Otherwise, don't bother.
%% Rule of thumb: If it ain't broke, don't fix it. If your current software
%% works, there's no reason to upgrade. 
\index{software!actualizar|)}
\index{software!instalar|)}

%% Traducción terminada el 11/02/01 por Sebastián Gurin, Cancerbero <anon@adinet.com.uy> 




