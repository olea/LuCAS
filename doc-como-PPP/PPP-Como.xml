<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>

<articleinfo>

<title>Linux PPP HOWTO</title>

<author>
<firstname>Al Longyear, <ulink
url="mailto:longyear@netcom.com"
>longyear@netcom.com</ulink
>.
  Traducido por Rafael Agundo
(INSFLUG), <ulink
url="mailto:ragundo@bitmailer.net"
>ragundo@bitmailer.net</ulink
></firstname>
</author>

<pubdate>v1.0, 9 Marzo 1996</pubdate>

<abstract>

<para>
Este documento contiene una lista con las preguntas más habituales (FAQ, o
PUF, Preguntas de Uso Frecuente, en castellano)  sobre PPP para Linux
(junto con sus respuestas). No es realmente un Como, pués se adapta más al
formato clásico de Pregunta/Respuesta de las PUF. 
</para>

</abstract>

</articleinfo>

<sect1>
<title>Prefacio.</title>

<para>
Si tiene alguna corrección sobre este documento, por favor, notifíquesela
a Al Longyear (<ulink
url="mailto:longyear@netcom.com"
>longyear@netcom.com</ulink
>). Si tiene alguna corrección relativa a la
traducción, contacte con Rafael Agundo (<ulink
url="mailto:ragundo@bitmailer.net"
>ragundo@bitmailer.net</ulink
>).
</para>

<para>
Este documento forma parte de los HOWTO y FAQs de Linux. Estos documentos
pueden conseguirse vía ftp en <ulink
url="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/"
>sunsite.unc.edu</ulink
>
(este es el sitio <emphasis>oficial</emphasis>) o bien mediante WWW en <ulink
url="http://sunsite.unc.edu/mdw/linux.html"
>la Linux Documentation home page</ulink
>. No espere que este HOWTO aparezca publicado en
<literal remap="tt">comp.os.linux.answers</literal>, debido a problemas de espacio. 
</para>

<para>
A lo largo de este documento, se usa la palabra <emphasis>remoto</emphasis> para
designar "el sistema que está al final del enlace a traves del módem". En
la documentación sobre PPP suele aparecer también como <emphasis>peer</emphasis>.
Cuando se habla de rutado suele aparecer como <emphasis>gateaway</emphasis>. La
dirección IP del sistema remoto aparecerá como el campo <emphasis>dirección
'P-t-P'</emphasis> cuando se use <literal remap="tt">ifconfig</literal>.  Asimismo, se emplea
indistintamente el término inglés <emphasis>frame</emphasis> junto con sus
equivalentes en castellano: trama o paquete. 
</para>

<para>
Microsoft es una marca registrada de Microsoft Corporation. Morning Star
es una marca registrada de Morning Star Technologies. El resto de
productos mencionados en este documento son marcas registradas de sus
respectivas compañías. 
</para>

</sect1>

<sect1>
<title>Información general</title>

<sect2>
<title>¿ Qué es PPP ?.</title>

<para>
PPP o Point-to-Point Protocol (<emphasis remap="bf">P</emphasis>rotocolo de <emphasis remap="bf">P</emphasis>unto a
<emphasis remap="bf">P</emphasis>unto) está reconocido como uno de los protocolos
<emphasis>oficiales</emphasis> de internet. Este protocolo se usa para intercambiar
tramas IP (y de otro tipo) a través de una línea serial. El número de RFC
para describir PPP es el 1661. No es el único, hay otros muchos documentos
relacionados con PPP. 
</para>

<para>
Contrariamente a lo que algunas personas piensan, PPP no significa "Peer
to Peer Processing", aunque se pueda realizar una comunicación peer to
peer usando TCP/IP a traves de un enlace PPP. 
</para>

</sect2>

<sect2>
<title>Mi universidad ( o compañía ) no soporta PPP. ¿ Puedo usar PPP ?.</title>

<para>
En general, no. Una implementación <emphasis>clásica</emphasis> de PPP requiere
cambios en las rutas y en los dispositivos conectados al sistema
operativo. En definitiva, sería necesario volver a recompilar el kernel en
el ordenador remoto. 
</para>

<para>
Obtener un nuevo kernel no es tarea para un usuario normal de un sistema.
Si puede convencer al administrador de su sistema de las ventajas de tener
instalado soporte PPP, entonces puede ser que se instale dicho soporte. Si
no es así, entonces no podrá usar probablemente PPP. 
</para>

<para>
Sin embargo, si usted usa un sistema soportado por la compañía que está
vendiendo el paquete adaptador TIA (The Internet Adapter), entonces puede
ser que si pueda usar PPP. El autor de este HOWTO no tiene disponible
mucha información sobre este paquete, sin embargo parece ser que ofrecerá
soporte PPP en su próxima versión. (Esta información puede estar ya
anticuada, mejor contacte con ellos directamente. Para averiguar más sobre
TIA, puede visitar <ulink
url="http://www.marketplace.com/tia/tiahome"
>www.marketplace.com</ulink
>
</para>

<para>
Actualmente ya existe una versión para Linux de este paquete.
</para>

<para>
Si su sistema no está soportado por el paquete TIA, ni puede convencer a
su administrador de sistema para que adopte PPP, entonces debería usar el
paquete <emphasis>term</emphasis>. Algunos proveedores de servicios de conexión pueden
ponerle trabas a utilizar <emphasis>term</emphasis> para conectar con sus sistemas.
Hay varias razones para ello, pero la más importante está referida a temas
de 'seguridad'. 
</para>

<para>
Además del paquete TIA, Danny Gasparovski ha escrito un programa llamado
<literal remap="tt">slirp</literal>, el cual realizará funciones similares al de TIA. Este
programa, junto con su código fuente, puede obtenerse mediante <ulink
url="ftp://blitzen.canberra.edu.au/pub/slirp"
>ftp</ulink
>
</para>

<para>
Debería conseguir el código fuente del programa si desea obtener una mejor
información de cómo funciona.  La primera impresión es que el programa es
una excelente alternativa al paquete comercial de TIA. 
</para>

</sect2>

<sect2>
<title>¿ Dónde se encuentra PPP?.</title>

<para>
El paquete PPP está dividido en dos partes. La primera se encuentra en el
kernel. A partir del kernel 1.1.13, el driver ya forma parte de los
drivers de red del sistema. 
</para>

<para>
La segunda parte es el <emphasis>demonio</emphasis> (daemon) <literal remap="tt">pppd</literal>. Este es un
proceso obligatorio a ejecutar cuando quiera realizar una conexión PPP. El
código fuente para <literal remap="tt">pppd</literal> se encuentra en el fichero
<literal remap="tt">ppp-2.2.0.tar.gz</literal> de <ulink
url="ftp://sunsite.unc.edu/pub/Linux/system/Network/serial"
>sunsite.unc.edu</ulink
>
</para>

<para>
La versión 2.2 de PPP y posteriores están diseñadas para ser utilizadas
sólo con versiones de kernel mayores o iguales que la 1.2. No utilize esta
versión con versiones del kernel 1.1 o inferior, dado que tanto el código
de red, como el driver tty están ya desfasados. 
</para>

</sect2>

<sect2>
<title>Acabo de conseguir el paquete PPP. ¿ Qué hago con él ?.</title>

<para>
Read The Fine Material available.
</para>

<para>

<footnote>

<para>
 ( Pequeña broma del autor que sustituye el famoso término RTFM:
Read The Fucked Manual, lea el jodido manual por RTFM: Read The Fine
Material, lea los agradables manuales).  
</para>

</footnote>

</para>

<para>
Comience por leer el fichero <literal remap="tt">README</literal> y después el fichero
<literal remap="tt">README.linux</literal>. Para más fuentes de documentación vea la siguiente
pregunta. 
</para>

</sect2>

<sect2 id="consultelo">
<title>¿ (Dónde está la documentación ?. ¿ Hay un HOWTO ?, etc.). ¿ Dónde
puedo conseguir documentación adicional sobre PPP ?. </title>

<para>
Hay varias fuentes de información sobre la manera en que se ha
implementado el protocolo PPP para Linux. 
</para>

<para>

<itemizedlist>
<listitem>

<para>
El fichero <literal remap="tt">README</literal> que viene junto con el paquete.

</para>
</listitem>
<listitem>

<para>
El fichero <literal remap="tt">README.linux</literal> que también viene junto con el paquete.

</para>
</listitem>
<listitem>

<para>
El documento Net-2-HOWTO.

</para>
</listitem>
<listitem>

<para>
La Network Administration Guide (NAG).

</para>
</listitem>
<listitem>

<para>
La página <literal remap="tt">man</literal> de <literal remap="tt">pppd</literal>.

</para>
</listitem>
<listitem>

<para>
La PPP FAQ. (Este HOWTO no lo es aunque lo parezca).

</para>
</listitem>

</itemizedlist>

</para>

<para>
El fichero HOWTO se encuentra en el lugar habitual para los HOWTOs de
Linux.  Actualmente están en <ulink
url="sunsite.unc.edu/pub/Linux/docs/HOWTO"
>sunsite.unc.edu</ulink
>. 
</para>

<para>
La Network Administration Guide (Guia de Administración de Red ) puede
obtenerse en <ulink
url="ftp://sunsite.unc.edu/pub/Linux/docs/LDP/network-guide"
>sunsite.unc.edu</ulink
>. También está publicada en forma de libro impreso
por la editorial <ulink
url="http://www.ora.com"
>O'Reilly and Associates</ulink
>. Si prefiere un documento profesional, bien impreso y
encuadernado, consiga una copia del libro en su librería habitual. 
</para>

<para>
Las páginas <literal remap="tt">man</literal> vienen incluídas junto con el código fuente del
paquete PPP.  Casi con seguridad, será necesario moverlas al directorio
habitual donde se sitúan las páginas <literal remap="tt">man</literal>, <literal remap="tt">/usr/man/man8</literal>
antes de que el comando <literal remap="tt">man</literal> pueda encontrarlas. También puede
usar <literal remap="tt">nroff</literal> y <literal remap="tt">more</literal> para leerlas directamente. 
</para>

<para>
La PPP FAQ describe el protocolo PPP en general, junto con varias de sus
implementaciones. La PPP FAQ puede encontrarse en el area de news
<literal remap="tt">comp.protocols.PPP</literal> y también archivada en <ulink
url="ftp://rtfm.mit.edu/pub/usenet"
>rtfm.mit.edu</ulink
>.  Actualmente, la
PPP FAQ está dividida en 8 partes. 
</para>

</sect2>

<sect2>
<title>¿ Podría alguien enviarme scripts para PPP, de tal manera que pueda
comprender cómo se han escrito ?. </title>

<para>
Existen unos pocos scripts que vienen incluidos con el código fuente del
paquete.  Estos ejemplos cubren los tipos de accesos más normales que
usted va a encontrar, accesos donde se conecta a una máquina UNIX que le
va a pedir un <literal remap="tt">login</literal> y un <literal remap="tt">password</literal>. 
</para>

<para>
Con el código fuente de <literal remap="tt">pppd</literal> no vienen scripts específicos para
conectar con un sistema en concreto. Si tiene problemas para conectar con
dicho sistema, entonces debería pedir ayuda a alguien de su sistema y si
no la encuentra, debería preguntar en el area local de news de su sistema.
Si, por último, sigue sin poder encontrar ayuda, pregunte en el grupo
adecuado de Linux en usenet (vea la siguiente pregunta).
Desafortunadamente, el autor no tiene tiempo para poder suministrar
scripts para cada sistema en concreto. 
</para>

</sect2>

<sect2>
<title>¿ Dónde debo preguntar para resolver mis posibles dudas sobre PPP?.</title>

<para>
El grupo adecuado de usenet para preguntar es <literal remap="tt">comp.protocols.PPP</literal>
o <literal remap="tt">comp.os.linux.setup</literal>.  Use estos grupos para realizar preguntas
del tipo: "¿ Cómo debo usar pppd ?" o "¿ Porqué no funciona esto ? ". 
</para>

<para>
Preguntas del estilo: "¿ Porqué no consigo compilar pppd ?", son preguntas
que debe dirigir al grupo <literal remap="tt">comp.os.linux.networking</literal>. 
</para>

<para>
Por favor, no utilice para estas cuestiones <literal remap="tt">comp.os.linux.help</literal>,
incluso si su sistema sigue recibiendo este grupo de news (ya obsoleto). 
</para>

</sect2>

<sect2>
<title>Mi software PPP no funciona. ¿ Qué hago ?.</title>

<para>
Esta es una de las preguntas más habituales que suelen hacerse. Si usted
envía esta pregunta a usenet sin dar una información más específica, lo
más probable es que la gente que lea el area la ignore. 
</para>

<para>
Vea primero la pregunta referida a errores que aparecen al desconectar el
módem (pregunta <xref linkend="modem-no-cuelga"/>).  Estos errores no son la causa del problema, sino sólo
síntomas.  Preguntar qué puede ir mal incluyendo sólo estos errores
tampoco sirve de mucho, asi que&hellip; 
</para>

<para>
Lo que realmente debe proporcionar junto con su petición de ayuda es una
copia del system log (syslog) que obtiene cuando ejecuta <literal remap="tt">pppd</literal> con
la opción <literal remap="tt">debug</literal>. Además, si usa <literal remap="tt">chat</literal> para establecer la
comunicación, use la opción <literal remap="tt">-v</literal> en la línea de comandos de
<literal remap="tt">chat</literal> para ver qué es lo que está ocurriendo realmente. 
</para>

<para>
Incluya además los mensajes que proporcione el kernel al arrancar el
sistema. Estos mensajes aportan información sobre el hardware que tiene
instalado en su máquina, tipo de UART, versión de PPP, etc. 
</para>

<para>
Incluya también toda la información que pueda relacionada con su problema. 
El tipo de disco duro que tenga, la marca de su tarjeta de sonido, o
cuanta memoria tiene su tarjeta de vídeo son irrelevantes. Lo importante
son cosas como el tipo de sistema al que desea conectar, la versión de PPP
(o de terminal) que usa el sistema remoto, el tipo de módem o la velocidad
con la que quiere conectar. 
</para>

<para>
Tenga en cuenta cuando ponga su syslog, que debe eliminar cualquier
posible referencia a su número de teléfono, su login o su password. No son
importantes a la hora de solucionar el problema, pero si pueden causarle
más de un problema de seguridad el proporcionar a todo el mundo su clave
de acceso.  Elimine también cualquier línea que no provenga del kernel o
de <literal remap="tt">pppd</literal>. 
</para>

<para>
<emphasis>NUNCA</emphasis> ejecute <literal remap="tt">pppd</literal> con la opción <literal remap="tt">kdebug 31</literal> para
acompañar su petición de ayuda. 
</para>

<para>
Si su problema requiere examinar el flujo de datos que se intercambia
entre los ordenadores implicados en la conexión, recibirá un email
solicitándole que lo envíe. Desafortunadamente, usenet cuesta demasiado
dinero a mucha gente como para engrosar innecesariamente la longitud de
los mensajes. 
</para>

<para>
La información relativa sobre PPP está estructurada en varios niveles. La
información de debug es enviada al nivel de debug. Los mensajes
aclaratorios son enviados al nivel de información. Los errores son
enviados al nivel de error. Incluya todos los mensajes que provengan del
grupo 'local2' del proceso <literal remap="tt">pppd</literal>. 
</para>

<para>
Por último, no borre la información relativa a la impresión de tiempos. Es
importante. 
</para>

</sect2>

<sect2>
<title>¿ Cómo debo usar PPP con un sistema remoto que usa asignación
dinámica de direcciones IP ?. ¡¡¡ Cada vez que conecto obtengo una
dirección IP distinta !!!. </title>

<para>
La asignación de la dirección IP local está en función de las opciones que
se proporcionen a <literal remap="tt">pppd</literal> y del protocolo IPCP. Debería utilizar la
dirección IP <emphasis>mágica</emphasis> 0.0.0.0 si necesita especificar su dirección
IP local. La mayoría de la gente simplemente no incluye la dirección IP
local en las opciones de <literal remap="tt">pppd</literal>. 
</para>

<para>
La otra opción relacionada con este tema se llama <literal remap="tt">noipdefault</literal>.
Esta opción indica a su proceso <literal remap="tt">pppd</literal> que no debe obtener su
dirección IP local a partir de los datos que contenga su fichero
<literal remap="tt">/etc/hosts</literal>, sino que dicha dirección IP debe proporcionarla el
sistema remoto. La mayoría de la gente usa esta opción cuando la dirección
IP es asignada dinámicamente. Sin embargo, esta opción no debe entenderse
como "usa direcciones IP dinámicas". El uso de direcciones IP dinámicas es
automático cuando no se proporciona la dirección IP local. 
</para>

</sect2>

<sect2>
<title>¿ Cómo puedo saber que dirección IP me ha sido asignada cuando se
usa asignación dinámica de direcciones ?. </title>

<para>
Utilize el fichero ejecutable <literal remap="tt">/etc/PPP/ip-up</literal>. La dirección IP
local es el cuarto parámetro que se le pasa a este fichero en su línea de
comandos. Este fichero se ejecuta cuando <literal remap="tt">pppd</literal> conoce su dirección IP
local. 
</para>

<para>
Además, por si le interesa, el quinto parámetro que se le pasa a este
fichero es la dirección IP remota del sistema con el que ha conectado. 
</para>

<para>
Si siente curiosidad sobre el valor que le ha sido asignado, entonces
debería ejecutar <literal remap="tt">ifconfig</literal>. Este programa le mostrará los valores
actuales de la direcciones IP local y remota bajo el campo "P-t-P". 
</para>

</sect2>

<sect2>
<title>¿ Puedo usar la misma dirección IP local para todas las líneas de
un servidor PPP?. </title>

<para>
Si. La dirección local no es significativa para el sistema local. Lo que
si debe tener es una única dirección IP remota. El rutado de información
se realiza usando la dirección IP remota, no la local. 
</para>

</sect2>

</sect1>

<sect1>
<title>Otras implementaciones.</title>

<sect2>
<title>¿ Existen otras implementaciones de PPP distintas a la de Linux ?.
Me gustaría saber si existe alguna para HP-UX o AIX o &hellip; </title>

<para>
Revise la PPP FAQ mencionada anteriormente. Consulte la pregunta <xref linkend="consultelo"/>. 
</para>

<para>
HP-UX está soportado por el paquete comercial de Morningstar. El soporte
para AIX se encuentra ya disponible en la versión 2.2 del paquete
<literal remap="tt">pppd</literal>. 
</para>

<para>
Si no encuentra el sistema que busca, pregunte en
<literal remap="tt">comp.protocols.ppp</literal> y <emphasis>NO</emphasis> en los grupos de Linux. 
</para>

<para>
Por favor, no mande email al autor de este HOWTO con cuestiones del
estilo:  "¿ Conoce algún paquete PPP para el sistema xxxx ?". Estas
preguntas serán archivadas "apropiadamente" <literal remap="tt">:-)</literal>. 
</para>

<para>
El paquete <literal remap="tt">pppd</literal> que se encuentra en <literal remap="tt">sunsite</literal> no contiene
código que implementa interfaces del tipo stream. Esto se debe a que estos
tipos de interfaces tienen copyright. El grupo de personas que han
diseñado el paquete <literal remap="tt">pppd</literal> ha realizado gestiones para ver si se
podían cambiar los términos de este copyright. Por el momento, no ha
habido respuesta. 
</para>

<para>
Por esta razón, y dado que <literal remap="tt">sunsite</literal> está dedicado específicamente
a Linux, se han eliminado los ports de PPP para AIX, SunOS, Next y otros
sistemas que contenían protocolos con streams.  Se siguen manteniendo los
ports para BSD y para Linux. Si quiere conseguir el código de
<literal remap="tt">pppd</literal> para otros sistemas, consulte la PPP FAQ. Alternativamente,
puede utilizar <literal remap="tt">archie</literal>. No intente buscarlo en los mirrors de
<literal remap="tt">sunsite</literal> porque tampoco estará ahí. 
</para>

</sect2>

<sect2>
<title>¿ Existe un programa llamado <literal remap="tt">dp</literal> ?.</title>

<para>
Si, existe. El paquete <literal remap="tt">dp</literal> fue considerado al inicio del
desarrollo de la traslación de PPP a Linux. Es un buen programa, permite
"demand dial", pero sólo funciona con sistemas que soportan streams. SunOS
(Solaris) es un ejemplo de estos sistemas. Linux, por el momento,
<emphasis>NO</emphasis> soporta streams. 
</para>

<para>
Existen otros paquetes para PPP circulando por Internet. <emphasis remap="bf">Portable
PPP</emphasis> es un paquete muy similar al de TIA. También existe otro paquete
denominado simplemente <emphasis remap="bf">ppp</emphasis>. El paquete <emphasis remap="bf">KA9Q</emphasis> también contiene
código que implementa PPP. 
</para>

<para>
De todos estos paquetes, <literal remap="tt">pppd</literal> fue el que más se ajustaba a las
necesidades de la traslación a Linux, por eso fue elegido. 
</para>

<para>
(Si quiere más información sobre estos programas, así como sobre otros,
pregunte en el grupo <literal remap="tt">comp.protocols.ppp</literal> ). 
</para>

</sect2>

<sect2>
<title>¿ Cuáles son los RFCs que describen el protocolo PPP ?.</title>

<para>
La implementación actual de PPP es una mezcla de varios de ellos. La mayor
parte del código de PPP aparece descrito en los RFCs 1331 y 1332. Estos
RFCs han quedado obsoletos hoy en día. RFC 1331 fue substituido por el RFC
1548 y éste a su vez fue sustituido 6 meses más tarde por el RFC 1661. 
</para>

<para>
La mayoría de las implementaciones de PPP no tienen porqué tener ningún
problema con la versión PPP de Linux. Para una lista completa, consulte la
PPP FAQ. 
</para>

<para>
Extraído de la PPP FAQ:
</para>

<para>
<quote
>Los RFCs 1134, 1171, 1172 (y 1055 para este tema en concreto)  han quedado
obsoletos. Sólo son interesantes si va a conectar con una implementación
"muy antigua" de PPP y no consigue negociar con ella. Por ejemplo, el PPP
remoto le pregunta al suyo por la opción 2 de IPCP con sólo una longitud
de 4 y con un tipo de compresión 0x0037. 

(Todavía existe un montón de todo esto circulando por ahí . Sea cuidadoso
ahí fuera). </quote
>
</para>

<para>
Linux, por ejemplo, detectaría esta condición y la corregiría
automáticamente. 
</para>

</sect2>

</sect1>

<sect1>
<title>Compatibilidad.</title>

<sect2>
<title>¿ Puede PPP dialogar con un interface tipo SLIP ?.</title>

<para>
No. SLIP funciona con SLIP y PPP funciona con PPP.
</para>

<para>
Algunos vendedores ofrecen productos que trabajan tanto con SLIP como con
PPP. Sin embargo, estos paquetes deben de ser configurados para trabajar
bien con SLIP, bien con PPP, pero no con ambos a la vez. Actualmente, no
hay ninguna forma de saber si se está solicitando utilizar PPP o SLIP en
el momento de establecer una comunicación. 
</para>

</sect2>

<sect2>
<title>¿ Qué es mejor: usar PPP o SLIP ?.</title>

<para>
<emphasis>Depende de muchos factores</emphasis>. Generalmente, las personas que hacen
esta pregunta, no han leído el documento Net-2-HOWTO. Consulte la pregunta
<xref linkend="consultelo"/>. 
</para>

<para>
Una excelente discusión teórica sobre esta cuestión está disponible en
<ulink
url="http://www.mornignstar.com/"
>el servidor WWW de Morning Star</ulink
>. 
</para>

</sect2>

<sect2>
<title>¿ Qué es mejor para la identificación y verificación: CHAP o PAP ?.</title>

<para>
Si puede elegir, use CHAP. Si no le queda más remedio use PAP, es mejor
que nada.
<footnote>

<para>
A lo largo del documento se utilizará el término
"identificación y verificación" en vez del equivalente inglés
"authentification".
</para>

</footnote>

</para>

</sect2>

</sect1>

<sect1>
<title>Ficheros de identificación y verificación.</title>

<sect2>
<title>¿ Cuál es el formato del fichero <literal remap="tt">/etc/pap-secrets</literal> ?. ¿ Hay
algún ejemplo disponible ?. </title>

<para>
 
</para>

<para>
El protocolo de identificación y verificación PAP se usa principalmente
para enviar al sistema remoto su login y su password en ese sistema. Más
concretamente, debe enviar el nombre del sistema remoto, el nombre de su
cuenta en ese sistema y su password. 
</para>

<para>
Si el usuario en la máquina abbot quiere llamar a costello, la entrada
correspondiente en <literal remap="tt">/etc/pap-secrets</literal> debería ser: 
</para>

<para>

<screen>
#account	remote		password	IP address list
abbot		*		firstbase
</screen>

</para>

</sect2>

<sect2>
<title>¿ Cuál es el formato del fichero <literal remap="tt">/etc/chap-secrets</literal> ?. ¿
Hay algún ejemplo disponible ?. </title>

<para>
 
</para>

<para>
El problema más común es que se suele olvidar que para que CHAP funcione,
<emphasis>AMBOS</emphasis> ordenadores implicados en la comunicación deben de tener su
fichero <literal remap="tt">/etc/chap-secrets</literal> convenientemente configurado. 
</para>

<para>
Siguiendo con el ejemplo anterior, si abbot quiere hablar con costello,
entonces el fichero <literal remap="tt">/etc/chap-secrets</literal> de abbot debe contener
</para>

<para>

<screen>
#remote		local		secret		IP address list
abbot		costello	firstbase	10.10.10.2
costello	abbot		who		10.10.10.1
</screen>

</para>

<para>
Y en la máquina costello <literal remap="tt">/etc/chap-secrets</literal> debe tener
</para>

<para>

<screen>
#remote		local		secret		IP address list
abbot		costello	firstbase	10.10.10.2
costello	abbot		who		10.10.10.1
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>Problemas de compilación.</title>

<sect2>
<title>Hay errores cuando intento compilar el kernel.</title>

<para>
El paquete con la versión 2.2 de <literal remap="tt">pppd</literal> contiene las instrucciones
necesarias para que pueda compilar el programa. Brevemente, necesita
ejecutar el comando <literal remap="tt">configure</literal>. Así se generarán los enlaces
adecuados para el Makefile. Después, haga un <literal remap="tt">make kernel</literal>. Esto
instalará las nuevas partes del programa que deban ser actualizadas. 
</para>

<para>
Una vez hecho esto, vuelva a recompilar el kernel. Debe hacerlo incluso si
ya había construído anteriormente otro kernel para soportar PPP. El driver
suministrado con las versiones del kernel 1.2 y las primeras del 1.3 no es
compatible con la versión 2.2 de <literal remap="tt">pppd</literal>. 
</para>

<para>
Una vez recompilado el kernel, ya puede seguir compilando <literal remap="tt">pppd</literal>,
<literal remap="tt">chat</literal> y <literal remap="tt">pppstats</literal>. 
</para>

</sect2>

</sect1>

<sect1>
<title>Problemas al ejecutar <literal remap="tt">pppd</literal>.</title>

<sect2>
<title><literal remap="tt">pppd</literal> dice que la versión 0.0.0 está fuera de fecha.</title>

<para>
Está intentando ejecutar la versión 2.2 de <literal remap="tt">pppd</literal> sin haber vuelto
a recompilar los drivers en el kernel. 
</para>

</sect2>

<sect2>
<title><literal remap="tt">pppd</literal> dice que el kernel no está configurado para PPP. Pero
yo estoy seguro de haber habilitado la opción al recompilarlo. </title>

<para>
Asegúrese de que compiló el kernel y de que lo está ejecutando
actualmente.  Puede ser que lo haya recompilado, pero no lo haya movido al
directorio adecuado donde pueda verlo el gestor de arranque (LILO, por
ejemplo). 
</para>

<para>
Asegúrese también de que no tiene una copia vieja de <literal remap="tt">pppd</literal> en su
disco y esté ejecutando esa versión. La versión anterior de <literal remap="tt">pppd</literal>
se guardaba en <literal remap="tt">/usr/lib/ppp</literal>. A muchas personas no les gustaba ese
directorio, asi que en la nueva versión 2.2 se ha movido <literal remap="tt">pppd</literal>,
<literal remap="tt">chat</literal> y <literal remap="tt">pppstats</literal> al directorio <literal remap="tt">/usr/sbin</literal>. Si sus
scripts todavía apuntan hacia <literal remap="tt">/usr/lib/ppp</literal>, entonces
probablemente esté ejecutando el código antiguo. 
</para>

</sect2>

<sect2>
<title><literal remap="tt">pppd</literal> no funciona a menos que sea root.</title>

<para>
El proceso <literal remap="tt">pppd</literal> requiere hacer algunos cambios en el sistema de
red, y tales cambios sólo debería hacerlos el usuario root. Si quiere que
otro usuario ejecute <literal remap="tt">pppd</literal>, asegúrese de configurar correctamente
<literal remap="tt">sudo</literal> para permitir usar <literal remap="tt">pppd</literal> a dicho usuario. 
</para>

<para>
chmod root pppd
chmod 4755 pppd
</para>

<para>
Si quiere que el acceso a <literal remap="tt">pppd</literal> esté limitado a un determinado
grupo de usuarios, haga que el proceso <literal remap="tt">pppd</literal> pertenezca a ese
grupo en concreto y no permita que nadie más pueda ejecutarlo. 
</para>

</sect2>

<sect2>
<title>Obtengo el mensaje: <literal remap="tt">unable to create pid file: no such file or
directory</literal>. </title>

<para>
Necesita crear un directorio denominado <literal remap="tt">/var/run</literal>. En versiones
anteriores de la distribución Slackware, existía un acceso directo
(symlink) al directorio <literal remap="tt">/etc</literal>.  En realidad, este mensaje no es un
error, sino un aviso (warning). PPP funcionará correctamente aunque
aparezca este mensaje. Sin embargo, el fichero script <literal remap="tt">PPP-off</literal>
depende de este fichero para funcionar.  Es una buena idea crear el
directorio antes mencionado o bien crear un acceso directo al sitio
adecuado. 
</para>

<para>
El fichero de cabezera POSIX <literal remap="tt">paths.h</literal> define, con el nombre
<literal remap="tt">_VAR_RUN</literal>, el lugar donde debe de encontrarse este fichero. Si
quiere usar un directorio distinto para PPP y/u otros paquetes, cambie el
valor de este campo y vuelva a compilar el paquete. 
</para>

</sect2>

<sect2>
<title>Obtengo el mensaje: <literal remap="tt">/etc/ppp/options: no such file or
directory</literal>. </title>

<para>
Necesita crear este directorio y dentro de él un fichero llamado
<literal remap="tt">options</literal>. Necesita, además tener los permisos adecuados para que
pueda ser visible por el proceso <literal remap="tt">pppd</literal> (root, generalmente). 
</para>

<para>
Este fichero debería estar vacío. Para crearlo, use el comando
<literal remap="tt">touch</literal>. 
</para>

<para>
Para más información sobre la función de este fichero, consulte la página
<literal remap="tt">man</literal> de <literal remap="tt">pppd</literal>, <literal remap="tt">pppd(8)</literal>. 
</para>

</sect2>

<sect2>
<title>No puedo averiguar cuál es mi dirección IP local.</title>

<para>
Este problema suele aparecer con muchas configuraciones de la Telebit
Netblazer.  El problema no es del servidor de terminal, sino que el
sistema donde se ha instalado no le ha proporcionado un conjunto de
direcciones IP válidas. 
</para>

<para>
Esto pueden ocurrir por una serie de situaciones:

<itemizedlist>
<listitem>

<para>
La tarjeta Netblazer no tiene su dirección IP (la de usted) y usted
no tiene su dirección IP. 

</para>
</listitem>
<listitem>

<para>
La Netblazer no sabe la dirección IP de su site y usted no sabe la
dirección IP de la Netblazer. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
El enlace no funcionará hasta que ambas direcciones IP esten definidas.
</para>

<para>
Debe indicarle a la Netblazer la dirección IP a usar. Use la dirección IP
local y la direccion IP remota como parámetros a pasar al proceso
<literal remap="tt">pppd</literal>.  Esta opción tiene el formato: 
</para>

<para>
<literal remap="tt">pppd local_ip:remote_ip [resto de opciones]</literal>
</para>

<para>
(o sea la dirección IP local, dos puntos y la dirección IP remota).
</para>

</sect2>

<sect2>
<title>No puedo averiguar la dirección IP remota.</title>

<para>
Vea la pregunta anterior.
</para>

</sect2>

<sect2>
<title>Obtengo mensajes diciéndome que el número mágico no es aceptado.</title>

<para>
Este mensaje aparecerá en su log como "magic number not ACK" o "magic
number NAK". Este es un error grave y PPP no funcionará. 
</para>

<para>
Hay una probabilidad de una entre 4 billones de que los dos sistemas que
se van a conectar tengan el mismo número mágico. Si obtiene continuamente
fallos de conexión debidos al número mágico, las probabilidades de que
esto sea una coincidencia se reducirán geométricamente. 
</para>

<para>
Las razones más comunes de este fallo son:
</para>

<para>

<itemizedlist>
<listitem>

<para>
El sistema remoto no está ejecutando PPP y usted piensa que sí lo
está haciendo. ¿ Está seguro de que el sistema remoto ha sido configurado
para ejecutar PPP ?. ¿ Está el proceso PPP en su lugar adecuado ?. ¿ Tiene
los permisos adecuados ?. 

Si ocurre esto, el shell está haciendo un eco de los datos que se le
mandan.  Esta es la causa más comun. 

</para>
</listitem>
<listitem>

<para>
El módem ha desconectado nada más iniciar la conexión y le ha dejado
conectado con una cuenta en el sistema remoto. La mayoría de los módem
están configurados para hacer un eco de los datos que se les mandan, asi
que lo que usted esta viendo no es más que el eco de los datos que usted
está mandando. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
En cualquiera de los dos casos anteriores, el sistema Linux está enviando
datos al sistema remoto, el cual, a medida que llegan, se los vuelve a
enviar a usted. Esta situación se denomina un lazo (loop en ingles). 
</para>

</sect2>

<sect2>
<title>Obtengo un mensaje: <literal remap="tt">protocol reject for protocol fffb</literal>.</title>

<para>
Este mensaje suele aparecer cuando intenta conectar con un servidor de
terminal de la casa Xiplex. Según los fabricantes, la versión 5.1 de su
software tiene numerosos problemas con PPP. A partir de la versión 5.3
estos problemas ya se han solucionado. 
</para>

<para>
Si usa la versión 5.1 use la opcion <literal remap="tt">vj-max-slots 3</literal> en la línea de
comandos de <literal remap="tt">pppd</literal> para limitar el numero de slots a 3. El problema
radica en que el servidor Xiplex acepta peticiones de hasta 16 slots, pero
a partir del tercero no funciona. Si funcionase bien, deberia retornar un
frame del tipo NAK dentro del márgen que hay especificado para ello, pero
el servidor no hace tal cosa. 
</para>

<para>
Alternativamente, también puede eliminar la compresión de cabeceras Van
Jacobson con la opción <literal remap="tt">-vj</literal> a pasar a <literal remap="tt">pppd</literal>. 
</para>

</sect2>

<sect2>
<title>El software PPP conecta con el sistema remoto, envía unas cuantos
tramas, pero parece como si la conexión no fuese completa. ¿ Qué significa
esto ?. </title>

<para>
Linux no soporta módems RPI. Si su módem es RPI necesitará otro tipo de
módem para poder usarlo con Linux. Esta situación no tiene visos de
cambiar según la política que mantiene Rockwell. 
</para>

<para>
Examine el system log que obtiene cuando usa la opción <literal remap="tt">debug</literal> en la
línea de comandos de <literal remap="tt">pppd</literal>. (Necesita el log de todas maneras si
quiere pedir ayuda a alguien). Si el log muestra que se está enviando el
frame LCP-request continuamente y además el número id no se incrementa,
sino que permanece fijo, entonces esto significa que no se están enviando
frames entre su máquina y la máquina remota. 
</para>

<para>
Las tres causas más comunes de este fallo son las siguientes:
</para>

<para>

<itemizedlist>
<listitem>

<para>
El software PPP no está funcionando en la máquina con la que quiere
conectar. Está enviando tramas PPP a otro software que debe de estar
preguntándose: "¿ Qué es todo este XLSKFDJFpeojd23623 que estoy recibiendo
?". 

Asegúrese de que el sistema remoto está ejecutando PPP antes de que usted
intente conectarse a él. Pruebe a usar un programa de comunicaciones
"normal" y llame hasta que llegue a la secuencia normal de login del
sistema remoto al que se conecte. ¿ Recibe ahora frames PPP ?. 

Los frames de PPP son muy fáciles de identificar. Suelen tener 40
caracteres de longitud y contienen varios caracteres. No tienen un retorno
de carro que separe líneas y se mandan en una secuencia cíclica, con una
pausa entre secuencias. 

</para>
</listitem>
<listitem>

<para>
La línea serial no está configurada con 8 bits de datos. PPP
requiere que la línea serial esté configurada para 8 bits de datos, sin
paridad y 1 bit de stop. 

Por defecto, el software PPP coloca la linea serial con 8 bits por dato,
sin paridad y un bit de stop. El sistema remoto debe también adoptar esta
configuración. Si no es así, aparecerán errores de paridad (parity) y de
trama (frame). 

PPP ignora caracteres enteros. PPP no es capaz de ignorar bits tal y como
lo hace kermit. PPP no funcionará con un enlace de comunicación de 7 bits
por dato. 

</para>
</listitem>
<listitem>

<para>
 El sistema remoto está configurado para usar algún metodo de
identificación y verificación (CHAP o PAP). Si usted no ha configurado su
sistema con alguno de estos métodos, el sistema remoto ignora cualquier
paquete IPCP de información que se le mande, ya que estará esperando el
paquete de identificación y verificación. 

En cualquier caso la solución consiste bien en deshabilitar la
identificación y verificación en el sistema remoto, bien habilitarla en su
sistema. 

Examine la recepción de las tramas del tipo <literal remap="tt">LCP configure</literal> en el log
de la conexión. Si aparece un <literal remap="tt">auth</literal> significa que el sistema remoto
requiere identificación y verificación. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>El script <literal remap="tt">/etc/ppp/ip-up</literal> no funciona.</title>

<para>
El proceso <literal remap="tt">pppd</literal> ejecuta el script <literal remap="tt">/etc/ppp/ip-up</literal> cuando
la "capa"  del protocolo IP se ha establecido correctamente. <literal remap="tt">pppd</literal>
y el protocolo IP le proporcionan al script los parámetros que definen el
status de la línea (nombre del dispositivo de conexión, velocidad de
comunicación y dirección IP). 
</para>

<para>
Sin embargo, lo que puede parecer confuso es que se trata a
<literal remap="tt">/etc/ppp/ip-up</literal> como a un programa ejecutable y no como a un
script. El programa se "lanza" mediante la función <literal remap="tt">exec</literal> de Linux. 
</para>

<para>
Esto quiere decir que si desea utilizar este script debe de hacer dos cosas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Necesita tener el fichero marcado como ejecutable. Haga esto con
<literal remap="tt">chmod</literal>.  Los permisos correctos de funcionamiento deberían ser de 100.
Usando <literal remap="tt">chmod</literal> con un valor de 500 es aceptable si va a leer del
fichero, o bién usar el valor de 700 su va a escribir en él. Este fichero
debería ser usado por el usuario root. 

</para>
</listitem>
<listitem>

<para>
El fichero debe tener como primera línea:


<screen>
  #!/bin/sh
</screen>


El caracter # debe ser el primer caracter de la primera línea del
fichero.  El intérprete de este script (<literal remap="tt">/bin/sh</literal> en este caso)
puede ser cualquier programa que pueda ser utilizado para ejecutar
scripts. La mayoría de la gente utiliza el shell Bourne <literal remap="tt">sh</literal>, pero
pueden usarse otros como el C shell <literal remap="tt">csh</literal> o incluso <literal remap="tt">perl</literal>. Lo
realmente importante es que los dos primeros caracteres sean # y !
respectivamente. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>No puedo conectar con la red merit.</title>

<para>
Algunos usuarios de esta red han señalado que es necesario utilizar PAP
para conectar con esta red. ¿ Ha probado a activar esta opción ?. 
</para>

</sect2>

</sect1>

<sect1>
<title>DIP</title>

<sect2>
<title>DIP no tiene soporte para ejecutar PPP.</title>

<para>
La versión más actual de dip-uri si soporta el uso de PPP, ya que
utilizando la opción <literal remap="tt">mode PPP</literal>, <literal remap="tt">dip</literal> lanzará el proceso <literal remap="tt">pppd</literal>
automáticamente. Sin embargo, <literal remap="tt">pppd</literal> necesita ser invocado con varias
opciones para poder funcionar correctamente. Como <literal remap="tt">dip</literal> no pasa estas
opciones a <literal remap="tt">pppd</literal>, dichas opciones deben de estar almacenadas en el
fichero <literal remap="tt">/etc/ppp/options</literal>. 
</para>

<para>
<literal remap="tt">dip</literal> es un programa que controla el establecimiento de una conexión
SLIP entre máquinas con la ayuda de otros programas: <literal remap="tt">slattach</literal>,
<literal remap="tt">ifconfig</literal> y <literal remap="tt">route</literal>.  Todos estos programas deben ser utilizados
para lograr una conexión SLIP válida, sin embargo, no son necesarios para
realizar una conexión PPP. 
</para>

<para>
<literal remap="tt">dip</literal> puede ser usado para efectuar la llamada telefónica y arrancar el
software PPP en el sistema remoto. Para utilizarlo en este modo, es mejor
usarlo como un parámetro a pasar con la opción <literal remap="tt">connect</literal>. Sin embargo,
usted tiene la opción de permitir que <literal remap="tt">dip</literal> controle el enlace. Es
indiferente como <literal remap="tt">pppd</literal> sea ejecutado, lo que si es realmente
importante es que debe ser ejecutato <emphasis>obligatoriamente</emphasis>, ya que es un
programa imprescindible para el protocolo PPP. 
</para>

</sect2>

</sect1>

<sect1>
<title>Terminación del proceso.</title>

<sect2 id="dip-k">
<title>¿ Existe un comando similar a <literal remap="tt">dip -k</literal> para PPP ?.</title>

<para>
No. En el directorio de <literal remap="tt">chat</literal> hay un <literal remap="tt">PPP-off</literal> script.
Ejecutando este script se consigue el mismo efecto que con <literal remap="tt">dip
-k</literal>.  Este script aparece a continuación. Para usarlo, corte el texto,
sálvelo en el fichero nombrado arriba y hagalo ejecutable con
<literal remap="tt">chmod</literal>. 
</para>

<para>

<screen>
  #!/bin/sh
  DEVICE=ppp0
  #
  # Si el fichero ppp0 pid existe es que el programa esta funcinando. Paralo.
  if [ -r /var/run/$DEVICE.pid ]; then
          kill -INT 'cat /var/run/$DEVICE.pid'
  #
  # Si kill no ha funcionado entoces no hay ningun proceso asociado a este
  # pid. Tambien puede significar que el fichero lock sigue abierto. Seria deseable
  # borrar tambien el fichero lock.
          if [ ! "$?" = "0" ]; then
                  rm -f /var/run/$DEVICE.pid
                  echo "ERROR: Removed stale pid file"
                  exit 1
          fi
  #
  # OK. Ahora dejamos a pppd terminar a su manera.
          echo "PPP link to $DEVICE terminated."
          exit 0
  fi
  #
  # el proceso PPP no esta ejecutandose para ppp0
  echo "ERROR: PPP link is not active on $DEVICE"
  exit 1
</screen>

</para>

</sect2>

<sect2 id="modem-no-cuelga">
<title>PPP no cuelga el módem cuando termina.</title>

<para>
Hay varias razones para que ocurra esto:
</para>

<para>

<itemizedlist>
<listitem>

<para>
¿ Especificó la opción <literal remap="tt">módem</literal> en la línea de comandos de
<literal remap="tt">pppd</literal> ?. Este parámetro controla si es <literal remap="tt">pppd</literal> el que debe controlar
las señales de status del módem. Este parámetro aparece explicado más
detalladamente en la página <literal remap="tt">man</literal> de <literal remap="tt">pppd</literal>.

</para>
</listitem>
<listitem>

<para>
¿ Tiene el módem configurado para usar las señales DCD y DTR ?. La
secuencia Hayes para el módem es normalmente <literal remap="tt">&amp;C1</literal>. Si resetea
el módem durante la sesión con <literal remap="tt">ATZ</literal>, asegúrese de que configura su
módem correctamente. 

La señal DTR la genera el ordenador e indica al módem cuando desconectar.
La secuencia Hayes para esto es <literal remap="tt">&amp;D1</literal> o <literal remap="tt">&amp;D2</literal>,
siendo <literal remap="tt">&amp;D2</literal> la opción preferida por PPP. Muchos fabricantes de
módems deshabilitan este uso de la señal DTR en la configuración de
fábrica que viene almacenada en el módem . 

</para>
</listitem>
<listitem>

<para>
¿ Está utilizando un cable barato que no conecta la senal DCD entre
el ordenador y el módem ?. Los cables de los ordenadores Machintosh
"Classic"  son un ejemplo. Estos ordendadores no usan esta señal. 

</para>
</listitem>
<listitem>

<para>
 Para conexiones a una cuenta en un sistema remoto, ¿ lanza la
ejecución de <literal remap="tt">pppd</literal> de forma correcta ?.  El proceso <literal remap="tt">pppd</literal> debería
ser lanzado (con <literal remap="tt">exec</literal>) desde un script y no desde la línea de
comandos del shell que esté usando. Si hace esto último y ejecuta
<literal remap="tt">pppd</literal>, será el shell el que reciba la señal HUP (hang-up, colgar) y no
<literal remap="tt">pppd</literal>. 

Un script típico para lanzar <literal remap="tt">pppd</literal> es el siguiente:


<programlisting>
#!/bin/sh
exec pppd -detach modem ...
</programlisting>


</para>
</listitem>
<listitem>

<para>
El uso conjunto de de <literal remap="tt">dip</literal> y <literal remap="tt">diald</literal> puede interferir en
algunas ocasiones con la capacidad de <literal remap="tt">pppd</literal> para detectar la falta de
portadora de la línea serial. En esta situación, debería usar las opciones
<literal remap="tt">lcp-echo-request</literal> y <literal remap="tt">lcp-echo-failure</literal> para que <literal remap="tt">pppd</literal> pueda
detectar esta condición. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

</sect1>

<sect1>
<title>Transferencia de datos.</title>

<sect2>
<title>¿ En las transferencias con ftp, parece que la conexion <emphasis>muere</emphasis>
cuando hago un <literal remap="tt">put</literal>. Sin embargo, si hago <literal remap="tt">get</literal> funciona
perfectamente. ¿ Qué ocurre ?. </title>

<para>
¿ Está activado el control de flujo (flow control) ?. Esto se hace pasando
a <literal remap="tt">pppd</literal> la opción <literal remap="tt">crtscts</literal> para usar control de flujo RTS/CTS
(hardware) o <literal remap="tt">xonxoff</literal> para control de flujo XON/XOFF (software). Si no
tiene habilitado el control de flujo, probablemente está sobrescribiendo
en los buffers del módem. Esto tiene consecuencias catastróficas si
utiliza compresión de cabezeras vj (Van Jacobson). 
</para>

</sect2>

<sect2>
<title>¿ Cómo debo usar el control de flujo XON/XOFF ?.</title>

<para>
Es mejor utilizar control de flujo hardware (CTS/RTS). Sin embargo, si se
ve obligado a usar control de flujo software, siga los siguientes pasos: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
Necesita especificar la opción <literal remap="tt">xonxoff</literal> en la línea de comandos
de <literal remap="tt">pppd</literal>. Esta opción le dice al dispositivo serial a utilizar que
utilice este tipo de control de flujo. Además, carga los dos caracteres
(XON y XOFF) dentro del driver tty. 

</para>
</listitem>
<listitem>

<para>
Necesita especificar los caracteres que representan XON y XOFF en el
parámetro <literal remap="tt">asyncmap</literal> que se pasa a <literal remap="tt">pppd</literal>. Esto avisa al sistema
remoto que debe <emphasis>separar</emphasis> estos caracteres cuando quiera enviárselos a
su máquina. Esto se indica normalmente con la opción <literal remap="tt">asyncmap a0000</literal>. 

</para>
</listitem>
<listitem>

<para>
Naturalmente, no olvide decirle a su módem que utilice control de
flujo XON/XOFF. En los módem ZyXEL, se suele utilizar la secuencia
<literal remap="tt">"R1&amp;H4"</literal>. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>¿ El módem parece que conecta a velocidades extrañas. Cuando uso
<literal remap="tt">minicom</literal>, el módem siempre usa 14400 bits/segundo. Sin embargo, PPP
dice que está conectando a 9600, 7200 e incluso a 2400 bits/segundo. ¿
Cómo puedo corregir esto ?. </title>

<para>
Especifique la velocidad que desea en la línea de comandos de <literal remap="tt">pppd</literal>.
Si no especifica la velocidad, PPP utilizará cualquier velocidad que
exista.  Algunos programas no dejan los parámetros de la línea serial
iguales que cuando se ejecutaron. Esto puede causar que la línea tenga una
configuración <emphasis>extraña</emphasis>. 
</para>

<para>
Linux no soporta módems que utilizan RPI (Rockwell Protocol Interface)
porque es un protocolo propietario. Dado que Rockwell no quiere facilitar
el código necesario para poder hacer una adaptación a Linux, hay muy pocas
posibilidades de ques estos módem sean soportados por Linux. La solución
en este caso es clara: no usar módems RPI. 
</para>

<para>
Si no sabe si un módem es RPI cuando quiera adquirirlo, fíjese en las
frases publicitarias que aparecen en la caja. Frases del estilo "con
corrección de errores software", o "compatible con Windows" o "requiere un
driver especial para funcionamiento completo", usualmente suelen indicar
que el módem es RPI. 
</para>

</sect2>

<sect2>
<title>Cuando hago ftp, la operación <literal remap="tt">get</literal> es muy lenta, pero la
operación <literal remap="tt">put</literal>, sin embargo, es muy rápida. ¿ Porqué ?. </title>

<para>
¿ Especificó la opción <literal remap="tt">asyncmap 0</literal> cuando ejecutó <literal remap="tt">pppd</literal> ?. Si
olvidó esto, el peer debe <emphasis>doblar</emphasis> todos los caracteres de control en
el rango <literal remap="tt">0x00..0x1F</literal> (hexadecimal).  Esto supone una reducción de
velocidad de un 12.5 % cuando está recibiendo datos. 
</para>

<para>
¿ Ha configurado bien el sistema remoto ?. ¿ Olvidó especificar el control
de flujo del módem remoto ?. 
</para>

</sect2>

<sect2>
<title>La opción <literal remap="tt">proxyarp</literal> no encuentra la dirección hardware.</title>

<para>
Use el paquete <literal remap="tt">ppp-2.1.2d.tar.gz</literal>. El proceso <literal remap="tt">pppd</literal> fué compilado
erróneamente con el kernel 1.1.8 y usaba definiciones Net-3 en vez de la
Net-2 como le correspondía. 
</para>

<para>
Consulte ademas el mini HOWTO proxy-ARP sobre los requerimientos
necesarios para utilizar proxy ARP. 
</para>

<para>
El paquete 2.1 tiene establecido un límite de 64 dispositivos de red.
Cuando se escribió el código de <literal remap="tt">proxyarp</literal> se pensó que era un número
razonable, dado que la mayoría de la gente suele tener uno o dos
controladores Ethernet como máximo en una máquina. Hoy en día hay máquinas
que tienen conectados hasta 128 dispositivos de red. 
</para>

<para>
La versión 2.2 ha elevado el límite a 256 dispositivos de red. Este límite
aparece en forma de un <literal remap="tt">#define</literal> que se encuentra en el módulo
<literal remap="tt">sys-linux.c</literal>. 
</para>

</sect2>

</sect1>

<sect1>
<title>Rutado y otros problemas.</title>

<sect2>
<title>¡ Mi ruta al sistema remoto sigue desapareciendo !. Estuvo activa
unos 3 minutos y ha vuelto a desaparecer. ¡ Ayuda !. </title>

<para>
Esta no es una pregunta que esté relacionada con PPP.
</para>

<para>
Pista: ¡ <emphasis>NO EJECUTE</emphasis> <literal remap="tt">routed</literal> !.
</para>

</sect2>

<sect2>
<title>¿ Me gustaría conectar los ordenadores de mi red a Internet usando
PPP. Sólo tengo una dirección IP que me es asignada por mi proveedor de
servicios de conexión (incluso esa dirección IP es asignada
dinámicamente). ¿ Cómo puedo hacer esto ?. </title>

<para>
No se puede. Al menos no de la manera que a usted le gustaría hacerlo
normalmente. El problema reside en que su proveedor no sabría las
direcciones IP de las máquinas conectadas a su red y, por tanto, no
rutaría ninguna trama a su sistema local. 
</para>

<para>
Sin embargo, existen otras soluciones:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Puede hacer un <literal remap="tt">telnet</literal> a la máquina que está conectada a
Internet usando <literal remap="tt">pppd</literal>. Una vez conectado a esa máquina, ya puede hacer
<literal remap="tt">telnet</literal> o <literal remap="tt">ftp</literal> al resto de Internet. Realmente, esto no es mucho
mejor que usar el ordenador directamente, pero es útil para realizar cosas
sencillas. 

</para>
</listitem>
<listitem>

<para>
Use un kernel reciente de la serie 1.3 y utilice la opcion <literal remap="tt">IP
Masquerade</literal>. Para saber más sobre cómo usar esta característica, debería
unirse a la lista de correo electrónico <literal remap="tt">linux-net developer</literal> o bien
consultar el documento <literal remap="tt">Net-2-HOWTO</literal>. 

</para>
</listitem>
<listitem>

<para>
Ejecute el programa <literal remap="tt">socks</literal> en su sistema PPP. Este programa
realizará la misma función que si usa <literal remap="tt">IP Masquerade</literal> pero, por contra,
necesitará clientes modificados. La ventaja de usar <literal remap="tt">socks</literal> es que este
programa lleva mucho tiempo circulando por ahí y muchos clientes
entenderán el concepto de servidor <emphasis>proxy</emphasis> (<literal remap="tt">proxy server</literal>) que es
necesario para trabajar correctamente con el programa. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Conecto con la máquina del sistema remoto, pero no puedo hacerlo
con ninguna otra máquina de dicho sistema. </title>

<para>
¿ Ha olvidado añadir el parámetro <literal remap="tt">defaultroute</literal> a la línea de
comandos de <literal remap="tt">pppd</literal> ?. Este parámetro añade una ruta por defecto
(default route) a su sistema de rutado, permitiendo que los frames
dirigidos a otras direcciones IP se canalicen a través del dispositivo
PPP. 
</para>

<para>
El software PPP no reemplazará la ruta por defecto si ya existía una
anterior a la ejecución de <literal remap="tt">pppd</literal>. El motivo de esto es evitar que
alguien pueda destruir accidentalmente la ruta por defecto a sus routers
ethernet. Un aviso aparecerá en el system log si <literal remap="tt">defaulrotute</literal> no
se ejecuta por esta razón. 
</para>

</sect2>

<sect2>
<title>Tengo una ruta por defecto pero sigo sin poder acceder al resto de
máquinas. ¿ Y ahora que hago ?. </title>

<para>
El problema no es entonces de su sistema Linux local. Lo más probable es
que haya un problema de rutado en la máquina remota. 
</para>

<para>
El sistema remoto no está configurado para <literal remap="tt">IP forwarding</literal>. En el RFC
de PPP se especifica que esta opción <emphasis>NO</emphasis> debe estar activada por
defecto.  Esta opción debe habilitarse. Para sistemas Linux, necesita
volver a compilar el kernel y especificar que desea <literal remap="tt">IP
forwarding/gatewaying</literal>. 
</para>

<para>
El ordenador remoto necesita una ruta hacia su máquina de la misma manera
que usted necesita una ruta hacia él. Esto puede hacerse por uno de los
cuatro métodos siguientes. Cada uno tiene sus ventajas y sus
inconvenientes y recuerde que sólo puede usar un metodo y sólo uno. 
</para>

<para>

<itemizedlist>
<listitem>

<para>
Use una ruta de host (host route). En cada host del sistema remoto,
añada una ruta a la dirección IP de su máquina Linux, siendo el gateway la
máquina que usted usa para conectar con ese sistema. Esto es adecuado si
el sistema remoto tiene pocas máquinas conectadas y usa una red simple,
sin bridges, routers, gateways, etc. 

</para>
</listitem>
<listitem>

<para>
Use una ruta de red (network route). Divida la dirección IP remota
de tal manera que la dirección IP local de su máquina Linux, la de la
máquina remota con la conecta usando PPP y la de la tarjeta Ethernet que
conecta esta máquina con el resto de su red pertenezcan al mismo dominio. 

Esto funciona si tiene suficientes direcciones IP para poder repartirlas.
Si tiene un dominio de direcciones IP de red de clase B, esta solución
funciona muy bien, puesto que puede poner todas las direcciones de las
máquinas remotas en el mismo dominio de direcciones IP. 

Una vez hecho esto, añada una ruta de red en cada uno de los gateways y
routers, de tal forma que cualquier dirección de la red remota sea enviada
al servidor de terminal. La mayoría de las configraciones de redes locales
tienen muchos hosts pero pocos routers. (Por ejemplo, en sii.com, hay unos
300 hosts activos con solo 3 routers). 

</para>
</listitem>
<listitem>

<para>
Use <literal remap="tt">gated</literal> en todos los gateways y en el servidor de terminal.
Con esto se consigue que el servidor de terminal <emphasis>propague</emphasis> (broadcast)
los frames para su dirección IP a los gateways adecuados. Como los hosts
tendrán una ruta por defecto a uno de los gateways, este gateway generará
una trama de redirección ICMP y el host específico añadirá automáticamente
su propia ruta de host. 

</para>
</listitem>
<listitem>

<para>
Utilice proxy ARP en el servidor de terminal. Esto sólo funcionará
si su dirección IP remota está en el mismo dominio de direcciones IP que
uno de los dominios de las tarjetas de red del sistema remoto.  
</para>
</listitem>

</itemizedlist>

No hay solucion "exacta". Debe elegir la que mejor se adapte a sus
circunstancias. 
</para>

<para>
Si su router remoto necesita recibir tramas RIP para poder actualizar la
ruta hacia su sistema, entonces debería usar el programa <literal remap="tt">bcastd</literal> de
<literal remap="tt">sunsite.unc.edu</literal>. Este programa genera las tramas RIP sin necesidad de
que tenga que instalar y ejecutar <literal remap="tt">gated</literal>. 
</para>

</sect2>

<sect2>
<title>No puedo hacer <literal remap="tt">ping</literal> a mi dirección IP local.</title>

<para>
No puede hacer esto porque normalmente no tiene definida una ruta hacia
esa dirección. Este es el modo normal de funcionamiento, asi que no hay
nada anormal.  Si quiere hacer un <literal remap="tt">ping</literal> a su sistema, utilice la
dirección del dispositivo loopback (127.0.0.1). 
</para>

<para>
Puede hacer un ping a la direccion IP remota, si así lo desea. Sin
embargo, algunos servidores de terminal no permitirán esto, ya que esa
dirección esta ocupada <emphasis>telefónicamente</emphasis> para ellos. Esto depende de la
configuración específica de cada servidor .  En general, no haga <literal remap="tt">ping</literal>
a ninguna de las 2 direcciones ( local o remota ). Elija una dirección IP
de otra máquina que sepa que está en la red remota (una de su nameserver,
por ejemplo). 
</para>

<para>
Mientras el software PPP no haga esta tarea, debe de añadir manualmente a
la tabla de rutado la ruta al host con el que acaba de conectar. Esto se
hace con el comando
</para>

<para>
route add -host 192.187.163.32 lo
</para>

<para>
Donde la dirección IP local es 192.187.163.32 en este ejemplo. Esto le
dice al software de red que debe dirigir todas las tramas destinadas a su
dirección IP al dispositivo loopback. Una vez que ha añadido la ruta
apropiada a la dirección IP local, entonces ya puede usar esta dirección
como el destino para las tramas IP. 
</para>

<para>
Usted es el responsable de eliminar esta ruta cuando el enlace termine.
</para>

</sect2>

</sect1>

<sect1>
<title>Interacción con otras implementaciones de PPP.</title>

<sect2>
<title>Estoy usando Trumpet (para MSDOS) y la conexión simplemente
termina. ¿ Porqué ocurre esto ?. </title>

<para>
Trumpet no acepta ningún tipo de compresión de cabeceras VJ. Utilize
<literal remap="tt">pppd</literal> con la opción <literal remap="tt">-vj</literal> para desactivar esta compresión. 
</para>

</sect2>

<sect2>
<title>Estoy usando <literal remap="tt">dp-3.1.2</literal> (con SunOS) y el sistema no me permite
hacer nada más que <literal remap="tt">ping</literal> o <literal remap="tt">nslookup</literal>. ¿ Porqué ocurre esto ?. </title>

<para>
Existe un fallo en la versión 3.1.2 de <literal remap="tt">dp</literal>. Actualícese a la versión
3.1.2a o posterior. Puede conseguirla en el <ulink
url="http://www.ecn.purdue.edu"
>home site de dp</ulink
>. 
</para>

<para>
Hasta que consiga esta actualización, no utilice compresión de cabeceras
VJ. 
</para>

</sect2>

<sect2>
<title>No puedo conectar con/desde mi máquina con Windows NT.</title>

<para>
Microsoft ha elegido para Windows NT un sistema no estandar de
identificación y verificación. Están en su derecho, ya que han registrado
su propio protocolo en la IANA. Si en la casilla "accept only Microsoft
encrypted authentication" está activada en la entrada "phone book",
entonces la conexión no podrá realizarse. Esta opción le indica a Windows
NT, que sólo puede comunicarse con otro sistema que tenga implementado el
protocolo PPP propio de Microsoft (otro sistema Windows NT). 
</para>

<para>
Linux no soporta este tipo de identificación y verificación.  Si puede
cambiar las opciones del sistema de su Windows NT, vaya a las opciones de
Windows NT Phone Book, eliga advanced, luego security settings y asegúrese
de que la casilla "Accept any authentication including clear text" está
activada y que la casilla "accept only Microsoft encrypted authentication"
no está activada. El resto de casillas del cuadro de dialogo no influyen
en este tema. 
</para>

<para>
Una vez hecho esto, utilice PAP en su máquina Linux y ponga el login y el
password de la máquina Windows NT en el fichero habitual
<literal remap="tt"></literal>etc/ppp/pap-secrets/. 
</para>

<para>
La secuencia de identificación y verificación de Microsoft es una variante
del sistema PAP con el password protegido por un sistema de criptografiado
del tipo DES. El sistema PAP normal envía las password sin encriptar, lo
cual supone una violacion de seguridad dentro del sistema de seguridad que
Microsoft ha elegido (tipo C2). 
</para>

<para>
Versiones anteriores del código de PPP a la 2.1.2c tienen un fallo en el
sistema de decodificación de las peticiones de identificación y
verificación. Una comunciación entre un sistema Windows NT y esta versión
no podrán nunca negociar. La versión actual, 2.2 o la 2.1.2d (si necesita
el soporte para la serie de kernels 1.1) deberían ser usadas en esta
situación
</para>

<para>
Segun Scott Hutton (<literal remap="tt">shutton@habanero.ucs.indiana.edu</literal>): 
</para>

<para>
Básicamente, NT RAS (Remote Access Services) terminará la conexión si su
máquina rechaza (REJ) algún componente del protocolo que sea crítico (i.e.
el protocolo de identificación y verificación). El truco consiste en crear
un fichero chap-secrets de lo mas simple. El mio es: 
</para>

<para>

<screen>
*	""	""
</screen>

</para>

<para>
Esto le dice a pppd que debe enviar un NAK (no aceptado) en vez de un REJ
(rechazado). Con la clave de registro (registry key) SPAP eliminada, el
siguiente protocolo a probar es PAP (que es el que yo uso). 
</para>

<para>
Otras personas afirman que SOLO los servicios de red TCP/IP deben estar
habilitados en el RAS (ni NetBEUI ni IPX (Ed: IPX está comprobándose
ahora.  Hasta que esté instalado convenientemente, es una buena idea
deshabilitarlo.)). También he tenido que batallar con un montón de claves
de registro (registry keys) para eliminar timeouts (que son problemáticos
cuando sólo se quiere usar TCP/IP): 
</para>

<para>

<screen>
  HKEY_LOCAL_MACHINE\eSYSTEM\eCurrentControlSet\eServices\eRemoteAccess\eP
           Autodisconnect: REG_DWORD: 0
</screen>

</para>

<para>
y para conseguir que el rutado funcione correctamente:
</para>

<para>

<screen>
  HKEY_LOCAL_MACHINE\eSYSTEM\eCurrentControlSet\eServices\eRasArp\eParamet
           DisableOtherSrcPackets: REG_DWORD: 0
</screen>

</para>

<para>
Para finalizar, la clave a eliminar para eliminar SPAP es:
</para>

<para>

<screen>
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\RasMan\PPP\SPAP
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>Otros mensajes enviados al system log.</title>

<sect2>
<title>Alarm.</title>

<para>
Esto no es un problema, aunque su nombre lo parezca. Sólo significa que un
temporizador (timer) ha concluido su cuenta. Los temporizadores son una
parte necesaria durante la fase de establecimiento del protocolo. 
</para>

</sect2>

<sect2>
<title>SIGHUP.</title>

<para>
El proceso <literal remap="tt">pppd</literal> ha recibido una señal HUP. La señal HUP se genera por
el software que controla el dispositivo tty cuando el dispositivo remoto
al que se estaba conectado ha terminado el enlace a través del módem. Esto
significa que el módem ha colgado ("hang up" en inglés) la conexión.  El
programa <literal remap="tt">kill</literal> también puede ser usado para enviar esta señal al
proceso <literal remap="tt">pppd</literal>.  Cuando <literal remap="tt">pppd</literal> recibe esta señal, empieza la
secuencia de finalización del enlace de una manera ordenada. 
</para>

</sect2>

<sect2>
<title>SIGINT.</title>

<para>
El proceso <literal remap="tt">pppd</literal> ha recibido una señal INT. Esta señal la genera el
software que controla la consola cuando se pulsa un CTRL+C y <literal remap="tt">pppd</literal> se
está ejecutando como un proceso de segundo plano (background).  Igualmente
<literal remap="tt">kill</literal> también puede generar esta señal para el proceso <literal remap="tt">pppd</literal>.  De
hecho, esta es la forma <emphasis>educada</emphasis> de finalizar la ejecución de
<literal remap="tt">pppd</literal> y terminar con el enlace. Vea la pregunta referida a <literal remap="tt">dip -k</literal>
(pregunta <xref linkend="dip-k"/>) para ver un script que realiza esta función.  De la
misma manera que con SIGHUP, <literal remap="tt">pppd</literal> termina con el enlace de una manera
ordenada. 
</para>

</sect2>

<sect2>
<title><literal remap="tt">Unknow protocol (c025) received</literal>.</title>

<para>
El sistema remoto desea utilizar el protocolo Lynk Quality Reporting con
su sistema Linux. Este protocolo no está soportado por la versión actual
de PPP para Linux. Esto no es un error, sólo indica que el sistema remoto
está enviando una invitación a usar este protocolo y Linux le responde con
un delicado: "No puedo hacer lo que me pides ahora, asi que no me marees
más con esto". 
</para>

<para>
El paquete PPP de Morning Star Software siempre intentará utilizar este
protocolo LQP. Esto es normal y no significa que el enlace no pueda
realizarse o sea erróneo. 
</para>

</sect2>

<sect2>
<title><literal remap="tt">Unknow protocol (80fd) received</literal>.</title>

<para>
El sistema remoto quiere utilizar el protocolo de control de compresión
(Compresion Control Protocol) con su sistema Linux. Este protocolo se
situa "por encima" del protocolo básico y, si se negocia correctamente, se
obtiene una reducción del número de bytes transmitidos en cada trama.  O
sea, que la transmisión es más rápida. 
</para>

<para>
Sin embargo, existen un buen número de compresores que pueden agruparse
bajo el tármino de Compression Control Protocol. La versión 2.2 del
paquete PPP sólo entiende uno: el compresor BSD. Este compresor funciona
de forma muy parecida a como lo hace el programa <literal remap="tt">compress</literal> de UNIX y
utiliza una compresión del tipo LZW.  Dependiendo del tamaño del código,
puede ser necesario una gran cantidad de espacio del kernel para
incorporar los diccionarios de compresión y descompresión necesarios. Esto
no debería ser utilizado si su máquina tiene un espacio limitado de
memoria (ni siquiera lo intente si tiene 8 megabytes o menos de RAM
física). Para estos casos, debería adquirir un módem decente que soporte
este tipo de compresión. 
</para>

<para>
A menos que los dos extremos del enlace acepten este tipo de compresión,
ésta no se utilizará en la conexión. 
</para>

<para>
Otro tipo común de compresor es Predictor-1. Necesita menos memoria y se
ejecuta más rápido. Sin embargo, su compresión no es tan buena como el de
BSD, ya que envía unos pocos más de bytes por cada trama. 
</para>

<para>
Muchos servidores de terminal comerciales utilizan un compresor denominado
Stacker(TM) LZW o Protocolo LZS. Este tipo de compresor es comercial y
requiere una licencia de uso. Aparentemente, Stacker le puede dar a usted
esa licencia gratis, pero existe otra licencia más específica que le
impide utilizar este tipo de compresión junto con <literal remap="tt">pppd</literal>. 
</para>

</sect2>

<sect2>
<title>La conexión falla con errores como <literal remap="tt">ioctl(TIOCGETD): I/O
error</literal> o <literal remap="tt">ioctl(PPPIOCSINPSIG): I/O error</literal>. </title>

<para>
Examine los mensajes que aparecen cuando arranca el sistema. Si aparece el
mensaje <literal remap="tt">PPP version 0.1.2</literal> es que tiene una versión antigua del driver
<literal remap="tt">PPP.c</literal>. 
</para>

<para>
Si aparece <literal remap="tt">PPP version 0.2.7</literal>, entonces tiene una versión actualizada
de <literal remap="tt">PPP.c</literal> para el paquete 2.1.2. Sin embargo, este fichero no fué
compilado con el mismo conjunto de números de ioctl. Asegurése que sólo
tiene un fichero llamado <literal remap="tt">if_ppp.h</literal>. Debería estar situado en el
directorio donde están los ficheros include del kernel de linux. Una vez
hecho esto, vuelva a compilar el kernel y el proceso <literal remap="tt">pppd</literal>. 
</para>

<para>
Si aparece <literal remap="tt">PPP version 2.2.0</literal> entonces está usando el driver
correspondiente a la versión 2.2 del paquete. Esta versión del driver solo
funciona con las versiones 2.2 del paquete <literal remap="tt">pppd</literal>. El programa
<literal remap="tt">pppd</literal> versión 2.2 sólo funcionará con esta versión del driver. 
</para>

</sect2>

<sect2>
<title>Ocurren errores del tipo <literal remap="tt">ioctl(PPPIOCGDEBUG): I/O error</literal>,
<literal remap="tt">ioctl(TIOCSETD): I/O error</literal> o <literal remap="tt">ioctl(TIOCNXCL): I/O error</literal>.
¿ Porqué ocurre esto ?. </title>

<para>
El sistema remoto ha desconectado el teléfono. Los drivers tty intentan
reestablecer la disciplina de conexión que tenían antes de perder la
línea. A la vez, <literal remap="tt">pppd</literal> intenta hacer lo mismo que estos drivers tty
para poder recuperar la conexión.  Cuando se produce esta situación es
normal que estos errores aparezcan. 
</para>

</sect2>

<sect2>
<title><literal remap="tt">ifconfig</literal> me proporciona una información extraña con PPP.</title>

<para>
Normalmente, <literal remap="tt">ifconfig</literal> proporciona una información parecida a esta:
</para>

<para>

<screen>
   ppp0      Link encap UNSPEC  HWaddr 00-00-00-00-00-00-00 ...
             inet addr 192.76.32.2  P-t-P 129.67.1.65  Mask 255.255.255.0
             UP POINTOPOINT RUNNING  MTU 1500  Metric 1

</screen>

</para>

<para>
Este mensaje aparece sólo con propósitos informativos. Si usa una versión
reciente del kernel, actualice el paquete <literal remap="tt">nettools</literal> por el de
<literal remap="tt"><ulink
url="http://sunacm.swan.ac.uk/pub/Linux/networking/nettools"
>http://sunacm.swan.ac.uk/pub/Linux/networking/nettools</ulink
></literal>. 
</para>

</sect2>

<sect2>
<title>El fichero <literal remap="tt">proc/net/dev</literal> parece que esta vacío.</title>

<para>
¿ Tecleó el comando <literal remap="tt">ls -l /proc/net</literal> y se está preguntando cómo
puede ser que tenga un tamaño de 0 bytes ?. Si es así, no se preocupe
porque es normal. En vez de eso teclee: 
</para>

<para>
<literal remap="tt">cat /proc/net/dev</literal>
</para>

<para>
Ahora no debería de estar vacío. El hecho de que la longitud del fichero
sea cero se debe a que se encuentra en un sistema de ficheros del tipo
"proc". De la misma manera, usar <literal remap="tt">more</literal>, <literal remap="tt">less</literal> o <literal remap="tt">most</literal> tampoco
deben usarse para visualizar este fichero. Si quiere un resultado similar
haga
</para>

<para>
<literal remap="tt">cat /proc/net/dev | less</literal>
</para>

</sect2>

<sect2>
<title>El kernel informa que los dispositivos PPP están siendo
"desactivados" cuando el sistema empieza a arrancar. </title>

<para>
Esto no es un problema. Este mensaje es el resultado de la llamada que
hace el driver de PPP al procedimiento <literal remap="tt">unregister_netdev</literal>. Esta
llamada permite al driver de PPP solicitar dinámicamente el número de
dispositivos que sean necesarios. No hay un límite real sobre el número de
ellos a crear. Por poner un límite, se ha elegido el valor de 256
dispositivos. Si encuentra que este número es pequeño, entonces debe
cambiar el <literal remap="tt">#define</literal> que se encuentra en el fichero <literal remap="tt">ppp.c</literal> y
poner el valor que desee. Este será el número de dispositivos que serán
cargados dinámicamente. 
</para>

</sect2>

<sect2>
<title>Acabo de comprobar que <literal remap="tt">/proc/net/dev</literal> no tiene ningún
dispositivo PPP. ¿ Donde están ?. </title>

<para>
No están en ningún sitio. Fueron desconectados durante el arranque del
sistema. Vea la pregunta anterior para más información. 
</para>

</sect2>

</sect1>

<sect1>
<title>Rutado con redes locales (usando PPP como un "bridge" económico).</title>

<sect2>
<title><literal remap="tt">Slattach</literal> e <literal remap="tt">ifconfig</literal> no funcionan como con SLIP.</title>

<para>
No utilice <literal remap="tt">slattach</literal> ni <literal remap="tt">ifconfig</literal> con PPP. Estos programas se usan
con SLIP. El proceso <literal remap="tt">pppd</literal> realiza las funciones de estos programas en
el momento adecuado. Estas funciones deben realizarse después de que se
hayan intercambiado los protocolos LCP e IPCP entre las máquinas que
realizan la conexión. 
</para>

<para>
Usted no puede reemplazar <literal remap="tt">ifconfig</literal> y <literal remap="tt">slattach</literal> por <literal remap="tt">pppd</literal>. La
mayoria de los protocolos que se usan con PPP residen dentro del código de
<literal remap="tt">pppd</literal>. Sólo el protocolo IP ( y el IPX cuando esté terminado ) residen
dentro del kernel. 
</para>

<para>
La ruta de host (host route) al sistema remoto la añade automáticamente
<literal remap="tt">pppd</literal>. No hay ninguna posibilidad de no añadir esta ruta. El proceso
<literal remap="tt">pppd</literal> terminará si no puede definirla y añadirla a la tabla de rutas
del sistema. 
</para>

<para>
La ruta por defecto (default route) puede ser o no añadida. Esto se
controla con la opcion <literal remap="tt">defaultroute</literal>. Si ya existía una ruta por
defecto anterior, <literal remap="tt">pppd</literal> no definirá una nueva, sino que conservará la
ya existente. 
</para>

<para>
Si quiere gobernar el rutado para una red entera, ponga el comando
<literal remap="tt">route</literal> dentro del script <literal remap="tt">/etc/ppp/ip-up</literal>. Los parámetros de
este script son: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
$0 : nombre del script que se esta ejecutando
(<literal remap="tt">/etc/ppp/ip-up</literal> o <literal remap="tt">/etc/ppp/ip-down</literal> ).
</para>
</listitem>
<listitem>

<para>
$1 : nombre del dispositivo de red (<literal remap="tt">ppp0</literal> por ejemplo).
</para>
</listitem>
<listitem>

<para>
$2 : nombre del dispositivo tty (<literal remap="tt">/dev/cua0</literal> por ejemplo).
</para>
</listitem>
<listitem>

<para>
$3 : velocidad del dispositivo tty en bits por segundo (14400 por
ejemplo).
</para>
</listitem>
<listitem>

<para>
$4 : la dirección IP local (en formato xxx.yyy.zzz.vvv).
</para>
</listitem>
<listitem>

<para>
$5 : la direccion IP remota (en formato xxx.yyy.zzz.vvv).
</para>
</listitem>
<listitem>

<para>
$6 : el valor del parámetro <literal remap="tt">ipparam</literal>.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Quiero definir una ruta a la red entera y no sólo a un host de esa red.</title>

<para>
Existe en <literal remap="tt">sunsite</literal> un paquete llamado <literal remap="tt">devinfo.tar.gz</literal> que contiene
una serie de pequeñas utilidades que extraen datos sobre el dispositivo de
red que se esté usando y, junto con las direcciones IP del enlace,
proporcionan informaciones muy útiles.  La documentación se encuentra en
las páginas <literal remap="tt">man</literal> del paquete. 
</para>

<para>
Por ejemplo, si quiere rutar el dominio entero de direcciones IP en la red
remota, haga lo siguiente en el script <literal remap="tt">/etc/ppp/ip-up</literal>.
Naturalmete, si los valores no son variables sino fijos, entonces
simplemente use esos valores en las entradas apropiadas del comando
<literal remap="tt">route</literal>. 
</para>

<para>

<screen>
  # Obtener la mascara de red (netmask) para el dispositivo ppp0 (o cualquier otro).
  NETMASK = "devinfo -d $1 -t mask"
  # Obtener el dominio IP (sin la direccion del host eliminando los bits extra)
  DOMAIN = "netmath -a $5 $NETMASK"
  # Creamos la network route ahora que ya se sabe el dominio IP
  route -net add $DOMAIN gw $5
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>Otras características y protocolos.</title>

<sect2>
<title>¿ Existe soporte para <literal remap="tt">demand dial</literal> ?.</title>

<para>
Utilice el paquete <literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/system/Network/serial"
>ftp://sunsite.unc.edu/pub/Linux/system/Network/serial</ulink
></literal>. Está en
<literal remap="tt">sunsite</literal>, en el mismo directorio que el código fuente de PPP.
</para>

</sect2>

<sect2>
<title>¿ Existe soporte para filtrado (<literal remap="tt">filtering</literal>) ?.</title>

<para>
No hay intención de implementar filtrado dentro del código de PPP.  La
versión 1.3 del kernel soporta una opción <literal remap="tt">firewall</literal> que debría usar en
vez de buscar un método de embutir la lógica de funcionamiento de un
cortafuegos (firewall) dentro de un dispositivo de red. Puede usar bien
<literal remap="tt">ipfw</literal>, bien <literal remap="tt">ipfwadm</literal> para definir las reglas que gobiernan el
funcionamiento del cortafuegos que está dentro del kernel. 
</para>

</sect2>

<sect2>
<title>¿ Existe soporte para IPX ?.</title>

<para>
El soporte IPX sería muy fácil de implementar. Esto se está haciendo en la
actualidad, gracias, sobre todo, al apoyo de <ulink
url="http://www.caldera.com"
>Caldera</ulink
>. 
</para>

</sect2>

<sect2>
<title>¿ Existe soporte para NetBIOS ?.</title>

<para>
Hay definido un protocolo PPP para NetBIOS. Sin embargo, la solución
óptima consiste en usar TCP/IP y la aplicación <literal remap="tt">samba</literal>. 
</para>

<para>
Microsoft y otras compañías han usado el protocolo PPP de NetBIOS.
</para>

<para>
El protocolo nbfcp y su documentación son de libre acceso y puede
obtenerse de numerosas fuentes. El protocolo NetBIOS no es una familia de
protocolos válidos actualmente para Linux. Hasta que Linux lo soporte, no
hace mucha falta el soporte de NetBIOS en el PPP de Linux. 
</para>

</sect2>

<sect2>
<title>¿ Existe soporte para ISDN ?.</title>

<para>
Para que se soporte ISDN se necesita un driver ISDN que funcione. El
diseño actual del driver PPP no se adapta bien al concepto ISDN de
recepción de bloques de datos. Esto está cambiando. Un driver para el
interfaz Sonix se está desarrollando actualmente. 
</para>

</sect2>

<sect2>
<title>¿ Existe soporte para multipuntos (multi-point) ?.</title>

<para>
Multi-point sería una característica muy útil para el PPP de Linux. Sin
embargo, el autor no tiene conocimiento de nadie que esté intentando
construir este tipo de soporte actualmente. 
</para>

</sect2>

<sect2>
<title>¿ Existe soporte para PPP síncrono ?.</title>

<para>
Son necesarios pequeños cambios para soportar un interfaz serial con
comunicación síncrona. El rediseño que se está haciendo del driver PPP
está también orientado hacia este fin.  Kate Marika Alhola ha mostrado su
interés en escribir este soporte.  Debería contactar con ella (<ulink
url="mailto:kate@digiw.fi"
>kate@digiw.fi</ulink
>) para más información. 
</para>

<para>
Actualmente, Kate ha informado al autor que este driver está ya en fase de
pruebas, funcionando con máquinas Cisco(TM) y con velocidades de 64K y
256K. El código fuente del programa se encuentra bajo la licencia GPL de
la GNU y puede encontrarse en <ulink
url="ftp://nic.funet.fi/pub/Linux/kernel/xnet-sync-driver-1.0.tar.gz"
>nic.funet.fi</ulink
>
</para>

</sect2>

</sect1>

<sect1>
<title>Miscelánea</title>

<sect2>
<title>¿ Existe un lector de correo compatible con PPP ?.</title>

<para>
¿ Uh ?. PPP no tiene nada que ver con el mail user agent (el programa que
le presenta el correo en pantalla). Todos estos programas son compatibles
con PPP. 
</para>

</sect2>

<sect2>
<title>¿ Y un lector de news ?.</title>

<para>
Vuelva a leer la pregunta anterior.
</para>

</sect2>

</sect1>

<sect1>
<title>Preguntas sobre <literal remap="tt">chat</literal>.</title>

<sect2>
<title>Mi módem no marca cuando ejecuto <literal remap="tt">chat</literal>.</title>

<para>
El módem debe encontrarse en modo comando para poder marcar. Si su módem
ya está en linea, los comandos de marcado se envían al sistema remoto como
si fuesen datos normales. 
</para>

<para>
Si es posible, configure su módem para que monitorice la señal DTR y
retorne al modo de comandos cuando se desactive esta señal. Esto permitirá
al ordenador forzar al módem para que vuelva al modo de comandos cuando el
proceso <literal remap="tt">pppd</literal> termine como resultado del fin de la conexión. De este
modo, se asegura que el módem se queda en el estado adecuado para que
<literal remap="tt">chat</literal> pueda marcar. 
</para>

<para>
Si no puede cambiar la configuración del módem, entonces debería cambiar
la secuencia de marcado para que se parezca a la siguiente. Esta secuencia
se asegura que el módem está en modo comando antes de intentar enviar la
secuencia de marcado al módem.  
</para>

<para>
 
<screen>
 TIMEOUT 3 "" \rAT
OK-+++\c-OK AT&amp;D2&amp;C1 TIMEOUT 60 OK ATDT555-1212 CONNECT
</screen>
 
</para>

<para>
 Esta secuencia cambia el temporizador de alarma a 3
segundos. Este valor se acomoda al tiempo requerido por la mayoría de los
módem para responder. Tras esto, envía un AT al módem para esperar su
respuesta OK. Si esto no sucede en el tiempo especificado en el TIMEOUT (3
segundos), manda la secuencia +++ al módem y espera de nuevo una respuesta
OK del módem. Una vez recibida la confirmación del módem, configura el
módem adecuadamente, restablece el TIMEOUT y marca (por tonos) el número
de teléfono (555-1212). 
</para>

</sect2>

<sect2>
<title>El módem solo marca en el segundo intento.</title>

<para>
Vea la pregunta anterior. Generalmente esto suele ser causado por el mismo
problema que el descrito en la pregunta anterior. 
</para>

</sect2>

<sect2>
<title>El script de <literal remap="tt">chat</literal> se para tras enviar el login al sistema remoto
y nunca envía el password.</title>

<para>
Algunos sistemas, especialmente SCO, vacían los buffers de recepción justo
tras escribir el prompt de entrada del login y del password. <literal remap="tt">Chat</literal>
normalmente transmite la respuesta al prompt nada más ver este prompt. El
resultado de todo esto es que la respuesta que ha enviado <literal remap="tt">chat</literal> se
pierde al vaciarse el buffer. Como el sistema remoto no ha recibido el
login, no pregunta por el password y como <literal remap="tt">chat</literal> está esperando
precisamente eso, se ha llegado a un estado de bloqueo. 
</para>

<para>
La solución es sencilla. Enleztezca las respuestas de <literal remap="tt">chat</literal>, de tal
forma que haya tiempo en el sistema remoto para vaciar su buffer antes de
que <literal remap="tt">chat</literal> envíe la respuesta. Para hacer esto, cambie las cadenas de
respuesta del script a algo como esto: 
</para>

<para>

<screen>
ogin:--ogin: \d\daccount assword: \d\dhello2u2
</screen>

</para>

<para>
Donde cada &bsol;d representa un retraso (delay) de un segundo a esperar
por <literal remap="tt">chat</literal> antes de enviar la respuesta.
</para>

</sect2>

</sect1>

<sect1 id="Grupos">
<title>Anexo: El INSFLUG </title>

<para>
El <emphasis>INSFLUG</emphasis> forma parte del grupo internacional <emphasis remap="it">Linux
Documentation Project</emphasis>, encargándose de las traducciones al castellano de
los Howtos (Comos), así como la producción de documentos originales en
aquellos casos en los que no existe análogo en inglés. 
</para>

<para>
En el <emphasis remap="bf">INSFLUG</emphasis> se orienta preferentemente a la traducción de
documentos breves, como los <emphasis>COMOs</emphasis> y <emphasis>PUFs</emphasis> (<emphasis remap="bf">P</emphasis>reguntas de
<emphasis remap="bf">U</emphasis>so <emphasis remap="bf">F</emphasis>recuente, las <emphasis remap="it">FAQs</emphasis>. <literal remap="tt">:)</literal> ), etc. 
</para>

<para>
Diríjase a la sede del INSFLUG para más información al respecto.
</para>

<para>
En la sede del INSFLUG encontrará siempre las <emphasis remap="bf">últimas</emphasis> versiones de
las traducciones:  <literal remap="tt"><ulink
url="www.insflug.org"
>www.insflug.org</ulink
></literal>. Asegúrese de comprobar cuál es la última
versión disponible en el Insflug antes de bajar un documento de un
servidor réplica. 
</para>

<para>
Se proporciona también una lista de los servidores réplica (<emphasis remap="it">mirror</emphasis>)
del Insflug más cercanos a Vd., e información relativa a otros recursos en
castellano. 
</para>

<para>
Francisco José Montilla, <literal remap="tt"><ulink
url="mailto:pacopepe@insflug.org"
>pacopepe@insflug.org</ulink
></literal>. 
</para>

</sect1>

</article>
