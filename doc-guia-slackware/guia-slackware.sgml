<!doctype book public "-//OASIS//DTD DocBook V3.1//EN">

<!-- DocBook file was created by LyX 1.1
  See http://www.lyx.org/ for more information -->
<book lang="es">
 <bookinfo>
  <title>
  Guía Práctica de Slackware 7.x para nuevos usuarios
 </title>
 <author>
 	<firstname>A. Gustavo</firstname> <surname>González</surname>
  	<ulink url="agonzale@cica.es"></ulink>
 </author>
 <date>
  Sevilla, 1 de Marzo de 2001
 </date>
 <abstract>
 <para>
  En este documento se presenta una guía práctica para la instalación y post-instalación de la distribución Linux Slackware 7.x mediante el CD oficial de instalación. 
 </para>
 </abstract>
 </bookinfo>

  <toc>
      <title>Índice general</title>
  </toc>


 <chapter>
  <title>
  Introducción
 </title>
 <para>
  Esto pretende ser, como el titulo indica, una guía práctica de la instalación y post-instalación de Slackware 7.x para nuevos usuarios de Slackware (aunque ya conozcan otras distribuciones Linux). Este documento puede ser copiado, modificado y distribuido sin ninguna restricción. Si alguien lo actualiza y reforma, por favor, envíe una copia a mi dirección <ulink url="agonzale@cica.es"></ulink>. Voy a referirme en esta guía a la instalación del sistema empleando el CD de instalación que contiene los arrchivos y directorios correspondientes a la versión &ldquo;slackware-current&rdquo;, que está entre la 7.1 y la futura 7.2 y puede conseguirse via ftp en <ulink url="ftp://ftp.slackware.com/pub/slackware/slackware-current/"></ulink>. El CD del que hablo también lo proporcionó la revista Sólo Programadores Linux Nº 27 con el título &ldquo;Slackware 7.1&rdquo;, aunque como digo, en realidad se trata de la versión &ldquo;current&rdquo;, que contiene numerosas novedades, como el escritorio KDE 2.0.1, la versión más reciente de Lilo que permite usarlo aún cuando nos encontremos más allá del límite obsoleto ya de los 1024 cilindros de nuestro disco duro, y otras muchas que indico brevemente a continuación 
 </para>
 <itemizedlist>
  <listitem>
  <para>
  Kernel modules   2.2.18
  </para>
 </listitem>
  <listitem>
  <para>
  PPP daemon   2.3.11
  </para>
 </listitem>
  <listitem>
  <para>
  Dynamic linker (ld.so)   1.9.9
  </para>
 </listitem>
  <listitem>
  <para>
  C compiler   egcs-1.1.2 y gcc-2.95.2
  </para>
 </listitem>
  <listitem>
  <para>
  Binutils   2.10.1.0.2
  </para>
 </listitem>
  <listitem>
  <para>
  C library   glibc-2.2
  </para>
 </listitem>
  <listitem>
  <para>
  C++ library   libstdc++ -3-libc6.1-2-2.10.0
  </para>
 </listitem>
  <listitem>
  <para>
  Procps   2.0.7
  </para>
 </listitem>
  <listitem>
  <para>
  Gpm   1.19.3
  </para>
 </listitem>
  <listitem>
  <para>
  SysV init   2.78
  </para>
 </listitem>
 </itemizedlist>
 <para>
  Ah! y ahora, tenemos Slackware para i386/Alpha/Sparc, un gran logro. Espero que lo que sigue sirva de ayuda a los nuevos usuarios de Slackware. Por supuesto esta guía es solo eso, una guía práctica para instalar Slackware. Pero necesitareis evidentemente apoyo para aprender más y más de Linux, apoyo que solo lo dan los libros y manuales, los COMOS (HOWTOs) y FAQs. Os recomiendo que visiteis en la red la web de LUCAS-HISPALINUX <ulink url="http://lucas.hispalinux.es"></ulink> y ECOL <ulink url="http://escomposlinux.org"></ulink> entre otros y que os suscribais al grupo de news es.comp.os.linux.instalacion.
 </para>
 </chapter>
 <chapter>
  <title>
  ¿Por qué Slackware?
 </title>
 <para>
  Evidentemente, todos sabemos que existen numerosas distribuciones GNU/Linux, entre otras las más conocidas aparte de Slackware son Debian, RedHat, Mandrake, SuSE, OpenLinux, etc. Entonces ¿qué tiene Slackware de especial para escogerla? Antes de decir nada quiero dejar bien claro que todas las distros Linux harán prácticamente lo mismo para el usuario y que seleccionar una u otra depende del gusto del propio usuario y ya se sabe que sobre gustos no hay nada escrito. Slackware Linux fue una de las primeras distribuciones Linux a la que tuvimos acceso. En 1993, SLS (Soft Landing System) creó una de las primeras distribuciones organizadas de Linux, pero presentaba ciertos problemas. Patrick Volkerding, partió de la distribución SLS, resolvió tales problemas y mejoró significativamente la estabilidad y la operatividad en red. A instancias de su amigo J.R. &ldquo;Bob&rdquo; Dobbs (El hombre de la pipa), llamó con sentido del humor a la naciente nueva distribución &ldquo;Slackware&rdquo;. En 1994 Slackware había conseguido tal diseminación que alcanzó una gran notoriedad, equiparable a las estrellas del rock : ). Patrick siempre estuvo interesado en producir un sistema linux lo más próximo posible a unix. Por adherencia al llamado principio KISS (Keep It Simple, Stupid) Slackware se ha convertido en una de las distribuciones más estables y adecuadas para administrar servidores y estaciones de trabajo.  Podríamos decir que Slackware es la distribución más p\'{r}oxima a Unix; su arranque sigue el estilo BSD, no el system V de las otras distros; Slackware es la distribución más ajustada al &ldquo;POSIX compliance&rdquo;; Slackware es para la gente que quiere aprender Linux. Aprender Linux por la vía dura, leyendo HOWTOs y FAQs, haciéndolo casi todo a mano. Empleando los tarballs habitualmente (tar.gz o algunos llamados &ldquo;paquetes slackware&rdquo; .tgz) y compilando el código fuente (./configure, make, make install). En pocas palabras, conociendo los entresijos del sistema. Slackware no te trata como un usuario final (que lo único que desea es instalar su sistema rápidamente para navegar por internet, escribir e-mails, jugar y usar ciertas aplicaciones), para eso hay otros... sino que tendrás que editar ficheros, hacer scripts, etc... para administrarlo adecuadamente. Además de esta flexibilidad, Slackware es una de las distros más estables y seguras. Por ello se ha llegado a decir que Slackware (al igual que Debian) era una distribución para usuarios avanzados, para gurús de Linux. Pero os puedo asegurar que es para cualquiera que desee usar y aprender Linux de verdad.
 </para>
 <para>
  Sin embargo, aunque Slackware sea mi preferida, existe otra que también merece ser subrayada y que en cierto modo es la portaestandarte de GNU/Linux y el software libre: Debian. Si bien Slackware es la más unix de todas las distros, debian es la más Linux en el sentido del desarrollo corporativo del modelo open-source del kernel linux y lo aplica al sistema operativo como un todo. si bien es cierto (de Usenet) que 
 </para>
 <blockquote>
 <para>
  &ldquo;Once a slacker, always a slacker&rdquo;
 </para>
 </blockquote>
 <para>
  no por ello dejo de considerar a Debian como la esencia pura de la filosofía Linux, no comercial, mantenida por desarrolladores voluntarios cristalizando la idea de la Catedral y el Bazar de Eric Raymond.
 </para>
 <para>
  Pero esta guía se la he dedicado a Slackware, así que, queridos novicios, al asunto.
 </para>
 </chapter>
 <chapter>
  <title>
  Preparativos
 </title>
 <para>
  Debéis tomar nota de las características de vuestro hardware: Ratón (tipo, puerto, 2 o 3 botones...), módem (tipo, puerto, velocidad ¡cuidado con los WINMODEMS!), monitor (tasa de frecuencia horizontal y refresco vertical, si es multifrecuencia), tarjeta gráfica (tipo, chipset, memoria), tarjeta de red (clase, denominación, dirección io...), etc.
 </para>
 <para>
  Ha de haber preparado un espacio suficiente para Linux en dos particiones (mediante FIPS+fdisk o PartitionMagic 5): una de intercambio (swap) de contenido variable (si tenéis más de 32 Mb de RAM y va a ser para uso doméstico, 64 Mb de swap será más que suficiente) y otra Linux native ext2 de al menos 1 Gb. Hoy día podéis daros el lujo de disfrutar de discos duros de gran capacidad. Si queréis grabar Cds, trabajar con imágenes, etc podéis destinar 4Gb para Linux.
 </para>
 <para>
  Otra cosa: si disponéis de conexión no intermitente (via eth0, no ppp), debéis anotar la dirección IP de vuestra máquina, máscara de subred (subnet maske), dirección de difusión (broadcast), puerta de enlace (default gateway), host name, domain name y las IP de los DNS que os ha proporcionado el admin de vuestro ISP. Tened formateados 2 disquetes de 1.4Mb si vuestra BIOS no permite Cds autoarrancables. 
 </para>
 </chapter>
 <chapter>
  <title>
  La instalación
 </title>
 <para>
  Supongamos que disponemos del CD de instalación para i386. El CD bastaría para comenzar la instalación si nuestra BIOS permite CD autoarrancables (el torito). En caso contrario debemos crear dos disquetes (floopies) de instalación: uno de inicio o arranque (bootdisk) y otro de instalación propiamente dicha (rootdisk). La imagen del bootdisk depende del hardware fuente y destino de la instalación, pues contiene el kernel de Linux que ha de ser congruente con el hardware de la máquina.. Si tanto el disco duro como el lector CD-ROM son de tipo IDE/ATAPI habrá que escoger el archivo bare.i que se encuentra en el directorio bootdskd.144 del CD de instalación. Si no es vuestro caso leed el fichero readme.txt dentro del directorio bootdsks.144. La imagen del rootdisk contiene el sistema Linux mínimo para llevar a cabo la instalación. Si vamos a instalar Slackware en una partición propia (ext2) debemos escoger el archivo color.gz que se encuentra en el directorio rootdsks. Podemos crear estos discos desde Windows o desde otro Unix/Linux. Desde Windows, explorando el CD, en la carpeta rootdsks, la utilidad rawrite.exe, un ejecutable para copiar estas imágenes. Si por ejemplo la unidad del lector de Cd en Windows es e:, al hacer un doble click de ratón sobre rawrite.exe, aparecerá la ventana de MSDOS :
 </para>
 <programlisting>
Enter source file name: e:\bootdsks.144\bare.i
Enter destination drive: a:
 </programlisting>
 <para>
  Luego te pide que introduzcas un disquete formateado en el drive A: y pulses ENTER. Rotula el disco como BOOTDISK. Repite el mismo proceso para color.gz 
 </para>
 <programlisting>
Enter source file name: e:\rootdsks\color.gz
Enter destination drive: a:
 </programlisting>
 <para>
  y rotula el disco como ROOTDISK.
 </para>
 <para>
  Para el caso de unix, los discos pueden crearse usando el comando dd. Si el Cd está montado en /cdrom, el proceso para el BOOTDISK (puesto en la disquetera A: = /dev/fd0) sería:
 </para>
 <programlisting>
dd if=/cdrom/bootdsks.144/bare.i of=/dev/fd0 obs=18k
 </programlisting>
 <para>
  Repite el proceso para ROOTDISK con if=/cdrom/rootdsks/color.gz, y ya tendrás los dos disquetes necesarios.
 </para>
 <para>
  Bueno: al turrón. Voy a suponer el caso mas restrictivo de tener que usar los dos disquetes. Si podéis arrancar desde el Cd, aún más fácil. Poned el Cd en vuestro lector de cdrom. A continuación introducid el bootdisk y reiniciad el ordenador...Al poco, saldrán los típicos mensajes 
 </para>
 <programlisting>
LILO 21.5-1
...bla bla bla
 </programlisting>
 <para>
  y el prompt boot: Hacemos &lsqb;ENTER&rsqb; y comienza a cargarse el ramdisk. Al ratito se nos pide el root disk:
 </para>
 <programlisting>
VFS:Insert root floppy disk to be loaded into RAM disk and press enter 
 </programlisting>
 <para>
  (Lo hacemos y comienza el espectáculo :))
 </para>
 <programlisting>
Welcome to Slackware Linux installation disk (version 7.1.0)
.
.
.
Slackware login:
 </programlisting>
 <para>
  Tenemos que entrar como root, así que despues de login: escribimos &ldquo;root&rdquo; (sin comillas, claro) y nos aparece
 </para>
 <programlisting>
Linux 2.2.18
...bla bla bla
...
To partition hard drive(s) use cfdisk o fdisk
To activate PCMCIA/cardbus devices needed for installation, type 'pcmcia'
To activate network devices needed for installation, type 'network'
To start the main installation, type 'setup'
 </programlisting>
  <sect1>
   <title>
   Particionando el disco
  </title>
  <para>
   Si no hicimos en su momento las particiones, ahora es el momento de hacerlas invocando
  </para>
  <para>
   &num;fdisk /dev/hdX
  </para>
  <para>
   siendo X la letra que corresponda al disco duro que queremos particionar. Como ejemplo vamos a suponer que tengo un disco duro de unos 19 Gbytes (/dev/hda) donde tengo al Windoze (4.4 Gbytes) y quiero hacer sitio para un swap de 120 Mbytes y el resto compartirlo con dos sistemas Linux: Debian y Slackware. Si hago 
  </para>
  <para>
   &num;fdisk /dev/hda
  </para>
  <para>
   obtengo:
  </para>
  <para>
   Command (m for help):
  </para>
  <para>
   y queda en espera de un comando. Los más importantes de fdisk son
  </para>
  <blockquote>
  <para>
   m: help
  </para>
  <para>
   n: crea una nueva partición
  </para>
  <para>
   p: muestra la tabla de particiones
  </para>
  <para>
   q: salir sin guardar (caso de meter la pata)
  </para>
  <para>
   w: salir guardando la tabla de particiones
  </para>
  <para>
   t: cambia el tipo de partición (82 para swap y 83 para linux nativo)
  </para>
  <para>
   d: borra una partición
  </para>
  </blockquote>
  <para>
   Por lo tanto si escribo : p (para ver la tabla de partición)
  </para>
  <blockquote>
  <para>
   Command (m for help): p
  </para>
  <para>
   Device     Boot  Start     End     Blocks  ld    System
  </para>
  <para>
   /dev/hda1    *          1     587   4715046   b   Win95 FAT32
  </para>
  </blockquote>
  <para>
   Vemos que tengo el disco duro con una partición de 4.4 Gbytes destinada a Windows. Ahora voy a crear mi partición (primaria) para el área de intercambio (swap). Para la creación de la partición swap hacemos
  </para>
  <blockquote>
  <para>
   Command (m for help): n 
  </para>
  <para>
   Command action
  </para>
  <para>
        e   extended
  </para>
  <para>
        p   primary partition (1-4)
  </para>
  <para>
   p
  </para>
  <para>
   Partition number (1-4): 2
  </para>
  <para>
   First cylinder (588- 2490): 588
  </para>
  <para>
   Last cylinder or +size or +sizeM or + sizeK(&lsqb;588&rsqb;-2490): +120M
  </para>
  </blockquote>
  <para>
   Luego hemos de indicar que es para swap
  </para>
  <blockquote>
  <para>
   Command (m for help): t
  </para>
  <para>
   Partition number (1-4): 2
  </para>
  <para>
   Hex Code (type L to list codes): 82
  </para>
  <para>
   Changed system type of partition 2 to 82 (swap linux)
  </para>
  </blockquote>
  <para>
   De este modo ya hemos hecho la partición para el área de intercambio. Ahora vamos a crear dos particiones ext2 (linux native) para nuestra Debian y nuestra Slackware. Para Debian destinaré unos 7 Gbytes y el resto (unos 7.2 Gbytes) para Slackware. Comencemos la creación
  </para>
  <blockquote>
  <para>
   Command (m for help): n 
  </para>
  <para>
   Command action
  </para>
  <para>
        e   extended
  </para>
  <para>
        p   primary partition (1-4)
  </para>
  <para>
   p
  </para>
  <para>
   Partition number (1-4): 3
  </para>
  <para>
   First cylinder (604 - 2490): 604
  </para>
  <para>
   Last cylinder or +size or +sizeM or +sizeK (&lsqb;604&rsqb;-2490): +7000M
  </para>
  </blockquote>
  <para>
   Ahora hemos de indicar que es para linux native 
  </para>
  <blockquote>
  <para>
   Command (m for help): t
  </para>
  <para>
   Partition number (1-4): 3
  </para>
  <para>
   Hex Code (type L to list codes): 83
  </para>
  <para>
   Changed system type of partition 3 to 83 (linux native)
  </para>
  </blockquote>
  <para>
   Hemos hecho la partición para Debian; ahora lo mismo para Slackware, pero antes de seguir veamos como va la cosa 
  </para>
  <blockquote>
  <para>
   Command (m for help): p
  </para>
  <para>
   Device     Boot  Start     End     Blocks  ld    System
  </para>
  <para>
   /dev/hda1    *       1     587    4715046   b    Win95 FAT32
  </para>
  <para>
   /dev/hda2          588     603     128520  82    Linux swap
  </para>
  <para>
   /dev/hda3          604    1533    7470225  83    Linux
  </para>
  </blockquote>
  <para>
   Continuemos entonces, pero en lugar de indicar ahora el tamaño de la partición lo que haremos será indicar que acabe en el último cilindro del disco
  </para>
  <blockquote>
  <para>
   Command (m for help): n 
  </para>
  <para>
   Command action
  </para>
  <para>
        e   extended
  </para>
  <para>
        p   primary partition (1-4)
  </para>
  <para>
   p
  </para>
  <para>
   Partition number (1-4): 4
  </para>
  <para>
   First cylinder (1534 - 2490): 1534
  </para>
  <para>
   Last cylinder or +size or +sizeM or +sizeK (&lsqb;604&rsqb;-2490): 2490
  </para>
  <para>
   Command (m for help): t
  </para>
  <para>
   Partition number (1-4): 4
  </para>
  <para>
   Hex Code (type L to list codes): 83
  </para>
  <para>
   Changed system type of partition 3 to 83 (linux native)
  </para>
  </blockquote>
  <para>
   y ahora tenemos la tabla final de particiones 
  </para>
  <blockquote>
  <para>
   Command (m for help): p
  </para>
  <para>
   Device     Boot  Start     End     Blocks  ld    System
  </para>
  <para>
   /dev/hda1    *       1     587    4715046   b    Win95 FAT32
  </para>
  <para>
   /dev/hda2          588     603     128520  82    Linux swap
  </para>
  <para>
   /dev/hda3          604    1533    7470225  83    Linux
  </para>
  <para>
   /dev/hda4         1534    2490    7687102+ 83    Linux
  </para>
  </blockquote>
  <para>
   Una vez que ya tenemos particionado adecuadamente el disco duro hagamos
  </para>
  <para>
   &num;setup
  </para>
  <para>
   y una vez dentro del programa iremos realizando la instalación paso a paso mediante el menú
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.program"></graphic>
  </para>
  <para>
   Podemos accionar HELP y encontraremos indicaciones generales:
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.help"></graphic>
  </para>
  <para>
   Una vez leído, hacemos &lt;EXIT&gt; y comenzamos con el siguiente ítem del setup, KEYMAP
  </para>
  </sect1>
  <sect1>
   <title>
   KEYMAP (Remap your keyboard if you're not using a US one)
  </title>
  <para>
   Una vez seleccionado KEYMAP+&lt;OK&gt;, aparece el panel
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.keymap"></graphic>
  </para>
  <para>
   y escogemos la la línea correspondiente a es.map. El programa permite comprobar el teclado (ojo que no verás la ñ todavía, pues eso lo resolveremos después de la instalación). Para aceptar la elección hay que introducir el &ldquo;1&rdquo; y luego hacer &lt;OK&gt;.
  </para>
  </sect1>
  <sect1>
   <title>
   ADDSWAP (Set up your swap partition)
  </title>
  <para>
   A continuación aparece un panel con información que nos dice Would you like to continue the installation and setup your swap space?, a lo que responderemos &lt;Yes&gt;, y entonces saldrá otro panel diciéndonos que 
  </para>
  <programlisting>
Slackware setup has detected a swap partition
  </programlisting>
  <blockquote>
  <para>
   Device     Boot  Start     End     Blocks  ld    System
  </para>
  <para>
   /dev/hda2          588     603     128520  82    Linux swap
  </para>
  </blockquote>
  <programlisting>
Do you wish to install this as your swap partition? 
  </programlisting>
  <para>
   Respondemos también &lt;Yes&gt; y entonces comienza el formateo
  </para>
  <programlisting>
FORMATTING SWAP PARTITION
Formatting /dev/hda2 as a Linux swap partition (and checking for bad blocks)
...
Activating swap partition
SWAP SPACE CONFIGURED
  </programlisting>
  <blockquote>
  <para>
   Your swap space has been configured. This information will be added to your /etc/fstab:
  </para>
  <para>
   /dev/hda2      swap       swap        defaults       0     0
  </para>
  </blockquote>
  </sect1>
  <sect1>
   <title>
   TARGET (Set up your target partition) 
  </title>
  <programlisting>
CONTINUE WITH INSTALLATION
...Would you like continue the installation and setup your target driver(s)?
  </programlisting>
  <para>
   &lt;Yes&gt;
  </para>
  <programlisting>
Select Linux installation partition
Please, select a partition from the following list to use for your root (/) Linux partition
  </programlisting>
  <para>
   De las que aparezcan, seleccionaremos 
  </para>
  <blockquote>
  <para>
   /dev/hda4     Linux native       7687102k
  </para>
  </blockquote>
  <para>
   y hacemos &lt;OK&gt;.
  </para>
  <para>
   Entonces comienza a formatearse la partición
  </para>
  <programlisting>
FORMAT PARTITION /dev/hda4
...
Would you like to format this partition?
  </programlisting>
  <para>
   entonces aparece el menú
  </para>
  <itemizedlist>
   <listitem>
   <para>
   Format -- Quick format with no bad block checking
   </para>
  </listitem>
   <listitem>
   <para>
   Check -- Slow format that checks for bad blocks
   </para>
  </listitem>
   <listitem>
   <para>
   No -- No, do not format this partition
   </para>
  </listitem>
  </itemizedlist>
  <para>
   y dependiendo lo que corresponda, seleccionad un ítem. (El último solo debeis seleccionarlo si ya habeis hecho la partición con Partitin Magic desde Windows y ya está formateada). A continuación hay que escoger la densidad de inodos:
  </para>
  <programlisting>
SELECT INODE DENSITY FOR /dev/hda4
  </programlisting>
  <itemizedlist>
   <listitem>
   <para>
   4096 (1 inode per 4096 bytes) (default)
   </para>
  </listitem>
   <listitem>
   <para>
   2048 (1 inode per 2048 bytes)
   </para>
  </listitem>
   <listitem>
   <para>
   1024 (1 inode per 1024 bytes)
   </para>
  </listitem>
  </itemizedlist>
  <para>
   Haced la selección idónea (2048 y 1024 vendrán bien si vais a tener muchos ficheros pequeños, pero en general es mejor la opción por defecto). Pero no acaba aquí la cosa, pues hay que añadir otras particiónes al fichero /etc/fstab (si así interesa) y nos encontramos con
  </para>
  <programlisting>
Select other linux partitions for /etc/fstab
  </programlisting>
  <para>
   Si no quieres añadirlas ahora, selecciona &lt;Cancel&gt; para continuar. Luego puedes hacerlo a mano editando el fichero.
  </para>
  <programlisting>
DONE ADDING LINUX PARTITIONS TO /etc/fstab
  </programlisting>
  <blockquote>
  <para>
   Adding this information to your /etc/fstab
  </para>
  <para>
   /dev/hda4       /        ext2        defaults       1     1
  </para>
  </blockquote>
  <para>
   Si teneis en el disco duro alguna partición para DOS, Windows o NT, aún no se acaba la cosa:
  </para>
  <programlisting>
FAT/FAT32/HPFS PARTIRTION DETECTED
Would you like to add these partitions to your /etc/fstab so that these partitions are visible from Linux?
  </programlisting>
  <para>
   Haced lo que más os guste. Mi impresión es seleccionar &lt;No&gt; ahora y luego ya veremos, pues siempre puedo hacerlo a mano.
  </para>
  <programlisting>
CONTINUE?
Would you like to go on to the source section and select your installation media?
  </programlisting>
  <para>
   Hacemos &lt;Yes&gt;
  </para>
  </sect1>
  <sect1>
   <title>
   SOURCE (Select source media)
  </title>
  <programlisting>
SOURDCE MEDIA INSTALLATION
Where do you plan to install Slackware Linux from?
  </programlisting>
  <orderedlist>
   <listitem>
   <para>
   Install from a Slackware CD-ROM
   </para>
  </listitem>
   <listitem>
   <para>
   Install from a hard drive partition
   </para>
  </listitem>
   <listitem>
   <para>
   Install via NFS
   </para>
  </listitem>
   <listitem>
   <para>
   Install from a pre-mounted directory
   </para>
  </listitem>
   <listitem>
   <para>
   Install from floppy disks (A and N series only)
   </para>
  </listitem>
  </orderedlist>
  <para>
   Seleccionamos 1 (Pues nos basamos en el CD ) y hacemos &lt;OK&gt;.
  </para>
  <programlisting>
SCAN FOR CD-ROM DRIVE
  </programlisting>
  <itemizedlist>
   <listitem>
   <para>
   auto (recommendable)
   </para>
  </listitem>
   <listitem>
   <para>
   manual
   </para>
  </listitem>
  </itemizedlist>
  <para>
   El barrido para encontrar el dispositivo CD-ROM puede hacerse automáticamente o a mano, el primero es el que vamos a seleccionar y &lt;OK&gt;. Entonces veremos en la consola
  </para>
  <programlisting>
PLACE DISC IN CD-ROM DRIVE
  </programlisting>
  <para>
   Asegúrate de que efectivamente está el CD de instalación de Slackware en el lector y haz &lt;OK&gt;.
  </para>
  <programlisting>
SCANNING
...
CHOOSE INSTALLATION TYPE
  </programlisting>
  <itemizedlist>
   <listitem>
   <para>
   slakware -- Normal installation to hard drive (best performance)
   </para>
  </listitem>
   <listitem>
   <para>
   slaktest -- Link /usr/ -&gt; /cdrom/live/usr to run mostly from CD
   </para>
  </listitem>
   <listitem>
   <para>
   custom -- Install from a custom directory
   </para>
  </listitem>
   <listitem>
   <para>
   help
   </para>
  </listitem>
  </itemizedlist>
  <para>
   Escogemos la primera opción y pasamos a la selección de paquetes.
  </para>
  <programlisting>
CONTINUE?
Would you like to go on to the SELECT section now?
  </programlisting>
  <para>
   &lt;Yes&gt;
  </para>
  </sect1>
  <sect1>
   <title>
   SELECT (Select categories of software to install)
  </title>
  <para>
   Ahora aparecerá un menú donde se incluye la serie de paquetes a instalar que vamos a indicar de manera breve a continuación:
  </para>
  <itemizedlist>
   <listitem>
   <para>
   A: El sistema base Slackware que ha de instalarse completamente
   </para>
  </listitem>
   <listitem>
   <para>
   AP: Aplicaciones linux de consola incluyendo editores, el midnight commander, shells, etc...
   </para>
  </listitem>
   <listitem>
   <para>
   D: Programas de Desarrollo, como intérpretes, compiladores y utilidades (C, C++, Fortran, LISP, Pascal, Perl...)
   </para>
  </listitem>
   <listitem>
   <para>
   DES: Encriptación empleando el estilo antiguo DES. Sin esto, solo es posible encriptar las contraseñas con MD5
   </para>
  </listitem>
   <listitem>
   <para>
   E: GNU Emacs, no un editor, sino todo un mundo de posibilidades
   </para>
  </listitem>
   <listitem>
   <para>
   F: Documentación Linux, FAQs y HOWTOs
   </para>
  </listitem>
   <listitem>
   <para>
   GTK: Aplicaciones X que usan las herramientas GTK+ . Entre otras encontramos a GIMP y GNOME 
   </para>
  </listitem>
   <listitem>
   <para>
   K: Fuentes del kernel Linux. Harán falta para recompilar el kernel
   </para>
  </listitem>
   <listitem>
   <para>
   KDE: El entorno de escritorio K con las bibliotecas QT
   </para>
  </listitem>
   <listitem>
   <para>
   N: Redes (Networking): paquete TCP/IP y UUCP, incluyendo SLIP/PPP, programas de correo (sendmail), lectores de noticias, servidor Apache y Samba,...
   </para>
  </listitem>
   <listitem>
   <para>
   T: La distribución teTeX/TeX. Fundamental para procesar en Latex, pasar documentos a pdf con pdftex, etc.
   </para>
  </listitem>
   <listitem>
   <para>
   TCL: Lenguage de scripts Tcl/Tk/TclX
   </para>
  </listitem>
   <listitem>
   <para>
   X: El sistema X window de XFree86
   </para>
  </listitem>
   <listitem>
   <para>
   XAP: Aplicaciones para el sistema X window, incluyendo gestores de ventanas, Netscape Communicator, xv, imagemagick, etc...
   </para>
  </listitem>
   <listitem>
   <para>
   XD: Herramientas para recompilar servidores X. Esta serie es muy poco requerida y casi nadie la instala.
   </para>
  </listitem>
   <listitem>
   <para>
   XV: Sirve de apoyo al gestor de ventanas OpenLook y para compilar aplicaciones XView
   </para>
  </listitem>
   <listitem>
   <para>
   Y: Juegos BSD, incluyendo fortune : )
   </para>
  </listitem>
  </itemizedlist>
  <para>
   El menú que aparece es el siguiente
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.select"></graphic>
  </para>
  <para>
   Las series de paquetes se navegan con los cursores y se seleccionan con la barra espaciadora. Luego haceis &lt;OK&gt;.
  </para>
  <programlisting>
CONTINUE?
Would you like to go on to the install section?
  </programlisting>
  <para>
   &lt;Yes&gt;
  </para>
  </sect1>
  <sect1>
   <title>
   INSTALL (Install the selected software)
  </title>
  <para>
   Nos aparecerá el siguiente menú
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.install"></graphic>
  </para>
  <para>
   La opción full instalará todos los paquetes de todas las series seleccionadas anteriormente. En el caso de nuestro CD current-version eso puede necesitar alrededor de 1 Gbyte (no hagais caso de lo que pone en la figura -386 MB- que corresponde a un setup de otra versión más antigua). La opción newbie instala todos los paquetes requeridos necesariamente en las series seleccionadas y para el resto de los paquetes tendremos un menú donde decidiremos si lo instalamos (YES), si no lo instalamos (NO) o si saltamos a la siguiente serie (SKIP). Además veremos una descripción de lo que hace cada paquete y el espacio que necesita. Es una opción que puede ser tediosa y lenta. La opción menu es una buena elección porque para cada serie de paquetes se describen los componentes brevemente y permite seleccionarlos o no con la barra espaciadora. Los paquetes cruciales no se indican, ya que han de instalarse necesariamente. La opción expert es como la menu, pero dando todo el control al usuario, incluso en los paquetes cruciales. Yo os recomiendo la opción menu; y si teneis un disco duro grande como yo, la full ;-).
  </para>
  <para>
   Según lo que hayais escogido, los paquetes se instalarán y dependiendo de la máquina, lo harán pronto o tardarán un ratito... 
  </para>
  <para>
   Luego pasaremos a la sección CONFIGURE
  </para>
  </sect1>
  <sect1>
   <title>
   CONFIGURE (Reconfigure your linux system)
  </title>
  <para>
   Ahora nos aparecerá un menú para seleccionar el kernel a instalar
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.kernel"></graphic>
  </para>
  <para>
   La opción más sencilla y recomendable es instalar el kernel que hemos usado en el disquete de instalación (el 2.2.18); por lo tanto seleccionamos bootdisk y &lt;OK&gt;.
  </para>
  <programlisting>
INSERT INSTALLATION BOOTDISK
Please, inser your installation bootdisk in /dev/fd0 (drive a:) and press ENTER to continue
  </programlisting>
  <para>
   &lt;OK&gt;
  </para>
  <programlisting>
COPYING
Copying kernel from bootdisk to /vmlinuz on your new system
  </programlisting>
  <para>
   A continuación el programa setup nos preguntará si queremos hacer un disco de arranque usando el núcleo del sistema con el siguiente menú
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.bootdisk"></graphic>
  </para>
  <para>
   La opción lilo es la más recomendable. Lo primero que haremos es introducir un floppy en a: y seleccionar format. Después de formateado, seleccionaremos la opción lilo, y una vez creado el disco de arranque y adecuadamente rotulado, seleccionamos continue y pasamos a la configuración del modem.
  </para>
  <programlisting>
MODEM CONFIGURATION
Where is your modem /dev/ttyS?
  </programlisting>
  <itemizedlist>
   <listitem>
   <para>
   ttyS0 = (COM1 : under DOS)
   </para>
  </listitem>
   <listitem>
   <para>
   ttyS1 = (COM2 : under DOS)
   </para>
  </listitem>
   <listitem>
   <para>
   ttyS2 = (COM3 : under DOS)
   </para>
  </listitem>
   <listitem>
   <para>
   ttyS3 = (COM4 : under DOS)
   </para>
  </listitem>
   <listitem>
   <para>
   no modem : I don't have a modem
   </para>
  </listitem>
  </itemizedlist>
  <para>
   Escoged la opción que corresponda y &lt;OK&gt;
  </para>
  <programlisting>
SCREEN FONT CONFIGURATION
Would you like try out some custom screen fonts?
  </programlisting>
  <para>
   Aquí, cada uno haga lo que quiera. Yo escogí &lt;No&gt;; pero si haces &lt;Yes&gt;, te saldrá un menú con tipos de letra para la consola que se usarán por defecto una vez escogidas:
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.font"></graphic>
  </para>
  <para>
   Ahora llega el momento de instalar LILO:
  </para>
  <programlisting>
INSTALL LILO
  </programlisting>
  <para>
   Aparece un menú como este
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/liloconfig.first"></graphic>
  </para>
  <para>
   Yo recomiendo (si realmente uno es un novato) la opción simple. Luego ya editaremos el fichero /etc/lilo.conf para ajustarlo un poquitín y ya está. Así que escojamos simple y &lt;OK&gt;. Tengo que decir que el programa de instalación de lilo está muy bien, porque ya usa la versión 21.5 de lilo y automáticamente, si tu disco es grande y tienes que instalar lilo más allá del cilindro 1024, NO HAY PROBLEMA y el programa (liloconfig) introduce la opción adecuada siempre que la BIOS no sea una antigualla; si no, a por LOADLIN. 
  </para>
  <para>
   El siguiente menú corresponde a la opción de configurar LILO para usar una consola framebuffer:
  </para>
  <programlisting>
CONFIGURE LILO TO USE FRAME BUFFER CONSOLE ?
  </programlisting>
  <para>
   <graphic fileref="/home/gustavo/book/liloconfig.framebuffer"></graphic>
  </para>
  <para>
   Pues nada, a seleccionar lo que más os guste. La elección de framebuffer console hace muy fácil la configuración de X en cualquier tarjeta de vídeo VESA con ratón PS/2, pero también es mucho más lenta que la consola estándar. Yo escogería la estándar y &lt;OK&gt;.
  </para>
  <para>
   Por último tenemos que ubicar LILO adecuadamente:
  </para>
  <programlisting>
SELECT LILO DESTINATION
  </programlisting>
  <itemizedlist>
   <listitem>
   <para>
   Root : Install to superblock (which must be made bootable)
   </para>
  </listitem>
   <listitem>
   <para>
   floppy: Install to a formatted floppy in /dev/fd0 (A:)
   </para>
  </listitem>
   <listitem>
   <para>
   MBR : Install to Master Boot Record (possibly unsafe)
   </para>
  </listitem>
  </itemizedlist>
  <para>
   La primera opción (root) instala LILO en el sector primero de la partición raíz /dev/hda4; opción ideal cuando disponemos de un bootloader, como el bootmagic o el OS2 boot loader para arrancar diversos sistemas operativos. La segunda (floppy) puede ser obligatoria en ciertos casos. Puede ocurrir que debido a la configuracion del disco duro, la BIOS no permita instalar LILO en la partición raíz de Linux. Esto sucede fundamentalmente si hemos sobrepasado el limite de los 1024 cilindros y la BIOS es algo antigua. No obstante, en lugar de tener que arrancar mediante un disquete con LILO sería mejor utilizar LOADLIN (ya lo veremos). La última opción instala LILO en el MBR de /dev/hda. Esto no es recomendable si tenemos otros sistemas operativos.
  </para>
  <para>
   Por lo tanto, si es posible seleccionaremos la opción Root y haremos &lt;OK&gt;.
  </para>
  <programlisting>
CONFIGURE NETWORK?
Would you like configure your network?
  </programlisting>
  <para>
   &lt;Yes&gt;
  </para>
  <programlisting>
NETWORK CONFIGURATION
We will attempt to configure your mail and TCP/IP...
...You will be able to reconfigure your system at any time by typing netconfig
  </programlisting>
  <para>
   &lt;OK&gt; (En efecto, el programa netconfig se encarga de llevar a cabo la configuración de la red)
  </para>
  <programlisting>
ENTER HOSTNAME
  </programlisting>
  <para>
   Introducimos el nombre base (sin el dominio), por ejemplo darkstar : )
  </para>
  <programlisting>
Enter hostname:
darkstar
  </programlisting>
  <para>
   &lt;OK&gt;
  </para>
  <programlisting>
ENTER DOMAIN NAME for 'darkstar'
  </programlisting>
  <para>
   por ejemplo, es (de esPAÑA)
  </para>
  <programlisting>
Enter domain name:
es
  </programlisting>
  <para>
   &lt;OK&gt;
  </para>
  <programlisting>
SETUP IP for 'darkstar.es'
  </programlisting>
  <itemizedlist>
   <listitem>
   <para>
   Static IP : Use a static IP address to configure ethernet
   </para>
  </listitem>
   <listitem>
   <para>
   DHCP : Use a DHCP server to configure ethernet
   </para>
  </listitem>
   <listitem>
   <para>
   loopback : Setup a loopback connection (modem or no net)
   </para>
  </listitem>
  </itemizedlist>
  <para>
   La primera opción corresponde al caso de una conexión permanente a la red mediante cable, con una dirección IP fija. La segunda se aplica cuando nos conectamos a la red mediante cable modem o servicios DSL. La última se escoge bien cuando no vamos a conectarnos a la red o cuando lo hagamos de manera intermitente mediante un modem con el protocolo PPP.
  </para>
  <para>
   La mayor parte de las máquinas domésticas (home PCs) escojerán la opción loopback y aquí se termina la configuración de red. Pero si se trata de una máquina conectada a red permanentemente (por ejemplo en una Universidad o en una empresa), entonces elegiremos Static IP y entonces se nos preguntará sucesivamente 
  </para>
  <programlisting>
ENTER LOCAL IP ADRESS
...
Enter your IP address for 'darkstar.es'(aaa.bbb.ccc.ddd):
  </programlisting>
  <para>
   Ponemos la IP de nuestra máquina y &lt;OK&gt;
  </para>
  <programlisting>
ENTER GATEWAY ADDRESS
...
Enter gateway address (aaa.bbb.ccc.ddd):
  </programlisting>
  <para>
   Escribimos la IP de vuestra pasarela, generalmente si la IP de vuestra máquina es W.X.Y.Z, la pasarela será W.X.Y.1
  </para>
  <programlisting>
ENTER NETMASK
...
Enter netmask (aaa.bbb.ccc.ddd):
  </programlisting>
  <para>
   generalmente si es de una red C será 255.255.255.0 &lt;OK&gt;
  </para>
  <programlisting>
SELECT NAMESERVER
...
Please give the IP address of the name server to use
You can add more Domain Name Servers by editing /etc/resolv.conf
Name Server for domain es (aaa.bbb.ccc.ddd):
  </programlisting>
  <para>
   Aquí introducimos el DNS primario de nuestro proveedor de internet. Los otros si los hay los ponemos a mano editando el archivo /etc/resolv.conf.
  </para>
  <para>
   De este modo el programa netconfig modifica los ficheros /etc/hosts (asigna nombres de sistema a direcciones IP) y /etc/resolv.conf (indica el dominio local del sistema y los servidores de nombres de dominio) y crea el archivo /etc/rc.d/rc.inet1(configura los dispositivos de red y establece el encaminamiento o &ldquo;routing&rdquo; a otras máquinas). Hay que recordar que tenemos en tal caso que configurar nuestra tarjeta de red (descomentando su entrada como módulo en /etc/rc.d/rc.modules). Una vez terminada la configuración de red...
  </para>
  <programlisting>
Your networking software has now been configured
  </programlisting>
  <para>
   &lt;OK&gt;
  </para>
  <programlisting>
MOUSE CONFIGURATION
  </programlisting>
  <para>
   Nos aparece un menú para seleccionar el tipo de ratón y su protocolo 
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.mouse"></graphic>
  </para>
  <para>
   En mi caso escogí un ratón tipo ps2 cuyo fichero de dispositivo, dev/psaux se enlaza simbólicamente con el dispositivo genérico /dev/mouse.
  </para>
  <programlisting>
GPM CONFIGURATION
  </programlisting>
  <para>
   Si quiero que se cargue el programa que permite el uso del ratón en consolas virtuales desde el arranque del sistema, escogeremos &lt;Yes&gt;, con lo cual añadiremos la línea
  </para>
  <programlisting>
gpm -m /dev/mouse -t ps2
  </programlisting>
  <para>
   al script de inicio /etc/rc.d/rc.gpm
  </para>
  <programlisting>
SENDMAIL CONFIGURATION
SMTP Standard TCP/IP config, no MAPS
MAPSRBL TCP/IP with MAPS RBL mail rejection
MAPSRBL+ TCP/IP with MAPS RBL+ (stronger) mail rejection
UUCP Use UUCP for mail transmission through a smarthost
  </programlisting>
  <para>
   Yo prefiero escoger el sistema estándar (SMTP) sin recursos de MAPS para rechazar correo indeseable ... para el spam y demás ya pondremos nuestros propios filtros con fetchmail+procmail ;-)
  </para>
  <para>
   Así que escogemos SMTP y &lt;OK&gt;.
  </para>
  <programlisting>
HARDWARE CLOCK SET TO UTC?
  </programlisting>
  <para>
   Elegiremos establecer el reloj en la hora local
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.hardware_clock"></graphic>
  </para>
  <para>
   Así que seleccionamos NO Hardware clock is set to local time y &lt;OK&gt;.
  </para>
  <programlisting>
TIMEZONE CONFIGURATION
  </programlisting>
  <para>
   Del siguiente menú 
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/setup.timezone"></graphic>
  </para>
  <para>
   Bajaremos con el cursor hasta encontrar Europa/Madrid y entonces &lt;OK&gt;.
  </para>
  <programlisting>
SELECT DEFAULT WINDOW MANAGER FOR X
  </programlisting>
  <para>
   <graphic fileref="/home/gustavo/book/setup.xwmconfig"></graphic>
  </para>
  <para>
   se trata de una cuestión de gustos; así que cada uno escoja el que más le guste (y haya instalado antes ;-)).
  </para>
  <programlisting>
WARNING: NO ROOT PASSWORD DETECTED
Would you like to set a root password
  </programlisting>
  <para>
   &lt;Yes&gt;. Evidentemente es algo crucial.
  </para>
  <programlisting>
Changing password for root
Enter the new password
New password: (lo metemos)
Re-enter new password: (lo re escribimos)
  </programlisting>
  <para>
   Y POR FIIIINNNNN:
  </para>
  <programlisting>
SETUP COMPLETE
Exit setup and reboot con Ctrl-Alt-del
  </programlisting>
  <para>
   De este modo, volvemos al frontispicio del programa setup y escogemos EXIT &lt;OK&gt;. Luego hacemos Ctrl-Alt-del para reiniciar el sistema. Pero antes de que lo hagáis considerad:
  </para>
  <itemizedlist>
   <listitem>
   <para>
   si arrancáis mediante LILO en el MBR o en la partición raíz, quitad el floppy que pudiera estar en la disquetera y el CD del lector (caso de BIOS CD arrancables). 
   </para>
  </listitem>
   <listitem>
   <para>
   si lo hacéis desde el floppy, dejadlo dentro y sacad el CD del lector (BIOS CD arrancables).
   </para>
  </listitem>
   <listitem>
   <para>
   si lo vais a hacer con loadlin, primero arranca con el floppy para terminar la instalación y luego ya lo acabaremos (Siempre sacad el CD del lector si la BIOS es CD arrancable).
   </para>
  </listitem>
  </itemizedlist>
  <para>
   Reiniciad la maquina... y continuamos con la instalación.
  </para>
  </sect1>
 </chapter>
 <chapter>
  <title>
  La Post-instalación
 </title>
  <sect1>
   <title>
   Creación de cuentas de usuario
  </title>
  <para>
   Aunque estemos solitos al frente de nuestra máquina no debemos andar nunca como root si no es para realizar tareas de administración, pues cualquier equivocación podría provocar un desastre. Así que lo mejor es crearnos una cuenta utilizando el comando adduser. Haced man adduser primero si es necesario para conocer su uso y luego haceis
  </para>
  <programlisting>
#adduser usuario
  </programlisting>
  <para>
   donde &ldquo;usuario&rdquo; es el nombre del usuario cuya cuenta vais a crear. Seguid todos los pasos del programa (la contraseña hay que escribirla dos veces para comprobar) y a partir de ahora cuando accedais al sistema lo hareis dando en el login: el nombre de la cuenta (aquí &ldquo;usuario&rdquo;) y escribiendo en el password: la contraseña que hayais elegido (mejor letras y números con algún signo &dollar;, &amp;, &percnt;...). Para administrar eventualmente el sistema podeis hacer 
  </para>
  <programlisting>
$ su
  </programlisting>
  <para>
   (de Super User) y a continuación os pedirá el password de root. Una vez introducido, funcionareis como root. Cuando hayais acabado vuestras labores de administración volvereis a ser el usuario normal haciendo 
  </para>
  <programlisting>
#exit
  </programlisting>
  <para>
   Podeis crear las cuentas de usuario que gusteis y los datos (uid, gid, shell...) se gusrdarán en el fichero /etc/passwd pero los passwords estarán encriptados y no aparecerán en tal fichero. 
  </para>
  </sect1>
  <sect1>
   <title>
   Configuración de las X Window
  </title>
  <para>
   Tenemos que configurar las X. Es fundamental tener anotados algunos datos fundamentales como las tasas de frecuencia horizontal y refresco vertical de nuestro monitor (y si es multifrecuencia) y la denominación de nuestra tarjeta gráfica, el chipset que usa y la memoria videoram. Si no lo sabemos o hemos perdido la documentación siempre podemos invocar el programa 
  </para>
  <programlisting>
#SuperProbe
  </programlisting>
  <para>
   que proporciona el nombre de la tarjeta, su chipset, memoria y ramdac.
  </para>
  <para>
   Ahora es el momento de hacer la instalación gráfica de las X con la herramienta XF86Setup. Hacemos, pues
  </para>
  <para>
    
  </para>
  <programlisting>
#XF86Setup
  </programlisting>
  <para>
   Y a partir de ahora vamos configurando paso a paso cada ítem gráficamente mediante clicks y arrastres con el ratón.
  </para>
  <para>
   El procedimiento es muy intuitivo porque en la barra superior de la ventana aparecen botones correspondientes a los elementos que hemos de configurar: Mouse, Keyboard, Card, Monitor, Mode Selection y Other como vemos en la figura: 
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/xf86setup"></graphic>
  </para>
  <para>
   Empezamos con el ratón mismo (mouse): ya estará bien configurado y simplemente si es un ratón de dos botones conviene activar la emulación con tres botones.
  </para>
  <para>
   NOTA: Puede ocurrir en el caso de que nuestro ratón sea ps2 y haya sido configurado previamente y lanzado como demonio (gpm -m /dev/psaux -t ps2 -Rms3, que al configurar las X aparezca no como /dev/psaux, sino como Microsoft  gpmdata (pseudodevice, repeater data for gpm mouse daemon). No os preocupéis y p'alante. (apply)
  </para>
  <para>
    
  </para>
  <para>
   En el teclado (keyboard) debéis seleccionar el de 102 teclas internacional y el idioma Spanish (apply), pero ¡Atención! en algunos casos he observado que se producía un &ldquo;cuelgue&rdquo; de las X cuando se configuraba en español. Si eso ocurriera NO IMPORTA. Pulsad Alt-Ctrl-Backspace para salir del cuelge a la consola y volved a comenzar. Haced lo mismo EXCEPTO la configuración del teclado y seguid adelante (lo dejaremos para el final) ;-)
  </para>
  <para>
    
  </para>
  <para>
   En el apartado de la tarjeta gráfica (Card) debéis seleccionarla de la lista. En mi caso se trata de una S3 Virge GX2 (generic). Podemos pasar al detailed setup y veremos arriba seleccionado el servidor X correspondiente a la tarjeta en cuestión, en mi caso, de nuevo es el SVGA. Podemos indicar la cantidad de memoria de la misma (la mía tiene 4Mb de video RAM) y si lo sabemos, mas opciones (chipset, ramdac, Clockchip) pero NO ES NECESARIO; basta con escoger la tarjeta y con mucho indicar la memoria.
  </para>
  <para>
    
  </para>
  <para>
   Para configurar el Monitor debemos escribir en los dos panelitos superiores bajo la denominación de Monitor sync rates los intervalos de frecuencias horizontales y verticales del mismo que las debéis saber (mirad la documentación). El mío tiene de frecuencia horizontal el intervalo 30-69 (kHz) y de vertical el rango de 50-120 (Hz).
  </para>
  <para>
    
  </para>
  <para>
   Los modos gráficos (Mode selection) permiten elegir la resolución de los gráficos así como la profundidad de color expresada en bits por pixel (bpp). El número de colores se puede calcular como 2 **profundidad (2 elevado al valor de profundidad de bpp). Así, 8 bpp corresponden a 256 colores, 16bpp a 65536, 24bpp a casi 17 millones y 32 bpp (true color) a más de cuatro mil millones. Las tarjetas gráficas almacenan el contenido de los píxeles en memoria de acceso aleatorio, conocida como vídeo RAM. El número de colores y la resolución de pantalla admitido por una tarjeta gráfica depende de su video RAM. Por ejemplo: Si quiero una resolución de 1024 x 768 pixels y una profundidad de color de 16 bpp, la cantidad de memoria necesaria será: 1024 x 768 pixel x 16 bits/pixel = 12582912 bits = 1572864 bytes (8 bits = 1byte) = 1.6 Mbytes (aprox.). Si tengo una tarjeta de 4 Mbytes puedo mantener esa resolución a 24 bpp (necesita unos 2.4 Mbytes) y a 32 bpp (alrededor de 3.2 Mbytes). Con una tarjeta de 1 Mbyte no puedo conseguir resolución de 1024x768 ni siquiera con el mínimo de profundidad ( 8bpp). Hacemos las cuentas y seleccionamos la resolución y la profundidad que queremos. En mi caso escogí 1024x768pixel y 16bpp.
  </para>
  <para>
    
  </para>
  <para>
   Ya solo queda hacer click en el siguiente y último botón de la barra superior (Other) y comprobar que tiene activada la secuencia de escape de las X, con las teclas Alt+Ctrl+Backspace y hacemos click en Done, con lo cual después de unos momentos nos saldrá el panel donde nos dice la ruta en que se almacenará la configuración (/etc/XF86Config) y si todo ha ido bien seleccionaremos Save the configuration and exit y ¡se acabó la configuración de las X excepto por el detalle del teclado! Vamos a arreglarlo ahora mismo: editamos como root con el editor que más nos guste (os recomiendo vi/vim/elvis) el fichero /etc/XF86Config y navegamos en él hasta llegar a la sección &ldquo;Keyboard&rdquo;. Allí veremos
  </para>
  <programlisting>
Section "Keyboard"
XkbModel "pc101"
XkbLayout "us"
  </programlisting>
  <para>
   que tenemos que modificarlas a:
  </para>
  <programlisting>
Section "Keyboard"
XkbModel "pc102"
XkbLayout "es"
  </programlisting>
  <para>
   Luego salvamos el fichero e invocamos 
  </para>
  <programlisting>
$ startx
  </programlisting>
  <para>
   Y si hemos escogido como escritorio al KDE, veremos como se carga ante nuestros ojos : ). Si quieres pasar a una consola lo puedes hacer con Alt+Ctrl+Fx (x de 1 a 6) y vuelves a la pantalla gráfica con Alt+Ctrl+F.
  </para>
  </sect1>
  <sect1>
   <title>
   LILO y Loadlin
  </title>
  <para>
   El programa liloconfig de Slackware está actualizado con la última versión de lilo y se encarga de ver si el disco duro es grande y el cargador de linux ha de albergarse más allá de los 1024 cilindros. En tal caso y si la BIOS es suficientemente reciente, resuelve el problema y configura lilo adecuadamente. En mi caso, la partición raíz de Slackware (/dev/hda4) está mucho más lejos de los 1024 cilindros. Pero mi BIOS no está muy obsoleta y ha funcionado el lilo. El contenido del fichero /etc/lilo.conf creado por liloconfig es el siguiente (quitando alguna morrallita de las framebuffers comentadas) :
  </para>
  <programlisting>
# LILO configuration file 
# generated by 'liloconfig' 
# 
# Start LILO global section 
lba32 
# Allow booting past 1024th cylinder with a recent BIOS 
boot = /dev/hda4 
# Normal VGA console 
vga = normal 
# Linux bootable partition config begins 
image = /vmlinuz 
root = /dev/hda4 
label = Linux 
read-only 
# Linux bootable partition config ends
  </programlisting>
  <para>
   No obstante, si en vuestro caso no funcionara, iniciais el sistema con el disquete de arranque y ahora es el momento usar loadlin. Entrad como root y montad en /mnt la partición de vuestro Windows 98 (que sera p. ej. /dev/hda1) mediante
  </para>
  <para>
    
  </para>
  <programlisting>
darkstar:#>mount -t vfat /dev/hda1 /mnt
darkstar:#>cd /mnt
darkstar:/mnt#>mkdir loadlin
darkstar:/mnt#> cd /
darkstar:/#>ls
  </programlisting>
  <para>
   y verás que entre los archivos se encuentra vmlinuz que es nuestro kernel de arranque. Vamos a copiarlo al directorio loadlin que hemos hecho en la partición de windows 98 (que coincidirá con la unidad C:&bsol; en DOS/WINDOWS).
  </para>
  <para>
    
  </para>
  <programlisting>
darkstar:/#>cp vmlinuz /mnt/loadlin/
darkstar:/#>cd /root
darkstar:#>ls
  </programlisting>
  <para>
    y verás entre otros archivos a loadlin16a.zip.
  </para>
  <para>
    
  </para>
  <para>
   Cópialo y descomprímelo en /tmp:
  </para>
  <para>
    
  </para>
  <programlisting>
darkstar:#>cp loadlin16a.zip /tmp
darkstar:#>cd /tmp
darkstar:/tmp#>unzip loadlin16a.zip


  </programlisting>
  <para>
   Unzip debe estar instalado. Al descomprimir se producirá el directorio loddlin que contiene dos ficheros fundamentales: loadlin.exe y linux.bat
  </para>
  <para>
    
  </para>
  <programlisting>
darkstar:/tmp#>cd loadlin
darkstar:/tmp/loadlin#>


  </programlisting>
  <para>
   Edita ahora con tu editor favorito el fichero linux.bat y verás su contenido:
  </para>
  <para>
    
  </para>
  <programlisting>
rem
 Sample DOS batch file to boot Linux.
rem
 First, ensure any unwritten disk buffers are flushed:
smartdrv /C
rem
 Start the LOADLIN process:
c:\loadlin\loadlin
 c:\loadlin\zimage
 root=/dev/hdb2
 ro
 vga=3

 
  </programlisting>
  <para>
   debemos cambiar /dev/hdb2 por nuestra partición Linux: /dev/hda4 (en nuestro ejemplo)
  </para>
  <para>
    
  </para>
  <para>
   y luego lo salvamos.
  </para>
  <para>
    
  </para>
  <para>
   Ahora, después de esto, copiamos estos dos ficheros en el directorio loadlin que habíamos creado en la partición de Windows:
  </para>
  <para>
    
  </para>
  <programlisting>
darkstar:/tmp/loadlin#>cp loadlin.exe
 linux.bat
 /mnt/loadlin/
  </programlisting>
  <para>
   y ya está todo listo
  </para>
  <para>
    
  </para>
  <para>
   Si estás escribiendo desde una xterm en las X, sal de ahí y desde la consola haz un reboot (o directamente Alt+Ctrl+Del). Inicia Windows 98 con el bootmanager que tengas y una vez allí: ve con el explorador de Windows a la carpeta c:&bsol;loadlin. Marca el fichero linux.bat con el ratón y selecciona en el menú de edición 'Copiar'. Vamos al escritorio, pulsamos el botón derecho del ratón y seleccionamos 'Pegar Acceso Directo'. Marcamos el acceso directo recién hecho con un click del ratón y pulsando su botón derecho seleccionamos 'Propiedades'. Escogemos la solapa 'Programa' y pulsamos en 'Avanzado...', luego marcamos la casilla 'Modo MS-DOS' y confirmamos con 'Aceptar'. Después pulsamos en 'Cambiar Icono...' y escogemos el que mas nos guste (El del capirote de mago con varita mágica por ejemplo &lt;(8^) ). Podemos cambiar la leyenda del icono (linux.bat) por otra mas adecuada como 'Slackware'. Al hacer doble click sobre el icono, saldrá primero una advertencia de que vamos a entrar en modo MS-DOS y luego ...accederemos a Slackware. (Esto lo he sacado de mi manual de SuSE 6.4)
  </para>
  <para>
   NOTA: Es posible pasar parámetros con loadlin como se hace con lilo, pero no lo comentaré. Leeros el manual de loadlin que viene con loadlin16a.zip y mirad el ejemplo test.par.
  </para>
  </sect1>
  <sect1>
   <title>
   Configuración de la tarjeta de red
  </title>
  <para>
   Si estando directamente conectados a la red mediante tarjeta ethernet y no cargamos en el núcleo los controladores como módulos, ahora es el momento de hacerlo. Tenemos evidentemente que conocer los datos de nuestra tarjeta. En mi caso de trata de una típica SMC Ether EZ con io = 0x2a0. El correspondiente driver es el smc-ultra. Si vamos al fichero /etc/rc.d/rc.modules, que es el fichero que contiene los módulos del kernel que se cargan en el arranque, navegando encontraremos 
  </para>
  <programlisting>
### Network device support ### 
# Most of these drivers will probe automatically for the card if you don't 
# specify an I/O address and IRQ. But, the NE2000 driver needs at least the 
# I/O. For complete information, see the net-modules.txt file that comes 
# with the Linux 2.2.x source code. This file can also be found on the 
# Slackware CD-ROM in the /docs/linux-2.2.x/ directory. 
# 
# First, if setup probing found a network card, there may be an 'rc.netdevice' 
# file that we should run to load the network module: 
if [ -x /etc/rc.d/rc.netdevice ]; then 
. /etc/rc.d/rc.netdevice 
fi
  </programlisting>
  <para>
   La tarjeta smc-ultra depende del chip 8390 y efectivamente, unas líneas debajo de
  </para>
  <programlisting>
### Ethernet cards based on the 8390 chip.
  </programlisting>
  <para>
   encontramos 
  </para>
  <programlisting>
# SMC Ultra support: 
#/sbin/modprobe smc-ultra
  </programlisting>
  <para>
   Basta con descomentar la línea /sbin/modprobe smc-ultra y guardar los cambios para que en el próximo arranque funcione nuestra tarjeta de red. Si todo ha ido bien y hacemos ifconfig, aparecerá además del bloque de loopback (lo) el de la interfaz ethernet (eth0).
  </para>
  </sect1>
  <sect1>
   <title>
   Configuración de la impresora
  </title>
  <para>
   Slackware instala por defecto los módulos parport ni parport_pc, que son necesarios para el funcionamiento de una impresora en paralelo. Para instalar y configurar la impresora usando el demonio de impresión típico en las distribuciones afines a BSD, como los FreeBSD y Slackware, el programa que hay que usar es apsfilter. En la &ldquo;current-version&rdquo; de la que hablo, se instala el paquete apsfilter 6.0 pero sin embargo se instala el paquete ghostscript versión 5.50. Para que la cosa vaya bien  
  </para>
  <para>
   (a) O bien actualizamos a ghostscript 6.01 (que habrá qu buscarlo en la red)
  </para>
  <para>
   (b) Desisnstalamos apsfilter 6.0 e instalamos el apsfilter 5.0
  </para>
  <para>
   Esta segunda opción es más fácil porque el paquete apsfilter 5.0 lo podemos encontrar en la URL oficial de slackware, <ulink url="http://www.slackware.com"></ulink> en formato tgz. 
  </para>
  <para>
   Así, lo primero será desinstalar el paquete apsfilter que viene en la distro. Para ello, como root, hacemos en consola
  </para>
  <programlisting>
#pkgtool
  </programlisting>
  <para>
   y saldrá un menú del que escogereis &ldquo;Remove&rdquo;. Seleccionais (con la barra espaciadora) el paquete apsfilt y &lt;OK&gt;. Una vez eliminado, nos vamos a la página de Slackware &lsqb; ATENCIÓN: Todavía no hemos hablado de conexión a internet. Así que primero habrá que aprender a hacerlo y a navegar usando Netscape o Konqueror de KDE. Eso lo veremos más abajo&rsqb;, Seleccionamos &ldquo;Packages&rdquo; y en el formulario elegimos:
  </para>
  <itemizedlist>
   <listitem>
   <para>
   Slackware version : 7.1
   </para>
  </listitem>
   <listitem>
   <para>
   Architechture : i386 (o la que corresponda)
   </para>
  </listitem>
   <listitem>
   <para>
   Software series : AP- Various applications ....
   </para>
  </listitem>
  </itemizedlist>
  <para>
   Luego tecleando en Browse, aparecerán los paquetes de la serie. El primero apsfilt.tgz es el programa apsfilter-5.0.1 que nos vendrá bien. Lo descargamos de la página y lo llevamos a /tmp/
  </para>
  <para>
   Allí hacemos (como root)
  </para>
  <programlisting>
#installpkg apsfilt.tgz
  </programlisting>
  <para>
   y ya está. Después cambiamos al directorio /usr/lib/apsfilter y hacemos
  </para>
  <programlisting>
#./SETUP
  </programlisting>
  <para>
   y seguimos a pies juntillas las instrucciones. Si en lugar de la versión actual &ldquo;current&rdquo; teneis la 7.1 no habrá ningún problema.
  </para>
  <para>
   En mi caso tengo una impresora hp Deskjet 930C y digo de antemano que en esta versión de ghostscript los &ldquo;drivers&rdquo; que son compatibles con ella son los de las hp Deskjet 550C (probando, probando ;-)). Para otro caso y si no encontramos la nuestra, habrá que hacer alguna probatina o preguntar en las news : ).
  </para>
  <para>
   Sin entrar en demasiados detalles, en el menú principal del apsfilter setup aparecen una serie de ítems. El primero que debemos seleccionar es 
  </para>
  <programlisting>
(1) Printer Driver Selection
  </programlisting>
  <para>
   Seleccionando 1 + &lt;ENTER&gt;, entramos en otro menú de controladores ghostscript para las impresoras. Como en mi caso tengo una hp Deskjet selecciono 
  </para>
  <programlisting>
(4) For HP Deskjet ...
  </programlisting>
  <para>
   Y de los controladores que se muestran escojo el
  </para>
  <programlisting>
(7) cdj550 --> HP Deskjet 550C/560C
  </programlisting>
  <para>
   que aunque no corresponde a mi modelo, hace que funcione perfectamente.
  </para>
  <para>
   Luego, entramos de nuevo en el menú principal y seleccionamos
  </para>
  <programlisting>
(2) Interface setup
  </programlisting>
  <para>
   Aquí escogemos si la impresora va a conectarse por el puerto paralelo, serie... (El nuevo apsfilter 6.0 que espero que en la definitiva Slackware 7.2 ya conviva con ghostscript 6.0, permite configurar puerto paralelo, USB, serie, local, remota, tipo Unix/Linux y Windows/Samba... será un gustazo : )). En mi caso lo haré por el puerto paralelo:
  </para>
  <programlisting>
(1) a parallel printer
  </programlisting>
  <para>
   y hay que dar el fichero de dispositivo (/dev/lp0 desde el kernel 2.2.13)
  </para>
  <programlisting>
Full path of parallel print device: /dev/lp0
  </programlisting>
  <para>
   De nuevo en el menú principal debemos dejar las opciones siguientes en el estado &lsqb;default&rsqb;:
  </para>
  <programlisting>
(3) print resolution
(4) Monochrom/Color
  </programlisting>
  <para>
   La opción siguiente corresponde a
  </para>
  <programlisting>
(5) Paper format
  </programlisting>
  <para>
   conduce a tres posibilidades, de las cuales escogemos:
  </para>
  <programlisting>
1 DIN A4
  </programlisting>
  <para>
   Ya lo que queda es comprobar que el driver y las otras selecciones son las adecuadas imprimiendo una página de prueba. Para ello escogemos
  </para>
  <programlisting>
(T) Print test page
  </programlisting>
  <para>
   y luego de nuevo (T)... con ello se crea la página de prueba y se imprime a continuación. Se trata de la figura de un tigre (tiger.ps) que debe quedar a gusto del consumidor exigente. En mi caso salió perfectamente y entonces escogí
  </para>
  <programlisting>
(C) Continue print setup
  </programlisting>
  <para>
   nos preguntará entonces
  </para>
  <programlisting>
"is your printer a (c)olor or (m)ono printer?"
  </programlisting>
  <para>
   yo escojo la &ldquo;c&rdquo; porque es una impresora de color, y después vemos que guarda el /etc/printacap original, comprueba los permisos de /var/spool/lpd (que deben ser root y lp), escribe entonces todas las entradas en el fichero /etc/printcap y establece un fichero global de configuración en /etc/apsfilterrc.
  </para>
  <para>
   En mi caso, el fichero /etc/printcap es el siguiente:
  </para>
  <para>
   &num; LABEL apsfilter
  </para>
  <para>
   &num; apsfilter setup mié mar  7 01:59:13 CET 2001
  </para>
  <para>
   &num;
  </para>
  <para>
   &num; APS_BASEDIR:/usr/lib/apsfilter
  </para>
  <para>
   &num;
  </para>
  <para>
   &num;
  </para>
  <para>
   ascii|lp1|cdj500-a4-ascii-mono|cdj500 ascii mono:&bsol;
  </para>
  <para>
           :lp=/dev/lp0:&bsol;
  </para>
  <para>
           :sd=/var/spool/lpd/cdj500-a4-ascii-mono:&bsol;
  </para>
  <para>
           :lf=/var/spool/lpd/cdj500-a4-ascii-mono/log:&bsol;
  </para>
  <para>
           :af=/var/spool/lpd/cdj500-a4-ascii-mono/acct:&bsol;
  </para>
  <para>
           :if=/usr/lib/apsfilter/filter/aps-cdj500-a4-ascii-mono:&bsol;
  </para>
  <para>
           :mx&num;0:&bsol;
  </para>
  <para>
           :sh:
  </para>
  <para>
   &num;
  </para>
  <para>
   lp2|cdj500-a4-auto-mono|cdj500 auto mono:&bsol;
  </para>
  <para>
           :lp=/dev/lp0:&bsol;
  </para>
  <para>
           :sd=/var/spool/lpd/cdj500-a4-auto-mono:&bsol;
  </para>
  <para>
           :lf=/var/spool/lpd/cdj500-a4-auto-mono/log:&bsol;
  </para>
  <para>
           :af=/var/spool/lpd/cdj500-a4-auto-mono/acct:&bsol;
  </para>
  <para>
           :if=/usr/lib/apsfilter/filter/aps-cdj500-a4-auto-mono:&bsol;
  </para>
  <para>
           :mx&num;0:&bsol;
  </para>
  <para>
           :sh:
  </para>
  <para>
   &num;
  </para>
  <para>
   lp3|cdj500-a4-ascii-color|cdj500 ascii color:&bsol;
  </para>
  <para>
           :lp=/dev/lp0:&bsol;
  </para>
  <para>
           :sd=/var/spool/lpd/cdj500-a4-ascii-color:&bsol;
  </para>
  <para>
           :lf=/var/spool/lpd/cdj500-a4-ascii-color/log:&bsol;
  </para>
  <para>
           :af=/var/spool/lpd/cdj500-a4-ascii-color/acct:&bsol;
  </para>
  <para>
           :if=/usr/lib/apsfilter/filter/aps-cdj500-a4-ascii-color:&bsol;
  </para>
  <para>
           :mx&num;0:&bsol;
  </para>
  <para>
           :sh:
  </para>
  <para>
   &num;
  </para>
  <para>
   lp|lp4|cdj500-a4-auto-color|cdj500 auto color:&bsol;
  </para>
  <para>
           :lp=/dev/lp0:&bsol;
  </para>
  <para>
           :sd=/var/spool/lpd/cdj500-a4-auto-color:&bsol;
  </para>
  <para>
           :lf=/var/spool/lpd/cdj500-a4-auto-color/log:&bsol;
  </para>
  <para>
           :af=/var/spool/lpd/cdj500-a4-auto-color/acct:&bsol;
  </para>
  <para>
           :if=/usr/lib/apsfilter/filter/aps-cdj500-a4-auto-color:&bsol;
  </para>
  <para>
           :mx&num;0:&bsol;
  </para>
  <para>
           :sh:
  </para>
  <para>
   &num;
  </para>
  <para>
   raw|lp5|cdj500-a4-raw|cdj500 auto raw:&bsol;
  </para>
  <para>
           :lp=/dev/lp0:&bsol;
  </para>
  <para>
           :sd=/var/spool/lpd/cdj500-raw:&bsol;
  </para>
  <para>
           :lf=/var/spool/lpd/cdj500-raw/log:&bsol;
  </para>
  <para>
           :af=/var/spool/lpd/cdj500-raw/acct:&bsol;
  </para>
  <para>
           :if=/usr/lib/apsfilter/filter/aps-cdj500-a4-raw:&bsol;
  </para>
  <para>
           :mx&num;0:&bsol;
  </para>
  <para>
           :sh:
  </para>
  </sect1>
  <sect1>
   <title>
   Escuchar música
  </title>
  <para>
   Ahora es muy fácil conseguir configurar nuestra tarjeta de sonido si no es muy peregrina porque ya existe apoyo para sonido en el kernel en forma modular. El ejemplo lo voy a poner con mi tarjeta de sonido, una clásica entre las clásicas: una SoundBlaster 16. Es muy importante recopilar toda la información acerca de la tarjeta de sonido a partir de la documentación o del Panel de Control de Windows viendo las propiedades de los dispositivos, para saber las direcciones de entrada/salida (io), las solicitudes de interrupción (irq), el acceso directo a memoria (dma, dma16), etc. 
  </para>
  <para>
    
  </para>
  <para>
   En mi caso:
  </para>
  <para>
   Creative SoundBlaster 16
  </para>
  <para>
   irq=5
  </para>
  <para>
   dma=1
  </para>
  <para>
   dma16=5
  </para>
  <para>
   sb io = 0x220-0x22f
  </para>
  <para>
   mpu_io = 0x330-0x331
  </para>
  <para>
   adlib_card io = 0x388-0x38b
  </para>
  <para>
    
  </para>
  <para>
   uart401 es el módulo &ldquo;Yamaha OPL3-SA1 audio controller&rdquo;
  </para>
  <para>
   y adlib_card es el módulo &ldquo;FM synthetizer for YM3812/OPL-3 support&rdquo;
  </para>
  <para>
    
  </para>
  <para>
   Si vamos de nuevo al fichero /etc/rc.d/rc.modules encontraremas la sección
  </para>
  <programlisting>
### Sound support ### 
# Sound Blaster Pro/16 support: 
#/sbin/modprobe sb io=0x220 irq=5 dma=3 dma16=5 mpu_io=0x300 
# Sound Blaster Live support: 
#/sbin/modprobe emu10k1 
# MAD16 support: 
#/sbin/modprobe mad16 io=0x530 irq=7 dma=0 dma16=1 
# AD1816(A) sound driver: 
#/sbin/modprobe modprobe ad1816 io=0x530 irq=5 dma=1 dma2=3 ad1816_clockfreq=33000 
# ES1370 support, such as Sound Blaster 128PCI: 
#/sbin/modprobe es1370 
# ES1371 support, such as Sound Blaster 64V PCI: 
#/sbin/modprobe es1371 
# ESS Maestro driver: 
#/sbin/modprobe maestro 
# (For information on configuring other sound cards with Linux, 
# see the documentation in /usr/src/linux/Documentation/sound/)
  </programlisting>
  <para>
   en donde encontramos una gran cantidad de módulos de tarjetas de sonido habituales. Ahora basta con descomentar la línea bajo &ldquo;Sound Blaster Pro/16 support y pasarle los parámetros adecuados a nuestra tarjeta. En mi caso:
  </para>
  <programlisting>
### Sound support ### 
# Sound Blaster Pro/16 support: 
/sbin/modprobe sb io=0x220 irq=5 dma=1 dma16=5 mpu_io=0x330 
/sbin/modprobe uart401 
/sbin/modprobe adlib_card io=0x388 
#
  </programlisting>
  <para>
   La próxima vez que iniciemos el sistema, los módulos de sonido se cargarán y si hacemos 
  </para>
  <programlisting>
cat /dev/sndstat 
  </programlisting>
  <para>
   aparece:
  </para>
  <programlisting>
OSS/Free:3.8s2++-971130
Load type: Driver loaded as a module
Kernel: Linux darkstar 2.2.13 #22 Wed Oct 20 17:32:52 CDT 1999 i686
Config options: 0


Installed drivers:


Card config:


Audio devices:
0: Sound Blaster 16 (4.13) (DUPLEX)


Synth devices:
0: Yamaha OPL3


Midi devices:
0: Sound Blaster 16


Timers:
0: System clock


Mixers:
0: Sound Blaster
  </programlisting>
  <para>
   OK! Si metemos un CD de música en nuestro lector y manualmente lo accionamos, lo escucharemos. Pero hacerlo así (aunque yo es lo que prefiero por sencillez) puede a otro parecer cutre y preferir por ejemplo hacerlo con el CD player del KDE. En tal caso no le funcionará...todavía porque no tenemos permiso de acceso a una serie de dispositivos. Para que todos los usuarios de la máquina puedan escuchar música sin tener que pulsar manualmente la tecla del lector hay que dar los permisos adecuados:
  </para>
  <para>
    
  </para>
  <para>
   chmod 666 /dev/dsp  /dev/audio  /dev/cdrom
  </para>
  <para>
    
  </para>
  <para>
   La próxima vez que ingresemos en el escritorio KDE ya se producirán los eventos de sonido (si están funcionales). Y al activar el CD-player funcionará y escucharemos música &ldquo;con magno artificio&rdquo;.
  </para>
  <para>
   Antes de terminar voy también a decir como configurar tarjetas PCI como la Creative SoundBlaster PCI 64 o128. Estas tarjetas vienen provistas de chips del tipo Ensonic ES1370 ó ES1371. Para instalar el controlador correspondiente descomentamos la línea debajo de &ldquo;ES1370 support, such as Sound Blaster 128PCI&rdquo; o &ldquo;ES1371 support, such as Sound Blaster 64PCI&rdquo;
  </para>
  <para>
   NOTA: Estas tarjetas no soportan el dispositivo /dev/sndstat ni permiten la reproducción directa con cat y /dev/audio. No tienen soporte MIDI por hardware, pero podemos parchearlo descargando el paquete timidity.
  </para>
  </sect1>
  <sect1>
   <title>
   Conexión PPP
  </title>
  <para>
   En principio utilizaremos la herramienta pppsetup, que es la genuina de Slackware. Para ello haremos como root
  </para>
  <programlisting>
pppsetup
  </programlisting>
  <para>
   y nos aparece el frontispicio
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/Pppsetup"></graphic>
  </para>
  <para>
   hacemos &lt;ENTER&gt; y pasamos al menú &ldquo;Phone number&rdquo;, donde hay que dar el número de teléfono de nuestro proveedor de internet
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/pppsetup.phonenumber"></graphic>
  </para>
  <para>
   Por ejemplo, supongamos que voy a conectarme usando la conexión gratis que ofrece eresmas.com para el nodo de Sevilla (955000123). Como el marcado es por tonos escribiré
  </para>
  <programlisting>
atdt955000123
  </programlisting>
  <para>
   y luego &lt;OK&gt;. A continuación hay que indicar el dispositivo del módem
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/pppsetup.modem"></graphic>
  </para>
  <para>
   que en mi caso será ttyS1 y luego &lt;OK&gt;. Después hay que indicar la velocidad en baudios:
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/pppsetup.baudrate"></graphic>
  </para>
  <para>
   que en mi caso es de 115200 porque mi modem es de 56 Kbps. Ahora hay que especificar si nuestro proveedor de internet usa &ldquo;callback&rdquo; (lo llamamos y le damos nuestro número de teléfono y luego nos llaman a nosotros dándonos el login y password) 
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/pppsetup.callback"></graphic>
  </para>
  <para>
   que en la mayoría de los casos es &ldquo;NO&rdquo;, como en nuestro ejemplo. Para finalizar con el modem hemos de indicar la cadena de inicio del modem
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/pppsetup.initstring"></graphic>
  </para>
  <para>
   que a menos que se tenga un modem extraño, deberá ser &ldquo;AT&amp;FH0&rdquo;. Hacemos &lt;ENTER&gt; para aceptar este valor por defecto.
  </para>
  <para>
   Ahora tenemos que indicar el nombre de dominio de nuestro proveedor de internet
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/pppsetup.domain"></graphic>
  </para>
  <para>
   en el ejemplo será &ldquo;eresmas.com&rdquo; y luego &lt;OK&gt;.
  </para>
  <para>
   A continuación hemos de indicar la dirección IP del servidor de nombres de dominio (DNS) de nuestro proveedor de internet
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/pppsetup.dns"></graphic>
  </para>
  <para>
   Introducimos la dirección IP del DNS principal: 62.81.16.197 y &lt;OK&gt;
  </para>
  <para>
   Después habremos de decir el método de autenticación
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/pppsetup.authentication"></graphic>
  </para>
  <para>
   Escogemos PAP y &lt;OK&gt;. Entonces nos pedirán que introduzcamos el nombre de usuario, que para acceder a eresmas es &ldquo;1050@eresmas&rdquo; y luego el password, que es &ldquo;gratis&rdquo;. 
  </para>
  <para>
   Finalmente, el programa nos muestra los ficheros de configuración PPP 
  </para>
  <para>
   <graphic fileref="/home/gustavo/book/pppsetup.done"></graphic>
  </para>
  <para>
   para que comprobemos y luego pulsamos &lt;ENTER&gt; para salir de pppsetup
  </para>
  <para>
   ¡Se acabó!
  </para>
  <para>
    
  </para>
  <para>
   De todos modos creo conveniente incluir en nuestro archivo /etc/resolv.conf los otros DNS del proveedor:
  </para>
  <para>
   ---------------------------
  </para>
  <programlisting>
search eresmas.com
nameserver 62.81.16.197
nameserver 62.81.0.1
  </programlisting>
  <para>
   ---------------------------
  </para>
  <para>
   Para la conexión (como root) usaremos la herramienta ppp-go. Escucharemos el click del modem si es interno, esperamos un poco y saldrá algo como
  </para>
  <programlisting>
#>Local: 62.82.85.62 --> Remote: 62.81.56.40 ppp0
  </programlisting>
  <para>
   Una vez que nos de una dirección IP local y remota ¡ya estamos conectados con internet! Podemos comprobar nuestra conexión haciendo
  </para>
  <programlisting>
#>ifconfig
  </programlisting>
  <para>
   y veremos que además del bloque de loopback (lo) está el de PPP (ppp0). Podemos probar a hacer ping, traceroute, telnet...Ahora como usuario normal, podemos entrar en KDE (o GNOME o WM...) y abrir netscape para navegar o lo que sea y cuando terminemos cerraremos la conexion (como root) con ppp-off.
  </para>
  </sect1>
  <sect1>
   <title>
   Hispanizando Slackware
  </title>
  <para>
   Al que le guste hispanizar su Slacware, no pierda tiempo y siga estas sencillas instrucciones.
  </para>
   <sect2>
    <title>
    La consola
   </title>
   <para>
    Si hemos realizado correctamente la instalación, al iniciarse el sistema, el script de arranque /etc/rc.d/rc.keymap habrá cargado el juego de caracteres del teclado español que se encuentra en /usr/lib/kbd/keytables/es.map mediante la instrucción
   </para>
   <programlisting>
loadkeys /usr/lib/kbd/keytables/es.map
   </programlisting>
   <para>
    Sin embargo veremos que aunque cada letra esta en su sitio del teclado, no visualizamos ni la ñ ni las vocales acentuadas. Para conseguir que la shell bash permita esto deberíamos crear en nuestro directorio &ldquo;home/usuario&rdquo; el fichero .inputrc con el siguiente contenido:
   </para>
   <programlisting>
#Para conservar 8 bits en la entrada del teclado
set input-meta on
#Idem en salida por terminal
set output-meta on
#Para no convertir las secuencias de escape
set convert-meta off
#Para exportar a la variable LC_TYPE el juego de caracteres 
export LC_TYPE=ISO_8859_1
   </programlisting>
   <para>
    Cuando iniciemos una nueva shell, debería permitir las vocales acentuadas y la ñ. Pero no todo funciona como debiera. Si hacéis por ejemplo (no necesariamente como root)
   </para>
   <programlisting>
mkdir cañón
   </programlisting>
   <para>
    y hacéis luego
   </para>
   <programlisting>
ls -l 
   </programlisting>
   <para>
    vereis una línea
   </para>
   <para>
     
   </para>
   <para>
    drwxr-xr-x   2 gustavo  users        4096 Sep  5 15:16 ca??n
   </para>
   <para>
     
   </para>
   <para>
    Esto se debe a que el comando ls no trabaja con caracteres de 8 bits. Podemos parchearlo, pero la solución integral la veremos luego en el apartado Locales.
   </para>
   <para>
    Otro problema aparece con vi y con less. Por defecto muestran solamente los caracteres de 7 bits (los de 8 los representan por su código ASCII). Esto también puede parchearse poniendo en /etc/profile
   </para>
   <programlisting>
export LESSCHARSET=latin1  
   </programlisting>
   <para>
    pero la solución auténtica la veremos en el epígrafe Locales.
   </para>
   <para>
     
   </para>
   </sect2>
   <sect2>
    <title>
    X Window
   </title>
   <para>
     
   </para>
   <para>
    Para asegurarnos de que se ha cargado el teclado español en las X miraremos en el fichero /etc/X11/XF86Config la sección Keyboard y nos aseguraremos que existen las líneas
   </para>
   <programlisting>
XkbModel "pc102"
XkbLayout "es"


   </programlisting>
   <para>
    De todos modos, este método no es perfecto porque muchas aplicaciones bajo X Window  tienen su propia configuración o carecen de soporte para caracteres extendidos.
   </para>
   </sect2>
   <sect2>
    <title>
    Locales
   </title>
   <para>
    Se conoce por 'Locales' a los rasgos culturales característicos de un país, como los caracteres especiales (nuestra ñ, vocales acentuadas), la forma de representar la fecha, etc...En Linux cada proceso funciona en un determinado entorno que llamaremos LOCALE donde se establece como ha de comportarse cada proceso según las peculiaridades del idioma y país. 
   </para>
   <para>
    Si por ejemplo hacemos date, obtenemos
   </para>
   <programlisting>
$date
   </programlisting>
   <para>
    Tue   Sep   5   15:07:31   CEST   2000
   </para>
   <para>
     
   </para>
   <para>
    Luego el entorno LOCALE no es el nuestro, sino el americano (por defecto). Para poder usar nuestro entorno LOCALE, en el fichero de inicio /etc/rc.d/rc.local hemos de añadir:
   </para>
   <programlisting>
echo "Setting locale"
/usr/bin/localedef -i es_ES -f ISO-8859-1 es_ES
   </programlisting>
   <para>
    Luego iremos al fichero /etc/profile y buscaremos la línea &ldquo;export LC_ALL=POSIX&rdquo;. La comentamos con la almohadilla (&num;) y escribimos
   </para>
   <programlisting>
export LC_ALL=es_ES
export LANG=es
   </programlisting>
   <para>
    En caso del español de otros paises iberoamericanos pondremos es_XX en lugar de es_ES, siendo XX=ES (español de España), MX (de México), CO (de Colombia) o AR (de Argentina). (En mi caso particular puse export LANG=es_ES)
   </para>
   <para>
    Ahora, aunque antes no lo hubieramos conseguido, funcionarán la ñ y las vocales acentuadas en la shell bash y al hacer date obtendremos la respuesta coherente:
   </para>
   <programlisting>
$date
   </programlisting>
   <para>
    mar  sep  5  15:07:31   CEST   2000
   </para>
   <para>
    y también leeremos correctamente los acentos y eñes con vi y less
   </para>
   <para>
    De este modo, los mensajes de diversas aplicaciones (Lyx, Netscape...) las veremos en español. Para terminar, si vamos a usar Tex/Latex/LyX y queremos que las palabras se corten de acuerdo con nuestras reglas, no basta con tener el diccionario, sino que hemos de hacer como root
   </para>
   <programlisting>
texconfig
   </programlisting>
   <para>
    luego escogemos HYPHEN y después latex (o pdflatex, etc; pues al hacerlo con uno, lo hacemos con todos ;-))
   </para>
   <para>
    entonces entramos en modo de edición vi y debemos descomentar 
   </para>
   <programlisting>
% spanish
   </programlisting>
   <para>
    luego salimos del editor guardando (:wq) y ya está. Podemos hacer también un REHASH y largarnos.
   </para>
   </sect2>
  </sect1>
 </chapter>
 <chapter>
  <title>
  Personalizando nuestra Slackware
 </title>
 <para>
  Además de los paquetes instalados necesitaremos otros muchos que podremos encontrar por la red como &ldquo;tarballs&rdquo; tar.gz o tar.bz2, que después de descomprimidos y desensamblados se compilan con la &ldquo;tría prima&rdquo; ./configure, make y make install. De todos modos en <ulink url="http://www.linuxmafia.org"></ulink> hay un excelente almacén de paquetes .tgz propios de Slackware.
 </para>
  <sect1>
   <title>
   Navegación, correo y noticias
  </title>
  <para>
   Como ya hemos dicho, si somos principiantes y estamos todavía acostumbrados al windoze o hasta ahora éramos usuarios finales, más vale que para empezar nos instalemos el Netscape Communicator 4.76, que aunque consume recursos es hasta que aparezca Mozzila estable, el bastión fundamental del linuxero novato para el disfrute de internet: Es un excelente navegador y además tiene posee un eficaz gestor de correo electrónico que integra un MUA para la lectura y composición del correo, un &ldquo;MTA&rdquo; que envía nuestras misivas al smarthost (smtp-outgoing ISP server) de nuestro proveedor de correo y un &ldquo;MDA&rdquo; que lo recoge del servidor pop del mismo. Fácil de configurar, es el medio más rápido y sencillo para la comunicación en internet. Además también dispone de un &ldquo;aceptable&rdquo; cliente de news que nos permite leer y componer mensajes de los grupos de noticias del servidor configurado. 
  </para>
  <para>
   Pero si ya tenemos algo de solera en linux, quizás optemos por procedimientos más genuinos. Para la navegación en consola el paquete lynx y su homófono &ldquo;links&rdquo; (algo mejor) son una delicia. Para la gestión del correo electrónico, el MTA (Mail Transfer Agent) que se instala para &ldquo;enviar&rdquo; correo directamente o a través de un smarthost (el SMTP mail server de nuestro ISP) es sendmail que es el más extendido en el mundo unix. Yo personalmente prefiero sendmail por su extremada flexibilidad (aunque hay que vigilar los posibles agujeros de seguridad) y porque en el fondo soy un carroza de tomo y lomo : ). Como MDA (Mail Delivery Agent) para distribuir el correo a nuestra cuenta, me gusta la combinación fetchmail+procmail. El primero lo baja del servidor pop de nuestro ISP y el segundo lo filtra y coloca en nuestra cuenta como nosotros lo hayamos configurado. Excelente para el spam y la estructuración del correo en carpetas. Como MUA (Mail User Agent): Para leer, guardar o eliminar correo, así como para componerlo me gusta pine, pero especialmente mutt. Mutt es extremadamente configurable y moldeable y permite firmar y encriptar mensages con PGP o GPG. Para la lectura de las news me gusta usar el proxy-cahé leafnode, que se baja las news del servidor de nuestro ISP y las podemos leer luego off-line usando el excelente lector slrn. No se me puede olvidar hablar de emacs-gnus para procesar nuestro correo y leer las news. Emacs es un &ldquo;entorno de trabajo&rdquo; que tiene integradas multitud de funcionalidades. Es conveniente pensar en instalar GPG y darle apoyo con mutt/slrn o emacs/gnus.
  </para>
   <sect2>
    <title>
    Sendmail
   </title>
   <para>
    Con Slackware &ldquo;current&rdquo; (pre-7.2) se instala sendmail 8.11.2 y para que funcione como nuestro MTA, apenas hay que modificar el fichero de configuración /etc/mail/sendmail.cf. Si estamos conectados mediante una red permanente y nuestra máquina está dada de alta en el DNS de nuestro proveedor de internet, prácticamente no hay que cambiar nada y funcionará bien. Pero si nuestro &ldquo;host&rdquo; no existe en realidad, entonces no funciona. Por ejemplo: Si me instalo la Slack en mi ordenador y le pongo (hostname) darkstar.es o soylareinadelosmares.com, al intentar enviar un mensaje a alguien se producirá el &ldquo;error 501&rdquo; : Sender domain must exist. Así pues, a continuación indicaré del modo más breve y minimalista cómo enviar correo desde nuestra máquina en casa con una conexión intermitente mediante modem con un proveedor de internet. Para casos más complejos como administrar una red local recomiendo que consulteis un manual adecuado <ulink url="http://lucas.hispalinux.es/Universitarios/tutorial-sendmail.html"></ulink>. Para una configuración rápida podeis consultar los artículos de Santiago Romero <ulink url="http://escomposlinux.org/sromero"></ulink>
   </para>
   <para>
    En principio, supongamos que nuestro proveedor de internet es &ldquo;proveedor.com&rdquo; y tenemos una cuenta de correo &ldquo;cervantes@isp.com&rdquo; con password para la autenticación PAP &ldquo;du1c1n3a&rdquo; y con servidores de correo outgoing (SMTP) e incoming (POP3), smpt.proveedor.com y pop3.proveedor.com, respectivamente. El password para bajarse el correo del servidor POP es &ldquo;qu1j0t3&rdquo;. Lo primero que debemos hacer es crearnos una cuenta con el usuario &ldquo;cervantes&rdquo; (el mismo nombre que el de nuestro correo electrónico). Configuramos el pppsetup con los datos de proveedor.com tal como lo habíamos indicado más arriba con el ejemplo de eresmas para la conexión a internet. Una vez hecho esto editamos el fichero /etc/mail/sendmail.cf y buscamos el trozo:
   </para>
   <programlisting>
# my official domain name 
#...define this only if sendmail cannot automatically determine your domain
Dj$w.foo.com
   </programlisting>
   <para>
    que debeis de cambiar a
   </para>
   <programlisting>
# my official domain name 
#...define this only if sendmail cannot automatically determine your domain
Djproveedor.com
   </programlisting>
   <para>
    con esto debería bastar para enviar correo remoto.
   </para>
   <para>
    Sin embargo algunos prefieren usar lo que se llama un &ldquo;smart relay host&rdquo;, es decir el correo saliente en lugar de llevarlo sendmail hasta la dirección remota, lo entrega al servidor de correo saliente del proveedor de internet, que es el smart host : smtp.proveedor.com y que será el que se encargue de entregar los mensajes. Para ello debe buscar las líneas:
   </para>
   <programlisting>
# "Smart" relay host (may be null) 
DS
   </programlisting>
   <para>
    y modificarla como
   </para>
   <programlisting>
# "Smart" relay host (may be null) 
DSsmtp.proveedor.com
   </programlisting>
   <para>
    Esto puede hacer que la entrega de correo sea más rápida; además, si algunos de los lugares donde se envía el correo tienen difícil acceso (el servidor de correo entrante puede estar ocupado o incluso inactivo durante cierto tiempo) es una buena opción. Pero a mí me gusta usar el sendmail como servidor de correo saliente siempre...tiene alguna ventajilla ;-), por ejemplo evitar los inconvenientes de que el servidor smtp de nuestro proveedor de internet esté inactivo o se haya caído (cosas que ocurren).
   </para>
   <para>
    Otra posible modificación que introducir en el fichero es la adición de un filtro para que a todos los mensajes de correo que enviemos muestre como dirección de retorno el dominio de nuestro proveedor (cdervantes@proveedor.com) en lugar del de nuestra máquina (cervantes@darkstar.es). Esto puede hacerse de manera más elegante usando la opción Reply-to del cliente de correo (MUA), pero algunos prefieren hacerloasí. Para ello buscamos ahora el texto 
   </para>
   <programlisting>
# who I masquerade as (null for no masquerading) (see also $=M) 
DM
   </programlisting>
   <para>
    y lo cambiamos por
   </para>
   <programlisting>
# who I masquerade as (null for no masquerading) (see also $=M) 
DMproveedor.com
   </programlisting>
   <para>
    Cuando enviamos un e-mail, por ejemplo con mutt, pine o xmail a una dirección determinada, el mensaje se graba en el archivo /var/spool/mail hasta que en la próxima conexión a internet, los envíe sendmail con el comando 
   </para>
   <programlisting>
sendmail -q
   </programlisting>
   <para>
    Los mensajes en cola de envío están en /var/spool/mqueue (para releerlos o borarlos) y podemos consultarlos con el comando mailq. Sendmail corre como demonio servidor y está ejecutándose continuamente tratando de enviar correo cada cierto tiempo. Para evitar esto, hay que editar el archivo de script de inicio /etc/rc.d/rc.M y buscar el texto correspondiente al arranque de sendmail
   </para>
   <programlisting>
# Start the sendmail daemon: 
if [ -x /usr/sbin/sendmail ]; then 
echo "Starting sendmail daemon (/usr/sbin/sendmail -bd -q15m)..." 
/usr/sbin/sendmail -bd -q15m 
fi
   </programlisting>
   <para>
    que nos indica que sendmail trata de enviar correo cada 15 minutos, y cambiarlo por
   </para>
   <programlisting>
# Start the sendmail daemon: 
if [ -x /usr/sbin/sendmail ]; then 
echo "Starting sendmail daemon (sending mail manually)..." 
/usr/sbin/sendmail -bd -oDeliveryMode=d
fi
   </programlisting>
   <para>
    De este modo, el demonio no envía el correo hasta que nosotros lo hagamos manualmente con sendmail -q. 
   </para>
   <para>
    Dentro del fichero /etc/mail/sendmail.cf deberíamos buscar una serie de controles de tiempo como los siguientes
   </para>
   <programlisting>
#o Timeout.fileopen=60s 
#o Timeout.control=2m 
o Timeout.queuereturn=5d 
#o Timeout.queuereturn.normal=5d 
#o Timeout.queuereturn.urgent=2d 
#o Timeout.queuereturn.non-urgent=7d 
o Timeout.queuewarn=4h 
#o Timeout.queuewarn.normal=4h 
#o Timeout.queuewarn.urgent=1h
   </programlisting>
   <para>
    Solamente nos interesan los textos descomentados. El primero se refiere a que si el correo no ha podido ser enviado en 5 días, se devuelva a sendmail. Esta opción es inmaterial para nosotros, pues los mensajes están en nuestro disco duro hasta que se envíen. Pero el segundo texto descomentado nos dice que recibiremos un aviso cada vez que un mensaje lleve más de 4 horas en cola sin ser enviado. Si nuestra conexión es intermitente, esto puede ser una lata. Así que debemos cambiarlo a 48h:
   </para>
   <programlisting>
o Timeout.queuewarn=48h 
   </programlisting>
   </sect2>
   <sect2>
    <title>
    Fetchmail
   </title>
   <para>
    La mejor manera de traer correo a nuestra máquina es dejarlo en nuestro buzón. De este modo el correo será accesible para cualquier cliente de correo (MUA). El programa fetchmail puede gestionar varias cuentas de correo remotas (POP o IMAP) y trae todo el correo a nuestra máquina. Fetchmail es el demonio servidor encargado de la recogida de correo, para posteriormente enviarlo a sendmail, que tiene incluído a procmail como MDA o pasarlo directamente a procmail, del que ya hablaremos. Fetchmail se encuentra ya instalado en Slackware 'current' a no ser que especialmente lo hayais deseleccionado en el setup. Como dice Santiago, la manera más simple de configurar el fetchmail para recoger correo es como root, creando un fichero .fetchmailrc en el directorio /root, de modo que el root recoge el correo y luego se lo pasa a los usuarios para que lo lean. El formato del fichero es el siguiente
   </para>
   <programlisting>
defaults
fetchall
pass8bits


poll servidor_de_correo_POP
proto pop3
user usuario
pass password
to usuario_local
   </programlisting>
   <para>
    Las primeras tres líneas son comunes al comienzo del fichero. Por cada ususario de la máquina que quiera recibir correo se agregarán las otras cinco líneas con sus correspondientes datos. Para el caso del usuario &ldquo;cervantes&rdquo;, tendríamos:
   </para>
   <programlisting>
defaults
fetchall
pass8bits


poll pop3.proveedor.com
proto pop3
user cervantes
pass qu1j0t3
to cervantes
   </programlisting>
   <para>
    Una vez creado el fichero con vi por ejemplo (como root), tenemos que darle los permisos adecuados:
   </para>
   <programlisting>
chmod 0600 .fetchmailrc
   </programlisting>
   <para>
    Para recoger el correo, basta con hacer como root
   </para>
   <programlisting>
fetchmail -v
   </programlisting>
   <para>
    Lo de -v es para que nos cuente lo que está haciendo ;-)
   </para>
   </sect2>
   <sect2>
    <title>
    Procmail
   </title>
   <para>
    Como indica Oskar Parra en su artículo &ldquo;Procesamiento del correo electrónico&rdquo; (Solo Programadores Linux, año II nº 7, pág 42-47), existen muchos motivos para procesar el correo entrante de nuestra máquina. De este modo, podemos guardar ciertos mensajes en determinadas carpetas según el tema o procedencia, especialmente cuando uno está suscrito a distintas listas de correo, filtrar el spam hacia /dev/null, etc. Para realizar estas tareas podemos usar como MDA a procmail. La mayor parte de las distribuciones lo incluyen como paquete, y en el caso de Slackware, ya se encuentra incluido en el fichero de configuración de sendmail como distribuidor de correo. Para comprobarlo basta con hacer:
   </para>
   <programlisting>
$ cat /etc/mail/sendmail.cf | grep "procmail" 
##### $Id: guia-slackware.sgml,v 1.1.1.1 2001/03/27 19:45:50 olea Exp $ ##### 
Mlocal, P=/usr/bin/procmail, F=lsDFMAw5:/|@qSPfhn9, S=EnvFromL/HdrFromL, 
R=EnvToL/HdrToL, 
A=procmail -Y -a $h -d $u
   </programlisting>
   <para>
    Como vemos, procmail se encuentra ya integrado en sendmail y entonces la configuración es muy sencilla, basándose en el fichero de configuración .procmailrc. Cuando fetchmail trae el correo entrante, lo pasa a sendmail para que este lo gestione. Entonces, sendmail invoca a procmail para que lea los mensajes de correo desde la entrada estándar. Luego, consulta el fichero .procmailrc del directorio home del usuario en cuestión para el que fetchmail bajó el correo, examina las reglas contenidas en él y las aplica, decidiendo el destino de los mensajes. Es posible que en lugar de pasar de fetchmail a sendmail y éste invocar a procmail, se produzca la cesión directa de fetchmail a procmail. Esto se consigue indicando al final de las líneas de usuario del fichero .fetchmailrc, la línea
   </para>
   <programlisting>
mda &ldquo;/usr/bin/procmail -d %s&rdquo;
   </programlisting>
   <para>
    Mediante el fichero .procmailrc indicaremos todas las acciones de filtrado y las acciones que queremos hacer con nuestros mensajes. Como explica Santiago Romero (ver en su web los artículos sobre correo electrónico), las reglas suelen ser de comprobación y búsqueda de cadenas de texto en el FROM (dirección de origen), SUBJECT (tema del mensaje), BODY (cuerpo del mensaje), etc. El fichero .procmail consta de dos secciones: En la primera se establecen una serie de variables y en el segundo, se definen las reglas de procesamiento y filtrado. 
   </para>
   <para>
    Las variables usuales en el primer bloque son
   </para>
   <itemizedlist>
    <listitem>
    <para>
    MAILDIR indica a procmail donde ha de almacenar los mensajes. Ha de coincidir con el fichero donde busque nuestro lector de correo. Así, si en nuestro lector de correo, por ejemplo mutt, hemos elegido &ldquo;set spoolfile='/var/spool/mail' &ldquo;, entonces MAILDIR=/var/spool/mail
    </para>
   </listitem>
    <listitem>
    <para>
    LOGFILE indica el fichero donde se guardarán los mensajes de error y advertencias, p. ej., LOGFILE=&dollar;MAILDIR/log
    </para>
   </listitem>
    <listitem>
    <para>
    SHELL señala el tipo de shell usado en la posible ejecución de comandos, p. ej., SHELL=/bin/sh
    </para>
   </listitem>
    <listitem>
    <para>
    SENDMAIL muestra donde se encuentra sendmail y sirve cuando hay que re-enviar un mensaje a otra dirección de correo. SENDMAIL=/usr/sbin/sendmail
    </para>
   </listitem>
    <listitem>
    <para>
    DEFAULT indica el fichero donde irá a parar el mensaje que está siendo procesado si no sigue ninguna de las reglas establecidas en el segundo bloque de .procmailrc. Generalmente suele ser DEFAULT=&dollar;MAILDIR/&lt;usuario&gt;
    </para>
   </listitem>
   </itemizedlist>
   <para>
    Hay más variables (FORMAIL, INCLUDERC...) pero esto es solamente una somera introducción. Vamos al segundo bloque de .procmailrc, donde se establecen las reglas de procesamiento. La sintaxis general de una regla es:
   </para>
   <programlisting>
:0 [opciones] [:]
* condición 1
* condición 2
...
* condición n
acción (comando a ejecutar)
   </programlisting>
   <para>
    Veamos algunos ejemplos:
   </para>
   <para>
    Para guardar en el archivo slack todos los mensajes en los que en el asunto aparezca la palabra &ldquo;slackware&rdquo;
   </para>
   <programlisting>
:0:
* \^{ }Subject:.*slackware
slack
   </programlisting>
   <para>
    Para eliminar los mensajes que vengan de la dirección hahaha@sexyfun.com
   </para>
   <programlisting>
:0:
* \^{ }From.*hahaha@sexyfun\.com
/dev/null
   </programlisting>
   <para>
    Nota: En el lenguaje de procmail, el punto (.) es un símbolo comodín y para que se lea como tal ha de ponerse delante la barra invertida (&bsol;).
   </para>
   <para>
    Para filtrar mensajes que provienen de una lista de correo, p. ej., hackindex@eListas.net y eliminar los mensajes de un remitente llamado &ldquo;Lecter&rdquo; ;-), es necesario concatenar las reglas:
   </para>
   <para>
    :0
   </para>
   <para>
    * \^{ }Sender: hackindex@eListas.net
   </para>
   <para>
    &lcub;
   </para>
   <para>
         :0
   </para>
   <para>
         * \^{ }From: Lecter@baltimore.gov
   </para>
   <para>
         /dev/null
   </para>
   <para>
         :0 B
   </para>
   <para>
         * (Lecter wrote)|(Lecter escribió)
   </para>
   <para>
         /dev/null
   </para>
   <para>
         :0
   </para>
   <para>
         hackindex-lista
   </para>
   <para>
    &rcub;
   </para>
   <para>
    En este caso, los mensajes que procedan de la dirección Lecter@baltimore.gov, se eliminan. Pero también aquellos que se hayan respondido a un mensaje de Lecter se eliminarán: Los que comienzan con &ldquo;Lecter wrote&rdquo; o &ldquo;Lecter escribió&rdquo; en el cuerpo (opción B de body) del mensaje. Los otros mensajes se guardan en el archivo hackindex-listas.
   </para>
   <para>
    Quien desee profundizar más en procmail, puede leer el artículo de Santiago Romero o buscar en la web <ulink url="http://www.procmail.org"></ulink>
   </para>
   </sect2>
   <sect2>
    <title>
    Servidores de news
   </title>
   <para>
    En Slackware 'current' el servidor de news que se instala por defecto (si no lo habeis deseleccionado) es inn-2.3.0, cuya documentación se puede leer (como la de todos los paquetes instalados) en /usr/doc/inn-2.3.0/, pero para los asíduos a leafnode, pueden desinstalar inn con pkgtool e instalarse luego la última vesión de leafnode. Pero recordad: Leafnode es solamente un proxy-caché de news, no un servidor de news en su completa acpción.
   </para>
   </sect2>
   <sect2>
    <title>
    Los clientes de correo y noticias
   </title>
   <para>
    Yo no tengo preferencias: los amo a todos. Mutt (correo) y Slrn (noticias) son los clientes de lectura que abrazan una gran cantidad de linuxeros, pero emacs/gnus no va a la zaga : ) (mirad en ecol instalacion o misc). Para documentaros en mutt/slrn visitad de nuevo la web de Santiago Romero. Para documentaros en emacs/gnus mirad un poco en <ulink url="http://www.userlocal.com/helpwithemacs.shtml"></ulink> y pillad el fichero de configuración para emacs y gnus de Lord Arenaza <ulink url="http://personales.jet.es/inaki.arenaza/"></ulink> o consultad <ulink url="http://sandmill.org/emacs.html"></ulink>. Por cierto, tengo que decir que el emacs que viene (emacs21) es una maravilla aún mayor: mirad en <ulink url="http://sandmill.org/graphics/emacs21/"></ulink> las instantáneas. El código para Slackware y Debian está en : <ulink url="http://people.debian.org/~kitame/emacs21/"></ulink>. 
   </para>
   </sect2>
  </sect1>
  <sect1>
   <title>
   Gestores de ventana y Escritorios
  </title>
  <para>
   Aquí, como de costumbre &ldquo;Aleluya, cada uno con la suya&rdquo;. Al que le guste uno en especial, que lo instale. GNOME (Escritorio)+Enlightenment (gestor) es una virguerida española, pero consume un montón. KDE2 es otra delicia, especialmente con Konqueror, pero no le va a la zaga en cuanto a consumir recursos. Yo uso WindowMaker y me va de perlas. 
  </para>
  </sect1>
  <sect1>
   <title>
   Editores y Entornos de desarrollo. 
  </title>
  <para>
   Existen multitud de editores, pero yo me quedo con aquellos dos que más solera tienen en el mundo unix: vi (vim, elvis,...) y emacs (20). Verdaderas torturas para los neófitos,  llegan a hacerse excelentes herramientas para las cuestiones fundamentales de la edición. Vi es más ligero y menos complejo que emacs, pero como ya he dicho emacs es en esencia un entorno de trabajo y desarrollo: podemos usarlo como editor de sgml/xml, como IDE para diversos lenguajes, incluyendo emacs-lisp, etc..Con estos editores podemos escribir documentos en LaTeX, xml, sgml...
  </para>
  <para>
   Disponemos de algunos front-ends como LyX que es un editor WYSIWYM (Lo que ves es lo que significa) fundamentalmente para LateX y SGML. Exporta ficheros .tex que tratados luego adecuadamente y procesados con pdflatex genera documentación en formato pdf. Los ficheros .sgml pueden convertirse en LateX, postscript, html...
  </para>
  <para>
   Aparte de emacs y joe existen otros entornos integrados de desarrollo (IDE) como gide o xwpe, que tiene apoyo (¡no digáis &ldquo;soporte&rdquo;!) para varios lenguajes y procesadores. E incluso herramientas RAD (Rapid Application Development) que son constructores visuales de GUIs (Graphical User Interfaces) como glade o visual-tcl. Glade puede generar código C, C++, ADA 95 y Perl. Esto solo son los entremeses. 
  </para>
  </sect1>
  <sect1>
   <title>
   Suites ofimáticas
  </title>
  <para>
   A la espera de la futura suite desarrollada por el proyecto GNOME (y fundamentalmente por Helix-Gnome), tenemos Abiword, un procesador de texto en la línea de Word. Todavía tiene muchas carencias, pero es un buen comienzo para el software Libre. En cuanto al escritorio KDE2, Koffice es una gran apuesta. La buena noticia ha sido que Sun liberó OpenOffice (Antes StarOffice) con licencia GPL: <ulink url="http://www.openoffice.org"></ulink> y también algunos podrán disfrutar de esta excelente Suite...pero todavía está en fase &ldquo;experimental&rdquo;. Mientras tanto es posible instalar StarOffice 5.2, que aunque se trata de software &ldquo;patentado&rdquo; es una maravilla y casi completamente compatible con M&dollar; Office.
  </para>
  </sect1>
  <sect1>
   <title>
   Visualizadores y procesadores de imágenes
  </title>
  <para>
   Para leer los archivos postscript necesitáis gv (una mejora de ghostview) que seguramente ya estará instalado. Para los ficheros pdf, debéis instalar el programa acroread (Adobe Acrobat Reader), y para el procesamiento de imágenes el excelente GIMP.
  </para>
  </sect1>
  <sect1>
   <title>
   ServidoresWeb y FTP
  </title>
  <para>
   Si disponéis de una conexión directa (universidad, empresa) a la red podéis utilizar el servidor Apache para empezar. Es conveniente instalar php como módulo y PosgreSQL para gestionar vuestras bases de datos. Para la elaboración de la documentación web podéis instalar el magnífico programa bluefish.
  </para>
  <para>
   Si queréis disponer de un servidor FTP, instalad el wu-ftp y configuradlo adecuadamente. 
  </para>
  </sect1>
  <sect1>
   <title>
   Seguridad
  </title>
  <para>
   Cuando uno se conecta a internet en casa con una conexión INTERMITENTE (módem vía PPP) con asignación dinámica de IP no es necesario llevar a cabo mucha labor de seguridad. Lo que debemos hacer es deshabilitar todo servicio que con seguridad no vayamos a dar. Por un lado eliminar los servicios de arranque directo que se inician al arrancar el sistema excepto quizá sendmail (no los usareis jamás con conexión intermitente) y por otro los de arranque bajo demanda en /etc/inet.conf (quitadlos todos, menos auth si disfrutáis con el IRC). Si tenéis una conexión permanente y un número fijo de IP de máquina, entonces estáis en la red y tendréis que hacer un balance entre los servicios que pretendéis proporcionar y la seguridad que deseáis. Los servicios proporcionados en el arranque debéis asociarlos con reglas de cortafuegos (tipo filtrado de paquetes con ipchains) y los de demanda los gestionareis con tcp-wrapper (poniendo cuidado en los ficheros /etc/hosts.allow y /etc/hosts.deny). Pero esto es otra historia que merece una atención especial que no puedo dar aquí. Para ver los servicios que ofrece vuestra máquina podéis hacer
  </para>
  <programlisting>
>netstat -atu | grep '*:*' | more
  </programlisting>
  <para>
   y así os haréis una idea de ello
  </para>
  </sect1>
 </chapter>
 <chapter>
  <title>
  Grabando CDs con grabadoras IDE
 </title>
 <para>
  Si tenemos una grabadora de CD IDE/ATAPI los programas para grabar como cdrecord no la reconocerán como unidad normal de cdrom, pues sólo reconocen las grabadoras tipo SCSI. Por lo tanto hemos de llevar a cabo una emulación IDE-SCSI en nuestra grabadora. Antaño, para conseguir nuestro objetivo había que recompilar el kernel del siguiente modo:
 </para>
 <orderedlist>
  <listitem>
  <para>
  Quitar el soporte para IDE-ATAPI CDROM (Block devices)
  </para>
 </listitem>
  <listitem>
  <para>
  Activar la emulación SCSI (Block devices)
  </para>
 </listitem>
  <listitem>
  <para>
  Incluir SCSI support, generic support y CDROM support (SCSI support) 
  </para>
 </listitem>
  <listitem>
  <para>
  Activar Loopback device support (Block devices)
  </para>
 </listitem>
  <listitem>
  <para>
  Si se tiene pensado hacer imágenes Joliet, habrá que dar apoyo a Microsoft Joliet CDROM extension (Filesystems) y dentro del submenú Native language support, activar Codepage 437, Codepage 850 y NLS ISO 8859-1
  </para>
 </listitem>
 </orderedlist>
 <para>
  Pero después de la instalación con el Cd Oficial, nuestra Slackware está preparada para realizar la emulación sin necesidad de recompilar el núcleo habida cuenta de la modularidad del mismo, con apoyo para tal emulación mediante la carga del módulo ide-scsi, pero antes hay que especificar en el arranque del sistema, para qué interfaz IDE se debe cargar posteriormente la emulación SCSI. Para ello, debemos pasar a LILO una línea con tal información. La manera más sencilla es incluir en el fichero /etc/lilo.conf una línea después de las especificaciones de la imagen del núcleo a cargar que sea:
 </para>
 <programlisting>
append=&rdquo;unidad IDE=ide-scsi&rdquo;
 </programlisting>
 <para>
  En mi caso dispongo de un lector CDROM en /dev/hdd (esclavo del segundo canal IDE) y una grabadora CDROM en /dev/hdb (esclava del primer canal IDE), con lo cual el archivo /etc/lilo.conf adecuado para la emulación será:
 </para>
 <programlisting>
# LILO configuration file 
# generated by 'liloconfig' 
# 
# Start LILO global section 
lba32 
# Allow booting past 1024th cylinder with a recent BIOS 
boot = /dev/hda4 
# Normal VGA console 
vga = normal 
# Linux bootable partition config begins 
image = /vmlinuz 
root = /dev/hda4 
label = Linux 
read-only 







 append="hdb=ide-scsi"
# Linux bootable partition config ends
 </programlisting>
 <para>
  Una vez re-escrito el fichero /etc/lilo.conf hay que hacer /sbin/lilo -v para que se lleven a cabo los acmbios. Una vez arrancado el kernel con esta opción pasada en el arranque deberán cargarse al inicio los módulos adecuados. Para ello hemos de ir al fichero /etc/rc.d/rc.modules y descomentar:
 </para>
 <programlisting>
# SCSI kernel support: 
/sbin/modprobe scsi_mod 
#/sbin/modprobe scsi_syms 
#/sbin/modprobe sd_mod 
/sbin/modprobe sg 
/sbin/modprobe sr_mod 
#/sbin/modprobe st
...
...
# SCSI emulation support. This will provide SCSI host adapter emulation 
# for IDE ATAPI devices, and will allow you to use a SCSI device driver 
# instead of a native ATAPI driver. This is useful if you have an ATAPI 
# device for which no native driver has been written (for example, an ATAPI 
# PD-CD or CDR drive); you can then use this emulation together with an 
# appropriate SCSI device driver. Note that this option does NOT allow you 
# to attach SCSI devices to a box that doesn't have a SCSI host adapter 
# installed: 
/sbin/modprobe ide-scsi
 </programlisting>
 <para>
  Después del arranque se crean una serie de dispositivos &ldquo;virtuales&rdquo; para usar la grabadora como lector de CDROM: Si hacemos ls /dev/sr* vemos que se han creado desde /dev/sr0 hasta /dev/sr15. También los dispositivos genéricos SCSI /dev/sg* desde /dev/sg0 a /dev/sg15 que son los que utiliza el programa cdrecord y también aparecerán los ficheros especiales /dev/loop* desde /dev/loop0 a /dev/loop7. De este modo podemos montar imágenes para revisarlas en un directorio (p.ej.) /mnt/imagenesCD:
 </para>
 <programlisting>
mount -o loop -t iso9660 imagenCD.iso /mnt/imagenCD
 </programlisting>
 <para>
  Podemos comprobar que nuestra grabadora está reconocida como SCSI viendo el resultado de cat /proc/scsi/scsi
 </para>
 <para>
   
 </para>
 <para>
  NOTA: Cuando tengamos una grabadora HP 7100 ó superior, hay que editar el archivo 
 </para>
 <para>
  /usr/src/kernel-sources-XXX/drivers/block/ide.h 
 </para>
 <para>
  y buscar la línea
 </para>
 <programlisting>
#define WAIT_CMD 
 
 
(10*HZ) 
/* 10 sec 
 - maximum wait for an IRQ to happen 
 */
 </programlisting>
 <para>
  para cambiarla por 
 </para>
 <programlisting>
#define WAIT_CMD 
 
 
(1000*HZ) 
/* 1000 sec 
 - maximum wait for an IRQ to happen 
 */
 </programlisting>
 <para>
  y de este modo funcionará.
 </para>
 <para>
   
 </para>
  <sect1>
   <title>
   Configurando Xcdroast-0.98alpha8
  </title>
  <para>
   Los programas fundamentales que permiten la grabación de imágenes en CDs o CD-CD son: mkisofs (permite hacer imágenes de CD en iso9660 raw) y cdrecord (para efectuar la grabación de CD), pero no vamos a considerar los procedimientos para realización de imágenes y grabación porque para los principiantes existe un programa llamado xcdroast que es una interfaz gráfica de esos dos programas y otros más y que permite de manera excelente la grabación de cds. Xcdroast de Thomas Niederreiter una de las interfaces gráficas más útil para la grabación de CDs. Antes (Slackware 7.0) podíamos instalar la versión 0.98 que estaba escrita con el lenguaje visual tcl/tk, pero en los tiempos que corren, tenemos a X-CD-Roast 0.98alpha8, reescrita con gtk+ y que es una maravilla. Para conseguirla, visitad la página <ulink url="http://www.xcdroast.org"></ulink> y bajaros los paquetes xcdroast-0.98alpha8.tar.gz y cdrecord-1.9.tar.gz. Antes que nada eliminad con pkgtool o removepkg el paquete cdutils:
  </para>
  <programlisting>
#>removepkg cdutils
  </programlisting>
  <para>
   con esto eliminamos la versión de cdrecord 1.8 que no es usable por xcdroast. Luego copiaremos los dos tarballs en /usr/local y los descomprimiremos, dando lugar a los directorios /usr/local/xcdroast-0.98alpha8 y /usr/local/cdrecord-1.9. Leed bien los correspondientes README y README.linux y cuidadín porque aparentemente puede ser lioso. Os lo resumo: En el entorno X-window, arrancado como usuario normal abrid una xterm. Entonces, pasaros a superusuario (root) y
  </para>
  <para>
   1. Id al directorio de cdrecord-1.9 y haced 
  </para>
  <programlisting>
cp Gmake.linux /usr/bin/Gmake
/usr/bin/Gmake
  </programlisting>
  <para>
   Cuando todo haya terminado, 
  </para>
  <para>
   2. Id al directorio de xcdroast-0.98 y haced
  </para>
  <programlisting>
make
  </programlisting>
  <para>
   después,
  </para>
  <para>
   3. Volved al directorio de cdrecord-1.9 y haced allí
  </para>
  <programlisting>
make
  </programlisting>
  <para>
   y a continuación según indica el fichero README, haced
  </para>
  <programlisting>
cp cdrecord/OBS/i686-linux-cc/cdrecord /usr/local/bin
cp cdda2wav/OBJ/i686-linux-cc/cdda2wav /usr/local/bin
cp mkisofs/OBJ/i686-linux-cc/mkisofs /usr/local/bin
cp misc/OBJ/i686-linux-cc/readcd /usr/local/bin
  </programlisting>
  <para>
   Sin embargo yo he comprobado después que el programa xcdroast buscaba a cdrecord en /usr/bin y no en /usr/local/bin por lo que os sugiero que ADEMÁS DE HABER COPIADO LOS FICHEROS ANTERIORES EN /usr/local/bin LOS COPIEIS TAMBIÉN EN /usr/bin Y ASÍ TODO IRÁ BIEN.
  </para>
  <para>
   4. Regresad ahora al directorio de xcdroast-0.98 y haced entonces
  </para>
  <programlisting>
make install
  </programlisting>
  <para>
   con lo que se instalará el programa xcdrgtk, que habrá que darle los permisos:
  </para>
  <programlisting>
chmod 2755 xcdrgtk
  </programlisting>
  <para>
   Por fín podemos hacer 
  </para>
  <programlisting>
xcdroast &
  </programlisting>
  <para>
   Y nos aparecerá un mensaje diciendo que las advertencias acerca de incorrecciones en los permisos del programa y bits setuid pueden ignorarse siempre que ejecutemos xcdrgtk como root : ) y de pronto surge una ventana indicándonos que no hay fichero de configuración para el root y empezamos a configurar. Hacemos OK y aparece el frontispicio llameante de xcdroast ;-). Aceptamos el disclaimer y accionamos el botón de setup. Aparece entonces el panel de setup con varias pestañas: Buscar dispositivos, Configuración CD, Configuración Disco Duro, Miscelánea, Opciones y Users. Los bloques de Buscar dispositivo, Opciones y Users, mejor dejarlas como están y no tocarlas.
  </para>
  <para>
   Configuración CD: Hay que configurar los dispositivos de lectura y escritura, que en nuestro caso, tal como hemos realizado la simulación SCSI, corresponderán al mismo elemento: la grabadora de CD. En mi caso tengo una antigua Memorex CRW-1622 que funciona de maravilla. Por lo tanto, en el bloque Configuración grabadora seleccionamos: 
  </para>
  <itemizedlist>
   <listitem>
   <para>
   DispositivoGrabación: Memorex CRW-1622
   </para>
  </listitem>
   <listitem>
   <para>
   MododeGrabación: Autodetected
   </para>
  </listitem>
   <listitem>
   <para>
   Velocidad de Grabación: 2x
   </para>
  </listitem>
   <listitem>
   <para>
   Tamaño del buffer FIFO ... : 4.0 MB
   </para>
  </listitem>
  </itemizedlist>
  <para>
   y en el bloque del Lector, escogemos:
  </para>
  <itemizedlist>
   <listitem>
   <para>
   Dispositivo primario de lectura: Memorex CDW-1622
   </para>
  </listitem>
   <listitem>
   <para>
   Dispositivo secundario de lectura: Memorex CDW-1622
   </para>
  </listitem>
   <listitem>
   <para>
   Velocidad lectura audio: 6x
   </para>
  </listitem>
  </itemizedlist>
  <para>
   y el resto lo dejamos tal cual.
  </para>
  <para>
    
  </para>
  <para>
   Configuración Disco Duro: Vamos abajo del panel, seleccionamos &ldquo;Visualizar&rdquo; y escogemos el directorio que queramos para guardar las imágenes (p. ej. /tmp). Luego damos a &ldquo;Añadir&rdquo; y aparecerá en la ventana grande superior con el correspondiente espacio libre. NOTA: Debéis tener al menos unos 650 MB libres para almacenar la imagen. 
  </para>
  <para>
   Miscelánea: Dejar las opciones por defecto excepto DPS-Device for audio, que seleccionaremos a /dev/dsp
  </para>
  <para>
    
  </para>
  <para>
   Por último accionamos el botón guardar configuración y luego hacemos OK, con lo cual volvemos al panel de presentación pero ahora tiene activos los botones DUPLICAR CD y CREAR CD.
  </para>
  <para>
   Los menús correspondientes son muy intuitivos y permiten copiar y elaborar CDs de manera excelente.
  </para>
  </sect1>
 </chapter>
 <chapter>
  <title>
  Direcciones slackeras
 </title>
 <para>
  Para los slackers no hay tanto como deseáramos en la red, pero &ldquo;siempre nos quedará París&rdquo; ;-). Existen unas cuantas direcciones que nos pueden venir bastante bien: 
 </para>
 <orderedlist>
  <listitem>
  <para>
  The Slack FAQ <ulink url="http://www.sirius.com/~oryx/linux/aols-faq.shtml"></ulink> contínuamente actualizada.
  </para>
 </listitem>
  <listitem>
  <para>
  El grupo de news: alt.os.linux.slackware
  </para>
 </listitem>
  <listitem>
  <para>
  La página oficial de Slackware <ulink url="http://www.slackware.com"></ulink>, &ldquo;The Slackware Project&rdquo;. Fundamental.
  </para>
 </listitem>
  <listitem>
  <para>
  La página de Linuxmafia <ulink url="http://www.linuxmafia.org"></ulink>, con cantidad de información y con el almacén de paquetes .tgz (Central Slackware packages) para que os descargueis los que os interesen.
  </para>
 </listitem>
  <listitem>
  <para>
  Para grabar imágenes &ldquo;iso&rdquo; de las distros estables (como la 7.1 en la actualidad): <ulink url="ftp://ftp.freesoftware.com/pub/linux/slackware-7.1/iso/"></ulink>
  </para>
 </listitem>
  <listitem>
  <para>
  Una página llena de noticias, trucos e información para los slackers: <ulink url="http://www.userlocal.com"></ulink>
  </para>
 </listitem>
  <listitem>
  <para>
  Una lista de correo ha surgido de es.comp.os.linux.instalacion: Esteban (un &ldquo;habitual de ecomposlinux.org&rdquo;) la modera. Cualquier mensaje a scandisk@wanadoo.es con el subject &ldquo;slack&rdquo; se procesa para la lista.
  </para>
 </listitem>
 </orderedlist>
 <para>
  Espero que esto haya servido para facilitar la entrada a los nuevos usuarios a esta magnífica distribución.
 </para>
 <para>
  Un saludo a todos
 </para>
 <para>
  Gustavo Gonzalez aka Lecter
 </para>
 </chapter>


</book>
