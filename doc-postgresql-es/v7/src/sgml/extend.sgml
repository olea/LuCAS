 <chapter id="extend">
  <title>Extendiendo <acronym>SQL</acronym>: Preludio</title>

  <para>
   En la sección que sigue, trataremos cómo extender el lenguaje
   <acronym>SQL</acronym> de <productname>Postgres</productname> 
   añadiendo:

   <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>
      funciones
     </para>
    </listitem>
    <listitem>
     <para>
      tipos
     </para>
    </listitem>
    <listitem>
     <para>
      operadores
     </para>
    </listitem>
    <listitem>
     <para>
      añadidos
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <sect1 id="extend-how">
   <title>Cómo funciona la extensibilidad</title>

   <para>
    <productname>Postgres</productname> es extensible porque opera sobre 
    catálogos. Si está familiarizado con los estándares de sistemas
    relacionales, sabe que la informacion de bases de datos,
    tablas, columnas, etc., se almacena en lo que comunmente se conoce 
    como sistema de catálogos. (Algunos sistemas lo llaman diccionario de 
    datos). Los catálogos aparecen al usuario como tablas, iguales a 
    cualquier otra, pero <acronym>DBMS</acronym> almacena información
    interna en ellos.
    Una diferencia clave entre <productname>Postgres</productname>
    y el estándar de sistemas relacionales es que 
    <productname>Postgres</productname>
    almacena mucha mas información en su catálogos, no solo información de 
    tablas y columnas, sino tambien información sobre sus tipos, 
    funciones, métodos de acceso y demás.
    Estas tablas pueden ser modificadas por el usuario, y dado que 
    <productname>Postgres</productname> basa la operación interna en estas 
    tablas, esto significa que <productname>Postgres</productname> puede ser 
    extendido por los usuarios. 
    Por comparación, los sistemas de base de datos convencionales sólo
    pueden ser extendidos cambiando los procedimientos codificados del 
    <acronym>DBMS</acronym> o cargando módulos especialmente escritos por el 
    vendedor del <acronym>DBMS</acronym>.  
   </para>
   
   <para>
    <productname>Postgres</productname> es tambien distinto de otros 
    gestores de datos en que el servidor puede incorporar código escrito por el 
    usuario a través de bibliotecas de carga dinámica. 
    O sea, el usuario puede especificar un fichero de codigo objeto 
    (p. ej., un fichero compilado .o o bibliotecas compartidas) que 
    implemente un nuevo tipo o función y <productname>Postgres</productname> 
    lo cargará cuando se requiera. El código escrito en <acronym>SQL</acronym> 
    es incluso más fácil de añadir al servidor.
    Esta habilidad para modificar la operacion 'al vuelo' hace a
    <productname>Postgres</productname> único para prototipos rapidos de 
    nuevas aplicaciones y estructuras de almacenamiento.    
   </para>
  </sect1>

  <sect1 id="type-system">
   <title>El Sistema de Tipos de <productname>Postgres</productname></title>

   <para>
    El sistema de tipos de <productname>Postgres</productname>
    puede ser analizado de varias formas:
    Los tipos estan divididos en tipos base y tipos compuestos.
    Los tipos base son aquellos, como <firstterm>int4</firstterm>, que 
    están implementados en lenguajes como <productname>C</productname>.  
    Generalmente se corresponden a lo comunmente conocido como 
    "tipos de datos abstractos"; <productname>Postgres</productname>    
    sólo puede operar con estos tipos a través de métodos provistos por el 
    usuario y solo entiende el comportamiento de los tipos en el ámbito
    descrito por el usuario. 
    Los tipos compuestos son los creados cuando el usuario crea una tabla.
    EMP es un ejemplo de un tipo compuesto.
   </para>

   <para>
   <productname>Postgres</productname> almacena estos tipos
    de una única forma (dentro del fichero que almacena todas las
    filas de la tabla) pero el usuario puede "mirar dentro"
    de los atributos de estos tipos con el lenguaje de peticiones 
    y optimizar su recuperación, por ejemplo, definiendo índices en los 
    atributos.    
    Los tipos base de <productname>Postgres</productname> se pueden 
    también dividir en tipos internos y tipos definidos por el usuario. 
    Los tipos internos (como <firstterm>int4</firstterm>)
    son los que están compilados dentro del sistema.
    Los tipos definidos por el usuario son creados por el usuario 
    de la manera descrita abajo. 
   </para>
  </sect1>

  <sect1 id="pg-system-catalogs">
   <title>Acerca de los Sistema de Catálogo de
<productname>Postgres</productname></title>

   <para>
    Habiendo presentado los conceptos básicos de la extensibilidad,
    estudiemos ahora como está implantado el sistema de catálogos.
    Puede saltarse esta sección ahora, pero algunas secciones siguientes 
    no serán comprendidas sin la información dada aqui, así que marque 
    esta página para posterior referencia.
    Todos los catálogos de sistema tienen un nombre que empieza por
    <firstterm>pg_</firstterm>.
    Las siguientes tablas contienen información que puede ser útil para
    los usuarios finales. (Hay muchos otros catálogos de sistema, pero 
    raramente encontrará una razón para consultarlos directamente).
    <table tocentry="1">
     <title>Catálogos de sistema de Postgres</title>
     <titleabbrev>Catalogs</titleabbrev>
     <tgroup cols="2">
      <thead>
       <row>
	<entry>Nombre del Catálogo</entry>
	<entry>Descripción</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>pg_database</entry>
	<entry> bases de datos</entry>
       </row>
       <row>
	<entry>pg_class</entry>
	<entry> tablas</entry>
       </row>
       <row>
	<entry>pg_attribute</entry>
	<entry> columnas de las tablas</entry>
       </row>
       <row>
	<entry>pg_index</entry>
	<entry> índices secundarios</entry>
       </row>
       <row>
	<entry>pg_proc</entry>
	<entry> procedimientos (tanto C como SQL)</entry>
       </row>
       <row>
	<entry>pg_type</entry>
	<entry> tipos (tanto los base como los complejos)</entry>
       </row>
       <row>
	<entry>pg_operator</entry>
	<entry> operadores</entry>
       </row>
       <row>
	<entry>pg_aggregate</entry>
	<entry> conjuntos y funciones</entry>
       </row>
       <row>
	<entry>pg_am</entry>
	<entry> métodos de acceso</entry>
       </row>
       <row>
	<entry>pg_amop</entry>
	<entry> operadores de métodos de acceso</entry>
       </row>
       <row>
	<entry>pg_amproc</entry>
	<entry> funciones de soporte de métodos de acceso</entry>
       </row>
       <row>
	<entry>pg_opclass</entry>
	<entry> tablas de operadores de métodos de acceso</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
    <figure float="1" id="EXTEND-CATALOGS">
     <title>El sistema principal de catálogo de 
       <productname>Postgres</productname></title>
     <graphic fileref="catalogs.gif" format="GIF" align="center"></graphic>
    </figure>

    El manual de referencia da explicación más detallada de estas tablas 
    de catálogos y sus columnas. De cualquier manera, 
    <xref endterm="EXTEND-CATALOGS" linkend="EXTEND-CATALOGS">
    muestra las entidades principales y sus relaciones en los catálogos
    del sistema.
    (Las columnas que no se refieren a otras entidades no se muestran a 
    menos que formen parte de una clave primaria).
 	
    Este diagrama puede ser más o menos incomprensible hasta que realmente 
    comience a mirar los contenidos de los catálogos y vea como se 
    relacionan entre si. Por ahora, los elementos principales que se 
    deben extraer de este diagrama son los siguientes:
     
    <itemizedlist spacing="compact" mark="bullet">
     <listitem>
      <para>
       En varias de las secciones que vienen a continuacion, presentaremos 
       varias consultas compuestas en los catalogos del sistema que 
       presentan información que necesitamos para extender el sistema. 
       Mirando este diagrama podremos hacer que algunas de estas consultas 
       compuestas (que a menudo se componen de tres o cuatro partes) sean
       más comprensibles, dado que será capaz de ver que las columnas 
       usadas en las consultas forman claves externas en otras tablas. 
      </para>
     </listitem>
     <listitem>
      <para>
       Muchas características distintas (tablas, atributos, funciones, 
       tipos, métodos de acceso, etc) estan estrechamente integradas en 
       este esquema. Un simple comando de creación puede modificar muchos 
       de estos catalogos.
      </para>
     </listitem>
     <listitem>
      <para>
       Los tipos y procedimientos son elementos fundamentales de este esquema.

       <note>
	<para>
	 Usamos las palabras <firstterm>procedure</firstterm> y 
	 <firstterm>function</firstterm> de forma más o menos indistinta.
	</para>
       </note>
       Prácticamente todo catálogo contiene alguna referencia a filas
       en una o ambas tablas. Por ejemplo, <productname>Postgres</productname>  
       frecuentemente usa firmas de tipo (por ejemplo, de funciones y  
       operadores) para identificar filas únicas en otros catálogos.
      </para>
     </listitem>
     <listitem>
      <para>
       Hay muchas otras columnas y relaciones que tienen un significado 
       obvio, pero hay otras muchas (particularmente aquellas que tienen 
       que ver con métodos de acceso) que no. Las relaciones entre 
       pg_am,   pg_amop,   pg_amproc,  pg_operator  y pg_opclass son 
       particularmente difíciles de comprender, y seran descritas en 
       profundidad (en la sección sobre interrelación de tipos y 
       operadores con índices) después de que estudiemos las 
       extensiones básicas.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
