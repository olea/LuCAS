 <chapter id="datatype">
  <title id="datatype-title">Tipos de Datos</title>

  <abstract>
   <para>
    Describe los tipos de datos incluidos utilizables en
    <productname>Postgres</productname>.
   </para>
  </abstract>

  <para>
   <productname>Postgres</productname> tiene un rico juego de tipos de datos nativos
   disponibles por los usuarios.
   Los usuarios pueden añadir nuevos tipos a <productname>Postgres</productname> utilizando
   el comando <command>DEFINE TYPE</command> descrito en otra parte.
  </para>

  <para>
   En el contexto de los tipos de datos, las siguientes secciones tratarán sobre el
   cumplimiento de los estándares <acronym>SQL</acronym>, los resultados de las migraciones
   y el uso.

   Algunos tipos de <productname>Postgres</productname> corresponden directamente a los
   tipos compatibles con <acronym>SQL92</acronym>. En otros casos, los tipos de datos definidos
   por la sintaxis <acronym>SQL92</acronym> se asignan directamente a tipos nativos de
   <productname>Postgres</productname>.

   Muchos de los tipos de datos incluidos en la base de datos tienen evidentes formatos
   externos. Sin embargo, muchos tipos o bien son únicos de <productname>Postgres</productname>,
   como las rutas abiertas y cerradas, o bien tienen varias posibilidades de formato, como
   los tipos de fechas y horas.
  </para>

  <para>
   <table tocentry="1">
    <title>Tipos de Datos de <productname>Postgres</productname></title>
    <titleabbrev>Tipos de Datos</titleabbrev>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Tipo <productname>Postgres</productname></entry>
       <entry>Tipo <acronym>SQL92</acronym> o <acronym>SQL3</acronym></entry>
       <entry>Descripcion</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>bool</entry>
       <entry>boolean</entry>
       <entry>logica booleana (verdadero/falso)</entry>
      </row>
      <row>
       <entry>box</entry>
       <entry></entry>
       <entry>caja rectangular en un plano de dos dimensiones</entry>
      </row>
      <row>
       <entry>char(n)</entry>
       <entry>character(n)</entry>
       <entry>cadena de caracteres de longitud fija</entry>
      </row>
      <row>
       <entry>cidr</entry>
       <entry></entry>
       <entry>dirección de un ordenador o una red IP version 4</entry>
      </row>
      <row>
       <entry>circle</entry>
       <entry></entry>
       <entry>circulo en un plano de dos dimensiones</entry>
      </row>
      <row>
       <entry>date</entry>
       <entry>date</entry>
       <entry>fecha del calendario sin hora del día</entry>
      </row>
      <row>
       <entry>decimal</entry>
       <entry>decimal(p,s)</entry>
       <entry>numérico exacto para p <= 9, s = 0</entry>
      </row>
      <row>
       <entry>float4/8</entry>
       <entry>float(p)</entry>
       <entry>numérico de punto flotante con precisión p</entry>
      </row>
      <row>
       <entry>float8</entry>
       <entry>real, double precision</entry>
       <entry>numérico de punto flotante de doble precisión</entry>
      </row>
      <row>
       <entry>inet</entry>
       <entry></entry>
       <entry>dirección de un ordenador o una red IP version 4</entry>
      </row>
      <row>
       <entry>int2</entry>
       <entry>smallint</entry>
       <entry>entero con signo de dos bytes</entry>
      </row>
      <row>
       <entry>int4</entry>
       <entry>int, integer</entry>
       <entry>entero con signo de 4 bytes</entry>
      </row>
      <row>
       <entry>int8</entry>
       <entry></entry>
       <entry>entero con signo de 8 bytes</entry>
      </row>
      <row>
       <entry>line</entry>
       <entry></entry>
       <entry>línea infinita en un plano de dos dimensiones</entry>
      </row>
      <row>
       <entry>lseg</entry>
       <entry></entry>
       <entry>segmento de línea en un plano de dos dimensiones</entry>
      </row>
      <row>
       <entry>money</entry>
       <entry>decimal(9,2)</entry>
       <entry>cantidad monetaria con el estilo de US</entry>
      </row>
      <row>
       <entry>numeric</entry>
       <entry>numeric(p,s)</entry>
       <entry>numerico exacto para p == 9, s = 0</entry>
      </row>
      <row>
       <entry>path</entry>
       <entry></entry>
       <entry>ruta geométrica abierta y cerrada en un plano de dos dimensiones</entry>
      </row>
      <row>
       <entry>point</entry>
       <entry></entry>
       <entry>punto geometrico en un plano de dos dimensiones</entry>
      </row>
      <row>
       <entry>polygon</entry>
       <entry></entry>
       <entry>ruta geométrica cerrada en un plano de dos dimensiones</entry>
      </row>
      <row>
       <entry>serial</entry>
       <entry></entry>
       <entry>identificación única para indixar y referencias cruzadas</entry>
      </row>
      <row>
       <entry>time</entry>
       <entry>time</entry>
       <entry>hora del día</entry>
      </row>
      <row>
       <entry>timespan</entry>
       <entry>interval</entry>
       <entry>margen de tiempo de uso general</entry>
      </row>
      <row>
       <entry>timestamp</entry>
       <entry>timestamp with time zone</entry>
       <entry>fecha/hora</entry>
      </row>
      <row>
       <entry>varchar(n)</entry>
       <entry>character varying(n)</entry>
       <entry>cadena de caracteres de longitud variable</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <para>
   <note>
    <para>
     Los tipos <type>cidr</type> y <type>inet</type> están diseñados para manipular
     cualquier tipo IP pero en la implementación actual solo se manipulan IPv4. Todo
     lo que se dice aquí sobre IPv4 se aplicará en una versión futura a IPv6.</para>
   </note></para>

  <para>
   <table tocentry="1">
    <title>Constantes de Función de <productname>Postgres</productname></title>
    <titleabbrev>Constantes</titleabbrev>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Función de <productname>Postgres</productname></entry>
       <entry>Constante de <acronym>SQL92</acronym></entry>
       <entry>Descripción</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>getpgusername()</entry>
       <entry>current_user</entry>
       <entry>nombre del usuario de la sesion actual</entry>
      </row>
      <row>
       <entry>date('now')</entry>
       <entry>current_date</entry>
       <entry>fecha de la transacción actual</entry>
      </row>
      <row>
       <entry>time('now')</entry>
       <entry>current_time</entry>
       <entry>hora de la transacción actual</entry>
      </row>
      <row>
       <entry>timestamp('now')</entry>
       <entry>current_timestamp</entry>
       <entry>fecha y hora de la transacción actual</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <para>
   <productname>Postgres</productname> tiene características del desarrollo más
   avanzado de <acronym>ORDBMS</acronym>. Además del cumplimiento de 
   <acronym>SQL3</acronym>, están también soportadas porciones sustanciales 
   <acronym>SQL92</acronym>. Aunque intentamos cumplir con <acronym>SQL92</acronym>,
   hay algunos aspectos del estandar que están mal considerados y que no deberían
   sobrevivir en los siguientes estándares. <productname>Postgres</productname> 
   no hará grandes esfuerzos por ajustarse a estos estándares. Sin embargo, esta 
   tendencia se aplica en aspectos muy poco usados o muy oscuros, y un usuario típico
   es poco probable que llegue a utilizarlos.</para>

  <para>
   La mayoría de las funciones de entrada y salida que corresponden a los tipos base
   (es decir, numéricos de punto flotante y enteros) realizan algún tipo de control 
   de errores. Algunos de los operadores y funciones (es decir, suma y multiplicación)
   no realizan comprobación de errores en el momento de la ejecución buscando incrementar
   la velocidad de ejecución. En algunos sistemas, por ejemplo, los operadores numéricos
   para algunos tipos de datos pueden subrecargarse o subcargarse silenciosamente.
  </para>

  <para>
   Nótese que algunas de las funciones de entrada y salida no son invertibles. Esto es, 
   el resultado de una función de salida puede perder precisión cuando se compara con
   la entrada origina.

   <note>
    <para>
     El codigo de <productname>Postgres</productname> v4.2 original recibido de Berkeley
     redondeaba todos los resultados de punto flotante de doble precisión a seis dígitos
     en la salida. A partir de la v6.1, se permite a los número de punto flotante 
     conservar la mayoría de la precisión intrínseca del tipo (típicamente 15 dígitos para
     dobles, y 6 dígitos para flotantes de 4 bytes).
     Otros tipos con campos de punto flotante subyacente (es decir, tipos geométricos) 
     soportan similar precisión.</para>
   </note>
  </para>

  <sect1>
   <title>Tipos Numéricos</title>

   <para>
    Los tipos numéricos incluyen enterior de dos y cuatro bytes y numeros de punto flotante
    de cuato y ocho bytes.
   </para>

   <para>
    <table tocentry="1">
     <title>Tipos Numéricos de <productname>Postgres</productname></title>
     <titleabbrev>Numerics</titleabbrev>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Tipo Numérico</entry>
	<entry>Almacenamiento</entry>
	<entry>Descripción</entry>
	<entry>Margen</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>decimal</entry>
	<entry>variable</entry>
	<entry>Precisión especificada por el usuario</entry>
	<entry>Sin límite</entry>
       </row>
       <row>
	<entry>float4</entry>
	<entry>4 bytes</entry>
	<entry>Precisión Variable</entry>
	<entry>6 dígitos decimales</entry>
       </row>
       <row>
	<entry>float8</entry>
	<entry>8 bytes</entry>
	<entry>Precisión variable</entry>
	<entry>15 dígitos decimales</entry>
       </row>
       <row>
	<entry>int2</entry>
	<entry>2 bytes</entry>
	<entry>Precisión fija</entry>
	<entry>-32768 a +32767</entry>
       </row>
       <row>
	<entry>int4</entry>
	<entry>4 bytes</entry>
	<entry>Elección habitual para precisión fija</entry>
	<entry>-2147483648 a +2147483647</entry>
       </row>
       <row>
	<entry>int8</entry>
	<entry>8 bytes</entry>
	<entry>Precisión fija de muy amplio rango</entry>
	<entry>+/- &gt; 18 decimal places</entry>
       </row>
       <row>
	<entry>numeric</entry>
	<entry>variable</entry>
	<entry>Precisión especificada por el usuarioUser-specified precision</entry>
	<entry>sin límite</entry>
       </row>
       <row>
	<entry>serial</entry>
	<entry>4 bytes</entry>
	<entry>Identificador o referencia cruzada</entry>
	<entry>0 to +2147483647</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
    Los tipos numéricos tiene un juego completo de funciones y operadores aritméticos
    correspondientes. Refierase a <xref endterm="math-opers" linkend="math-opers"> y
    <xref endterm="math-funcs" linkend="math-funcs"> para conseguir más información.
   </para>

   <para>
    El tipo <type>int8</type> puede no estar disponible en todas las plataformas, ya que 
    necesita el soporte del compilador para proporcionarlo.
   </para>

   <sect2>
    <title>El Tipo Serial</title>

    <para>
     El tipo <type>serial</type> es un caso especial de tipo construido por 
     <productname>Postgres</productname> a partir de otros componentes existentes.
     Se utiliza típicamente para crear identificadores únicos para entradas de tablas.
     En la implementación actual, especificar

     <programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> 
(<replaceable class="parameter">colname</replaceable> SERIAL);
     </programlisting>

     es equivalente a especificar:

     <programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">tablename</replaceable>
    (<replaceable class="parameter">colname</replaceable> INT4 DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq');
CREATE UNIQUE INDEX <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_key on <replaceable class="parameter">tablename</replaceable> (<replaceable class="parameter">colname</replaceable>);
     </programlisting>

     <caution>
      <para>
       La secuencia (sequence) que se crea implícitamente para el tipo <type>serial</type> 
       <emphasis>no se eliminará</emphasis> automáticamente cuando se elimine la tabla.
      </para>
     </caution>

     Las secuencias implícitas que soportan los tipos <type>serial</type> no se eliminan
     automáticamente cuando se elimina una tabla que contiene un tipo serie. Por ello,
     los siguientes comandos ejecutados en este orden fallarán:

     <programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (<replaceable class="parameter">colname</replaceable> SERIAL);
DROP TABLE <replaceable class="parameter">tablename</replaceable>;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (<replaceable class="parameter">colname</replaceable> SERIAL);
     </programlisting>

     La secuencia se mantendrá en la base de datos hasta que se elimine explicitamente usando
     <command>DROP SEQUENCE</command>.
    </para>
   </sect2>

  </sect1>

  <sect1>
   <title>El Tipo Monetary</title>

   <note>
    <title>Tipo Obsoleto</title>
    <para>
     El tipo <type>money</type> está ahora obsoleto. Utilice <type>numeric</type>
     o <type>decimal</type> en su lugar.
    </para>
   </note>

   <para>
    El tipo <type>money</type> soporta conteo monetario de tipo estadounidense con 
    representación de punto decimal fijo.
    Si <productname>Postgres</productname> se compila con USE_LOCALE,
    el tipo <type>money</type> debería utilizar las convenciones monetrarias definidas en 
    <citetitle>locale(7)</citetitle>.
   </para>

   <para>
    <table tocentry="1">
     <title>Tipoo Monetario de <productname>Postgres</productname></title>
     <titleabbrev>Money</titleabbrev>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Tipo Monetario</entry>
	<entry>Almacenamiento</entry>
	<entry>Descripción</entry>
	<entry>Margen</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>money</entry>
	<entry>4 bytes</entry>
	<entry>Precisión fija</entry>
	<entry>-21474836.48 a +21474836.47</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
    <type>numeric</type> reemplazará al tipo money, y debería preferirse.
   </para>

  </sect1>

  <sect1>
   <title>Tipos de Caracteres</title>

   <para>
    <acronym>SQL92</acronym> define dos tipos de caracteres primarios:
    <type>char</type> and <type>varchar</type>. 
    <productname>Postgres</productname> soporta estos tipos, 
    además del tipo más general <type>text</type>, 
    que contra lo que ocurre con <type>varchar</type>,
    no requiere que se declare un limite superior al tamaño del campo.
   </para>

   <para>
    <table tocentry="1">
     <title>Tipos de Caracteres de <productname>Postgres</productname></title>
     <titleabbrev>Characters</titleabbrev>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Tipo de Caracteres</entry>
	<entry>Almacenamiento</entry>
	<entry>Recomendación</entry>
	<entry>Descripción</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>char</entry>
	<entry>1 byte</entry>
	<entry>compatible con <acronym>SQL92</acronym></entry>
	<entry>caracter único</entry>
       </row>
       <row>
	<entry>char(n)</entry>
	<entry>(4+n) bytes</entry>
	<entry>compatible con <acronym>SQL92</acronym></entry>
	<entry>Rellenado a blancos por la derecha, de longitud fija</entry>
       </row>
       <row>
	<entry>text</entry>
	<entry>(4+x) bytes</entry>
	<entry>La mejor elección</entry>
	<entry>Longitud variable</entry>
       </row>
       <row>
	<entry>varchar(n)</entry>
	<entry>(4+n) bytes</entry>
	<entry>compatible con <acronym>SQL92</acronym></entry>
	<entry>longitud variable con límite</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
    Hay otro tipo de caracteres de longitud fija.
    El tipo <type>name</type> sólo tiene un propósito, que es 
    proporcionar a <productname>Postgres</productname> 
    un tipo especial para utilizar con los nombres internos.
    Su longitud está actualmente definida como 32 caracteres, pero 
    se deberían referir a ella utilizando NAMEDATALEN.
    Este se fija en el momento de la compilación, y puede cambiar en una
    versión futura.
   </para>

   <para>
    <table tocentry="1">
     <title>Tipos de Caracteres Especiales de <productname>Postgres</productname></title>
     <titleabbrev>Specialty Characters</titleabbrev>
     <tgroup cols="3">
      <thead>
       <row>
	<entry>Tipo de Caracteres</entry>
	<entry>Almacenamiento</entry>
	<entry>Descripción</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>name</entry>
	<entry>32 bytes</entry>
	<entry>Tipo de caracteres internos de treinta y dos bytes</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

  </sect1>

  <sect1>
   <title>Tipos para Fechas y Horas</title>

   <para>
    <productname>PostgreSQL</productname> soporta el juego completo de
    tipos de fechas y horas de <acronym>SQL</acronym>.
   </para>

   <para>
    <table tocentry="1">
     <title>Tipos de Fechas y Horas de <productname>PostgreSQL</productname></title>
     <titleabbrev>Date/Time</titleabbrev>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Tipo</entry>
        <entry>Descripción</entry>
	<entry>Almacenamiento</entry>
        <entry>Inicial</entry>
        <entry>Final</entry>
        <entry>Resolución</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>timestamp</type></entry>
        <entry>para datos que contienen tanto la fecha como la hora</entry>
        <entry>8 bytes</entry>
        <entry>4713 A.C.</entry>
        <entry>1465001 D.C.</entry>
        <entry>1 microsegundo / 14 dígitos</entry>
       </row>
       <row>
        <entry><type>interval</type></entry>
        <entry>para intervalos de tiempo</entry>
        <entry>12 bytes</entry>
        <entry>-178000000 años</entry>
        <entry>178000000 años</entry>
        <entry>1 mircosegundo</entry>
       </row>
       <row>
        <entry><type>date</type></entry>
        <entry>para datos que contienen sólo fechas</entry>
        <entry>4 bytes</entry>
        <entry>4713 A.C.</entry>
        <entry>32767 D.C.</entry>
        <entry>1 día</entry>
       </row>
       <row>
        <entry><type>time</type></entry>
        <entry>para datos que contienen sólo horas del día</entry>
        <entry>4 bytes</entry>
        <entry>00:00:00.00</entry>
        <entry>23:59:59.99</entry>
        <entry>1 microsegundo</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <note>
     <para>
      Para asegurar la compatibilidad con versiones previas de 
      <productname>PostgreSQL</productname>, también continuaremos proporcionando
      <type>datetime</type> (equivalente a <type>timestamp</type>) y
      <type>timespan</type> (equivalente a <type>interval</type>). Los tipos 
      <type>abstime</type> y <type>reltime</type> tienen menor precisión que los tipos
      utilizados internamente. Recomendamos encarecidamente que no se utilicen ninguno
      de estos tipos y que se migren las aplicaciones desde los tipos de datos antíguos
      a los apropiados modernos. Cualquiera de todos estos tipos de datos podría desaparecer
      en versiones futuras.
     </para>
    </note>
   </para>


   <sect2>
    <title>Entrada de Fechas y Horas</title>

    <para>
     La entrada de fechas y horas se acepta en casi todos los formatos razonables, incluyendo
     <acronym>ISO</acronym>-compatible, <acronym>SQL</acronym>-compatible, 
     <productname>Postgres</productname> traditional, y otros.
     Como la ordenación de mes y día en la entrada de la fecha puede ser ambiguo, hay
     un mecanismo de parametrización para especificar como debe interpretarse. El comando
     <literal>SET DateStyle TO 'US'</literal> o <literal>SET DateStyle TO 'NonEuropean'</literal>
     especifica la variante <quote>mes antes del día</quote>, mientras el comando
     <literal>SET DateStyle TO 'European'</literal> fija la variante
     <quote>día antes del mes</quote>. La versión de defecto es la 'US'.
    </para>

    <para>
     Vea <xref linkend="datetime-appendix-title" endterm="datetime-appendix-title">
     para revisar las reglas de traducción exacta de entrada de fechas y horas y para
     obtener información sobre las zonas horarias reconocidas.
    </para>

    <para>
     Recuerde que cualquier entrada de fechas u horas necesita estar encerrada entre
     comillas simples, como las cadenas de texto.
    </para>

    <sect3>
    <title>date</title>
    <para>
     Los siguientes son las entradas posibles para el tipo <type>date</type>.
     <table tocentry="1">
      <title>Entrada de Fechas en <productname>PostgreSQL</productname></title>
      <titleabbrev>Date Inputs</titleabbrev>
      <tgroup cols="2">
       <thead>
	<row>
	 <entry>Ejemplo</entry>
	 <entry>Descripción</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>January 8, 1999</entry>
	 <entry>No ambiguo</entry>
	</row>
	<row>
	 <entry>1999-01-08</entry>
	 <entry>Formato ISO-8601, el preferido</entry>
	</row>
	<row>
	 <entry>1/8/1999</entry>
	 <entry>US; se lee como 1 de Agosto en modo europeo</entry>
	</row>
	<row>
	 <entry>8/1/1999</entry>
	 <entry>European; se lee como 1 de Agosto en modo estadounidense</entry>
	</row>
	<row>
	 <entry>1/18/1999</entry>
	 <entry>US; se lee como 18 de Enero en cualquier modo (N. del T: no existe el mes 18)</entry>
	</row>
	<row>
	 <entry>1999.008</entry>
	 <entry>Año y día de año</entry>
	</row>
	<row>
	 <entry>19990108</entry>
	 <entry>Año, mes y día en formato ISO-8601</entry>
	</row>
	<row>
	 <entry>990108</entry>
	 <entry>Año, mes y día en formato ISO-8601</entry>
	</row>
	<row>
	 <entry>99008</entry>
	 <entry>Año y día del año</entry>
	</row>
	<row>
	 <entry>January 8, 99 BC</entry>
	 <entry>Año 99 Antes de Cristo</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
    </para>

    <para>
     <table tocentry="1">
      <title>Abreviaturas para Meses en <productname>PostgreSQL</productname></title>
      <titleabbrev>Month Abbreviations</titleabbrev>
      <tgroup cols="2">
       <thead>
	<row>
	 <entry>Mes</entry>
	 <entry>Abreviaturas</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>Enero</entry>
	 <entry>Jan</entry>
	</row>
	<row>
	 <entry>Febrero</entry>
	 <entry>Feb</entry>
	</row>
	<row>
	 <entry>Marzo</entry>
	 <entry>Mar</entry>
	</row>
	<row>
	 <entry>Abril</entry>
	 <entry>Apr</entry>
	</row>
	<row>
	 <entry>Junio</entry>
	 <entry>Jun</entry>
	</row>
	<row>
	 <entry>Julio</entry>
	 <entry>Jul</entry>
	</row>
	<row>
	 <entry>Agosto</entry>
	 <entry>Aug</entry>
	</row>
	<row>
	 <entry>Septiembre</entry>
	 <entry>Sep, Sept</entry>
	</row>
	<row>
	 <entry>Octubre</entry>
	 <entry>Oct</entry>
	</row>
	<row>
	 <entry>Noviembre</entry>
	 <entry>Nov</entry>
	</row>
	<row>
	 <entry>Diciembre</entry>
	 <entry>Dec</entry>
	</row>
       </tbody>
      </tgroup>
     </table>

     <note>
      <para>
       El mes <literal>Mayo</literal> (May en inglés) no tiene abreviatura explícita.
      </para>
     </note>
    </para>

    <para>
     <table tocentry="1">
      <title>Abreviaturas para el Día de la Semana en <productname>PostgreSQL</productname></title>
      <titleabbrev>Día de la Semana</titleabbrev>
      <tgroup cols="2">
       <thead>
	<row>
	 <entry>Día</entry>
	 <entry>Abreviatura</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>Lunes</entry>
	 <entry>Mon</entry>
	</row>
	<row>
	 <entry>Martes</entry>
	 <entry>Tue, Tues</entry>
	</row>
	<row>
	 <entry>Miercoles</entry>
	 <entry>Wed, Weds</entry>
	</row>
	<row>
	 <entry>Jueves</entry>
	 <entry>Thu, Thur, Thurs</entry>
	</row>
	<row>
	 <entry>Viernes</entry>
	 <entry>Fri</entry>
	</row>
	<row>
	 <entry>Sábado</entry>
	 <entry>Sat</entry>
	</row>
	<row>
	 <entry>Domingo</entry>
	 <entry>Sun</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
    </para>
    </sect3>

    <sect3>
    <title>Hora</title>
    <para>
     Las siguientes son entradas válidas de <type>time</type> (hora).
     <table tocentry="1">
      <title>Entrada de Horas en <productname>PostgreSQL</productname></title>
      <titleabbrev>Entrada de Horas</titleabbrev>
      <tgroup cols="2">
       <thead>
	<row>
	 <entry>Ejemplo</entry>
	 <entry>Descripción</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>04:05:06.789</entry>
	 <entry>ISO-8601</entry>
	</row>
	<row>
	 <entry>04:05:06</entry>
	 <entry>ISO-8601</entry>
	</row>
	<row>
	 <entry>04:05</entry>
	 <entry>ISO-8601</entry>
	</row>
	<row>
	 <entry>040506</entry>
	 <entry>ISO-8601</entry>
	</row>
	<row>
	 <entry>04:05 AM</entry>
	 <entry>Lo mismo que 04:05; AM no afecta al valor</entry>
	</row>
	<row>
	 <entry>04:05 PM</entry>
	 <entry>Lo mismo que 16:05; la entrada de la hora debe ser<= 12</entry>
	</row>
	<row>
	 <entry>z</entry>
	 <entry>Lo mismo que 00:00:00</entry>
	</row>
	<row>
	 <entry>zulu</entry>
	 <entry>Lo mismo que 00:00:00</entry>
	</row>
	<row>
	 <entry>allballs</entry>
	 <entry>Lo mismo que 00:00:00</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
    </para>
    </sect3>

    <sect3>
    <title>timestamp</title>
    <para>
     Las entradas válidas para el tipo <type>timestamp</type> consisten en la concatenación
     de una fecha y una hora, seguidos del opcional <literal>AD</literal> o
     <literal>BC</literal>, seguidos de una zona horaria opcional. (Ver más abajo.)
     Así
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>
     es un valor válido de <type>timestamp</type>, que cumple <acronym>ISO</acronym>.
     Además, el formato extendido
<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
     también está soportado.
    </para>

    <para>
     <table tocentry="1">
      <title>Entrada de Zonas Horarias en <productname>PostgreSQL</productname></title>
      <titleabbrev>Entrada de Zonas Horarias</titleabbrev>
      <tgroup cols="2">
       <thead>
	<row>
	 <entry>Zona Horaria</entry>
	 <entry>Descripción</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>PST</entry>
	 <entry>Pacific Standard Time</entry>
	</row>
	<row>
	 <entry>-8:00</entry>
	 <entry>Referencia ISO-8601 para PST</entry>
	</row>
	<row>
	 <entry>-800</entry>
	 <entry>Referencia ISO-8601 para PST</entry>
	</row>
	<row>
	 <entry>-8</entry>
	 <entry>Referencia ISO-8601 para PST</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
    </para>
    </sect3>

    <sect3>
     <title>intervalos</title>
      <para>
       Los <type>interval</type>os se pueden especificar con la siguiente sintaxis:
<programlisting>
  Quantity Unit [Quantity Unit...] [Direction]
@ Quantity Unit [Direction]
</programlisting>
       donde: <literal>Quantity</literal> es ..., <literal>-1</literal>,
       <literal>0</literal>, <literal>1</literal>, <literal>2</literal>, ...;
       <literal>Unit</literal> es <literal>second</literal>,
       <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>,
       <literal>week</literal>, <literal>month</literal>, <literal>year</literal>,
       <literal>decade</literal>, <literal>century</literal>, <literal>millenium</literal>,
       o abreviaturas o plurales de estas unidades;
       <literal>Direction</literal> puede ser <literal>ago</literal> o nada.
      </para>
     </sect3>

    <sect3>
    <title>Valores Especiales</title>
    <para>
     Las siguientes funciones compatibles con <acronym>SQL</acronym>
     se pueden utilizar como entradas de fechas u horas para los corresponidentes
     tipos de datos:<literal>CURRENT_DATE</literal>,
     <literal>CURRENT_TIME</literal>, <literal>CURRENT_TIMESTAMP</literal>.
    </para>
    <para>
     <productname>PostgreSQL</productname> también soporta varias constantes especiales
     para facilitar el uso.

     <table tocentry="1">
      <title>Constantes de Fecha/Hora Especiales en <productname>PostgresSQL</productname></title>
      <titleabbrev>Constantes</titleabbrev>
      <tgroup cols="2">
       <thead>
	<row>
	 <entry>Constante</entry>
	 <entry>Descripción</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>current</entry>
	 <entry>Hora de la Transacción Actual, deferido</entry>
	</row>
	<row>
	 <entry>epoch</entry>
	 <entry>1970-01-01 00:00:00+00 (Momento cero en sistemas Unix)</entry>
	</row>
	<row>
	 <entry>infinity</entry>
	 <entry>Más alla de otros momentos válidos</entry>
	</row>
	<row>
	 <entry>-infinity</entry>
	 <entry>Antes de otros momentos válidos</entry>
	</row>
	<row>
	 <entry>invalid</entry>
	 <entry>Entrada Ilegal</entry>
	</row>
	<row>
	 <entry>now</entry>
	 <entry>Momento de la transacción activa</entry>
	</row>
	<row>
	 <entry>today</entry>
	 <entry>Medianoche de Hoy</entry>
	</row>
	<row>
	 <entry>tomorrow</entry>
	 <entry>Medianoche de Mañana</entry>
        </row>
	<row>
	 <entry>yesterday</entry>
	 <entry>Medianoche de ayer</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
     <literal>'now'</literal> se resuelve en el momento en que se inserta el valor, mientras
     que <literal>'current'</literal> se resuelve cada vez que se recupera el valor. De forma
     que probáblemente sea preferible utilizar <literal>'now'</literal> en la mayoría de las
     aplicaciones. (Por supuesto, lo que <emphasis>really</emphasis> es preferible es
     <literal>CURRENT_TIMESTAMP</literal>, que es equivalente a <literal>'now'</literal>.)
    </para>
    </sect3>

   </sect2>


   <sect2>
    <title>Salida de Fechas/Horas</title>

    <para>
     Los formatos de salida se pueden fijar a uno de los cuatro estilos
     ISO-8601, <acronym>SQL</acronym> (Ingres), tradicional
     Postgres, y German, utilizando <command>SET DateStyle</command>.
     El valor de defecto es el formato <acronym>ISO</acronym>.

     <table tocentry="1">
      <title>Estilos de Salida de Fecha/Hora de <productname>PostgreSQL</productname></title>
      <titleabbrev>Estilos</titleabbrev>
      <tgroup cols="3">
       <thead>
	<row>
	 <entry>Especificación de Estilo</entry>
	 <entry>Descripción</entry>
	 <entry>Ejemplo</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>'ISO'</entry>
	 <entry>Estándar ISO-8601</entry>
	 <entry>1997-12-17 07:37:16-08</entry>
	</row>
	<row>
	 <entry>'SQL'</entry>
	 <entry>Estilo Tradicional</entry>
	 <entry>12/17/1997 07:37:16.00 PST</entry>
	</row>
	<row>
	 <entry>'Postgres'</entry>
	 <entry>Estilo Original</entry>
	 <entry>Wed Dec 17 07:37:16 1997 PST</entry>
	</row>
	<row>
	 <entry>'German'</entry>
	 <entry>Estilo Regional</entry>
	 <entry>17.12.1997 07:37:16.00 PST</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
    </para>

    <para>
     La salida de los estilos <type>date</type> y <type>time</type> es por supuesto 
     sólo la parte de fecha u hora correspondiente de los ejemplos anteriores.
    </para>

    <para>
     El estilo <acronym>SQL</acronym> tiene variantes europea y no europea (US), 
     que determina si el mes sigue al día o viceversa. (Ver también las anteriores
     entradas de Fecha/Hora, pues esta sección se afecta también de la interpretación
     de los valores de entrada).

     <table tocentry="1">
      <title>Convenciones en el Orden de Fechas de <productname>PostgreSQL</productname></title>
      <titleabbrev>Orden</titleabbrev>
      <tgroup cols="3">
       <thead>
	<row>
	 <entry>Especificación de Estilo</entry>
	 <entry>Ejemplo</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>European</entry>
	 <entry>17/12/1997 15:37:16.00 MET</entry>
	</row>
	<row>
	 <entry>US</entry>
	 <entry>12/17/1997 07:37:16.00 PST</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
    </para>

    <para>
    La salida <type>interval</type> se muestra como el formato de entrada, excepto que las
    unidades como <literal>week</literal> o <literal>century</literal> se convierten en años y 
    días. En modo ISO, la salida se muestra como
<programlisting>
[ Quantity Units [ ... ] ] [ Days ] Hours:Minutes [ ago ]
</programlisting>
    </para>

    <para>
     Hay varias formas de afecta la apariencia de los tipos de fecha/hora:

     <itemizedlist spacing="compact" mark="bullet">
      <listitem>
       <para>
	La variable de entorno <envar>PGDATESTYLE</envar> utilizada por el servidor
        directamente en el arranque de postmaster.
       </para>
      </listitem>
      <listitem>
       <para>
        La variable de entorno <envar>PGDATESTYLE</envar> usada por el cliente libpq
        en el arranque de una sesión.
       </para>
      </listitem>
      <listitem>
       <para>
	El comando <acronym>SQL</acronym> <command>SET DATESTYLE</command>.
       </para>
      </listitem>
     </itemizedlist>
    </para>

   </sect2>

   <sect2>
    <title>Zonas Horarias</title>

    <para>
     <productname>PostgreSQL</productname> intenta ser compatible con las definiciones de
     <acronym>SQL92</acronym> para un uso típico.
     Sin embargo, el estándar <acronym>SQL92</acronym> tiene una mezcla singular de tipos y
     capacidades de fecha y hora. Hay dos problemas obvios:

     <itemizedlist>
      <listitem>
       <para>
        Aunque el tipo <type>date</type> no tiene una zona horaria asociada,
        el tipo <type>time</type> puede tenerla o no.
       </para>
      </listitem>

      <listitem>
       <para>
	La zona horaria de defecto está especificada como un entero relativo a GMT/UTC.
       </para>
      </listitem>

     </itemizedlist>

     Las zonas horarias en el mundo real pueden no tener significado al menos asociado
     con la fecha así como con la hora, ya que la compensación puede variar a lo largo
     del año con las modificaciones horarias orientadas a aprovechar la luz del día.
    </para>

    <para>
     
     Para orientar estas dificultades, <productname>PostgreSQL</productname>
     asocia las zonas horarias solo con los tipos de fecha y hora que contengan tanto
     la fecha como la hora, y asume la hora local para cualquier tipo que contenga sólo 
     fecha u hora. Más aún, el soporte de zonas horarias se deriva de la capacidad de 
     soportarlas que tenga el sistema operativo subyacente, y a partir de él puede 
     manipular ajustes del horario diurno y otros comportamientos esperados.
    </para>

    <para>
     <productname>PostgreSQL</productname> obtiene el soporte de zonas horarias 
     del sistema operativo subyacente para fechas entre 1902 y 2038 (aproximádamente los
     límites de fecha típicos de sistemas de estilo Unix). Fuera de este rango, se asume que
     todas las fechas se especifican y utilizan en el Horario Universal Coordinado (Universal
     Coordinated Time, UTC).
    </para>

    <para>
     Todas las fechas y horas se almacenan internamente en UTC Universal, conocido también 
     como horario del meridiado de Greenwich (GMT).
     Las horas las convierte a la hora local el servidor de base de datos antes de envialas
     a la aplicación cliente, por lo que por defecto están en la zona horaria del servidor.
    </para>

    <para>
     Hay varias formas de afectar el comportamiento de la zona horaria:

     <itemizedlist spacing="compact" mark="bullet">
      <listitem>
       <para>
        La variable de entorno TZ utilizada por el servidor directamente en el arranque 
        del postmaster como la zona horaria de defecto.
       </para>
      </listitem>
      <listitem>
       <para>
        La variable de entorno PGTZ fijaza en el cliente y utilizada por libpq para enviar
        información sobre la zona horaria al servidor sobre la conexión.
       </para>
      </listitem>
      <listitem>
       <para>
        El comando <acronym>SQL</acronym> <command>SET TIME ZONE</command>
        fija la zona horaria para la sesión.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Si se especifica una zona horaria inválida,
     se utiliza GMT (en la mayoría de sistemas en cualquier caso):
    </para>

    <para>

     <note>
      <para>
       Si se ha fijado la opción del compilador USE_AUSTRALIAN_RULES, el literal
       <literal>EST</literal> se refiere a Australia Eastern Std Time,
       que tiene un desplazamiento de +10:00 horas sobre UTC.
      </para>
     </note>
    </para>

   </sect2>

   <sect2>
    <title>Características Internas</title>

    <para>
     <productname>PostgreSQL</productname> utiliza fechas Julianas para todos los
     cálculos de fecha/hora. Estas tienen la agradable propiedad de precedir/calcular
     correctamente cualquier fecha más reciente que 4713 a. de C. hacia el futuro, 
     asumiendo que la longitud del año es de 365,2425 días.
    </para>

    <para>
     Se utilizan convenciones de fecha antes del siglo 19 para facilitar la lectura,
     pero no son consistentes para garantizar la codificación en un manipulador 
     de fechas y horas.
    </para>
   </sect2>

  </sect1>

  <sect1>
   <title>Tipo Booleano</title>

   <para>
    <productname>Postgres</productname> soporta <type>bool</type> como el tipo
    booleano de <acronym>SQL3</acronym>.
    El tipo <type>bool</type> sólo puede tener dos estados: 'true' o 'false'. 
    Un tercer estado, 'unknown', no está implementado y no está sugerido en 
    <acronym>SQL3</acronym>; <acronym>NULL</acronym> es un sustituto efectivo.
    <type>bool</type> se puede utilzar en cualquier expresión booleana, y las expresiones
    booleanas siempre dan como resultado uno compatible con este tipo.</para>

   <para>
    <type>bool</type> utiliza 1 byte de almacenamiento.
   </para>

   <para>
    <table tocentry="1">
     <title>Tipo <productname>Postgres</productname> Booleano</title>
     <titleabbrev>Booleans</titleabbrev>
     <tgroup cols="3">
      <thead>
       <row>
	<entry>Estado</entry>
	<entry>Salida</entry>
	<entry>Entrada</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>True</entry>
	<entry>'t'</entry>
	<entry>TRUE, 't', 'true', 'y', 'yes', '1'</entry>
       </row>
       <row>
	<entry>False</entry>
	<entry>'f'</entry>
	<entry>FALSE, 'f', 'false', 'n', 'no', '0'</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
  </sect1>

  <sect1>
   <title>Tipos Geometricos</title>

   <para>
    Los tipos geométricos representan objetos espaciales bidimensionales.
    El tipo fundamental, el punto, constituye la base para todos los demás.
   </para>

   <para>
    <table tocentry="1">
     <title>Tipos Geométricos de <productname>Postgres</productname></title>
     <titleabbrev>Geometrics</titleabbrev>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Tipo Geométrico</entry>
	<entry>Tamaño</entry>
	<entry>Representación</entry>
	<entry>Descripción</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>point</entry>
	<entry>16 bytes</entry>
	<entry>(x,y)</entry>
	<entry>Punto en el espacio</entry>
       </row>
       <row>
	<entry>line</entry>
	<entry>32 bytes</entry>
	<entry>((x1,y1),(x2,y2))</entry>
	<entry>Línea infinita</entry>
       </row>
       <row>
	<entry>lseg</entry>
	<entry>32 bytes</entry>
	<entry>((x1,y1),(x2,y2))</entry>
	<entry>Segmento finito</entry>
       </row>
       <row>
	<entry>box</entry>
	<entry>32 bytes</entry>
	<entry>((x1,y1),(x2,y2))</entry>
	<entry>Caja rectangular</entry>
       </row>
       <row>
	<entry>path</entry>
	<entry>4+32n bytes</entry>
	<entry>((x1,y1),...)</entry>
	<entry>Ruta cerrada (similar al polígono)</entry>
       </row>
       <row>
	<entry>path</entry>
	<entry>4+32n bytes</entry>
	<entry>[(x1,y1),...]</entry>
	<entry>Ruta abierta</entry>
       </row>
       <row>
	<entry>polygon</entry>
	<entry>4+32n bytes</entry>
	<entry>((x1,y1),...)</entry>
	<entry>Polígono (similar a <literal>path</literal>)</entry>
       </row>
       <row>
	<entry>circle</entry>
	<entry>24 bytes</entry>
	<entry><(x,y),r></entry>
	<entry>Círculo (centro y radio)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
    Hay disponible un rico conjunto de funciones y operaciones para realizar varias
    operaciones geométricas como escalado, traslación, rotación y determinación de 
    intersecciones.
   </para>

   <sect2>
    <title>Puntos</title>

    <para>
     Los puntos (<type>point</type>) son los bloques bidimensionales fundamentales para construir los tipos
     geométricos.
    </para>

    <para>
     <type>point</type> se especifica utilizando la siguiente sintaxis:

     <programlisting>
( x , y )
  x , y
donde
    x es la coordenada en el eje x en formato numérico de punto flotate
    y es la coordenada en el eje y en formato numérico de punto flotate
     </programlisting>
    </para>
   </sect2>

   <sect2>
    <title>Segmento de Línea</title>

    <para>
     Los segmentos de línea (<type>lseg</type>) se representan por pares de puntos.
    </para>

    <para>
     <type>lseg</type> utiliza la siguiente sintaxis:
     <programlisting>
( ( x1 , y1 ) , ( x2 , y2 ) )
  ( x1 , y1 ) , ( x2 , y2 )  
    x1 , y1   ,   x2 , y2    
donde
    (x1,y1) y (x2,y2) son los puntos de los extremos del segmento
     </programlisting>
    </para>
   </sect2>

   <sect2>
    <title>Caja</title>

    <para>
     Las cajas se representan por pares de puntos que son las esquinas opuestas de la caja.
    </para>

    <para>
     <type>box</type> se especifica utilizando la siguiente sintaxis:

     <programlisting>
( ( x1 , y1 ) , ( x2 , y2 ) )
  ( x1 , y1 ) , ( x2 , y2 )  
    x1 , y1   ,   x2 , y2    
donde
    (x1,y1) y (x2,y2) son las esquinas opuestas
     </programlisting>

     Las cajas se muestran utilizando la primera sintaxis. Las esquinas se reordenan en la
     entrada para almacenar la esquina inferior izquierda primero, y luego la superior derecha.
     Se pueden entrar las otras esquinas, pero en función de ellas se determinan y almacenan 
     la inferior izquierda y la superior derecha.
    </para>
   </sect2>

   <sect2>
    <title>Rutas</title>

    <para>
     Las rutas se representan conectando conjuntos de puntos. Las rutas pueden ser "abiertas",
     en las que el primer y el último punto no están conectados, y "cerradas", en las que
     el primer y el último punto están conectados. Se suministran las funciones 
     <function>popen(p)</function> y <function>pclose(p)</function> para forzar a una ruta 
     a ser abierta o cerrada, y las funciones <function>isopen(p)</function> y
     <function>isclosed(p)</function> para seleccionar el tipo deseado en una consulta.
    </para>

    <para>
     <type>path</type> se especifica utilizando la siguiente sintaxis:

     <programlisting>
( ( x1 , y1 ) , ... , ( xn , yn ) )
[ ( x1 , y1 ) , ... , ( xn , yn ) ]
  ( x1 , y1 ) , ... , ( xn , yn )  
  ( x1 , y1   , ... ,   xn , yn )  
    x1 , y1   , ... ,   xn , yn    
where
    (x1,y1),...,(xn,yn) are points 1 through n
    a leading "[" indicates an open path
    a leading "(" indicates a closed path
     </programlisting>

     Las rutas se muestran utilizando la primera sintaxis. Nótese que las versiones
     de Paths <productname>Postgres</productname> anteriores a v6.1 utilizaban
     un formato para las rutas que tenía un único paréntesis inicial, una indicación
     de "cerrado", un entero para contar el número de puntos, la lista de puntos
     seguida de un paréntesis de cierre. Se proporciona la función 
     <function>upgradepath</function> para convertir las rutas vaciadas y recargadas
     de bases de datos previas a la v6.1.
    </para>
   </sect2>

   <sect2>
    <title>Polígono</title>

    <para>
     Los polígonos se representan con conjuntos de puntos. Los polígonos deberían
     probáblemente considerarse equivalentes a rutas cerradas, pero se almacenan de
     forma diferente y tienen su propio conjunto de rutinas de soporte.
    </para>

    <para>
     <type>polygon</type> se especifica utilizando la siguiente sintaxis:
     <programlisting>
( ( x1 , y1 ) , ... , ( xn , yn ) )
  ( x1 , y1 ) , ... , ( xn , yn )  
  ( x1 , y1   , ... ,   xn , yn )  
    x1 , y1   , ... ,   xn , yn    
donde
    (x1,y1),...,(xn,yn) son puntos de 1 a n
     </programlisting>

     Los polígonos se muestran utilizando la primera sintaxis. Es importante remarcar
     que las versiones de <productname>Postgres</productname> previas a la v6.1
     utilizaban un formato para los polígonos que tenía un único paréntesis inicial, 
     la lista de coordenadas x, la lista de coordenadas y, y un paréntesis de cierre.
     Se proporciona la función <function>upgradepoly</function> para convertir los
     polígonos vaciados y recargados a partir de bases de datos previas a v6.1.
    </para>
   </sect2>

   <sect2>
    <title>Círculo</title>

    <para>
     Los círculos se representan por un punto centras y un radio.
    </para>

    <para>
     <type>circle</type> se especifica utilizando la siguinte sintaxis:

     <programlisting>
< ( x , y ) , r >
( ( x , y ) , r )
  ( x , y ) , r  
    x , y   , r  
donde
    (x,y) es el centro del círculo
    r es el radio del círculo
     </programlisting>

     Los círculos se muestran siguiendo la primera sintaxis.
    </para>
   </sect2>

  </sect1>

  <sect1>
   <title>Redes IP Versión 4 y Direcciones de Ordenadores</title>

   <para>
    El tipo <type>cidr</type> almacena redes especificadas en 
    <acronym>CIDR</acronym> (Classless Inter-Domain Routing) notacion.
    El tipo <type>inet</type> almacena ordenadores y redes en notación utilizando
    una sencilla variación en la representación para representar direcciones 
    de ordenador TCP/IP sencillas.
   </para>

   <para>
    <table tocentry="1">
     <title>Tipos <productname>Postgres</productname>IP Versión 4</title>
     <titleabbrev>IPV4</titleabbrev>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Tipo IPV4</entry>
	<entry>Almacenamiento</entry>
	<entry>Descriptión</entry>
	<entry>Rango</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>cidr</entry>
	<entry>variable</entry>
	<entry>Redes CIDR</entry>
	<entry>Bloques CIDR IPV4 válidos</entry>
       </row>
       <row>
	<entry>inet</entry>
	<entry>variable</entry>
	<entry>redes y ordenadores</entry>
	<entry>Bloques CIDR IPV4 válidos</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <sect2>
    <title>CIDR</title>

    <para>
     El tipo <type>cidr</type> almacena una red CIDR. El formato para específicar
     redes sin clase es <replaceable class="parameter">x.x.x.x/y</replaceable>
     donde <replaceable class="parameter">x.x.x.x</replaceable> es la red y
     <replaceable class="parameter">/y</replaceable> es el número de bits en la
     máscara de red. Si se omite <replaceable class="parameter">/y</replaceable>,
     se calcula utilizando las asunciones del antíguo sistema de nombres con
     clase completa, excepto qeu se extiende para incluir al meos todos los octetos
     de la entrada.
    </para>

    <para>
     Veamos unos ejemplos:

     <table tocentry="1">
      <title>Ejemplos de Tipos IP de <productname>Postgres</productname></title>
      <tgroup cols="2">
       <thead> 
	<row> 
	 <entry>CIDR de Entrada</entry>
	 <entry>CIDR Mostrado</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>192.168.1</entry>
	 <entry>192.168.1/24</entry>
	</row>
	<row>
	 <entry>192.168</entry>
	 <entry>192.168.0/24</entry>
	</row>
	<row>
	 <entry>128.1</entry>
	 <entry>128.1/16</entry>
	</row>
	<row>
	 <entry>128</entry>
	 <entry>128.0/16</entry>
	</row>
	<row>
	 <entry>128.1.2</entry>
	 <entry>128.1.2/24</entry>
	</row>
	<row>
	 <entry>10.1.2</entry>
	 <entry>10.1.2/24</entry>
	</row>
	<row>
	 <entry>10.1</entry>
	 <entry>10.1/16</entry>
	</row>
	<row>
	 <entry>10</entry>
	 <entry>10/8</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
    </para>
   </sect2>

   <sect2>
    <title id="inet-type"><type>inet</type></title>

    <para>
     El tipo <type>inet</type> está diseñado para almacenar, en un único campo, toda
     la información sobre un ordenador, incluyendo la subred de estilo CIDR en la que
     se encuentra. Observese que si se quieren almacenar redes CIDR adecuadamente,
     se debería utilizar el tipo <type>cidr</type>. El tipo <type>inet</type> es 
     similar al tipo <type>cidr</type> excepto en que los bits en la parte del host
     pueden ser distintos de cero. Existen funciones para extraer los diferentes
     elementos del campo.
    </para>

    <para>
     El formato de entrada para esta función es 
     <replaceable class="parameter">x.x.x.x/y</replaceable> 
     donde <replaceable class="parameter">x.x.x.x</replaceable> es un ordenador en
     internet y <replaceable class="parameter">y</replaceable> el número de bits en
     la máscara de red. Si la parte <replaceable class="parameter">/y</replaceable>
     no se indica, se trata como <literal>/32</literal>. En salida, la parte
     <replaceable class="parameter">/y</replaceable> no se muestra si es 
     <literal>/32</literal>. Esto permite utilizar el tipo como un tipo host
     completo, simplemente dejanto la parte de los bits vacía.
    </para>
   </sect2>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->







