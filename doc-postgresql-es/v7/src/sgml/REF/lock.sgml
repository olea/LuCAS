<!--
$Header: /home/cvs/lucas/doc-postgresql-es/v7/src/sgml/REF/lock.sgml,v 1.2 2001/10/11 21:46:27 rssantos Exp $
Postgres documentation
-->

<refentry id="SQL-LOCK">
 <refmeta>
  <refentrytitle id="sql-lock-title">
   LOCK
  </refentrytitle>
  <refmiscinfo>SQL - Declaración del lenguage </refmiscinfo>
 </refmeta>
 <refnamediv>
  <refname>
   LOCK
  </refname>
  <refpurpose>
   Explícitamente bloquea una tabla dentro de una transacción
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <refsynopsisdivinfo>
   <date>1999-07-20</date>
  </refsynopsisdivinfo>
  <synopsis>
LOCK [ TABLE ] <replaceable class="PARAMETER">name</replaceable>
LOCK [ TABLE ] <replaceable class="PARAMETER">name</replaceable> IN [ ROW | ACCESS ] { SHARE | EXCLUSIVE } MODE
LOCK [ TABLE ] <replaceable class="PARAMETER">name</replaceable> IN SHARE ROW EXCLUSIVE MODE
  </synopsis>

  <refsect2 id="R2-SQL-LOCK-1">
   <refsect2info>
    <date>1999-06-09</date>
   </refsect2info>
   <title>
    Entradas
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
       <para>
	El nombre de una tabla existente para bloquear.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ACCESS SHARE MODE</term>
      <listitem>
       <note>
	<para>
	 A este modo de bloqueo se accede automáticamente sobre tablas que estan siendo consultadas.
	 <productname>Postgres</productname> libera automáticamente los bloqueos accedidos
	 ACCESS SHARE despues de que se haya hecho la sentencia.
	</para>
       </note>

       <para>
	Este es el modo de bloqueo menos restrictivo el cual entra en conflicto sólo con el modo
	ACCESS EXCLUSIVE . Se pretende proteger una tabla que está siendo consultada
        de sentencias concurrentes <command>ALTER TABLE</command>, <command>DROP TABLE</command> y <command>VACUUM</command>
	sobre la misma tabla.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ROW SHARE MODE</term>
      <listitem>
       <note>
       <para>
	 Se accede automáticamente por cualquier declaración <command>SELECT FOR UPDATE.</command>
	</para>
       </note>

       <para>
	Conflictos con los modos de bloqueo EXCLUSIVE y ACCESS EXCLUSIVE.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ROW EXCLUSIVE MODE</term>
      <listitem>
       <note>
	<para>
	 Se accede automáticamente por cualquier sentencia <command>UPDATE</command>,
	 <command>DELETE</command>, <command>INSERT.</command>
	</para>
       </note>

       <para>
	 Conflictos con los modos SHARE, SHARE ROW EXCLUSIVE, EXCLUSIVE
	 ACCESS EXCLUSIVE. Generalmente significa que una transacción actualiza o
	 inserta algunas tuplas en una tabla.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>SHARE MODE</term>
      <listitem>
       <note>
       <para>
	 Se accede automáticamente por cualquier sentencia <command>CREATE INDEX</command>
       </para>
       </note>

       <para>
	Conflictos con  los modos ROW EXCLUSIVE, SHARE ROW EXCLUSIVE, EXCLUSIVE y
	ACCESS EXCLUSIVE . Este modo protege una tabla contra
	actualizaciones concurrentes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>SHARE ROW EXCLUSIVE MODE</term>
      <listitem>

       <para>
	Conflictos con los modos ROW EXCLUSIVE, SHARE, SHARE ROW EXCLUSIVE,
	EXCLUSIVE y ACCESS EXCLUSIVE. Este modo es más
	restrictivo que el modo SHARE debido a que sólo  puede soportar
        este bloqueo una transacción por vez .
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>EXCLUSIVE MODE</term>
      <listitem>

       <para>
	Conflictos con los modos ROW SHARE, ROW EXCLUSIVE, SHARE, SHARE ROW EXCLUSIVE,
	EXCLUSIVE y ACCESS EXCLUSIVE modes. Este modo es aún más
	restrictivo que ése de SHARE ROW EXCLUSIVE; bloquea todas las consultas concurrentes
	SELECT FOR UPDATE .
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ACCESS EXCLUSIVE MODE</term>
      <listitem>
       <note>
	<para>
	 Se accede automáticamente por las sentencias <command>ALTER TABLE</command>,
	 <command>DROP TABLE</command>, <command>VACUUM</command> .
	</para>
       </note>

       <para>
	Este es el modo de bloqueo más restrictivo y es incompatible
	con todos los demás modos de bloqueo y protege una tabla bloqueada
	de cualquier otra operación concurrente.
       </para>
	   
       <note>
	<para>
	 Este modo de bloqueo se accede también por un
	 <command>LOCK TABLE</command> sin cualificar. (i.e. el comando sin una opción de
	bloqueo explícita).
	</para>
       </note>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>

  <refsect2 id="R2-SQL-LOCK-2">
   <refsect2info>
    <date>1998-09-24</date>
   </refsect2info>
   <title>
    Salidas
   </title>
   <para>
    
    <variablelist>
     <varlistentry>
      <term><computeroutput>
LOCK TABLE
       </computeroutput></term>
      <listitem>
       <para>
	El bloqueo se activó con éxito.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><computeroutput>
ERROR <replaceable class="PARAMETER">name</replaceable>: La tabla no existe.
       </computeroutput></term>
      <listitem>
       <para>
	Mensaje devuelto si el <replaceable class="PARAMETER">nombre</replaceable>
	no existe.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
 </refsynopsisdiv>

 <refsect1 id="R1-SQL-LOCK-1">
  <refsect1info>
   <date>1998-09-24</date>
  </refsect1info>
  <title>
   Description
  </title>
  <para>
   <productname>Postgres</productname> siempre usa el modo de bloqueo
   menos restrictivo cuando le es posible. <command>LOCK TABLE</command>
   toma medidas para cuando se pueda necesitar un modo de bloqueo mas restrictivo.
  </para>

  <para>
   Por ejemplo, una aplicación ejecuta una transacción  en el nivel de aislamiento READ COMMITTED
   y necesita asegurar la existencia de datos en una tabla para la
   duracion de la transacción. Para ello tú podrías usar el modo de bloqueo SHARE sobre la
   tabla antes de la consulta. Esto protegerá los datos de cambios concurrentes
   y proporcionará cualquier otra operación de escritura sobre la tabla con datos en su
   verdadero estado actual, porque el modo de bloqueo SHARE  es incompatible con cualquier ROW EXCLUSIVE
   accedido por los que esriben, y
   <command>LOCK TABLE "tabla" <replaceable class="PARAMETER">en sentencia</replaceable> IN SHARE MODE</command>
   esperará hasta que se produzca o se "baje" cualquier operación de escritura concurrente.

   <note>
    <para>
     Para leer datos en su verdadero estado actual cuando ejecutas una transacción
     en el nivel de aislamiento SERIALIZABLE tienes que ejecutar una declaración LOCK TABLE
     antes de la ejecución de cualquier sentencia DML, cuando la transacción define
     qué cambios concurrentes serán visibles por ellos mismos.
    </para>
   </note>
  </para>
  
  <para>
   Además de los requerimientos precedentes, si una transacción va a
   cambiar datos en una tabla entonces  se debería acceder al modo SHARE ROW EXCLUSIVE
   para evitar condiciones de punto muerto cuando dos transacciones coincidentes
   intentan bloquear la tabla en modo SHARE y entonces
   intentan cambiar datos en esta tabla, ambas (implicitamente) accediendo al modo de bloqueo
   ROW EXCLUSIVE que es incompatible con el bloqueo SHARE .
  </para>
  
  <para>
   Para continuar con los puntos muertos (cuando dos transacciones se esperan la una a la otra)
   tema tratado arriba, deberías seguir dos reglas generales para evitar
   condiciones de punto muerto :
  </para>

  <itemizedlist>  
   <listitem>
    <para>
     Las transacciones tienen que acceder a bloqueos de los mismos objetos en el mismo orden.
    </para>
   
    <para>
     Por ejemplo, si una aplicación actualiza la fila  R1 y después actualiza
     la fila R2 (en la misma transacción) entonces la segunda aplicación no debería
     actualizar la fila R2 si ello va a actualizar la fila R1 más tarde (en una transacción simple).
     En cambio, debería actualizar la fila R1 y R2  en el mismo orden como en la primera
     aplicación.
    </para>
   </listitem>

   <listitem>
    <para>
     Las transacciones deberían procurarse dos modos de bloqueo conflictivos sólo  si
     uno de ellos es auto-conflictivo (i.e. podría ser soportado por sólo una transacción
     cada vez). Si estan involucrados modos de bloqueo múltiples,
     entonces las transacciones deberían siempre acceder primero al modo más restrictivo.
    </para>
   
    <para>
     Un ejemplo para esta regla se dió antes cuando se discutió
     el uso del modo SHARE ROW EXCLUSIVE mejor que el modo SHARE.
    </para>
   </listitem>
  </itemizedlist>

  <note>
   <para>
    <productname>Postgres</productname> no detecta puntos muertos "bajará"
    una transacción a la espera para resolver el punto muerto.
   </para>
  </note>

  <refsect2 id="R2-SQL-LOCK-3">
   <refsect2info>
    <date>1999-06-08</date>
   </refsect2info>
   <title>
    Notas
   </title>

   <para>
    <command>LOCK</command> es una extension del lenguaje <productname>Postgres.</productname>

   </para>

   <para>
    Excepto para los modos de bloqueo ACCESS SHARE/EXCLUSIVE , todos los demás modos de bloqueo de
    <productname>Postgres</productname> y las sentencias
    <command>LOCK TABLE</command> son compatibles con aquellos
    presentes en <productname>Oracle</productname>.
   </para>

   <para>
    <command>LOCK</command> funciona sólo dentro de transacciones.
   </para>
  </refsect2>
 </refsect1>
  
 <refsect1 id="R1-SQL-LOCK-2">
  <title>
   Uso
  </title>

  <para>
   Illustrate a SHARE lock on a primary key table when going to perform
   inserts into a foreign key table:

  <programlisting>
BEGIN WORK;
LOCK TABLE películas IN SHARE MODE;
SELECT id FROM películas
    WHERE name = 'Star Wars: Episodio I - La amenaza fantasma';
-- Haz ROLLBACK si el registro no fue devuelto
INSERT INTO comentarios_usuario_películas VALUES
    (_id_, 'GUAY! Llevaba tanto tiempo esperándola!');
COMMIT WORK;
   </programlisting>
  </para>

  <para>
   Toma un bloqueo SHARE ROW EXCLUSIVE clave de tabla primaria cuando vayas a hacer una
   operación de borrado:

   <programlisting>
BEGIN WORK;
LOCK TABLE películas IN SHARE ROW EXCLUSIVE MODE;
DELETE FROM comentarios_usuario_películas WHERE id IN
    (SELECT id FROM películas WHERE clasificación < 5);
DELETE FROM películas WHERE clasificación < 5;
COMMIT WORK;
   </programlisting>
  </para>
 </refsect1>

 <refsect1 id="R1-SQL-LOCK-3">
  <title>
   Compatibilidad
  </title>
	  
  <refsect2 id="R2-SQL-LOCK-4">
   <refsect2info>
    <date>1998-09-24</date>
   </refsect2info>
   <title>
    SQL92
   </title>
   <para>
    No hay <command>LOCK TABLE</command> en <acronym>SQL92</acronym>,
    que usa en cambio <command>SET TRANSACTION</command> para especificar
    niveles de concurrencia en transacciones.  Nosotros también la tenemos; ver
    <xref linkend="SQL-SET-TITLE" endterm="SQL-SET-TITLE"> para más detalles.
   </para>
  </refsect2>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
