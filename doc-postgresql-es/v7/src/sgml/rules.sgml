<Chapter Id="rules">
<Title>El Sistema de reglas de <ProductName>Postgres</ProductName></Title>

<Para>
     Los sistemas de reglas de producción son conceptualmente simples,
     pero hay muchos puntos sutiles implicados en el uso actual de ellos.
     Algunos de estos puntos y los fundamentos teóricos del sistema de 
     reglas de <ProductName>Postgres</ProductName> se pueden encontrar en
     [<XRef LinkEnd="STON90b" EndTerm="STON90b">].
</Para>

<Para>
     Algunos otros sistemas de base de datos definen reglas de base 
     de datos activas. Éstas son habitualmente procedimientos y disparadores 
     (a partir de aquí utilizaré el término más habitual de "trigger")
     almacenados y se implementan en
     <ProductName>Postgres</ProductName>
     como funciones y triggers.  
</Para>

<Para>
     El sistema de reglas de reescritura de queries (el "sistema de reglas"
     a partir de ahora) es totalmente diferente a los procedimientos
     almacenados y los triggers. Él modifica las queries para tomar
     en consideración las reglas y entonces pasa la query modificada al
     planificador para su ejecución. Es muy poderoso, y puede utilizarse
     de muchas formas, tales como procedimientos, vistas y versiones del
     lenguaje de query. El poder de este sistema de reglas se discute en
[<XRef LinkEnd="ONG90" EndTerm="ONG90">]
 y en
[<XRef LinkEnd="STON90b" EndTerm="STON90b">].
</para>
<Sect1 id="querytree">
<Title>¿Qué es un árbol de query?</Title>

<Para>
    Para comprender como trabaja el sistema de reglas, es necesario conocer
    cuándo se invoca y cuáles son sus entradas y sus resultados.
</Para>

<Para>
    El sistema de reglas se situa entre el analizador de la query y el
    planificador. Toma la salida del traductor, un árbol de la query,
    y las reglas de reescritura del catálogo <FileName>pg_rewrite</FileName>, 
    los cuales son también árboles de queries con alguna información extra,
    y crea cero o muchos árboles de query como resultado. Por tanto,
    su entrada y salida son siempre elementos que el analizador mismo podría
    haber producido y, de este modo, todo aparece básicamente repesentable
    como una instrucción <Acronym>SQL</Acronym>.
</Para>

<Para>
    Ahora, ¿qué es un árbol de query? Es una representación interna de una 
    instrucción  <Acronym>SQL</Acronym> donde se almacenan de modo separado 
    las partes menores que la componen. Estos árboles de query son visibles 
    cuando arrancamos el motor de <ProductName>Postgres</ProductName> con 
    nivel de debug 4 y tecleamos queries en el interface de usuario 
    interactivo. 
    Las acciones de las reglas almacenadas en el catálogo de sistema 
    <FileName>pg_rewrite</FileName> están almacenadas también como árboles
    de queries. No están formateadas como la salida del debug, pero contienen
    exactamente la misma información.
</Para>

<Para>
    Leer un árbol de query requiere experiencia y era bastante duro cuando
    empecé a trabajar en el sistema de reglas. Puedo recordar que mientras
    estaba esperando en la máquina de café, asimilaba el vaso con una lista de
    objetivos, el agua y el polvo del café con una tabla de rangos, y todos
    los botones con expresiones de cualificación. Puesto que las
    representaciones de <Acronym>SQL</Acronym> de árboles de queries son
    suficientes para entender el sistema de reglas, este documento no le
    enseñará como leerlo. Él debería ayudarle a aprenderlo, con las
    convenciones de nombres requeridas en las descripciones que siguen más
    adelante.
</Para>

<Sect2>
<Title>Las partes de un árbol de query</Title>

<Para>
    Cuando se leen las representaciones de <Acronym>SQL</Acronym> de los
    árboles de queries en este documento, es necesario ser capaz de
    identificar las partes en las que la sentencia se ha dividido cuando
		está en la estructura de un árbol de query. Las partes de un árbol de
    query son:
</Para>

<Para>
<VariableList>
    <VarListEntry>
    <Term>
        El tipo de commando (commandtype)
    </Term>
    <ListItem>
    <Para>
        Este es un valor sencillo que nos dice el comando que produjo el
	arbol de traducción (SELECT, INSERT, UPDATE, DELETE).
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>
    <Term>
        La tabla de rango (rangetable)
    </Term>
    <ListItem>
    <Para>
        La tabla de rango es una lista de las relaciones que se utilizan
	en la query. En una instrucción SELECT, son las relaciones dadas
	tras la palabra clave FROM.
    </Para>

    <Para>
        Toda entrada en la tabla del rango identifica una tabla o vista,
	y nos dice el nombre por el que se la identifica en las otras
	partes de la query. En un árbol de query, las entradas de la tabla
	de rango se indican por un índice en lugar de por su nombre como
	estarían en una instrucción <Acronym>SQL</Acronym>. Esto puede ocurrir
	cuando se han mezclado las tablas de rangos de reglas. Los ejemplos
	de este documento no muestran esa situación.
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>
    <Term>
        La relación-resultado (resultrelation).
    </Term>
    <ListItem>
    <Para>
        Un índice a la tabla de rango que identifica la relación donde irán
	los resultados de la query.
    </Para>

    <Para>
        Las queries SELECT normalmente no tienen una relación resultado. El
	caso especial de una SELECT INTO es principalmente identica a una
	secuencia CREATE TABLE, INSERT ... SELECT y no se discute aquí por
	separado.
    </Para>

    <Para>
        En las queries INSERT, UPDATE y DELETE, la relación resultado es la
	tabla (¡o vista!) donde tendrán efecto los cambios.
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>
    <Term>
        La lista de objetivos (targetlist).
    </Term>
    <ListItem>
    <Para>
        La lista de objetivos es una lista de expresiones que definen el 
	resultado de la query. En el caso de una SELECT, las expresiones son las que
	construyen la salida final de la query. Son las expresiones entre
	las palabras clave SELECT y FROM (* es sólo una abreviatura de
	todos los nombres de atributos de una relación. Es expandida por el
  analizador a los atributos individuales, por lo que el sistema de reglas
  nunca lo ve.).
    </Para>

    <Para>
  Las queries DELETE no necesitan una lista de objetivos porque no producen
	ningún resultado. El planificador añadirá una entrada especial de
	identificador de tupla (CTID, ver más adelante en "Reglas de vistas para
	instrucciones diferentes a SELECT") a la lista de objetivos vacia. Pero esto
	ocurre después del sistema de reglas y lo comentaremos más tarde. Para el 
	sistema de reglas, la lista de objetivos está vacía.
    </Para>

    <Para>
  En queries INSERT la lista de objetivos describe las nuevas filas que irán
	a la relación resultado. Son las expresiones de la claúsula VALUES o las de la
  sentencia SELECT en INSERT ... SELECT. Las columnas que no aparecen en la
  relación resultado serán añadidas por el planificador con una expresión
	constante NULL.
    </Para>

    <Para>
        En queries UPDATE, describe las nuevas filas que reemplazarán a las
	viejas. En el sistema de reglas, contiene las expresiones de la parte de la
  consulta SET atributo = expresión. El planificador añadirá las columnas que
  no aparecen	insertando expresiones que recuperan los valores de las filas
  viejas en las nuevas. Y añadirá una entrada especial CTID como lo hace 
	DELETE.
    </Para>

    <Para>
  Cada entrada de la lista de objetivos contiene una expresión que puede ser
	un valor constante, una variable apuntando a un atributo de una de las
	relaciones en la tabla de rango, un parámetro o un arbol de
	expresiones hecho de llamadas a funciones, constantes, variables,
	operadores, etc.
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>
    <Term>
        La cualificación.
    </Term>
    <ListItem>
    <Para>
        La cualificación de las queries es una expresión muy similar a otra de
	las contenidas en las entradas de la lista de objetivos. El valor
	resultado de esta expresión es un booleano que dice si la operación
	(INSERT, UPDATE, DELETE o SELECT) para las filas del resultado final
	deberá ser ejecutada o no. Es la clausula WHERE de una instrucción
	<Acronym>SQL</Acronym>.
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>

 <Term>
		El árbol de uniones
	</Term>
		<ListItem>
			<Para>
        EL árbol de uniones de la query muestra la estructura de la
        claúsula FROM. Para una consulta simple como SELECT FROM a, b, c
        el árbol de uniones es únicamente una lista de los elementos de FROM,
        porque se nos permite unirlos en cualquier orden. Pero cuando se usan
        expresiones JOIN -- particularmente OUTER JOIN --, hemos de unir en
        el orden indicado por la claúsula JOIN. El árbol de uniones muestra la
        estructura de las expresiones JOIN. Las restricciones asociadas con
        claúsulas JOIN particulares (de expresiones ON o USING) se almacenan
        como expresiones de cualificación vinculadas a esos nodos del árbol de
        uniones. Conviene almacenar la expresión WHERE de más alto nivel como
        una cualificación vinculada al elemento del árbol de uniones de más
        alto nivel. Por tanto, realmente el árbol de uniones representa las
        claúsulas FROM y WHERE de una select.
			</Para>
		</ListItem>
				</VarListEntry>

				<VarListEntry>

    <Term>
        Las otras
    </Term>
    <ListItem>
    <Para>
        Las otras partes de un arbol de query, como la clausula ORDER BY, no
	tienen interés aquí. El sistema de reglas sustituye las entradas aquí
	presentes mientras está aplicando las reglas, pero aquellas no tiene
	mucho que hacer con los fundamentos del sistema de reglas.
    </Para>
    </ListItem>
    </VarListEntry>

</VariableList>
</para>
</Sect2>
</Sect1>

<Sect1 id="rules-views">
<Title>Las vistas y el sistema de reglas.</Title>

<Sect2>
<Title>Implementación de las vistas en 
<ProductName>Postgres</ProductName></Title>

<Para>
    Las vistas en <ProductName>Postgres</ProductName> se implementan 
    utilizando el sistema de reglas. De hecho, no hay diferencia entre

<ProgramListing>
    CREATE VIEW myview AS SELECT * FROM mytab;
</ProgramListing>

    y la secuencia:

<ProgramListing>
    CREATE TABLE myview
    (<Replaceable>la misma lista de atributos de mytab</Replaceable>);
    CREATE RULE "_RETmyview" AS ON SELECT TO myview DO INSTEAD
        SELECT * FROM mytab;
</ProgramListing>

    Porque esto es exactamente lo que hace internamente el comando CREATE VIEW.
    Esto tiene algunos efectos colaterales. Uno de ellos es que la información
    sobre una vista en el sistema de catálogos de
    <ProductName>Postgres</ProductName> es exactamente la misma que para una
    tabla. De este modo, para el analizador de queries, no hay diferencia
    entre una tabla y una vista, son lo mismo: relaciones. Esto es lo más
    importante por ahora.
</Para>
</Sect2>

<Sect2>
<Title>Cómo trabajan las reglas de SELECT</Title>

<Para>
    Las reglas ON SELECT se aplican a todas las queries como el último paso,
    incluso si el comando dado es INSERT, UPDATE o DELETE. Y tienen diferentes
    semánticas de las otras en las que modifican el árbol de traducción en
    lugar de crear uno nuevo. Por ello, las reglas SELECT se describen las
    primeras.
</Para>

<Para>
    Actualmente, debe haber sólo una acción en una regla ON SELECT, y debe
    ser una SELECT incondicional que sea INSTEAD.
    Esta restricción se requería para hacer las reglas seguras
    contra la apertura por usuarios ordinarios, y restringe las reglas
    ON SELECT a reglas para vistas reales.
</Para>

<Para>
    Los ejemplos para este documento son dos vistas unidas que hacen algunos
    cálculos y algunas otras vistas utilizadas para ello. Una de estas dos
    primeras vistas se personaliza más tarde añadiendo reglas para operaciones
    de INSERT, UPDATE y DELETE de modo que el resultado final será una vista
    que se comporta como una tabla real con algunas funcionalidades mágicas.
    No es un ejemplo fácil para empezar, y quizá sea demasiado duro. Pero es
    mejor tener un ejemplo que cubra todos los puntos discutidos paso a paso
    que tener muchos ejemplos diferentes que tener que mezclar después.
</Para>

<Para>
    La base de datos necesaria para ejecutar los ejemplos se llama al_bundy.
    Verá pronto el porqué de este nombre. Y necesita tener instalado el
    lenguaje procedural PL/pgSQL, ya que necesitaremos una pequeña función
    min() que devuelva el menor de dos valores enteros.
    Creamos esta función como:

<ProgramListing>
    CREATE FUNCTION min(integer, integer) RETURNS integer AS
        'BEGIN
            IF $1 < $2 THEN
                RETURN $1;
            END IF;
            RETURN $2;
        END;'
    LANGUAGE 'plpgsql';
</ProgramListing>
</Para>

<Para>
    Las tablas reales que necesitaremos en las dos primeras descripciones del
    sistema de reglas son estas:

<ProgramListing>
    CREATE TABLE shoe_data (      -- datos de zapatos
        shoename   char(10),      -- clave primaria (primary key)
        sh_avail   integer,       -- número de pares disponibles
        slcolor    char(10),      -- color de cordón preferido
        slminlen   float,         -- longitud mínima de cordón
        slmaxlen   float,         -- longitud máxima del cordón
        slunit     char(8)        -- unidad de longitud
    );

    CREATE TABLE shoelace_data (  -- datos de cordones de zapatos
        sl_name    char(10),      -- clave primaria (primary key)
        sl_avail   integer,       -- número de pares disponibles
        sl_color   char(10),      -- color del cordón
        sl_len     float,         -- longitud del cordón
        sl_unit    char(8)        -- unidad de longitud
    );

    CREATE TABLE unit (           -- unidades de longitud
        un_name    char(8),       -- clave primaria (primary key)
        un_fact    float          -- factor de transformación a cm
    );
</ProgramListing>

    Pienso que la mayoría de nosotros lleva zapatos, y puede entender que
    este es un ejemplo de datos realmente útiles. Bien es cierto que hay
    zapatos en el mundo que no necesitan cordones, pero eso no hará la vida
    de Al más fácil así que los ignoramos.
</Para>

<Para>
    Las vistas las crearemos como:

<ProgramListing>
    CREATE VIEW shoe AS
        SELECT sh.shoename,
               sh.sh_avail,
               sh.slcolor,
               sh.slminlen,
               sh.slminlen * un.un_fact AS slminlen_cm,
               sh.slmaxlen,
               sh.slmaxlen * un.un_fact AS slmaxlen_cm,
               sh.slunit
          FROM shoe_data sh, unit un
         WHERE sh.slunit = un.un_name;

    CREATE VIEW shoelace AS
        SELECT s.sl_name,
               s.sl_avail,
               s.sl_color,
               s.sl_len,
               s.sl_unit,
               s.sl_len * u.un_fact AS sl_len_cm
          FROM shoelace_data s, unit u
         WHERE s.sl_unit = u.un_name;

    CREATE VIEW shoe_ready AS
        SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM shoe rsh, shoelace rsl
          WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm >= rsh.slminlen_cm
           AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
</ProgramListing>

    El comando CREATE VIEW para la vista <Filename>shoelace</Filename>
    (que es la más simple que tenemos) creará una relación shoelace y
    una entrada en <FileName>pg_rewrite</FileName> que dice que hay una
    regla de reescritura que debe ser aplicada siempre que la relación
    shoelace sea referida en la tabla de rango de una query. La regla
    no tiene cualificación de regla (discutidas más adelante en las reglas
    no SELECT, puesto que las reglas SELECT no pueden tenerlas) y es de tipo
    INSTEAD (en vez de). ¡Nótese que la cualificación de las reglas no son lo
    mismo que las cualificación de las queries! La acción de la regla
    tiene una cualificación de query.
</Para>

<Para>
    La acción de la regla es un árbol de query que es una copia exacta
    de la instrucción SELECT en el comando de creación de la vista.

    <Note>
    <Title>Nota:</Title>
    <Para>
    Las dos tablas de rango extra para NEW y OLD (llamadas *NEW* y *CURRENT*
    por razones históricas en el árbol de query escrito) que se pueden ver
    en la entrada <Filename>pg_rewrite</Filename> no son de interes para las
    reglas de SELECT.
    </Para>
    </Note>

    Ahora llenaremos <Filename>unit</Filename>, <Filename>shoe_data</Filename>
    y <Filename>shoelace_data</Filename> y Al (el propietario de al_bundy)
    teclea su primera SELECT en esta vida.

<ProgramListing>
    al_bundy=> INSERT INTO unit VALUES ('cm', 1.0);
    al_bundy=> INSERT INTO unit VALUES ('m', 100.0);
    al_bundy=> INSERT INTO unit VALUES ('inch', 2.54);
    al_bundy=>
    al_bundy=> INSERT INTO shoe_data VALUES
    al_bundy->     ('sh1', 2, 'black', 70.0, 90.0, 'cm');
    al_bundy=> INSERT INTO shoe_data VALUES
    al_bundy->     ('sh2', 0, 'black', 30.0, 40.0, 'inch');
    al_bundy=> INSERT INTO shoe_data VALUES
    al_bundy->     ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
    al_bundy=> INSERT INTO shoe_data VALUES
    al_bundy->     ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
    al_bundy=>
    al_bundy=> INSERT INTO shoelace_data VALUES
    al_bundy->     ('sl1', 5, 'black', 80.0, 'cm');
    al_bundy=> INSERT INTO shoelace_data VALUES
    al_bundy->     ('sl2', 6, 'black', 100.0, 'cm');
    al_bundy=> INSERT INTO shoelace_data VALUES
    al_bundy->     ('sl3', 0, 'black', 35.0 , 'inch');
    al_bundy=> INSERT INTO shoelace_data VALUES
    al_bundy->     ('sl4', 8, 'black', 40.0 , 'inch');
    al_bundy=> INSERT INTO shoelace_data VALUES
    al_bundy->     ('sl5', 4, 'brown', 1.0 , 'm');
    al_bundy=> INSERT INTO shoelace_data VALUES
    al_bundy->     ('sl6', 0, 'brown', 0.9 , 'm');
    al_bundy=> INSERT INTO shoelace_data VALUES
    al_bundy->     ('sl7', 7, 'brown', 60 , 'cm');
    al_bundy=> INSERT INTO shoelace_data VALUES
    al_bundy->     ('sl8', 1, 'brown', 40 , 'inch');
    al_bundy=>
    al_bundy=> SELECT * FROM shoelace;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl1       |       5|black     |    80|cm      |       80
    sl2       |       6|black     |   100|cm      |      100
    sl7       |       7|brown     |    60|cm      |       60
    sl3       |       0|black     |    35|inch    |     88.9
    sl4       |       8|black     |    40|inch    |    101.6
    sl8       |       1|brown     |    40|inch    |    101.6
    sl5       |       4|brown     |     1|m       |      100
    sl6       |       0|brown     |   0.9|m       |       90
    (8 rows)
</ProgramListing>
    Esta es la SELECT más sencilla que Al puede hacer en sus vistas,
    de modo que nosotros la tomaremos para explicar la base de las
    reglas de las vistas. 'SELECT * FROM shoelace' fue interpretado
    por el analizador y produjo un árbol de traducción:

<ProgramListing>
    SELECT shoelace.sl_name, shoelace.sl_avail,
           shoelace.sl_color, shoelace.sl_len,
           shoelace.sl_unit, shoelace.sl_len_cm
      FROM shoelace shoelace;
</ProgramListing>

    y este se le dá al sistema de reglas. El sistema de reglas viaja
    a través de la tabla de rango, y comprueba si hay reglas en
    <Filename>pg_rewrite</Filename> para alguna relación. Cuando se
    procesa las entradas en la tabla de rango para
    <Filename>shoelace</Filename> (el único hasta ahora) encuentra la regla
    '_RETshoelace' con el árbol de traducción

<ProgramListing>
    <FirstTerm>SELECT s.sl_name, s.sl_avail,
           s.sl_color, s.sl_len, s.sl_unit,
           float8mul(s.sl_len, u.un_fact) AS sl_len_cm
      FROM shoelace *OLD*, shoelace *NEW*,
           shoelace_data s, unit u
     WHERE bpchareq(s.sl_unit, u.un_name);</FirstTerm>
</ProgramListing>

    Nótese que el analizador cambió el cálculo y la cualificación por llamadas
    a las funciones apropiadas. Pero de hecho esto no cambia nada.
    </Para>
    <Para>
    Para expadir la vista, el reescritor simplemente crea una entrada de tabla
    de rango con una subselect que contiene el árbol de acciones de la regla, y
    sustituye esta tabla de rango por la original a la que se refería la vista.
    El árbol resultante es el mismo que si Al hubiese tecleado:

<ProgramListing>
    SELECT shoelace.sl_name, shoelace.sl_avail,
           shoelace.sl_color, shoelace.sl_len,
           shoelace.sl_unit, shoelace.sl_len_cm
      FROM (SELECT s.sl_name,
                   s.sl_avail,
                   s.sl_color,
                   s.sl_len,
                   s.sl_unit,
                   s.sl_len * u.un_fact AS sl_len_cm
              FROM shoelace_data s, unit u
             WHERE s.sl_unit = u.un_name) shoelace;
</ProgramListing>
  De todas formas hay una diferencia: la tabla de rango de la subquery tiene
  dos entradas extra: shoelace *OLD* y shoelace *NEW*. Entas entradas no
  participan directamente en la query ya que no están referenciadas por el
  árbol de la subquery ni la lista de campos. El reescritor los usa para
  almacenar la información de comprobación de permisos que estaba presente en
  la tabla de rango referenciada por la vista. De esta forma, el ejecutor
  puede todavia comprobar que el usuario tiene los permisos adecuados para
  acceder a la vista, incluso aunque no hay utilización directa de la vista
  en el query reescrito.
</Para>
<Para>
  Esta fué la primera regla aplicada. El sistema de reglas continuará
  comprobando las siguientes entradas en la tabla de rango en la query superior
  (en este ejemplo no hay más), e irá recursivamente comprobando las tablas de
  rango en el subquery añadido para ver si alguno referencia vistas (pero no
  expandirá *OLD* ni *NEW*, si no, generaría una recursión infinita). En este
  ejemplo no hay reglas de reescritura para shoelace_data ni unit, por lo que
  se hace una reescritura completa y el anterior sería el resultado final
  proporcionado al planificador.
</Para>

<Para>
    Ahora enfrentamos a Al al problema de que los Blues Brothers aparecen en su
    tienda y quieren comprarse zapatos nuevos, y como son los Blues Brothers,
    quieren llevar los mismos zapatos. Y los quieren llevar inmediatamente, 
    de modo que necesitan también cordones.
</Para>

<Para>
    Al necesita conocer los zapatos para los que tiene en el almacén cordones 
    en este momento (en color y en tamaño), y además para los que tenga un 
    número igual o superior a 2. Nosotros le enseñamos a realizar la consulta 
    a su base de datos:

<ProgramListing>
    al_bundy=> SELECT * FROM shoe_ready WHERE total_avail >= 2;
    shoename  |sh_avail|sl_name   |sl_avail|total_avail
    ----------+--------+----------+--------+-----------
    sh1       |       2|sl1       |       5|          2
    sh3       |       4|sl7       |       7|          4
    (2 rows)
</ProgramListing>
    
    Al es un guru de los zapatos, y sabe que sólo los zapatos de tipo sh1 le 
    sirven (los cordones sl7 son marrones, y los zapatos que necesitan cordones
    marrones no son los más adecuados para los Blues Brothers).
</Para>

<Para>
    La salida del traductor es esta vez el arbol de traducción.

<ProgramListing>
    SELECT shoe_ready.shoename, shoe_ready.sh_avail,
           shoe_ready.sl_name, shoe_ready.sl_avail,
           shoe_ready.total_avail
      FROM shoe_ready shoe_ready
     WHERE int4ge(shoe_ready.total_avail, 2);
</ProgramListing>

    La primera regla aplicada será la de la vista
    <Filename>shoe_ready</Filename> y da como resultado el árbol

<ProgramListing>
    SELECT shoe_ready.shoename, shoe_ready.sh_avail,
           shoe_ready.sl_name, shoe_ready.sl_avail,
           shoe_ready.total_avail
      FROM (SELECT rsh.shoename,
                   rsh.sh_avail,
                   rsl.sl_name,
                   rsl.sl_avail,
                   min(rsh.sh_avail, rsl.sl_avail) AS total_avail
              FROM shoe rsh, shoelace rsl
             WHERE rsl.sl_color = rsh.slcolor
               AND rsl.sl_len_cm >= rsh.slminlen_cm
               AND rsl.sl_len_cm <= rsh.slmaxlen_cm) shoe_ready
     WHERE int4ge(shoe_ready.total_avail, 2);
</ProgramListing>
    De forma parecida, las reglas para shoe y shoelace se sustituyen en la
    tabla de rango de la subquery, conduciendo a un árbol de query final
    de tres niveles:
<ProgramListing>
    SELECT shoe_ready.shoename, shoe_ready.sh_avail,
           shoe_ready.sl_name, shoe_ready.sl_avail,
           shoe_ready.total_avail
      FROM (SELECT rsh.shoename,
                   rsh.sh_avail,
                   rsl.sl_name,
                   rsl.sl_avail,
                   min(rsh.sh_avail, rsl.sl_avail) AS total_avail
              FROM (SELECT sh.shoename,
                           sh.sh_avail,
                           sh.slcolor,
                           sh.slminlen,
                           sh.slminlen * un.un_fact AS slminlen_cm,
                           sh.slmaxlen,
                           sh.slmaxlen * un.un_fact AS slmaxlen_cm,
                           sh.slunit
                      FROM shoe_data sh, unit un
                     WHERE sh.slunit = un.un_name) rsh,
                   (SELECT s.sl_name,
                           s.sl_avail,
                           s.sl_color,
                           s.sl_len,
                           s.sl_unit,
                           s.sl_len * u.un_fact AS sl_len_cm
                      FROM shoelace_data s, unit u
                     WHERE s.sl_unit = u.un_name) rsl
             WHERE rsl.sl_color = rsh.slcolor
               AND rsl.sl_len_cm >= rsh.slminlen_cm
               AND rsl.sl_len_cm <= rsh.slmaxlen_cm) shoe_ready
     WHERE int4ge(shoe_ready.total_avail, 2);
</ProgramListing>
    El planificador condensará este árbol en un query de dos niveles: el
    select inferior será "detenido" por el select del medio ya que no hay
    necesidad de procesarlos por separado. Pero el del medio permanecerá
    separado del superior porque contiene funciones agregadas. Si las
    retuviésemos cambiaríamos el comportamiento de la select superior, lo que
    no queremos. De todas formas, colapsar el árbol de query es una
    optimización que no concierne al sistema de reescritura.

    <Note>
    <Title>Nota</Title>
    <Para>
    Actualmente no hay mecanismos de parar la recursión para las
    reglas de las vistas en el sistema de reglas (sólo para las
    otras clases de reglas). Esto no es muy grave, ya que la única forma de
    meterlo en un bucle sin fin (bloqueando al cliente hasta que
    alcance el límite de memoria) es crear tablas y luego crearles reglas
    a mano con CREATE RULE de forma que una lea a la otra y la otra
    a la una. Esto no puede ocurrir con el comando CREATE VIEW, 
    porque en la primera creación de una vista la segunda aún no 
    existe, de modo que la primera vista no puede seleccionar 
    desde la segunda.
    </Para>
    </Note>
</Para>

</Sect2>

<Sect2>
<Title>Reglas de vistas en instrucciones diferentes a SELECT</Title>

<Para>
    Dos detalles del árbol de traducción no se han tocado en la 
    descripción de las reglas de vistas hasta ahora. Estos son 
    el tipo de comando (commandtype) y la relación resultado 
    (resultrelation). De hecho, las reglas de vistas no necesitan 
    esta información.
</Para>

<Para>
    Hay sólo unas pocas diferencias entre un árbol de traducción 
    para una SELECT y uno para cualquier otro comando. Obviamente, 
    tienen otros tipos de comandos, y esta vez la relación resultado 
    apunta a la entrada de la tabla de rango donde irá el resultado.
    Cualquier otra cosa es absolutamente igual. Por ello, teniendo dos
    tablas t1 y t2, con atributos a y b, los árboles de traducción para
    las dos instrucciones:

<ProgramListing>
    SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;

    UPDATE t1 SET b = t2.b WHERE t1.a = t2.a;
</ProgramListing>

    son prácticamente idénticos.

    <ItemizedList>
        <ListItem>
	<Para>
	    Las tablas de rango contienen entradas para las tablas t1 y t2.
	</Para>
        </ListItem>

        <ListItem>
	<Para>
	    Las listas de objetivos contienen una variable que apunta al
	    atributo b de la entrada de la tabla rango para la tabla t2.
	</Para>
        </ListItem>

        <ListItem>
	<Para>
	    Las expresiones de cualificación comparan los atributos a
	    de ambos rangos para la igualdad.
	</Para>
        </ListItem>
        <ListItem>
	<Para>
	    Los árboles de unión muestran una unión simple entre t1 y t2.
	</Para>
        </ListItem>

    </ItemizedList>

    La consecuencia es que ambos árboles de traducción dan lugar a
    planes de ejecución similares. En ambas hay joins entre las dos 
    tablas. Para la UPDATE, las columnas que no aparecen de la tabla 
    t1 son añadidas a la lista de objetivos por el planificador, y el
    árbol de traducción final se lee como: 

<ProgramListing>
    UPDATE t1 SET a = t1.a, b = t2.b WHERE t1.a = t2.a;
</ProgramListing>

    Y por ello el ejecutor al correr sobre la join producirá exactamente 
    el mismo juego de resultados que

<ProgramListing>
    SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;
</ProgramListing>
    
    Pero hay un pequeño problema con el UPDATE. El ejecutor no cuidará 
    de que el resultado de la join sea coherente. El sólo produce un
    juego resultante de filas. La diferencia entre un comando SELECT 
    y un comando UPDATE la manipula el llamador (caller) del ejecutor. 
    El llamador sólo conoce (mirando en el árbol de traducción) que 
    esto es una UPDATE, y sabe que su resultado deberá ir a la tabla t1. 
    Pero ¿Cuál de las filas que están ahí debe ser reemplazada por la
    nueva fila?.
</Para>

<Para>
    Para resolver este problema, se añade otra entrada a la lista de objetivos 
		en las instrucciones UPDATE (y también en DELETE). Es el identificador de
    tupla actual (current tuple id, ctid). Éste es un atributo de sistema que
    contiene el número de bloque del fichero y la posición dentro del bloque
    para cada fila. Conociendo la tabla, el ctid puede usarse para obtener la
    fila t1 original que se va a actualizar. Después de añadir el ctid a la
    lista de objetivos, el query debería parecerse a

<ProgramListing>
    SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;
</ProgramListing>
    
    Entra ahora en funcionamiento otro detalle de 
    <ProductName>Postgres</ProductName>. 
    Las filas de la tabla no son reescritas en este momento, y es por ello por 
    lo que ABORT TRANSACTION es rápido. En una Update, la nueva fila
    resultante se inserta en la tabla (tras retirarle el ctid) y en la 
    cabecera de la tupla de la fila cuyo ctid apuntaba a las entradas 
    cmax y xmax, se fija el contador de comando actual y el identificador 
    de transaccion actual. De este modo, la fila anterior se oculta y tras
    el commit de la transacción puede realmente eliminarse.
</Para>

<Para>
    Conociendo todo eso, podemos simplemente aplicar las reglas de las vistas 
    exactamente en la misma forma en cualquier comando. No hay diferencia.
</Para>
</Sect2>

<Sect2>
<Title>El poder de las vistas en <ProductName>Postgres</ProductName></Title>

<Para>
    Todo lo anterior demuestra como el sistema de reglas incorpora las 
    definiciones de las vistas en el árbol de traducción original. En el 
    segundo ejemplo, una simple SELECT de una vista creó un árbol de 
    traducción final que es una join de cuatro tablas (cada una se utiliza 
    dos veces con diferente nombre).
</Para>

<Sect3>
<Title>Beneficios</Title>

<Para>
    Los beneficios de implementar las vistas con el sistema de reglas 
    están en que el planificador tiene toda la información sobre qué
    tablas tienen que ser revisadas, más las relaciones entre estas tablas, 
    más las cualificaciones restrictivas a partir de la definición de las 
    vistas, más las cualificaciones de la query original, todo en un único 
    árbol de traducción. Y esta situación se mantiene cuando la query
    original es ya una join entre vistas. Ahora el planificador debe decidir
    cuál es la mejor ruta para ejecutar la query. Cuanta más información tenga
    el planificador, mejor será la decisión. Y el sistema de reglas
    implementado en <ProductName>Postgres</ProductName> asegura que toda
    la información sobre la query está disponible.
</Para>
</Sect3>
</Sect2>

<Sect2>
<Title>Actualizaciones sobre las vistas</Title>
<Para>
  ¿Qué sucede si se utiliza un vista en la lista de relaciones de un INSERT,
  UPDATE o DELETE?. Después de realizar las sustituciones descritas
  anteriormente, tendremos un árbol de consulta en el que la relación
  resultado apunta a una tabla de rango de una subquery. Esto no funcionará,
  por lo que el reescritor lanza un error cuando encuentra esta circunstancia.
</Para>
<Para>
  Para cambiar esto podemos definir regla que modifiquen el comportamiento de
  queries no SELECT. Este es el contenido de la siguiente sección.
</Para>
</Sect2>
</Sect1>

<Sect1 id="rules-insert">
<Title>Reglas sobre INSERT, UPDATE y DELETE</Title>

<Sect2>
<Title>Diferencias con las reglas de vistas.</Title>

<Para>
    Las reglas que se definen para ON INSERT, UPDATE y DELETE son totalmente
    diferentes de las que se han descrito en la sección anterior para las 
    vistas. Primero, su comando CREATE RULE permite más:

    <ItemizedList>
        <ListItem>
	<Para>
            Pueden no tener acción.
	</Para>
	</ListItem>

        <ListItem>
	<Para>
	    Pueden tener múltiples acciones.
	</Para>
	</ListItem>

        <ListItem>
	<Para>
	    La palabra clave INSTEAD es opcional.
	</Para>
	</ListItem>

        <ListItem>
	<Para>
	    Las pseudo-relaciones NEW y OLD se vuelven utilizables.
	</Para>
	</ListItem>

        <ListItem>
	<Para>
	    Puede haber cualificaciones a las reglas.
	</Para>
	</ListItem>
    </ItemizedList>

    Segundo, no modifican el árbol de traducción en el sitio. En lugar de ello,
    crean cero o varios árboles de traducción nuevos y pueden desechar el
    original.
</Para>
</sect2>
<Sect2>
<Title>Cómo trabajan estas reglas</Title>

<Para>
    Mantenga en mente la sintaxis

<ProgramListing>
    CREATE RULE rule_name AS ON event
        TO object [WHERE rule_qualification]
        DO [INSTEAD] [action | (actions) | NOTHING];
</ProgramListing>

    En lo que sigue, "las reglas de update" muestran reglas que están definidas
    ON INSERT, UPDATE o DELETE.
</Para>

<Para>
    Update toma las reglas aplicadas por el sistema de reglas cuando la
    relación resultado y el tipo de comando de un árbol de traducción son 
    iguales al objeto y el acontecimiento dado en el comando CREATE RULE. Para 
    reglas de update, el sistema de reglas crea una lista de árboles de 
    traducción. Inicialmente la lista de árboles de traducción está vacía. 
    Puede haber cero (palabra clave NOTHING), una o múltiples acciones. Para 
    simplificar, veremos una regla con una acción. Esta regla puede tener una 
    cualificación o no y puede ser INSTEAD o no.
</Para>

<Para>
    ¿Qué es una cualificación de una regla? Es una restricción que dice
    cuándo las acciones de una regla se deberían realizar y cuándo no. Esta
    cualficación sólo se puede referir a las pseudo-relaciones NEW y/o OLD, que
    básicamente son la relación dada como objeto (pero con unas características
    especiales).
</Para>

<Para>
    De este modo tenemos cuatro casos que producen los siguientes árboles de
    traducción para una regla de una acción:
</Para>
<Para>
    <ItemizedList>
    <ListItem>
    <Para>
        Sin cualificación ni INSTEAD:
        <ItemizedList>
	    <ListItem>
	    <Para>
	        El árbol de traducción para la acción de la regla donde se
		ha añadido la cualificación del árbol de traducción original.
	    </Para>
	    </ListItem>
	</ItemizedList>
    </Para>
    </ListItem>

    <ListItem>
    <Para>
        Sin cualificación pero con INSTEAD:
        <ItemizedList>
	    <ListItem>
	    <Para>
	        El árbol de traducción para la acción de la regla donde se
		ha añadido la cualificación del árbol de traducción original.
	    </Para>
	    </ListItem>
	</ItemizedList>
    </Para>
    </ListItem>

    <ListItem>
    <Para>
        Se da cualificación y no se da INSTEAD:
        <ItemizedList>
    <ListItem>
    <Para>
        El árbol de traducción de la acción de la regla donde se han
        añadido la cualificación de la regla y la cualificación del árbol
        de traducción original.
      </Para>
    </ListItem>
</ItemizedList>
   </Para>
   </ListItem>

   <ListItem>
   <Para>
        Se da cualificación y se da INSTEAD:
       <ItemizedList>
    <ListItem>
    <Para>
        El árbol de traducción de la acción de la regla donde se han
        añadido la cualificación de la regla y la cualificación del árbol de
        traducción original.
    </Para>
    </ListItem>

    <ListItem>
    <Para>
        El árbol de traducción original al que se le ha añadido la
cualificación de la regla negada.
    </Para>
    </ListItem>
  </ItemizedList>
   </Para>
   </ListItem>
   </ItemizedList>
</para>
<Para>
    Finalmente, si la regla no es INSTEAD, el árbol de traducción original sin
    cambiar se añade a la lista. Puesto que sólo las reglas INSTEAD
    cualificadas se añaden al árbol de traducción original, podemos terminar
    con uno o dos árboles de traducción de salida para una regla con una
    acción.
</Para>

<Para>
    Los árboles de traducción generados a partir de las acciones de las reglas
    se colocan en el sistema de reescritura de nuevo, y puede ser que otras
    reglas aplicadas resulten en más o menos árboles de traducción.
    De este modo, los árboles de traducción de las acciones de las reglas
    deberían tener bien otro tipo de comando, bien otra relación resultado. De
    otro modo, este proceso recursivo terminaría en un bucle. Hay un límite de
    recursiones compiladas actualmente de 10 iteraciones. Si tras 10
    iteraciones aún sigue habiendo reglas de update para aplicar, el sistema de
    reglas asumirá que se ha producido un bucle entre muchas definiciones de
    reglas y aborta la transacción.
</Para>

<Para>
    Los árboles de traducción encontrados en las acciones del catálogo de
    sistema <Filename>pg_rewrite</Filename> son sólo plantillas. Al poder
    referenciar las entradas en la tabla de rango para NEW y OLD, se deberán
    hacer algunas sustituciones antes de que se puedan utilizar. Para
    cualquier referencia a NEW, la lista de objetivos de la query original se
    revisa busando una entrada correspondiente. Si se encuentra, esa expresión
    de entrada reemplaza a la referencia. En caso contrario, NEW significará
    lo mismo que OLD (para un UPDATE) o se reemplaza por NULL (para un INSERT).
    Cualquier referencia a OLD se reemplaza por una referencia a
    la entrada de la tabla de rango que es la relación resultado.
</Para>
<Para>
    Después de aplicar las regla de actualización, se aplican las reglas de
    vista al árbol (o árboles) de traducción generado(s). Las vistas no pueden
    añadir nuevas reglas de actualización por lo que no hay necesidad de
    aplicarlas a la salida de la reescritura de la vista.
</Para>

<Sect3>
<Title>Una primera regla paso a paso.</Title>

<Para>
    Queremos tracear los cambios en la columna sl_avail de la relación
    <Filename>shoelace_data</Filename>. Para ello, crearemos una tabla de log,
    y una regla que escriba las entradas condicionalmente cada vez que se
    realice una UPDATE sobre <Filename>shoelace_data</Filename>.

<ProgramListing>
    CREATE TABLE shoelace_log (
        sl_name    char(10),      -- cordón del zapato cambiado
        sl_avail   integer,       -- nueva cantidad disponible
        log_who    text,          -- quién lo hizo
        log_when   timestamp      -- cuando lo hizo
    );

    CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
        WHERE NEW.sl_avail != OLD.sl_avail
        DO INSERT INTO shoelace_log VALUES (
                                        NEW.sl_name,
                                        NEW.sl_avail,
                                        current_user,
                                        current_timestamp
                                    );
</ProgramListing>
</Para>

<Para>
    Ahora Al hace lo siguiente

<ProgramListing>
    al_bundy=> UPDATE shoelace_data SET sl_avail = 6
    al_bundy->     WHERE sl_name = 'sl7';
</ProgramListing>

    y nosotros miramos en la tabla de log.

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace_log;
    sl_name   |sl_avail|log_who|log_when                        
    ----------+--------+-------+--------------------------------
    sl7       |       6|Al     |Tue Oct 20 16:14:45 1998 MET DST
    (1 row)
</ProgramListing>

    Que es justo lo que nosotros esperábamos. Veamos qué ha ocurrido en la 
    sombra. El traductor creó un árbol de traducción (esta vez la parte del 
    árbol de traducción original está resaltada porque la base de las operación
    es la acción de la regla para las reglas de update)

<ProgramListing>
    <FirstTerm>UPDATE shoelace_data SET sl_avail = 6
      FROM shoelace_data shoelace_data
     WHERE bpchareq(shoelace_data.sl_name, 'sl7');</FirstTerm>
</ProgramListing>

    Hay una regla para 'log_shoelace' que es ON UPDATE con la expresión de
    cualificación de la regla:

<ProgramListing>
    int4ne(NEW.sl_avail, OLD.sl_avail)
</ProgramListing>

    y una acción

<ProgramListing>
    INSERT INTO shoelace_log VALUES(
           *NEW*.sl_name, *NEW*.sl_avail,
           current_user, current_timestamp
      FROM shoelace_data *NEW*, shoelace_data *OLD*;
</ProgramListing>

    Tiene un aspecto extraño ya que normalmente se escribe INSERT ... VALUES
    ... FROM. Esta cláusula FROM indica que hay entrada de la tabla de rango
    con *NEW* y *OLD*. Son necesarias así que pueden referenciarse por
    variables en el árbol de query del comando INSERT.
</Para>

<Para>
    La regla es una regla no-INSTEAD cualificada, de modo que el sistema de
    reglas deberá devolver dos árboles de traducción: la acción de la regla
    modificada y el árbol de traducción original. En el primer paso, la tabla 
    de rango de la query original se incorpora al árbol de traducción de la
    acción de la regla. Esto da como resultado

<ProgramListing>
    INSERT INTO shoelace_log VALUES(
           *NEW*.sl_name, *NEW*.sl_avail,
           current_user, current_timestamp
      FROM shoelace_data *NEW*, shoelace_data *OLD*,
           <FirstTerm>shoelace_data shoelace_data</FirstTerm>;
</ProgramListing>

    En el segundo paso, se añade la cualificación de la regla, de modo que el 
    resultado se restringe a las filas en las que sl_avail cambia.

<ProgramListing>
    INSERT INTO shoelace_log VALUES(
           *NEW*.sl_name, *NEW*.sl_avail,
           current_user, current_timestamp
      FROM shoelace_data *NEW*, shoelace_data *OLD*,
           shoelace_data shoelace_data
     <FirstTerm>WHERE int4ne(*NEW*.sl_avail, *OLD*.sl_avail)</FirstTerm>;
</ProgramListing>
    Esto tiene un aspecto extraño, ya que INSERT ... VALUES no tiene claúsula
    WHERE, pero el planificador y el ejecutor no encuentran deficultad con ello.
    Necesitan soportar esta misma funcionalidad con INSERT ... SELECT.

    En el tercer paso, se añade la cualificación de los árboles de traducción
    originales, restringiendo el juego de resultados más aún, a sólo las filas
    tocadas por el árbol de traducción original.

<ProgramListing>
    INSERT INTO shoelace_log VALUES(
           *NEW*.sl_name, *NEW*.sl_avail,
           current_user, current_timestamp
      FROM shoelace_data *NEW*, shoelace_data *OLD*,
           shoelace_data shoelace_data
     WHERE int4ne(*NEW*.sl_avail, *OLD*.sl_avail)
       <FirstTerm>AND bpchareq(shoelace_data.sl_name, 'sl7')</FirstTerm>;
</ProgramListing>

    En el paso cuatro se sustituyen las referencias NEW por las entradas de la
    lista de objetivos del árbol de traducción original o con las referencias a 
    variables correspondientes de la relación resultado.

<ProgramListing>
    INSERT INTO shoelace_log VALUES(
           <FirstTerm>shoelace_data.sl_name</FirstTerm>, <FirstTerm>6</FirstTerm>,
           current_user, current_timestamp
      FROM shoelace_data *NEW*, shoelace_data *OLD*,
           shoelace_data shoelace_data
     WHERE int4ne(<FirstTerm>6</FirstTerm>, *OLD*.sl_avail)
       AND bpchareq(shoelace_data.sl_name, 'sl7');
</ProgramListing>

    El paso 5 reemplaza las referencias OLD por referencias en la relación
    resultado.

<ProgramListing>
    INSERT INTO shoelace_log VALUES(
           shoelace_data.sl_name, 6,
           current_user, current_timestamp
      FROM shoelace_data *NEW*, shoelace_data *OLD*,
           shoelace_data shoelace_data
     WHERE int4ne(6, <FirstTerm>shoelace_data.sl_avail</FirstTerm>)
       AND bpchareq(shoelace_data.sl_name, 'sl7');
</ProgramListing>

    Ya está. Al no ser la regla de tipo INSTEAD, también generamos el árbol de
    traducción original. Resumiendo, la salida del sistema de
    reglas es una lista de dos árboles de traducción que son lo mismo que las 
    instrucciones:

<ProgramListing>
    INSERT INTO shoelace_log VALUES(
           shoelace_data.sl_name, 6,
           current_user, current_timestamp
      FROM shoelace_data
     WHERE 6 != shoelace_data.sl_avail
       AND shoelace_data.sl_name = 'sl7';

    UPDATE shoelace_data SET sl_avail = 6
     WHERE sl_name = 'sl7';
</ProgramListing>

    Estas con ejecutadas en este orden y eso es exactamente lo que la regla 
    define. Las sustituciones y las cualificaciones añadidas aseguran que si la
    query original fuese, digamos,

<ProgramListing>
    UPDATE shoelace_data SET sl_color = 'green'
     WHERE sl_name = 'sl7';
</ProgramListing>

    no se habría escrito ninguna entrada en la tabla de log. En esta ocasión el
    árbol de traducción original no contiene una entrada de la lista de 
		objetivos para sl_avail, de modo que NEW.sl_avail será reemplazada por 
    shoelace_data.sl_avail resultando en la query adicional

<ProgramListing>
    INSERT INTO shoelace_log VALUES(
           shoelace_data.sl_name, <FirstTerm>shoelace_data.sl_avail</FirstTerm>,
           current_user, current_timestamp)
      FROM shoelace_data
     WHERE <FirstTerm>shoelace_data.sl_avail</FirstTerm> != shoelace_data.sl_avail
       AND shoelace_data.sl_name = 'sl7';
</ProgramListing>

    y esa cualificación nunca será cierta. Eso funcionará también si la query
    original modificaba multiples filas, por lo que si Al utilizara este
    comando:

<ProgramListing>
    UPDATE shoelace_data SET sl_avail = 0
     WHERE sl_color = 'black';
</ProgramListing>

    serán actualizadas cuatro filas (sl1, sl2, sl3 y sl4). Pero sl3 ya tiene
    sl_avail = 0. Esta vez, la cualificación del árbol de traducción
    original es diferente y se produce el árbol:

<ProgramListing>
    INSERT INTO shoelace_log SELECT
           shoelace_data.sl_name, 0,
           current_user, current_timestamp
      FROM shoelace_data
     WHERE 0 != shoelace_data.sl_avail
       AND <FirstTerm>shoelace_data.sl_color = 'black'</FirstTerm>;
</ProgramListing>

    Este árbol de traducción insertará tres nuevas entradas de la
    tabla de log. Y eso es absolutamente correcto.
</Para>

<Para>
    Es importante recordar que el árbol de traducción original se ejecuta el 
    último. El "agente de tráfico" de <ProductName>Postgres</ProductName> 
    incrementa el contador de comandos entre la ejecución de los dos árboles de
    traducción, de modo que el segundo puede ver cambios realizados por el 
    primero. Si la UPDATE hubiera sido ejecutada primero, todas las filas 
    estarían ya a 0, de modo que la INSERT del logging no habría encontrado 
    ninguna fila para las que shoelace_data.sl_avail != 0: no habría dejado 
    ningún rastro.
</Para>
</Sect3>

</Sect2>

<Sect2>
<Title>Cooperación con las vistas</Title>

<Para>
    Una forma sencilla de proteger las relaciones de vista de la mencionada
    posibilidad de que alguien pueda hacer INSERT, UPDATE y DELETE sobre ellas
    es hacer que esos árboles de traducción sean desechados.
    Creamos las reglas

<ProgramListing>
    CREATE RULE shoe_ins_protect AS ON INSERT TO shoe
        DO INSTEAD NOTHING;
    CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe
        DO INSTEAD NOTHING;
    CREATE RULE shoe_del_protect AS ON DELETE TO shoe
        DO INSTEAD NOTHING;
</ProgramListing>

    Si Al ahora intenta hacer cualquiera de estas operaciones en la relación 
    vista <Filename>shoe</Filename>, el sistema de reglas aplicará las reglas.
    Una vez que las reglas no tiene acciones y son INSTEAD, la lista resultante
    de árboles de traducción estará vacía, y la query no devolverá nada, debido
    a que no hay nada para ser optimizado o ejecutado tras la actuación del 
    sistema de reglas.

    <Note>
    <Title>Nota</Title>
    <Para>
    Esta via de solución irritaría a las aplicaciones cliente, ya que no ocurre
    absolutamente nada en la base de datos, y por ello, el servidor no devuelve
    nada para la query. Ni siquiera un PGRES_EMPTY_QUERY o similar estará
    disponible en libpq. En psql, no ocurre nada. Esto debería cambiar en el
    futuro.
    </Para>
    </Note>

</Para>

<Para>
    Una forma más sofisticada de utilizar el sistema de reglas es crear reglas 
    que reescriban el árbol de traducción en uno que haga la operación correcta
    en las tablas reales. Para hacer esto en la vista 
    <Filename>shoelace</Filename>, crearemos las siguientes reglas: 

<ProgramListing>
    CREATE RULE shoelace_ins AS ON INSERT TO shoelace
        DO INSTEAD
        INSERT INTO shoelace_data VALUES (
               NEW.sl_name,
               NEW.sl_avail,
               NEW.sl_color,
               NEW.sl_len,
               NEW.sl_unit);

    CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
        DO INSTEAD
        UPDATE shoelace_data SET
               sl_name = NEW.sl_name,
               sl_avail = NEW.sl_avail,
               sl_color = NEW.sl_color,
               sl_len = NEW.sl_len,
               sl_unit = NEW.sl_unit
         WHERE sl_name = OLD.sl_name;

    CREATE RULE shoelace_del AS ON DELETE TO shoelace
        DO INSTEAD
        DELETE FROM shoelace_data
         WHERE sl_name = OLD.sl_name;
</ProgramListing>

    Ahora llega un paquete de cordones de zapatos a la tienda de Al, y el tiene
    una gran lista de artículos. Al no es particularmente bueno haciendo 
    cálculos, y no lo queremos actualizando manualmente la vista shoelace. En 
    su lugar, creamos dos tablas pequeñas, una donde él pueda insertar los 
    datos de la lista de artículos, y otra con un truco especial. 
    Los comandos CREATE completos son:

<ProgramListing>
    CREATE TABLE shoelace_arrive (
        arr_name    char(10),
        arr_quant   integer
    );

    CREATE TABLE shoelace_ok (
        ok_name     char(10),
        ok_quant    integer
    );

    CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
        DO INSTEAD
        UPDATE shoelace SET
               sl_avail = sl_avail + NEW.ok_quant
         WHERE sl_name = NEW.ok_name;
</ProgramListing>

    ahora Al puede sentarse y hacer algo como:

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace_arrive;
    arr_name  |arr_quant
    ----------+---------
    sl3       |       10
    sl6       |       20
    sl8       |       20
    (3 rows)
</ProgramListing>

    Que es exactamente lo que hay en la lista de artículos. Daremos una
    rápida mirada en los datos actuales.
    
<ProgramListing>
    al_bundy=> SELECT * FROM shoelace ORDER BY sl_name;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl1       |       5|black     |    80|cm      |       80
    sl2       |       6|black     |   100|cm      |      100
    sl7       |       6|brown     |    60|cm      |       60
    sl3       |       0|black     |    35|inch    |     88.9
    sl4       |       8|black     |    40|inch    |    101.6
    sl8       |       1|brown     |    40|inch    |    101.6
    sl5       |       4|brown     |     1|m       |      100
    sl6       |       0|brown     |   0.9|m       |       90
    (8 rows)
</ProgramListing>

    trasladamos los cordones recien llegados:

<ProgramListing>
    al_bundy=> INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;
</ProgramListing>

    y comprobamos los resultados:

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace ORDER BY sl_name;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl1       |       5|black     |    80|cm      |       80
    sl2       |       6|black     |   100|cm      |      100
    sl7       |       6|brown     |    60|cm      |       60
    sl4       |       8|black     |    40|inch    |    101.6
    sl3       |      10|black     |    35|inch    |     88.9
    sl8       |      21|brown     |    40|inch    |    101.6
    sl5       |       4|brown     |     1|m       |      100
    sl6       |      20|brown     |   0.9|m       |       90
    (8 rows)

    al_bundy=> SELECT * FROM shoelace_log;
    sl_name   |sl_avail|log_who|log_when                        
    ----------+--------+-------+--------------------------------
    sl7       |       6|Al     |Tue Oct 20 19:14:45 1998 MET DST
    sl3       |      10|Al     |Tue Oct 20 19:25:16 1998 MET DST
    sl6       |      20|Al     |Tue Oct 20 19:25:16 1998 MET DST
    sl8       |      21|Al     |Tue Oct 20 19:25:16 1998 MET DST
    (4 rows)
</ProgramListing>

    Hay un largo camino desde el INSERT ... SELECT a estos
    resultados. Y su descripción será la última en este documento (pero no el 
    último ejemplo :-). Primero estaba la salida de los analizadores:

<ProgramListing>
    INSERT INTO shoelace_ok SELECT
           shoelace_arrive.arr_name, shoelace_arrive.arr_quant
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;
</ProgramListing>

    Ahora se aplica la primera regla 'shoelace_ok_in' y se vuelve:

<ProgramListing>
    UPDATE shoelace SET
           sl_avail = int4pl(shoelace.sl_avail, shoelace_arrive.arr_quant)
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
           shoelace_ok *OLD*, shoelace_ok *NEW*,
           shoelace shoelace
     WHERE bpchareq(shoelace.sl_name, showlace_arrive.arr_name);
</ProgramListing>

    y lanza otra vez la INSERT original sobre <Filename>shoelace_ok</Filename>.
    Esta query reescrita se pasa al sistema de reglas de nuevo, y la aplicación
    de la segunda regla 'shoelace_upd' produce

<ProgramListing>
    UPDATE shoelace_data SET
           sl_name = shoelace.sl_name,
           sl_avail = int4pl(shoelace.sl_avail, shoelace_arrive.arr_quant),
           sl_color = shoelace.sl_color,
           sl_len = shoelace.sl_len,
           sl_unit = shoelace.sl_unit
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
           shoelace_ok *OLD*, shoelace_ok *NEW*,
           shoelace shoelace, shoelace *OLD*,
           shoelace *NEW*, shoelace_data showlace_data
     WHERE bpchareq(shoelace.sl_name, showlace_arrive.arr_name)
       AND bpchareq(shoelace_data.sl_name, shoelace.sl_name);
</ProgramListing>

    Otra vez es una regla INSTEAD, y el árbol de traducción anterior se 
    deshecha. Nótese que esta query aún utiliza la vista 
    <Filename>shoelace</Filename>. Pero el sistema de reglas no ha terminado 
    con esta vuelta, de modo que continúa y aplica la regla '_RETshoelace', 
    produciendo

<ProgramListing>
    UPDATE shoelace_data SET
           sl_name = s.sl_name,
           sl_avail = int4pl(s.sl_avail, shoelace_arrive.arr_quant),
           sl_color = s.sl_color,
           sl_len = s.sl_len,
           sl_unit = s.sl_unit
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
           shoelace_ok *OLD*, shoelace_ok *NEW*,
           shoelace shoelace, shoelace *OLD*,
           shoelace *NEW*, shoelace_data showlace_data,
           shoelace *OLD*, shoelace *NEW*,
           shoelace_data s, unit u
     WHERE bpchareq(s.sl_name, showlace_arrive.arr_name)
       AND bpchareq(shoelace_data.sl_name, s.sl_name);
</ProgramListing>

    De nuevo se ha aplicado una regla de update y por ello vuelve a girar la 
    rueda, y llegamos a la ronda de reescritura número 3. Esta vez, se aplica 
    la regla 'log_shoelace', que produce el árbol de traducción extra

<ProgramListing>
    INSERT INTO shoelace_log SELECT
           s.sl_name,
           int4pl(s.sl_avail, shoelace_arrive.arr_quant),
           current_user,
           current_timestamp
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
           shoelace_ok *OLD*, shoelace_ok *NEW*,
           shoelace shoelace, shoelace *OLD*,
           shoelace *NEW*, shoelace_data showlace_data,
           shoelace *OLD*, shoelace *NEW*,
           shoelace_data s, unit u,
           shoelace_data *OLD*, shoelace_data *NEW*
           shoelace_log shoelace_log
     WHERE bpchareq(s.sl_name,  showlace_arrive.arr_name)
       AND bpchareq(shoelace_data.sl_name, s.sl_name);
       AND int4ne(int4pl(s.sl_avail, shoelace_arrive.arr_quant),
                                                    s.sl_avail);
</ProgramListing>

    Tras de lo cual, el sistema de reglas se desconecta y devuelve los árboles 
    de traducción generados. De esta forma, terminamos con dos árboles de 
    traducción finales que son iguales a las instrucciones de 
    <Acronym>SQL</Acronym>

<ProgramListing>
    INSERT INTO shoelace_log SELECT
           s.sl_name,
           s.sl_avail + shoelace_arrive.arr_quant,
           getpgusername(),
           'now'
      FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,
           shoelace_data s
     WHERE s.sl_name = shoelace_arrive.arr_name
       AND shoelace_data.sl_name = s.sl_name
       AND s.sl_avail + shoelace_arrive.arr_quant != s.sl_avail;
           
    UPDATE shoelace_data SET
           sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant
     FROM shoelace_arrive shoelace_arrive,
          shoelace_data shoelace_data,
          shoelace_data s
    WHERE s.sl_name = shoelace_arrive.sl_name
      AND shoelace_data.sl_name = s.sl_name;
</ProgramListing>

    El resultado es que los datos vienen de una relación, se insertan en otra, 
    cambian por actualizaciones una tercera, cambian por actualizaciones una 
    cuarta, más registran esa actualización final en una quinta: todo eso se 
    reduce a dos queries.
</Para>

<Para>
    Hay un pequeño detalle un tanto desagradable. Mirando en las dos queries, 
    descrubrimos que la relación <Filename>shoelace_data</Filename> aparece dos
    veces en la tabla de rango, lo que se debería reducir a una sóla. 
    El plnificador no manipula esto, y por ello el plan de ejecución para la
    salida del sistema de reglas de la INSERT será

<ProgramListing>
Nested Loop
  ->  Merge Join
        ->  Seq Scan
              ->  Sort
                    ->  Seq Scan on s
        ->  Seq Scan
              ->  Sort
                    ->  Seq Scan on shoelace_arrive
  ->  Seq Scan on shoelace_data
</ProgramListing>

    mientras que omitiendo la entrada extra a la tabla de rango debería ser

<ProgramListing>
Merge Join
  ->  Seq Scan
        ->  Sort
              ->  Seq Scan on s
  ->  Seq Scan
        ->  Sort
              ->  Seq Scan on shoelace_arrive
</ProgramListing>

    que produce exactamente las mismas entradas en la relación de log. Es 
    decir, el sistema de reglás ha probocado un barrido extra de la relación 
    <Filename>shoelace_data</Filename> absolútamente innecesario. Y el mismo 
    barrido obsoleto se produce de nuevo en la UPDATE. Pero era un trabajo 
    realmente duro hacer que todo sea posible.
</Para>

<Para>
    Una demostración final del sistema de reglas de
    <ProductName>Postgres</ProductName> y de su potencia. Hay una guapa rubia
    que vende cordones de zapatos. Y lo que Al nunca hubiese imaginado, ella no
    sólo es guapa, también es elegante, un poco demasiado elegante. Por ello
    se empeña de tiempo en tiempo en que Al pida cordones que son
    absolutamente invendibles. Esta vez ha pedido 1000 pares de cordones
    magenta, y aunque no está disponible otra clase pero se comprometió a
    comprar algunos, también ha preparado su base de datos para cordones rosa.

<ProgramListing>
    al_bundy=> INSERT INTO shoelace VALUES
    al_bundy->     ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
    al_bundy=> INSERT INTO shoelace VALUES 
    al_bundy->     ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
</ProgramListing>

    Ya que es algo que sucede con frecuencia, debe buscar lo cordones que no
    casan con ningún par de zapatos. Se podría realizar con una sentencia
    complicada cada vez o podemos preparar una vista, que sería:

<ProgramListing>
    CREATE VIEW shoelace_obsolete AS
        SELECT * FROM shoelace WHERE NOT EXISTS
            (SELECT shoename FROM shoe WHERE slcolor = sl_color);
</ProgramListing>

    cuya salida es

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace_obsolete;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl9       |       0|pink      |    35|inch    |     88.9
    sl10      |    1000|magenta   |    40|inch    |    101.6
</ProgramListing>

    Sobre los 1000 cordones magenta, deberíamos avisar a Al antes de que 
    podamos hacerlo de nuevo, pero ese es otro problema. La entrada rosa, la 
    borramos. Para hacerlo un poco más dificil para 
    <ProductName>Postgres</ProductName>, no la borramos directamente. En su 
    lugar, crearemos una nueva vista

<ProgramListing>
    CREATE VIEW shoelace_candelete AS
        SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
</ProgramListing>

    Y lo haremos de esta forma:

<ProgramListing>
    DELETE FROM shoelace WHERE EXISTS
        (SELECT * FROM shoelace_candelete
                 WHERE sl_name = shoelace.sl_name);
</ProgramListing>

    Voila:

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl1       |       5|black     |    80|cm      |       80
    sl2       |       6|black     |   100|cm      |      100
    sl7       |       6|brown     |    60|cm      |       60
    sl4       |       8|black     |    40|inch    |    101.6
    sl3       |      10|black     |    35|inch    |     88.9
    sl8       |      21|brown     |    40|inch    |    101.6
    sl10      |    1000|magenta   |    40|inch    |    101.6
    sl5       |       4|brown     |     1|m       |      100
    sl6       |      20|brown     |   0.9|m       |       90
    (9 rows)
</ProgramListing>

    Una DELETE en una vista, con una subselect como cualificación, que en total
    utiliza 4 vistas anidadas/cruzadas, donde una de ellas mismas tiene una 
    subselect de cualificación conteniendo una vista y donde se utilizan 
    columnas calculadas queda reescrita en un único árbol de traducción que 
    borra los datos requeridos de una tabla real.
</Para>

<Para>
    Pienso que hay muy pocas ocasiones en el mundo real en las que se una 
    construcción similar sea necesaria. Pero me tranquiliza un poco que esto 
    funcione.

    <Note>
    <Title>La verdad es</Title>
    <Para>
    Haciendo esto encontré otro bug mientras escribía este documento. Pero 
    tras arreglarlo comprobé un poco avergonzado que funcionaba correctamente.
    </Para>
    </Note>
</Para>
</Sect2>

</Sect1>

<Sect1 id="rules-permissions">
<Title>Reglas y permisos</Title>

<Para>
    Debido a la reescritura de las queries por el sistema de reglas de
    <ProductName>Postgres</ProductName>, se han accedido a otras tablas/vistas
    diferentes de las de la query original. Utilizando las reglas de update,
    esto puede incluir acceso de escritura a tablas.
</Para>

<Para>
    Las reglas de reescritura no tienen un propietario diferenciado. El
    propietario de una relación (tabla o vista) es automáticamente el
    propietario de las reglas de reescritura definidas para ella. El sistema de
    reglas de <ProductName>Postgres</ProductName> cambia el comportamiento del
    sistema de control de acceso de defecto. Las relaciones que se utilizan
    debido a las reglas son comprobadas con los
    permisos del propietario de la relación, no los del usuario que invoca la
    regla. Esto hace que el usuario no necesite sólo permisos para las
    tablas/vistas a las que él hace referencia en sus queries.
</Para>

<Para>
    Por ejemplo: Un usuario tiene una lista de números de teléfono en la que
    algunos son privados y otros son de interés para la secretaria en la 
    oficina. Él puede construir lo siguiente:

<ProgramListing>
    CREATE TABLE phone_data (person text, phone text, private bool);
    CREATE VIEW phone_number AS
        SELECT person, phone FROM phone_data WHERE NOT private;
    GRANT SELECT ON phone_number TO secretary;
</ProgramListing>
    
    Nadie excepto él, y el superusuario de la base de datos, pueden acceder a
    la tabla phone_data. Pero debido a la GRANT, la secretaria puede SELECT a
    través de la vista phone_number. El sistema de reglas reescribirá la SELECT
    de phone_number en una SELECT de phone_data y añade la cualificación de que
    sólo se buscan las entradas cuyo "privado" sea falso. Una vez que el 
    usuario sea el propietario de phone_number, la lectura accede a phone_data
    se comprueba contra sus permisos, y la consulta se considera autorizada. Se
    realiza también la comprobación del acceso a phone_number, pero se hace con
    el usuario que está invocando, por lo que nadie excepto el usuario y la
    secretaria pueden utilizarla.
</Para>

<Para>
    Los permisos son comprobados regla a regla. De modo que la secretaria es
    ahora la única que puede ver los números de teléfono públicos. Pero la
    secretaria puede crear otra vista y autorizar el acceso a ella al público.
    Entonces, cualquiera puede ver los datos de phone_number a través de la
    vista de la secretaria. Lo que la secretaria no puede hacer es crear una
    vista que acceda directamente a phone_data (realmente si puede, pero no
    funcionara, puesto que cada acceso abortará la transacción durante la
    comprobación de los permisos). Y tan pronto como el usuario tenga noticia
    de que la secretaria ha abierto su vista a phone_number, el puede REVOKE su
    acceso. Inmediatamente después, cualquier acceso a la vista de la
    secretaria fallará.
</Para>

<Para>
    Alguien podría pensar que este chequeo regla a regla es un agujero de
    seguridad, pero de hecho no lo es. Si esto no funcionase, la secretaria
    podría generar una tabla con las mismas columnas de phone_number y copiar
    los datos aquí todos los días. En este caso serían ya sus propios datos, y
    podría autorizar el acceso a cualquiera que ella quisiera. Un GRANT quiere
    decir "Yo Confío en Tí". Si alguien en quien confiamos hace lo anterior, es
    el momento de volver sobre nuestros pasos, y hacer el REVOKE.
</Para>

<Para>
    Este mecanismo también funciona para reglas de update. En el ejemplo de la
    sección previa, el propietario de las tablas de la base de datos de Al 
    (suponiendo que no fuera el mismo Al) podría haber autorizado (GRANT)
    SELECT, INSERT, UPDATE o DELETE a la vista shoelace a Al. Pero sólo SELECT
    en shoelace_log. La acción de la regla de escribir entradas del log sería
    ejecutada igualmente, y Al podría ver las entradas del log, pero no
    podría crear entradas falsas, ni podría manipular ni borrar las existentes.

    <Note>
    <Title>Atención</Title>
    <Para>
    GRANT ALL actualmente incluye permisos RULE. Esto permite al usuario 
    autorizado borrar la regla, hacer los cambios y reinstalarla. Pienso que 
    esto debería ser cambiado rápidamente.
    </Para>
    </Note>
</Para>
</Sect1>

<Sect1>
<Title>Reglas frente triggers</Title>

<Para>
    Son muchas las cosas que se hacen utilizando triggers que pueden hacerse 
    también utilizando el sistema de las reglas de 
    <ProductName>Postgres</ProductName>. Lo que actualmente no se puede 
    implementar a través de reglas son algunos tipos de restricciones 
    (constraints). Es posible situar una regla cualificada que reescriba una 
    query a NOTHING si el valor de la columna no aparece en otra tabla, pero 
    entonces los datos son eliminados silenciosamente, y eso no es una buena 
    idea. Si se necesitan comprobaciones para valores válidos, y en el caso de 
    aparecer un valor inválido dar un mensaje de error, eso deberá hacerse por 
    ahora con un trigger.
</Para>

<Para>
    Por otro lado, un trigger que se dispare a partir de una INSERT en una 
    vista puede hacer lo mismo que una regla, situar los datos en cualquier 
    otro sitio y suprimir la inserción en una vista. Pero no puede hacer lo 
    mismo en una UPDATE o una DELETE, porque no hay datos reales en la relación
    vista que puedan ser comprobados, y por ello el trigger nunca podría ser 
    llamado. Sólo una regla podría ayudarnos.
</Para>

<Para>
    Para los tratamientos que podrían implementarse de ambas formas, dependerá 
    del uso de la base de datos cuál sea la mejor. Un trigger se dispara para 
    cada fila afectada. Una regla manipula el árbol de traducción o genera uno 
    adicional. De modo que si se manipulan muchas filas en una instrucción, una
    regla ordenando una query adicional usualmente daría un mejor resultado que
    un trigger que se llama para cada fila individual y deberá ejecutar sus 
    operaciones muchas veces.
</Para>

<Para>
    Por ejemplo: hay dos tablas.

<ProgramListing>
    CREATE TABLE computer (
        hostname        text     -- indexed
	manufacturer    text     -- indexed
    );

    CREATE TABLE software (
        software        text,    -- indexed
        hostname        text     -- indexed
    );
</ProgramListing>
    Ambas tablas tienen muchos millares de filas y el índice sobre hostname es 
    único. La columna hostname contiene el nombre de dominio cualificado 
    completo del ordenador. La regla/trigger debería desencadenar el borrado de
    filas de la tabla software que se refieran a un host borrado. Toda vez que 
    el trigger se llama para cada fila individual borrada de computer, se puede
    usar la instrucción

<ProgramListing>
    DELETE FROM software WHERE hostname = $1;
</ProgramListing>

    en un plan preparado y salvado, y pasar el hostname en el parámetro. 
    La regla debería ser escrita como

<ProgramListing>
    CREATE RULE computer_del AS ON DELETE TO computer
        DO DELETE FROM software WHERE hostname = OLD.hostname;
</ProgramListing>

    Veremos ahora en que se diferencian los dos tipos de delete. En el caso de 
    una
    
<ProgramListing>
    DELETE FROM computer WHERE hostname = 'mypc.local.net';
</ProgramListing>

    La tabla computer se revisa por índice (rápido) y la query lanzada por el 
    trigger también debería ser un barrido de índice (rápido también). La query
    extra para la regla sería una

<ProgramListing>
    DELETE FROM software WHERE computer.hostname = 'mypc.local.net'
                           AND software.hostname = computer.hostname;
</ProgramListing>

    Puesto que se han creado los índices apropiados, el planificador creará un
    plan de

<ProgramListing>
    Nestloop
      ->  Index Scan using comp_hostidx on computer
      ->  Index Scan using soft_hostidx on software
</ProgramListing>

    De modo que no habría mucha diferencia de velocidad entre la implementación
    del trigger y de la regla. Con la siguiente delete, queremos mostrar borrar
    los 2000 ordenadores cuyo hostname empieza con 'old'. Hay dos posibles 
    queries para hacer eso. Una es

<ProgramListing>
    DELETE FROM computer WHERE hostname >= 'old'
                           AND hostname <  'ole'
</ProgramListing>
    
    Donde el plan de ejecución para la query de la regla será

<ProgramListing>
    Hash Join
      ->  Seq Scan on software
      ->  Hash
	    ->  Index Scan using comp_hostidx on computer
</ProgramListing>

    La otra query posible es   

<ProgramListing>
    DELETE FROM computer WHERE hostname ~ '^old';
</ProgramListing>

    con un plan de ejecución

<ProgramListing>
    Nestloop
      ->  Index Scan using comp_hostidx on computer
      ->  Index Scan using soft_hostidx on software
</ProgramListing>

    Esto muestra que el optimizador no comprueba que la cualificación sobre 
    hostname en computer también debería ser utilizada para un barrido por 
    índice en software donde hay múltiples expresiones de cualificación 
    combinadas con AND, que el hace en la versión regexp de la query. El 
    trigger será invocado una vez para cada una de los 2000 viejos ordenadores 
    que serán borrados, lo que dará como resultado un barrido por índice sobre 
    computer y 2000 barridos por índice sobre software. La implementación de la
    regla lo hará con dos queries sobre índices. Y dependerá del tamaño 
    promedio de la tabla software si la regla será más rápida en una situación 
    de barrido secuencial. 2000 ejecuciones de queries sobre el gestor SPI 
    toman su tiempo, incluso si todos los bloques del índice se encuentran en 
    la memoría caché.
</Para>

<Para>
    La última query que veremos es

<ProgramListing>
    DELETE FROM computer WHERE manufacurer = 'bim';
</ProgramListing>
    
    De nuevo esto debería dar como resultado muchas filas para borrar de 
    computer. Por ello el trigger disparará de nuevo muchas queries sobre el 
    ejecutor. Pero el plan de las reglas será de nuevo un bucle anidado sobre 
    dos barridos de índice. Sólo usando otro índice en computer: 

<ProgramListing>
    Nestloop
      ->  Index Scan using comp_manufidx on computer
      ->  Index Scan using soft_hostidx on software
</ProgramListing>

    dando como resultado de la query de las reglas

<ProgramListing>
    DELETE FROM software WHERE computer.manufacurer = 'bim'
                           AND software.hostname = computer.hostname;
</ProgramListing>

    En cualquiera de estos casos, las queries extra del sistema de reglas serán
    más o menos independientes del número de filas afectadas en la query.
</Para>

<Para>
    Otra situación son los casos de UPDATE donde depende del cambio de un 
    atributo si la acción debería realizarse o no. En la versión 6.4 de 
    <ProductName>Postgres</ProductName>, la especificación de atributos para 
    eventos de regla se ha deshabilitado (y tendrá su regreso en la 
    6.5, quizá antes ¡permanezcan en antena!). De modo que por ahora la única 
    forma de crear una regla como en el ejemplo de shoelace_log es hacerlo con 
    una cualificación de la regla. Eso da como resultado una query adicional que
    se realiza siempre, incluso si el atributo que nos interesa no puede ser
    cambiado de ninguna forma porque no aparece en la lista de objetivos de la 
    query inicial. Cuando se habilite de nuevo, será una nueva ventaja del
    sistema de reglas sobre los triggers. La optimización de un trigger deberá 
    fallar por definición en este caso, porque el hecho de que sus acciones
    sólo se realicen cuando un atributo específico sea actualizado, está oculto
    en su funcionalidad. La definición de un trigger sólo permite especificarlo
    a nivel de fila, de modo que cuando se toca una fila, el trigger será
    llamado a hacer su trabajo. El sistema de reglas lo sabrá mirando la lista
    de objetivos y suprimirá la query adicional por completo si el atributo no
    se ha tocado. De modo que la regla, cualificada o no, sólo hará sus
    comprobaciones si tiene algo que hacer.
</Para>

<Para>
    Las reglas sólo serán significativamente más lentas que los triggers si sus
    acciones dan como resultado joins grandes y mal cualificadas, una situación
    en la que falla el planificador. Son como un gran martillo. Utilizar un gran
    martillo sin cuidado puede causar un gran daño, pero dar el toque correcto,
    puede hundir cualquier clavo hasta la cabeza.
</Para>
</Sect1>

</Chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
