 <chapter id="sql">
  <title>SQL</title>

  <abstract>
   <para>
    Este capítulo apareció originariamente como parte de la tesis doctoral de Stefan Simkovics.
   (<xref linkend="SIM98" endterm="SIM98">).
   </para>
  </abstract>

  <para>
   <acronym>SQL</acronym> se ha convertido en el lenguaje de consulta relacional
más popular.
   El nombre <quote><acronym>SQL</acronym></quote> es una abreviatura de
<firstterm>Structured Query Language</firstterm> (Lenguaje de consulta
estructurado). En 1974 Donald Chamberlain y otros definieron el lenguaje
SEQUEL (<firstterm>Structured English Query Language</firstterm>) en IBM
Research. Este lenguaje fue implementado inicialmente en un prototipo de IBM
llamado SEQUEL-XRM en 1974-75. En 1976-77 se definió una revisión de SEQUEL
llamada SEQUEL/2 y el nombre se cambió a <acronym>SQL</acronym>.
  </para>

  <para>
   IBM desarrolló un nuevo prototipo llamado System R en 1977. System R
implementó un amplio subconjunto de SEQUEL/2 (now <acronym>SQL</acronym>) y un
número de cambios que se le hicieron a (now <acronym>SQL</acronym>) durante el
proyecto. System R se instaló en un número de puestos de usuario, tanto
internos en IBM como en algunos clientes seleccionados. Gracias al éxito y
aceptación de System R en los mismos, IBM inició el
desarrollo de productos comerciales que implementaban el lenguaje
<acronym>SQL</acronym> basado en la tecnología System R.
  </para>

  <para>
   Durante los años siguientes, IBM y bastantes otros vendedores anunciaron
productos <acronym>SQL</acronym> tales como 
   <productname>SQL/DS</productname> (IBM),
   <productname>DB2</productname> (IBM),
   <productname>ORACLE</productname> (Oracle Corp.),
   <productname>DG/SQL</productname> (Data General Corp.),
   y <productname>SYBASE</productname> (Sybase Inc.).
  </para>

  <para>
   <acronym>SQL</acronym> es también un estándar oficial hoy. En 1982, la
American National Standards Institute (<acronym>ANSI</acronym>) encargó a su
Comité de Bases de Datos X3H2 el desarrollo de una propuesta de lenguaje
relacional estándar. Esta propuesta fue ratificada en 1986 y consistía
básicamente en el dialecto de IBM de <acronym>SQL</acronym>. En 1987, este
estándar <acronym>ANSI</acronym> fue también aceptado por la Organización
Internacional de Estandarización (<acronym>ISO</acronym>).
Esta versión estándar original de <acronym>SQL</acronym> recibió informalmente
el nombre de "<abbrev>SQL/86</abbrev>". En 1989, el estándar original fue
extendido, y recibió el nuevo nombre, también informal, de
"<abbrev>SQL/89</abbrev>". También en 1989 se desarrolló un estándar
relacionado llamado <firstterm>Database Language Embedded
<acronym>SQL</acronym></firstterm> (<acronym>ESQL</acronym>).
  </para>

  <para>
   Los comités <acronym>ISO</acronym> y <acronym>ANSI</acronym> han estado
trabajando durante muchos años en la definición de una versión muy ampliada
del estándar original, llamado informalmente
<firstterm><acronym>SQL2</acronym></firstterm> o
<firstterm><acronym>SQL/92</acronym></firstterm>. Esta versión se convirtió en
un estándar ratificado durante 1992: <foreignphrase>International Standard ISO/IEC
9075:1992, Database Language <acronym>SQL</acronym></foreignphrase>.
<acronym>SQL/92</acronym> es la versión a la que normalmente la gente se
refiere cuando habla de «<acronym>SQL</acronym> estándar». Se da una
descripción detallada de <acronym>SQL/92</acronym> en  <xref linkend="DATE97"
endterm="DATE97">. En el momento de escribir este documento, se está
desarrollando un nuevo estándar denominado informalmente como
<firstterm><acronym>SQL3</acronym></firstterm>. Se plantea hacer de
<acronym>SQL</acronym> un lenguaje de alcance completo (e Turing-complete
language), es decir, serán posibles todas las consultas computables, (por ejemplo consultas
recursivas). Esta es una tarea muy compleja y por ello no se
debe esperar la finalización del nuevo estándar antes de 1999.
  </para>

  <sect1 id="rel-model">
   <title>El Modelo de Datos Relacional</title>

  <para>
    Como mencionamos antes, <acronym>SQL</acronym> es un lenguaje
relacional. Esto quiere decir que se basa en el <firstterm>modelo de
datos relacional</firstterm> publicado inicialmente por E.F.Codd en 1970.
Daremos una descripción formal del modelo de datos relacional más tarde (en
<xref linkend="formal-notion" endterm="formal-notion">), pero primero queremos
dar una mirada desde un punto de vista más intuitivo.
  </para>

  <para>
    Una <firstterm>base de datos relacional</firstterm> es una base de datos
que se percibe por los usuarios como una <firstterm>colección de
tablas</firstterm> (y nada más que tablas). Una tabla consiste en filas y
columnas, en las que cada fila representa un registro, y cada columna
representa un atributo del registro contenido en la tabla. <xref
linkend="supplier-fig" endterm="supplier-fig">  muestra un ejemplo de base de
datos consistente en tres tablas.

    <itemizedlist>
     <listitem>
      <para>
       SUPPLIER es una tabla que recoge el número
       (SNO), el nombre (SNAME) y la ciudad (CITY) de un proveedor.
      </para>
     </listitem>

     <listitem>
      <para>
       PART es una tabla que almacena el número (PNO) el nombre (PNAME) y
       el precio (PRICE) de un artículo.
      </para>
     </listitem>

     <listitem>
      <para>
       SELLS almacena información sobre qué artículo (PNO) es vendido por qué
       proveedor (SNO). 
       Esto sirve en un sentido para conectar las dos tablas entre ellas.
      </para>
     </listitem>
    </itemizedlist>

    <example>
     <title id="supplier-fig">La Base de Datos de Proveedores y
Artículos</title>
      <programlisting>
   SUPPLIER   SNO |  SNAME  |  CITY      SELLS   SNO | PNO
             -----+---------+--------           -----+-----
               1  |  Smith  | London              1  |  1
               2  |  Jones  | Paris               1  |  2
               3  |  Adams  | Vienna              2  |  4
               4  |  Blake  | Rome                3  |  1
                                                  3  |  3
                                                  4  |  2
   PART       PNO |  PNAME      |  PRICE          4  |  3 
             -----+-------------+---------        4  |  4
               1  |  Tornillos  |   10
               2  |  Tuercas    |    8
               3  |  Cerrojos   |   15
               4  |  Levas      |   25
     </programlisting>
    </example>
   </para>

   <para>
    Las tablas PART y SUPPLIER se pueden ver como 
<firstterm>entidades</firstterm> y SELLS se puede ver como una
<firstterm>relación</firstterm> entre un artículo particular y un
proveedor particular.
</para>

   <para>
    Como veremos más tarde, <acronym>SQL</acronym> opera en las tablas
tal como han sido definidas, pero antes de ello estudiaremos la teoría
del modelo relacional.
    </para>
  </sect1>

  <sect1>
   <title id="formal-notion">Formalidades del Modelo Relacional de Datos</title>

   <para>
    El concepto matemático que subyace bajo el modelo relacional es la
<firstterm>relación</firstterm> de la teoría de conjuntos, la cual es un
subconjunto del producto cartesiano de una lista de dominios. Esta relación de
la teoría de conjuntos proporciona al modelo su nombre (no confundir con la
relación del  
<firstterm>Modelo Entidad-Relación</firstterm>). Formalmente, un dominio es
simplemente un conjunto de valores. Por ejemplo, el conjunto de los enteros es
un dominio. También son ejemplos de dominios las cadenas de caracteres de
longitud 20 y los números reales.
   </para>

   <para>
<!--
\begin{definition}
El <firstterm>producto cartesiano</firstterm> de los dominios $D_{1},
D_{2},\ldots, D_{k}$ escritos \mbox{$D_{1} \times D_{2} \times \ldots \times
D_{k}$} es el conjunto de todos los $k$-tuples
$(v_{1},v_{2},\ldots,v_{k})$ tales que \mbox{$v_{1} \in D_{1}, v_{2} \in
D_{2}, \ldots, v_{k} \in D_{k}$}. \end{definition}
-->
    El <firstterm>producto cartesiano</firstterm> de los dominios
    <parameter>D<subscript>1</subscript></parameter>,
    <parameter>D<subscript>2</subscript></parameter>,
    ...
    <parameter>D<subscript>k</subscript></parameter>,
    escritos
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>
    es el conjunto de las k-tuplas
    <parameter>v<subscript>1</subscript></parameter>,
    <parameter>v<subscript>2</subscript></parameter>,
    ...
    <parameter>v<subscript>k</subscript></parameter>,
    tales que
    <parameter>v<subscript>1</subscript></parameter> &isin; 
    <parameter>D<subscript>1</subscript></parameter>,
    <parameter>v<subscript>1</subscript></parameter> &isin; 
    <parameter>D<subscript>1</subscript></parameter>,
    ...
    <parameter>v<subscript>k</subscript></parameter> &isin; 
    <parameter>D<subscript>k</subscript></parameter>.
   </para>

   <para>
    Por ejemplo, cuando tenemos
<!--
 $k=2$, $D_{1}=\{0,1\}$ y
$D_{2}=\{a,b,c\}$, entonces $D_{1} \times D_{2}$ es
$\{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)\}$.
-->
    <parameter>k</parameter>=2,
    <parameter>D<subscript>1</subscript></parameter>=<literal>{0,1}</literal> y
    <parameter>D<subscript>2</subscript></parameter>=<literal>{a,b,c}</literal>
entonces   
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> es    
    <literal>{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)}</literal>.    
   </para>

   <para>
<!--
\begin{definition}
Una relación es cualquier subconjutno del producto cartesiano de dos o más
dominios.$R \subseteq$ \mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$}
\end{definition}
-->
    
    Una Relación es cualquier subconjunto del producto cartesiano de uno o más
dominios:
    <parameter>R</parameter> &sube;
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>.
   </para>

   <para>
    Por ejemplo,  <literal>{(0,a),(0,b),(1,a)}</literal> es una relación;
    De hecho es un subconjunto de 
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter>
    mencionado antes.
   </para>

   <para>
    Los miembros de una relación se llaman tuplas. Cada relación de algún
producto cartesiano
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>
    se dice que tiene nivel <literal>k</literal> y de este modo es un
    subconjunto de <literal>k</literal>-tuplas.
    </para>

   <para>
   Una relación se puede ver como una tabla (como ya dijimos, recuerde <xref
linkend="supplier-fig" endterm="supplier-fig"> donde cada tupla se representa
como una fila y cada columna corresponde a un componente de la tupla. Dando
nombres (llamados atributos) a las columnas, nos acercamos a la definición de
un <firstterm>esquema relacional</firstterm>.
   </para>

   <para>
<!--
\begin{definition}
Un {\it esquema relacional} $R$ es un conjunto finito de atributos
\mbox{$\{A_{1},A_{2},\ldots,A_{k}\}$}. Hay un dominio $D_{i}$
para cada atributo $A_{i}, 1 \le i \le k$ de donde se toman los valores de
los atributos. Entonces escribimos un esquema relacional como
\mbox{$R(A_{1},A_{2},\ldots,A_{k})$}. \end{definition} 
-->
    Un <firstterm>esquema relacional</firstterm>
    <literal>R</literal> es un conjunto finito de atributos
    <parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>.
    Hay un dominio
    <parameter>D<subscript>i</subscript></parameter>,
    para cada atributo
    <parameter>A<subscript>i</subscript></parameter>,
    1 &lt;= <literal>i</literal> &lt;= <literal>k</literal>,
    de donde se toman los valores de los atributos. Entonces escribimos es
esquema relacional como
    <literal>R(<parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>)</literal>.

    <note>
     <para>
      Un <firstterm>esquema relacional</firstterm> es sólo un juego de plantillas
       mientras que una <firstterm>relación</firstterm> es un ejemplo de un 
       <firstterm>esquema relacional</firstterm>. La relación consiste en las tuplas
      (y pueden ser vistas como una tabla); no así el esquema relacional.      
     </para>
    </note>
   </para>

   <sect2>
    <title id="domains">Dominios contra Tipos de Datos</title>

    <para>
     Ya hemos hablado de <firstterm>dominios</firstterm> en la sección anterior.
     Recalcar que el dominio es, formalmente, un conjunto de valores (por ejemplo
     el conjunto de los enteros o el de los números reales).
     En términos de sistemas de base de datos, hemos hablado de <firstterm>tipos de datos</firstterm>
     más que de dominios. Cuando hemos definido una tabla, hemos tomado una decisión
     sobre qué atributos incluir. Adicionalmente, hemos decidido qué juego de datos 
     deberá ser almacenado en valores de los atributos. Por ejemplo, los valores de
     <classname>SNAME</classname> de la tabla <classname>SUPPLIER</classname> serán
     cadenas de caracteres, mientras que <classname>SNO</classname> almacenará enteros. 
     Definimos esto asignando un tipo de datos a cada atributo. El tipo de 
     <classname>SNAME</classname> será <type>VARCHAR(20)</type> (este es el tipo <acronym>SQL</acronym>
     para cadenas de caracteres de longitud &lt;= 20), el tipo de <classname>SNO</classname> 
     será <type>INTEGER</type>. Con la asignación de tipos de datos, también habremos 
     seleccionado un dominio para un atributo. El dominio de <classname>SNAME</classname> 
     es el conjunto de todas las cadenas de caracteres de longitud &lt;= 20, mientras el 
     dominio de <classname>SNO</classname> es el conjunto de todos los números enteros.
    </para>
   </sect2>
  </sect1>

  <sect1>
   <title id="operations">Operaciones en el Modelo de Datos Relacional</title>

   <para>
    En la sección previa  (<xref linkend="formal-notion" endterm="formal-notion">)
    definimos la noción matemática del modelo relacional. Ahora conocemos como los datos
    pueden almacenarse utilizando un modelo de datos relacional, pero no conocemos
    qué podemos hacer con todas estas tablas para recuperar algo desde esa base de
    datos todavía. Por ejemplo, alguien podría preguntar por los nombre de todos los 
    proveedores que vendan el artículo 'tornillo'. Hay dos formas diferentes de notaciones
    para expresar las operaciones entre relaciones. 


    <itemizedlist>
     <listitem>
      <para>
       El <firstterm>Álgebra Relacional</firstterm> es una notación algebraica, en la cual
       las consultas se expresan aplicando operadores especializados a las relaciones.       
      </para>
     </listitem>

     <listitem>
      <para>
       El <firstterm>Cálculo Relacional</firstterm> es una notación lógica, donde las consultas
       se expresan formulando algunas restricciones lógicas que las tuplas de la respuesta deban
       satisfacer. 
      </para>
    </listitem>
    </itemizedlist>
   </para>

   <sect2>
    <title id="rel-alg">Álgebra Relacional</title>

    <para>
     El <firstterm>Álgebra Relacional</firstterm> fue introducida por E.F.Codd en 1972.
     Consiste en un conjunto de operaciones con las relaciones.

     <itemizedlist>
      <listitem>
       <para>
	SELECT (&sigma;): extrae <firstterm>tuplas</firstterm> a partir de una relación
        que satisfagan una restricción dada. Sea <parameter>R</parameter> una tabla que 
        contiene un atributo <parameter>A</parameter>.	
	&sigma;<subscript>A=a</subscript>(R) = {t &isin; R &mid; t(A) = a}
	donde <literal>t</literal> denota una
	tupla de <parameter>R</parameter> y <literal>t(A)</literal>
	denota el valor del atributo <parameter>A</parameter> de la tupla <literal>t</literal>.
       </para>
      </listitem>

      <listitem>
       <para>
	PROJECT (&pi;): extrae <firstterm>atributos</firstterm> (columnas)
        específicos de una relación. Sea <classname>R</classname> una relación que 
	contiene un atributo <classname>X</classname>.
	&pi;<subscript>X</subscript>(<classname>R</classname>) = {t(X) &mid; t &isin; <classname>R</classname>},
	donde <literal>t</literal>(<classname>X</classname>) denota el valor del atributo
	 <classname>X</classname> de la tupla <literal>t</literal>.
       </para>
      </listitem>

      <listitem>
       <para>
	PRODUCT (&times;): construye el producto cartesiano de dos relaciones. Sea
	<classname>R</classname> una tabla de rango (arity)
	<literal>k</literal><subscript>1</subscript> y sea
	<classname>S</classname> una tabla con rango 
	(arity) <literal>k</literal><subscript>2</subscript>.
	<classname>R</classname> &times; <classname>S</classname>
	es el conjunto de las 
	<literal>k</literal><subscript>1</subscript>
	+ <literal>k</literal><subscript>2</subscript>-tuplas
	cuyos primeros <literal>k</literal><subscript>1</subscript>
	componentes forman una tupla en <classname>R</classname> y cuyos últimos
	<literal>k</literal><subscript>2</subscript> componentes forman una 
	tupla en <classname>S</classname>.
       </para>
      </listitem>

      <listitem>
       <para>
	UNION (&cup;): supone la unión de la teoría de conjuntos de dos tablas.
	Dadas las tablas <classname>R</classname> y
	<classname>S</classname> (y ambas deben ser del mismo rango),
	la unión <classname>R</classname> &cup; <classname>S</classname>
	es el conjunto de las tuplas que están en <classname>R</classname>
	<classname>S</classname> o en las dos.
       </para>
      </listitem>

      <listitem>
       <para>
	INTERSECT (&cap;): Construye la intersección de la teoría de conjuntos de dos tablas.
	Dadas las tablas <classname>R</classname> y
	<classname>S</classname>,
	<classname>R</classname> &cup; <classname>S</classname> es el conjunto de las tuplas
	que están en <classname>R</classname> y en <classname>S</classname>>.
	De nuevo requiere que <classname>R</classname> y <classname>S</classname> tengan el mismo
        rango.
       </para>
      </listitem>

      <listitem>
       <para>
	DIFFERENCE (&minus; or &setmn;): supone el conjunto diferencia de dos tablas.
	Sean <classname>R</classname> y <classname>S</classname>
	de nuevo dos tablas con el mismo rango.
	<classname>R</classname> - <classname>S</classname>
	Es el conjunto de las tuplas que están en <classname>R</classname> pero no en <classname>S</classname>.
       </para>
      </listitem>

      <listitem>
       <para>
	JOIN (&prod;): conecta dos tablas por sus atributos comunes.
	Sea <classname>R</classname> una tabla con los atributos
	<classname>A</classname>,<classname>B</classname> 
	y <classname>C</classname> y
	sea <classname>S</classname> una tabla con los atributos
	<classname>C</classname>,<classname>D</classname>
	y <classname>E</classname>. Hay un atributo común para ambas relaciones,
	el atributo <classname>C</classname>. 
<!--
	<classname>R</classname> &prod; <classname>S</classname> =
	&pi;<subscript><classname>R</classname>.<classname>A</classname>,<classname>R</classname>.<classname>B</classname>,<classname>R</classname>.<classname>C</classname>,<classname>S</classname>.<classname>D</classname>,<classname>S</classname>.<classname>E</classname></subscript>(&sigma;<subscript><classname>R</classname>.<classname>C</classname>=<classname>S</classname>.<classname>C</classname></subscript>(<classname>R</classname> &times; <classname>S</classname>)).
-->
	R &prod; S = &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S)).
	¿Qué estamos haciendo aquí? Primero calculamos el producto cartesiano
	<classname>R</classname> &times; <classname>S</classname>.
	Entonces seleccionamos las tuplas cuyos valores para el atributo común
	<classname>C</classname> sea igual
	(&sigma;<subscript>R.C = S.C</subscript>).
	Ahora tenemos una tabla que contiene el atributo <classname>C</classname>
	dos veces y lo corregimos eliminando la columna duplicada.
       </para>

       <example>
	<title id="join-example">Una Inner Join (Una Join Externa)
################### WARNING #################
¿Externa? ¿No será Interna? -- Isma.
#############################################
	</title>

	<para>
	 Veamos las tablas que se han producido evaluando los 
	 pasos necesarios para una join.
	 Sean las siguientes tablas dadas:

	 <programlisting>
         R   A | B | C      S   C | D | E
            ---+---+---        ---+---+---
             1 | 2 | 3          3 | a | b
             4 | 5 | 6          6 | c | d
             7 | 8 | 9
	 </programlisting>
	</para>
       </example>

       <para>
        Primero calculamos el producto cartesiano
	<classname>R</classname> &times; <classname>S</classname> y
	tendremos:

	<programlisting>
       R x S   A | B | R.C | S.C | D | E
              ---+---+-----+-----+---+---
               1 | 2 |  3  |  3  | a | b
               1 | 2 |  3  |  6  | c | d
               4 | 5 |  6  |  3  | a | b
               4 | 5 |  6  |  6  | c | d
               7 | 8 |  9  |  3  | a | b
               7 | 8 |  9  |  6  | c | d
	</programlisting>
       </para>

       <para>
        Tras la selección
	&sigma;<subscript>R.C=S.C</subscript>(R &times; S)
	tendremos:

	<programlisting>
               A | B | R.C | S.C | D | E
              ---+---+-----+-----+---+---
               1 | 2 |  3  |  3  | a | b
               4 | 5 |  6  |  6  | c | d
	</programlisting>
       </para>

       <para>
        Para eliminar las columnas duplicadas
	<classname>S</classname>.<classname>C</classname>
	realizamos la siguiente operación:
	&pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))
	y obtenemos:

	<programlisting>
                   A | B | C | D | E
                  ---+---+---+---+---
                   1 | 2 | 3 | a | b
                   4 | 5 | 6 | c | d
	</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
	DIVIDE (&divide;): Sea <classname>R</classname> una tabla 
	con los atributos A, B, C, y D y sea
	<classname>S</classname> una tabla con los atributos
	C y D.
	Definimos la división como:

	R &divide; S = {t &mid; &forall; t<subscript>s</subscript> &isin; S
	 &exist; t<subscript>r</subscript> &isin; R

	tal que
t<subscript>r</subscript>(A,B)=t&and;t<subscript>r</subscript>(C,D)=t<subscript>s</subscript>}
	donde
	t<subscript>r</subscript>(x,y)
	denota una tupla de la tabla
	<classname>R</classname> que consiste sólo en los componentes
	<literal>x</literal> y <literal>y</literal>.
	Nótese que la tupla <literal>t</literal> consiste sólo en los componentes
	<classname>A</classname> y <classname>B</classname> de la relación
	<classname>R</classname>.
       </para>

       <para id="divide-example">
        Dadas las siguientes tablas

	<programlisting>
          R   A | B | C | D        S   C | D
             ---+---+---+---          ---+---
              a | b | c | d            c | d
              a | b | e | f            e | f
              b | c | e | f
              e | d | c | d
              e | d | e | f
              a | b | d | e
	</programlisting>

	R &divide; S
	se deriva como

	<programlisting>
                         A | B
                        ---+---
                         a | b
                         e | d
	</programlisting>
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Para una descripción y definición más detallada del Álgebra Relacional
     diríjanse a [<xref linkend="ULL88" endterm="ULL88">] o
     [<xref linkend="DATE94" endterm="DATE94">].
    </para>

    <example>
     <title id="suppl-rel-alg">Una consulta utilizando Álgebra Relacional</title>
     <para>
      Recalcar que hemos formulado todos estos operadores relacionales como 
      capaces de recuperar datos de la base de datos. Volvamos a nuestro ejemplo
      de la sección previa (<xref linkend="operations" endterm="operations">)
      donde alguien quería conocer los nombres de todos los proveedores que 
      venden el artículo <literal>Tornillos</literal>. 
      Esta pregunta se responde utilizando el álgebra relacional con la 
      siguiente operación:

      <programlisting>
&pi;<subscript>SUPPLIER.SNAME</subscript>(&sigma;<subscript>PART.PNAME='Tornillos'</subscript>(SUPPLIER &prod; SELLS &prod; PART))
      </programlisting>
     </para>

     <para>
      Llamamos a estas operaciones una consulta. Si evaluamos la consulta anterior
      contra las tablas de nuestro ejemplo
      (<xref linkend="supplier-fig" endterm="supplier-fig">)
      obtendremos el siguiente ejemplo:

      <programlisting>
                             SNAME
                            -------
                             Smith
                             Adams
      </programlisting>
     </para>
    </example>
   </sect2>

   <sect2 id="rel-calc">
    <title>Cálculo Relacional</title>

    <para>
     El Cálculo Relacional se basa en la
     <firstterm>lógica de primer orden</firstterm>. Hay dos variantes
     del cálculo relacional:

     <itemizedlist>
      <listitem>
       <para>
        El <firstterm>Cálculo Relacional de Dominios</firstterm>
	(<acronym>DRC</acronym>), donde las variables esperan
	componentes (atributos) de las tuplas.
       </para>
      </listitem>

      <listitem>
       <para>
        El <firstterm>Cálculo Relacional de Tuplas</firstterm>
	The <firstterm>Tuple Relational Calculus</firstterm>
	(<acronym>TRC</acronym>), donde las variables esperan tuplas.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Expondremos sólo el cálculo relacional de tuplas porque es el único
     utilizado por la mayoría de lenguajes relacionales. Para una discusión
     detallada de <acronym>DRC</acronym> (y también de
     <acronym>TRC</acronym>) vea
     [<xref linkend="DATE94" endterm="DATE94">]
     o
     [<xref linkend="ULL88" endterm="ULL88">].
    </para>
   </sect2>

   <sect2>
    <title>Cálculo Relacional de Tuplas</title>

    <para>
     Las consultas utilizadas en <acronym>TRC</acronym> tienen el siguiente formato:
      x(A) &mid; F(x)

     donde <literal>x</literal> es una variable de tipo tupla,
     <classname>A</classname> es un conjunto de atributos y <literal>F</literal> es una
     fórmula. La relación resultante consiste en todas las tuplas
     <literal>t(A)</literal> que satisfagan <literal>F(t)</literal>.
    </para>

    <para>
     Si queremos responder la pregunta del ejemplo
     <xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">
     utilizando <acronym>TRC</acronym> formularemos la siguiente consulta:

<programlisting>
     {x(SNAME) &mid; x &isin; SUPPLIER &and; \nonumber
                       &exist; y &isin; SELLS &exist; z &isin; PART (y(SNO)=x(SNO) &and; \nonumber
                        z(PNO)=y(PNO) &and; \nonumber
                        z(PNAME)='Tornillos')} \nonumber
     </programlisting>
    </para>

    <para>
     Evaluando la consulta contra las tablas de 
     <xref linkend="supplier-fig" endterm="supplier-fig">
     encontramos otra vez el mismo resultado de
     <xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">.
    </para>
   </sect2>

   <sect2 id="alg-vs-calc">
    <title>Álgebra Relacional contra Cálculo Relacional</title>

    <para>
     El álgebra relacional y el cálculo relacional tienen el mismo
     <firstterm>poder de expresión</firstterm>; es decir, todas las consultas 
     que se pueden formular utilizando álgebra relacional pueden también formularse
     utilizando el cálculo relacional, y viceversa.
     Esto fue probado por E. F. Codd en 1972. Este profesor se basó en un
     algoritmo (<quote>algoritmo de reducción de Codd</quote>)
     mediante el cual una expresión arbitraria del cálculo relacional 
     se puede reducir a la expresión semánticamente equivalente del álgebra
     relacional. Para una discusión más detallada sobre este punto, diríjase a 
     [<xref linkend="DATE94" endterm="DATE94">]
     y
     [<xref linkend="ULL88" endterm="ULL88">].
    </para>

    <para>
     Se dice a veces que los lenguajes basados en el cálculo relacional son
     de "más alto nivel" o "más declarativos" que los basados en el álgebra relacional
     porque el álgebra especifica (parcialmente) el orden de las operaciones, 
     mientras el cálculo lo traslada a un compilador o interprete que determina
     el orden de evaluación más eficiente.
    </para>
   </sect2>
  </sect1>

  <sect1 id="sql-language">
   <title>El Lenguaje <acronym>SQL</acronym> </title>

   <para>
    Como en el caso de los más modernos lenguajes relacionales,
    <acronym>SQL</acronym> está basado en el cálculo relacional de tuplas.
    Como resultado, toda consulta formulada utilizando el cálculo relacional
    de tuplas ( o su equivalente, el álgebra relacional) se pude formular
    también utilizando <acronym>SQL</acronym>. Hay, sin embargo, capacidades
    que van más allá del cálculo o del álgebra relaciona. Aquí tenemos una lista de algunas
    características proporcionadas por <acronym>SQL</acronym> que no forman parte 
    del álgebra y del cálculo relacionales:

    <itemizedlist>
     <listitem>
      <para>
       Comandos para inserción, borrado o modificación de datos.
      </para>
     </listitem>

     <listitem>
      <para>
       Capacidades aritméticas: En <acronym>SQL</acronym> es posible incluir operaciones
       aritméticas así como comparaciones, por ejemplo

       A &lt; B + 3.

       Nótese que ni + ni otros operadores aritméticos aparecían en el 
       álgebra relacional ni en cálculo relacional.
      </para>
     </listitem>

     <listitem>
      <para>
       Asignación y comandos de impresión: es posible imprimir una relación 
       construida por una consulta y asignar una relación calculada a un nombre de
       relación.
      </para>
     </listitem>

     <listitem>
      <para>
       Funciones agregadas: Operaciones tales como
       <firstterm>promedio (average)</firstterm>, <firstterm>suma (sum)</firstterm>,
       <firstterm>máximo (max)</firstterm>, etc. se pueden aplicar a las columnas
       de una relación para obtener una cantidad única.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect2 id="select">
    <title id="select-title">Select</title>

    <para>
     El comando más usado en <acronym>SQL</acronym> es la instrucción SELECT,
     que se utiliza para recuperar datos. La sintaxis es:

     <synopsis>
   SELECT [ALL|DISTINCT] 
          { * | <replaceable class="parameter">expr_1</replaceable> [AS <replaceable class="parameter">c_alias_1</replaceable>] [, ... 
                [, <replaceable class="parameter">expr_k</replaceable> [AS <replaceable class="parameter">c_alias_k</replaceable>]]]}
   FROM <replaceable class="parameter">table_name_1</replaceable> [<replaceable class="parameter">t_alias_1</replaceable>] 
        [, ... [, <replaceable class="parameter">table_name_n</replaceable> [<replaceable class="parameter">t_alias_n</replaceable>]]]
   [WHERE <replaceable class="parameter">condition</replaceable>]
   [GROUP BY <replaceable class="parameter">name_of_attr_i</replaceable> 
             [,... [, <replaceable class="parameter">name_of_attr_j</replaceable>]] [HAVING <replaceable class="parameter">condition</replaceable>]]
   [{UNION [ALL] | INTERSECT | EXCEPT} SELECT ...]
   [ORDER BY <replaceable class="parameter">name_of_attr_i</replaceable> [ASC|DESC] 
             [, ... [, <replaceable class="parameter">name_of_attr_j</replaceable> [ASC|DESC]]]];
     </synopsis>
    </para>

    <para>
     Ilustraremos ahora la compleja sintaxis de la instrucción SELECT con varios ejemplos.
     Las tablas utilizadas para los ejemplos se definen en:
     <xref linkend="supplier-fig" endterm="supplier-fig">.
    </para>

    <sect3>
     <title>Select sencillas</title>

     <para>
      Aquí tenemos algunos ejemplos sencillos utilizando la instrucción SELECT:

      <example>
       <title id="simple-query">Query sencilla con cualificación</title>
       <para>
        Para recuperar todas las tuplas de la tabla PART donde el atributo PRICE es 
	mayor que 10, formularemos la siguiente consulta:

	<programlisting>
   SELECT * FROM PART
     WHERE PRICE > 10;
	</programlisting>

	y obtenemos la siguiente tabla:

	<programlisting>
                   PNO |  PNAME      |  PRICE
                  -----+-------------+--------
                    3  |  Cerrojos   |   15
                    4  |  Levas      |   25
	</programlisting>
       </para>

       <para>
        Utilizando "*" en la instrucción SELECT solicitaremos todos los atributos
	de la tabla. Si queremos recuperar sólo los atributos PNAME y PRICE de la 
	tabla PART utilizaremos la instrucción:

	<programlisting>
   SELECT PNAME, PRICE 
   FROM PART
   WHERE PRICE > 10;
	</programlisting>

	En este caso el resultado es:

	<programlisting>
                      PNAME      |  PRICE
                     ------------+--------
                      Cerrojos   |   15
                      Levas      |   25
	</programlisting>

	Nótese que la SELECT <acronym>SQL</acronym> corresponde a la "proyección"
	en álgebra relaciona, no a la "selección"
	(vea <xref linkend="rel-alg" endterm="rel-alg"> para más detalles).
       </para>

       <para>
        Las cualificaciones en la clausula WHERE pueden también conectarse lógicamente
	utilizando las palabras claves OR, AND, y NOT:

	<programlisting>
   SELECT PNAME, PRICE 
   FROM PART
   WHERE PNAME = 'Cerrojos' AND
         (PRICE = 0 OR PRICE < 15);
	</programlisting>

	dará como resultado:

	<programlisting>
                      PNAME      |  PRICE
                     ------------+--------
                      Cerrojos   |   15
	</programlisting>
       </para>

       <para>
        Las operaciones aritméticas se pueden utilizar en la lista de objetivos
	y en la clausula WHERE. Por ejemplo, si queremos conocer cuanto cuestan si
	tomamos dos piezas de un artículo, podríamos utilizar la siguiente consulta:

	<programlisting>
   SELECT PNAME, PRICE * 2 AS DOUBLE
   FROM PART
   WHERE PRICE * 2 < 50;
	</programlisting>

	y obtenemos:

	<programlisting>
                      PNAME      |  DOUBLE
                     ------------+---------
                      Tornillos  |    20
                      Tuercas    |    16
                      Cerrojos   |    30
	</programlisting>

	Nótese que la palabra DOBLE tras la palabra clave AS es el nuevo título de la
	segunda columna. Esta técnica puede utilizarse para cada elemento de la lista objetivo
	para asignar un nuevo título a la columna resultante. Este nuevo título recibe
	el calificativo de "un alias". El alias no puede utilizarse en todo el resto de la consulta.
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Joins (Cruces)</title>

     <para id="simple-join">
      El siguiente ejemplo muestra como las <firstterm>joins (cruces)</firstterm> se 
      realizan en <acronym>SQL</acronym>.
     </para>

     <para>
      Para cruzar tres tablas SUPPLIER, PART y SELLS a través de sus atributos comunes, 
      formularemos la siguiente instrucción:

      <programlisting>
   SELECT S.SNAME, P.PNAME
   FROM SUPPLIER S, PART P, SELLS SE
   WHERE S.SNO = SE.SNO AND
         P.PNO = SE.PNO;
      </programlisting>

      y obtendremos la siguiente tabla como resultado:

      <programlisting>
                       SNAME | PNAME
                      -------+-------
                       Smith | Tornillos
                       Smith | Tuercas
                       Jones | Levas
                       Adams | Tornillos
                       Adams | Cerrojos
                       Blake | Tuercas
                       Blake | Cerrojos
                       Blake | Levas
      </programlisting>
     </para>

     <para>
      En la clausula FROM hemos introducido un alias al nombre para cada relación
      porque hay atributos con nombre común (SNO y PNO) en las relaciones.
      Ahora podemos distinguir entre los atributos con nombre común simplificando
      la adicción de un prefijo al nombre del atributo con el nombre del alias seguido 
      de un punto. La join se calcula de la misma forma, tal como se muestra en
      <xref linkend="join-example" endterm="join-example">.
      Primero el producto cartesiano:

      SUPPLIER &times; PART &times; SELLS

      Ahora seleccionamos únicamente aquellas tuplas que satisfagan las condiciones
      dadas en la clausula WHERE (es decir, los atributos con nombre común deben
      ser iguales). Finalmente eliminamos las columnas repetidas (S.SNAME, P.PNAME).
     </para>
    </sect3>

    <sect3>
     <title>Operadores Agregados</title>

     <para>
      <acronym>SQL</acronym> proporciona operadores agregados
      (como son AVG, COUNT, SUM, MIN, MAX) que toman el nombre de un
      atributo como argumento. El valor del operador agregado se calcula sobre todos
      los valores de la columna especificada en la tabla completa. Si se
      especifican grupos en la consulta, el cálculo se hace sólo sobre los valores de cada
      grupo (vean la siguiente sección).

      <example>
       <title id="aggregates-example">Aggregates</title>

       <para>
        Si queremos conocer el coste promedio de todos los artículos de la tabla PART, 
	utilizaremos la siguiente consulta:

	<programlisting>
   SELECT AVG(PRICE) AS AVG_PRICE
   FROM PART;
	</programlisting>
       </para>

       <para>
        El resultado es:

	<programlisting>
                         AVG_PRICE
                        -----------
                           14.5
	</programlisting>
       </para>

       <para>
        Si queremos conocer cuantos artículos se recogen en la tabla PART, utilizaremos
	la instrucción:

	<programlisting>
   SELECT COUNT(PNO)
   FROM PART;
	</programlisting>

	y obtendremos:

	<programlisting>
                           COUNT
                          -------
                             4
	</programlisting>

       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Agregación por Grupos</title>

     <para>
      <acronym>SQL</acronym> nos permite particionar las tuplas de una tabla en
      grupos. En estas condiciones, los operadores agregados descritos antes 
      pueden aplicarse a los grupos (es decir, el valor del operador agregado
      no se calculan sobre todos los valores de la columna especificada, sino sobre
      todos los valores de un grupo. El operador agregado se calcula individualmente
      para cada grupo).
     </para>

     <para>
      El particionamiento de las tuplas en grupos se hace utilizando las
      palabras clave <command>GROUP BY</command> seguidas de una lista de atributos
      que definen los grupos. Si tenemos
      <command>GROUP BY A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript></command>
      habremos particionado la relación en grupos, de tal modo que dos tuplas son del
      mismo grupo si y sólo si tienen el mismo valor en sus atributos
      A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript>.

      <example>
       <title id="aggregates-groupby">Agregados</title>
       <para>
	Si queremos conocer cuántos artículos han sido vendidos por cada proveedor
	formularemos la consulta:

	<programlisting>
   SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
   FROM SUPPLIER S, SELLS SE
   WHERE S.SNO = SE.SNO
   GROUP BY S.SNO, S.SNAME;
	</programlisting>

	y obtendremos:

	<programlisting>
                     SNO | SNAME | COUNT
                    -----+-------+-------
                      1  | Smith |   2
                      2  | Jones |   1
                      3  | Adams |   2
                      4  | Blake |   3
	</programlisting>
       </para>

       <para>
	Demos ahora una mirada a lo que está ocurriendo aquí.
	Primero, la join de las tablas SUPPLIER y SELLS:

	<programlisting>
                  S.SNO | S.SNAME | SE.PNO
                 -------+---------+--------
                    1   |  Smith  |   1
                    1   |  Smith  |   2
                    2   |  Jones  |   4
                    3   |  Adams  |   1
                    3   |  Adams  |   3
                    4   |  Blake  |   2
                    4   |  Blake  |   3
                    4   |  Blake  |   4
	</programlisting>
       </para>

       <para>
	Ahora particionamos las tuplas en grupos reuniendo todas
	las tuplas que tiene el mismo atributo en S.SNO y  S.SNAME:

	<programlisting>
                  S.SNO | S.SNAME | SE.PNO
                 -------+---------+--------
                    1   |  Smith  |   1
                                  |   2
                 --------------------------
                    2   |  Jones  |   4
                 --------------------------
                    3   |  Adams  |   1
                                  |   3
                 --------------------------
                    4   |  Blake  |   2
                                  |   3
                                  |   4
	</programlisting>
       </para>

       <para>
	En nuestro ejemplo, obtenemos cuatro grupos y ahora podemos aplicar
	el operador agregado COUNT para cada grupo, obteniendo el resultado
	total de la consulta dada anteriormente.
       </para>
      </example>
     </para>

     <para>
      Nótese que para el resultado de una consulta utilizando GROUP BY y operadores
      agregados para dar sentido a los atributos agrupados, debemos primero 
      obtener la lista objetivo. Los demás atributos que no aparecen en la 
      clausula GROUP BY se seleccionarán utilizando una función agregada. 
      Por otro lado, no se pueden utilizar funciones agregadas en atributos
      que aparecen en la clausula GROUP BY.
     </para>
    </sect3>

    <sect3>
     <title>Having</title>

     <para>
      La clausula HAVING trabaja de forma muy parecida a la clausula WHERE, y 
      se utiliza para considerar sólo aquellos grupos que satisfagan la
      cualificación dada en la misma. Las expresiones permitidas
      en la clausula HAVING deben involucrar funcionen agregadas. Cada 
      expresión que utilice sólo atributos planos deberá recogerse en la 
      clausula WHERE. Por otro lado, toda expresión que involucre funciones
      agregadas debe aparecer en la clausula HAVING.

      <example>
       <title id="having-example">Having</title>

       <para>
        Si queremos solamente los proveedores que venden más de un artículo, 
	utilizaremos la consulta:

	<programlisting>
   SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
   FROM SUPPLIER S, SELLS SE
   WHERE S.SNO = SE.SNO
   GROUP BY S.SNO, S.SNAME
   HAVING COUNT(SE.PNO) > 1;
	</programlisting>

	 y obtendremos:

	<programlisting>
                     SNO | SNAME | COUNT
                    -----+-------+-------
                      1  | Smith |   2
                      3  | Adams |   2
                      4  | Blake |   3
	</programlisting>
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Subconsultas</title>

     <para>
      En las clausulas WHERE y HAVING se permite el uso de subconsultas (subselects)
      en cualquier lugar donde se espere un valor. En este caso, el valor debe derivar
      de la evaluación previa de la subconsulta. El uso de subconsultas amplía el poder 
      expresivo de <acronym>SQL</acronym>.

      <example>
       <title id="subselect-example">Subselect</title>

       <para>
        Si queremos conocer los artículos que tienen mayor precio que el 
	artículo llamado 'Tornillos', utilizaremos la consulta:

	<programlisting>
   SELECT *
   FROM PART
   WHERE PRICE > (SELECT PRICE FROM PART
                  WHERE PNAME='Tornillos');
	</programlisting>
       </para>

       <para>
        El resultado será:

	<programlisting>
                   PNO |  PNAME      |  PRICE
                  -----+-------------+--------
                    3  |  Cerrojos   |   15
                    4  |  Levas      |   25
	</programlisting>
       </para>

       <para>
        Cuando revisamos la consulta anterior, podemos ver la palabra clave
	SELECT dos veces. La primera al principio de la consulta - a la que 
	nos referiremos como la SELECT externa - y la segunda en la clausula
	WHERE, donde empieza una consulta anidada - nos referiremos a ella como
	la SELECT interna. Para cada tupla de la SELECT externa, la SELECT
	interna deberá ser evaluada. Tras cada evaluación, conoceremos el
	precio de la tupla llamada 'Tornillos', y podremos chequear si el 
	precio de la tupla actual es mayor.
       </para>

       <para>
        Si queremos conocer todos los proveedores que no venden ningún 
	artículo (por ejemplo, para poderlos eliminar de la base de datos), 
	utilizaremos:

	<programlisting>
   SELECT * 
   FROM SUPPLIER S
   WHERE NOT EXISTS
             (SELECT * FROM SELLS SE
              WHERE SE.SNO = S.SNO);
	</programlisting>
       </para>

       <para>
        En nuestro ejemplo, obtendremos un resultado vacío, porque cada proveedor
	vende al menos un artículo. Nótese que utilizamos S.SNO de la SELECT externa
	en la clausula WHERE de la SELECT interna. Como hemos descrito antes, la 
	subconsulta se evalúa para cada tupla de la consulta externa, es decir, el 
	valor de S.SNO se toma siempre de la tupla actual de la SELECT externa.
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Unión, Intersección, Excepción</title>

     <para>
      Estas operaciones calculan la unión, la intersección y la diferencia de
      la teoría de conjuntos de las tuplas derivadas de dos subconsultas.

      <example>
       <title id="union-example">Union, Intersect, Except</title>

       <para>
        La siguiente consulta es un ejemplo de UNION:

	<programlisting>
   SELECT S.SNO, S.SNAME, S.CITY
   FROM SUPPLIER S
   WHERE S.SNAME = 'Jones'
   UNION
   SELECT S.SNO, S.SNAME, S.CITY
   FROM SUPPLIER S
   WHERE S.SNAME = 'Adams';    
	</programlisting>

	Dará el resultado:

	<programlisting>
                     SNO | SNAME |  CITY
                    -----+-------+--------
                      2  | Jones | Paris
                      3  | Adams | Vienna
	</programlisting>
       </para>

       <para>
        Aquí tenemos un ejemplo para INTERSECT:

	<programlisting>
   SELECT S.SNO, S.SNAME, S.CITY
   FROM SUPPLIER S
   WHERE S.SNO > 1
   INTERSECT
   SELECT S.SNO, S.SNAME, S.CITY
   FROM SUPPLIER S
   WHERE S.SNO > 2;
	</programlisting>

	que dará como resultado:

	<programlisting>
                     SNO | SNAME |  CITY
                    -----+-------+--------
                      2  | Jones | Paris
         La única tupla devuelta por ambas partes de la consulta es la única que tiene $SNO=2$.
	</programlisting>
       </para>

       <para>
        Finalmente, un ejemplo de EXCEPT:

	<programlisting>
   SELECT S.SNO, S.SNAME, S.CITY
   FROM SUPPLIER S
   WHERE S.SNO > 1
   EXCEPT
   SELECT S.SNO, S.SNAME, S.CITY
   FROM SUPPLIER S
   WHERE S.SNO > 3;
	</programlisting>

	 que dará como resultado:

	<programlisting>
                     SNO | SNAME |  CITY
                    -----+-------+--------
                      2  | Jones | Paris
                      3  | Adams | Vienna
	</programlisting>
       </para>
      </example>
     </para>
    </sect3>
   </sect2>

   <sect2 id="datadef">
    <title>Definición de Datos</title>

    <para>
     El lenguaje <acronym>SQL</acronym> incluye un conjunto de
     comandos para definición de datos.
    </para>

    <sect3 id="create">
     <title id="create-title">Create Table</title>

     <para>
      El comando fundamental para definir datos es el que crea una nueva
      relación (una nueva tabla). La sintaxis del comando CREATE TABLE es:

	<synopsis>
   CREATE TABLE <replaceable class="parameter">table_name</replaceable>
                (<replaceable class="parameter">name_of_attr_1</replaceable> <replaceable class="parameter">type_of_attr_1</replaceable>
                 [, <replaceable class="parameter">name_of_attr_2</replaceable> <replaceable class="parameter">type_of_attr_2</replaceable> 
                 [, ...]]);
      </synopsis>

      <example>
       <title id="table-create">Creación de una tabla</title>

       <para>
        Para crear las tablas definidas en
	<xref linkend="supplier-fig" endterm="supplier-fig"> 
	se utilizaron las siguientes instrucciones de <acronym>SQL</acronym>:

	<programlisting>
   CREATE TABLE SUPPLIER
                (SNO   INTEGER,
                 SNAME VARCHAR(20),
                 CITY  VARCHAR(20));
	</programlisting>

	<programlisting>
   CREATE TABLE PART
                (PNO   INTEGER,
                 PNAME VARCHAR(20),
                 PRICE DECIMAL(4 , 2));
	</programlisting>

	<programlisting>
   CREATE TABLE SELLS
                (SNO INTEGER,
                 PNO INTEGER);
	</programlisting>
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Tipos de Datos en <acronym>SQL</acronym></title>

     <para>
      A continuación sigue una lista de algunos tipos de datos soportados por
      <acronym>SQL</acronym>:

      <itemizedlist>
       <listitem>
	<para>
	 INTEGER: entero binario con signo de palabra completa (31 bits de precisión). 
	</para>
       </listitem>

       <listitem>
	<para>
	 SMALLINT: entero binario con signo de media palabra (15 bits de precisión).
	</para>
       </listitem>

       <listitem>
	<para>
	 DECIMAL (<replaceable class="parameter">p</replaceable>[,<replaceable class="parameter">q</replaceable>]):
	 número decimal con signo de
	 <replaceable class="parameter">p</replaceable>
	 dígitos de precisión, asumiendo
	 <replaceable class="parameter">q</replaceable>
	 a la derecha para el punto decimal.

(15 &ge; <replaceable class="parameter">p</replaceable> &ge; <replaceable class="parameter">q</replaceable>q &ge; 0).

	 Si <replaceable class="parameter">q</replaceable>
	 se omite, se asume que vale 0.
	</para>
       </listitem>

       <listitem>
	<para>
	 FLOAT: numérico con signo de doble palabra y coma flotante.
	</para>
       </listitem>

       <listitem>
	<para>
	 CHAR(<replaceable class="parameter">n</replaceable>):
	 cadena de caracteres de longitud fija, de longitud
	 <replaceable class="parameter">n</replaceable>.
	</para>
       </listitem>

       <listitem>
	<para>
	 VARCHAR(<replaceable class="parameter">n</replaceable>):
	 cadena de caracteres de longitud variable, de longitud máxima
	 <replaceable class="parameter">n</replaceable>.
	</para>
       </listitem>
      </itemizedlist>
     </para>
    </sect3>

    <sect3>
     <title>Create Index</title>

     <para>
      Se utilizan los índices para acelerar el acceso a una relación. Si una relación
      <classname>R</classname> tiene un índice en el atributo <classname>A</classname> 
      podremos recuperar todas la tuplas <replaceable>t</replaceable> que tienen
      <replaceable>t</replaceable>(<classname>A</classname>) = <replaceable>a</replaceable>
      en un tiempo aproximadamente proporcional al número de tales tuplas <replaceable>t</replaceable>
      más que en un tiempo proporcional al tamaño de <classname>R</classname>.
     </para>

     <para>
      Para crear un índice en <acronym>SQL</acronym>
      se utiliza el comando CREATE INDEX. La sintaxis es:

      <programlisting>
   CREATE INDEX <replaceable class="parameter">index_name</replaceable> 
   ON <replaceable class="parameter">table_name</replaceable> ( <replaceable class="parameter">name_of_attribute</replaceable> );
      </programlisting>
     </para>

     <para>
      <example>
       <title id="index-create">Create Index</title>

       <para>
        Para crear un índice llamado I sobre el atributo SNAME de la relación SUPPLIER,
	utilizaremos la siguiente instrucción:

      <programlisting>
   CREATE INDEX I
   ON SUPPLIER (SNAME);
      </programlisting>
     </para>

       <para>
        El índice creado se mantiene automáticamente. es decir, cada vez que una nueva tupla
	se inserte en la relación SUPPLIER, se adaptará el índice I. Nótese que 
	el único cambio que un usuario puede percibir cuando se crea un índice es un
	incremento en la velocidad.
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Create View</title>

     <para>
      Se puede ver una vista como una <firstterm>tabla virtual</firstterm>,
      es decir, una tabla que no existe <emphasis>físicamente</emphasis> 
      en la base de datos, pero aparece al usuario como si existiese.
      Por contra, cuando hablamos de una <firstterm>tabla base</firstterm>,
      hay realmente un equivalente almacenado para cada fila en la 
      tabla en algún sitio del almacenamiento físico.
     </para>

     <para>
      Las vistas no tienen datos almacenados propios, distinguibles y físicamente
      almacenados. En su lugar, el sistema almacena la definición de la vista 
      (es decir, las reglas para acceder a las tablas base físicamente almacenadas
      para materializar la vista) en algún lugar de los catálogos del sistema (vea
      <xref linkend="catalogs-title" endterm="catalogs-title">). 
      Para una discusión de las diferentes técnicas para implementar vistas, refiérase a 
<!--
      section
      <xref linkend="view-impl" endterm="view-impl">.
-->
      <citetitle>SIM98</citetitle>.
     </para>

     <para>
      En <acronym>SQL</acronym> se utiliza el comando <command>CREATE VIEW</command>
      para definir una vista. La sintaxis es:

      <programlisting>
   CREATE VIEW <replaceable class="parameter">view_name</replaceable>
   AS <replaceable class="parameter">select_stmt</replaceable>
      </programlisting>

      donde <replaceable class="parameter">select_stmt</replaceable> 
      es una instrucción select válida, como se definió en
      <xref linkend="select-title" endterm="select-title">.
      Nótese que <replaceable class="parameter">select_stmt</replaceable> no se 
      ejecuta cuando se crea la vista. Simplemente se almacena en los
      <firstterm>catálogos del sistema</firstterm>
      y se ejecuta cada vez que se realiza una consulta contra la vista.
     </para>

     <para>
      Sea la siguiente definición de una vista (utilizamos de nuevo las tablas de
      <xref linkend="supplier-fig" endterm="supplier-fig"> ):

      <programlisting>
   CREATE VIEW London_Suppliers
      AS SELECT S.SNAME, P.PNAME
         FROM SUPPLIER S, PART P, SELLS SE
         WHERE S.SNO = SE.SNO AND
               P.PNO = SE.PNO AND
               S.CITY = 'London';
      </programlisting>
     </para>

     <para>
      Ahora podemos utilizar esta <firstterm>relación virtual</firstterm>
      <classname>London_Suppliers</classname> como si se tratase de 
      otra tabla base:

      <programlisting>
   SELECT *
   FROM London_Suppliers
   WHERE P.PNAME = 'Tornillos';
      </programlisting>

      Lo cual nos devolverá la siguiente tabla: 

      <programlisting>
                       SNAME | PNAME
                      -------+----------
                       Smith | Tornillos
      </programlisting>
     </para>

     <para>
      Para calcular este resultado, el sistema de base de datos ha realizado
      previamente un acceso <emphasis>oculto</emphasis> a las tablas de la base
      SUPPLIER, SELLS y PART. Hace esto ejecutando la consulta dada en la definición
      de la vista contra aquellas tablas base. Tras eso, las cualificaciones 
      adicionales (dadas en la consulta contra la vista) se podrán aplicar para
      obtener la tabla resultante.
     </para>
    </sect3>

    <sect3>
     <title>Drop Table, Drop Index, Drop View</title>

     <para>
      Se utiliza el comando DROP TABLE para eliminar una tabla (incluyendo 
      todas las tuplas almacenadas en ella):

      <programlisting>
   DROP TABLE <replaceable class="parameter">table_name</replaceable>;
       </programlisting>
      </para>

     <para>
      Para eliminar la tabla SUPPLIER, utilizaremos la instrucción:

      <programlisting>
   DROP TABLE SUPPLIER;
      </programlisting>
     </para>

     <para>
      Se utiliza el comando DROP INDEX para eliminar un índice:

      <programlisting>
   DROP INDEX <replaceable class="parameter">index_name</replaceable>;
      </programlisting>
     </para>

     <para>
      Finalmente, eliminaremos una vista dada utilizando el comando DROP VIEW:

      <programlisting>
   DROP VIEW <replaceable class="parameter">view_name</replaceable>;
      </programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2>
    <title>Manipulación de Datos</title>

    <sect3>
     <title>Insert Into</title>

     <para>
      Una vez que se crea una tabla (vea
      <xref linkend="create-title" endterm="create-title">), 
      puede ser llenada con tuplas mediante el comando
      <command>INSERT INTO</command>.
      La sintaxis es:

      <programlisting>
   INSERT INTO <replaceable class="parameter">table_name</replaceable> (<replaceable class="parameter">name_of_attr_1</replaceable> 
                             [, <replaceable class="parameter">name_of_attr_2</replaceable> [,...]])
   VALUES (<replaceable class="parameter">val_attr_1</replaceable> 
           [, <replaceable class="parameter">val_attr_2</replaceable> [, ...]]);
      </programlisting>
     </para>

     <para>
      Para insertar la primera tupla en la relación SUPPLIER (de
      <xref linkend="supplier-fig" endterm="supplier-fig">) utilizamos la siguiente 
      instrucción:

      <programlisting>
   INSERT INTO SUPPLIER (SNO, SNAME, CITY)
   VALUES (1, 'Smith', 'London');
      </programlisting>
     </para>

     <para>
      Para insertar la primera tupla en la relación SELLS, utilizamos:

      <programlisting>
   INSERT INTO SELLS (SNO, PNO)
   VALUES (1, 1);
      </programlisting>
     </para>
    </sect3>

    <sect3>
     <title>Update</title>

     <para>
      Para cambiar uno o más valores de atributos de tuplas en una relación,
      se utiliza el comando UPDATE. La sintaxis es:

      <programlisting>
   UPDATE <replaceable class="parameter">table_name</replaceable>
   SET <replaceable class="parameter">name_of_attr_1</replaceable> = <replaceable class="parameter">value_1</replaceable> 
       [, ... [, <replaceable class="parameter">name_of_attr_k</replaceable> = <replaceable class="parameter">value_k</replaceable>]]
   WHERE <replaceable class="parameter">condition</replaceable>;
      </programlisting>
     </para>

     <para>
      Para cambiar el valor del atributo PRICE en el artículo 'Tornillos' de 
      la relación PART, utilizamos:

      <programlisting>
   UPDATE PART
   SET PRICE = 15
   WHERE PNAME = 'Tornillos';
      </programlisting>
     </para>

     <para>
      El nuevo valor del atributo PRICE de la tupla cuyo nombre es 'Tornillos' 
      es ahora 15.
     </para>
    </sect3>

    <sect3>
     <title>Delete</title>

     <para>
      Para borrar una tupla de una tabla particular, utilizamos el comando
      DELETE FROM. La sintaxis es:

      <programlisting>
   DELETE FROM <replaceable class="parameter">table_name</replaceable>
   WHERE <replaceable class="parameter">condition</replaceable>;
      </programlisting>
     </para>

     <para>
      Para borrar el proveedor llamado 'Smith' de la tabla SUPPLIER,
      utilizamos la siguiente instrucción:

      <programlisting>
   DELETE FROM SUPPLIER
   WHERE SNAME = 'Smith';
      </programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2 id="catalogs">
    <title id="catalogs-title">System Catalogs</title>

    <para>
     En todo sistema de base de datos <acronym>SQL</acronym> se emplean
     <firstterm>catálogos de sistema</firstterm> para mantener el control
     de qué tablas, vistas, índices, etc están definidas en la base de datos.
     Estos catálogos del sistema se pueden investigar como si de cualquier
     otra relación normal se tratase. Por ejemplo, hay un catálogo utilizado
     para la definición de vistas. Este catálogo almacena la consulta de la
     definición de la vista. Siempre que se hace una consulta contra la vista, 
     el sistema toma primero la <firstterm>consulta de definición de la vista</firstterm>
     del catálogo y materializa la vista antes de proceder con la consulta del 
     usuario (vea
<!--
      section
      <xref linkend="view-impl" endterm="view-impl">.
-->
     <citetitle>SIM98</citetitle>
     para obtener una descripción más detallada). 
     Diríjase a<citetitle>DATE</citetitle> para obtener más información sobre
     los catálogos del sistema.
    </para>
   </sect2>

   <sect2>
    <title><acronym>SQL</acronym> Embebido</title>

    <para>
     En esta sección revisaremos como se puede embeber <acronym>SQL</acronym>
     en un lenguaje de host (p.e. <literal>C</literal>).
     Hay dos razones principales por las que podríamos querer utilizar
     <acronym>SQL</acronym>desde un lenguaje de host:

     <itemizedlist>
      <listitem>
       <para>
        Hay consultas que no se pueden formular utilizando <acronym>SQL</acronym> puro
	(por ejemplo, las consultas recursivas). Para ser capaz de realizar esas consultas
	necesitamos un lenguaje de host de mayor poder expresivo que <acronym>SQL</acronym>.
       </para>
      </listitem>

      <listitem>
       <para>
        Simplemente queremos acceder a una base de datos desde una aplicación que 
	está escrita en el lenguaje del host (p.e. un sistema de reserva de billetes
	con una interface gráfica escrita en C, y la información sobre los billetes
	está almacenada en una base de datos que puede accederse utilizando 
	<acronym>SQL</acronym> embebido).
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Un programa que utiliza <acronym>SQL</acronym> embebido en un lenguaje de host
     consiste en instrucciones del lenguaje del host e instrucciones de 
     <firstterm><acronym>SQL</acronym> embebido</firstterm>
     (<acronym>ESQL</acronym>). Cada instrucción de <acronym>ESQL</acronym>
     empieza con las palabras claves <command>EXEC SQL</command>.
     Las instrucciones <acronym>ESQL</acronym> se transforman en instrucciones
     del lenguaje del host mediante un <firstterm>precompilador</firstterm>
     (que habitualmente inserta llamadas a rutinas de librerías que ejecutan 
     los variados comandos de <acronym>SQL</acronym>).
    </para>

    <para>
     Cuando vemos los ejemplos de 
     <xref linkend="select-title" endterm="select-title"> 
     observamos que el resultado de las consultas es algo muy próximo a un
     conjunto de tuplas. La mayoría de los lenguajes de host no están diseñados
     para operar con conjuntos, de modo que necesitamos un mecanismo para 
     acceder a cada tupla única del conjunto de tuplas devueltas por una 
     instrucción SELECT. Este mecanismo puede ser proporcionado declarando un
     <firstterm>cursor</firstterm>. Tras ello, podemos utilizar el comando
     FETCH para recuperar una tupla y apuntar el cursor hacia la siguiente
     tupla.
    </para>

    <para>
     Para una discusión más detallada sobre el <acronym>SQL</acronym> embebido, 
     diríjase a
     [<xref linkend="DATE97" endterm="DATE97">],
     [<xref linkend="DATE94" endterm="DATE94">],
     o
     [<xref linkend="ULL88" endterm="ULL88">].
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->

