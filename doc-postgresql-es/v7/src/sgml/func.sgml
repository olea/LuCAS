<!-- $Header: /home/cvs/lucas/doc-postgresql-es/v7/src/sgml/func.sgml,v 1.3 2002/04/16 21:49:05 emaldonadog Exp $ -->

<chapter id="functions">
 <title>Funciones y operadores</title>

 <para>
  <productname>Postgres</productname> está provisto de un gran número de
  funciones y operadores para los tipos de datos internos. Los usuarios
  también pueden definir sus propias funciones y operadores, tal como se
  describe en <citetitle>La Guia del Programador</citetitle>. Se pueden
  usar los comandos <command>\df</command> y <command>\do</command> de
  <application>psql</application> para mostrar la lista de las funciones
  y operadores disponibles, respectivamente.
 </para>

 <para>
  Si le importa la portabilidad, sepa que la mayoría de las funciones y
  operadores descritos en este capítulo, con las excepción de los básicos
  de aritmética y comparación y algunas funciones señaladas explícitamente,
  no están especificadas por el estándar <acronym>SQL</acronym>. De todas
  formas, la mayoría de los demás paquetes <acronym>RDBMS</acronym> están
  provistos de muchas funciones iguales o similares y, de hecho, algunos de
  los que trae <productname>Postgres</productname> están inspirados en los
  de otras implementaciones.
 </para>


 <sect1 id="functions-logical">
  <title>Operadores Lógicos</title>

  <para>
   Los siguientes operadores lógicos usuales están disponibles:

   <simplelist>
    <member>AND</member>
    <member>OR</member>
    <member>NOT</member>
   </simplelist>

   <acronym>SQL</acronym> utiliza lógica booleana de tres valores, en la que
   NULO representa <quote>desconocido</quote>. Fíjese en las siguientes 
   tablas de verdad:

   <informaltable>
    <tgroup cols="4">
     <thead>
      <row>
       <entry><replaceable>a</replaceable></entry>
       <entry><replaceable>b</replaceable></entry>
       <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
       <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>Verdadero</entry>
       <entry>Verdadero</entry>
       <entry>Verdadero</entry>
       <entry>Verdadero</entry>
      </row>

      <row>
       <entry>Verdadero</entry>
       <entry>Falso</entry>
       <entry>Falso</entry>
       <entry>Verdadero</entry>
      </row>

      <row>
       <entry>Verdadero</entry>
       <entry>NULO</entry>
       <entry>NULO</entry>
       <entry>Verdadero</entry>
      </row>

      <row>
       <entry>Falso</entry>
       <entry>Falso</entry>
       <entry>Falso</entry>
       <entry>Falso</entry>
      </row>

      <row>
       <entry>Falso</entry>
       <entry>NULO</entry>
       <entry>Falso</entry>
       <entry>NULO</entry>
      </row>

      <row>
       <entry>NULO</entry>
       <entry>NULO</entry>
       <entry>NULO</entry>
       <entry>NULO</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry><replaceable>a</replaceable></entry>
       <entry>NOT <replaceable>a</replaceable></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>Verdadero</entry>
       <entry>Falso</entry>
      </row>

      <row>
       <entry>Falso</entry>
       <entry>Verdadero</entry>
      </row>

      <row>
       <entry>NULO</entry>
       <entry>NULO</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </sect1>

 <sect1 id="functions-comparison">
  <title>Operadores de comparación</title>

  <table>
   <title>Operadores de comparación</TITLE>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Operador</entry>
      <entry>Descripción</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry> <literal>&lt;</literal> </entry>
      <entry>menor que</entry>
     </row>

     <row>
      <entry> <literal>&gt;</literal> </entry>
      <entry>mayor que</entry>
     </row>

     <row>
      <entry> <literal>&lt;=</literal> </entry>
      <entry>menor o igual que</entry>
     </row>

     <row>
      <entry> <literal>&gt;=</literal> </entry>
      <entry>mayor o igual que</entry>
     </row>

     <row>
      <entry> <literal>=</literal> </entry>
      <entry>igual a</entry>
     </row>

     <row>
      <entry> <literal>&lt;&gt;</literal> or <literal>!=</literal> </entry>
      <entry>distinto de</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    El operador <literal>!=</literal> se convierte a
    <literal>&lt;&gt;</literal> en la fase de análisis. No es posible
    implementar operadores <literal>!=</literal> y
    <literal>&lt;&gt;</literal> que hagan cosas diferentes.
   </para>
  </note>

  <para>
   Los operadores de comparación se pueden utilizar sobre todos los
   tipos de datos en los que tenga sentido hacerlo. Todos los operadores
   de comparación son operadores binarios que devuelven valores de tipo
   <type>boolean</type>; expresiones como <literal>1 &lt; 2 &lt; 3</literal>
   no son válidas, (porque no hay un operador lógico para comparar un 
   valor booleano con <literal>3</literal>).
  </para>

  <para>
   Además de los operadores de comparación está disponible la construcción
   especial <token>BETWEEN</token>. 
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
equivale a 
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
Y también
<synopsis>
<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
   equivale a 
<synopsis>
<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR <replaceable>a</replaceable> &gt; <replaceable>y</replaceable>
</synopsis>
   No hay diferencia entre las dos respectivas formas, excepto los ciclos de
   <acronym>CPU</acronym> que se requieren para convertir la primera en la
   segunda internamente.
  </para>

  <para>
   Para comprobar cuando un valor es o no NULO, utilice las construcciones
<synopsis>
<replaceable>expresión</replaceable> IS NULL
<replaceable>expresión</replaceable> IS NOT NULL
</synopsis>
   <emphasis>No</emphasis> utilice
   <literal><replaceable>expresión</replaceable> = NULL</literal>
   porque NULL no es <quote>igual a</quote> NULL.  (NULL representa un
   valor desconocido, por lo tanto no se sabe si dos valores desconocidos
   son iguales). <productname>Postgres</productname> actualmente convierte
   <literal>x = NULL</literal> en <literal>x IS NULL</literal> para permitir
   que funcionen algunas aplicaciones clientes (como
   <productname>Microsoft Access</productname>) pero ésto puede dejar de
   hacerse en versiones futuras.
  </para>
 </sect1>


 <sect1 id="functions-math">
  <title>Funciones y operadores matemáticos</title>

  <table>
   <title>Operadores matemáticos</TITLE>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nombre</entry>
      <entry>Descripción</entry>
      <entry>Ejemplo</entry>
      <entry>Resultado</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry> <literal>+</literal> </entry>
      <entry>Suma</entry>
      <entry>2 + 3</entry>
      <entry>5</entry>
     </row>

     <row>
      <entry> <literal>-</literal> </entry>
      <entry>Resta</entry>
      <entry>2 - 3</entry>
      <entry>-1</entry>
     </row>

     <row>
      <entry> <literal>*</literal> </entry>
      <entry>Multiplicación</entry>
      <entry>2 * 3</entry>
      <entry>6</entry>
     </row>

     <row>
      <entry> <literal>/</literal> </entry>
      <entry>División (La división de enteros trunca el resultado)</entry>
      <entry>4 / 2</entry>
      <entry>2</entry>
     </row>

     <row>
      <entry> <literal>%</literal> </entry>
      <entry>Módulo (resto de la división)</entry>
      <entry>5 % 4</entry>
      <entry>1</entry>
     </row>

     <row>
      <entry> <literal>^</literal> </entry>
      <entry>Exponenciación</entry>
      <entry>2.0 ^ 3.0</entry>
      <entry>8.0</entry>
     </row>

     <row>
      <entry> <literal>|/</literal> </entry>
      <entry>Raíz cuadrada</entry>
      <entry>|/ 25.0</entry>
      <entry>5.0</entry>
     </row>

     <row>
      <entry> <literal>||/</literal> </entry>
      <entry>Raíz cúbica</entry>
      <entry>||/ 27.0</entry>
      <entry>3</entry>
     </row>

     <row>
      <entry> <literal>!</literal> </entry>
      <entry>Factorial</entry>
      <entry>5 !</entry>
      <entry>120</entry>
     </row>

     <row>
      <entry> <literal>!!</literal> </entry>
      <entry>Factorial (operador prefijo)</entry>
      <entry>!! 5</entry>
      <entry>120</entry>
     </row>

     <row>
      <entry> <literal>@</literal> </entry>
      <entry>Valor absoluto</entry>
      <entry>@ -5.0</entry>
      <entry>5.0</entry>
     </row>

     <row>
      <entry> <literal>&amp;</literal> </entry>
      <entry>AND binario</entry>
      <entry>91 & 15</entry>
      <entry>11</entry>
     </row>

     <row>
      <entry> <literal>|</literal> </entry>
      <entry>OR binario</entry>
      <entry>32 | 3</entry>
      <entry>35</entry>
     </row>

     <row>
      <entry> <literal>#</literal> </entry>
      <entry>XOR binario</entry>
      <entry>17 # 5</entry>
      <entry>20</entry>
     </row>

     <row>
      <entry> <literal>~</literal> </entry>
      <entry>NOT binario</entry>
      <entry>~1</entry>
      <entry>-2</entry>
     </row>

     <row>
      <entry> &lt;&lt; </entry>
      <entry>Desplazamiento binario hacia la izquierda</entry>
      <entry>1 &lt;&lt; 4</entry>
      <entry>16</entry>
     </row>

     <row>
      <entry> &gt;&gt; </entry>
      <entry>Desplazamiento binario hacia la derecha</entry>
      <entry>8 &gt;&gt; 2</entry>
      <entry>2</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Los operadores <quote>binarios</quote> también están disponibles para
   los tipos de cadena de bits <type>BIT</type> y <type>BIT VARYING</type>.

   <table>
    <title>Operadores binarios de cadenas de bits</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Resultado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>B'10001' & B'01101'</entry>
       <entry>00001</entry>
      </row>
      <row>
       <entry>B'10001' | B'01101'</entry>
       <entry>11101</entry>
      </row>
      <row>
       <entry>B'10001' # B'01101'</entry>
       <entry>11110</entry>
      </row>
      <row>
       <entry>~ B'10001'</entry>
       <entry>01110</entry>
      </row>
      <row>
       <entry>B'10001' &lt;&lt; 3</entry>
       <entry>01000</entry>
      </row>
      <row>
       <entry>B'10001' &gt;&gt; 2</entry>
       <entry>00100</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   Los argumentos de cadenas de bits para <literal>&</literal>,
   <literal>|</literal>, y <literal>#</literal> deben ser de la misma
   longitud. Cuando se desplazan bits, se mantiene la longitud original
   de la cadena, tal como se muestra aquí.
  </para>

  <table tocentry="1">
   <title>Funciones matemáticas</title>
   <tgroup cols="5">
    <thead>
     <row>
      <entry>Función</entry>
      <entry>Tipo devuelto</entry>
      <entry>Descripción</entry>
      <entry>Ejemplo</entry>
      <entry>Resultado</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>abs(<replaceable>x</replaceable>)</entry>
      <entry>(igual que x)</entry>
      <entry>valor absoluto</entry>
      <entry>abs(-17.4)</entry>
      <entry>17.4</entry>
     </row>

     <row>
      <entry>cbrt(<type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>raíz cúbica</entry>
      <entry>cbrt(27.0)</entry>
      <entry>3.0</entry>
     </row>

     <row>
      <entry>ceil(<type>numeric</type>)</entry>
      <entry><type>numeric</type></entry>
      <entry>entero más pequeño no menor que el argumento</entry>
      <entry>ceil(-42.8)</entry>
      <entry>-42</entry>
     </row>

     <row>
      <entry>degrees(<type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>radianes a grados</entry>
      <entry>degrees(0.5)</entry>
      <entry>28.6478897565412</entry>
     </row>

     <row>
      <entry>exp(<type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>exponencial</entry>
      <entry>exp(1.0)</entry>
      <entry>2.71828182845905</entry>
     </row>

     <row>
      <entry>floor(<type>numeric</type>)</entry>
      <entry><type>numeric</type></entry>
      <entry>entero más grande no mayor que el argumento</entry>
      <entry>floor(-42.8)</entry>
      <entry>-43</entry>
     </row>

     <row>
      <entry>ln(<type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>logaritmo neperiano</entry>
      <entry>ln(2.0)</entry>
      <entry>0.693147180559945</entry>
     </row>

     <row>
      <entry>log(<type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>logaritmo en base 10</entry>
      <entry>log(100.0)</entry>
      <entry>2.0</entry>
     </row>

     <row>
      <entry>log(<parameter>b</parameter> <type>numeric</type>,
       <parameter>x</parameter> <type>numeric</type>)</entry>
      <entry><type>numeric</type></entry>
      <entry>logaritmo a base <parameter>b</parameter></entry>
      <entry>log(2.0, 64.0)</entry>
      <entry>6.0</entry>
     </row>

     <row>
      <entry>mod(<parameter>y</parameter>, <parameter>x</parameter>)</entry>
      <entry>(el mismo que los tipos de los argumentos)</entry>
      <entry>resto de <parameter>y</parameter>/<parameter>x</parameter></entry>
      <entry>mod(9,4)</entry>
      <entry>1</entry>
     </row>

     <row>
      <entry>pi()</entry>
      <entry><type>dp</type></entry>
      <entry>La constante <quote>Pi</quote></entry>
      <entry>pi()</entry>
      <entry>3.14159265358979</entry>
     </row>

     <row>
      <entry>pow(<parameter>e</parameter> <type>dp</type>,
       <parameter>n</parameter> <type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>Eleva un número al exponente <parameter>e</parameter></entry>
      <entry>pow(9.0, 3.0)</entry>
      <entry>729.0</entry>
     </row>

     <row>
      <entry>radians(<type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>grados a radianes</entry>
      <entry>radians(45.0)</entry>
      <entry>0.785398163397448</entry>
     </row>

     <row>
      <entry>random()</entry>
      <entry><type>dp</type></entry>
      <entry>valor aleatorio entre 0.0 y 1.0</entry>
      <entry>random()</entry>
      <entry></entry>
     </row>

     <row>
      <entry>round(<type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>redondea al entero más cercano</entry>
      <entry>round(42.4)</entry>
      <entry>42</entry>
     </row>

     <row>
      <entry>round(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type>)</entry>
      <entry><type>numeric</type></entry>
      <entry>redondea a <parameter>s</parameter> posiciones decimales</entry>
      <entry>round(42.4382, 2)</entry>
      <entry>42.44</entry>
     </row>
<!--
     <row>
      <entry>setseed(<replaceable>new-seed</replaceable>)</entry>
      <entry>asigna la semilla para posteriores llamadas a random()</entry>
      <entry>setseed(0.54823)</entry>
      <entry></entry>
     </row>
-->
     <row>
      <entry>sqrt(<type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>raíz cuadrada</entry>
      <entry>sqrt(2.0)</entry>
      <entry>1.4142135623731</entry>
     </row>

     <row>
      <entry>trunc(<type>dp</type>)</entry>
      <entry><type>dp</type></entry>
      <entry>trunca hacia cero</entry>
      <entry>trunc(42.8)</entry>
      <entry>42</entry>
     </row>

     <row>
      <entry>trunc(<type>numeric</type>, <parameter>s</parameter> <type>integer</type>)</entry>
      <entry><type>numeric</type></entry>
      <entry>trunca a <parameter>s</parameter> posiciones decimales</entry>
      <entry>round(42.4382, 2)</entry>
      <entry>42.43</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   En la tabla anterior, "<literal>dp</literal>" indica 
   <type>doble precisión</type>.
   Las funciones <function>exp</function>, <function>ln</function>,
   <function>log</function>, <function>pow</function>,
   <function>round</function> (1 argumento), <function>sqrt</function>,
   y <function>trunc</function> (1 argumento) también están disponibles
   para el tipo <type>numeric</type> en lugar de 
   <type>doble precisión</type>.
   Las funciones que devuelven un resultado <type>numeric</type> 
   toman argumentos de entrada <type>numeric</type>, a menos que se
   especifique otro. Muchas de estas funciones están implementadas sobre
   la librería C del sistema servidor y el comportamiento en casos 
   límite pueden variar dependiendo del sistema operativo.
  </para>

  <table>
   <title>Funciones trigonométricas</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Función</entry>
      <entry>Descripción</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>acos(<replaceable>x</replaceable>)</entry>
      <entry>inverso del coseno</entry>
     </row>

     <row>
      <entry>asin(<replaceable>x</replaceable>)</entry>
      <entry>inverso del seno</entry>
     </row>

     <row>
      <entry>atan(<replaceable>x</replaceable>)</entry>
      <entry>inverso de la tangente</entry>
     </row>

     <row>
      <entry>atan2(<replaceable>x</replaceable>, <replaceable>y</replaceable>)</entry>
      <entry>inverso de la tangente de <replaceable>y</replaceable>/<replaceable>x</replaceable></entry>
     </row>

     <row>
      <entry>cos(<replaceable>x</replaceable>)</entry>
      <entry>coseno</entry>
     </row>

     <row>
      <entry>cot(<replaceable>x</replaceable>)</entry>
      <entry>cotangente</entry>
     </row>

     <row>
      <entry>sin(<replaceable>x</replaceable>)</entry>
      <entry>seno</entry>
     </row>

     <row>
      <entry>tan(<replaceable>x</replaceable>)</entry>
      <entry>tangente</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Todas las funciones trigonométricas tienen tipo
   <type>doble precisión</type> para los argumentos y valores devueltos.
  </para>

 </sect1>


 <sect1 id="functions-string">
  <title>Funciones y operadores de cadena</title>

  <para>
   Esta sección describe funciones y operadores para examinar y manipular
   valores de cadena. En este contexto, cadena incluye valores de todos
   los tipos <type>CHARACTER</type>, <type>CHARACTER VARYING</type>, y
   <type>TEXT</type>. A menos que se indique otra cosa, todas las
   funciones listadas a continuación funcionan con todos esos tipos, pero
   tenga cuidado de los efectos potenciales del ajuste automático cuando
   se use el tipo <type>CHARACTER</type>. Generalmente las funciones aquí
   descritas también funcionan con otros tipos de datos, convirtiéndolos
   primeros a una representación de cadena. Algunas funciones también
   existen de forma nativa para tipos de cadena de bits.
  </para>

  <para>
   <acronym>SQL</acronym> define algunas funciones de cadena con una
   sintaxis especial en la que se utilizan ciertas palabras clave en
   vez de comas para separar los argumentos.
   Los detalles están en <xref linkend="functions-string-sql">.
   Esas funciones también están implementadas con la sintaxis habitual
   para la invocación de funciones (Vea
   <xref linkend="functions-string-other">.)
  </para>

  <table id="functions-string-sql">
   <title>Funciones y operadores de cadenas de <acronym>SQL</acronym></title>
   <tgroup cols="5">
    <thead>
     <row>
      <entry>Función</entry>
      <entry>Tipo devuelto</entry>
      <entry>Descripción</entry>
      <entry>Ejemplo</entry>
      <entry>Resultado</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry> <parameter>cadena</parameter> <literal>||</literal> <parameter>string</parameter> </entry>
      <entry> <type>texto</type> </entry>
      <entry>concatenación de cadenas</entry>
      <entry>'Postgre' || 'SQL'</entry>
      <entry>PostgreSQL</entry>
     </row>

     <row>
      <entry>char_length(<parameter>cadena</parameter>) or character_length(<parameter>cadena</parameter>)</entry>
      <entry><type>integer</type></entry>
      <entry>longitud de la cadena</entry>
      <entry>char_length('jose')</entry>
      <entry>4</entry>
     </row>

     <row>
      <entry>lower(<parameter>cadena</parameter>)</entry>
      <entry><type>texto</type></entry>
      <entry>Convierte la cadena a minúsculas.</entry>
      <entry>lower('TOM')</entry>
      <entry>tom</entry>
     </row>

     <row>
      <entry>octet_length(<parameter>cadena</parameter>)</entry>
      <entry><type>integer</type></entry>
      <entry>número de bytes en la cadena</entry>
      <entry>octet_length('jose')</entry>
      <entry>4</entry>
     </row>

     <row>
      <entry>position(<parameter>subcadena</parameter> in <parameter>cadena</parameter>)</entry>
      <entry><type>integer</type></entry>
      <entry>situación de la subcadena especificada</entry>
      <entry>position('om' in 'Thomas')</entry>
      <entry>3</entry>
     </row>

     <row>
      <entry>substring(<parameter>string</parameter> <optional>from <type>integer</type></optional> <optional>for <type>integer</type></optional>)</entry>
      <entry><type>text</type></entry>
      <entry>extrae la subcadena</entry>
      <entry>substring('Thomas' from 2 for 3)</entry>
      <entry>oma</entry>
     </row>

     <row>
      <entry>
       trim(<optional>leading | trailing | both</optional>
       <optional><parameter>characters</parameter></optional> from
       <parameter>string</parameter>)
      </entry>
      <entry><type>text</type></entry>
      <entry>
			 Elimina la cadena que contenga los
       <parameter>characters</parameter> (por defecto 'blancos')
			 del principio | fin | ambos extremos de
       <parameter>string</parameter>.
      </entry>
      <entry>trim(both 'x' from 'xTomx')</entry>
      <entry>Tom</entry>
     </row>

     <row>
      <entry>upper(<parameter>string</parameter>)</entry>
      <entry><type>text</type></entry>
      <entry>Convierte la cadena a mayúsculas.</entry>
      <entry>upper('tom')</entry>
      <entry>TOM</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
	 Hay disponibles funciones de manipulación de cadenas que están
	 listadas más abajo. Algunas de ellas se utilizan internamente para
	 implementar las funciones de cadenas de <acronym>SQL</acronym>
	 listadas anteriormente.
  </para>

  <table id="functions-string-other">
   <title>Otras funciones de cadenas</title>
   <tgroup cols="5">
    <thead>
     <row>
      <entry>Función</entry>
      <entry>Tipo devuelto</entry>
      <entry>Descripción</entry>
      <entry>Ejemplo</entry>
      <entry>Resultado</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>ascii(<type>text</type>)</entry>
      <entry>integer</entry>
      <entry>Devuelve el código <acronym>ASCII</acronym> del primer carácter
			del argumento</entry>
      <entry>ascii('x')</entry>
      <entry>120</entry>
     </row>

     <row>
      <entry>btrim(<parameter>string</parameter> <type>text</type>, <parameter>trim</parameter> <type>text</type>)</entry>
      <entry><type>text</type></entry>
      <entry>
       Elimina la cadena más larga formada por los caracteres en
       <parameter>trim</parameter> del inicio y fin de
       <parameter>string</parameter>.
      </entry>
      <entry>btrim('xyxtrimyyx','xy')</entry>
      <entry>trim</entry>
     </row>

     <row>
      <entry>chr(<type>integer</type>)</entry>
      <entry><type>text</type></entry>
      <entry>Devuelve el carácter con el código <acronym>ASCII</acronym> indicado.</entry>
      <entry>chr(65)</entry>
      <entry>A</entry>
     </row>

     <row>
      <entry>initcap(<type>text</type>)</entry>
      <entry><type>text</type></entry>
      <entry>Convierte la primera letra de cada palabra (separada por espacios) a mayúsculas.</entry>
      <entry>initcap('hi thomas')</entry>
      <entry>Hi Thomas</entry>
     </row>

     <row>
      <entry>
       lpad(<parameter>string</parameter> <type>text</type>,
       <parameter>length</parameter> <type>integer</type>
       <optional>, <parameter>fill</parameter> <type>text</type></optional>)
      </entry>
      <entry>text</entry>
      <entry>
       Alarga <parameter>string</parameter> hasta la longitud
       <parameter>length</parameter> insertando al principio los caracteres
       <parameter>fill</parameter> (por defecto espacios).  Si la cadena
       <parameter>string</parameter> es ya más larga que
       <parameter>length</parameter> entonces se trunca (por la derecha)
      </entry>
      <entry>lpad('hi', 5, 'xy')</entry>
      <entry>xyxhi</entry>
     </row>

     <row>
      <entry>ltrim(<parameter>string</parameter> <type>text</type>, <parameter>trim</parameter> <type>text</type>)</entry>
      <entry><type>text</type></entry>
      <entry>
       Elimina la cadena que contenga los caracteres en
       <parameter>trim</parameter> del comienzo de la cadena.
      </entry>
      <entry>ltrim('zzzytrim','xyz')</entry>
      <entry>trim</entry>
     </row>

     <row>
      <entry>repeat(<type>text</type>, <type>integer</type>)</entry>
      <entry><type>text</type></entry>
      <entry>Repite text un número integer de veces.</entry>
      <entry>repeat('Pg', 4)</entry>
      <entry>PgPgPgPg</entry>
     </row>

     <row>
      <entry>
       rpad(<parameter>string</parameter> <type>text</type>,
       <parameter>length</parameter> <type>integer</type>
       <optional>, <parameter>fill</parameter> <type>text</type></optional>)
      </entry>
      <entry><type>text</type></entry>
      <entry>
       Alarga la cadena <parameter>string</parameter> hasta la longitud
       <parameter>length</parameter> insertándole los caracteres en
       <parameter>fill</parameter> (por defecto espacios). Si la cadena
       <parameter>string</parameter> ya es más larga que
       <parameter>length</parameter> entonces se trunca.
      </entry>
      <entry>rpad('hi', 5, 'xy')</entry>
      <entry>hixyx</entry>
     </row>

     <row>
      <entry>rtrim(<parameter>string</parameter> text, <parameter>trim</parameter> text)</entry>
      <entry><type>text</type></entry>
      <entry>
			 Elimina la cadena más larga que contenga los caracteres en
       <parameter>trim</parameter> del final de la cadena.
      </entry>
      <entry>rtrim('trimxxxx','x')</entry>
      <entry>trim</entry>
     </row>

     <row>
      <entry>strpos(<parameter>string</parameter>, <parameter>substring</parameter>)</entry>
      <entry><type>integer</type></entry>
      <entry>
			 Encuentra la subcadena especificada (igual que
       <literal>position(<parameter>substring</parameter> in
       <parameter>string</parameter>)</literal>, pero con el orden de
			 los argumentos invertido)
      </entry>
      <entry>strpos('high','ig')</entry>
      <entry>2</entry>
     </row>

     <row>
      <entry>substr(<parameter>string</parameter>, <parameter>from</parameter> <optional>, <parameter>count</parameter></optional>)</entry>
      <entry><type>text</type></entry>
      <entry>
			 Devuelve la subcadena especificada (igual que
       <literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)
      </entry>
      <entry>substr('alphabet', 3, 2)</entry>
      <entry>ph</entry>
     </row>

     <row>
      <entry>to_ascii(<type>text</type> <optional>, <parameter>encoding</parameter></optional>)</entry>
      <entry><type>text</type></entry>
      <entry>Convierte de codificación multibyte a <acronym>ASCII</acronym>.</entry>
      <entry>to_ascii('Karel')</entry>
      <entry>Karel</entry>
     </row>

     <row>
      <entry>
       translate(<parameter>string</parameter> <type>text</type>,
       <parameter>from</parameter> <type>text</type>,
       <parameter>to</parameter> <type>text</type>)
      </entry>
      <entry><type>text</type></entry>
      <entry>
       Cualquier carácter en <parameter>string</parameter> que se encuentre en
       el conjunto <parameter>from</parameter> se reemplaza por el carácter
       correspondiente en el conjunto <parameter>to</parameter>.
      </entry>
      <entry>translate('12345', '14', 'ax')</entry>
      <entry>a23x5</entry>
     </row>       

    </tbody>
   </tgroup>
  </table>

  <para>
   La función <function>to_ascii</function> solamente soporta conversión 
	 desde LATIN1, LATIN2, WIN1250 (CP1250).
  </para>
 </sect1>


 <sect1 id="functions-matching">
  <title>Búsqueda mediante patrones</title>

  <para>
   <productname>Postgres</productname> implementa dos mecanismos para
	 la búsqueda por patrones: el operador de <acronym>SQL</acronym>
   <function>LIKE</function> y las expresiones regulares estilo
   <acronym>POSIX</acronym>.
  </para>

  <tip>
   <para>
	  Si los requerimientos de búsqueda por patrones van más allá de esto,
		o se necesitan sustituciones o traducciones indicadas por patrones,
		se debería considerar escribir una función de usuario definida en
		Perl o Tcl.
   </para>
  </tip>

  <sect2 id="functions-like">
   <title>Búsqueda por patrones con <function>LIKE</function></title>

<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional> ESCAPE <replaceable>escape-character</replaceable> </optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional> ESCAPE <replaceable>escape-character</replaceable> </optional>
</synopsis>

   <para>
    Cada <replaceable>pattern</replaceable> define un conjunto de cadenas.
    La expresión <function>LIKE</function> devuelve true (verdadero) si
    <replaceable>string</replaceable> está contenida en el conjunto de
		cadenas representado por <replaceable>pattern</replaceable>.  (Tal como
    se supone, la expresión <function>NOT LIKE</function> devuelve
    false (falso) si <function>LIKE</function> devuelve true, y viceversa.
    Una expresión equivalente sería <literal>NOT
    (<replaceable>string</replaceable> LIKE
    <replaceable>pattern</replaceable>)</literal>.)
   </para>

   <para>
    Si <replaceable>pattern</replaceable> no contiene signos de porcentaje
		o subrayado, entonces el patrón representa únicamente la cadena en si
		misma; en ese caso <function>LIKE</function> equivale al operador 
		igual. Un subrayado (<literal>_</literal>) en el patrón
    <replaceable>pattern</replaceable> busca un único carácter;
    un signo de porcentaje (<literal>%</literal>) busca una cadena de
		cero o más caracteres.
   </para>

   <informalexample>
    <para>
     Algunos ejemplos:
<programlisting>
'abc' LIKE 'abc'    <lineannotation>verdadero</lineannotation>
'abc' LIKE 'a%'     <lineannotation>verdadero</lineannotation>
'abc' LIKE '_b_'    <lineannotation>verdadero</lineannotation>
'abc' LIKE 'c'      <lineannotation>falso</lineannotation>
</programlisting>
    </para>
   </informalexample>

   <para>
    Las búsquedas con patrones <function>LIKE</function> siempre abarcan
		la cadena completa. Para encontrar un patrón en cualquier sitio
		dentro de la cadena, el patrón debe por tanto empezar y terminar por
		el signo de porcentaje.
   </para>

   <para>
	  Para buscar un carácter de subrayado o porcentaje literal, el carácter
		respectivo debe estar precedido del carácter de escape. El caráter
		de escape por defecto es la contrabarra (\) pero se puede seleccionar
		otro usando la claúsula <literal>ESCAPE</literal>. Para el propio
		carácter de escape, se deben escribir dos caracteres de escape.
   </para>

   <para>
		Al tener ya la contrabarra un significado especial en las cadenas,
		para escribir un patrón que contenga contrabarras se deberán escribir
		dos contrabarras en el query. Se puede evitar esto seleccionando
		un carácter de escape diferente con <literal>ESCAPE</literal>.
   </para>

   <para>
    Se puede usar <token>ILIKE</token> en lugar de 
    <token>LIKE</token> para hacer la búsqueda insensible a 
		mayúsculas/minúsculas según el locale activo. Esto no es un estándar de
    <acronym>SQL</acronym> sino una extensión de
    <productname>Postgres</productname>.
   </para>

   <para>
    El operador <literal>~~</literal> es equivalente a
    <function>LIKE</function>, y <literal>~~*</literal> corresponde a
    <function>ILIKE</function>. También existen los operadores
    <literal>!~~</literal> y <literal>!~~*</literal> que representan a
    <function>NOT LIKE</function> y <function>NOT
    ILIKE</function>.  Todos eston son específicos de
    <productname>Postgres</productname>.
   </para>
  </sect2>


  <sect2 id="functions-regexp">
   <title>Expresiones regulares de<acronym>POSIX</acronym></title>

   <table>
    <title>Operadores de búsqueda con expresiones regulares</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Operador</entry>
       <entry>Descripción</entry>
       <entry>Ejemplo</entry>
      </row>
     </thead>

     <tbody>
       <ROW>
	<ENTRY> <literal>~</literal> </ENTRY>
	<ENTRY>Coincide la expresión regular, sensible a mayúsculas/minúsculas</ENTRY>
	<ENTRY>'thomas' ~ '.*thomas.*'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> <literal>~*</literal> </ENTRY>
	<ENTRY>Coincide la expresión regular, insensible a mayúsculas/minúsculas</ENTRY>
	<ENTRY>'thomas' ~* '.*Thomas.*'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> <literal>!~</literal> </ENTRY>
	<ENTRY>No coincide la expresión regular, sensible a mayúsculas/minúsculas</ENTRY>
	<ENTRY>'thomas' !~ '.*Thomas.*'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> <literal>!~*</literal> </ENTRY>
	<ENTRY>No coincide la expresión regular, insensible a mayúsculas/minúsculas</ENTRY>
	<ENTRY>'thomas' !~* '.*vadim.*'</ENTRY>
       </ROW>
     </tbody>
    </tgroup>
   </table>

   <para>
    Las expresiones regulares <acronym>POSIX</acronym> aportan más potencia
		a la búsqueda por patrones que la función <function>LIKE</function>.
		Muchas herramientas Unix como <command>egrep</command>,
    <command>sed</command>, o <command>awk</command> usan un lenguaje de
		búsqueda por patrones similar al aquí descrito.
   </para>

   <para>
	  Una expresión regular es una secuencia de caracteres que es una
		definición abreviada de un conjunto de cadenas (un <firstterm>
		conjunto regular</firstterm>). Se dice que una cadena coincide con
		la expresión regular si es un miembro del conjunto regular descrito
		por la expresión regular. Igual que con <function>LIKE</function>, 
		los caracteres del patrón coinciden con los caracteres de la cadena
		a menos que contengan caracteres especiales para el lenguaje de
		expresiones regulares (las expresiones regulares utilizan 
		caracteres especiales diferentes a <function>LIKE</function>).
    A diferencia de los patrones de <function>LIKE</function>, a una 
		expresión regular se le permite buscar en cualquier parte dentro de 
		la cadena, a menos que la expresión regular se limite al comienzo o 
		fin de la cadena.
   </para>


<!-- derived from the re_format.7 man page -->
   <para>
    Las expresiones regulares (<quote>RE</quote>s), tal como se definen en 
		<acronym>POSIX</acronym> 1003.2, vienen en dos formas: las modernas REs 
		(aproximadamente las del comando <command>egrep</command>; 1003.2 las llama
    REs <quote>extendidas</quote>) y REs obsoletas (aprox. las del comando
    <command>ed</command>; para 1003.2 REs <quote>básicas</quote>).
    <productname>Postgres</productname> implementa la forma moderna.
   </para>

   <para>
		Una RE moderna es una o más <firstterm>secciones</firstterm> no vacías,
		separadas por <literal>|</literal>. Esto encuentra cualquier cosa que 
		coincida con una de las secciones.
   </para>

   <para>
    Una sección es una o más <firstterm>partes</firstterm>, concatenadas.
		Se realiza una búsqueda en la primera, seguida de una búsqueda para la
		segunda, etc.
   </para>

   <para>
    Una parte es un <firstterm>átomo</firstterm> seguido posiblemente de
		de un único carácter <literal>*</literal>, <literal>+</literal>,
    <literal>?</literal>, o <firstterm>límite</firstterm>. Un átomo
		seguido de un <literal>*</literal> busca una secuencia de cero o más
		coincidencias del átomo. Un átomo seguido de <literal>+</literal>
		busca una secuencia de una o más coincidencias del átomo. Un átomo
		seguido de <literal>?</literal> busca una secuencia de cero o una
		coincidencias del átomo.
   </para>

   <para>
    Un <firstterm>límite</firstterm> es <literal>{</literal> seguido de
		un entero decimal sin signo, posiblemente seguido de una
    <literal>,</literal> posiblemente seguido de otro entero decimal sin
		signo, y siempre terminado con <literal>}</literal>. Los enteros deben
		estar entre 0 y <symbol>RE_DUP_MAX</symbol> (255) ambos incluidos, y si
		están los dos, el primero no debe ser superior al segundo. Un átomo seguido
		de un límite que contenga un entero <replaceable>i</replaceable> sin coma
		realiza una búsqueda de exactamente <replaceable>i</replaceable> 
		coincidencias del átomo. Un átomo seguido de un límite que contenga
		un entero <replaceable>i</replaceable> y una coma realiza una búsqueda
		de <replaceable>i</replaceable> o más coincidencias del átomo. Un átomo
		seguido de un límite que contenga dos enteros
    <replaceable>i</replaceable> y <replaceable>j</replaceable>
    busca una secuencia de <replaceable>i</replaceable> hasta 
    <replaceable>j</replaceable> (incluidos) secuencias del átomo.
   </para>

   <note>
    <para>
     Un operador de repetición (<literal>?</literal>,
     <literal>*</literal>, <literal>+</literal>, o límite) no puede seguir
		 a otro operador de repetición. Un operador de repetición no puede 
		 comenzar una expresión o subexpresión o seguir a un
     <literal>^</literal> o <literal>|</literal>.
    </para>
   </note>

   <para>
    Un <firstterm>átomo</firstterm> es una expresión regular encerrada entre
    <literal>()</literal> (para buscar una coincidencia en una expresión
		regular), un conjunto vacío de <literal>()</literal> (para buscar la
		cadena nula), una <firstterm>expresión entre corchetes</firstterm> (ver
    más abajo), <literal>.</literal> (para buscar un solo carácter),
    <literal>^</literal> (para buscar una cadena nula al comienzo de la 
		cadena de entrada), <literal>$</literal> (para buscar una cadena nula
		al final de la cadena de entrada), una <literal>\</literal> seguida de uno
		de los caracteres <literal>^.[$()|*+?{\</literal> (para buscar ese
		carácter tomado como carácter ordinario), una <literal>\</literal>
		seguida de cualquier otro carácter (para buscar ese carácter tomado como
		carácter ordinario, como si la <literal>\</literal> no estuviera presente),
		o un único carácter sin otro significado (para buscar ese carácter).
    Una <literal>{</literal> seguida de cualquier otro carácter que no sea
		un dígito es un carácter ordinario, no el comienzo de un límite. Es ilegal
		finalizar una RE con <literal>\</literal>.
   </para>

   <para>
    Al tener ya la contrabarra (<literal>\</literal>) un significado especial
		en cadenas literales, para escribir una constante de patrón que contenga
		una contrabarra, se deberán escribir dos contrabarras.
   </para>

   <para>
    Una <firstterm>expresión entre corchetes</firstterm> es una lista de
		caracteres encerrados entre <literal>[]</literal>. Normalmente busca un
		único carácter de la lista (pero ver más abajo). Si la lista comienza
		por <literal>^</literal>, entonces busca un único caracter (pero ver más
		abajo) que no esté en la lista. Si dos caracteres de la lista están 
		separados por <literal>-</literal>, esto es un atajo para indicar el rango
		completo entre esos dos caracteres (ambos inclusive),
    ejemplo <literal>[0-9]</literal> en <acronym>ASCII</acronym> busca
		cualquier dígito decimal. Es ilegal que dos rangos compartan el punto
		final, ejemplo <literal>a-c-e</literal>. La secuencia de los rangos es
		muy dependiente de la plataforma, por lo que los programas portables
		deberían evitar confiar demasiado en ellos.
   </para>

   <para>
    Para incluir un <literal>]</literal> en la lista, se debe colocar como
		primer carácter (siguiendo a un posible <literal>^</literal>). Para
		incluir un <literal>-</literal>, se deberá poner al principio o al 
		final, o como punto final de un rango. Para usa un
    <literal>-</literal> como punto inicial de un rango, se debe encerrar
		entre <literal>[.</literal> y <literal>.]</literal>.
		Con la excepción de estas y algunas combinaciones que usan
    <literal>[</literal> (ver los siguientes párrafos), todos los demás
		caracteres especiales, incluyendo la <literal>\</literal>, pierden su
		significado especial al formar parte de una expresión entre corchetes.
   </para>

   <para>
		Dentro de una expresión entre corchetes, un elemento de cotejo (un
		carácter, una secuencia multicarácter que se coteja como si fuera un
		único carácter, o un nombre de secuencia de cotejo para cualquiera de los
		dos) encerrado entre <literal>[.</literal> y <literal>.]</literal>
		representa la secuencia de caracteres de ese elemento de cotejo. La
		secuencia es un único elemento de la lista de la expresión entre
		corchetes. Una expresión entre corchetes que contenga un elemento de
		cotejo multicarácter puede así buscar más de un carácter, por ejemplo,
		si la secuencia de cotejo incluye el elemento de cotejo
    <literal>ch</literal>, entonces la RE
    <literal>[[.ch.]]*c</literal> se iguala con los primero cinco caracteres
		de <literal>chchcc</literal>.
   </para>

   <para>
		Dentro de una expresión de corchetes, un elemento de cotejo encerrado
		entre <literal>[=</literal> y <literal>=]</literal> es una clase de
		equivalencia, representando las secuencias de caracteres de todos los
		elementos de cotejo equivalentes a ese, incluido si mismo. (Si no hay
		otros elementos de cotejo equivalentes, se trata como si los delimitadores
		fuesen <literal>[.</literal> y <literal>.]</literal>.) Por ejemplo, si
		<literal>o</literal> y <literal>^</literal> son miembros de una clase de
		equivalencia, entonces <literal>[[=o=]]</literal>, 
		<literal>[[=^=]]</literal>, y <literal>[o^]</literal> son todos sinónimos.
		Una clase de equivalencia no puede ser punto final de un rango.
   </para>

   <para>
	  Dentro de una expresión entre corchetes, el nombre de una clase de 
		caracteres encerrado entre <literal>[:</literal> y <literal>:]</literal>
		representa la lista de todos los caracteres que pertenecen a esa clase.
		Los nombre de clases de caracteres estándar son:
    <literal>alnum</literal>,
    <literal>alpha</literal>, <literal>blank</literal>,
    <literal>cntrl</literal>, <literal>digit</literal>,
    <literal>graph</literal>, <literal>lower</literal>,
    <literal>print</literal>, <literal>punct</literal>,
    <literal>space</literal>, <literal>upper</literal>,
    <literal>xdigit</literal>. Estos representan las clases de caracteres
		definidas en
    <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
		Un locale puede añadir otras. Una clase de caracteres no puede ser usada
		como punto final de un rango.
   </para>

   <para>
	  Hay dos clases especiales de expresiones entre caracteres:
    <literal>[[:<:]]</literal> y <literal>[[:>:]]</literal> buscan la cadena
		nula al principio y al final de una palabra respectivamente. Una palabra
		se defina como una secuencia de caracteres de palabra que no está
		precedida ni seguida de caracteres de palabra. Un carácter de palabra es
		un carácter alfanumérico (tal como se define en
    <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>)
		o un subrayado. Esto es una extensión, compatible pero no especificada por
		POSIX 1003.2, y debería ser usada con precaución en software que pueda
		ser portado a otros sistemas.
   </para>

   <para>
		En el caso de que una RE pudiera localizar más de una subcadena dentro
		de la cadena dada, la RE encuentra la que empieza primero en la cadena.
		Si la RE pudiera localizar más de una subcadena que empezara en el
		mismo punto, encontrará la más larga. Las subexpresiones también recogen
		las subcadenas más largas posibles, sujetas a la condición de que el
		emparejamiento total debe ser el más largo posible, con las 
		subexpresiones que empiezan antes tomando prioridad sobre las que 
		empiezan más tarde. Por tanto las subexpresiones con el nivel más alto
		toman de esta forma prioridad sobre sus componentes de más bajo nivel.
   </para>

   <para>
		La longitud de los emparejamientos se mide en caracteres, no en elementos
		de cotejo. Una cadena nula se considera más larga que ningún emparejamiento.
		Por ejemplo <literal>bb*</literal> se empareja con los tres caracteres del
		medio de <literal>abbbc</literal>,
    <literal>(wee|week)(knights|nights)</literal> casa con los diez caracteres
		de <literal>weeknights</literal>, cuando
    <literal>(.*).*</literal> se utiliza con
    <literal>abc</literal> la subexpresión entre paréntesis casa con los tres
		caracteres, y cuando <literal>(a*)*</literal> se enfrenta con
    <literal>bc</literal> tanto la RE completa como la subexpresión entre
		paréntesis recogen la cadena nula.
   </para>

   <para>
	 	Si se especifican búsquedas independientes de mayúsculas / minúsculas es
		como si las distinciones hubieran desaparecido del alfabeto. Cuando un 
		carácter alfabético aparece como carácter ordinario fuera de los 
		corchetes, es automáticamente transformado en una expresión entre
		corchetes que contienes ambos casos, p.ej:
    <literal>x</literal> se convierte en <literal>[xX]</literal>.
		Cuando aparece dentro de una expresión entre corchetes se añaden los
		demás casos a la expresión, p.ej:
    <literal>[x]</literal> se convierte en <literal>[xX]</literal> y
    <literal>[^x]</literal> se convierte en <literal>[^xX]</literal>.
   </para>

   <para>
		No hay un límite en la longitud de las REs, excepto el de la memoria
		disponible. El uso de memoria en aproximadamente lineal en el tamaño de
		las REs e insensible a la complejidad excepto para repeticiones de
		límites. Las repeticiones de límites se implementan por expansión de
		macros, lo que es costoso en tiempo y espacio si los números son grandes o
		los límites son anidados.
		Una RE como
    <literal>((((a{1,100}){1,100}){1,100}){1,100}){1,100}</literal>
		podría dejar sin espacio de swap a la máquina.
   </para>
<!-- end re_format.7 man page -->
  </sect2>

 </sect1>


  <sect1 id="functions-formatting">
   <title>Instrucciones de formato</title>

   <note>
    <title>Author</title>
    <para>
     Written by Karel Zak (<email>zakkr@zf.jcu.cz</email>) on 2000-01-24
    </para>
   </note>

   <para>
    Las funciones de formato de <productname>Postgres</productname>
		proporcionan un potente juego de herramientas para convertir varios
		tipos de datos (fecha/hora, enteros, punto flotante) a cadenas formateadas
		y viceversa. Estas funciones siguen un convenio común de llamada: el primer
		argumento es el valor a ser formateado y el segundo es una plantilla que
		define el formato de entrada o salida.
   </para>

   <para>
    <table tocentry="1">
     <title>Instrucciones de formato</title>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Función</entry>
	<entry>Devuelve</entry>
	<entry>Descripción</entry>
	<entry>Ejemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>to_char(timestamp, text)</entry>
	<entry>text</entry>
	<entry>convierte timestamp a string</entry>
	<entry>to_char(timestamp 'now','HH12:MI:SS')</entry>
       </row>
       <row>
	<entry>to_char(int, text)</entry>
	<entry>text</entry>
	<entry>convierte int4/int8 a string</entry>
	<entry>to_char(125, '999')</entry>
       </row>
       <row>
	<entry>to_char(double precision, text)</entry>
	<entry>text</entry>
	<entry>convierte real/double precision a string</entry>
	<entry>to_char(125.8, '999D9')</entry>
       </row>
       <row>
	<entry>to_char(numeric, text)</entry>
	<entry>text</entry>
	<entry>convierte numeric a string</entry>
	<entry>to_char(numeric '-125.8', '999D99S')</entry>
       </row>
       <row>
	<entry>to_date(text, text)</entry>
	<entry>date</entry>
	<entry>convierte string a date</entry>
	<entry>to_date('05 Dec 2000', 'DD Mon YYYY')</entry>
       </row>
       <row>
	<entry>to_timestamp(text, text)</entry>
	<entry>timestamp</entry>
	<entry>convierte string a timestamp</entry>
	<entry>to_timestamp('05 Dec 2000', 'DD Mon YYYY')</entry>
       </row>
       <row>
	<entry>to_number(text, text)</entry>
	<entry>numeric</entry>
	<entry>convierte string a numeric</entry>
	<entry>to_number('12,454.8-', '99G999D9S')</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
		En una plantilla de salida, hay ciertos patrones que se reconocen y se
		reemplazan con los datos apropiadamente formateados del valor a ser 
		formateado. Cualquier texto que no es patrón de plantilla es simplemente
		copiado literalmente. De forma parecida, en una plantilla de entrada, los
		patrones de plantilla identifican las partes de la cadena de entrada en las
		que se debe buscar y los valores que se encontrarán ahí.
   </para>

   <para>
    <table tocentry="1">
     <title>Patrones de plantilla para conversiones fecha/hora</title>
     <tgroup cols="2">
      <thead>
       <row>
	<entry>Patrón</entry>
	<entry>Descripción</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>HH</entry>
	<entry>hora del dia (01-12)</entry>
       </row>
       <row>
	<entry>HH12</entry>
	<entry>hora del dia (01-12)</entry>
       </row>       
       <row>
	<entry>HH24</entry>
	<entry>hora del dia (00-23)</entry>
       </row>       
       <row>
	<entry>MI</entry>
	<entry>minuto (00-59)</entry>
       </row>   
       <row>
	<entry>SS</entry>
	<entry>segundo (00-59)</entry>
       </row>
       <row>
	<entry>SSSS</entry>
	<entry>segundos pasados desde medianoche (0-86399)</entry>
       </row>
       <row>
	<entry>AM or A.M. or PM or P.M.</entry>
	<entry>indicador de meridiano (en mayúsculas)</entry>
       </row>
       <row>
	<entry>am or a.m. or pm or p.m.</entry>
	<entry>indicador de meridiano (en minúsculas)</entry>
       </row>
       <row>
	<entry>Y,YYY</entry>
	<entry>año (4 y más dígitos) con coma</entry>
       </row>
       <row>
	<entry>YYYY</entry>
	<entry>año (4 y más dígitos)</entry>
       </row>
       <row>
	<entry>YYY</entry>
	<entry>los últimos 3 dígitos del año</entry>
       </row>
       <row>
	<entry>YY</entry>
	<entry>los últimos 2 dígitos del año</entry>
       </row>
       <row>
	<entry>Y</entry>
	<entry>el último dígito del año</entry>
       </row>
       <row>
	<entry>BC or B.C. or AD or A.D.</entry>
	<entry>indicador de año (en mayúsculas)</entry>
       </row>
       <row>
	<entry>bc or b.c. or ad or a.d.</entry>
	<entry>indicador de año (en minúsculas)</entry>
       </row>
       <row>
	<entry>MONTH</entry>
	<entry>nombre completo del año en mayúsculas (relleno con blancos a 9 caracteres)full upper case month name (blank-padded to 9 chars)</entry>
       </row>
       <row>
	<entry>Month</entry>
	<entry>nombre completo del año con la primera en mayúsculas (relleno con blancos a 9 caracteres)</entry>
       </row>
       <row>
	<entry>month</entry>
	<entry>nombre completo del año en minúsculas (relleno con blancos a 9 caracteres)</entry>
       </row>
       <row>
	<entry>MON</entry>
	<entry>mes abreviado en mayúsculas (3 caracteres)abbreviated upper case month name (3 chars)</entry>
       </row>
       <row>
	<entry>Mon</entry>
	<entry>mes abreviado 1ª mayúscula (3 caracteres)</entry>
       </row>
       <row>
	<entry>mon</entry>
	<entry>mes abreviado en minúsculas (3 caracteres)</entry>
       </row>
       <row>
	<entry>MM</entry>
	<entry>número de mes (01-12)</entry>
       </row>
       <row>
	<entry>DAY</entry>
	<entry>nombre del dia completo en mayúsculas (relleno con blancos a 9 caracteres)</entry>
       </row>
       <row>
	<entry>Day</entry>
	<entry>nombre del dia completo 1ª mayúscula (relleno con blancos a 9 caracteres)</entry>
       </row>
       <row>
	<entry>day</entry>
	<entry>nombre del dia completo en minúsculas (relleno con blancos a 9 caracteres)</entry>
       </row>
       <row>
	<entry>DY</entry>
	<entry>nombre del dia abreviado en mayúsculas (3 caracteres)abbreviated upper case day name (3 chars)</entry>
       </row>
       <row>
	<entry>Dy</entry>
	<entry>nombre del dia abreviado 1ª mayúscula (3 caracteres)</entry>
       </row>
       <row>
	<entry>dy</entry>
	<entry>nombre del dia abreviado en minúsculas (3 caracteres)</entry>
       </row>
       <row>
	<entry>DDD</entry>
	<entry>dia del año (001-366)</entry>
       </row>
       <row>
	<entry>DD</entry>
	<entry>dia del mes (01-31)</entry>
       </row>
       <row>
	<entry>D</entry>
	<entry>dia de la semana (1-7; Domingo=1)</entry>
       </row>
       <row>
	<entry>W</entry>
	<entry>semana del mes (1-5) donde la 1ª semana empieza en el primer dia del mes</entry>
       </row> 
       <row>
	<entry>WW</entry>
	<entry>número de semana del año (1-53) donde la 1ª semana empieza en el primer dia del año</entry>
       </row>
       <row>
	<entry>IW</entry>
	<entry>número ISO de semana del año (el primer jueves del nuevo año está en la primera semana)</entry>
       </row>
       <row>
	<entry>CC</entry>
	<entry>siglo (2 dígitos)</entry>
       </row>
       <row>
	<entry>J</entry>
	<entry>dia Juliano (dias desde el 1 de enero de 4712 AC)</entry>
       </row>
       <row>
	<entry>Q</entry>
	<entry>trimestre del año (1-4)</entry>
       </row>
       <row>
	<entry>RM</entry>
	<entry>mes en números romanos (I-XII; I=enero) - mayúsculas</entry>
       </row>
       <row>
	<entry>rm</entry>
	<entry>mes en números romanos (i-xii; i=enero) - minúsculas</entry>
       </row>
       <row>
	<entry>TZ</entry>
	<entry>nombre de la zona horaria - mayúsculas</entry>
       </row>
       <row>
	<entry>tz</entry>
	<entry>nombre de la zona horaria - minúsculas</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
	  Existen modificadores para alterar el comportamiento de los patrones. Por
		ejemplo, <quote><literal>FMMonth</literal></quote>
    es el patrón <quote><literal>Month</literal></quote> con el prefijo
    <quote><literal>FM</literal></quote>.
   </para>

   <para>
    <table tocentry="1">
     <title>Modificadores para patrones de plantilla de conversión 
		     fecha/hora</title>
     <tgroup cols="3">
      <thead>
       <row>
	<entry>Modificador</entry>
	<entry>Descripción</entry>
	<entry>Ejemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>Prefijo <literal>FM</literal></entry>
	<entry>modo de relleno (suprime el relleno con blancos o ceros)</entry>
	<entry>FMMonth</entry>
       </row>
       <row>
	<entry>Sufijo <literal>TH</literal></entry>
	<entry>añade el sufijo ordinal en mayúsculas</entry>
	<entry>DDTH</entry>
       </row>	
       <row>
	<entry>Sufijo <literal>th</literal></entry>
	<entry>añade el sufijo ordinal en minúsculas</entry>
	<entry>DDth</entry>
       </row>
       <row>
	<entry>Prefijo <literal>FX</literal></entry>
	<entry>Opción de ajuste de formato global (ver más adelante)</entry>
	<entry>FX Month DD Day</entry>
       </row>	
       <row>
	<entry>Sufijo <literal>SP</literal></entry>
	<entry>modo hablado (no implementado aún)</entry>
	<entry>DDSP</entry>
       </row>       
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
    Notas de utilización:

    <itemizedlist>
     <listitem>
      <para>
       <literal>FM</literal> suprime el relleno con ceros o blancos que en 
			 otros casos se utiliza para hacer que la salida del patrón sea de
			 ancho fijo.
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_timestamp</function> y <function>to_date</function>
			 saltan espacios en blanco múltiples en la cadena de entrada si no
			 se utiliza la opción <literal>FX</literal>. <literal>FX</literal>
			 deberá usarse como primer elemento en la plantilla; por ejemplo 
       <literal>to_timestamp('2000    JUN','YYYY MON')</literal> es correcto,
			 pero
       <literal>to_timestamp('2000    JUN','FXYYYY MON')</literal> devuelve
			 error, porque <function>to_timestamp</function> espera un único espacio
			 en blanco.
      </para>
     </listitem>

     <listitem>
      <para>
       Si se desea una contrabarra (<quote><literal>\</literal></quote>) en
			 una constante de cadena, se deberá introducir una doble contrabarra
       (<quote><literal>\\</literal></quote>), por ejemplo
       <literal>'\\HH\\MI\\SS'</literal>. Esto se aplica para cualquier
			 constante de cadena en <productname>Postgres</productname>.
      </para>
     </listitem>

     <listitem>
      <para>
			 Se permite texto ordinario en plantillas <function>to_char</function>
			 y se sacará literalmente. Se puede poner una subcadena en comillas
			 dobles para forzar que sea interpretado como texto literal incluso
			 aunque contenga elementos de patrones. Por ejemplo, en
       <literal>'"Hello Year: "YYYY'</literal>, el <literal>YYYY</literal>
			 será reemplazado por el año de la fecha, pero el único
       <literal>Y</literal> no será reemplazado.
      </para>
     </listitem>

     <listitem>
      <para>
			 Si se quiere una comilla doble en la salida, se deberá preceder con
			 una contrabarra, por ejemplo <literal>'\\"YYYY Month\\"'</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       La conversión <literal>YYYY</literal> de cadena a timestamp está 
			 restringida si se usa un año de más de 4 dígitos. Se debe usar una 
			 plantilla o carácter no numérico despues de <literal>YYYY</literal>,
			 en caso contrario el año se interpretará como de 4 dígitos. Por ejemplo
			 (con el año 20000):
       <literal>to_date('200001131', 'YYYYMMDD')</literal> será interpretado
			 como un año de 4 dígitos; sería mejor usar un separador como:
       <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> o
       <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    <table tocentry="1">
     <title>Patrones de plantilla para conversiones numéricas</title>
     <tgroup cols="2">
      <thead>
       <row>
	<entry>Patrón</entry>
	<entry>Descripción</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>9</entry>
	<entry>valor con el número especificado de dígitos</entry>
       </row>
       <row>
	<entry>0</entry>
	<entry>valor con ceros rellenando por la izquierda</entry>
       </row>
       <row>
	<entry>. (punto)</entry>
	<entry>punto decimal</entry>
       </row>       
       <row>
	<entry>, (coma)</entry>
	<entry>separador de miles</entry>
       </row>
       <row>
	<entry>PR</entry>
	<entry>representación del valor negativo entre ángulos (&lt; &gt;)</entry>
       </row>
       <row>
	<entry>S</entry>
	<entry>representación del valor negativo con el signo menos (utiliza el locale)</entry>
       </row>
       <row>
	<entry>L</entry>
	<entry>símbolo de moneda (utiliza el locale)</entry>
       </row>
       <row>
	<entry>D</entry>
	<entry>punto decimal (utiliza el locale)</entry>
       </row>
       <row>
	<entry>G</entry>
	<entry>separador de miles (utiliza el locale)</entry>
       </row>
       <row>
	<entry>MI</entry>
	<entry>signo menos en la posición especificada (si el número < 0)</entry>
       </row>
       <row>
	<entry>PL</entry>
	<entry>signo más en la posición especificada (si el número > 0)</entry>
       </row>
       <row>
	<entry>SG</entry>
	<entry>signo más/menos en la posición especificada</entry>
       </row>
       <row>
	<entry>RN</entry>
	<entry>numeral romano (entrada entre 1 y 3999)</entry>
       </row>
       <row>
	<entry>TH or th</entry>
	<entry>convierte a número ordinal</entry>
       </row>
       <row>
	<entry>V</entry>
	<entry>desplaza <replaceable>n</replaceable> dígitos (ver notas)</entry>
       </row>
       <row>
	<entry>EEEE</entry>
	<entry>número en formato científico (aún no soportado)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
   Notas de uso:

    <itemizedlist>
     <listitem>
      <para>
			 Un signo formateado usando 'SG', 'PL' o 'MI' no es un ancla en el
			 número; por ejemplo,
       to_char(-12, 'S9999') produce <literal>'  -12'</literal>,
       pero to_char(-12, 'MI9999') produce <literal>'-  12'</literal>.
			 La implementación de Oracle no permite el uso de
       <literal>MI</literal> delante de <literal>9</literal>, más bien
			 requiere que <literal>9</literal> preceda a
       <literal>MI</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>9</literal> especifica un valor con tantos dígitos como
       <literal>9</literal>s. Si no hay dígito usa un espacio en blanco.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TH</literal> no convierte valores menores que cero y tampoco
			 convierte valores decimales.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>PL</literal>, <literal>SG</literal>, y
       <literal>TH</literal> son extensiones de 
			 <productname>Postgres</productname>.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>V</literal> multiplica los valores de entrada por
       <literal>10^<replaceable>n</replaceable></literal>, donde
       <replaceable>n</replaceable> es el número de dígitos detrás de
       <literal>V</literal>. 
       <function>to_char</function> no soporta el uso de
       <literal>V</literal> combinado con un punto decimal.
       (Ej:, no se permite <literal>99.9V99</literal>.)
      </para>
     </listitem>
    </itemizedlist>
   </para>   

   <para>
    <table tocentry="1">
     <title>Ejemplos de <function>to_char</function></title>
     <tgroup cols="2">
      <thead>
       <row>
	<entry>Entrada</entry>
	<entry>Salida</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>to_char(now(),'Day, DD  HH12:MI:SS')</entry>
        <entry><literal>'Martes  , 06  05:39:18'</literal></entry>
       </row>
       <row>
        <entry>to_char(now(),'FMDay, FMDD  HH12:MI:SS')</entry>
        <entry><literal>'Martes, 6  05:39:18'</literal></entry>
       </row>          
       <row>
        <entry>to_char(-0.1,'99.99')</entry>
        <entry><literal>' -.10'</literal></entry>
       </row>
       <row>
        <entry>to_char(-0.1,'FM9.99')</entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry>to_char(0.1,'0.9')</entry>
        <entry><literal>' 0.1'</literal></entry>
       </row>
       <row>
        <entry>to_char(12,'9990999.9')</entry>
        <entry><literal>'    0012.0'</literal></entry>
       </row>
       <row>
        <entry>to_char(12,'FM9990999.9')</entry>
        <entry><literal>'0012'</literal></entry>
       </row>
       <row>
        <entry>to_char(485,'999')</entry>
        <entry><literal>' 485'</literal></entry>
       </row>
       <row>
        <entry>to_char(-485,'999')</entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry>to_char(485,'9 9 9')</entry>
        <entry><literal>' 4 8 5'</literal></entry>
       </row>
       <row>
        <entry>to_char(1485,'9,999')</entry>
        <entry><literal>' 1,485'</literal></entry>
       </row>
       <row>
        <entry>to_char(1485,'9G999')</entry>
        <entry><literal>' 1 485'</literal></entry>
       </row>
       <row>
        <entry>to_char(148.5,'999.999')</entry>
        <entry><literal>' 148.500'</literal></entry>
       </row>
       <row>
        <entry>to_char(148.5,'999D999')</entry>
        <entry><literal>' 148,500'</literal></entry>	 
       </row>
       <row>
        <entry>to_char(3148.5,'9G999D999')</entry>
        <entry><literal>' 3 148,500'</literal></entry>
       </row>
       <row>
        <entry>to_char(-485,'999S')</entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>		
        <entry>to_char(-485,'999MI')</entry>
        <entry><literal>'485-'</literal></entry>	
       </row>
       <row>
        <entry>to_char(485,'999MI')</entry>
        <entry><literal>'485'</literal></entry>		
       </row>
       <row>
        <entry>to_char(485,'PL999')</entry>
        <entry><literal>'+485'</literal></entry>	
       </row>
       <row>		
        <entry>to_char(485,'SG999')</entry>
        <entry><literal>'+485'</literal></entry>	
       </row>
       <row>
        <entry>to_char(-485,'SG999')</entry>
        <entry><literal>'-485'</literal></entry>	
       </row>
       <row>
        <entry>to_char(-485,'9SG99')</entry>
        <entry><literal>'4-85'</literal></entry>	
       </row>
       <row>
        <entry>to_char(-485,'999PR')</entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>		
       </row>
       <row>
        <entry>to_char(485,'L999')</entry>
        <entry><literal>'DM 485</literal></entry>	 
       </row>
       <row>
        <entry>to_char(485,'RN')</entry>		
        <entry><literal>'        CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry>to_char(485,'FMRN')</entry>	
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry>to_char(5.2,'FMRN')</entry>
        <entry><literal>V</literal></entry>		
       </row>
       <row>
        <entry>to_char(482,'999th')</entry>
        <entry><literal>' 482nd'</literal></entry>				
       </row>
       <row>
        <entry>to_char(485, '"Good number:"999')</entry>
        <entry><literal>'Good number: 485'</literal></entry>
       </row>
       <row>
        <entry>to_char(485.8,'"Pre:"999" Post:" .999')</entry>
        <entry><literal>'Pre: 485 Post: .800'</literal></entry>
       </row>
       <row>
        <entry>to_char(12,'99V999')</entry>		
        <entry><literal>' 12000'</literal></entry>
       </row>
       <row>
        <entry>to_char(12.4,'99V999')</entry>
        <entry><literal>' 12400'</literal></entry>
       </row>
       <row>		
        <entry>to_char(12.45, '99V9')</entry>
        <entry><literal>' 125'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
  </sect1>


  <sect1 id="functions-datetime">
   <title>Funciones de Fecha/Hora</title>

   <para>
    <xref linkend="functions-datetime-table"> muestra las funciones
		disponibles para procesar fechas/horas. También están disponibles los
		operadores aritméticos básicos (<literal>+</literal>, 
		<literal>*</literal>, etc.). Para funciones de formateo, vea
		<xref linkend="functions-formatting">.  También debería familiarizarse
		con la información de fondo sobre los tipos de datos fecha/hora (vea
		<xref linkend="datatype-datetime">).
   </para>

    <table id="functions-datetime-table">
     <title>Funciones de Fecha/Hora</title>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Nombre</entry>
	<entry>Valor devuelto</entry>
	<entry>Descripción</entry>
	<entry>Ejemplo</entry>
	<entry>Resultado</entry>
       </row>
      </thead>

      <tbody>
       <row>
	<entry>age(timestamp)</entry>
	<entry>interval</entry>
	<entry>Resta de la fecha actual</entry>
	<entry>age(timestamp '1957-06-13')</entry>
	<entry>43 años 8 meses 3 dias</entry>
       </row>

       <row>
	<entry>age(timestamp, timestamp)</entry>
	<entry>interval</entry>
	<entry>Resta los argumentos</entry>
	<entry>age('2001-04-10', timestamp '1957-06-13')</entry>
	<entry>43 años 9 meses 27 dias</entry>
       </row>

       <row>
	<entry>current_date</entry>
	<entry>date</entry>
	<entry>Fecha actual; vea <link linkend="functions-datetime-current">
	más adelante</link>
	</entry>
	<entry></entry>
	<entry></entry>
       </row>

       <row>
	<entry>current_time</entry>
	<entry>time</entry>
	<entry>Hora actual; vea <link
	 linkend="functions-datetime-current">más adelante</link>
	</entry>
	<entry></entry>
	<entry></entry>
       </row>

       <row>
	<entry>current_timestamp</entry>
	<entry>timestamp</entry>
	<entry>Fecha y hora actual; vea también <link
	 linkend="functions-datetime-current">más adelante</link>
	</entry>
	<entry></entry>
	<entry></entry>
       </row>

       <row>
	<entry>date_part(text, timestamp)</entry>
	<entry>double precision</entry>
	<entry>Obtiene un subcampo (equivale a
	 <function>extract</function>); vea también <link
	 linkend="functions-datetime-datepart">más adelante</link>
        </entry>
	<entry>date_part('hour', timestamp '2001-02-16 20:38:40')</entry>
	<entry>20</entry>
       </row>

       <row>
	<entry>date_part(text, interval)</entry>
	<entry>double precision</entry>
	<entry>Obtiene un subcampo (equivale a
	 <function>extract</function>); vea también <link
	 linkend="functions-datetime-datepart">más adelante</link>
        </entry>
	<entry>date_part('month', interval '2 years 3 months')</entry>
	<entry>3</entry>
       </row>

       <row>
	<entry>date_trunc(text, timestamp)</entry>
	<entry>timestamp</entry>
	<entry>Trunca a la precisión especificada; vea también <link
         linkend="functions-datetime-trunc">más adelante</link>
        </entry>
	<entry>date_trunc('hour', timestamp '2001-02-16 20:38:40')</entry>
	<entry>2001-02-16 20:00:00+00</entry>
       </row>

       <row>
	<entry>extract(<parameter>field</parameter> from timestamp)</entry>
	<entry>double precision</entry>
	<entry>Obtiene subcampo; vea también <link
         linkend="functions-datetime-extract">más adelante</link>
        </entry>
	<entry>extract(hour from timestamp '2001-02-16 20:38:40')</entry>
	<entry>20</entry>
       </row>

       <row>
	<entry>extract(<parameter>field</parameter> from interval)</entry>
	<entry>double precision</entry>
	<entry>Obtiene subcampo; vea también <link
         linkend="functions-datetime-extract">below</link>
        </entry>
	<entry>extract(month from interval '2 years 3 months')</entry>
	<entry>3</entry>
       </row>

       <row>
	<entry>isfinite(timestamp)</entry>
	<entry>boolean</entry>
	<entry>Comprueba que el timestamp sea finito (que no sea inválido ni
	infinito)<entry>
	<entry>isfinite(timestamp '2001-02-16 21:28:30')</entry>
	<entry>true</entry>
       </row>

       <row>
	<entry>isfinite(interval)</entry>
	<entry>boolean</entry>
	<entry>Comprueba que el intervalo sea finito</entry>
	<entry>isfinite(interval '4 hours')</entry>
	<entry>true</entry>
       </row>

       <row>
	<entry>now()</entry>
	<entry>timestamp</entry>
	<entry>Fecha y hora actual; (equivalente a
	 <function>current_timestamp</function>); vea también <link
	 linkend="functions-datetime-current">más adelante.</link>
	</entry>
	<entry></entry>
	<entry></entry>
       </row>

       <row>
	<entry>timeofday()</entry>
	<entry>text</entry>
	<entry>Fecha y hora con alta precisión; vea también <link
	 linkend="functions-datetime-current">más adelante.</link>
	</entry>
	<entry>timeofday()</entry>
	<entry>Wed Feb 21 17:01:13.000126 2001 EST</entry>
       </row>

       <row>
	<entry>timestamp(date)</entry>
	<entry>timestamp</entry>
	<entry>De fecha a timestamp</entry>
	<entry>timestamp(date '2000-12-25')</entry>
	<entry>2000-12-25 00:00:00</entry>
       </row>

       <row>
	<entry>timestamp(date, time)</entry>
	<entry>timestamp</entry>
	<entry>De fechay hora a timestamp</entry>
	<entry>timestamp(date '1998-02-24',time '23:07')</entry>
	<entry>1998-02-24 23:07:00</entry>
       </row>
      </tbody>
     </tgroup>
    </table>


  <sect2 id="functions-datetime-extract">
   <title><function>EXTRACT</function>, <function>date_part</function></title>

<synopsis>
EXTRACT (<replaceable>campo</replaceable> FROM <replaceable>fuente</replaceable>)
</synopsis>

   <para>
    La función <function>extract</function> devuelve subcampos de valores de
		fecha/hora, tales como año o hora.
    <replaceable>fuente</replaceable> es una expresión que es evaluada como
		tipo <type>timestamp</type> o <type>interval</type>. (Las expresiones de
		tipo <type>date</type> o <type>time</type> serán convertidas a 
    <type>timestamp</type> con lo que también pueden usarse).
    <replaceable>campo</replaceable> es un identificador o cadena que 
		selecciona el campo que se va a extraer del valor fuente.
    La función <function>extract</function> devuelve valores de tipo
    <type>double precision</type>.
		Los siguientes son valores válidos:

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term>century</term>
      <listitem>
       <para>
        El año dividido por 100.
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>20</computeroutput>
</screen>
       </informalexample>

       <para>
			  Observe que el resultado del campo century es simplemente el año 
				dividido por 100 y no la definición convencional de siglo que indica 
				que, por ejemplo, los años de 1900-1999 pertenecen al siglo 20.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>day</term>
      <listitem>
       <para>
        El dia del mes (1 - 31)
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>16</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>decade</term>
      <listitem>
       <para>
        The año dividido por 10.
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>200</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>dow</term>
      <listitem>
       <para>
        El dia de la semana (0-6; Domingo es 0) (sólo para valores
        <type>timestamp</type>)
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>5</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>doy</term>
      <listitem>
       <para>
        El dia del año (1 - 365/366) (sólo para valores <type>timestamp</type>)
       </para>
       <informalexample>
<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>47</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>epoch</term>
      <listitem>
       <para>
        Para valores <type>date</type> y <type>timestamp</type>, el número de
				segundos desde 01-01-1970 00:00:00 (El resultado puede ser negativo);
				para valores <type>interval</type>, el número total de segundos del
				intervalo.
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>982352320</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Resultado: </lineannotation><computeroutput>442800</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>hour</term>
      <listitem>
       <para>
        El campo hora (0 - 23)
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>20</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>microseconds</term>
      <listitem>
       <para>
        Los segundos, incluyendo la parte fraccional, multiplicado por 1000000.
				Esto incluye segundos completos.
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Resultado: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>millennium</term>
      <listitem>
       <para>
        El año dividido por 1000
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>2</computeroutput>
</screen>
       </informalexample>

       <para>
				El resultado de millennium el simplemente el año dividido por 1000, no
				la definición convencional de milenio que indica que, p.ej., los años 
				1900-1999 pertenecen al segundo milenio.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>milliseconds</term>
      <listitem>
       <para>
				Los segundos, incluyendo la parte fracional, multiplicado por 1000. 
				Esto incluye segundos completos.
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Resultado: </lineannotation><computeroutput>28500</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>minute</term>
      <listitem>
       <para>
        Los minutos (0 - 59)
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>38</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>month</term>
      <listitem>
       <para>
        Para valores <type>timestamp</type>, el número de mes dentro del año
				(1 - 12); para valores <type>interval</type> el resto del número de
				meses dividido por 12 (0-11)
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Resultado: </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Resultado: </lineannotation><computeroutput>1</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>quarter</term>
      <listitem>
       <para>
        El trimestre del año (1 - 4) en el que está la fecha dada (sólo para
				valores <type>timestamp</type>)
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>1</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>second</term>
      <listitem>
       <para>
				Los segundos, incluyendo parte fraccional (0 - 59)
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Resultado: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>week</term>
      <listitem>
       <para>
        Para valores <type>timestamp</type>, calcula el número de semana
				del año en el que está el dia. Por definición
        (<acronym>ISO</acronym> 8601), la primera semana del año contiene
				el 4 de enero de ese año.  (La semana <acronym>ISO</acronym>
				empieza en lunes). Dicho de otra forma, el primer jueves del año
				está en la semana primera de ese año.
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>7</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>year</term>
      <listitem>
       <para>
        El año
       </para>

       <informalexample>
<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>2001</computeroutput>
</screen>
       </informalexample>
      </listitem>
     </varlistentry>

<!--
tz
tz_hour
tz_minute
-->

    </variablelist>

   </para>

   <para>
    La función <function>extract</function> está pensada principalmente para
		cálculo. Para formatear valores fecha/hora, vea
    <xref linkend="functions-formatting">.
   </para>

   <anchor id="functions-datetime-datepart">
   <para>
    La función <function>date_part</function> se ha modelado como un 
		equivalente <productname>Ingres</productname> a la función
		<function>extract</function> de <acronym>SQL</acronym>.
<synopsis>
date_part('<replaceable>campo</replaceable>', <replaceable>fuente</replaceable>)
</synopsis>
    Observe que aquí el <replaceable>campo</replaceable> debe ser una string.
		Los valores válidos de campo para <function>date_part</function> son los
		mismos que para <function>extract</function>.
   </para>

   <informalexample>
<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes')
<lineannotation>Resultado: </lineannotation><computeroutput>4</computeroutput>
</screen>
   </informalexample>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

   <para>
    La función <function>date_trunc</function> es similar conceptualmente
		a la función <function>trunc</function> que se usa para números.
   </para>

   <para>
<synopsis>
date_trunc('<replaceable>campo</replaceable>', <replaceable>fuente</replaceable>)
</synopsis>
    <replaceable>fuente</replaceable> es una expresión de tipo
    <type>timestamp</type> (los valores de tipo <type>date</type> y
    <type>time</type> se convierten automáticamente).
    <replaceable>campo</replaceable> selecciona a que precisión se quiere
		truncar el valor timestamp. El valor devuelto es de tipo
    <type>timestamp</type> con todos los campos que son menores que el 
		seleccionado puestos a cero (excepto dia y mes, que se ponen a 1)
   </para>

   <para>
    Valores válidos para <replaceable>campo</replaceable> son:
    <simplelist>
     <member>microseconds</member>
     <member>milliseconds</member>
     <member>second</member>
     <member>minute</member>
     <member>hour</member>
     <member>day</member>
     <member>month</member>
     <member>year</member>
     <member>decade</member>
     <member>century</member>
     <member>millennium</member>
    </simplelist>
   </para>

   <informalexample>
    <para>
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>2001-02-16 20:00:00+00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Resultado: </lineannotation><computeroutput>2001-01-01 00:00:00+00</computeroutput>
</screen>
    </para>
   </informalexample>
  </sect2>

  <sect2 id="functions-datetime-current">
   <title>Fecha/hora actual</title>

   <para>
		Están disponibles las siguientes funciones para obtener la fecha y/o hora
		actuales:
<synopsis>
CURRENT_TIME
CURRENT_DATE
CURRENT_TIMESTAMP
</synopsis>
		Observe que debido a los requerimientos del estándar
    <acronym>SQL</acronym>, estas funciones no deben ser llamadas dentro de
		paréntesis arrastrados.
   </para>

   <informalexample>
<screen>
SELECT CURRENT_TIME;
<computeroutput>19:07:32</computeroutput>

SELECT CURRENT_DATE;
<computeroutput>2001-02-17</computeroutput>

SELECT CURRENT_TIMESTAMP;
<computeroutput>2001-02-17 19:07:32-05</computeroutput>
</screen>
   </informalexample>

   <para>
    La función <function>now()</function> es el equivalente
    <productname>Postgres</productname> a 
    <function>CURRENT_TIMESTAMP</function>.
   </para>

   <para>
    También está la función <function>timeofday()</function>, que devuelve
		la hora con mayor precisión de la que lo hace 
    <function>CURRENT_TIMESTAMP</function>
   </para>

   <informalexample>
<screen>
SELECT timeofday();
 Sat Feb 17 19:07:32.000126 2001 EST
</screen>
   </informalexample>

   <para>
    <function>timeofday()</function> usa la llamada al sistema operativo
    <function>gettimeofday(2)</function>, que puede tener precisión de
		microsegundos (dependiendo de la plataforma); las otras funciones se
		basan en <function>time(2)</function> que está limitada a resolución
		de un segundo. Por razones históricas, <function>timeofday()</function>
		devuelve su resultado como cadena de texto en vez de valor timestamp.
   </para>

   <para>
		Es bastante importante entender que <function>CURRENT_TIMESTAMP</function>
		y las demás funciones relacionadas devuelven la hora del comienzo de la
		transacción actual; sus valores no cambian mientras se ejecuta la
		transacción, pero <function>timeofday()</function> devuelve realmente
		la hora actual.
   </para>

   <para>
		Todos los tipos de datos fecha/hora también aceptan el literal especial
    <literal>now</> para especificar la fecha/hora actual. Por tanto, las
		tres líneas siguientes devuelven el mismo valor:
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';
</programlisting>
    <note>
     <para>
			No se necesita usar la tercera forma para especificar un valor por
			defecto cuando se crea una tabla. El sistema convertirá
			<literal>now</> a timestamp tan pronto como la constante sea analizada,
			por lo que cuando se necesite el valor por defecto se usará la fecha de
			creación de la tabla. Las dos primeras formas no serán evaluadas
			hasta que se use el valor por defecto, porque son llamadas a funciones.
			De esta forma darán el comportamiento deseado de dar el valor de la fecha
			de inserción de la fila.
     </para>
    </note>
   </para>
  </sect2>
 </sect1>

  
 <sect1 id="functions-geometry">
   <title>Funciones y operadores geométricos</title>

   <para>
		Los tipos geométricos point (punto), box (rectángulo), lseg (segmento de
		línea), line (recta), path (camino), polygon (polígono), y
    circle (círculo) tienen un conjunto importante de funciones y operadores
		de soporte nativo.
   </para>

   <table>
     <TITLE>Operadores geométricos</TITLE>
     <TGROUP COLS="3">
      <THEAD>
       <ROW>
	<ENTRY>Operador</ENTRY>
	<ENTRY>Descripción</ENTRY>
	<ENTRY>Uso</ENTRY>
       </ROW>
      </THEAD>
      <TBODY>
       <ROW>
	<ENTRY> + </ENTRY>
	<ENTRY>Traslación</ENTRY>
	<ENTRY>box '((0,0),(1,1))' + point '(2.0,0)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> - </ENTRY>
	<ENTRY>Traslación</ENTRY>
	<ENTRY>box '((0,0),(1,1))' - point '(2.0,0)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> * </ENTRY>
	<ENTRY>Escalado / Rotación</ENTRY>
	<ENTRY>box '((0,0),(1,1))' * point '(2.0,0)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> / </ENTRY>
	<ENTRY>Escalado / Rotación</ENTRY>
	<ENTRY>box '((0,0),(2,2))' / point '(2.0,0)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> # </ENTRY>
	<ENTRY>Intersección</ENTRY>
	<ENTRY>'((1,-1),(-1,1))' # '((1,1),(-1,-1))'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> # </ENTRY>
	<ENTRY>Número de puntos del polígono</ENTRY>
	<ENTRY># '((1,0),(0,1),(-1,0))'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> ## </ENTRY>
	<ENTRY>Punto más cercano</ENTRY>
	<ENTRY>point '(0,0)' ## lseg '((2,0),(0,2))'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &amp;&amp; </ENTRY>
	<ENTRY>¿Se solapa?</ENTRY>
	<ENTRY>box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &amp;&lt; </ENTRY>
	<ENTRY>¿Se solapa por la izquierda?</ENTRY>
	<ENTRY>box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &amp;&gt; </ENTRY>
	<ENTRY>¿Se solapa por la derecha?</ENTRY>
	<ENTRY>box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &lt;-&gt; </ENTRY>
	<ENTRY>Distancia entre elementos</ENTRY>
	<ENTRY>circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &lt;&lt; </ENTRY>
	<ENTRY>¿Está a su izquierda?</ENTRY>
	<ENTRY>circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &lt;^ </ENTRY>
	<ENTRY>¿Está debajo?</ENTRY>
	<ENTRY>circle '((0,0),1)' &lt;^ circle '((0,5),1)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &gt;&gt; </ENTRY>
	<ENTRY>¿Está a la derecha?</ENTRY>
	<ENTRY>circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &gt;^ </ENTRY>
	<ENTRY>¿Está encima?</ENTRY>
	<ENTRY>circle '((0,5),1)' >^ circle '((0,0),1)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> ?# </ENTRY>
	<ENTRY>Insersecta o solapa</ENTRY>
	<ENTRY>lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))';</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> ?- </ENTRY>
	<ENTRY>¿Está horizontal?</ENTRY>
	<ENTRY>point '(1,0)' ?- point '(0,0)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> ?-| </ENTRY>
	<ENTRY>¿Está perpendicular?</ENTRY>
	<ENTRY>lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> @-@  </ENTRY>
	<ENTRY>Longitud de la circunferencia</ENTRY>
	<ENTRY>@-@ path '((0,0),(1,0))'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> ?| </ENTRY>
	<ENTRY>¿Está vertical?</ENTRY>
	<ENTRY>point '(0,1)' ?| point '(0,0)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> ?|| </ENTRY>
	<ENTRY>¿Es paralelo?</ENTRY>
	<ENTRY>lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> @ </ENTRY>
	<ENTRY>Está contenido o encima</ENTRY>
	<ENTRY>point '(1,1)' @ circle '((0,0),2)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> @@ </ENTRY>
	<ENTRY>Centro del elemento</ENTRY>
	<ENTRY>@@ circle '((0,0),10)'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> ~= </ENTRY>
	<ENTRY>Igual a</ENTRY>
	<ENTRY>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</ENTRY>
       </ROW>
      </TBODY>
     </TGROUP>
   </TABLE>

   <table>
     <title>Funciones geométricas</title>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Función</entry>
	<entry>Devuelve</entry>
	<entry>Descripción</entry>
	<entry>Ejemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>area(objecto)</entry>
	<entry>double precision</entry>
	<entry>area del elemento</entry>
	<entry>area(box '((0,0),(1,1))')</entry>
       </row>
       <row>
	<entry>box(box, box)</entry>
	<entry>box</entry>
	<entry>box de intersección</entry>
	<entry>box(box '((0,0),(1,1))',box '((0.5,0.5),(2,2))')</entry>
       </row>
       <row>
	<entry>center(object)</entry>
	<entry>point</entry>
	<entry>center del elemento</entry>
	<entry>center(box '((0,0),(1,2))')</entry>
       </row>
       <row>
	<entry>diameter(circle)</entry>
	<entry>double precision</entry>
	<entry>diámetro del círculo</entry>
	<entry>diameter(circle '((0,0),2.0)')</entry>
       </row>
       <row>
	<entry>height(box)</entry>
	<entry>double precision</entry>
	<entry>tamaño vertical del box</entry>
	<entry>height(box '((0,0),(1,1))')</entry>
       </row>
       <row>
	<entry>isclosed(path)</entry>
	<entry>boolean</entry>
	<entry>¿Está el camino cerrado?</entry>
	<entry>isclosed(path '((0,0),(1,1),(2,0))')</entry>
       </row>
       <row>
	<entry>isopen(path)</entry>
	<entry>boolean</entry>
	<entry>¿Está el camino abierto?</entry>
	<entry>isopen(path '[(0,0),(1,1),(2,0)]')</entry>
       </row>
       <row>
	<entry>length(object)</entry>
	<entry>double precision</entry>
	<entry>longitud del elemento</entry>
	<entry>length(path '((-1,0),(1,0))')</entry>
       </row>
       <row>
	<entry>pclose(path)</entry>
	<entry>path</entry>
	<entry>convierte el camino en camino cerrado</entry>
	<entry>pclose(path '[(0,0),(1,1),(2,0)]')</entry>
       </row>
<!--
Not defined by this name. Implements the intersection operator '#'
       <row>
	<entry>point(lseg,lseg)</entry>
	<entry>point</entry>
	<entry>intersection</entry>
	<entry>point(lseg '((-1,0),(1,0))',lseg '((-2,-2),(2,2))')</entry>
       </row>
-->
       <row>
	<entry>npoint(path)</entry>
	<entry>int4</entry>
	<entry>número de puntos</entry>
	<entry>npoints(path '[(0,0),(1,1),(2,0)]')</entry>
       </row>
       <row>
	<entry>popen(path)</entry>
	<entry>path</entry>
	<entry>convierte el camino en camino abierto</entry>
	<entry>popen(path '((0,0),(1,1),(2,0))')</entry>
       </row>
       <row>
	<entry>radius(circle)</entry>
	<entry>double precision</entry>
	<entry>radio del círculo</entry>
	<entry>radius(circle '((0,0),2.0)')</entry>
       </row>
       <row>
	<entry>width(box)</entry>
	<entry>double precision</entry>
	<entry>tamaño horizontal</entry>
	<entry>width(box '((0,0),(1,1))')</entry>
       </row>
      </tbody>
     </tgroup>
   </table>


   <table>
     <title>Funciones de conversión de tipos geométricos</title>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Función</entry>
	<entry>Devuelve</entry>
	<entry>Descripción</entry>
	<entry>Ejemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>box(circle)</entry>
	<entry>box</entry>
	<entry>circle a box</entry>
	<entry>box(circle '((0,0),2.0)')</entry>
       </row>
       <row>
	<entry>box(point, point)</entry>
	<entry>box</entry>
	<entry>points a box</entry>
	<entry>box(point '(0,0)', point '(1,1)')</entry>
       </row>
       <row>
	<entry>box(polygon)</entry>
	<entry>box</entry>
	<entry>polygon a box</entry>
	<entry>box(polygon '((0,0),(1,1),(2,0))')</entry>
       </row>
       <row>
	<entry>circle(box)</entry>
	<entry>circle</entry>
	<entry>box a circle</entry>
	<entry>circle(box '((0,0),(1,1))')</entry>
       </row>
       <row>
	<entry>circle(point, double precision)</entry>
	<entry>circle</entry>
	<entry>point a circle</entry>
	<entry>circle(point '(0,0)', 2.0)</entry>
       </row>
       <row>
	<entry>lseg(box)</entry>
	<entry>lseg</entry>
	<entry>lseg con la diagonal de la box</entry>
	<entry>lseg(box '((-1,0),(1,0))')</entry>
       </row>
       <row>
	<entry>lseg(point, point)</entry>
	<entry>lseg</entry>
	<entry>points a lseg</entry>
	<entry>lseg(point '(-1,0)', point '(1,0)')</entry>
       </row>
       <row>
	<entry>path(polygon)</entry>
	<entry>point</entry>
	<entry>polygon a path</entry>
	<entry>path(polygon '((0,0),(1,1),(2,0))')</entry>
       </row>
       <row>
	<entry>point(circle)</entry>
	<entry>point</entry>
	<entry>punto centro</entry>
	<entry>point(circle '((0,0),2.0)')</entry>
       </row>
       <row>
	<entry>point(lseg, lseg)</entry>
	<entry>point</entry>
	<entry>intersección</entry>
	<entry>point(lseg '((-1,0),(1,0))', lseg '((-2,-2),(2,2))')</entry>
       </row>
       <row>
	<entry>point(polygon)</entry>
	<entry>point</entry>
	<entry>centro</entry>
	<entry>point(polygon '((0,0),(1,1),(2,0))')</entry>
       </row>
       <row>
	<entry>polygon(box)</entry>
	<entry>polygon</entry>
	<entry>polygon de 12 puntos</entry>
	<entry>polygon(box '((0,0),(1,1))')</entry>
       </row>
       <row>
	<entry>polygon(circle)</entry>
	<entry>polygon</entry>
	<entry>polygon de 12 puntos</entry>
	<entry>polygon(circle '((0,0),2.0)')</entry>
       </row>
       <row>
	<entry>polygon(<replaceable class="parameter">npts</replaceable>, circle)</entry>
	<entry>polygon</entry>
	<entry>polygon de <replaceable class="parameter">npts</replaceable> puntos</entry>
	<entry>polygon(12, circle '((0,0),2.0)')</entry>
       </row>
       <row>
	<entry>polygon(path)</entry>
	<entry>polygon</entry>
	<entry>path a polygon</entry>
	<entry>polygon(path '((0,0),(1,1),(2,0))')</entry>
       </row>
      </tbody>
     </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-net">
   <title>Funciones para tipos de direcciones de red</title>


    <table tocentry="1" id="cidr-inet-operators-table">
     <title>Operadores para <type>cidr</> and <type>inet</></title>
     <TGROUP COLS="3">
      <THEAD>
       <ROW>
	<ENTRY>Operador</ENTRY>
	<ENTRY>Descripción</ENTRY>
	<ENTRY>Uso</ENTRY>
       </ROW>
      </THEAD>
      <TBODY>
       <ROW>
	<ENTRY> &lt; </ENTRY>
	<ENTRY>Menor que</ENTRY>
	<ENTRY>inet '192.168.1.5' &lt; inet '192.168.1.6'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &lt;= </ENTRY>
	<ENTRY>Menor o igual que</ENTRY>
	<ENTRY>inet '192.168.1.5' &lt;= inet '192.168.1.5'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> = </ENTRY>
	<ENTRY>Igual a</ENTRY>
	<ENTRY>inet '192.168.1.5' = inet '192.168.1.5'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &gt;= </ENTRY>
	<ENTRY>Mayor o igual que</ENTRY>
	<ENTRY>inet '192.168.1.5' &gt;= inet '192.168.1.5'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &gt; </ENTRY>
	<ENTRY>Mayor que</ENTRY>
	<ENTRY>inet '192.168.1.5' &gt; inet '192.168.1.4'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &lt;&gt; </ENTRY>
	<ENTRY>No igual a</ENTRY>
	<ENTRY>inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &lt;&lt; </ENTRY>
	<ENTRY>Está contenida en</ENTRY>
	<ENTRY>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &lt;&lt;= </ENTRY>
	<ENTRY>Es igual o está contenida en</ENTRY>
	<ENTRY>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &gt;&gt; </ENTRY>
	<ENTRY>contiene a</ENTRY>
	<ENTRY>inet'192.168.1/24' &gt;&gt; inet '192.168.1.5'</ENTRY>
       </ROW>
       <ROW>
	<ENTRY> &gt;&gt;= </ENTRY>
	<ENTRY>contiene o es igual a</ENTRY>
	<ENTRY>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</ENTRY>
       </ROW>
      </TBODY>
     </TGROUP>
    </TABLE>

    <para>
     Todos los operadores para <type>inet</type> pueden ser aplicados a
     <type>cidr</type>. Los operadores
     <literal>&lt;&lt;</>, <literal>&lt;&lt;=</>,
     <literal>&gt;&gt;</>, <literal>&gt;&gt;=</>
		 comprueban la inclusión en subred: consideran solamente las partes de
		 red de las dos direcciones, ignorando la parte del servidor y determinan
		 cuando una parte de red es idéntica o es una subred de la otra.
    </para>


    <table tocentry="1" id="cidr-inet-functions">
     <title>Funciones de <type>cidr</> y <type>inet</></title>
     <tgroup cols="5">
      <thead>
       <row>
	<entry>Función</entry>
	<entry>Devuelve</entry>
	<entry>Descripción</entry>
	<entry>Ejemplo</entry>
	<entry>Resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>broadcast(inet)</entry>
	<entry>inet</entry>
	<entry>dirección de broadcast de una red</entry>
	<entry>broadcast('192.168.1.5/24')</entry>
	<entry>192.168.1.255/24</entry>
       </row>
       <row>
	<entry>host(inet)</entry>
	<entry>text</entry>
	<entry>extrae la dirección IP como texto</entry>
	<entry>host('192.168.1.5/24')</entry>
	<entry>192.168.1.5</entry>
       </row>
       <row>
	<entry>masklen(inet)</entry>
	<entry>integer</entry>
	<entry>Longitud de la máscara de red</entry>
	<entry>masklen('192.168.1.5/24')</entry>
	<entry>24</entry>
       </row>
       <row>
	<entry>netmask(inet)</entry>
	<entry>inet</entry>
	<entry>genera la máscara de red para la dirección</entry>
	<entry>netmask('192.168.1.5/24')</entry>
	<entry>255.255.255.0</entry>
       </row>
       <row>
	<entry>network(inet)</entry>
	<entry>cidr</entry>
	<entry>extrae la parte de red de la dirección</entry>
	<entry>network('192.168.1.5/24')</entry>
	<entry>192.168.1.0/24</entry>
       </row>
       <row>
	<entry>text(inet)</entry>
	<entry>text</entry>
	<entry>extrae la dirección IP y la longitud de la máscara como texto</entry>
	<entry>text(inet '192.168.1.5')</entry>
	<entry>192.168.1.5/32</entry>
       </row>
       <row>
	<entry>abbrev(inet)</entry>
	<entry>text</entry>
	<entry>extrae la dirección abreviada como texto</entry>
	<entry>abbrev(cidr '10.1.0.0/16')</entry>
	<entry>10.1/16</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Todas las funciones de <type>inet</type> pueden ser aplicadas a
    <type>cidr</type>. Las funciones <function>host</>(),
    <function>text</>(), y <function>abbrev</>() están pensadas principalmente
		para ofrecer formatos de presentación alternativos.
   </para>

   <para>
    <table tocentry="1" id="macaddr-functions">
     <title>Funciones para <type>macaddr</></title>
     <tgroup cols="5">
      <thead>
       <row>
	<entry>Función</entry>
	<entry>Devuelve</entry>
	<entry>Descripción</entry>
	<entry>Ejemplo</entry>
	<entry>Resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>trunc(macaddr)</entry>
	<entry>macaddr</entry>
	<entry>Asigna cero a los 3 últimos bytes</entry>
	<entry>trunc(macaddr '12:34:56:78:90:ab')</entry>
	<entry>12:34:56:00:00:00</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
    La función <function>trunc</>(<type>macaddr</>) devuelve una dirección
		MAC con los 3 últimos bytes puestos a 0. Esto puede utilizarse para
		asociar el prefijo restante a un fabricante. El directorio
    <filename>contrib/mac</> en la distribución fuente contiene algunas
		funciones para crear y mantener una tabla de asociaciones.
   </para>

   <para>
    El tipo <type>macaddr</> también soporta los operadores estándar 
		tradicionales (<literal>&gt;</>, <literal>&lt;=</>, etc.) para ordenación
		lexicográfica.
   </para>

  </sect1>


 <sect1 id="functions-conditional">
  <title>Expresiones condicionales</title>

  <para>
	 Esta sección describe las expresiones condicionales de 
   <acronym>SQL</acronym>disponibles en <productname>Postgres</productname>.
  </para>

  <tip>
   <para>
		Si necesita ir más allá de las posibilidades de estas expresiones
		condicionales debería considerar escribir un procedimiento almacenado
		en un lenguaje de programación más capacitado.
   </para>
  </tip>

  <bridgehead renderas="sect2">CASE</bridgehead>

<synopsis>
CASE WHEN <replaceable>condición</replaceable> THEN <replaceable>resultado</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>resultado</replaceable></optional>
END
</synopsis>

  <para>
	 La <token>CASE</token> de <acronym>SQL</acronym> es una expresión
	 condicional genérica, similar a las sentencias if/else de otros 
	 lenguajes. Las claúsulas <token>CASE</token> pueden se usadas allá donde
	 sea válida una expresión. <replaceable>condición</replaceable> es una
	 expresión que devuelve un resultado <type>boolean</type>. Si el resultado
	 es verdadero entonces el valor de la expresión <token>CASE</token> es
   <replaceable>resultado</replaceable>. Si el resultado es falso entonces se
	 siguen recorriendo las <token>WHEN</token> subsiguientes de la misma forma.
	 Si ninguna <replaceable>condición</replaceable> es verdadera, entonces el
	 valor de la expresión CASE es el <replaceable>resultado</replaceable> de la
	 claúsula <token>ELSE</token>. Si se ha omitido la claúsula 
	 <token>ELSE</token> y no se cumple ninguna condición, entonces el 
	 resultado es NULL.
  </para>

  <informalexample>
   <para>
    Un ejemplo :
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM test;</userinput>
<computeroutput>
 a
---
 1
 2
 3
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT a, CASE WHEN a=1 THEN 'uno' WHEN a=2 THEN 'dos' ELSE 'otro' END FROM test;</userinput>
<computeroutput>
 a | case
---+-------
 1 | uno
 2 | dos
 3 | otro
</computeroutput>
</screen>
   </para>
  </informalexample>

  <para>
   Los tipos de datos de todas la expresiones 
	 <replaceable>resultado</replaceable> deben ser convertibles a un solo
	 tipo de salida.
   Vea <xref linkend="typeconv-union-case"> para más detalles.
  </para>

<synopsis>
CASE <replaceable>expresión</replaceable>
    WHEN <replaceable>valor</replaceable> THEN <replaceable>resultado</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>resultado</replaceable></optional>
END
</synopsis>

  <para>
   Esta expresión <token>CASE</token> <quote>sencilla</quote> es una variante
	 especializada de la forma general vista arriba.
   La <replaceable>expresión</replaceable> es computada y comparada con todos
	 los <replaceable>valor</replaceable>es en las claúsulas
   <token>WHEN</token> hasta que se encuentra uno que sea igual. Si no se
	 encuentra, se devuelve el <replaceable>resultado</replaceable> de la
   claúsula <token>ELSE</token> (o NULL). Esto es similar a la sentencia
   <function>switch</function> de C.
  </para>

  <informalexample>
   <para>
    Veamos el ejemplo anterior usando la sintaxis <token>CASE</token> sencilla:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT a, CASE a WHEN 1 THEN 'uno' WHEN 2 THEN 'dos' ELSE 'otro' END FROM test;</userinput>
<computeroutput>
 a | case
---+-------
 1 | uno
 2 | dos
 3 | otro
</computeroutput>
</screen>
    </para>
   </informalexample>

   <bridgehead renderas="sect2">COALESCE</bridgehead>

<synopsis>
<function>COALESCE</function>(<replaceable>valor</replaceable><optional>, ...</optional>)
</synopsis>

  <para>
   La función <function>COALESCE</function> devuelve el primero de sus 
	 argumentos que no es NULL. Es útil con frecuencia para sustituir un valor por
	 defecto para valores nulos cuando se recogen datos para mostrar, por
	 ejemplo:
<programlisting>
SELECT COALESCE(descripcion, descripcion_corta, '(ninguno)') ...
</programlisting>
  </para>

 <bridgehead renderas="sect2">NULLIF</bridgehead>

<synopsis>
<function>NULLIF</function>(<replaceable>valor1</replaceable>, <replaceable>valor2</replaceable>)
</synopsis>

  <para>
   La función <function>NULLIF</function> devuelve NULL si y sólo si el
   <replaceable>valor1</replaceable> y el <replaceable>valor2</replaceable>
	 son iguales. En otro caso devuelve <replaceable>valor1</replaceable>.
	 Esto puede ser usado para realizar la operación inversa al ejemplo con
   <function>COALESCE</function> visto arriba:
<programlisting>
SELECT NULLIF(valor, '(ninguno)') ...
</programlisting>
  </para>

  <tip>
   <para>
    <function>COALESCE</function> y <function>NULLIF</function> son únicamente
		atajos para expresiones <token>CASE</token>. Son realmente convertidas
		a expresiones <token>CASE</token> en una primera fase de proceso, y los
		subsiguientes procesos "piensan" que están tratando con una
    <token>CASE</token>. De esta forma, una función 
		<function>COALESCE</function> o <function>NULLIF</function> incorrectas
		pueden lanzar un mensaje de error que se refiere a una
    <token>CASE</token>.
   </para>
  </tip>

 </sect1>


  <sect1 id="functions-misc">
   <title>Funciones misceláneas</>

   <table>
    <title>Funciones misceláneas</>
    <tgroup cols="3">
     <thead>
      <row><entry>Nombre</> <entry>Tipo devuelto</> <entry>Descripción</></row>
     </thead>

     <tbody>
      <row>
       <entry>current_user</>
       <entry>name</>
       <entry>nombre del usuario del contexto actual de ejecución</>
      </row>
      <row>
       <entry>session_user</>
       <entry>name</>
       <entry>nombre del usuario de la sesión</>
      </row>
      <row>
       <entry>user</>
       <entry>name</>
       <entry>equivalente a <function>current_user</></>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    El <function>session_user</> es el usuario que ha iniciado la conexión a 
		la base de datos y es fijo durante toda esa conexión.
    <function>current_user</> es el usuario al que se le aplican los permisos.
		Actualmente es igual al usuario de sesión, pero en el futuro, podrían
		aparecer funciones <quote>setuid</> y otras utilidades para permitir el
		cambio temporal de usuario. En el idioma Unix, el session_user es el
		<quote>usuario real</> y el current_user el <quote>usuario efectivo</>.
   </para>

   <para>
    Dentro de <acronym>SQL</>, estas funciones deben ser llamadas sin 
		paréntesis arrastrados.
   </para>

   <note>
    <title>Desaprobadas</>
    <para>
     La función <function>getpgusername()</> es un equivalente obsoleto de
     <function>current_user</>.
    </para>
   </note>
  </sect1>


 <sect1 id="functions-aggregate">
  <title>Funciones estadísticas</title>

  <note>
   <title>Author</title>
   <para>
    Written by Isaac Wilcox <email>isaac@azartmedia.com</email> on 2000-06-16
   </para>
  </note>

  <para>
   Las <firstterm>funciones estadísticas</firstterm> calculan un único resultado
	 de un conjunto de valores de entrada. Las consideraciones sintácticas 
	 especiales de las funciones estadísticas se explican en
	 <xref linkend="syntax-aggregates">.  Consulte el <citetitle>Tutorial de
	 PostgreSQL</citetitle> para información adicional.
  </para>

  <table tocentry="1">
   <title>Funciones estadísticas</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Función</entry>
      <entry>Descripción</entry>
      <entry>Notas</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>AVG(<replaceable class="parameter">expresión</replaceable>)</entry>
      <entry>La media arimética de los valores de entrada</entry>
      <entry>
			 El cálculo del valor medio está disponible para los siguiente tipos de
			 datos: <type>smallint</type>, <type>integer</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>, <type>interval</type>.
       El resultado es de tipo <type>numeric</type> para cualquier valor entero,
       <type>double precision</type> para valores de punto flotante, y en los
			 demás casos es igual al tipo de los valores de entrada.
      </entry>
     </row>

     <row>
      <entry>COUNT(*)</entry>
      <entry>Número de los valores de entrada</entry>
      <entry>The valor devuelto es de tipo<type>integer</type>.</entry>
     </row>

     <row>
      <entry>COUNT(<replaceable class="parameter">expresión</replaceable>)</entry>
      <entry>
       Cuenta los valores de entrada para los que la <replaceable
       class="parameter">expresión</replaceable> no es nula.
      </entry>
      <entry></entry>
     </row>

     <row>
      <entry>MAX(<replaceable class="parameter">expresión</replaceable>)</entry>
      <entry>El valor máximo de la <replaceable class="parameter">expresión</replaceable> a lo largo de los valores de entrada</entry>
      <entry>
			 Disponible para todos los datos numéricos, cadenas y tipos fecha/hora.
			 El resultado es del mismo tipo que la expresión de entrada.
      </entry>
     </row>

     <row>
      <entry>MIN(<replaceable class="parameter">expresión</replaceable>)</entry>
      <entry>El valor mínimo de la <replaceable class="parameter">expresión</replaceable> en los valores de entrada</entry>
      <entry>
			 Disponible para todos los datos numéricos, cadenas y tipos fecha/hora.
			 El resultado es del mismo tipo que la expresión de entrada.
      </entry>
     </row>

     <row>
      <entry>STDDEV(<replaceable class="parameter">expresión</replaceable>)</entry>
      <entry>La desviación estándar de los valores de entrada</entry>
      <entry>
			 Está disponible para los siguientes tipos de datos:
       <type>smallint</type>, <type>integer</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>. El resultado es de tipo
       <type>double precision</type> para entrada de punto flotante, y en los
			 otros casos, <type>numeric</type>.
      </entry>
     </row>

     <row>
      <entry>SUM(<replaceable class="parameter">expresion</replaceable>)</entry>
      <entry>Suma de <replaceable class="parameter">expresión</replaceable> en 
			los valores de entrada</entry>
      <entry>
			 Está disponible para los siguientes tipos de datos:
       <type>smallint</type>, <type>integer</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>, <type>interval</type>.
       El resultado es de tipo <type>numeric</type> para cualquier valor entero,
       <type>double precision</type> para entrada de punto flotante, y en los
			 demás casos, igual al tipo de los valores de entrada.
      </entry>
     </row>

     <row>
      <entry>VARIANCE(<replaceable class="parameter">expresión</replaceable>)</entry>
      <entry>La varianza de los valores de entrada</entry>
      <entry>
			 La varianza es la raíz de la desviación estándar. Se soportan los mismos
			 tipos de datos.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Se debería hacer notar que excepto para <function>COUNT</function>,
	 estas funciones devuelven NULL cuando no se seleccionan filas. En
	 particular, <function>SUM</function> de ninguna fila devuelve NULL, no
	 cero como se podría esperar.
  </para>

 </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
