<Chapter Id="protocol">
<DocInfo>
<Author>
<FirstName>Phil</FirstName>
<Surname>Thompson</Surname>
</Author>
<Date>1998-08-08</Date>
</DocInfo>
<Title>Protocolo Frontend/Backend</Title>

<Para>
<Note>
<Para>
Escrito por <ULink url="mailto:phil@river-bank.demon.co.uk">Phil Thompson</ULink>.
Actualizaciones del protocolo por <ULink url="mailto:tgl@sss.pgh.pa.us">Tom Lane</ULink>.
</Para>
</Note>
</para>

<Para>
<ProductName>Postgres</ProductName> utiliza un protocolo basado en mensajes
para la comunicación entre frontend y backends. El protocolo  está implementado
sobre <Acronym>TCP/IP</Acronym> y también sobre Unix sockets.
<ProductName>Postgres</ProductName> v6.3 introdució números de versión en el
protocolo.
Esto fue hecho de tal forma que aún permite conexiones desde versiones
anteriores de los frontends, pero este documento no cubre el protocolo utilizado
por esas versiones.
</para>

<Para>
Este documento describe la versión 2.0 del protocolo, implementada en 
<ProductName>Postgres</ProductName> v6.4 y posteriores.
</para>

<Para>
Las características de alto nivel sobre este protocolo (por ejemplo, como
<FileName>libpq</FileName> pasa ciertas variables de entorno despues de que
la comunicación es establecida), son tratadas en otros lugares.
</para>

<Sect1>
<Title>Introducción</Title>

<Para>
Los tres principales componentes son el frontend (ejecutandose en el clicente)
y el postmaster y backend (ejecutandose en el servidor). El postmaster y 
backend juegan diferentes roles pero pueden ser implementados por el mismo
ejecutable.
</para>

<Para>
Un frontend envía un paquete de inicio al postmaster. Este incluye los nombres
del usuario y base de datos a la que el usuario quiere conectarse. El postmaster
entonces utiliza esto, y la información en el fichero pg_hba.conf(5) para
determinar que información adicional de autentificación necesita del frontend
(si existe) y responde al frontend en concordancia.
</para>

<Para>
El frontend envía entonces cualquier información de autentificación requerida.
Una vez que el postmaster valida esta información responde al frontend que está
autentificado y entrega una conexión a un backend. El backend entonces envía un
mensaje indicando arranque correcto (caso normal) o fallo (por ejemplo, un
nombre de base de datos inválido).
</para>

<Para>
Las subsiguientes comunicaciones son paquetes de consulta y resultados
intercambiados entre el frontend y backend. El postmaster no interviene
ya en la comunicación ordinaria de cosultas/resultados. Sin embargo el
postmaster se involucra cuando el frontend desea cancelar una consulta
que se esté efectuando en su backend. Más detalles sobre esto aparecen
más abajo.
</para>

<Para>
Cuando el frontend desea desconectar envía un paquete apropiado y cierra
la conexión sin esperar una respuesta del backend.
</para>

<Para>
Los paquetes son enviados como un flujo de datos. El primer byte determina
que se debería esperar en el resto del paquete. La excepción son los paquetes
enviados desde un frontend al postmaster, los cuales incluyen la longitud
del paquete y el resto de él. Esta diferencia es histórica.
</para>
</sect1>

<Sect1>
<Title>Protocolo</Title>

<Para>
Esta sección describe el flujo de mensajes. Existen cuatro tipos diferentes
de flujo dependiendo del estado de la conexión: inicio, consulta, llamada
de función y final. Existen tambien provisiones especiales para notificación
de respuestas y cancelación de comandos, que pueden ocurrir en cualquier
instante despues de la fase de inicio.
</para>


<Sect2>
<Title>Inicio</Title>

<Para>
El inicio se divide en fase de autentificación y fase de arranque del
backend.
</para>

<Para>
Inicialmente, el frontend envía un StartupPacket. El postmaster utiliza
esta información y el contenido del fichero pg_hba.conf(5) para determinar
que método de autentificación debe emplear. El postmaster responde entonces
con uno de los siguientes mensajes:
</para>

<Para>
<VariableList>
<VarListEntry>
<Term>
	ErrorResponse
</Term>
<ListItem>
<Para>
        El postmaster cierra la comunicación inmediatamente.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	AuthenticationOk
</Term>
<ListItem>
<Para>
        El postmaster entonces cede la comunicación al backend. El
        postmaster no toma parte en la comunicación posteriormente.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	AuthenticationKerberosV4
</Term>
<ListItem>
<Para>
        El frontend debe tomar parte en una diálogo de autentificación
        Kerberos V4 (no descrito aquí) con el postmaster. En caso de
        éxito, el postmaster responde con un AuthenticationOk, en caso
        contrario responde con un ErrorResponse.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	AuthenticationKerberosV5
</Term>
<ListItem>
<Para>
        El frontend debe tomar parte en un diálogo de autentificación
        Kerberos V5 (no descrito aquí) con el postmaster. En caso de
        éxito, el postmaster responde con un AuthenticationOk, en
        otro caso responde con un ErrorResponse.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	AuthenticationUnencryptedPassword
</Term>
<ListItem>
<Para>
        El frontend debe enviar un UnencryptedPasswordPacket. Si este
        es el password correcto, el postmaster responde con un
        AuthenticationOk, en caso contrario responde con un 
        ErrorResponse.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	AuthenticationEncryptedPassword
</Term>
<ListItem>
<Para>
        El frontend debe enviar un EncryptedPasswordPacket. Si este
        esel password correcto, el postmaster responde con un
        AuthenticationOk, en caso contrario responde con un
        ErrorResponse.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>

<Para>
Si el frontend no soporta el método de autentificación requerido por el
postmaster, debería cerrar inmediatamente la conexión.
</para>

<Para>
Despues de enviar AuthenticationOk, el postmaster intenta lanzar un
proceso backend. Como esto podría fallar, o el backend podría encontrar
un error durante el arranque, el frontend debe esperar por una confirmación
de inicio correcto del backend. El frontend no debería enviar mensajes
en este momento. Los posibles mensajes procedentes del backend durante esta
fase son:

<VariableList>
<VarListEntry>
<Term>
	BackendKeyData
</Term>
<ListItem>
<Para>
        Este mensaje es enviado despues de un inicio correcto
        del backend. Proporciona una clave secreta que el frontend
        debe guardar is quiere ser capaz de enviar peticiones de
        cancelación más tarde. El frontend no debería responder a
        este mensaje, pero podría continuar escuchando por un
        mensaje ReadyForQuery.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	ReadyForQuery
</Term>
<ListItem>
<Para>
        El arranque del backend tuvo éxito. El frontend puede ahora
        enviar mensajes de peticiones o llamandas a función.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	ErrorResponse
</Term>
<ListItem>
<Para>
        El arranque del backend no tuvo éxito. La conexión es
        cerrada despues de enviar este mensaje.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	NoticeResponse
</Term>
<ListItem>
<Para>
        Se envía un mensaje de advertencia. El frontend debería
        mostrar un mensaje pero debería continuar a la espera de
        un mensaje ReadyForQuery o ErrorResponse.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>

<Para>
El mensaje ReadyForQuery es el mismo que el backend debe enviar despues de
cada ciclo de consulta. Dependiendo de las necesiades de codificado del
frontend, es razonable considerar ReadyForQuery como iniciando un ciclo
de consulta (y entonces BackendKeyData indica una conclusión correcta de
la fase de inicio), o considerar ReadyForQuery como finalizando la fase
de arranque y cada subsiguiente ciclo de consulta.
</para>
</sect2>

<Sect2>
<Title>Consulta</Title>

<Para>
Un ciclo de consulta se inicia por el frontend enviando un mensaje Query
al backend. El backend entonces envía uno o más mensajes de respuesta
dependiendo del contenido de la cadea de consulta, y finalmente un 
mensaje ReadyForQuery. ReadyForQuery informa al frontend que puede enviar
una nueva consulta o llamada de función de forma segura.
</para>

<Para>
Los posibles mensajes del backend son:

<VariableList>
<VarListEntry>
<Term>
	CompletedResponse
</Term>
<ListItem>
<Para>
        Una sentencia SQL se completó con normalidad.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	CopyInResponse
</Term>
<ListItem>
<Para>
        El backend está preparado para copiar datos del frontend
        a una relación. El frontend debería enviar entonces un
        mensaje CopyDataRows. El backend responde con un mensaje
        CompletedResponse con un tag de "COPY".
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	CopyOutResponse
</Term>
<ListItem>
<Para>
        El backend está listo para copiar datos de una relación al
        frontend. El envía entonces un mensaje CopyDataRows, y
        un mensaje CompletedResponse con un tag de "COPY".
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	CursorResponse
</Term>
<ListItem>
<Para>
        La consulta fue bien un insert(l), delete(l), update(l),
        fetch(l) o una sentencia select(l).
                Si la transacción ha sido abortada entonces el backend envía
                un mensaje CompletedResponse con un tag "*ABORT STATE*". En
                otro caso las siguientes respuesta son enviadas.
</Para>
<Para>
		Para una sentencia insert(l), el backend envía un mensaje 
		CompletedResponse con un tag de "INSERT <Replaceable>oid</Replaceable> 
        <Replaceable>rows</Replaceable>"
		donde <Replaceable>rows</Replaceable> es el número de filas insertadas, y 
        <Replaceable>oid</Replaceable> es el ID de objeto de la fila insertada si
		<Replaceable>rows</Replaceable> es 1, en otro caso <Replaceable>oid</Replaceable>
		es 0.
</Para>
<Para>
        Para una sentencia delete(l), el backend envía un mensaje CompletedResponse con
        un tag de "DELETE <Replaceable>rows</Replaceable>" donde <Replaceable>rows</Replaceable>
        es el número de filas borradas.
</Para>
<Para>
        Para una sentencia update(l) el backend envía un mensaje CompletedResponse
        con un tag de "UPDATE <Replaceable>rows</Replaceable>" 
        donde <Replaceable>rows</Replaceable>
        es el número de filas modificadas.
</Para>
<Para>
		para una sentencia fetch(l) o select(l), el backend envía un mensaje
		RowDescription.  Es seguido después con un mensaje AsciiRow o BinaryRow
        (dependiendo de si fué especificado un cursor binario) para cada fila que
        es envíada al frontend. Por último, el backend envía un mensaje CompletedResponse
        con un tag de "SELECT".
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	EmptyQueryResponse
</Term>
<ListItem>
<Para>
        Se encontro una caden de consulta vacía. (La necesidad de
        distinguir este caso concreto es histórica).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	ErrorResponse
</Term>
<ListItem>
<Para>
        Ocurrió un error.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	ReadyForQuery
</Term>
<ListItem>
<Para>
        El procesado de la cadena de consulta se completó. Un mensaje
        seperado es enviado para indicar esto debido a que la cadena de
        consulta puede contener múltiples sentencias SQL. (CompletedResponse
        marca el final el procesado del una sentencia SQL, no de toda   
        la cadena). Siempre se enviará ReadyForQuery, bien el procesado
        terminase con éxito o con error.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	NoticeResponse
</Term>
<ListItem>
<Para>
        Un mensaje de advertencia fué enviado en relación con la
        consulta. Estas advertencias se envían en adición a otras
        respuestas, es decir, el backend continuará procesando la  
        sentencia.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>

<Para>
Un frontend debe estar preparado para aceptar mensaje ErrorResponse
y NoticeResponse cuando se espere cualquier otro tipo de mensaje.
</para>

<Para>
De hecho, es posible que NoticeResponse se reciba incluso cuando el frontned
no está esperando ningún tipo de mensaje, es decir, cuando el backend está
normalmente inactivo. En particular, el frontend puede solicitar la
finalización del backend. En este caso se envía una NoticeResponse antes
de cerrar la conexión. Se recomienda que el frontend compruebe esas advertencias
asíncronas antes de enviar cada sentencia.
</para>

<Para>
También, si el frontend envía cualquier comando listen(l), entonces debe estar
preparado para aceptar mensajes NotificationResponse en cualquier momento.
Véase más abajo.
</para>
</sect2>

<Sect2>
<Title>Llamada a función</Title>

<Para>
Un ciclo de llamada a función se inicia por el frontend enviando un mensaje
FunctionCall al backend. El backend entonces envía uno o más mensajes de
respueste dependiendo de los resultados de la llamada a función, y finalmente
un mensaje ReadyForQuery. ReadyForQuery informa al frontend que puede enviar
una nueva consulta o llamada a función de forma segura.
</para>

<Para>
Los posibles mensajes de respuesta provinientes de backend son:

<VariableList>
<VarListEntry>
<Term>
	ErrorResponse
</Term>
<ListItem>
<Para>
        Ocurrió un error.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	FunctionResultResponse
</Term>
<ListItem>
<Para>
        La llamada a función fue ejecutada y devolvió un resultado.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	FunctionVoidResponse
</Term>
<ListItem>
<Para>
        La llamada a función fue ejecutada y no devolvió resultados.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	ReadyForQuery
</Term>
<ListItem>
<Para>
        El procesado de la llamada a función se completó. ReadyForQuery
        se enviará siempre, aunque el procesado termine con éxito o error.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	NoticeResponse
</Term>
<ListItem>
<Para>
        Un mensaje de advertencia se generó en relación con la llamada
        a función. Estas advertencias aparecen en adición a otras
        respuestas, es decir, el backend continuará procesando el
        comando.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>

<Para>
El frontend debe estar preparado para aceptar mensajes ErrorResponse y 
NoticeResponse cuando se esperen otro tipo de mensajes. También si
envía cualquier comando listen(l) debe estar preparado para aceptar
mensajes NotificationResponse en cualquier momento, véase más abajo.
</para>
</sect2>

<Sect2>
<Title>Respuestas de notificación</Title>

<Para>
Si un frontend envía un comando listen(l), entonces el backend enviará
un mensaje NotificationResponse (no se confunca con NoticeResponse!)
cuando un comando notify(l) sea ejecutado para el mismo nombre de
notificación.
</para>

<Para>
Las respuestas de notificación son permitidas en cualquier punto en el
protocolo (despues del inicio), excepto dentro de otro mensaje del
backend. Así, el frontend debe estar preparado para reconocer un mensaje
NotificationResponse cuando está esperando cualquier mensaje. De hecho
debería ser capaz de manejar mensajes NotificationResponse incluso cuando
no está envuelto en una consulta.

<VariableList>
<VarListEntry>
<Term>
	NotificationResponse
</Term>
<ListItem>
<Para>
        Un comando notify(l) ha sido ejecutado para un nombre para
        el que se ejecutó previamente un comando listen(l). Se
        pueden enviar notifiaciones en cualquier momento.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>

<Para>
Puede merecer la pena apuntar que los nombres utilizados en los comandos
listen y notify no necesitan tener nada que ver con los nombres de
relaciones (tablas) y bases de datos SQL. Los nombres de notificación
son simplemente nombres arbitrariamente seleccionados.
</para>
</sect2>

<Sect2>
<Title>Cancelación de peticiones en progreso</Title>

<Para>
Durante el procesado de una consulta, el frontend puede solicitar la cancelación
de la consulta mediante el envío de una peticion apropiada al postmaster. La
petición de cancelación no es enviada directamente al backend por razones de
eficiencia de implementación: no deseamos tener al backend constantemente
esperando nuevos datos del frontend durante el procesado de consultas. Las
peticiones de cancelación deberían ser relativamente infrecuentes, por lo que
las hacemos un poco mas voluminosas con el fín de evitar una penalización en el
caso normal.
</para>

<Para>
Para enviar una petición de cancelación, el frontend abre una nueva
conexión con el postmaster y envía un mensaje CancelRequest, en vez del
mensaje StartupPacket que enviaría normalmente en una nueva conexión. El
postmaster procesará esta petición y cerrará la conexión. Por razones de
seguridad, no se envía una respuesta directa al mensaje de cancelación.
</para>

<Para>
Un mensaje CancelRequest será ignorado a menos que contenga los mismos
datos clave (PID y clave secreta) enviados al frontend durante el inicio
de la conexión. Si la petición contiene el PID e clave secreta el backend
aborta el procesado de la consulta actual.
</para>

<Para>
La señal de cancelación puede tener o no tener efectos - por ejemplo, si llega
despues de que el backend haya finalizado de procesar la petición, entonces
no tendrá efecto. Si la cancelación es efectiva, produce la terminación prematura
del comando actual dando un mensaje de error.
</para>

<Para>
La consecuencia de todo esto es que por razones tanto de seguridad como
de eficiencia, el frontend no tiene forma directa de decidir cuando una
petición de cancelación tuvo éxito. Debe continuar esperando hasta que
el backend responda a al petición. Enviar unha petición de cancelación
simplemente aumenta las probabilidades de que la consulta actual finalice
pronto, y aumenta las probabilidades de que falle con un mensaje de error
en vez de terminar con éxito.
</para>

<Para>
Ya que la petición de cancelación es enviada al postmaster y no a través
del enlace normal frontend/backend, es posible que cualquier proceso
realice la petición, no sólo el frontend cuya consulta va a ser cancelada.
Esto puede tener algún beneficio de cara a aumentar la flexibilidad al
diseñar aplicaciones multi-proceso. Tambien introduce un riesgo de 
seguridad, ya que personas no autorizadas podrían intentar cancelar
consultas. El riesgo de seguridad es afrontado requiriendo la clave
secreta generada dinámicamente.
</para>
</sect2>

<Sect2>
<Title>Finalización</Title>

<Para>
El procedimiento de finalización normal es que el frontend envíe un
mensaje Terminate y cierre inmediatamente la conexión. Al recibir el
mensaje, el backend cierra inmediatamente la conexión y finaliza.
</para>

<Para>
Una finalización anormal puede ocurrir debido a fallos de software (i.e. core
dump) en cualquier extremo. Si el frontend o el backend ve un cierre inexperado
de la conexión, debería liberar resursos y finalizar. El frontend tiene la
opción de lanzar un nuevo backen recontactando el postmaster, si lo desea.
</para>
</sect2>
</sect1>

<Sect1>
<Title>Tipos de Datos de Mensajes</Title>

<Para>
Esta sección describo los tipos básicos de datos utilizados en los mensajes.

<VariableList>
<VarListEntry>
<Term>
	Int<Replaceable>n</Replaceable>(<Replaceable>i</Replaceable>)
</Term>
<ListItem>
<Para>
		Un entero <Replaceable>n</Replaceable> en orden de bytes de red.
                Si <Replaceable>i</Replaceable> está especificado es
                el valor literal. P.e. Int16, Int32(42).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	LimString<Replaceable>n</Replaceable>(<Replaceable>s</Replaceable>)
</Term>
<ListItem>
<Para>
		Un array de caracteres de exactamente <Replaceable>n</Replaceable> bytes interpretado como
        una cadena terminada en '\0'.
		El '\0' se omite si no existe espacio suficiente. Si <Replaceable>s</Replaceable> está
        especificado entonces es el valor literal.
		P.e. LimString32, LimString64("user").
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String(<Replaceable>s</Replaceable>)
</Term>
<ListItem>
<Para>
		Una cadena de C convencional terminada en '\0' sin limitación de longitud.
		Si <Replaceable>s</Replaceable> está especificada es el valor literal.
		P.e. String, String("user").
</Para>
		
<Note>
<Para>
<Emphasis>No existe límite predefinido </Emphasis> para la longitud de una cadena que
puede ser retornada por el backend. Una buena estrategia a utilizar por el frontend
consiste en usar un buffer expandible para que cualquier cosa que quepa en memoria
pueda ser aceptada. Si esto no es posible, se debe leer toda la cadena y deshechar
los caracteres que no quepan en el buffer de longitud fija.
</Para>
</Note>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Byte<Replaceable>n</Replaceable>(<Replaceable>c</Replaceable>)
</Term>
<ListItem>
<Para>
		Exactamente <Replaceable>n</Replaceable> bytes.  Si <Replaceable>c</Replaceable> está
        especificade es el valor literal.
		P.e. Byte, Byte1('\n').
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</sect1>

<Sect1>
<Title>Formatos de Mensajes</Title>

<Para>
Esta seccion describe el formato detallado de cada mensaje. Cana uno puede
ser enviado por un frontend (F), por un backend (B) o por ambos (F y B).
</para>

<VariableList>
<VarListEntry>
<Term>
AsciiRow (B)
</Term>
<ListItem>
<Para>
<VariableList>
<VarListEntry>
<Term>
	Byte1('D')
</Term>
<ListItem>
<Para>
		Identifica el mensaje como una fila de datos <Acronym>ASCII</Acronym> .
		(Un mensaje previo RowDescription define el número de campos en la fila
        y sus tipos de datos).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
                Un mapa de bits con un bit para cada campo en la fila. El
                primer campo corresponde al bit 7 (MSB) del primer byte,
                el segundo campo corresponde al bit 6 del primer byte, el
                octavo campo corresponde al bit 0 (LSB) del primer byte,
                el noveno campo corresponde al bit 7 del segundo byte, y
                así sucesivamente. Cada bit está activo si el valor del campo
                correspondiente no es NULL. Si el número de campos no es un
                múltiplo de 8, el resto del último byte en el mapa de bits
                no es utilizado.
</Para>
<Para>
    Por lo tanto, para cada campo con un valor no NULL, tenemos lo siguiente:
<VariableList>
<VarListEntry>
<Term>
		Int32
</Term>
<ListItem>
<Para>
            Especifica el tamaño del valor del campo, incluyendo este tamaño.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
		Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
            Especifica el valor del campo mismo en caracteres <Acronym>ASCII</Acronym>.
			<Replaceable>n</Replaceable> es el anterior tamaño menos 4.
                        No hay '\0' al final del campo de datos, el frontend debe
                        añadirlo si quiere uno.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
AuthenticationOk (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('R')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una petición de autentificación.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32(0)
</Term>
<ListItem>
<Para>
        Especifica que la autentificación tuvo éxito.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
AuthenticationKerberosV4 (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('R')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una petición de autentificación.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32(1)
</Term>
<ListItem>
<Para>
        Especifica que se requiere autentificación Kerberos V4.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
AuthenticationKerberosV5 (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('R')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una petición de autentificación.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32(2)
</Term>
<ListItem>
<Para>
        Especifica que se requiere autentificación Kerberos V5.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
AuthenticationUnencryptedPassword (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('R')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una petición de autentificación.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32(3)
</Term>
<ListItem>
<Para>
        Especifica que se requiere una contraseña no encriptada.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
AuthenticationEncryptedPassword (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('R')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una petición de autentificación.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32(4)
</Term>
<ListItem>
<Para>
        Especifica que se requiere una contraseña encriptada.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Byte2
</Term>
<ListItem>
<Para>
        El salto a utilizar al encriptar la contraseña.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
BackendKeyData (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('K')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una clave de cancelación.
        El frontend debe guardar estos valore se desea poder
        enviar mensajes CancelRequest posteriormente.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        El ID de proceso del backend.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        La clave secreta de este backend.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
BinaryRow (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('B')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una fila de datos binarios.
        (Un mensaje RowDescription previo define el número de
        campos en la fial y sus tipos de datos)
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
                Un mapa de bits con un bit para cada campo en la fila. El
                primer campo corresponde al bit 7 (MSB) del primer byte,
                el segundo campo corresponde al bit 6 del primer byte, el
                octavo campo corresponde al bit 0 (LSB) del primer byte,
                el noveno campo corresponde al bit 7 del segundo byte, y
                así sucesivamente. Cada bit está activo si el valor del campo
                correspondiente no es NULL. Si el número de campos no es un
                múltiplo de 8, el resto del último byte en el mapa de bits
                no es utilizado.
</Para>
<Para>
    Para cada campo con un valor distinto de NULL, tenemos lo siguiente:
<VariableList>
<VarListEntry>
<Term>
		Int32
</Term>
<ListItem>
<Para>
            Especifica el tamaño del valor del campo, excluyendo este tamaño.

****************************************************************************
*************************** Comprobar esto, por que aquí dice _excluyendo_ y
            antes (línea 756) dice incluyendo??????????????*****************
****************************************************************************

</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
		Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
            Especifica el valor del campo mismo en formato binario.
			<Replaceable>n</Replaceable> es el tamaño previo.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
CancelRequest (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Int32(16)
</Term>
<ListItem>
<Para>
        El tamaño del paquete en bytes.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32(80877102)
</Term>
<ListItem>
<Para>
        El código de cancelación de petición. El valor es elegido
        para que contenga "1234" el los 16 bits más significativos,
        y "5678" en los 16 bits menos significativos. Para evitar
        confisión, este código no debe ser el mismo que ningún
        número de versión del protocolo.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        El ID de proceso del backend objetivo.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        La clave secreta para el backend objectivo.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
CompletedResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('C')
</Term>
<ListItem>
<Para>
        Identifica este mensaje como una petición completada.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String
</Term>
<ListItem>
<Para>
        El comando. Normalmente (pero no siempre) una palabra simple
        que identifica que comando SQL se completó.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
CopyDataRows (B y F)
</Term>
<ListItem>
<Para>
    Es un flujo de filas donde cada una está terminada por un Byte1('\n').
    Se completa con una secuencia Byte1('\\'), Byte1('.'),
	Byte1('\n').
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
CopyInResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('G')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una respuesta Start Copy In.
        El frontend debe enviar un mensaje CopyDataRows.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
CopyOutResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('H')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una respuesta Start Copy Out.
        Este mensaje será seguido por un mensaje CopyDataRows. 
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
CursorResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('P')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como un cursor.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String
</Term>
<ListItem>
<Para>
        El nombre del cursor. Será "blanco" si el cursor es implícito.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
EmptyQueryResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('I')
</Term>
<ListItem>
<Para>
        Identifica este mensaje como una respuesta a una sentencia vacía.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String("")
</Term>
<ListItem>
<Para>
        Sin utilizar.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
EncryptedPasswordPacket (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        El tamaño del paquete en bytes.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String
</Term>
<ListItem>
<Para>
        La contraseña encriptada (mediante crypt()).
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
ErrorResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('E')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como un error.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String
</Term>
<ListItem>
<Para>
        El mensaje de error mismo.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
FunctionCall (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('F')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una llamada a función.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String("")
</Term>
<ListItem>
<Para>
        Sin utilizar.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        Especifica el ID de objeto de la función a llamar.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        Especifica el número de argumentos que se suministran
        a la función.
</Para>
<Para>
    Para cada argumento, se tiene lo siguiente:
<VariableList>
<VarListEntry>
<Term>
		Int32
</Term>
<ListItem>
<Para>
            Especifica el tamaño del valor del argumento, excluyendo
            este tamaño.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
		Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
            Especifica el valor del campo mismo en formato binario.
			<Replaceable>n</Replaceable> es el tamaño anterior.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>

</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
FunctionResultResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('V')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como un resultado de llamada a función.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Byte1('G')
</Term>
<ListItem>
<Para>
        Especifica que se devolvió un resultado no vacío.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        Especifica el tamaño del valor del resultado, excluyendo este
        tamaño.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
        Especifia el valor del resultado en formato binario.
		<Replaceable>n</Replaceable> Es el tamaño anterior.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Byte1('0')
</Term>
<ListItem>
<Para>
        Sin utilizar. (Hablando propiamente, FunctionResultResponse y
        FunctionVoidResponse son lo mismo pero con algunas partes
        opcionales en el mensaje).
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
FunctionVoidResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('V')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como un resultado de llamada a función.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Byte1('0')
</Term>
<ListItem>
<Para>
        Especifica que se devolvió un resultado vacío.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
NoticeResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('N')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una advertencia.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String
</Term>
<ListItem>
<Para>
        El mensaje de advertencia mismo.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
NotificationResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('A')
</Term>
<ListItem>
<Para>
        Identifica el mansaje como una repuesta de notificación.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        El ID de proceso del proceso backend.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String
</Term>
<ListItem>
<Para>
        El nombre de la condición en la que se lanzó la notificación.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
Query (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('Q')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una petición.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String
</Term>
<ListItem>
<Para>
        La petición misma.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
ReadyForQuery (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('Z')
</Term>
<ListItem>
<Para>
        Identifica el tipo de mensaje. ReadyForQuery es enviado
        cuando el backend está listo para un nuevo ciclo de petición.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
RowDescription (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('T')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una descripción de fila.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int16
</Term>
<ListItem>
<Para>
        Especifica el número de campos en una fila (puede ser cero).
</Para>
<Para>
    Para cada campo tenemos lo siguiente:
<VariableList>
<VarListEntry>
<Term>
		String
</Term>
<ListItem>
<Para>
            Especifica el nombre del campo.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
		Int32
</Term>
<ListItem>
<Para>
            Especifica el ID de objeto del tipo de campo.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
		Int16
</Term>
<ListItem>
<Para>
            Especifica el tamaño del tipo.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
		Int32
</Term>
<ListItem>
<Para>
            Especifica el modificador del tipo.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
StartupPacket (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Int32(296)
</Term>
<ListItem>
<Para>
        El tamaño del paquete en bytes.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        El número de versión del protocolo. Los 16 bits más significativos
        son el numero de versión mayor. Los 16 bits menos significativos son
        el número de versión menor.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	LimString64
</Term>
<ListItem>
<Para>
        El nombre de la base de datos, por defecto el nombre del usuario
        si no se especifica.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	LimString32
</Term>
<ListItem>
<Para>
        El nombre del usuario.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	LimString64
</Term>
<ListItem>
<Para>
        Cualquier linea de argumentos para pasar al backend por el postmaster.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	LimString64
</Term>
<ListItem>
<Para>
        Sin utilizar.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	LimString64
</Term>
<ListItem>
<Para>
        La tty opcional que el backen debería utilizar para mensajes de depuración.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
Terminate (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Byte1('X')
</Term>
<ListItem>
<Para>
        Identifica el mensaje como una terminación.
</Para>
</ListItem>
</VarListEntry>
</VariableList>


</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
UnencryptedPasswordPacket (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
	Int32
</Term>
<ListItem>
<Para>
        El tamaño del paquete en bytes.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
	String
</Term>
<ListItem>
<Para>
        La contraseña sin encriptar.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>
</VariableList>

</sect1>
</Chapter>
