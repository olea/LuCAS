<!--
$Header: /home/cvs/lucas/doc-postgresql-es/v7/src/sgml/indexcost.sgml,v 1.2 2002/04/27 22:48:32 emaldonadog Exp $
-->

 <chapter id="indexcost">
  <title>Funciones de estimación del coste de índices</title>

  <note>
   <title>Author</title>

   <para>
    Escrito por Tom Lane (<email>tgl@sss.pgh.pa.us</email>) el 24-01-2000
   </para>
  </note>

   <note>
    <para>
		 Esto debería llegar a formar parte de un capítulo más grande sobre
		 escribir nuevos métodos de acceso a índices.
    </para>
   </note>

  <para>
	 Cada método de acceso a un índice debe presentar una función de 
	 estimación de costes para ser usada por el optimizador/planificador.
	 El OID del proceso de esta función aparece en el campo
   <literal>amcostestimate</literal> en la entrada <literal>pg_am</literal> del
	 método de acceso.
   <note>
    <para>
		 Previamente a Postgres 7.0, se usaba un sistema diferente para registrar
		 las funciones de estimación de coste de índices.
    </para>
   </note>
  </para>

  <para>
	 A la función amcostestimate se le da una lista de claúsulas WHERE que
	 se ha determinado que sean utilizables con el índice. Debe devolver
	 estimaciones del coste de acceso al índice y la selectividad de las
	 claúsulas WHERE (es decir, la fracción de tuplas de la tabla principal
	 que serán leidas durante la búsqueda con el índice). Para casos simples,
	 prácticamente todo el trabajo de estimación del coste se puede hacer
	 llamando a rutinas estándar del optimizador; el tener la función
	 amcostestimate permite a los métodos de acceso a índices aportar
	 conocimiento específico del tipo de índice, es caso de que sea posible
	 mejorar las estimaciones estándar.
  </para>

  <para>
	 Cada función amcostestimate debe tener la estructura:
   <programlisting>
void
amcostestimate (Query *root,
                RelOptInfo *rel,
                IndexOptInfo *index,
                List *indexQuals,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity);
   </programlisting>

   Los primeros cuatro parámetros son de entrada:

   <variablelist>
    <varlistentry>
     <term>root</term>
     <listitem>
      <para>
       La consulta que se va a procesar.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>rel</term>
     <listitem>
      <para>
       La relación sobre la que está el índice.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>index</term>
     <listitem>
      <para>
       El propio índice.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>indexQuals</term>
     <listitem>
      <para>
			 Lista de cláusulas cualificadoras del índice (implícitamente 
			 unidas con AND); una lista nula indica que no hay cualificadores
			 disponibles.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
	 Los últimos tres parámetros son de salida y se pasan por referencia:
   <variablelist>
    <varlistentry>
     <term>*indexStartupCost</term>
     <listitem>
      <para>
			 Apunta al coste del procesamiento de arranque del índice
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexTotalCost</term>
     <listitem>
      <para>
			 Apunta al coste total del procesamiento del índice
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexSelectivity</term>
     <listitem>
      <para>
       Apunta a la selectividad del índice
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
	 Las funciones de estimación de coste deben escribirse en C, no en SQL u
	 otros lenguajes procedurales disponibles, ya que deben acceder a 
	 estructuras internas de datos del planificador/optimizador.
  </para>

  <para>
	 Los costes de acceso a índices deben calcularse en las unidades usadas
	 por src/backend/optimizer/path/costsize.c: una lectura secuencial de un
	 bloque de disco tiene coste 1.0, una lectura no secuencial tiene coste
	 random_page_cost, y el coste de procesar una tupla del índice debería
	 tomarse usualmente como cpu_index_tuple_cost (que es un parámetro del
	 optmizador ajustable por el usuario). Además, se debería cargar un 
	 múltiplo apropiado de cpu_operator_cost para los operadores de comparación
	 invocados durante el procesamiento de índice (especialmente en la 
	 evaluación de los cualificadores de índices).
  </para>

  <para>
	 Los costes de acceso deberían incluir todos los costes de discos y CPU
	 asociados al exámen del propio índice, pero NO los costes de la lectura
	 o procesamiento de las tuplas de la tabla principal que el índice ha
	 identificado.
  </para>

  <para>
	 El "coste de arranque" es parte del coste total de análisis que se debe
	 invertir antes de comenzar a traer la primera tupla. Para la mayoría de los
	 índices se puede tomar como cero, pero un tipo de índice con un alto coste
	 de arranque debería asignarse diferente de cero.
  </para>

  <para>
	 La selectividad del índice debería ajustarse a una fracción estimada de las
	 tuplas de la tabla principal que serán recuperadas en el análisis de índice.
	 En caso de un índice impreciso, este valor será mayor que el de la fracción
	 de tuplas que realmente pasan las condiciones de cualificación dadas.
  </para>

  <procedure>
   <title>Estimación de costes</title>
   <para>
		Un estimador de costes típico debería proceder así:
   </para>

   <step>
    <para>
		 Estimar y devolver la fracción de tuplas de la tabla principal que serán
		 visitados en las condiciones de cualificación dadas. Si no hay
		 conocimiento sobre el tipo de índice específico, se usará la función
		 estándar del optimizador clauselist_selectivity():

     <programlisting>
*indexSelectivity = clauselist_selectivity(root, indexQuals,
                                           lfirsti(rel->relids));
     </programlisting>
    </para>
   </step>

   <step>
    <para>
		 Estimar el número de tuplas del índice que se visitarán durante el 
		 análisis. Para la mayoría de tipos de índices será igual a
		 indexSelectivity veces el número de tuplas en el índice, pero podría ser
		 mayor. (Observe que el tamaño del índice en páginas y tuplas está
		 disponible en la estructura IndexOptInfo.)
    </para>
   </step>

   <step>
    <para>
		 Estimar el número de páginas del índice que serán recuperadas durante el
		 análisis. Esto debería ser indexSelectivity veces el tamaño del índice en
		 páginas.
    </para>
   </step>

   <step>
    <para>
		 Calcular el coste de acceso al índice. Un estimador genérico debería
		 hacer esto:

     <programlisting>
    /*
		 * Asumimos genéricamente que las páginas del índice se leerán
		 * secuencialmente, por lo que cada una costará 1.0, no random_page_cost.
		 * También cargamos para evaluación de los cualificadores del índice
		 * de cada tupla del índice.
		 * Se asume que todos los costes se pagarán incrementalmente durante
		 * la evaluación.
     */
    *indexStartupCost = 0;
    *indexTotalCost = numIndexPages +
        (cpu_index_tuple_cost + cost_qual_eval(indexQuals)) * numIndexTuples;
     </programlisting>
    </para>
   </step>
  </procedure>

  <para>
	 Se pueden encontrar ejemplos de funciones de estimación de costes en
   <filename>src/backend/utils/adt/selfuncs.c</filename>.
  </para>

  <para>
	 Por convenio, la entrada <literal>pg_proc</literal> de una función
   <literal>amcostestimate</literal> debería mostrar
   <programlisting>
prorettype = 0
pronargs = 7
proargtypes = 0 0 0 0 0 0 0
   </programlisting>

   Se usa cero ("opaco") para todos los argumentos cuando ninguno de ellos
	 tiene un tipo conocido en pg_type.
  </para>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
