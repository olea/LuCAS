.\" This is -*-nroff-*-
.\" XXX standard disclaimer belongs here....
.\" $Header: /home/cvs/lucas/doc-postgresql-es/v7/src/sgml/catalogs.sgml,v 1.3 2002/10/14 22:21:15 emaldonadog Exp $
.TH "SYSTEM CATALOGS" INTRO 03/13/94 PostgreSQL PostgreSQL
.SH "Section 7 - System Catalogs"
.de LS
.PP
.if n .ta 5 +13 +13
.if t .ta 0.5i +1.3i +1.3i
.in 0
.nf
..
.de LE
.fi
.in
..
.SH "DESCRIPCIÓN"
En esta sección listamos cada uno de los atributos de los catálogos del sistema, y definimos sus
significados
.SH "CATÁLOGOS DEL SISTEMA DE TIPOS/CLASES"
Estos catálogos forman el núcleo de la extensibilidad del sistema:
.LS
	\fBname\fP	\fBcompartido/local\fP	\fBdescripción\fP
	pg_aggregate	local	                funciones agragadas
	pg_am		local			métodos de acceso
	pg_amop		local			operadores utilizables con métodos de acceso específicos
	pg_amproc	local			procedimientos usados con métodos de acceso específicos
	pg_attribute	local			atributos de las clases
	pg_class	local			clases
	pg_index	local			índices
	pg_inherits	local			jerarquía de herencia de las clases
	pg_language	local			lenguajes de implementación de procedimientos
	pg_opclass	local			clases de operadores
	pg_operator	local			operadores del lenguaje de consultas
	pg_proc		local			procedimientos (funciones)
	pg_type		local			tipos de datos
.LE
.SH "ENTIDADES"
Estos catálogos tratan de la identificación de las entidades conocidas a través del sitio:
.LS
	\fBnombre\fP	\fBcompartido/local\fP	\fBdescripción\fP
	pg_database	compartido		bases de datos actuales
	pg_group	compartido		grupos de usuarios
	pg_shadow	compartido		usuarios válidos
.LE
.SH "CATÁLOGOS DEL SISTEMA DE REGLAS"
.LS
	\fBnombre\fP	\fBcompartido/local\fP	\fBdescripción\fP
	pg_listener	local			procesos esperando sus desencadenantes
	pg_prs2plans	local			instancias de procedimientos de sistema
	pg_prs2rule	local			instancias de reglas de sistema
	pg_prs2stub	local			``stubs'' del sistema de instancias
	pg_rewrite	local			información de reescritura del sistema
.LE
.SH "CATÁLOGOS DE OBJETOS GRANDES"
.PP
Estos catálogos son específicos del sistema de archivos de Inversión y de objetos grandes en general
.LS
	\fBnombre\fP	\fBcompartido/local\fP	\fBdescripción\fP
	pg_lobj		local			descripción de un objeto grande
	pg_naming	local			mapeado del espacio de nombres de Inversión
	pg_platter	local			// OJO jukebox platter inventory
	pg_plmap	local			// OJO jukebox platter extent map
.LE
.SH "CATÁLOGOS INTERNOS"
.PP
Estos catálogos son para las clases internas que no se almacenan en los 'heap' normales, y a los
que no puede acceserse por medios normales (el intento de hacerlo provoca un error).
.LS
	\fBnombre\fP	\fBcompartido/local\fP	\fBdescripción\fP
	pg_log		compartido		registro de transacciones commit/rollback
	pg_magic	compartido		constantes mágicas
	pg_time		compartido		tiempos de commit/rollback
	pg_variable	compartido		valores de variables especiales
.LE
.PP
Existen otras clases definidas con nombre \*(lqpg_\*(rq.
Junto a los que terminan en \*(lqind\*(rq (indices secundarios), son todos obsoletos o
desanconsejados por otros motivos.
.SH "CATÁLOGOS DE CLASES/TIPOS DEL SISTEMA"
.PP
Los siguientes catálogos se refieren a las clases y tipos del sistema.
.nf M
/*
 * agregados
 *
 * ver DEFINE AGGREGATE para una explicación de las funciones de trancisión
 */
pg_aggregate
    NameData      aggname	/* nombre de agregado (p.ej. "count") */
    oid         aggowner	/* identificación del creador */
    regproc     aggtransfn1	/* primera función de trancisión */
    regproc     aggtransfn2	/* segunda función de trancisión */
    regproc     aggfinalfn	/* función final */
    oid         aggbasetype	/* tipo de dato sobre el que opera el agregado */
    oid         aggtranstype1	/* tipo devuelto por aggtransfn1 */
    oid         aggtranstype2	/* tipo devuelto por aggtransfn2 */
    oid         aggfinaltype	/* tipo devuelto por aggfinalfn */
    text        agginitval1	/* formato externo del valor inicial (de comienzo) de aggtransfn1 */
    text        agginitval2	/* formato externo del valor inicial (de comienzo) de aggtransfn2 */
.fi
.nf M
pg_am
    NameData    amname          /* nombre del método de acceso */
    oid         amowner         /* identificador del creador */
    int2        amstrategies    /* NUMERO total de estrategias por las cuales puede recorrerse/
                                   buscar este AM */
    int2        amsupport       /* NUMERO total de funciones de apoyo que usa este AM */
    int2        amorderstrategy /* si este AM tiene un modo e ordenación, el numero de estrategia
                                 * del operador de ordenación. Cero si AM no está ordenado */
    regproc     amgettuple      /* función "siguiente tupla válida" */
    regproc     aminsert        /* función "insertar esta tupla" */
    regproc     amdelete        /* función "eliminar esta tupla" */
    regproc     amgetattr       /* - desaconsejado */
    regproc     amsetlock       /* - desaconsejado */
    regproc     amsettid        /* - desaconsejado */
    regproc     amfreetuple     /* - desaconsejado */
    regproc     ambeginscan     /* función "comenzar nueva exploración" */
    regproc     amrescan        /* función "reiniciar esta exploración" */
    regproc     amendscan       /* función "terminar esta exploración" */
    regproc     ammarkpos       /* función "marcar posición de la exploración actual" */
    regproc     amrestrpos      /* función "restablecer la posición de exploración marcadan" */
    regproc     amopen          /* - desaconsejado */
    regproc     amclose         /* - desaconsejado */
    regproc     ambuild         /* función "construir nuevo indice" */
    regproc     amcreate        /* - desaconsejado */
    regproc     amdestroy       /* - desaconsejado */
    regproc     amcostestimate  /* coste estimado de una exploración de índice */

.fi
.nf M
pg_amop
    oid         amopid		/* método de acceso con el que puede usarse este operador */
    oid         amopclaid	/* clase de operador con la que puede usarse este operador */
    oid         amopopr		/* el operador */
    int2        amopstrategy	/* numero de estrategia tranversal/de busqueda al que se aplica
				   este operador */
.fi
.nf M
pg_amproc
    oid         amid		/* metodo de acceso con el que se asocia este procedimiento */
    oid         amopclaid	/* clase de operador con la que puede usarse este operador */
    oid         amproc		/* el  procedimiento */
    int2        amprocnum	/* numero de funciones de apoyo al que se aplica este operador */
.fi
.nf M
pg_class
     NameData     relname	/* nombre de clase */
     oid        relowner	/* ientificador del propietario */
     oid        relam		/* método de acceso */
     int4       relpages	/* numero de páginas de 8KB */
     int4       reltuples	/* numero de instancias */
     abstime    relexpires	/* tiempo tras el cual las intancias se eliminan del almacenamiento
                                   no definitivo. */
     reltime    relpreserved	/* inervalo de tiempo tras el cual las instancias son eliminadas
                                   del almacenamiento no definitivo */
     bool       relhasindex	/* ¿tiene la clase un indice secundario? */
     bool       relisshared	/* ¿la clase es local o compartida? */
     char       relkind		/* tipo de relación:
				   i=indice
				   r=relacion (montón)
				   s=especial
				   u=no catalogado (temporaral) */
     char       relarch		/* modo de archivo:
				   h=pesado
				   l=ligero
			   	   n=ninguno */
     int2       relnatts	/* numero actual de atributos no pertenecientes al sistema */
     int2       relsmgr		/* metodo de almacenamiento:
			   	  0=disco magnático
			   	  1=sony WORM jukebox
			          2=memoria princiapal */
     int2vector relkey		/* - no usado */
     oidvector  relkeyop	/* - no usado */
     aclitem    relacl[1]	/* lista de control de acceso */
.fi
.nf M
pg_attribute
    oid         attrelid	/* clase que contiene este atributo */
    NameData      attname	/* nombre del atributo */
    oid         atttypid	/* tipo del atributo */
    oid         attdefrel	/* - desaconsejado */
    int4        attnvals	/* - desaconsejado */
    oid         atttyparg	/* - desaconsejado */
    int2        attlen		/* longitud del atributo, en bytes-1=variable */
    int2        attnum		/* numero del atributo
			   		>0=atributo de usuario
			   		<0=atributo de sistema */
    int2        attbound	/* - desaconsejado */
    bool        attbyval	/* ¿tipo pasado por valor? */
    bool        attcanindex	/* - desaconsejado */
    oid         attproc		/* - desaconsejado */
    int4        attnelems	/* numero de dimensiones de la matriz */
    int4        attcacheoff	/* caché de desplazamiento en la tupla */
    bool        attisset	/* ¿tiene el atributo un valor asignado? */
.fi
.nf M
pg_inherits
    oid         inhrel		/* clase hija */
    oid         inhparent	/* clase padre */
    int4        inhseqno	/* - desaconsejado */
.fi
.nf M
    oid         indexrelid	/* oid de la clase índice secundario */
    oid         indrelid	/* oid de la clase pila indexada */
    oid         indproc		/* función para calcular la clave índice a partir
    				   de los atributos en el heap
				   0=no es un índice funcional */
    int2vector  indkey		/* números de atributo de los atributos clave */
    oidvector   indclass	/* opclass cd cada clave */
    bool        indisclustered	/* ¿está el índice "clusterizado"? - no se usa */
    bool        indisarchived	/* ¿está el índice archivado?  - no se usa */
    text        indpred	/* plan de la query para predicados de índices parciales */
.fi
.nf M
pg_type
    NameData      typname	/* nombre del tipo */
    oid         typowner	/* usesysid del propietario */
    int2        typlen		/* longitud en formato interno -1=longitud variable */
    int2        typprtlen	/* longitud en formato externo */
    bool        typbyval	/* ¿es un tipo pasado por value? */
    char        typtype		/* grupo del tipo:
			   		c=catálogo (compuesto)
			   		b=base */
    bool        typisdefined	/* ¿definido o corresponde a la shell? */
    char        typdelim	/* delimitador para formatos de vectores externos */
    oid         typrelid	/* clase (si es compuesto) */
    oid         typelem		/* tipo de cada elemento del vector */
    regproc     typinput	/* función de conversión externa-interna */
    regproc     typoutput	/* función de conversión interna-externa */
    regproc     typreceive	/* función de conversión cliente-servidor */
    regproc     typsend		/* función de conversión servidor-cliente */
    text        typdefault	/* valor de defecto */
.fi
.nf M
pg_operator
    NameData      oprname	/* nombre del operador */
    oid         oprowner	/* usesysid del propietario */
    int2        oprprec		/* - despreciado */
    char        oprkind		/* grupo del operador:
			   		b=binario
			   		l=unario por la izquierda
			   		r=unario por la derecha */
    bool        oprisleft	/* ¿es el operador asociativo izquierda/derecha? */
    bool        oprcanhash	/* ¿se puede utilizar para hashjoin? */
    oid         oprleft		/* tipo del operando de la izquierda */
    oid         oprright	/* tipo del operando de la derecha */
    oid         oprresult	/* tipo del resultado */
    oid         oprcom		/* operador commutador */
    oid         oprnegate	/* operador negador */
    oid         oprlsortop	/* orden del operador para el operando de la izquierda */
    oid         oprrsortop	/* orden del operador para el operando de la derecha */
    regproc     oprcode		/* función que implementea este operador */
    regproc     oprrest		/* función para calcular la selectividad de restricción del operador */
    regproc     oprjoin		/* función para calcular la selectividad de unión del operador */
.fi
.nf M
pg_opclass
    NameData      opcname	/* nombre de la clase de operador */
.fi
.nf M
pg_proc
    NameData    proname		/* nombre de la función */
    oid         proowner	/* usesysid del propietario */
    oid         prolang		/* lenguaje de implementación de la función */
    bool        proisinh	/* - despreciado */
    bool        proistrusted	/* ¿corre en el servidor o procesa funciones no seguras? */
    bool        proiscachable	/* ¿se pueden almacenar en memoria los valores devueltos por la función? */
    int2        pronargs	/* número de argumentos */
    bool        proretset	/* ¿devuelve un conjunto la función? - no se usa */
    oid         prorettype	/* tipo devuelto */
    oidvector   proargtypes	/* tipos de los argumentos */
    int4        probyte_pct	/* % del tamaño de los argumentos (in bytes) que se necesitan examinar para
    				   calcular la función */
    int4        properbyte_cpu	/* sensibilidad de tiempo de ejecución de la función al tamaño de sus inputs */
    int4        propercall_cpu	/* sobrecarga de la invocación de la función (sin mirar el tamaño de las
    				   entradas) */
    int4        prooutin_ratio	/* tamaño de las salidas de la función, como un porcentaje del tamaño
    				   de las entradas */
    text        prosrc		/* definicón de la función:
			   INTERNAL: nombre C actual de la función
			   C: actualmente este campo no se usa
			   SQL: texto de la query(ies)
			   PL: texto en lenguaje procedural */
    bytea       probin		/* ruta al fichero objeto (sólo para funciones C) */
.fi
.nf M
pg_language
    NameData      lanname	/* nombre del lenguaje */
    text        lancompiler	/* - despreciado */
.fi
.SH "ENTITIES"
.nf M
pg_database
    NameData      datname	/* nombre de la base de datos */
    oid         datdba		/* usesysid del administrador de la base de datos */
    text        datpath		/* directorio de la base de datos bajo $PGDATA */
.fi
.nf M
pg_group
    NameData      groname	/* nombre del grupo */
    int2        grosysid	/* identificador del grupo UNIX */
    int2        grolist[1]	/* lista de usesysid,s de los miembros del grupo */
.fi
.nf M
pg_shadow
    NameData      usename	/* nombre del usuario */
    int2        usesysid	/* identificador UNIX del usuario */
    bool        usecreatedb	/* ¿Puede el usuario crear bases de datos? */
    bool        usetrace	/* ¿Puede activar trazas? */
    bool        usesuper	/* ¿puede ser superusuario de POSTGRES? */
    bool        usecatupd	/* ¿Puede actualizar catálogos? */
.fi
.SH "RULE SYSTEM CATALOGS"
.nf M
pg_listener
    NameData      relname	/* clases para las que se desea notificación
                       asíncrona */
    int4        listenerpid	/* identificador del proceso de servidor que corresponde
                           al programa frontal que está esperando notificación 
                           asíncrona */
    int4        notification	/* Si hay pendiente una notificación de acontecimiento
                           para este proceso */

.fi
.nf M
pg_prs2rule
    NameData      prs2name	/* nombre de la regla */
    char        prs2eventtype	/* tipo del acontecimiento de la regla:
				   R=recuperación (retrieve)
				   U=actualización (update)
				   A=adición (append)
				   D=borrado (delete) */
    oid         prs2eventrel	/* clase a la cual se aplica el acontecimiento */
    int2        prs2eventattr	/* atributo al cual se aplica el evento */
    float8      necessary	/* - despreciado */
    float8      sufficient	/* - despreciado */
    text        prs2text	/* texto de la definición original de la regla */
.fi
.nf M
pg_prs2plans
    oid         prs2ruleid	/* instancia de prs2rule para la que se utiliza este plan */
    int2        prs2planno	/* número del plan (una regla puede invocar múltiples planes) */
    text        prs2code	/* representación externa del plan */
.fi
.nf M
pg_prs2stub
    oid         prs2relid	/* clase a la cual se aplica esta regla */
    bool        prs2islast	/* ¿es este el último fragmento del despiece? 
                                (del análisis de la regla) */
    int4        prs2no		/* número del fragmento del despiece */
    stub        prs2stub	/* fragmento del despiece */
.fi
.nf M
pg_rewrite
    NameData      rulename	/* nombre de la regla */
    char        ev_type	/* tipo del acontecimiento:
			   RETRIEVE, REPLACE, APPEND, DELETE
			   los códigos dependen del analizador sintáctico (!?) */
    oid         ev_class	/* clase a la que se aplica esta regla */
    int2        ev_attr	/* atributo al que se aplica esta regla */
    bool        is_instead	/* ¿es una regla de sustitución? */
    text        ev_qual	/* cualificación con la cual modificar (reescribir) el plan
                       que ha disparado esta regla */
    text        action	/* arbol de traducción de la acción */
.fi
.SH "CATÁLOGOS DE OBJETOS GRANDES"
.nf M
pg_lobj
    oid         ourid		/* 'ourid' en pg_naming que identifica 
                           este objeto en el espacio de nombres del 
                           sistema de ficheros de Inversión */
    int4        objtype		/* Código de tipo de almacenamiento:
				   0=Inversion
				   1=Unix
				   2=Externo
				   3=Jaquith */
    bytea       object_descripto/* estructura de manipulación del objeto opaco */
.fi
.nf M
pg_naming
    NameData      filename	/* nombre del fichero del componente */
    oid         ourid		/* oid aleatorio utilizado para identificar esta
                           instancia en otras instancias (no se puede utilizar el oid
                           activo por oscuras razones) */
    oid         parentid	/* instancia de pg_naming del directorio padre en el 
                           sistema de ficheros de Inversión */
.fi
.nf M
pg_platter
     NameData     plname		/* nombre de platter */
     int4       plstart		/* extención más alta OCUPADA */
.fi
.nf M
pg_plmap
     oid        plid		/* platter (en pg_platter) en el que reside esta extensión
                           (de bloques) */
     oid        pldbid		/* base de datos de la clase de la que depende esta extensión
                           (de bloques) */
     oid        plrelid		/* clase de la que depende esta extensión (de bloques) */
     int4       plblkno		/* número del bloque que empieza en la clase */
     int4       ploffset	/* dirección del platter en el que empieza esta extensión */
     int4       plextentsz	/* longitud de esta extensión */
.fi
