 <chapter id="query">
  <title>El Lenguaje de consultas</title>

  <para>
   El lenguaje de consultas de Postgres   <productname>Postgres</productname> es una
	 variante del estándar <acronym>SQL3</acronym> Tiene muchas extensiones, tales 
	como tipos de sistema extensibles, herencia, reglas de producción y funciones. 
	Estas son características tomadas del lenguaje de consultas original de 
	<productname>Postgres</productname> (<productname>PostQuel</productname>). Ésta
	 sección proporciona un primer vistazo de cómo usar <productname>Postgres</productname>
   <acronym>SQL</acronym>  para realizar operaciones sencillas. La intención de este 
	manual es simplemente la de proporcionarle una idea de nuestra versión de  
	<acronym>SQL</acronym> y no es de ningún modo un completo tutorial acerca de 
   <acronym>SQL</acronym>.  Se han escrito numerosos libros sobre 
   <acronym>SQL</acronym>, incluyendo 
<!--
<XRef LinkEnd="MELT93"> and <XRef LinkEnd="DATE97">.
-->
[MELT93] and [DATE97].
   Tenga en cuenta que algunas características del lenguaje son extensiones del estándar 
	 <acronym>ANSI</acronym>.
  </para>

  <sect1>
   <title>Monitor interactivo</title>

   <para>
    En los ejemplos que siguen, asumimos que ha creado la base de datos
	 mydb como se describe en la subsección anterior y que ha arrancado 
	<application>psql</application>.
    Los ejemplos que aparecen en este manual también se pueden encontrar en 
    <filename>/usr/local/pgsql/src/tutorial/</filename>.  Consulte el fichero 
    <filename>README</filename> en ese directorio para saber cómo usarlos. 
	Para empezar con el tutorial haga lo siguiente: 


    <programlisting>
% cd /usr/local/pgsql/src/tutorial
% psql -s mydb
Welcome to the POSTGRESQL interactive sql monitor:
  Please read the file COPYRIGHT for copyright terms of POSTGRESQL

   type \? for help on slash commands
   type \q to quit
   type \g or terminate with semicolon to execute query
 You are currently connected to the database: postgres

mydb=> \i basics.sql
    </programlisting>
   </para>

   <para>
    El comando  <literal>\i</literal>  lee en las consultas desde los 
	ficheros especificados . La opción <literal>-s</literal> le pone en modo single
	 step, que hace una pausa antes de enviar la consulta al servidor. Las consultas 
	de esta sección están en el fichero <filename>basics.sql</filename>.
   </para>

   <para>
    <application>psql</application>
    tiene varios comandos  <literal>\d</literal> para mostrar información de sistema. 
	Consulte éstos comandos para ver más detalles y teclee <literal>\?</literal> desde el prompt 
	 <application>psql</application> para ver un listado de comandos disponibles. 

   </para>
  </sect1>

  <sect1>
   <title>Conceptos</title>

   <para>
    La noción fundamental en  <productname>Postgres</productname> es la de clase, 
	que es una colección de instancias de un objeto. Cada instancia tiene la misma
	 colección de atributos y cada atributo es de un tipo específico. Más aún, cada
	 instancia tiene un  <firstterm>identificador de objeto </firstterm>
    (<acronym>OID</acronym>)
    permanente, que es único a lo largo de toda la instalación. Ya que la sintaxis 
    <acronym>SQL</acronym> hace referencia a tablas, usaremos los términos 
    <firstterm>tabla</firstterm> y <firstterm>clase</firstterm> indistintamente.
    Asimismo ,una <firstterm>fila</firstterm><acronym>SQL</acronym> es una
    <firstterm>instancia</firstterm> y las <firstterm>columnas</firstterm> <acronym>SQL</acronym>
    son <firstterm>atributos</firstterm>.
    Como ya se dijo anteriormente, las clases se agrupan en bases de datos y una colección de 
	bases de datos gestionada por un único proceso <application>postmaster</application> 
	constituye una instalación o sitio. 
   </para>
  </sect1>

  <sect1>
   <title>Creación de una nueva clase</title>

   <para>
    Puede crear una nueva clase especificando el nombre de la clase
	 , además de todos los nombres de atributo y sus tipos: 

    <programlisting>
CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -- temperatura mínima
    temp_hi         int,           -- temperatura máxima
    prcp            real,          -- precipitación
    date            date
);
    </programlisting>
   </para>

   <para>
    Tenga en cuenta que las palabras clave y los identificadores son sensibles a las 
	mayúsculas y minúsculas. Los identificadores pueden llegar a ser sensibles a 
	mayúsculas o minúsculas si se les pone entre dobles comillas, tal como lo permite 
	<acronym>SQL92</acronym>.
    <productname>Postgres</productname>  <acronym>SQL</acronym> soporta los tipos habituales de 
    <acronym>SQL</acronym> como: <type>int</type>,
    <type>float</type>,  <type>real</type>,  <type>smallint</type>,
<type>char(N)</type>,  
    <type>varchar(N)</type>,  <type>date</type>, <type>time</type>,
    y <type>timestamp</type>, así como otros de tipo general y otros con un rico conjunto de 
	tipos geométricos. Tal como veremos más tarde, <productname>Postgres</productname> puede ser 
	configurado con un número arbitrario de tipos de datos definidos por el usuario. Consecuentemente,
	 los nombres de tipo no son sintácticamente palabras clave, excepto donde se requiera para soportar
	 casos especiales en el estándar <acronym>SQL92</acronym> .
    Yendo más lejos, el comando <productname>Postgres</productname> <command>CREATE</command>es idéntico 
	al comando usado para crear una tabla en el sistema relacional de siempre . Sin embargo, veremos que 
	las clases tienen propiedades que son extensiones del modelo relacional. 
   </para>
  </sect1>

  <sect1>
   <title>Llenando una clase con instancias</title>

   <para>
    La declaración  <command>insert</command> se usa para llenar una clase 
	con instancias: 

    <programlisting>
INSERT INTO weather
    VALUES ('San Francisco', 46, 50, 0.25, '11/27/1994');
    </programlisting>
   </para>

   <para>
    También puede usar el comando  <command>copy</command> para cargar grandes 
	cantidades de datos desde ficheros (<acronym>ASCII</acronym>) . Generalmente 
	esto suele ser más rápido porque los datos son leídos (o escritos) como una 
	única transacción directamente a o desde la tabla destino. Un ejemplo sería: 

    <programlisting>
COPY weather FROM '/home/user/weather.txt'
    USING DELIMITERS '|';
    </programlisting>

    donde el path del fichero origen debe ser accesible al servidor backend , 
	no al cliente, ya que el servidor lee el fichero directamente
   </para>
  </sect1>

  <sect1>
   <title>Consutar a una clase</title>

   <para>
    La clase weather puede ser consultada con una selección 
	relacional normal y consultas de proyección. La declaración 
	<acronym>SQL</acronym>
    <command>select</command>se usa para hacer esto. La declaración se divide
	 en una lista destino (la parte que lista los atributos que han de ser 
	devueltos) y una cualificación (la parte que especifica cualquier restricción).
	 Por ejemplo, para recuperar todas las filas de weather, escriba: 

    <programlisting>
SELECT * FROM weather;
    </programlisting>

    and the output should be:
    <programlisting>
+--------------+---------+---------+------+------------+
|city          | temp_lo | temp_hi | prcp | date       |
+--------------+---------+---------+------+------------+
|San Francisco | 46      | 50      | 0.25 | 11-27-1994 |
+--------------+---------+---------+------+------------+
|San Francisco | 43      | 57      | 0    | 11-29-1994 |
+--------------+---------+---------+------+------------+
|Hayward       | 37      | 54      |      | 11-29-1994 |
+--------------+---------+---------+------+------------+
    </programlisting>
    Puede especificar cualquier expresión en la lista de destino. Por ejemplo, puede hacer: 
    <programlisting>
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
    </programlisting>
   </para>

   <para>
    Los operadores booleanos 
    (<command>and</command>,  <command>or</command> and <command>not</command>) ) se pueden 
	usar en la cualificación de cualquier consulta. Por ejemplo, 

    <programlisting>
SELECT * FROM weather
    WHERE city = 'San Francisco'
    AND prcp > 0.0;
    </programlisting>
da como resultado: 
    <programlisting>
+--------------+---------+---------+------+------------+
|city          | temp_lo | temp_hi | prcp | date       |
+--------------+---------+---------+------+------------+
|San Francisco | 46      | 50      | 0.25 | 11-27-1994 |
+--------------+---------+---------+------+------------+
    </programlisting>
   </para>

   <para>
    Como apunte final, puede especificar que los resultados de un select 
	puedan ser devueltos de  <firstterm>manera ordenada </firstterm>
    o quitando las <firstterm>instancias duplicadas</firstterm>.

    <programlisting>
SELECT DISTINCT city
    FROM weather
    ORDER BY city;
    </programlisting>
   </para>
  </sect1>

  <sect1>
   <title>Redireccionamiento de consultas SELECT</title>

   <para>
    Cualquier consulta select puede ser redireccionada a una nueva clase: 
    <programlisting>
SELECT * INTO TABLE temp FROM weather;
    </programlisting>
   </para>

   <para>
    Esto forma de manera implícita un comando <command>create</command>,
	 creándose una nueva clase temp con el atributo names y types 
	especificados en la lista destino del comando <command>select into</command>.
	 Entonces podremos , por supuesto, realizar cualquier operación sobre la clase
	 resultante como lo haríamos sobre cualquier otra clase. 
   </para>
  </sect1>

  <sect1>
   <title>Joins (uniones) entre clases</title>

   <para>
    Hasta ahora, nuestras consultas sólo accedían a una clase a la vez. 
	Las consultas pueden acceder a múltiples clases a la vez, o acceder 
	a la misma clase de tal modo que múltiples instancias de la clase sean
	 procesadas al mismo tiempo . Una consulta que acceda a múltiples 
	instancias de las mismas o diferentes clases a la vez se conoce como una
	 consulta join. Como ejemplo, digamos que queremos encontrar todos los 
	registros que están en el rango de temperaturas de otros registros. En 
	efecto, necesitamos comparar los atributos temp_lo y temp_hi de cada 
	instancia EMP con los atributos temp_lo y temp_hi de todas las demás 
	instancias EMP. 
    <note>
     <para>
      Esto es sólo un modelo conceptual. El verdadero join puede hacerse de 
		una manera más eficaz, pero esto es invisible para el usuario.
     </para>
    </note>

    Podemos hacer esto con la siguiente consulta: 

    <programlisting>
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
    W2.city, W2.temp_lo AS low, W2.temp_hi AS high
    FROM weather W1, weather W2
    WHERE W1.temp_lo < W2.temp_lo
    AND W1.temp_hi > W2.temp_hi;

+--------------+-----+------+---------------+-----+------+
|city          | low | high | city          | low | high |
+--------------+-----+------+---------------+-----+------+
|San Francisco | 43  | 57   | San Francisco | 46  | 50   |
+--------------+-----+------+---------------+-----+------+
|San Francisco | 37  | 54   | San Francisco | 46  | 50   |
+--------------+-----+------+---------------+-----+------+
    </programlisting>     

    <note>
     <para>
      : Los matices de este join están en que la cualificación es una 
		expresión verdadera definida por el producto cartesiano de las 
		clases indicadas en la consulta. Para estas instancias en el 
		producto cartesiano cuya cualificación sea verdadera, 
      <productname>Postgres</productname> calcula y devuelve los valores
		 especificados en la lista de destino.   
      <productname>Postgres</productname> <acronym>SQL</acronym>
      no da ningún significado a los valores duplicados en este tipo de 
		expresiones. Esto significa que <productname>Postgres</productname> 
		en ocasiones recalcula la misma lista de destino varias veces. Esto 
		ocurre frecuentemente cuando las expresiones booleanas se conectan 
		con un "or". Para eliminar estos duplicados, debe usar la declaración 
		<command>select distinct</command> .
     </para>
    </note>
   </para>

   <para>
    En este caso, tanto W1 como W2 son sustituidos por una instancia de la clase
	 weather y se extienden por todas las instancias de la clase. (En la 
	terminología de la mayoría de los sistemas de bases de datos W1 y W2 se conocen 
	como <firstterm>range variables (variables de rango)</firstterm>.)  
    Una consulta puede contener un número arbitrario de nombres de clases y 
	sustituciones. 
   </para>
  </sect1>

  <sect1>
   <title>Actualizaciones</title>

   <para>
    Puede actualizar instancias existentes usando el comando update. 
	Suponga que descubre que la lectura de las temperaturas el 28 de 
	Noviembre fue 2 grados superior a la temperatura real. Puede 
	actualizar los datos de esta manera: 

    <programlisting>
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date > '11/28/1994';
    </programlisting>
   </para>
  </sect1>

  <sect1>
   <title>Borrados</title>

   <para>
    Los borrados se hacen usando el comando  <command>delete</command>:
    <programlisting>
DELETE FROM weather WHERE city = 'Hayward';
    </programlisting>

    Todos los registros de weather pertenecientes a Hayward son borrados. 
	Debería ser precavido con las consultas de la forma 
    <programlisting>
DELETE FROM classname;
    </programlisting>

    Sin una cualificación, <command>delete</command> simplemente borrará 
	todas las instancias de la clase dada, dejándola vacía. El sistema 
	no pedirá confirmación antes de hacer esto. 
   </para>
  </sect1>

  <sect1>
   <title>Uso de funciones de conjunto</title>

   <para>
    Como otros lenguajes de consulta, 
    <productname>PostgreSQL</productname> soporta funciones de conjunto. Una 
	función de conjunto calcula un único resultado a partir de múltiples filas 
	de entrada. Por ejemplo, existen funciones globales para calcular 
    <function>count</function>(contar) ,<function>sum</function> (sumar),
    <function>avg</function> (media), <function>max</function> (máximo) and
    <function>min</function> (mínimo) sobre un conjunto de instancias. 
   </para>

   <para>
    Es importante comprender la relación entre las funciones de conjunto y las cláusulas 
    SQL <command>where</command> y <command>having</command> .
    . La diferencia fundamental entre  <command>where</command> y
    <command>having</command> es que: <command>where</command> selecciona las columnas de
	 entrada antes de los grupos y entonces se computan las funciones de conjunto (de este 
	modo controla qué filas van a la función de conjunto), mientras que
    <command>having</command> selecciona grupos de filas después de los grupos y entonces 
	se computan las funciones de conjunto. De este modo la cláusula 
    <command>where</command> puede no contener funciones de conjunto puesto que no tiene 
	sentido intentar usar una función de conjunto para determinar qué fila será la entrada 
	de la función. Por otra parte, las cláusulas 
    <command>having</command> siempre contienen funciones de conjunto. (Estrictamente 
	hablando, usted puede escribir una cláusula <command>having</command>que no use 
	funciones de grupo, pero no merece la pena. La misma condición podría ser usada de un 
	modo más eficaz con<command>where</command> .)
   </para>

   <para>
    Como ejemplo podemos buscar la mínima temperatura en cualquier parte con 

    <programlisting>
SELECT max(temp_lo) FROM weather;
    </programlisting>

    Si queremos saber qué ciudad o ciudades donde se dieron estas temperaturas, podemos 
	probar 

    <programlisting>
SELECT city FROM weather WHERE temp_lo = max(temp_lo);
    </programlisting>

    pero no funcionará debido a que la función max() no puede ser usada en 
    <command>where</command>. Sin embargo, podemos replantar la consulta 
	para llevar a cabo lo que buscamos. En este caso usando una 
    <firstterm>subseleccion</firstterm>:
    <programlisting>
SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
    </programlisting>
    Lo que ya es correcto, ya que la subselección es una operación independiente 
	que calcula su propia función de grupo sin importar lo que pase en el select exterior. 
   </para>

   <para>
    Las funciones de grupo son también muy útiles combinándolas con cláusulas 
    <firstterm>group by</firstterm> . Por ejemplo, podemos obtener la temperatura 
	mínima tomada en cada ciudad con :
    <programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city;
    </programlisting>
    que nos devuelve una fila por ciudad. Podemos filtrar estas filas agrupadas 
	usando  <command>having</command>:
    <programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING min(temp_lo) < 0;
    </programlisting>
    que nos da los mismos resultados, pero de ciudades con temperaturas bajo cero. 
	Finalmente, si sólo nos interesan las ciudades cuyos nombres empiecen por 'P', 
	deberíamos hacer : 
    <programlisting>
SELECT city, max(temp_lo)
    FROM weather
    WHERE city like 'P%'
    GROUP BY city
    HAVING min(temp_lo) < 0;
    </programlisting>
    Tenga en cuenta que podemos aplicar la restricción del nombre de ciudad en 
    <command>where</command>, ya que no necesita funciones de conjunto. Esto es 
	más eficaz que añadir la restricción a <command>having</command>,debido a que 
	evitamos hacer los cálculos de grupo para todas las filas que no pasan el 
	filtro de <command>where</command> .
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/CATALOG"
sgml-local-ecat-files:nil
End:
-->
