 <chapter id="libpqplusplus">
  <title>libpq C++ Binding</title>
  
  <para>
   <filename>libpq++</filename> es la API C++ API para 
   <productname>Postgres</productname>.
   <filename>libpq++</filename>  es un conjunto de clases que permiten a los
   programas cliente conectarse al servidor de 
   <productname>Postgres</productname>. Estas conexiones vienen de dos formas:
   una Clase de Base de Datos, y una clase de Objetos Grandes.
  </para>

  <para>
   La Clase de Base de datos está pensada para manipular una base de datos. Puede
   usted enviar toda suerte de consultas SQL al servidor <productname>Postgres</productname>,
   y recibir las repuestas del servidor.
  </para>

  <para>
   La Clase de Objetos Grandes está pensada para manipular los objetos grandes en la 
   base de datos. Aunque una instancia de Objetos Grandes puede enviar consultas 
   normales al servidor de <productname>Postgres</productname>, sólo está pensado 
   para consultas sencillas que no devuelven ningún dato. Un objeto grande se debería ver
   como una cadena de un fichero. En el futuro, debería comportarse de forma muy próxima
   a las cadenas de fichero de C++
   <literal>cin</literal>,
   <literal>cout</literal>
   y
   <literal>cerr</literal>.
  </para>

  <para>
   Este capítulo está basado en la documentación para la librería C <filename>libpq</filename>.
   Al final de esta sección se listan tres programas cortos como ejemplo de programación
   con <filename>libpq++</filename> (aunque no necesariamente de una buena programación).
   Hay muchos tipos de aplicaciones <filename>libpq++</filename> en 
   <filename>src/libpq++/examples</filename>, incluyendo el código fuente de los
   tres ejemplos expuestos en este capítulo.
  </para>

  <sect1>
   <title>Control e Inicialización</title>
    
   <sect2>
    <title>Variables de Entorno.</title>
    <para>
     Las siguientes variables de entorno se pueden utilizar para fijar variables de 
     defecto para un entorno, y para evitar codificar nombres de la base de datos 
     en un programa de aplicación:
     <note>
      <para>
       Diríjase a <xref endterm="libpq" linkend="libpq-envars"> para conseguir una lista
       completa de opciones de conexión.
      </para>
     </note>
    </para>

    <para>
     Las siguientes variables de entorno se pueden utilizar para seleccionar
     valores de parámetros de conexión de defecto, que serán utilizados por
     PQconnectdb o PQsetdbLogin si no se ha especificado directamente ningún 
     otro valor por parte del código que realiza la llamada. Son utilizables para
     impedir la codificación de nombres de base de datos en programas de aplicación
     sencillos.
     <note>
      <para>
       <filename>libpq++</filename> utiliza sólo variables de entorno o cadenas del tipo
       conninfo de PQconnectdb.
      </para>
     </note>
	  
     <itemizedlist>
      <listitem>
       <para>
	<envar>PGHOST</envar> fija el nombre del ordenador servidor de defecto.
      Si se especifica una cadena de longitud distinta de 0, se utiliza comunicación
      TCP/IP. Sin un nombre de host, libpq conectará utilizando una conexión (un socket)
      del dominio Unix local.
       </para>
      </listitem>
      <listitem>
       <para>
	<envar>PGPORT</envar>  fija el puerto de defecto o la extensión del fichero de 
      conexión del dominio Unix local para la comunicación con el servidor 
      <productname>Postgres</productname>.
       </para>
      </listitem>
      <listitem>
       <para>
	<envar>PGDATABASE</envar>  fija el nomber de la base de datos
	<productname>Postgres</productname> de defecto.
       </para>
      </listitem>
      <listitem>
       <para>
	<envar>PGUSER</envar>
      fija el nombre de usuario utilizado para conectarse a la base de datos y para
      la autenticación.
       </para>
      </listitem>
      <listitem>
       <para>
	<envar>PGPASSWORD</envar>
      fija la palabra de paso utilizada si el servidor solicita autenticación de la 
      palabra de paso.
       </para>
      </listitem>
      <listitem>
       <para>
	<envar>PGREALM</envar> fija el reino Kerberos a utilizar con 
	<productname>Postgres</productname>,
      si es diferente del reino local. Si se fija <envar>PGREALM</envar>, 
      las aplicaciones <productname>Postgres</productname> 
      intentarán la autenticación con los servidores de este reino, y utilizarán
      ficheros de ticket separados, para impedir conflictos con los ficheros de
      ticket locales. Esta variable de entorno sólo se utiliza si el servidor
      selecciona la autenticación Kerberos.
       </para>
      </listitem>
      <listitem>
       <para>
	<envar>PGOPTIONS</envar> fija opciones de tiempo de ejecución adicionales para
      el servidor de <productname>Postgres</productname>.
       </para>
      </listitem>
      <listitem>
       <para>
	<envar>PGTTY</envar> fija el fichero o tty al cual el servidor enviará los 
      mensajes de seguimiento de la ejecución.
       </para>
      </listitem>
     </itemizedlist>
    </para>
	
    <para>
     Las siguientes variables de entorno se pueden utilizar para especificar 
     el comportamiento de defecto para los usuarios para cada sesión de Postgres:
	  
     <itemizedlist>
      <listitem>
       <para>
	<envar>PGDATESTYLE</envar>
      fija el estilo de defecto de la representación de fecha/hora.
       </para>
      </listitem>
      <listitem>
       <para>
	<envar>PGTZ</envar>
      fija la zona horaria de defecto.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    
    <para>
     Las siguientes variables de entorno se pueden utilizar para especificar el 
     comportamiento interno de defecto para cada sesion de Postgres:
     
     <itemizedlist>
      <listitem>
       <para>
	<envar>PGGEQO</envar>
      fija el modo de defecto para el optimizador genérico.
       </para>
      </listitem>
     </itemizedlist>
    </para>
	
    <para>
     Encontrará información sobre los valores correctos de estas variables de 
     entorno en el comando <command>SET</command> de <acronym>SQL</acronym>.
    </para>
   </sect2>
  </sect1>

  <sect1>
   <title>Clases de libpq++</title>

   <sect2>
    <title>Clase de Conexión: <classname>PgConnection</classname></title>

    <para>
     La clase de conexión realiza la conexión en vigor sobre la base de datos, y se 
     hereda por todas las clases de acceso.
    </para>
   </sect2>

   <sect2>
    <title>Clase Base de Datos: <classname>PgDatabase</classname></title>

    <para>
     La Clase Base de Datos proporciona los objetos C++ que tienen una conexión
     con el servidor. Para crear tal objeto, primero se necesita el entorno 
     adecuado para acceder al servidor.
     Los constructores siguientes se relacionan con la realización de conexiones a 
     un servidor desde programas C++.
    </para>
   </sect2>
  </sect1>

  <sect1>
   <title>Funciones de Conexión a la Base de Datos</title>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       <function>PgConnection</function>
       realiza una nueva conexión a un servidor de base de datos.
       <synopsis>
	PgConnection::PgConnection(const char *conninfo)
       </synopsis>
       Aunque habitualmente se le llama desde una de las clases de acceso, también
       es posible conectarse a un servidor creando un objeto PgConnection.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>ConnectionBad</function>
       Devuelve si la conexión con el servidor de datos se consiguió o no.
       <synopsis>
	int PgConnection::ConnectionBad()
       </synopsis>
       Devuelve VERDADERO si la conexión falló.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>Status</function>
       devuelve el status de la conexión con el servidor.
       <synopsis>
	ConnStatusType PgConnection::Status()
       </synopsis>
       Devuelve CONNECTION_OK o CONNECTION_BAD dependiendo del estado de la
       conexión.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>PgDatabase</function>
       realiza una nueva conexión a un servidor de base de datos.
       <synopsis>
	PgDatabase(const char *conninfo)
       </synopsis>
       Tras la creación de PgDatabase, se debería comprobar para asegurarse
       de que la conexión se ha realizado con éxito antes de enviar consultas
       al objeto. Se puede hacer facilmente recogiendo el status actual del 
       objeto PgDatabase con los métodos
       <function>Status</function> o <function>ConnectionBad</function>.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>DBName</function>
       Devuelve el nombre de la base de datos actual.
       <synopsis>
	const char *PgConnection::DBName()
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>Notifies</function>
       Devuelve la siguiente notificación de una lista de mensajes de notificación sin
       manipular recibidos desde el servidor.
       <synopsis>
	PGnotify* PgConnection::Notifies()
       </synopsis>
       Vea PQnotifies() para conseguir más detalles.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect1>

  <sect1>
   <title>Funciones de Ejecución de las Consultas</title>
   <para>  
    <itemizedlist>
     <listitem>
      <para>
       <function>Exec</function>
       Envia una consulta al servidor. Probáblemente sea más deseable utilizar
       una de las dos siguientes funciones.
       <synopsis>
	ExecStatusType PgConnection::Exec(const char* query)
       </synopsis>
       Devuelve el resultado de la consulta. Se pueden esperar los siguientes resultados.
       
       <simplelist>
	<member>
	 PGRES_EMPTY_QUERY
	</member>
	<member>
	 PGRES_COMMAND_OK, si la consulta era un comando
	</member>
	<member>
	 PGRES_TUPLES_OK, si la consulta ha devuelto tuplas
	</member>
	<member>
	 PGRES_COPY_OUT
	</member>
	<member>
	 PGRES_COPY_IN
	</member>
	<member>
	 PGRES_BAD_RESPONSE, si se ha recibido una respuesta inesperada
	</member>
	<member>
	 PGRES_NONFATAL_ERROR
	</member>
	<member>
	 PGRES_FATAL_ERROR
	</member>
       </simplelist>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>ExecCommandOk</function>
       Envía una consulta de comando sobre el servidor.
       <synopsis>
	int PgConnection::ExecCommandOk(const char *query)
       </synopsis>
       Devuelve VERDADERO si la consulta de comando se realizó con exito.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>ExecTuplesOk</function>
       Envía una consulta de tuplas al servidor.
       <synopsis>
	int PgConnection::ExecTuplesOk(const char *query)
       </synopsis>
       Devuelve VERDADERO si la consulta se realizó con exito.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>ErrorMessage</function>
       Devuelve el texto del último mensaje de error.
       <synopsis>
	const char *PgConnection::ErrorMessage()
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>Tuples</function>
       Devuelve el número de tuplas (instancias) presentes en el resultado de 
       la consulta.
       <synopsis>
	int PgDatabase::Tuples()
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>Fields</function>
       Devuelve el número de campos (atributos) de cada tupla de las que componen
       el resultado de la consulta.
       <synopsis>
	int PgDatabase::Fields()
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>FieldName</function>
       Devuelve el nombre del campo (atributo) asociado al índice de campo dado.
       Los índices de campo empiezan en 0.
       <synopsis>
	const char *PgDatabase::FieldName(int field_num)
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>FieldNum</function>
       PQfnumber Devuelve el índice del campo (atributo) asociado con el nombre 
       del campo dado.
       <synopsis>
	int PgDatabase::FieldNum(const char* field_name)
       </synopsis>
       Si el nombre de campo no se corresponde con ninguno de los de la consulta
       se devuelve un valor de -1.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>FieldType</function>
       Devuelve el tipo de campo asociado con el índice de campo dado. El entero 
       devuelto es una codificación interna del tipo. Los índices de campo empiezan
       en 0.
       <synopsis>
	Oid PgDatabase::FieldType(int field_num)
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>FieldType</function>
       Devuelve el tipo de campo asociado con el nombre de campo dado. El
       entero devuelto es una codificación interna del tipo. Los índices de
       campo empiezan en 0.
       <synopsis>
	Oid PgDatabase::FieldType(const char* field_name)
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>FieldSize</function>
       Devuelve el tamaño en bytes del campo asociado con el índice de campo
       dado. Los índices de campo empiezan en 0.
       <synopsis>
	short PgDatabase::FieldSize(int field_num)
       </synopsis>
       Devuelve el lugar ocupado por este campo en la tupla de base de datos,
       dando el número de campo. En otras palabras, el tamaño de la representación
       binaria en el servidor del tipo de datos. Devolverá -1 si se trata de un
       campo de tamaño variable.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>FieldSize</function>
       Devuelve el tamaño en bytes del campo asociado con el índice de campo dado.
       Los índices de campo empiezan en 0.
       <synopsis>
	short PgDatabase::FieldSize(const char *field_name)
       </synopsis>
       Devuelve el espacio ocupado por este campo en la tupla de base de datos
       dando el nombre del campo. En otras palabras, el tamaño de la representación 
       binaria del tipo de datos en el servidor. Se devolverá -1 si el campo es de 
       tamaño variable.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>GetValue</function>
       Devuelve un valor único de campo (atributo) en una tupla de PGresult.
       Los índices de tupla y de campo empiezan en 0.
       <synopsis>
	const char *PgDatabase::GetValue(int tup_num, int field_num)
       </synopsis>
       Para la mayoría de las consultas, el valor devuelto por GetValue es
       una representación en ASCII terminada con un null del valor del atributo.
       Pero si BinaryTuples() es VERDADERO, el valor que devuelve GetValue es la
       representación binaria del tipo en el formato interno del servidor (pero sin 
       incluir el tamaño, en el caso de campos de longitud variable). Es responsabilidad
       del programador traducir los datos al tipo C correcto. El puntero de devuelve 
       GetValue apunta al almacenamiento que es parte de la estructura PGresult. 
       No se debería modificar, y se debería copiar explícitamente el valor a otro 
       almacenamiento si se debe utilizar pasado el tiempo de vida de la estructura
       PGresult misma. BinaryTuples() no se ha implementado aún.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>GetValue</function>
       Devuelve el valor de un único campo (atributo) en una tupla de PGresult.
       Los índices de tupla y campo empiezan en 0.
       <synopsis>
	const char *PgDatabase::GetValue(int tup_num, const char *field_name)
       </synopsis>
       Para la mayoría de las consultas, el valor devuelto por GetValue es
       una representación en ASCII terminada con un null del valor del atributo.
       Pero si BinaryTuples() es VERDADERO, el valor que devuelve GetValue es la
       representación binaria del tipo en el formato interno del servidor (pero sin 
       incluir el tamaño, en el caso de campos de longitud variable). Es responsabilidad
       del programador traducir los datos al tipo C correcto. El puntero de devuelve 
       GetValue apunta al almacenamiento que es parte de la estructura PGresult. 
       No se debería modificar, y se debería copiar explícitamente el valor a otro 
       almacenamiento si se debe utilizar pasado el tiempo de vida de la estructura
       PGresult misma. BinaryTuples() no se ha implementado aún.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>GetLength</function>
       Devuelve la longitud de un campo (atributo) en bytes. Los índices de tupla y
       campo empiezan en 0.
       <synopsis>
	int PgDatabase::GetLength(int tup_num, int field_num)
       </synopsis>
       Esta es la longitud actual del valor particular del dato, que es el tamaño 
       del objeto apuntado por GetValue. Tenga en cuenta que para valores 
       representados en ASCII, este tamaño tiene poco que ver con el tamaño
       binario indicado por PQfsize.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>GetLength</function>
       Devuelve la longitud de un campo (atributo) en bytes. Los índices de tupla y
       campo empiezan en 0.
       <synopsis>
	int PgDatabase::GetLength(int tup_num, const char* field_name)
       </synopsis>
       Esta es la longitud actual del valor particular del dato, que es el tamaño 
       del objeto apuntado por GetValue. Tenga en cuenta que para valores 
       representados en ASCII, este tamaño tiene poco que ver con el tamaño
       binario indicado por PQfsize.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>DisplayTuples</function>
       Imprime todas las tuplas y, opcionalmente, los nombres de atributo
       de la corriente de salida especificada.
       <synopsis>
	void PgDatabase::DisplayTuples(FILE *out = 0, int fillAlign = 1, 
	const char* fieldSep = "|",int printHeader = 1, int quiet = 0)
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>PrintTuples</function>
       Imprime todas las tuplas y, opcionalmente, los nombres de los atributos
       en la corriente de salida especificada.
       <synopsis>
	void PgDatabase::PrintTuples(FILE *out = 0, int printAttName = 1, 
	int terseOutput = 0, int width = 0) 
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>GetLine</function>
       <synopsis>
	int PgDatabase::GetLine(char* string, int length)
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>PutLine</function>
       <synopsis>
	void PgDatabase::PutLine(const char* string)
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>OidStatus</function>
       <synopsis>
	const char *PgDatabase::OidStatus()
       </synopsis>
      </para>
     </listitem>
     <listitem>
      <para>
       <function>EndCopy</function>
       <synopsis>
	int PgDatabase::EndCopy()
       </synopsis>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect1>

  <sect1>
   <title>Notificación Asíncrona</title>
    
   <para>
    <productname>Postgres</productname> soporta notificación asíncrona
    a través de los comandos <command>LISTEN</command> y <command>NOTIFY</command>.
    Un servidor registra su interes en un semáforo particular con el comando 
    <command>LISTEN</command>. Todos los servidores que están escuchando un
    semáforo particular identificado por su nombre recibirán una notificación
    asíncrona cuando otro servidor ejecute un <command>NOTIFY</command> 
    para ese nombre. No se pasa ninguna otra información desde el servidor
    que notifica al servidor que escucha. Por ello, típicamente, cualquier
    dato actual que se necesite comunicar se transfiere a través de la relación.
    
    <note>
     <para>
      En el pasado, la documentación tenía asociados los nombres utilizados para
      las notificaciones asíncronas con relaciones o clases. Sin embargo, no hay
      de hecho unión directa de los dos conceptos en la implementación, y los
      semáforos identificados con un nombre de hecho no necesitan tener una 
      relación correspondiente previamente definida.
     </para>
    </note>
   </para>
   <para>
    Las aplicaciones con <filename>libpq++</filename> son notificadas cada vez que 
    un servidor al que están conectadas recibe una notificación asíncrona. Sin 
    embargo la comunicación entre el servidor y la aplicación cliente no es 
    asíncrona. La aplicación con <filename>libpq++</filename>
    debe llamar al servidor para ver si hay información de alguna notificación
    pendiente. Tras la ejecución de una consulta, una aplicación cliente puede
    llamar a <function>PgDatabase::Notifies</function> para ver si en ese
    momento se encuentra pendiente algún dato de notificación desde el servidor.
    <function>PgDatabase::Notifies</function> devuelve la notificación de una
    lista de notificaciones pendientes de manipular desde el servidor.
    La función devuelve NULL si no hay notificaciones pendientes en el servidor.
    <function>PgDatabase::Notifies</function> se comporta como el reparto de una
    pila. Una vez que <function>PgDatabase::Notifies</function> ha devuelto 
    la notificación, esta se considera manipulada y se elimina de la lista de 
    
    <itemizedlist>
     <listitem>
      <para>
       <function>PgDatabase::Notifies</function>
       recupera notificaciones pendientes del servidor.
       
       <synopsis>
	PGnotify* PgDatabase::Notifies()
       </synopsis>
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    El segundo programa de muestra da un ejemplo del uso de notificaciones
    asíncronas.
   </para>
  </sect1>

  <sect1>
   <title>Funciones Asociadas con el Comando COPY.</title>
   
   <para>
    El comando <command>copy</command> de <productname>Postgres</productname>
    tiene opciones para leer y escribir en la conexión de red utilizada por 
    <filename>libpq++</filename>.
    Por esta razon, se necesitan funciones para acceder a esta conexión de
    red directamente, de forma que las aplicaciones puedan tomar ventajas
    completas de esta capacidad.
    
    <itemizedlist>
     <listitem>
      <para>
       <function>PgDatabase::GetLine</function>
       lee una linea de caracteres terminada con "nueva línea" (transmitida
       por el servidor) en una zona de almacenamiento (un buffer)
       <replaceable class="parameter">string</replaceable>
       de tamaño <replaceable class="parameter">length</replaceable>.
       <synopsis>
	int PgDatabase::GetLine(char* string, int length)
       </synopsis>
      </para>
      <para>
       Como la rutina de sistema de Unix
       <function>fgets (3)</function>,
       esta rutina copia 
       <literal><replaceable class="parameter">length</replaceable>-1</literal>
       caracteres en 
       <replaceable class="parameter">string</replaceable>.
       Es como <function>gets (3)</function>, sin embargo, 
       en que convierte la terminación "nueva línea" en un caracter null.
      </para>
      <para>
       <function>PgDatabase::GetLine</function>
       Devuelve EOF al final de un fichero, 0 si se ha leido la línea entera, y 1 si
       la zona de almacenamiento de ha llenado pero no se ha leído aún el carácter
       "nueva línea" de terminación.
      </para>
      <para>
       Nótese que la aplicación debe comprobar si la nueva línea consiste simplemente
       en único punto ("."), lo que indicaría que el servidor ha terminado de 
       enviar el resultado de <command>copy</command>.
       Por ello, si la aplicación siempre espera recibir líneas que tienen más de
       <literal><replaceable class="parameter">length</replaceable>-1</literal>
       caracteres de longitud, la aplicación deberá asegurarse de comprobar el 
       valor de retorno de <function>PgDatabase::GetLine</function> muy cuidadosamente.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>PgDatabase::PutLine</function>
       Envía un <replaceable class="parameter">string</replaceable> 
       terminado en null al servidor.
       <synopsis>
	void PgDatabase::PutLine(char* string)
       </synopsis>
      </para>
      <para>
       La aplicación debe enviar explícitamente un único punto (".") para
       indicar al servidor que ha terminado de enviar sus datos.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>PgDatabase::EndCopy</function>
       sincroniza con el servidor.
       <synopsis>
	int PgDatabase::EndCopy()
       </synopsis>
       Esta función espera hasta que el servidor ha terminado de procesar 
       el comando <command>copy</command>.
       Debería utilizarse bien cuando se ha enviado la última cadena al servidor
       utilizando <function>PgDatabase::PutLine</function>, bien cuando se ha 
       recibido la última cadena desde el servidor utilizando 
       <function>PgDatabase::GetLine</function>.
       Debe utilizarse, o el servidor puede detectar <quote>fuera de sincronía</quote>
       (out of sync) con la aplicación cliente. Una vez vuelve de esta función, el 
       servidor está preparado para recibir la siguiente consulta.
      </para>	    
      <para>
       El valor devuelto es 0 cuando se completa con éxito, y distinto de cero en otro caso.
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    As an example:
    
    <programlisting>
PgDatabase data;
data.Exec("create table foo (a int4, b char(16), d float8)");
data.Exec("copy foo from stdin");
data.putline("3\etHello World\et4.5\en");
data.putline("4\etGoodbye World\et7.11\en");
&amp;...
data.putline(".\en");
data.endcopy();
    </programlisting>
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
