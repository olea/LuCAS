**************** Colocar aquí la segunda parte del fichero.
**************** Dejar estas líneas para el coordinador.
Objetos de gran tamaño (Large Object)

Los objetos de gran tamaño están soportados en la especificación del 
estándar <acronym>JDBC</acronym>. No obstante, ese interface está limitado
y el api provisto por PotgreSQL permite el acceso aleatorio al contenido
de los objetos, como si se tratara de un archivo local.

El paquete postgresql.largeobject provee a Java de la interface <acronym>API</acronym>
para objetos grandes libpq C. Ésta consiste en dos clases, LargeObjectManager
que se encarga de crear, abrir y borrar objetos grandes, y LargeObject que se
encarga de un objeto individual.

Class postgresql.largeobject.LargeObject

java.lang.Object
   |
   +----postgresql.largeobject.LargeObject

public class LargeObject extends Object

Esta clase implemeta la interface a postgresql para objetos grandes.

Provee los métodos básicos requeridos para ejectutar la interface, además
de un par de métodos que proveen las clases InputStream y OutputStream para
este objeto.

Normalmente, el código cliente usaría los métodos getAsciiStream, 
getBinaryStream, o getUnicodeStream en ResultSet, o los métodos
setAsciiStream, setBinaryStream, o setUnicodeStream en PreparedStatement
para acceder a los objetos grandes.

Sin embargo, algunas veces se requiere el acceso a bajo nivel a los objetos
grandes, lo cual no se soporta en la especificación <acronym>JDBC</acronym>.

Refiérase a postgresql.largeobject.LargeObjectManager para ver cómo conseguir
acceso a un objeto de gran tamaño o cómo crear uno.

   Vea también:
          LargeObjectManager

Variables

 public static final int SEEK_SET

          Indica una búsqueda desde el principio de un archivo

 public static final int SEEK_CUR

          Indica una búsqueda desde la posición actual

 public static final int SEEK_END

          Indica una búsqueda desde el final de un archivo

Métodos

 public int getOID()

        Devuelve:
                El OID de este LargeObject

 public void close() throws SQLException

          Este método cierra el objeto. No se debe llamar a ningún método
en este objeto tras realizar esta llamada.

    Lanza: SQLException
                si ocurre un error de base de datos.

 public byte[] read(int len) throws SQLException

          Lee algunos datos del objeto y los devuelve como un array de bytes[]

        Parámetros:
                len - número de bytes a leer

        Devuelve:
                array de bytes[] que contiene los datos leidos

        Lanza: SQLException
                si ocurre un error de base de datos.

 public void read(byte buf[],
                  int off,
                  int len) throws SQLException

          Lee algunos datos del objeto y los introduce en un array preexistente

        Parámetros:
                buf - array destino
                off - desplazamiento dentro del array
                len - número de bytes a leer

        Lanza: SQLException
                si ocurre un error de base de datos.

 public void write(byte buf[]) throws SQLException

          Escribe un array al objeto


        Parámetros:
                buf - array a escribir

        Lanza: SQLException
                si ocurre un error de base de datos.

 public void write(byte buf[],
                   int off,
                   int len) throws SQLException

          Escribe algunos datos de un array a un objeto

        Parámetros:
                buf - array destino
                off - offset dentro del array
                len - número de bytes a escribir

        Lanza: SQLException
                si ocurre un error de base de datos.

 public void seek(int pos,
                  int ref) throws SQLException

          Fija la posición actual dentro del objeto.

          Esto es similar a la llamada fseek() en la librería C
          estándar.Le permite tener acceso aleatorio al objeto.

        Parámetros:
                pos - posición dentro del objeto
                ref - Cualquiera entre SEEK_SET, SEEK_CUR o SEEK_END
        Lanza: SQLException
                si ocurre un error de base de datos.

 public void seek(int pos) throws SQLException

          Establece la posición actual en el objeto.

          Esto es similar a la llamada fseek() en la librería C
          estándar. Le permite tener acceso aleatorio al objeto.

        Parámetros:
                pos - posición dentro del objeto desde el principio

        Lanza: SQLException
                si ocurre un error de base de datos.

 public int tell() throws SQLException

        Devuelve:
                la posición actual dentro del objeto

        Lanza: SQLException
                si ocurre un error de base de datos.

 public int size() throws SQLException
        Este método es ineficiente, ya que el único método para buscar
el tamaño del objeto es posicionarse al final, guardar la posición actual
y después volver a la posición inicial. 
        En el futuro se encontrará un método mejor.
      
        Devuelve:
                el tamaño del objeto

        Lanza: SQLException
                si ocurre un error de base de datos.

 public InputStream getInputStream() throws SQLException

          Devuelve un InputStream (canal de entrada) del objeto.

          Este InputStream puede ser usado posteriormente en cualquier
método que requiera un InputStream.

        Lanza: SQLException
                si ocurre un error de base de datos.

 public OutputStream getOutputStream() throws SQLException

          Devuelve un OutputStream (canal de salida) al objeto.

          Este OutputStream puede ser usado posteriormente en cualquier
método que requiera un OutputStream.

        Lanza: SQLException
                si ocurre un error de base de datos.

Class postgresql.largeobject.LargeObjectManager
                                
java.lang.Object
   |
   +----postgresql.largeobject.LargeObjectManager

public class LargeObjectManager extends Object

Esta clase implementa la interficie a objetos de gran tamaño de postgresql.
        
   Proporciona un método que permite al código cliente crear, abrir y
borrar objetos de gran tamaño desde la base de datos. Cuando se abre un
objeto, se devuelve una instancia de postgresql.largeobject.LargeObject
y sus métodod permiten el acceso al objeto.

Esta clase sólo puede ser creada por postgresql.Connection

Para obtener acceso a esta clase, usar el siguiente código:

 import postgresql.largeobject.*;
 Connection  conn;
 LargeObjectManager lobj;
 ... código que abre una conexión ...
 lobj = ((postgresql.Connection)myconn).getLargeObjectAPI();

Normalmente, el código del cliente usará los métodos getAsciiStream, 
getBinaryStream, o getUnicodeStream en los métodos ResultSet, o 
setAsciiStream, setBinaryStream, o setUnicodeStream en PreparedStatement 
para acceder a los objetos de gran tamaño.

   En cualquier caso, a veces es necesario acceso a bajo nivel al objeto,
lo que no es soportado por la especificación <acronym>JDBC</acronym>.

   Refiérase a postgresql.largeobject.LargeObject para saber cómo manipular
el contenido de un objeto de gran tamaño.


   Vea también:
          LargeObject

Variables

 public static final int WRITE

          Este modo indica que queremos escribir a un objeto

 public static final int READ

          Este modo indica que queremos leer un objeto

 public static final int READWRITE

          Este es el modo por defecto. Indica que queremos acceso
para lectura y para escritura al objeto		

Métodos

 public LargeObject open(int oid) throws SQLException
          
          Esto abre un objeto de gran tamaño existente, basado en su
OID. Este método asume que se requiere el acceso para lectura y escritura
(el modo por defecto).		  

        Parámetros:
                oid - del objeto

        Devuelve:
                Una instancia LargeObject la cual da acceso al objeto

        Lanza: SQLException
                en caso de error

 public LargeObject open(int oid,
                         int mode) throws SQLException
          
          Esto abre un objeto existente, basándose en su OID
  
        Parámetros:
                oid - del objeto
                mode - modo de apertura

        Devuelve:
                Una instancia LargeObject la cual da acceso al objeto

        Lanza: SQLException
                en caso de error

 public int create() throws SQLException

          Esto crea un objeto, devolviendo su OID.
		  Pone los nuevos atributos del objeto por defecto en modo lectura y escritura 


        Devuelve:
                oid del objeto

        Lanza: SQLException
                en caso de error

 public int create(int mode) throws SQLException

          Esto crea un objeto de gran tamaño, devolviendo su OID

        Parámetros:
                mode - una máscara de bits que describe los diferentes atributos del
				nuevo objeto

        Devuelve:
                oid del nuevo objeto

        Lanza: SQLException
                en caso de error

 public void delete(int oid) throws SQLException
          
          Esto elimina un objeto de gran tamaño.
          
        Parámetros:
                oid - que describe el objeto a eliminar

        Lanza: SQLException
                en caso de error

 public void unlink(int oid) throws SQLException

          Esto elimina un objeto de gran tamaño.

          Es idéntico al método "delete" y se facilita su uso como en el
		  <acronym>API</acronym> C.

        Parámetros:
                oid - que describe el objeto a eliminar

        Lanza: SQLException
                en caso de error

Adaptación del objeto (Serialisation)
PostgreSQL no es una base de datos SQL normal. Es mucho más extensible que
muchas otras bases de datos y soporta características únicas de orientación
a objetos.

Una de las consecuencias de esto es que puede tener una tabla referida a una
fila en otra tabla. Por ejemplo:

test=> create table users (username name,fullname text);
CREATE
test=> create table server (servername name,adminuser users);
CREATE
test=> insert into users values ('peter','Peter Mount');
INSERT 2610132 1
test=> insert into server values ('maidast',2610132::users);
INSERT 2610133 1
test=> select * from users;
username|fullname      
--------+--------------
peter   |Peter Mount   
(1 row)

test=> select * from server;
servername|adminuser
----------+---------
maidast   |  2610132
(1 row)

De acuerdo, el ejemplo anterior muestra cómo se puede usar un nombre
de tabla como un campo y el valor oid de la fila se almacena en ese campo.

¿Qué tiene esto que ver con Java?

En Java, se puede almacenar un objeto en un stream mintras su clase implemente
el interface java.io.Serializable. Este proceso, conocido como adaptación
de un objeto (Object Serialization), puede ser usado para almacenar objetos
complejos en una base de datos.

Ahora, bajo <acronym>JDBC</acronym>, puede tener que usar un Objeto de gran
tamaño para almacenarlo. Sin embargo, no se pueden realizar consultas a
estos objetos.

Lo que hace la clase postgresql.util.Serialize es proveer un método para
almacenar un objeto como una tabla y para devolver ese objeto desde una
tabla. En muchos casos, no necesitaría acceder a esta clase directamente,
pero podría usar los métodos PreparedStatement.setObject() y ResultSet.getObject().
Estos métodos comprueban los nombres de clase de los objetos contra las
tablas en la base de datos. Si se encuentra una coincidencia, se asume
que el objeto es un objeto adaptado, y se devuelve desde la tabla.
De la misma forma, si el objeto contiene otros objetos adaptados, se
repite recursivamente a través del árbol.

¿Suena complicado? De hecho, es más fácil de lo que he escrito, sólo es
difícil de explicar.

El único momento en el que debería acceder a esta clase es para usar los
métodos create(). No son usados por el driver, pero hacen una o más declaraciones
"create table" a la base de datos, basándose en un objeto o clase Java que
desee adaptar.

Ah, una última cosa. Si su objeto contine una línea como:

     public int oid;

después, cuando el objeto es devuelto desde una tabla, se asigna al oid
dentro de la tabla. Después, si el objeto es modificado y re-adaptado,
la entrada existente se actualiza.

Si la variable oid no está presente, cuando el objeto es adaptado, siempre
se inserta en la tabla y cualquier entrada existente en la tabla se mantiene.

Poniendo oid a cero antes de la adaptación, también hará que el objeto 
se inserte. Ésto permite a un objeto estar duplicado en la base de datos.

Class postgresql.util.Serialize

java.lang.Object
   |
   +----postgresql.util.Serialize

   public class Serialize extends Object

   Esta clase usa las características de orientación a objetos de PostgreSQL 
para almacenar objetos Java. Ésto ser realiza mapeando un nombre de clase 
Java a una tabla en la base de datos. Cada entrada en esta nueva tabla 
representa una instancia adaptada de esta clase. Como cada entrada tiene
un OID (identificador de objeto), este OID puede incluirse en otra tabla.
Esto es demasiado complejo para mostralo aquí y será documentado en los
documentos principales con más detalle.

Constructores

 public Serialize(Connection c,
                  String type) lanza SQLException

          Esto crea una instancia que puede ser usada para adaptar o
desadaptar un objeto Java desde una tabla PostgreSQL.  

Métodos

 public Object fetch(int oid) throws SQLException

          Selecciona un objeto desde una tabla, dado su OID

        Parámetros:
                oid - El oid del objeto

        Devuelve:
                Objeto asociado al oid

        Lanza: SQLException
                si hay error

 public int store(Object o) throws SQLException

          Almacena un objto en una tabla, devolviendo su OID.

          Si el objeto tiene un entero llamado OID y es mayor a cero,
este valor se usa para el OID y la tabla será actualizada. Si el valor
de OID es cero, se crea una nueva entrada y el valor de OID se pondrá en
el objeto. Esto permite que el valor de un objeto en la base de datos sea
actualizable. Si el objeto no tiene un entero llamado OID, el objeto se
almacena. Sin embargo, si el objeto es devuelto más tarde, corregido y
almacenado de nuevo, su nuevo estao será añadido a la tabla y no sobreescribirá
las entradas antiguas.

        Parámetros:
                o - Objeto a almacenar (debe implementar Serializable)

        Devuelve:
                oid del objeto almacenado

        Lanza: SQLException
                en caso de error
 
 public static void create(Connection con,
                           Object o) throws SQLException

          Este método no es usado por el driver, pero crea una tabla
dado un objeto Java	adaptable. Debe ser usado antes de adaptar cualquier
objeto.

        Parámetros:
                c - Conexión a la base de datos
                o - Objeto en el que se basará la tabla

        Lanza: SQLException
                en caso de error

        Retorna:
		       Objeto relacionado con el oid

        Lanza: SQLException
                en caso de error

 public int store(Object o) throws SQLException

          Ésto almacena un objeto en una tabla, retornando su OID.

          Si el objeto tiene un entero llamando OID y es mayor a cero,
este valor se usa para el OID y la tabla se actualizará. Si el valor de
OID es cero, se creará una nueva fila y se pondrá el valor del OID en el
objeto. Ésto permite que el valor de un objeto en la base de datos sea
actualizable. Si el objeto no tiene un entero llamado OID, el objeto se
almacena. Sin embargo, si el objeto es devuelto más tarde, corregido y
almacenado de nuevo, su nuevo estao será añadido a la tabla y no sobreescribirá
las entradas antiguas.

        Parámetros:
                o - Objeto a almacenar (debe implementar Serializable)

        Devuelve:
                oid del objeto almacenado

        Lanza: SQLException
                en caso de error
 
 public static void create(Connection con,
                           Object o) throws SQLException

          Este método no es usado por el driver, pero crea una tabla,
dado un objeto Java adaptado. Debe ser usado antes de adaptar cualquier
objeto.

        Parámetros:
                c - Conexión a la base de datos
                o - Objeto en el que se basa la tabla

        Lanza: SQLException
                en caso de error
                
 public static void create(Connection con,
                           Class c) throws SQLException

          Este método no es usado por el driver, pero crea una tabla,
dado un objeto Java adaptado. Debe ser usado antes de adaptar cualquier
objeto.

        Parámetros:
                c - Conexión a la base de datos
                o - Clase en el que se basa la tabla

        Lanza: SQLException
                en caso de error

 public static String toPostgreSQL(String name) throws SQLException
          
          Ésto convierte un nombre de clase de Java en una tabla
		  postgresql, reemplazando . por _

          Debido a esto, una clase no debe contener _ en su nombre.

          Otra limitación es que nombre completo de la clase (incluyendo
		  los paquetes) no debe ser mayor de 31 caracteres (un límite forzado
		  por PostgreSQL).

        Parámetros:
                name - nombre de la clase

        Devuelve:
                Nombre de la tabla PostgreSQL

        Lanza: SQLException
                en caso de error
          
 public static String toClassName(String name) throws SQLException

          Ésto convierte una tabla postgresql a un nombre de clase
		  Java, reemplazando _ por .

        Parámetros:
                name - nombre de la tabla PostgreSQL
  
        Returns:
                nombre de la clase

        Lanza: SQLException
                en caso de error

Clases de utilidades

El paquete postgresql.util contiene clases usadas por el funcionamiento
interno del driver y otras extensiones.

Class postgresql.util.PGmoney
                                
java.lang.Object
   |
   +----postgresql.util.PGobject
           |
           +----postgresql.util.PGmoney

   public class PGmoney extends PGobject implements Serializable, 
Cloneable
               
   Ésto implementa una clase que maneja el tipo PostgreSQL "money"

Variables

 public double val
                                
          El valor del campo

Constructores
           
 public PGmoney(double value)
   
        Parámetros:
                value - del campo
               
 public PGmoney(String value) throws SQLException
   
          Ésto es llamado principalmente desde otros tipos geométricos,
cuando un punto está embebido en su definición.		  

        Parámetros:
                value - Definición de este punto en la sintaxis PostgreSQL

 public PGmoney()

          Requerido por el driver

Métodos

 public void setValue(String s) throws SQLException

        Parámetros:
                s - Definición de este punto en la sintaxis PostgreSQL

        Lanza: SQLException
                en caso de fallo en la conversión

        Overrides:
                setValue en la clase PGobject

 public boolean equals(Object obj)

        Parámetros:
                obj - Objeto a comparar
                                
        Devuelve:
                cierto si las dos cajas son idénticas

        Overrides:
                iguales en la clase PGobject

 public Object clone()
                
          Esto debe superponerse (override) para permitir al objeto ser clonado

        Overrides:
                clon en la clase PGobject

 public String getValue()

        Devuelve:
                el PGpoint en la sintaxis esperada por postgresql

        Overrides:
                getValue en la clase PGobject

Class postgresql.util.PGobject

java.lang.Object
   |
   +----postgresql.util.PGobject

   public class PGobject extends Object implements Serializable, 
Cloneable
               
   Esta clase se usa para describir tipos de datos desconocidos por el
estandar  <acronym>JDBC</acronym>.
Una llamada a postgresql.Connection permite que una clase que extiende
a esta sea asociada con un nombre de tipo. Así es como opera el paquete
postgresql.geometric.
	ResultSet.getObject() devolverá esta clase para cualquier tipo que sea
no reconocido o que tenga su propio manejador. Debido a esto, se soporta
cualquier tipo postgresql.

Constructores

 public PGobject()

          Llamado por postgresql.Connection.getObject() para crear
el objeto.

Métodos

 public final void setType(String type)

          Este método pone el tipo de este objeto.

          No debe ser extendido mediante subclases, por lo tanto es final

        Parámetros:
                tipo - una cadena que describe el tipo del objeto

 public void setValue(String value) throws SQLException

          Este método pone el valor del objeto. Debe ser superpuesto (override).

        Parámetros:
                value - una cadena que representa el valor del objeto

        Lanza: SQLException
                se lanza si el valor es inválido para ese tipo
    
 public final String getType()

          Como no puede variar durante la vida del objeto, es final

        Devuelve:
                el nombre del tipo del objeto

 public String getValue()

          Debe ser superpuesto, para devolver el valor del objeto, de la
forma requerida por postgresql.		  


        Devuelve:
                el valor del objeto

 public boolean equals(Object obj)

          Debe ser superpuesto para permitir comparaciones de objetos

        Parámetros:
                obj - Objeto a comparar

        Devuelve:
                cierto si las dos cajas son idénticas

        Overrides:
                iguales en clase Object

 public Object clone()

          Debe ser superpuesto para permitir que el objeto sea clonado

        Overrides:
                clon en la clase Object

 public String toString()

          Está definido aquí, por lo cual el código del usuario no necesita
superponerlo (override).		  
          
        Devuelve:
                el valor del objeto, en la sintaxis esperada por postgresql

        Overrides:
                toString en la clase Object

Class postgresql.util.PGtokenizer

java.lang.Object
   |
   +----postgresql.util.PGtokenizer

   public class PGtokenizer extends Object

   Esta clase se usa para "tokenizar" (obtener los tokens o lexemas de) el texto de salida de postgres.

   Podemos usar StringTokenizer para hacer esto, no obstante, necesitaremos
manejar anidados de '(' ')' '[' ']' '<' y '>' ya que son usados por los tipos
de datos geométricos.

   Se usa principalmente por las clases geométricas, pero es útil en el parseado
de cualquier salida de tipos de datos de usuario hacia prostgresql.
                 
   Vea también:
          PGbox, PGcircle, PGlseg, PGpath, PGpoint, PGpolygon
          
Constructores

 public PGtokenizer(String string,
                    char delim)

          Crea un "tokenizador"

        Parámetros:
                string - que contiene los tokens (lexemas en la cadena)
                delim - caracter simple para dividir los lexemas

Métodos
        
 public int tokenize(String string,
                     char delim)

          Resetea el "tokenizador" con una nueva cadena y/o delimitador.

        Parámetros:
                string - que contiene los tokens
                delim - caracter simple para dividir los tokens

 public int getSize()

        Devuelve:
                el número de tokens disponibles

 public String getToken(int n)

        Parámetros:
                n - Número de token ( 0 ... getSize()-1 )

        Devuelve:
                El valor del token

 public PGtokenizer tokenizeToken(int n,
                                  char delim)

          Devuelve un nuevo "tokenizador" basándose en uno de nuestros tokens.
Los tipos de datos geométricos lo usan para procesar tokens anidades (usualmente
PGpoint).

        Parámetros:
                n - Número de token ( 0 ... getSize()-1 )
                delim - Delimitador a usar

        Devuelve:
				Una nueva instancia de PGtokenizer basada en el token

 public static String remove(String s,
                             String l,
                             String t)

          Elimina de una cadena las cadenas indicadas de su izquierda y derecha (lead/trailing)

        Parámetros:
                s - Cadena fuente
                l - Cadena de la izquierda (leading) a eliminar
                t - Cadena de la derecha (trailing) a eliminar
                
        Devuelve:
                Una cadena sin las cadenas de la izquierda y la derecha

 public void remove(String l,
                    String t)

          Elimina las cadenas de su izquierda y derecha (lead/trailing) de todos los lexemas

        Parámetros:
                l - Cadena de la izquierda (leading) a eliminar
                t - Cadena de la derecha (trailing) a eliminar

 public static String removePara(String s)

          Elimina ( y ) desde el principio y final de una cadena

        Parámetros:
                s - Cadena a tratar

        Devuelve:
                Cadena sin el ( o )

 public void removePara()

          Elimina ( y ) del principio y final de todos los lexemas

        Devuelve:
                Cadena sin el ( o )

 public static String removeBox(String s)
   
          Elimina [ y ] desde el principio y final de una cadena

        Parámetros:
                s - Cadena a tratar
   
        Devuelve:
                Cadena sin el [ o ]

 public void removeBox()

          Elimina [ y ] del principio y final de todos los lexemas

        Devuelve:
                Cadena sin el [ o ]

 public static String removeAngle(String s)

          Elimina < y > desde el principio y final de una cadena

        Parámetros:
                s - Cadena a tratar

        Devuelve:
                Cadena sin el < o >

 public void removeAngle()

          Elimina < y > del principio y final de todos los lexemas

        Devuelve:
                Cadena sin el < o >

Class postgresql.util.Serialize

Ha sido documentado anteriormente en la sección Adaptación del objeto (Serialisation)

Class postgresql.util.UnixCrypt
              
java.lang.Object
   |
   +----postgresql.util.UnixCrypt

   public class UnixCrypt extends Object

   Esta clase provee una utilidad con la capacidad de encriptar passwords
al enviarlos sobre el flujo de red.   

   Contiene métodos estáticos para encriptar y comparar los passwords
con los passwords encriptados de Unix.   

   Vea la página "John Dumas's Java Crypt" para ver la fuente original.

   http://www.zeh.com/local/jfd/crypt.html

Métodos

 public static final String crypt(String salt,
                                  String original)

          Encripta un password habiendo dado el password en texto
en claro y un "salt" (cadena mediante la cual se encripta el password)
   
        Parámetros:
                salt - Una cadena de dos caracteres que representa el
				"salt" para iterar el mecanismo de encriptación de muchas
				formas diferentes. Si está generando una nueva encriptación
				este valor deberá ser aleatorio.

                original - El password a ser encriptado.

        Devuelve:
                Una cadena que consiste en los dos caracteres del salt seguidos
				del password encriptado.
            
 public static final String crypt(String original)

          Encripta un password, dado el password en texto en claro. Éste método
genera un salt usando la clase 'java.util.Random'.  

        Parámetros:
                original - El password a ser encriptado.
   
        Devuelve: 
                Una cadena que consiste en los dos caracteres del salt seguidos
				del password encriptado.
				             
 public static final boolean matches(String encryptedPassword,
                                     String enteredPassword)
                 
          Comprueba que el password introducido concuerda con el encriptado.
               
        Parámetros:
                encryptedPassword - El password encriptado. Los primeros dos
caracteres se asume que son el salt. Ésta cadena podría ser igual a una que se
encontrara en el archivo Unix /etc/passwd.
                enteredPassword - El password introducido por el usuario (u otro
adquirido de otra forma).

        Devuelve:
                cierto si el password debe ser considerado correcto.

Usando el driver en un entorno multi-hilo (multi thread) o servlet

Un problema con muchos drivers <acronym>JDBC</acronym> es que sólo un hilo
puede una conexión a la vez - de otra forma podría enviar una consulta mientras
otro está recibiendo los resultados y ésto podría ser negativo para el mecanismo
de la base de datos.


PostgreSQL 6.4, ogrece seguridad en los hilos para todo el driver. El estandard
<acronym>JDBC</acronym> era seguro en thread en la versión 6.3.x, pero el
<acronym>API</acronym>  Fastpath no lo era.

Por lo tanto, si su aplicación usa múltiples hilos (muchas de las aplicaciones
decentes puede usarlos), no necesita preocuparse sobre complejos esquemas para
asegurar que sólo uno de ellos accede a la base de datos a la vez.

Si un hilo intenta usar la conexión mientras otro la está usando, esperará hasta
que el otro hilo haya finalizado su operación actual.

Si la operación es una sentencia SQL estandard, la operación envía la sentencia y
devuelve cualquier ResultSet (por completo).

Si es una llamada Fastpath (por ejemplo: leer un bloque de un LargeObject), es el 
momento de enviar y devolver ese bloque.

Ésto es correcto para aplicaciones y applets, pero puede causar problemas de
funcionamiento con los servlets.

Con servlets puede tener una gran carga en la conexión. Si usted tiene
muchos hilos realizando consultas, cada uno se pausará, lo cual puede no ser
lo que se pretendía.

Para resolver ésto, puede ser aconsejado para crear un pool (conjunto) de conexiones.

Cuando en algún momento un hilo necesite usar la base de datos, pregunta a
una clase manejadora para realizar la conexión. Toma una conexión libre
para el hilo y la marca como ocupada. Si no está disponoble una conexión libre,
abre una nueva.

Una vez que el hilo ha acabado con ella, la devuelve al manejador, el cual
puede cerrarla o añadirla al pool. El manejador también podría comprobar
que la conexión todavía está viva y eliminarla del pool en caso contrario.

Por lo tanto, con servlets es elección suya usar una conexión simple o un pool.
La parte positiva de un pool es que  los hilos no se verán afectados por
el cuello de botella provocado por una sola conexión de red. La parte negativa
es que incrementa la carga del servidor, ya que se crea un backend para cada
conexión.

Es cuestión de sus preferencias y de los requerimientos de sus aplicaciones.
</programlisting>
</para>
</sect1>

<sect1>
<title>Próximas lecturas</title>

<para>
Si todavía no lo ha hecho, le recomiendo que lea la documentación del
<acronym>API</acronym> <acronym>JDBC</acronym> (proporcionada por 
<acronym>JDK</acronym> de Sun, y la especificación del <acronym>JDBC</acronym>.
Ambas están disponibles en 
<ulink url="http://www.javasoft.com">JavaSoft's web site</ulink>.
</para>

<para>
<ulink url="http://www.retep.org.uk">Mi propia web</ulink> contiene información
no incluída en este documento y tabién incluye drivers precompiladors para la v6.4
y anteriores.
</para>
</sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/CATALOG"
sgml-local-ecat-files:nil
End:
-->
