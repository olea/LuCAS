<Chapter Id="rules">
<Title>El Sistema de reglas de <ProductName>Postgres</ProductName></Title>

<Para>
     Los sistemas de reglas de producción son conceptualmente simples,
     pero hay muchos puntos sutiles implicados en el uso actual de ellos.
     Algunos de estos puntos y los fundamentos teóricos del sistema de 
     reglas de <ProductName>Postgres</ProductName> se pueden encontrar en
     [<XRef LinkEnd="STON90b" EndTerm="STON90b">].
</Para>

<Para>
     Algunos otros sistemas de base de datos definen reglas de base 
     de datos activas. Éstas son habitualmente procedimientos y disparadores 
     (a partir de aquí utilizaré el término más habitual de "trigger")
     almacenados y se implementan en
     <ProductName>Postgres</ProductName>
     como funciones y triggers.  
</Para>

<Para>
     El sistema de reglas de reescritura de queries (el "sistema de reglas" 
     a partir de ahora) es totalmente diferente a los procedimientos 
     almacenados y los triggers. Él modifica las queries para tomar 
     en consideración las reglas y entonces pasa la query modificada al 
     optimizador para su ejecución. Es muy poderoso, y puede utilizarse 
     de muchas formas, tales como procedimientos, vistas y versiones del 
     lenguaje de query. El poder de este sistema de reglas se discute en
[<XRef LinkEnd="ONG90" EndTerm="ONG90">]
 y en
[<XRef LinkEnd="STON90b" EndTerm="STON90b">].
</para>
<Sect1>
<Title>¿Qué es un árbol de query?</Title>

<Para>
    Para comprender como trabaja el sistema de reglas, es necesario conocer 
    cuándo se invoca y cuáles son sus inputs y sus resultados.
</Para>

<Para>
    El sistema de reglas se situa entre el traductor de la query y el 
    optimizador. Toma la salida del traductor, un árbol de la query, 
    y las reglas de reescritura del catálogo <FileName>pg_rewrite</FileName>, 
    los cuales son también árboles de queries con alguna información extra, 
    y crea cero o muchos árboles de query como resultado. De este modo, 
    su input y su output son siempre tales como el traductor mismo podría 
    haberlos producido y, de este modo, todo aparece básicamente repesentable 
    como una instrucción <Acronym>SQL</Acronym>.
</Para>

<Para>
    Ahora, ¿qué es un árbol de query? Es una representación interna de una 
    instrucción  <Acronym>SQL</Acronym> donde se almacenan de modo separado 
    las partes menores que la componen. Estos árboles de query son visibles 
    cuando arrancamos el motor de <ProductName>Postgres</ProductName> con 
    nivel de debug 4 y tecleamos queries en el interface de usuario 
    interactivo. 
    Las acciones de las reglas almacenadas en el catalgo de sistema 
    <FileName>pg_rewrite</FileName> están almacenadas también como árboles 
    de queries. No están formateadas como la salida del debug, pero contienen 
    exactamente la misma información. 
</Para>

<Para>
    Leer un árbol de query requiere experiencia y era bastante duro cuando 
    empecé a trabajar en el sistema de reglas. Puedo recordar que mientras 
    estaba esperando en la máquina de café asimilaba el vaso a una lista de 
    objetivos, el agua y el polvo del café a una tabla de rangos, y todos 
    los botones a expresiones de cualificación. Puesto que las 
    representaciones de <Acronym>SQL</Acronym> de árboles de queries son 
    suficientes para entender el sistema de reglas, este documento no le 
    enseñará como leerlo. Él debería ayudarle a aprenderlo, con las 
    convenciones de nombres requeridas en las descripciones que siguen más 
    adelante.
</Para>

<Sect2>
<Title>Las partes de un árbol de query</Title>

<Para>
    Cuando se leen las representaciones de <Acronym>SQL</Acronym> de los 
    árboles de queries en este documento, es necesario ser capaz de 
    identificar las partes de la instrucción que se ha roto en ella, y que 
    está en la estructura del árbol de query. Las partes de un árbol de 
    query son:
</Para>

<Para>
<VariableList>
    <VarListEntry>
    <Term>
        El tipo de commando (commandtype)
    </Term>
    <ListItem>
    <Para>
        Este es un valor sencillo que nos dice el comando que produjo el 
	arbol de traducción (SELECT, INSERT, UPDATE, DELETE).
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>
    <Term>
        La tabla de rango (rangetable)
    </Term>
    <ListItem>
    <Para>
        La tabla de rango es una lista de las relaciones que se utilizan 
	en la query. En una instrucción SELECT, son las relaciones dadas 
	tras la palabra clave FROM.
    </Para>

    <Para>
        Toda entrada en la tabla del rango identifica una tabla o vista, 
	y nos dice el nombre por el que se la identifica en las otras 
	partes de la query. En un árbol de query, las entradas de la tabla 
	de rango se indican por un índice en lugar de por su nombre como 
	estarían en una instrucción <Acronym>SQL</Acronym>. Esto puede ocurrir 
	cuando se han mezclado las tablas de rangos de reglas. Los ejemplos 
	de este documento no muestran esa situación.
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>
    <Term>
        La relación-resultado (resultrelation).
    </Term>
    <ListItem>
    <Para>
        Un índice a la tabla de rango que identifica la relación donde irán 
	los resultados de la query.
    </Para>

    <Para>
        Las queries SELECT normalmente no tienen una relación resultado. El 
	caso especial de una SELECT INTO es principalmente identica a una 
	secuencia CREATE TABLE, INSERT ... SELECT y no se discute aquí por 
	separado. 
    </Para>

    <Para>
        En las queries INSERT, UPDATE y DELETE, la relación resultado es la 
	tabla (¡o vista!) donde tendrán efecto los cambios.
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>
    <Term>
        La lista objetivo (targetlist).
    </Term>
    <ListItem>
    <Para>
        La lista objetivo es una lista de expresiones que definen el resultado 
	de la query. En el caso de una SELECT, las expresiones son las que 
	construyen la salida final de la query. Son las expresiones entre 
	las palabras clave SELECT y FROM (* es sólo una abreviatura de 
	todos los nombres de atributos de una relación).
    </Para>

    <Para>
        Las queries DELETE no necesitan una lista objetivo porque no producen 
	ningún resultado. De hecho, el optimizador añadirá una entrada 
	especial para una lista objetivo vacía. Pero esto ocurre tras el 
	sistema de reglas y lo comentaremos más tarde. Para el sistema de 
	reglas, la lista objetivo está vacía.
    </Para>

    <Para>
        En queries INSERT la lista objetivo describe las nuevas filas que irán 
	a la relación resultado. Las columnas que no aparecen en la relación 
	resultado serán añadidas por el optimizador con una expresión 
	constante NULL. Son las expresiones de la clausula VALUES y las de la 
	clausula SELECT en una INSERT .... SELECT.
    </Para>

    <Para>
        En queries UPDATE, describe las nuevas filas que reemplazarán a otras 
	viejas. Ahora el optimizador añadirá las columnas que no aparecen 
	insertando expresiones que recuperan los valores de las filas viejas 
	en las nuevas. Y añadirá una entrada especial como lo hace DELETE. Es 
	la parte de la query que recoge las expresiones del atributo 
	SET atributo = expresión.
    </Para>

    <Para>
        Cada entrada de la lista objetivo contiene una expresion que puede ser 
	un valor constante, una variable apuntando a un atributo de una de las 
	relaciones en la tabla de rango, un parámetro o un arbol de 
	expresiones hecho de llamadas a funciones, constantes, variables, 
	operadores, etc.
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>
    <Term>
        La cualificación.
    </Term>
    <ListItem>
    <Para>
        La cualificación de las queries es una expresión muy similar a otra de 
	las contenidas en las entradas de la lista objetivo. El valor 
	resultado de esta expresión e un booleano que dice si la operación 
	(INSERT, UPDATE, DELETE o SELECT) para las filas del resultado final 
	deberá ser ejecutada o no. Es la clausula WHERE de una instrucción 
	<Acronym>SQL</Acronym>.
    </Para>
    </ListItem>
    </VarListEntry>

    <VarListEntry>
    <Term>
        the others
    </Term>
    <ListItem>
    <Para>
        Las otras partes de un arbol de query, como la clausula ORDER BY, no 
	tienen interés aquí. El sistema de reglas sustituye las entradas aquí 
	presentes mientras está aplicando las reglas, pero aquellas no tiene 
	mucho que hacer con los fundamentos del sistema de reglas. GROUP BY es 
	una forma especial en la que aparece una definición de una vista, y 
	aún necesita ser documentado.
    </Para>
    </ListItem>
    </VarListEntry>

</VariableList>
</para>
</Sect2>
</Sect1>

<Sect1>
<Title>Las vistas y el sistema de reglas.</Title>

<Sect2>
<Title>Implementación de las vistas en 
<ProductName>Postgres</ProductName></Title>

<Para>
    Las vistas en <ProductName>Postgres</ProductName> se implementan 
    utilizando el sistema de reglas. De hecho, no hay diferencia entre

<ProgramListing>
    CREATE VIEW myview AS SELECT * FROM mytab;
</ProgramListing>
    
    y la secuencia:

<ProgramListing>
    CREATE TABLE myview 
    (<Replaceable>la misma lista de atributos de mytab</Replaceable>);
    CREATE RULE "_RETmyview" AS ON SELECT TO myview DO INSTEAD
        SELECT * FROM mytab;
</ProgramListing>
    
    Porque esto es exactamente lo que hace internamente el comando CREATE VIEW.
    Esto tiene algunos efectos colaterales. Uno de ellos es que la información 
    sobre una vista en el sistema de catálogos de 
    <ProductName>Postgres</ProductName> es exactamente el mismo que para una 
    tabla. De este modo, para los traductores de queries, no hay diferencia 
    entre una tabla y una vista, son lo mismo: relaciones. Esto es lo más 
    importante por ahora.
</Para>
</Sect2>

<Sect2>
<Title>Cómo trabajan las reglas de SELECT</Title>

<Para>
    Las reglas ON SELECT se aplican a todas las queries como el último paso, 
    incluso si el comando dado es INSERT, UPDATE o DELETE. Y tienen diferentes 
    semanticas de las otras en las que modifican el arbol de traducción en 
    lugar de crear uno nuevo. Por ello, las reglas SELECT se describen las 
    primeras.
</Para>

<Para>
    Actualmente, debe haber sólo una acción y debe ser una acción SELECT que 
    es una INSTEAD. Esta restricción se requería para hacer las reglas seguras 
    contra la apertura por usuarios ordinarios, y restringe las reglas 
    ON SELECT a reglas para vistas reales.
</Para>

<Para>
    El ejemplo para este documento son dos vistas unidas que hacen algunos 
    cálculos y algunas otras vistas utilizadas para ello. Una de estas dos 
    primeras vistas se personaliza más tarde añadiendo reglas para operaciones
    de INSERT, UPDATE y DELETE de modo que el resultado final será una vista 
    que se comporta como una tabla real con algunas funcionalidades mágicas. 
    No es un ejemplo fácil para empezar, y quizá sea demasiado duro. Pero es 
    mejor tener un ejemplo que cubra todos los puntos discutidos paso a paso 
    que tener muchos ejemplos diferentes que tener que mezclar después.    
</Para>

<Para>
    La base de datos necesitada para ejecutar los ejemplos se llama al_bundy. 
    Verá pronto el porqué de este nombre. Y necesita tener instalado el 
    lenguaje procedural PL/pgSQL, ya que necesitaremos una pequeña función 
    min() que devuelva el menor de dos valores enteros. 
    Creamos esta función como:

<ProgramListing>
    CREATE FUNCTION min(integer, integer) RETURNS integer AS
        'BEGIN
            IF $1 < $2 THEN
                RETURN $1;
            END IF;
            RETURN $2;
        END;'
    LANGUAGE 'plpgsql';
</ProgramListing>
</Para>

<Para>
    Las tablas reales que necesitaremos en las dos primeras descripciones del 
    sistema de reglas son estas: 

<ProgramListing>
    CREATE TABLE shoe_data (      -- datos de zapatos
        shoename   char(10),      -- clave primaria (primary key)
        sh_avail   integer,       -- número de pares utilizables
        slcolor    char(10),      -- color de cordón preferido
        slminlen   float,         -- longitud mínima de cordón
        slmaxlen   float,         -- longitud máxima del cordón
        slunit     char(8)        -- unidad de longitud
    );

    CREATE TABLE shoelace_data (  -- datos de cordones de zapatos
        sl_name    char(10),      -- clave primaria (primary key)
        sl_avail   integer,       -- número de pares utilizables
        sl_color   char(10),      -- color del cordón
        sl_len     float,         -- longitud del cordón
        sl_unit    char(8)        -- unidad de longitud
    );

    CREATE TABLE unit (           -- unidades de longitud
        un_name    char(8),       -- clave primaria (primary key)
        un_fact    float          -- factor de transformación a cm
    );
</ProgramListing>

    Pienso que la mayoría de nosotros lleva zapatos, y puede entender que 
    este es un ejemplo de datos realmente utilizables. Bien es cierto que hay 
    zapatos en el mundo que no necesitan cordones, pero nos hará más facil la 
    vida ignorarlos.
</Para>

<Para>
    Las vistas las crearemos como:

<ProgramListing>
    CREATE VIEW shoe AS
        SELECT sh.shoename,
               sh.sh_avail,
               sh.slcolor,
               sh.slminlen,
               sh.slminlen * un.un_fact AS slminlen_cm,
               sh.slmaxlen,
               sh.slmaxlen * un.un_fact AS slmaxlen_cm,
               sh.slunit
          FROM shoe_data sh, unit un
         WHERE sh.slunit = un.un_name;

    CREATE VIEW shoelace AS
        SELECT s.sl_name,
               s.sl_avail,
               s.sl_color,
               s.sl_len,
               s.sl_unit,
               s.sl_len * u.un_fact AS sl_len_cm
          FROM shoelace_data s, unit u
         WHERE s.sl_unit = u.un_name;

    CREATE VIEW shoe_ready AS
        SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM shoe rsh, shoelace rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm >= rsh.slminlen_cm
           AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
</ProgramListing>

    El comando CREATE VIEW para la vista <Filename>shoelace</Filename>
    (que es la más simple que tenemos) creará una relación shoelace y 
    una entrada en <FileName>pg_rewrite</FileName> que dice que hay una 
    regla de reescritura que debe ser aplicada siempre que la relación 
    shoelace sea referida en la tabla de rango de una query. La regla 
    no tiene cualificación de regla (discutidas en las reglas no SELECT, 
    puesto que las reglas SELECT no pueden tenerlas) y es de tipo INSTEAD 
    (en vez de). ¡Nótese que la cualificación de las reglas no son lo 
    mismo que las cualificación de las queries! La acción de las reglas 
    tiene una cualificación.
</Para>

<Para>
    La acción de las reglas es un árbol de query que es una copia exacta 
    de la instrucción SELECT en el comando de creación de la vista.
    
    <Note>
    <Title>Nota:</Title>
    <Para>
    Las dos tablas de rango extra para NEW y OLD (llamadas *NEW* y *CURRENT* 
    por razones históricas en el árbol de query escrito) que se pueden ver 
    en la entrada <Filename>pg_rewrite</Filename> no son de interes para las 
    reglas de SELECT.
    </Para>
    </Note>

    Ahora publicamos <Filename>unit</Filename>, <Filename>shoe_data</Filename>
    y <Filename>shoelace_data</Filename> y Al (el propietario de al_bundy) 
    teclea su primera SELECT en esta vida.

<ProgramListing>
    al_bundy=> INSERT INTO unit VALUES ('cm', 1.0);
    al_bundy=> INSERT INTO unit VALUES ('m', 100.0);
    al_bundy=> INSERT INTO unit VALUES ('inch', 2.54);
    al_bundy=> 
    al_bundy=> INSERT INTO shoe_data VALUES 
    al_bundy->     ('sh1', 2, 'black', 70.0, 90.0, 'cm');
    al_bundy=> INSERT INTO shoe_data VALUES 
    al_bundy->     ('sh2', 0, 'black', 30.0, 40.0, 'inch');
    al_bundy=> INSERT INTO shoe_data VALUES 
    al_bundy->     ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
    al_bundy=> INSERT INTO shoe_data VALUES 
    al_bundy->     ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
    al_bundy=> 
    al_bundy=> INSERT INTO shoelace_data VALUES 
    al_bundy->     ('sl1', 5, 'black', 80.0, 'cm');
    al_bundy=> INSERT INTO shoelace_data VALUES 
    al_bundy->     ('sl2', 6, 'black', 100.0, 'cm');
    al_bundy=> INSERT INTO shoelace_data VALUES 
    al_bundy->     ('sl3', 0, 'black', 35.0 , 'inch');
    al_bundy=> INSERT INTO shoelace_data VALUES 
    al_bundy->     ('sl4', 8, 'black', 40.0 , 'inch');
    al_bundy=> INSERT INTO shoelace_data VALUES 
    al_bundy->     ('sl5', 4, 'brown', 1.0 , 'm');
    al_bundy=> INSERT INTO shoelace_data VALUES 
    al_bundy->     ('sl6', 0, 'brown', 0.9 , 'm');
    al_bundy=> INSERT INTO shoelace_data VALUES 
    al_bundy->     ('sl7', 7, 'brown', 60 , 'cm');
    al_bundy=> INSERT INTO shoelace_data VALUES 
    al_bundy->     ('sl8', 1, 'brown', 40 , 'inch');
    al_bundy=> 
    al_bundy=> SELECT * FROM shoelace;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl1       |       5|black     |    80|cm      |       80
    sl2       |       6|black     |   100|cm      |      100
    sl7       |       7|brown     |    60|cm      |       60
    sl3       |       0|black     |    35|inch    |     88.9
    sl4       |       8|black     |    40|inch    |    101.6
    sl8       |       1|brown     |    40|inch    |    101.6
    sl5       |       4|brown     |     1|m       |      100
    sl6       |       0|brown     |   0.9|m       |       90
    (8 rows)
</ProgramListing>
    Esta es la SELECT más sencilla que Al puede hacer en sus vistas, 
    de modo que nosotros la tomaremos para explicar la base de las 
    reglas de las vistas. 'SELECT * FROM shoelace' fue interpretado 
    por el traductor y produjo un árbol de traducción.

<ProgramListing>
    SELECT shoelace.sl_name, shoelace.sl_avail,
           shoelace.sl_color, shoelace.sl_len,
           shoelace.sl_unit, shoelace.sl_len_cm
      FROM shoelace shoelace;
</ProgramListing>

    y este se le dá al sistema de reglas. El sistema de reglas viaja 
    a través de la tabla de rango, y comprueba si hay reglas en 
    <Filename>pg_rewrite</Filename> para alguna relación. Cuando se 
    procesa las entradas en la tabla de rango para 
    <Filename>shoelace</Filename> (el único hasta ahora) encuentra la regla 
    '_RETshoelace' con el árbol de traducción

<ProgramListing>
    <FirstTerm>SELECT s.sl_name, s.sl_avail,
           s.sl_color, s.sl_len, s.sl_unit,
           float8mul(s.sl_len, u.un_fact) AS sl_len_cm
      FROM shoelace *OLD*, shoelace *NEW*,
           shoelace_data s, unit u
     WHERE bpchareq(s.sl_unit, u.un_name);</FirstTerm>
</ProgramListing>

    Nótese que el traductor cambió el calculo y la cualificación en llamadas 
    a las funciones apropiadas. Pero de hecho esto no cambia nada. El primer 
    paso en la reescritura es mezclar las dos tablas de rango. El árbol de 
    traducción entonces lee

<ProgramListing>
    SELECT shoelace.sl_name, shoelace.sl_avail,
           shoelace.sl_color, shoelace.sl_len,
           shoelace.sl_unit, shoelace.sl_len_cm
      FROM shoelace shoelace, <FirstTerm>shoelace *OLD*</FirstTerm>,
           <FirstTerm>shoelace *NEW*</FirstTerm>, 
	   <FirstTerm>shoelace_data s</FirstTerm>,
           <FirstTerm>unit u</FirstTerm>;
</ProgramListing>

    En el paso 2, añade la cualificación de la acción de las reglas al árbol 
    de traducción resultante en

<ProgramListing>
    SELECT shoelace.sl_name, shoelace.sl_avail,
           shoelace.sl_color, shoelace.sl_len,
           shoelace.sl_unit, shoelace.sl_len_cm
      FROM shoelace shoelace, shoelace *OLD*,
           shoelace *NEW*, shoelace_data s,
           unit u
     <FirstTerm>WHERE bpchareq(s.sl_unit, u.un_name)</FirstTerm>;
</ProgramListing>

    Y en el paso 3, reemplaza todas las variables en el arbol de traducción, 
    que se refieren a entradas de la tabla de rango (la única que se está 
    procesando en este momento para <Filename>shoelace</Filename>) por 
    las correspondientes expresiones de la lista objetivo correspondiente
    a la acción de las reglas. El resultado es la query final:

<ProgramListing>
    SELECT <FirstTerm>s.sl_name</FirstTerm>, <FirstTerm>s.sl_avail</FirstTerm>,
           <FirstTerm>s.sl_color</FirstTerm>, <FirstTerm>s.sl_len</FirstTerm>, 
           <FirstTerm>s.sl_unit</FirstTerm>, 
	   <FirstTerm>float8mul(s.sl_len, u.un_fact)</FirstTerm> AS sl_len_cm
      FROM shoelace shoelace, shoelace *OLD*,
           shoelace *NEW*, shoelace_data s,
           unit u
     WHERE bpchareq(s.sl_unit, u.un_name);
</ProgramListing>

    Para realizar esta salida en una instrucción <Acronym>SQL</Acronym> 
    real, un usuario humano debería teclear:

<ProgramListing>
    SELECT s.sl_name, s.sl_avail,
           s.sl_color, s.sl_len,
           s.sl_unit, s.sl_len * u.un_fact AS sl_len_cm
      FROM shoelace_data s, unit u
     WHERE s.sl_unit = u.un_name;
</ProgramListing>

    Esta ha sido la primera regla aplicada. Mientras se iba haciendo esto, 
    la tabla de rango iba creciendo. De modo que el sistema de reglas 
    continúa comprobando las entradas de la tabla de rango. Lo siguiente 
    es el el número 2 (shoelace *OLD*). La Relación 
    <Filename>shoelace</Filename> tiene una regla, pero su entrada en la 
    tabla de rangos no está referenciada en ninguna de las variables del 
    árbol de traducción, de modo que se ingnora. Puesto que todas las 
    entradas restantes en la tabla de rango, o bien no tienen reglas en 
    <Filename>pg_rewrite</Filename> o bien no han sido referenciadas, se 
    alcanza el final de la tabla de rango. 
    La reescritura está completa y el resultado final dado se pasa al 
    optimizador. El optimizador ignora las entradas extra en la tabla de 
    rango que no están referenciadas por variables en el árbol de traducción, 
    y el plan producido por el planificador/optimizador debería ser exactamente
    el mismo que si Al hubiese tecleado la SELECT anterior en lugar de la 
    selección de la vista.
</Para>

<Para>
    Ahora enfrentamos a Al al problema de que los Blues Brothers aparecen en su
    tienda y quieren comprarse zapatos nuevos, y como son los Blues Brothers, 
    quieren llevar los mismos zapatos. Y los quieren llevar inmediatamente, 
    de modo que necesitan también cordones.
</Para>

<Para>
    Al necesita conocer los zapatos para los que tiene en el almacén cordones 
    en este momento (en color y en tamaño), y además para los que tenga un 
    número igual o superior a 2. Nosotros le enseñamos a realizar la consulta 
    a su base de datos:

<ProgramListing>
    al_bundy=> SELECT * FROM shoe_ready WHERE total_avail >= 2;
    shoename  |sh_avail|sl_name   |sl_avail|total_avail
    ----------+--------+----------+--------+-----------
    sh1       |       2|sl1       |       5|          2
    sh3       |       4|sl7       |       7|          4
    (2 rows)
</ProgramListing>
    
    Al es un guru de los zapatos, y sabe que sólo los zapatos de tipo sh1 le 
    sirven (los cordones sl7 son marrones, y los zapatos que necesitan cordones
    marrones no son los más adecuados para los Blues Brothers).
</Para>

<Para>
    La salida del traductor es esta vez el arbol de traducción.

<ProgramListing>
    SELECT shoe_ready.shoename, shoe_ready.sh_avail,
           shoe_ready.sl_name, shoe_ready.sl_avail,
           shoe_ready.total_avail
      FROM shoe_ready shoe_ready
     WHERE int4ge(shoe_ready.total_avail, 2);
</ProgramListing>

    Esa será la primera regla aplicada para la relación 
    <Filename>shoe_ready</Filename> y da como resultado el árbol 
    de traducción

<ProgramListing>
    SELECT <FirstTerm>rsh.shoename</FirstTerm>, 
           <FirstTerm>rsh.sh_avail</FirstTerm>,
           <FirstTerm>rsl.sl_name</FirstTerm>, 
	   <FirstTerm>rsl.sl_avail</FirstTerm>,
           <FirstTerm>min(rsh.sh_avail, rsl.sl_avail) AS 
	           total_avail</FirstTerm>
      FROM shoe_ready shoe_ready, <FirstTerm>shoe_ready *OLD*</FirstTerm>,
           <FirstTerm>shoe_ready *NEW*</FirstTerm>, 
	   <FirstTerm>shoe rsh</FirstTerm>,
           <FirstTerm>shoelace rsl</FirstTerm>
     WHERE int4ge(<FirstTerm>min(rsh.sh_avail, rsl.sl_avail)</FirstTerm>, 2)
       <FirstTerm>AND (bpchareq(rsl.sl_color, rsh.slcolor)
            AND float8ge(rsl.sl_len_cm, rsh.slminlen_cm)
            AND float8le(rsl.sl_len_cm, rsh.slmaxlen_cm)
           )</FirstTerm>;
</ProgramListing>

    En realidad, la clausula AND en la cualificación será un nodo de 
    operadores de tipo AND, con una expresión a la izquierda y otra 
    a la derecha. Pero eso la hace menos legible de lo que ya es, y 
    hay más reglas para aplicar. De modo que sólo las mostramos entre 
    paréntesis para agruparlos en unidades lógicas en el orden en que 
    se añaden, y continuamos con las reglas para la relación 
    <Filename>shoe</Filename> como está en la entrada de la tabla de 
    rango a la que se refiere, y tiene una regla. 
    El resultado de aplicarlo es

<ProgramListing>
    SELECT <FirstTerm>sh.shoename</FirstTerm>, 
           <FirstTerm>sh.sh_avail</FirstTerm>,
           rsl.sl_name, rsl.sl_avail,
           min(<FirstTerm>sh.sh_avail</FirstTerm>, rsl.sl_avail) 
	           AS total_avail,
      FROM shoe_ready shoe_ready, shoe_ready *OLD*,
           shoe_ready *NEW*, shoe rsh,
           shoelace rsl, <FirstTerm>shoe *OLD*</FirstTerm>,
           <FirstTerm>shoe *NEW*</FirstTerm>, 
	   <FirstTerm>shoe_data sh</FirstTerm>,
           <FirstTerm>unit un</FirstTerm>
     WHERE (int4ge(min(<FirstTerm>sh.sh_avail</FirstTerm>, rsl.sl_avail), 2)
            AND (bpchareq(rsl.sl_color, <FirstTerm>sh.slcolor</FirstTerm>)
                 AND float8ge(rsl.sl_len_cm, 
                    <FirstTerm>float8mul(sh.slminlen, un.un_fact)</FirstTerm>)
                 AND float8le(rsl.sl_len_cm, 
                    <FirstTerm>float8mul(sh.slmaxlen, un.un_fact)</FirstTerm>)
                )
           )
       <FirstTerm>AND bpchareq(sh.slunit, un.un_name)</FirstTerm>;
</ProgramListing>

    Y finalmente aplicamos la regla para <Filename>shoelace</Filename> 
    que ya conocemos bien (esta vez en un arbol de traducción que es 
    un poco más complicado) y obtenemos   

<ProgramListing>
    SELECT sh.shoename, sh.sh_avail,
           <FirstTerm>s.sl_name</FirstTerm>, <FirstTerm>s.sl_avail</FirstTerm>,
           min(sh.sh_avail, <FirstTerm>s.sl_avail</FirstTerm>) AS total_avail
      FROM shoe_ready shoe_ready, shoe_ready *OLD*,
           shoe_ready *NEW*, shoe rsh,
           shoelace rsl, shoe *OLD*,
           shoe *NEW*, shoe_data sh,
           unit un, <FirstTerm>shoelace *OLD*</FirstTerm>,
           <FirstTerm>shoelace *NEW*</FirstTerm>, 
	   <FirstTerm>shoelace_data s</FirstTerm>,
           <FirstTerm>unit u</FirstTerm>
     WHERE (  (int4ge(min(sh.sh_avail, <FirstTerm>s.sl_avail</FirstTerm>), 2)
       AND (bpchareq(<FirstTerm>s.sl_color</FirstTerm>, sh.slcolor)
           AND float8ge(<FirstTerm>float8mul(s.sl_len, u.un_fact)</FirstTerm>, 
                                   float8mul(sh.slminlen, un.un_fact))
           AND float8le(<FirstTerm>float8mul(s.sl_len, u.un_fact)</FirstTerm>, 
                                   float8mul(sh.slmaxlen, un.un_fact))
                     )
                )
            AND bpchareq(sh.slunit, un.un_name)
           )
       <FirstTerm>AND bpchareq(s.sl_unit, u.un_name)</FirstTerm>;
</ProgramListing>

    Lo reducimos otra vez a una instrucción <Acronym>SQL</Acronym> 
    real que sea equivalente en la salida final del sistema de reglas:

<ProgramListing>
    SELECT sh.shoename, sh.sh_avail,
           s.sl_name, s.sl_avail,
           min(sh.sh_avail, s.sl_avail) AS total_avail
      FROM shoe_data sh, shoelace_data s, unit u, unit un
     WHERE min(sh.sh_avail, s.sl_avail) >= 2
       AND s.sl_color = sh.slcolor
       AND s.sl_len * u.un_fact >= sh.slminlen * un.un_fact
       AND s.sl_len * u.un_fact <= sh.slmaxlen * un.un_fact
       AND sh.sl_unit = un.un_name
       AND s.sl_unit = u.un_name;
</ProgramListing>

    El procesado recursivo del sistema de reglas reescribió una 
    SELECT de una vista en un árbol de traducción que es equivalente 
    a exactamente lo que Al hubiese tecleado de no tener vistas.

    <Note>
    <Title>Nota</Title>
    <Para>
    Actualmente no hay mecanismos de parar la recursión para las 
    reglas de las vistas en el sistema de reglas (sólo para las 
    otras reglas). Esto no es muy grave, ya que la única forma de 
    meterlo en un bucle sin fin (bloqueando al cliente hasta que 
    lea el limite de memoria) es crear tablas y luego crearles reglas 
    a mano con CREATE RULE de forma que una lea a la otra y la otra 
    a la una. Esto no puede ocurrir con el comando CREATE VIEW, 
    porque en la primera creación de una vista la segunda aún no 
    existe, de modo que la primera vista no puede seleccionar 
    desde la segunda.
    </Para>
    </Note>
</Para>

</Sect2>

<Sect2>
<Title>Reglas de vistas en instrucciones diferentes a SELECT</Title>

<Para>
    Dos detalles del arbol de traducción no se han tocado en la 
    descripción de las reglas de vistas hasta ahora. Estos son 
    el tipo de comando (commandtype) y la relación resultado 
    (resultrelation). De hecho, las reglas de vistas no necesitan 
    estas informaciones.
</Para>

<Para>
    Hay sólo unas pocas diferencias entre un árbol de traducción 
    para una SELECT y uno para cualquier otro comando. Obviamente, 
    tienen otros tipos de comandos, y esta vez la relación resultado 
    apunta a la entrada de la tabla de rango donde irá el resultado. 
    Cualquier otra cosa es absolutamente igual. Por ello, teniendo dos 
    tablas t1 y t2, con atributos a y b, los árboles de traducción para 
    las dos instrucciones:

<ProgramListing>
    SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;

    UPDATE t1 SET b = t2.b WHERE t1.a = t2.a;
</ProgramListing>

    son prácticamente idénticos.

    <ItemizedList>
        <ListItem>
	<Para>
	    Las tablas de rango contienen entradas para las tablas t1 y t2.
	</Para>
        </ListItem>

        <ListItem>
	<Para>
	    Las listas objetivo continen una variable que apunta al 
	    atributo b de la entrada de la tabla rango para la tabla t2.
	</Para>
        </ListItem>

        <ListItem>
	<Para>
	    Las expresiones de cualificación comparan los atributos a 
	    de ambos rangos para la igualdad.
	</Para>
        </ListItem>
    </ItemizedList>

    La consecuencia es que ambos árboles de traducción dan lugar a 
    planes de ejecución similares. En ambas hay joins entre las dos 
    tablas. Para la UPDATE, las columnas que no aparecen de la tabla 
    t1 son añadidas a la lista objetivo por el optimizador, y el 
    árbol de traducción final se lee como: 

<ProgramListing>
    UPDATE t1 SET a = t1.a, b = t2.b WHERE t1.a = t2.a;
</ProgramListing>

    Y por ello el ejecutor al correr sobre la join producirá exactamente 
    el mismo juego de resultados que

<ProgramListing>
    SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;
</ProgramListing>
    
    Pero hay un pequeño problema con el UPDATE. El ejecutor no cuidará 
    de que el resultado de la join sea coherente. El sólo produce un 
    juego resultante de filas. La diferencia entre un comando SELECT 
    y un comando UPDATE la manipula el llamador (caller) del ejecutor. 
    El llamador sólo conoce (mirando en el árbol de traducción) que 
    esto es una UPDATE, y sabe que su resultado deberá ir a la tabla t1. 
    Pero ¿cuál de las 666 filas que hay debe ser reemplazada por la nueva 
    fila? El plan ejecutado es una join con una cualificación que 
    potencialmente podría producir cualquier número de filas entre 0 y 666 en 
    un número desconocido.
</Para>

<Para>
    Para resolver este problema, se añade otra entrada a la lista objetivo en 
    las instrucciones UPDATE y DELETE. Es el identificador de tupla actual 
    (current tuple id, ctid). Este es un atributo de sistema con 
    características especiales. Contiene el bloque y posición en el bloque para
    cada fila. Conociendo la tabla, el ctid puede utilizarse para encontrar una
    fila específica en una tabla de 1.5 GB que contiene millones de filas 
    atacando un único bloque de datos. Tras la adición del ctid a la lista 
    objetivo, el juego de resultados final se podría definir como

<ProgramListing>
    SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;
</ProgramListing>
    
    Entra ahora en funcionamiento otro detalle de 
    <ProductName>>Postgres</ProductName>. 
    Las filas de la tabla no son reescritas en este momento, y el por ello por 
    lo que ABORT TRANSACTION es muy rápido. En una Update, la nueva fila 
    resultante se inserta en la tabla (tras retirarle el ctid) y en la 
    cabecera de la tupla de la fila cuyo ctid apuntaba a las entradas 
    cmax y zmax, se fija el contador de comando actual y el identificador 
    de transaccion actual (ctid). De este modo, la fila anterior se oculta tras
    el commit de la transacción, y el limpiador vacuum puede realmente 
    eliminarla.
</Para>

<Para>
    Conociendo todo eso, podemos simplemente aplicar las reglas de las vistas 
    exactamente en la misma forma en cualquier comando. No hay diferencia.
</Para>
</Sect2>

<Sect2>
<Title>El poder de las vistas en <ProductName>Postgres</ProductName></Title>

<Para>
    Todo lo anterior demuestra como el sistema de reglas incorpora las 
    definiciones de las vistas en el árbol de traducción original. En el 
    segundo ejemplo, una simple SELECT de una vista creó un árbol de 
    traducción final que es una join de cuatro tablas (cada una se utiliza 
    dos veces con diferente nombre).
</Para>

<Sect3>
<Title>Beneficios</Title>

<Para>
    Los beneficios de implementar las vistas con el sistema de reglas 
    están en que el optimizados tiene toda la información sobre qué 
    tablas tienen que ser revisadas, más las relaciones entre estas tablas, 
    más las cualificaciones restrictivas a partir de la definición de las 
    vistas, más las cualificaciones de la query original, todo en un único 
    árbol de traducción. Y esta es también la situación cuando la query 
    original es ya una join entre vistas. Ahora el optimizador debe decidir 
    cuál es la mejor ruta para ejecutar la query. Cuanta más información tenga
    el optimizador, mejor será la decisión. Y la forma en que se implementa el
    sistema de reglas en <ProductName>Postgres</ProductName> asegura que toda 
    la información sobre la query está utilizable. 
</Para>
</Sect3>

<Sect3>
<Title>Puntos delicados a considerar</Title>

<Para>
    Hubo un tiempo en el que el sistema de reglas de 
    <ProductName>Postgres</ProductName> se consideraba agotado. El uso de 
    reglas no se recomendaba, y el único lugar en el que trabajaban era las 
    reglas de las vistas. E incluso estas reglas de las vistas daban problemas 
    porque el sistema de reglas no era capaz de aplicarse adecuadamente en más 
    instrucciones que en SELECT (por ejemplo, no trabajaría en una UPDATE que 
    utilice datos de una vista).
</Para>

<Para>
    Durante ese tiempo, el desarrollo se dirigió hacia muchas características 
    añadidas al traductor y al optimizador. El sistema de reglas fué quedando 
    cada vez más desactualizado en sus capacidades, y se volvió cada vez más 
    dificil de actualizar. Y por ello, nadie lo hizo.
</Para>

<Para>
    En 6.4, alguien cerró la puerta, respiró hondo, y se puso manos a la obra.
    El resultado fué el sistema de reglas cuyas capacidades se han descrito en
    este documento. Sin embargo, hay todavía algunas construcciones no 
    manejadas, y algunas fallan debido a cosas que no son soportadas por el 
    optimizador de queries de <ProductName>Postgres</ProductName>. 

    <ItemizedList>
        <ListItem>
	<Para>
	    Las vistas con columnas agregadas tienen malos problemas. Las 
	    expresiones agregadas en las cualificaciones deben utilizarse en 
	    subselects. Actualmente no es posible hacer una join de dos vistas 
	    en las que cada una de ellas tenga una columna agregada, y comparar
	    los dos valores agregados en a cualificación. Mientras tanto, es 
	    posible colocar estas expresiones agregadas en funciones con los 
	    argumentos apropiados y utilizarlas en la definición de las vistas.
  
	</Para>
        </ListItem>

        <ListItem>
	<Para>
            Las vistas de uniones no son soportadas. Ciertamente es sencillo 
	    reescribir una SELECT simple en una unión, pero es un poco más 
	    dificil si la vista es parte de una join que hace una UPDATE.
	</Para>
        </ListItem>

        <ListItem>
	<Para>
            Las clausulas ORDER BY en las definiciones de las vistas no están 
	    soportadas.
	</Para>
        </ListItem>

        <ListItem>
	<Para>
            DISTINCT no está soportada en las definiciones de vistas.
	</Para>
        </ListItem>
    </ItemizedList>

    No hay una buena razon por la que el optimizador no debiera manipular 
    construcciones de árboles de traducción que el traductor nunca podría 
    producir debido a las limitaciones de la sintaxis de 
    <Acronym>SQL</Acronym>. El autor se alegrará de que estas limitaciones 
    desaparezcan en el futuro.
</Para>
</Sect3>
</Sect2>

<Sect2>
<Title>Efectos colaterales de la implementación</Title>

<Para>
    La utilización del sistema de reglas descrito para implementar las vistas 
    tiene algunos efectos colaterales divertidos. Lo siguiente no parece 
    trabajar:

<ProgramListing>
    al_bundy=> INSERT INTO shoe (shoename, sh_avail, slcolor)
    al_bundy->     VALUES ('sh5', 0, 'black');
    INSERT 20128 1
    al_bundy=> SELECT shoename, sh_avail, slcolor FROM shoe_data;
    shoename  |sh_avail|slcolor   
    ----------+--------+----------
    sh1       |       2|black     
    sh3       |       4|brown     
    sh2       |       0|black     
    sh4       |       3|brown     
    (4 rows)
</ProgramListing>

    Lo interesante es que el código de retorno para la INSERT nos dió una 
    identificación de objeto, y nos dijo que se ha insertado una fila. Sin 
    embargo no aparece en <Filename>shoe_data</Filename>. Mirando en el 
    directorio de la base de datos, podemos ver que el fichero de la base de 
    datos para la relación de la vista <Filename>shoe</Filename> parece tener 
    ahora un bloque de datos. Y efectivamente es así.
</Para>

<Para>
    Podemos también intentar una DELETE, y si no tiene una cualificación, nos 
    dirá que las filas se han borrado y la siguiente ejecución de vacuum 
    limpiará el fichero hasta tamaño cero.
</Para>

<Para>
    La razon para este comportamiento es que el árbol de la traducción para la
    INSERT no hace referencia a la relación <Filename>shoe</Filename> en 
    ninguna variable. La lista objetivo contiene sólo valores constantes. Por 
    ello no hay reglas que aplicar y se mantiene sin cambiar hasta la 
    ejecución, insertandose la fila. Del mismo modo para la DELETE.
</Para>

<Para>
    Para cambiar esto, podemos definir reglas que modifiquen el comportamiento 
    de las queries no-SELECT. Este es el tema de la siguiente sección.
</Para>
</Sect2>

</Sect1>

<Sect1>
<Title>Reglas sobre INSERT, UPDATE y DELETE</Title>

<Sect2>
<Title>Diferencias con las reglas de las vistas.</Title>

<Para>
    Las reglas que se definien para ON INSERT, UPDATE y DELETE son totalmente 
    diferentes de las que se han descrito en la sección anterior para las 
    vistas. Primero, su comando CREATE RULE permite más:

    <ItemizedList>
        <ListItem>
	<Para>
            Pueden no tener acción.
	</Para>
	</ListItem>

        <ListItem>
	<Para>
	    Pueden tener múltiples acciones.
	</Para>
	</ListItem>

        <ListItem>
	<Para>
	    La palabra clave INSTEAD es opcional.
	</Para>
	</ListItem>

        <ListItem>
	<Para>
	    Las pseudo-relaciones NEW y OLD se vuelven utilizables.
	</Para>
	</ListItem>

        <ListItem>
	<Para>
	    Puede haber cualificaciones a las reglas.
	</Para>
	</ListItem>
    </ItemizedList>

    Segundo, no modifican el árbol de traducción en el sitio. En lugar de ello,
    crean cero o varios árboles de traducción nuevos y pueden desechar el 
    original.
</Para>
</sect2>
<Sect2>
<Title>Cómo trabajan estas reglas</Title>

<Para>
    Mantenga en mente la sintaxis

<ProgramListing>
    CREATE RULE rule_name AS ON event
        TO object [WHERE rule_qualification]
        DO [INSTEAD] [action | (actions) | NOTHING];
</ProgramListing>

    En lo que sigue, "las reglas de update" muestran reglas que están definidas
    ON INSERT, UPDATE o DELETE.
</Para>

<Para>
    Update toma las reglas aplicadas por el sistema de reglas cuando la 
    relación resultado y el tipo de comando de un árbol de traducción son 
    iguales al objeto y el acontecimiento dado en el comando CREATE RULE. Para 
    reglas de update, el sistema de reglas crea una lista de árboles de 
    traducción. Inicialmente la lista de árboles de traducción está vacía. 
    Puede haber cero (palabra clave NOTHING), una o múltiples acciones. Para 
    simplificar, veremos una regla con una acción. Esta regla puede tener una 
    cualificación o no y puede ser INSTEAD o no.
</Para>

<Para>
    ¿Qué es una cualificación de una regla? Es una restricción que se dice 
    cuándo las acciones de una regla se deberían realizar y cuándo no. Esta 
    cualficación sólo se puede referir a las pseudo-relaciones NEW y/o OLD, que
    básicamente son la relación dada como objeto (pero con unas características
    especiales).
</Para>

<Para>
    De este modo tenemos cuatro casos que producen los siguientes árboles de 
    traducción para una regla de una acción:
</Para>
<Para>
    <ItemizedList>
    <ListItem>
    <Para>
        Sin cualificación ni INSTEAD:
        <ItemizedList>
	    <ListItem>
	    <Para>
	        El árbol de traducción para la acción de la regla a la que se 
		ha añadido cualificación a los árboles de traducción 
		originales.
	    </Para>
	    </ListItem>
	</ItemizedList>
    </Para>
    </ListItem>

    <ListItem>
    <Para>
        Sin cualificación pero con INSTEAD:
        <ItemizedList>
	    <ListItem>
	    <Para>
	        El árbol de traducción para la acción de la regla a la que se 
		ha añadido cualificación a los árboles de traducción 
		originales.
	    </Para>
	    </ListItem>
	</ItemizedList>
    </Para>
    </ListItem>

    <ListItem>
    <Para>
        Se da cualificación y no se da INSTEAD:
        <ItemizedList>
	    <ListItem>
	    <Para>
	        El árbol de traducción de la acción de la regla, a la que se 
		han añadido la cualificación de la regla y la cualificación de
		los árboles de traducción originales.
	    </Para>
	    </ListItem>
	</ItemizedList>
    </Para>
    </ListItem>

    <ListItem>
    <Para>
        Se da cualificación y se da INSTEAD:
        <ItemizedList>
	    <ListItem>
	    <Para>
	        El árbol de traducción de la acción de la regla a la que se han
		añadido la cualificación de la regla y la cualificación de los 
		árboles de traducción originales.
	    </Para>
	    </ListItem>

	    <ListItem>
	    <Para>
	        El árbol de traducción original al que se le ha añadido la 
		cualificación de la regla negada. 
	    </Para>
	    </ListItem>
	</ItemizedList>
    </Para>
    </ListItem>
    </ItemizedList>
</para>
<Para>
    Finalmente, si la regla no es INSTEAD, el árbol de traducción original sin 
    cambiar se añade a la lista. Puesto que sólo las reglas INSTEAD 
    cualificadas se añaden al árbol de traducción original, terminamos con un 
    máximo total de dos árboles de traducción para una regla con una acción.
</Para>

<Para>
    Los árboles de traducción generados a partir de las acciones de las reglas 
    se colocan en el sistema de reescritura de nuevo, y puede ser que otras 
    reglas aplicadas resulten en más o menos árboles de traducción.
    De este modo, los árboles de traducción de las acciones de las reglas 
    deberían tener bien otro tipo de comando, bien otra relación resultado. De 
    otro modo, este proceso recursivo terminaría en un bucle. Hay un límite de 
    recursiones compiladas actualmente de 10 iteraciones. Si tras 10 
    iteraciones aún sigue habiendo reglas de update para aplicar, el sistema de
    reglas asumirá que se ha producido un bucle entre muchas definiciones de 
    reglas y aborta la transacción.
</Para>

<Para>
    Los árboles de traducción encontrados en las acciones del catálogo de 
    sistema <Filename>pg_rewrite</Filename> son sólo plantillas. Una vez que 
    ellos pueden hacer referencia a las entradas de tabla de rango para NEW u 
    OLD, algunas sustituciones habrán sido hechas antes de ser utilizadas. Para
    cualquier referencia a NEW, la lista objetivo de la query original se 
    revisa busando una entrada correspondiente. si se encuentra, esas entradas 
    de la expresión se sitúan en la referencia. De otro modo, NEW se mantiene 
    igual que OLD. Cualquier referencia a OLD se reemplaza por una referencia a
    la entrada de la tabla de rango que es la relación resultado.
</Para>

<Sect3>
<Title>Una primera regla paso a paso.</Title>

<Para>
    Queremos tracear los cambios en la columna sl_avail de la relación 
    <Filename>shoelace_data</Filename>. Para ello, crearemos una tabla de log,
    y una regla que escriba las entradas cada vez que se realice una UPDATE 
    sobre <Filename>shoelace_data</Filename>.

<ProgramListing>
    CREATE TABLE shoelace_log (
        sl_name    char(10),      -- shoelace changed
        sl_avail   integer,       -- new available value
        log_who    name,          -- who did it
        log_when   datetime       -- when
    );

    CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
        WHERE NEW.sl_avail != OLD.sl_avail
        DO INSERT INTO shoelace_log VALUES (
                                        NEW.sl_name,
                                        NEW.sl_avail,
                                        getpgusername(),
                                        'now'::text
                                    );
</ProgramListing>

    Un detalle interesante es la caracterización de 'now' en la reglas de la 
    acción INSERT para teclear texto. Sin ello, el traductor vería en el 
    momento del CREATE RULE, que el tipo objetivo en 
    <Filename>shoelace_log</Filename> es un dato de tipo fecha, e intenta hacer
    una constante de él... con éxito. De ese modo, se almacenaría un valor 
    constante en la acción de la regla y todas las entradas del log tendrían la
    hora de la instrucción CREATE RULE. No es eso exactamente lo que queremos. 
    La caracterización lleva al traductor a construir un "fecha-hora" que será 
    evaluada en el momento de la ejecución (datetime('now'::text)).
</Para>

<Para>
    Ahora Al hace

<ProgramListing>
    al_bundy=> UPDATE shoelace_data SET sl_avail = 6                       
    al_bundy->     WHERE sl_name = 'sl7';
</ProgramListing>

    y nosotros miramos en la tabla de log.  

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace_log;
    sl_name   |sl_avail|log_who|log_when                        
    ----------+--------+-------+--------------------------------
    sl7       |       6|Al     |Tue Oct 20 16:14:45 1998 MET DST
    (1 row)
</ProgramListing>

    Que es justo lo que nosotros esperábamos. Veamos qué ha ocurrido en la 
    sombra. El traductor creó un árbol de traducción (esta vez la parte del 
    árbol de traducción original está resaltado porque la base de las operación
    es es la acción de la regla para las reglas de update)

<ProgramListing>
    <FirstTerm>UPDATE shoelace_data SET sl_avail = 6
      FROM shoelace_data shoelace_data
     WHERE bpchareq(shoelace_data.sl_name, 'sl7');</FirstTerm>
</ProgramListing>

    Hay una regla para 'log_shoelace' que es ON UPDATE con la expresión de 
    cualificación de la regla:

<ProgramListing>
    int4ne(NEW.sl_avail, OLD.sl_avail)
</ProgramListing>

    y una acción

<ProgramListing>
    INSERT INTO shoelace_log SELECT 
           *NEW*.sl_name, *NEW*.sl_avail,
           getpgusername(), datetime('now'::text)
      FROM shoelace_data *NEW*, shoelace_data *OLD*,
           shoelace_log shoelace_log;
</ProgramListing>

    No detallaremos la salida de la vista del sistema pg_rules. Especialmente 
    manipula la siutación de que aquí sólo se haga referencia a NEW y OLD en la
    INSERT, y las salidas del formato de VALUES de INSERT. De hecho, no hay 
    diferencia entre una INSERT ... VALUES y una INSERT ... SELECT al nivel del
    árbol de traducción. Ambos tienen tablas de rango, listas objetivo, pueden 
    tener cualificación, etc. El optimizador decide más tarde si crear un plan 
    de ejecución de tio resultado, barrido secuencial, barrido de índice, join 
    o cualquier otro para ese árbol de traducción. Si no hay referencias en 
    entradas de la tabla de rango previas al árbol de traducción, éste se 
    convierte en un plan de ejecución (la versión INSERT ... VALUES). La acción
    de las reglas anterior puede ciertamente resultar en ambas variantes.
</Para>

<Para>
    La regla es una regla no-INSTEAD cualificada, de modo que el sistema de 
    reglas deberá devolver dos árboles de traducción. La acción de la regla 
    modificada y el árbol de traducción original. En el primer paso, la tabla 
    de rango de la query original está incorporada al árbol de traducción de la
    acción de las reglas. Esto da como resultado

<ProgramListing>
    INSERT INTO shoelace_log SELECT 
           *NEW*.sl_name, *NEW*.sl_avai,
           getpgusername(), datetime('now'::text)
      FROM <FirstTerm>shoelace_data shoelace_data</FirstTerm>, 
           shoelace_data *NEW*,
           shoelace_data *OLD*, 
	   shoelace_log shoelace_log;
</ProgramListing>

    En el segundo paso, se añade la cualificación de la regla, de modo que el 
    resultado se restringe a las filas en las que sl_avail cambie.

<ProgramListing>
    INSERT INTO shoelace_log SELECT 
           *NEW*.sl_name, *NEW*.sl_avai,
           getpgusername(), datetime('now'::text)
      FROM shoelace_data shoelace_data, shoelace_data *NEW*,
           shoelace_data *OLD*, shoelace_log shoelace_log
     <FirstTerm>WHERE int4ne(*NEW*.sl_avail, *OLD*.sl_avail)</FirstTerm>;
</ProgramListing>

    En el tercer paso, se añade la cualificación de los árboles de traducción 
    originales, restringiendo el juego de resultados más aún, a sólo las filas 
    tocadas por el árbol de traducción original.

<ProgramListing>
    INSERT INTO shoelace_log SELECT 
           *NEW*.sl_name, *NEW*.sl_avai,
           getpgusername(), datetime('now'::text)
      FROM shoelace_data shoelace_data, shoelace_data *NEW*,
           shoelace_data *OLD*, shoelace_log shoelace_log
     WHERE int4ne(*NEW*.sl_avail, *OLD*.sl_avail)
       <FirstTerm>AND bpchareq(shoelace_data.sl_name, 'sl7')</FirstTerm>;
</ProgramListing>

    En el paso cuatro se sustituyen las referencias NEW por las entradas de la 
    lista objetivo del árbol de traducción original o con las referencias a 
    variables correspondientes de la relación resultado.

<ProgramListing>
    INSERT INTO shoelace_log SELECT 
           <FirstTerm>shoelace_data.sl_name</FirstTerm>, 
	   <FirstTerm>6</FirstTerm>,
           getpgusername(), datetime('now'::text)
      FROM shoelace_data shoelace_data, shoelace_data *NEW*,
           shoelace_data *OLD*, shoelace_log shoelace_log
     WHERE int4ne(<FirstTerm>6</FirstTerm>, *OLD*.sl_avail)
       AND bpchareq(shoelace_data.sl_name, 'sl7');
</ProgramListing>

    El paso 5 reemplaza las referencias OLD por referencias en la relación 
    resultado.

<ProgramListing>
    INSERT INTO shoelace_log SELECT 
           shoelace_data.sl_name, 6,
           getpgusername(), datetime('now'::text)
      FROM shoelace_data shoelace_data, shoelace_data *NEW*,
           shoelace_data *OLD*, shoelace_log shoelace_log
     WHERE int4ne(6, <FirstTerm>shoelace_data.sl_avail</FirstTerm>)
       AND bpchareq(shoelace_data.sl_name, 'sl7');
</ProgramListing>

    Y esto es. De modo que la máxima reducción de la salida del sistema de 
    reglas es una lista de dos árboles de traducción que son lo mismo que las 
    instrucciones:

<ProgramListing>
    INSERT INTO shoelace_log SELECT
           shoelace_data.sl_name, 6,
           getpgusername(), 'now'
      FROM shoelace_data
     WHERE 6 != shoelace_data.sl_avail
       AND shoelace_data.sl_name = 'sl7';

    UPDATE shoelace_data SET sl_avail = 6
     WHERE sl_name = 'sl7';
</ProgramListing>

    Estas con ejecutadas en este orden y eso es exactamente lo que la regla 
    define. Las sustituciones y las cualificaciones añadidas aseguran que si la
    query original fuese una

<ProgramListing>
    UPDATE shoelace_data SET sl_color = 'green'
     WHERE sl_name = 'sl7';
</ProgramListing>

    no se habría escrito ninguna entrada en la tabla de log, ya que esta vez el
    árbol de traducción original no contiene una entrada de la lista objetivo 
    para sl_avail, de modo que NEW.sl_avail será reemplazada por 
    shoelace_data.sl_avail resultando en la query adicional

<ProgramListing>
    INSERT INTO shoelace_log SELECT
           shoelace_data.sl_name, 
	   <FirstTerm>shoelace_data.sl_avail</FirstTerm>,
           getpgusername(), 'now'
      FROM shoelace_data
     WHERE <FirstTerm>shoelace_data.sl_avail</FirstTerm> != 
           shoelace_data.sl_avail
       AND shoelace_data.sl_name = 'sl7';
</ProgramListing>

    cuya cualificación nunca será cierta. Una vez que no hay diferencias a 
    nivel de árbol de traducción entre una INSERT ... SELECT, y una INSERT ... 
    VALUES, trabajará también si la query original modificaba multiples 
    columnas. De modo que si Al hubiese pedido el comando

<ProgramListing>
    UPDATE shoelace_data SET sl_avail = 0
     WHERE sl_color = 'black';
</ProgramListing>

    serán actualizadas cuatro filas (sl1, sl2, sl3 y sl4). Pero sl3 ya tiene 
    sl_avail = 0. Esta vez, la cualificación de los árboles de traducción 
    originales es diferente y como resultado tenemos el árbol de traducción 
    adicional

<ProgramListing>
    INSERT INTO shoelace_log SELECT
           shoelace_data.sl_name, 0,
           getpgusername(), 'now'
      FROM shoelace_data
     WHERE 0 != shoelace_data.sl_avail
       AND <FirstTerm>shoelace_data.sl_color = 'black'</FirstTerm>;
</ProgramListing>

    Este árbol de traducción seguramente insertará tres nuevas entradas de la 
    tabla de log. Y eso es absolútamente correcto.
</Para>

<Para>
    Es importante recordar que el árbol de traducción original se ejecuta el 
    último. El "agente de tráfico" de <ProductName>Postgres</ProductName> 
    incrementa el contador de comandos entre la ejecución de los dos árboles de
    traducción, de modo que el segundo puede ver cambios realizados por el 
    primero. Si la UPDATE hubiera sido ejecutada primero, todas las filas 
    estarían ya a 0, de modo que la INSERT del logging no habría encontrado 
    ninguna fila para las que shoelace_data.sl_avail != 0: no habría dejado 
    ningún rastro.
</Para>
</Sect3>

</Sect2>

<Sect2>
<Title>Cooperación con las vistas</Title>

<Para>
    Una forma sencilla de proteger las relaciones vista de la mencionada 
    posibilidad de que alguien pueda INSERT, UPDATE y DELETE datos invisibles 
    es permitir a sus árboles de traducción recorrerlas de nuevo. 
    Creamos las reglas

<ProgramListing>
    CREATE RULE shoe_ins_protect AS ON INSERT TO shoe
        DO INSTEAD NOTHING;
    CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe
        DO INSTEAD NOTHING;
    CREATE RULE shoe_del_protect AS ON DELETE TO shoe
        DO INSTEAD NOTHING;
</ProgramListing>

    Si Al ahora intenta hacer cualquiera de estas operaciones en la relación 
    vista <Filename>shoe</Filename>, el sistema de reglas aplicará las reglas.
    Una vez que las reglas no tiene acciones y son INSTEAD, la lista resultante
    de árboles de traducción estará vacía, y la query no devolverá nada, debido
    a que no hay nada para ser optimizado o ejecutado tras la actuación del 
    sistema de reglas.

    <Note>
    <Title>Nota</Title>
    <Para>
    Este hecho debería irritar a las aplicaciones cliente, ya que no ocurre 
    absolútamente nada en la base de datos, y por ello, el servidor no devuelve
    nada para la query. Ni siquiera un PGRES_EMPTY_QUERY o similar será 
    utilizable en libpq. En psql, no ocurre nada. Esto debería cambiar en el 
    futuro.
    </Para>
    </Note>

</Para>

<Para>
    Una forma más sofisticada de utilizar el sistema de reglas es crear reglas 
    que reescriban el árbol de traducción en uno que haga la operación correcta
    en las tablas reales. Para hacer esto en la vista 
    <Filename>shoelace</Filename>, crearemos las siguientes reglas: 

<ProgramListing>
    CREATE RULE shoelace_ins AS ON INSERT TO shoelace
        DO INSTEAD
        INSERT INTO shoelace_data VALUES (
               NEW.sl_name,
               NEW.sl_avail,
               NEW.sl_color,
               NEW.sl_len,
               NEW.sl_unit);

    CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
        DO INSTEAD
        UPDATE shoelace_data SET
               sl_name = NEW.sl_name,
               sl_avail = NEW.sl_avail,
               sl_color = NEW.sl_color,
               sl_len = NEW.sl_len,
               sl_unit = NEW.sl_unit
         WHERE sl_name = OLD.sl_name;

    CREATE RULE shoelace_del AS ON DELETE TO shoelace
        DO INSTEAD
        DELETE FROM shoelace_data
         WHERE sl_name = OLD.sl_name;
</ProgramListing>

    Ahora llega un paquete de cordones de zapatos a la tienda de Al, y el tiene
    una gran lista de artículos. Al no es particularmente bueno haciendo 
    cálculos, y no lo queremos actualizando manualmente la vista shoelace. En 
    su lugar, creamos dos tablas pequeñas, una donde él pueda insertar los 
    datos de la lista de artículos, y otra con un truco especial. 
    Los comandos CREATE completos son:

<ProgramListing>
    CREATE TABLE shoelace_arrive (
        arr_name    char(10),
        arr_quant   integer
    );

    CREATE TABLE shoelace_ok (
        ok_name     char(10),
        ok_quant    integer
    );

    CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
        DO INSTEAD
        UPDATE shoelace SET
               sl_avail = sl_avail + NEW.ok_quant
         WHERE sl_name = NEW.ok_name;
</ProgramListing>

    ahora Al puede sentarse y hacer algo como:

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace_arrive;
    arr_name  |arr_quant
    ----------+---------
    sl3       |       10
    sl6       |       20
    sl8       |       20
    (3 rows)
</ProgramListing>

    Que es exactametne lo que había en la lista de artículos. Daremos una 
    rápida mirada en los datos actuales.
    
<ProgramListing>
    al_bundy=> SELECT * FROM shoelace ORDER BY sl_name;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl1       |       5|black     |    80|cm      |       80
    sl2       |       6|black     |   100|cm      |      100
    sl7       |       6|brown     |    60|cm      |       60
    sl3       |       0|black     |    35|inch    |     88.9
    sl4       |       8|black     |    40|inch    |    101.6
    sl8       |       1|brown     |    40|inch    |    101.6
    sl5       |       4|brown     |     1|m       |      100
    sl6       |       0|brown     |   0.9|m       |       90
    (8 rows)
</ProgramListing>

    trasladamos los cordones recien llegados:

<ProgramListing>
    al_bundy=> INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;
</ProgramListing>

    y comprobamos los resultados:

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace ORDER BY sl_name;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl1       |       5|black     |    80|cm      |       80
    sl2       |       6|black     |   100|cm      |      100
    sl7       |       6|brown     |    60|cm      |       60
    sl4       |       8|black     |    40|inch    |    101.6
    sl3       |      10|black     |    35|inch    |     88.9
    sl8       |      21|brown     |    40|inch    |    101.6
    sl5       |       4|brown     |     1|m       |      100
    sl6       |      20|brown     |   0.9|m       |       90
    (8 rows)

    al_bundy=> SELECT * FROM shoelace_log;
    sl_name   |sl_avail|log_who|log_when                        
    ----------+--------+-------+--------------------------------
    sl7       |       6|Al     |Tue Oct 20 19:14:45 1998 MET DST
    sl3       |      10|Al     |Tue Oct 20 19:25:16 1998 MET DST
    sl6       |      20|Al     |Tue Oct 20 19:25:16 1998 MET DST
    sl8       |      21|Al     |Tue Oct 20 19:25:16 1998 MET DST
    (4 rows)
</ProgramListing>

    Esta es una larga vía desde la primera INSERT ... SELECT a estos 
    resultados. Y su descripción será la última en este documento (pero no el 
    último ejemplo :-). Primero estaba la salida de los traductores:

<ProgramListing>
    INSERT INTO shoelace_ok SELECT
           shoelace_arrive.arr_name, shoelace_arrive.arr_quant
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;
</ProgramListing>

    Ahora se aplica la primera regla 'shoelace_ok_in' y se vuelve:

<ProgramListing>
    UPDATE shoelace SET
           sl_avail = int4pl(shoelace.sl_avail, shoelace_arrive.arr_quant)
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
           shoelace_ok *OLD*, shoelace_ok *NEW*,
           shoelace shoelace
     WHERE bpchareq(shoelace.sl_name, showlace_arrive.arr_name);
</ProgramListing>

    y lanza otra vez la INSERT original sobre <Filename>shoelace_ok</Filename>.
    Esta query reescrita se pasa al sistema de reglas de nuevo, y la aplicación
    de la segunda regla 'shoelace_upd' produce

<ProgramListing>
    UPDATE shoelace_data SET
           sl_name = shoelace.sl_name,
           sl_avail = int4pl(shoelace.sl_avail, shoelace_arrive.arr_quant),
           sl_color = shoelace.sl_color,
           sl_len = shoelace.sl_len,
           sl_unit = shoelace.sl_unit
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
           shoelace_ok *OLD*, shoelace_ok *NEW*,
           shoelace shoelace, shoelace *OLD*,
           shoelace *NEW*, shoelace_data showlace_data
     WHERE bpchareq(shoelace.sl_name, showlace_arrive.arr_name)
       AND bpchareq(shoelace_data.sl_name, shoelace.sl_name);
</ProgramListing>

    Otra vez es una regla INSTEAD, y el árbol de traducción anterior se 
    deshecha. Nótese que esta query aún utiliza la vista 
    <Filename>shoelace</Filename>. Pero el sistema de reglas no ha terminado 
    con esta vuelta, de modo que continúa y aplica la regla '_RETshoelace', 
    produciendo

<ProgramListing>
    UPDATE shoelace_data SET
           sl_name = s.sl_name,
           sl_avail = int4pl(s.sl_avail, shoelace_arrive.arr_quant),
           sl_color = s.sl_color,
           sl_len = s.sl_len,
           sl_unit = s.sl_unit
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
           shoelace_ok *OLD*, shoelace_ok *NEW*,
           shoelace shoelace, shoelace *OLD*,
           shoelace *NEW*, shoelace_data showlace_data,
           shoelace *OLD*, shoelace *NEW*,
           shoelace_data s, unit u
     WHERE bpchareq(s.sl_name, showlace_arrive.arr_name)
       AND bpchareq(shoelace_data.sl_name, s.sl_name);
</ProgramListing>

    De nuevo se ha aplicado una regla de update y por ello vuelve a girar la 
    rueda, y llegamos a la ronda de reescritura número 3. Esta vez, se aplica 
    la regla 'log_shoelace', que produce el árbol de traducción extra

<ProgramListing>
    INSERT INTO shoelace_log SELECT
           s.sl_name,
           int4pl(s.sl_avail, shoelace_arrive.arr_quant),
           getpgusername(),
           datetime('now'::text)
      FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
           shoelace_ok *OLD*, shoelace_ok *NEW*,
           shoelace shoelace, shoelace *OLD*,
           shoelace *NEW*, shoelace_data showlace_data,
           shoelace *OLD*, shoelace *NEW*,
           shoelace_data s, unit u,
           shoelace_data *OLD*, shoelace_data *NEW*
           shoelace_log shoelace_log
     WHERE bpchareq(s.sl_name,  showlace_arrive.arr_name)
       AND bpchareq(shoelace_data.sl_name, s.sl_name);
       AND int4ne(int4pl(s.sl_avail, shoelace_arrive.arr_quant),
                                                    s.sl_avail);
</ProgramListing>
    
    Tras de lo cual, el sistema de reglas se desconecta y devuelve los árboles 
    de traducción generados. De esta forma, terminamos con dos árboles de 
    traducción finales que son iguales a las instrucciones de 
    <Acronym>SQL</Acronym>

<ProgramListing>
    INSERT INTO shoelace_log SELECT
           s.sl_name,
           s.sl_avail + shoelace_arrive.arr_quant,
           getpgusername(),
           'now'
      FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,
           shoelace_data s
     WHERE s.sl_name = shoelace_arrive.arr_name
       AND shoelace_data.sl_name = s.sl_name
       AND s.sl_avail + shoelace_arrive.arr_quant != s.sl_avail;
           
    UPDATE shoelace_data SET
           sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant
     FROM shoelace_arrive shoelace_arrive,
          shoelace_data shoelace_data,
          shoelace_data s
    WHERE s.sl_name = shoelace_arrive.sl_name
      AND shoelace_data.sl_name = s.sl_name;
</ProgramListing>

    El resultado es que los datos vienen de una relación, se insertan en otra, 
    cambian por actualizaciones una tercera, cambian por actualizaciones una 
    cuarta, más registran esa actualización final en una quinta: todo eso se 
    reduce a dos queries.
</Para>

<Para>
    Hay un pequeño detalle un tanto desagradable. Mirando en las dos queries, 
    descrubrimos que la relación <Filename>shoelace_data</Filename> aparece dos
    veces en la tabla de rango, lo que se debería reducir a una sóla. 
    El optimizador no manipula esto, y por ello el plan de ejecución para la 
    salida del sistema de reglas de la INSERT será

<ProgramListing>
Nested Loop
  ->  Merge Join
        ->  Seq Scan
              ->  Sort
                    ->  Seq Scan on s
        ->  Seq Scan
              ->  Sort
                    ->  Seq Scan on shoelace_arrive
  ->  Seq Scan on shoelace_data
</ProgramListing>

    mientras que omitiendo la entrada extra a la tabla de rango debería ser

<ProgramListing>
Merge Join
  ->  Seq Scan
        ->  Sort
              ->  Seq Scan on s
  ->  Seq Scan
        ->  Sort
              ->  Seq Scan on shoelace_arrive
</ProgramListing>

    que produce exactamente las mismas entradas en la relación de log. Es 
    decir, el sistema de reglás ha probocado un barrido extra de la relación 
    <Filename>shoelace_data</Filename> absolútamente innecesario. Y el mismo 
    barrido obsoleto se produce de nuevo en la UPDATE. Pero era un trabajo 
    realmente duro hacer que todo sea posible.
</Para>

<Para>
    Una demostración final del sistema de reglas de 
    <ProductName>Postgres</ProductName> y de su poder. Hay una astuta rubia que
    vende cordones de zapatos. Y lo que Al nunca hubiese imaginado, ella no es
    sólo astuta, también es elegante, un poco demasiado elegante. Por ello, 
    ella se empeña de tiempo en tiempo en que Al pida cordones que son 
    absolútamente invendibles. Esta vez ha pedido 1000 pares de cordones 
    magenta, y aunque ahora no es posible adquirir otro color, como él se 
    comprometió a comprar algo, prepara su base de datos para cordones rosa.

<ProgramListing>
    al_bundy=> INSERT INTO shoelace VALUES 
    al_bundy->     ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
    al_bundy=> INSERT INTO shoelace VALUES 
    al_bundy->     ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
</ProgramListing>

    Ahora quiere revisar los cordones que no casan con ningún par de zapatos. 
    El podría realizar una complicada query cada vez, o bien le podemos 
    preparar una vista al efecto: 

<ProgramListing>
    CREATE VIEW shoelace_obsolete AS
        SELECT * FROM shoelace WHERE NOT EXISTS
            (SELECT shoename FROM shoe WHERE slcolor = sl_color);
</ProgramListing>

    cuya salida es

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace_obsolete;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl9       |       0|pink      |    35|inch    |     88.9
    sl10      |    1000|magenta   |    40|inch    |    101.6
</ProgramListing>

    Sobre los 1000 cordones magenta, deberíamos avisar a Al antes de que 
    podamos hacerlo de nuevo, pero ese es otro problema. La entrada rosa, la 
    borramos. Para hacerlo un poco más dificil para 
    <ProductName>Postgres</ProductName>, no la borramos directamente. En su 
    lugar, crearemos una nueva vista

<ProgramListing>
    CREATE VIEW shoelace_candelete AS
        SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
</ProgramListing>

    Y lo haremos de esta forma:

<ProgramListing>
    DELETE FROM shoelace WHERE EXISTS
        (SELECT * FROM shoelace_candelete
                 WHERE sl_name = shoelace.sl_name);
</ProgramListing>

    Voila:

<ProgramListing>
    al_bundy=> SELECT * FROM shoelace;
    sl_name   |sl_avail|sl_color  |sl_len|sl_unit |sl_len_cm
    ----------+--------+----------+------+--------+---------
    sl1       |       5|black     |    80|cm      |       80
    sl2       |       6|black     |   100|cm      |      100
    sl7       |       6|brown     |    60|cm      |       60
    sl4       |       8|black     |    40|inch    |    101.6
    sl3       |      10|black     |    35|inch    |     88.9
    sl8       |      21|brown     |    40|inch    |    101.6
    sl10      |    1000|magenta   |    40|inch    |    101.6
    sl5       |       4|brown     |     1|m       |      100
    sl6       |      20|brown     |   0.9|m       |       90
    (9 rows)
</ProgramListing>

    Una DELETE en una vista, con una subselect como cualificación, que en total
    utiliza 4 vistas anidadas/cruzadas, donde una de ellas mismas tiene una 
    subselect de cualificación conteniendo una vista y donde se utilizan 
    columnas calculadas queda reescrita en un único árbol de traducción que 
    borra los datos requeridos de una tabla real.
</Para>

<Para>
    Pienso que hay muy pocas ocasiones en el mundo real en las que se una 
    construcción similar sea necesaria. Pero me tranquiliza un poco que esto 
    funcione.

    <Note>
    <Title>La verdad es</Title>
    <Para>
    Haciendo esto encontré otro bug mientras escribía este documento. Pero 
    tras fijarlo comprobé un poco avergonzado que trabajaba correctamente.
    </Para>
    </Note>
</Para>
</Sect2>

</Sect1>

<Sect1>
<Title>Reglas y permisos</Title>

<Para>
    Debido a la reescritura de las queries por el sistema de reglas de 
    <ProductName>Postgre</ProductName>, se han accedido a otras tablas/vistas 
    diferentes de las de la query original. Utilizando las reglas de update, 
    esto puede incluir acceso en escritura a tablas.
</Para>

<Para>
    Las reglas de reescritura no tienen un propietario diferenciado. El 
    propietario de una relación (tabla o vista) es automáticamente el 
    propietario de las reglas de reescritura definidas para ella. El sistema de
    reglas de <ProductName>Postgres</ProductName> cambia el comportamiento del 
    sistema de control de acceso de defecto. Las relaciones que se utilizan 
    debido a las reglas son comprobadas durante la reescritura contralos 
    permisos del propietario de la relación, contra la que la regla se ha 
    definido. Esto hace que el usuario no necesite sólo permisos para las 
    tablas/vistas a las que él hace referencia en sus queries.
</Para>

<Para>
    Por ejemplo: Un usuario tiene una lista de números de teléfono en la que 
    algunos son privados y otros son de interés para la secretaria en la 
    oficina. Él puede construir lo siguiente:

<ProgramListing>
    CREATE TABLE phone_data (person text, phone text, private bool);
    CREATE VIEW phone_number AS
        SELECT person, phone FROM phone_data WHERE NOT private;
    GRANT SELECT ON phone_number TO secretary;
</ProgramListing>
    
    Nadie excepto él, y el superusuario de la base de datos, pueden acceder a 
    la tabla phone_data. Pero debido a la GRANT, la secretaria puede SELECT a 
    través de la vista phone_numbre. El sistema de reglas reescribirá la SELECT
    de phone_numbre en una SELECT de phone_data y añade la cualificación de que
    sólo se buscan las entradas cuyo "privado" sea falso. Una vez que el 
    usuario sea el propietario de phone_numbre, la lectura accede a phone_data 
    se comprueba contra sus permisos, y la query se considera autorizada. La 
    comprobación para acceder a phone_number se realiza entonces, de modo que 
    nadie más que la secretaria pueda utilizarlo.
</Para>

<Para>
    Los permisos son comprobados regla a regla. De modo que la secretaria es 
    ahora la única que puede ver los números de teléfono públicos. Pero la 
    secretaria puede crear otra vista y autorizar el acceso a ella al público. 
    Entonces, cualquiera puede ver los datos de phone_numbre a través de la 
    vista de la secretaria. Lo que la secretaria no puede hacer es crear una 
    vista que acceda directamente a phone_data (realmente si puede, pero no 
    trabajará, puesto que cada acceso abortará la transacción durante la 
    comprobación de los permisos). Y tan pronto como el usuario tenga noticia 
    de que la secretaria ha abierto su vista a phone_numbre, el puede REVOKE su
    acceso. Inmediatamente después, cualquier acceso a la vista de las 
    secretarias fallará.
</Para>

<Para>
    Alguien podría pensar que este chequeo regla a regla es un agujero de 
    seguridad, pero de hecho no lo es. Si esto no trabajase, la secretaria 
    podría generar una tabla con las mismas columnas de phone_number y copiar 
    los datos aquí todos los días. En este caso serían ya sus propios datos, y 
    podría autorizar el acceso a cualquiera que ella quisiera. Un GRANT quiere 
    decir "Yo Confío en Tí". Si alguien en quien confiamos hace lo anterior, es
    el momento de volver sobre nuestros pasos, y hacer el REVOKE.
</Para>

<Para>
    Este mecanismo también trabaja para reglas de update. En el ejemplo de la 
    sección previa, el propietario de las tablas de la base de datos de Al 
    (suponiendo que no fuera el mismo Al) podría haber autorizado (GRANT) 
    SELECT, INSERT, UPDATE o DELETE a la vista shoelace a Al. Pero sólo SELECT 
    en shoelace_log. La acción de la regla de escribir entradas del log deberá 
    ser ejecutada con exito, y Al podría ver las entradas del log, pero el no 
    puede crear nuevas entradas, ni podría manipular ni remover las existentes.

    <Note>
    <Title>Atención</Title>
    <Para>
    GRANT ALL actualmente incluye permisos RULE. Esto permite al usuario 
    autorizado borrar la regla, hacer los cambios y reinstalarla. Pienso que 
    esto debería ser cambiado rápidamente.
    </Para>
    </Note>
</Para>
</Sect1>

<Sect1>
<Title>Reglas frente triggers</Title>

<Para>
    Son muchas las cosas que se hacen utilizando triggers que pueden hacerse 
    también utilizando el sistema de las reglas de 
    <ProductName>Postgres</ProductName>. Lo que actualmente no se puede 
    implementar a través de reglas son algunos tipos de restricciones 
    (constraints). Es posible situar una regla cualificada que reescriba una 
    query a NOTHING si el valor de la columna no aparece en otra tabla, pero 
    entonces los datos son eliminados silenciosamente, y eso no es una buena 
    idea. Si se necesitan comprobaciones para valores válidos, y en el caso de 
    aparecer un valor inválido dar un mensaje de error, eso deberá hacerse por 
    ahora con un trigger.
</Para>

<Para>
    Por otro lado, un trigger que se dispare a partir de una INSERT en una 
    vista puede hacer lo mismo que una regla, situar los datos en cualquier 
    otro sitio y suprimir la inserción en una vista. Pero no puede hacer lo 
    mismo en una UPDATE o una DELETE, poruqe no hay datos reales en la relación
    vista que puedan ser comprobados, y por ello el trigger nunca podría ser 
    llamado. Sólo una regla podría ayudarnos.
</Para>

<Para>
    Para los tratamientos que podrían implementarse de ambas formas, dependerá 
    del uso de la base de datos cuál sea la mejor. Un trigger se dispara para 
    cada fila afectada. Una regla manipula el árbol de traducción o genera uno 
    adicional. De modo que si se manupulan muchas filas en una instrucción, una
    regla ordenando una query adicional usualmente daría un mejor resultado que
    un trigger que se llama para cada fila individual y deberá ejecutar sus 
    operaciones muchas veces.
</Para>

<Para>
    Por ejemplo: hay dos tablas.

<ProgramListing>
    CREATE TABLE computer (
        hostname        text     -- indexed
	manufacturer    text     -- indexed
    );

    CREATE TABLE software (
        software        text,    -- indexed
        hostname        text     -- indexed
    );
</ProgramListing>
    Ambas tablas tienen muchos millares de filas y el índice sobre hostname es 
    único. La columna hostname contiene el nombre de dominio cualificado 
    completo del ordenador. La regla/trigger debería desencadenar el borrado de
    filas de la tabla software que se refieran a un host borrado. Toda vez que 
    el trigger se llama para cada fila individual borrada de computer, se puede
    usar la instrucción

<ProgramListing>
    DELETE FROM software WHERE hostname = $1;
</ProgramListing>

    en un plan preparado y salvado, y pasar el hostname en el parámetro. 
    La regla debería ser escrita como

<ProgramListing>
    CREATE RULE computer_del AS ON DELETE TO computer
        DO DELETE FROM software WHERE hostname = OLD.hostname;
</ProgramListing>

    Veremos ahora en que se diferencian los dos tipos de delete. En el caso de 
    una
    
<ProgramListing>
    DELETE FROM computer WHERE hostname = 'mypc.local.net';
</ProgramListing>

    La tabla computer se revisa por índice (rápido) y la query lanzada por el 
    trigger también debería ser un barrido de índice (rápido también). La query
    extra para la regla sería una

<ProgramListing>
    DELETE FROM software WHERE computer.hostname = 'mypc.local.net'
                           AND software.hostname = computer.hostname;
</ProgramListing>

    Puesto que se han creado los índices apropiados, el optimizador creará un 
    plan de

<ProgramListing>
    Nestloop
      ->  Index Scan using comp_hostidx on computer
      ->  Index Scan using soft_hostidx on software
</ProgramListing>

    De modo que no habría mucha diferencia de velocidad entre la implementación
    del trigger y de la regla. Con la siguiente delete, queremos mostrar borrar
    los 2000 ordenadores cuyo hostname empieza con 'old'. Hay dos posibles 
    queries para hacer eso. Una es

<ProgramListing>
    DELETE FROM computer WHERE hostname >= 'old'
                           AND hostname <  'ole'
</ProgramListing>
    
    Donde el plan de ejecución para la query de la regla será

<ProgramListing>
    Hash Join
      ->  Seq Scan on software
      ->  Hash
	    ->  Index Scan using comp_hostidx on computer
</ProgramListing>

    La otra query posible es   

<ProgramListing>
    DELETE FROM computer WHERE hostname ~ '^old';
</ProgramListing>

    con un plan de ejecución

<ProgramListing>
    Nestloop
      ->  Index Scan using comp_hostidx on computer
      ->  Index Scan using soft_hostidx on software
</ProgramListing>

    Esto muestra que el optimizador no comprueba que la cualificación sobre 
    hostname en computer también debería se utilizado para un barrido por 
    índice en software donde hay múltiples expresiones de cualificación 
    combinadas con AND, que el hace en la versión regexp de la query. El 
    trigger será invocado una vez para cada una de los 2000 viejos ordenadores 
    que serán borrados, lo que dará como resultado un barrido por índice sobre 
    computer y 2000 barridos por índice sobre software. La implementación de la
    regla lo hará con dos queries sobre índices. Y dependerá del tamaño 
    promedio de la tabla software si la regla será más rápida en una situación 
    de barrido secuencial. 2000 ejecuciones de queries sobre el gestor SPI 
    toman su tiempo, incluso si todos los bloques del índice se encuentran en 
    la memoría caché.
</Para>

<Para>
    La última query que veremos es

<ProgramListing>
    DELETE FROM computer WHERE manufacurer = 'bim';
</ProgramListing>
    
    De nuevo esto debería dar como resultado muchoas filas para borrar de 
    computer. Por ello el trigger disparará de nuevo muchas queries sobre el 
    ejecutor. Pero el plan de las reglas será de nuevo un bucle anidado sobre 
    dos barridos de índice. Sólo usando otro índice en computer: 

<ProgramListing>
    Nestloop
      ->  Index Scan using comp_manufidx on computer
      ->  Index Scan using soft_hostidx on software
</ProgramListing>

    dando como resultado de la query de las reglas

<ProgramListing>
    DELETE FROM software WHERE computer.manufacurer = 'bim'
                           AND software.hostname = computer.hostname;
</ProgramListing>

    En cualquiera de estos casos, las queries extra del sistema de reglas serán
    más o menos independientes del número de filas afectadas en la query.
</Para>

<Para>
    Otra situación son los casos de UPDATE donde depende del cambio de un 
    atributo si la acción debería realizarse o no. En la versión 6.4 de 
    <ProductName>Postgres</ProductName>, la especificación de atributos para 
    acontencimientos de reglas se ha deshabilitado (y tendrá su regreso en la 
    6.5, quizá antes ¡permanezcan en antena!). De modo que por ahora la única 
    forma de crear una regla como en el ejemplo de shoelace_log es hacerlo con 
    una cualficación de la regla. Eso da como resultado una query adicional que
    se realiza siempre, incluso si el atributo que nos interesa no puede ser 
    cambiado de ninguna forma porque no aparece en la lista objetivo de la 
    query inicial. Cuando se habilite de nuevo, será una nueva ventaja del 
    sistema de reglas sobre los triggers. La optimización de un trigger deberá 
    fallar por definición en este caso, porque el hecjo de que su accoión solo 
    se hará cuando un atributo específico sea actualizado, está oculto a su 
    funcionalidad. La definición de un trigger sólo permite especificar el 
    nivel de fila, de modo que si se toca una fila, el trigger será llamado a 
    hacer su trabajo. El sistema de reglas lo sabrá mirándo la lista objetivo y
    suprimirá la query adicional por completo si el atributo no se ha tocado. 
    De modo que la regla, cualificada o no, sólo hará sus barridos si tiene 
    algo que hacer.
</Para>

<Para>
    Las reglas sólo serán significativamente más lentas que los triggers si sus
    acciones dan como resultado joins grandes y mal cualificadas, una situación
    en la que falla el optimizador. Tenemos un gran martillo. Utilizar un gran 
    martillo sin cuidado puede causar un gran daño, pero dar el toque correcto,
    puede hundir cualquier clavo hasta la cabeza.
</Para>
</Sect1>

</Chapter>
