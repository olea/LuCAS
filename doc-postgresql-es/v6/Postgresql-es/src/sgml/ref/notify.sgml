<!--
$Header: /home/cvs/lucas/doc-postgresql-es/v6/Postgresql-es/src/sgml/ref/notify.sgml,v 1.4 2001/04/21 21:57:14 olea Exp $
Postgres documentation
-->

<refentry id="SQL-NOTIFY">
 <refmeta>
  <refentrytitle id="sql-notify-title">
   NOTIFY
  </refentrytitle>
  <refmiscinfo>SQL - Sentencia de lenguage</refmiscinfo>
 </refmeta>
 <refnamediv>
  <refname>
   NOTIFY
  </refname>
  <refpurpose>
   Señala todos los "fronends" y "backends" a la escucha de una condición notify.
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <refsynopsisdivinfo>
   <date>1999-07-20</date>
  </refsynopsisdivinfo>
  <synopsis>
NOTIFY <replaceable class="PARAMETER">name</replaceable>        
  </synopsis>

  <refsect2 id="R2-SQL-NOTIFY-1">
   <refsect2info>
    <date>1998-10-07</date>
   </refsect2info>
   <title>
    Entradas
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">notifyname</replaceable></term>
      <listitem>
       <para>
	Notifica la condición a ser señalada.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>

  <refsect2 id="R2-SQL-NOTIFY-2">
   <refsect2info>
    <date>1998-10-07</date>
   </refsect2info>
   <title>
    Salidas
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term><computeroutput>
NOTIFY
       </computeroutput></term>
      <listitem>
       <para>
	Acuse de recibo de que el comando  notify ha sido ejecutado.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><replaceable>Eventos Notify</replaceable></term>
      <listitem>
       <para>
	Los eventos son repartidos a los "frontends" que están a la escucha; el cómo y si cada aplicacion "frontend"
	reacciona depende de su programación.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
 </refsynopsisdiv>

 <refsect1 id="R1-SQL-NOTIFY-1">
  <refsect1info>
   <date>1998-10-07</date>
  </refsect1info>
  <title>
   Descripción
  </title>
  <para>
   El comando <command>NOTIFY</command>  envía un evento notify a cada
   aplicación frontend que previamente ha ejecutado
   <command>LISTEN <replaceable class="parameter">notifyname</replaceable></command>
   para la condición notify específica en la base de datos en curso.
  </para>
  <para>
   La información pasada al "frontend" para un evento notify incluye el nombre de la condición notify
   y el PID de la notificación del proceso "backend".  Es asunto
   del diseñador de la base de datos el definir los nombres de las condiciones
   que serán usadas en una base de datos dada y que significa cada una.
  </para>
  <para>
   Comunmente, el nombre de una condición notify es el mismo que el de alguna tabla
   en la base de datos, y el evento notify esencialmente significa "He cambiado ésta tabla,
   echale un vistazo para ver los cambios".  Pero dicha asociación no es obligada
   por lo comandos <command>NOTIFY</command> y <command>LISTEN</command>.  Por
   ejemplo, un diseñador de bases de datos podría usar varios nombres de condición diferentes
   para señalar diferentes tipos de cambios en una misma tabla.
  </para>
  <para>
   <command>NOTIFY</command> provee un modo simple de señalar o un mecanismo
   de comunicación entre procesos (IPC interprocess communication) para el conjunto de procesos
   que acceden a la misma base de datos <productname>Postgres</productname>.
   Se pueden construir mecanismos de más alto nivel usando tablas en la base de datos
   para pasar datos adicionales (más allá de un mero nombre de condición) desde el notificador al
   o a los que estén a la escucha.
  </para>
  <para>
   Cuando se usa <command>NOTIFY</command> para señalar la ocurrencia de cambios
   en una tabla en particular, una técnica útil de programación es poner
   <command>NOTIFY</command> en una norma que es disparada por actualizaciones de la tabla.
   De esta manera, la notificación es automática cuando la tabla cambia,
   y el programador de la aplicación no puede olvidarse de ello de forma accidental.
  </para>
  <para>
   <command>NOTIFY</command> interactúa con transacciones SQL de una manera
   importante.  Primero, si se ejecuta un <command>NOTIFY</command> dentro de una
   transacción, lo eventos notify no son repartidos hasta y a menos que la
   transacción se haya hecho.  Esto es adecuado, dado que si una transacción
   se aborta nos gustaría que todos los comandos dentro de ella no hubieran tenido
   efecto, incluyendo <command>NOTIFY</command>.  Pero puede ser desconcertante si uno
   está esperando que los eventos notify se repartan inmediatamente.  Segundo, si
   un "backend" a la escucha recibe una señal notify mientras está en una transacción,
   el evento notify no se repartirá al "frontend" conectado hasta justo
   después de que la transacción se haya completado (tanto si se ejecuta como si se aborta).  De nuevo, la
   razón es que si un notify fuera repartido dentro de una transacción que después fue
   abortado, sería deseable que la notificación se deshiciera de alguna manera --- pero
   el "backend" no puede echar marcha atrás un notify una vez que ha sido enviado al "frontend".
   Por tanto los eventos notify son sólo repartidos entre transacciones.  El resultado de ésto
   es que las aplicaciones que usan <command>NOTIFY</command> para señalar en tiempo real
   deberían tratar de mantener cortas sus transacciones.
  </para>
  <para>
   <command>NOTIFY</command> se comporta como las señales Unix en un aspecto
   importante:si una misma condición es señalada varias veces en una sucesión
   rápida, los receptores puede que sólo recibieran un evento notify para varias ejecucuiones
   de <command>NOTIFY</command>.  Por ello es mala idea depender del número
   de notificaciones recibidas.  En cambio, usaremos <command>NOTIFY</command> para "despertar"
   a las aplicaciones que necesitan prestar atención a algo, y usaremos un objeto de base de datos
   (tal como una secuencia) para mantener un registro de lo que ha ocurrido o cuantas veces
   ha ocurrido.
  </para>
  <para>
   Es usual para un "frontend" que envía <command>NOTIFY</command> estar él mismo
   a la escucha del mismo nombre notify.  En ese caso recibirá un evento
   notify , justo igual que los otros "frontends" a la escucha.  Dependiendo de la
   lógica de la aplicación, esto podría acarrear un trabajo inútil --- por ejemplo,
   releyendo una tabla de una base de datos para encontrar la misma actualización que ése mismo frontend
   acababa de escribir.  En <productname>Postgres</productname> 6.4 y posteriores , es posible
   evitar dicho trabajo extra notificando si el PID del proceso de notificación del "backend"
   (suministrado en el mensaje del evento  notify) es el mismo que el PID
   del backend de uno mismo (valga la redundancia) (disponible en libpq).  Cuando son el mismo, el
   evento notificación es la recuperación del propio trabajo de uno mismo, y puede ser ignorado.  (A pesar de lo que
   se dijo en el párrafo precedente, esto es una técnica segura.
   <productname>Postgres</productname> mantiene las auto-notificaciones separadas de las notificaciones
   que llegan de otros "backends", de manera que no puedes perder una notificación de fuera por ignorar
   tus propias notificaciones.(Si alguien entiende ésto que me lo explique))
  </para>

  <refsect2 id="R2-SQL-NOTIFY-3">
   <refsect2info>
    <date>1998-10-07</date>
   </refsect2info>
   <title>
    Notas
   </title>
   <para>
    <replaceable class="PARAMETER">name</replaceable>
    puede ser una cadena válica com un nombre;
    no es necesaría una relación con el nombre de la tabla en sí.  Si
    <replaceable class="PARAMETER">name</replaceable>
    se encierra entre dobles comillas, ni siquiera necesita un nombre sintácticamente
    válido, sino que pude ser cualquier cadena de hasta 31 caracteres de longitud.
   </para>
   <para>
    En algunas versiones previas de
    <productname>Postgres</productname>,
    <replaceable class="PARAMETER">name</replaceable>
    tenía que encerrarse entre comillas dobles cuando no había relación con ningún
    nombre de tabla existente, incluso si sintácticamente era válido como nombre.  Esto ya no es necesario.
   </para>
   <para>
    En versiones <productname>Postgres</productname> anteriores a la 6.4, el  PID de backend
    repartido en un mensaje notify era siempre el PID del backend del frontend de uno mismo.
    Por eso no se podía distinguir las notificaciones deuno mismo de las notificaciones
    de otros clientes en aquellas versiones.
   </para>
  </refsect2>
 </refsect1>

 <refsect1 id="R1-SQL-NOTIFY-2">
  <title>
   Uso
  </title>
  <para>
   Configura y ejecuta una secuencia listen(escucha)/notify(notificación) desde
   <application>psql</application>:

   <programlisting>
LISTEN virtual;
NOTIFY virtual;
ASYNC NOTIFY de 'virtual' desde el pide de backend  '11239' recivido
   </programlisting>
  </para>
 </refsect1>

 <refsect1 id="R1-SQL-NOTIFY-3">
  <title>
   Compatibilidad
  </title>

  <refsect2 id="R2-SQL-NOTIFY-4">
   <refsect2info>
    <date>1998-09-24</date>
   </refsect2info>
   <title>
    SQL92
   </title>
   <para>
    No hay  sentencia<command>NOTIFY</command> en
    <acronym>SQL92</acronym>.
   </para>
  </refsect2>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
