<!--
$Header: /home/cvs/lucas/doc-postgresql-es/v6/Postgresql-es/src/sgml/ref/psql-ref/psql-ref_1.sgml,v 1.2 2002/02/27 22:52:58 emaldonadog Exp $
Postgres documentation
-->
<refentry id="APP-PSQL">
  <refmeta>
    <refentrytitle id="app-psql-title">
        <application>psql</application>
    </refentrytitle>
    <refmiscinfo>Aplicación</refmiscinfo>
  </refmeta>
  <refnamediv>
    <refname>
      <application>psql</application>
    </refname>
    <refpurpose>
      Terminal interaciva<productname>postgreSQL</productname> 
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <refsynopsisdivinfo>
      <date>1999-10-26</date>
    </refsynopsisdivinfo>
    <synopsis>psql [ <replaceable class="parameter">opciones</replaceable> ] [ <replaceable class="parameter">dbnombre</replaceable> [ <replaceable class="parameter">usuario</replaceable> ] ]</synopsis>
  <refsect2 id="R2-APP-PSQL-1">
    <refsect2info>
      <date>1998-09-26</date>
    </refsect2info>
    <title>Resumen</title>
    <para>
     <application>psql</application> es una terminal basada en front-end de 
     <productname>PostgreSQL</productname>. Te habilita a escribir en consultas interactivamente, emitiéndolas hacia  <productname>PostgreSQL</productname>, y ver los resultados de la consulta. Alternativamente, la entrada puede ser desde un archivo. En adición, provee un número de metacomandos y varios características para facilitar escribir guiones (scripts) y automatiza una ancha variedad de tareas.
    </para>
  </refsect2>
</refsynopsisdiv>
<refsect1 id="R1-APP-PSQL-1">
  <refsect1info>
    <date>1998-10-26</date>
  </refsect1info>
  <title>Descripción</title>
  <refsect2 id="R2-APP-PSQL-connecting">
    <refsect2info>
      <date>2000-01-14</date>
    </refsect2info>
    <title>Connecting To A Database</title>
    <para>
    <application>psql</application>es una aplicación cliente <productname>PostgreSQL</productname>regular. Para conectarse hacia una base de datos, tu necesitas saber el nombre de tu base de datos destino, el nombre del host y el número de puerto de el servidor y con que nombre de usuario te quieres conectar.
 <application>psql</application>puede ser enunciado acerca de todos aquellos parámetros via opciones de linea de comando, es decir
<option>-d</option>, <option>-h</option>, <option>-p</option>, and <option>-U</option> respectivamente.
Si un argumento es encontrado dque no pertenece a ninguna opción será interpretado como el nombre de la base de datos. No todas estas opciones son requeridas, pueden aplicarse algunas por defult.
Si tu omites el nombre del host, psql te conectará via socket de dominio hacia un servidor sobre el host local. El número de puerto por defecto es determinado en tiempo de compilación. Desde que el servidor de la base de datos usa el mismo default, cambios que haces, no tienen que especificar el puerto en la mayoría de las configuraciones. El nombre de usuario por defecto es tu nombre de usuario de unix, el mismo con la base de datos. Nota que tu no puedes simplemente conectarte con cualquier base de datos bajo cualquier nombre de usuario. Tu administrador de base de datos debe haberte informado sobre tus derechos de acceso. Para salvarte de algún tipeado tu puedes también configurar las variables de ambiente <envar>PGDATABASE</envar>,
    <envar>PGHOST</envar>, <envar>PGPORT</envar>, <envar>PGUSER</envar>,
respectivamente para valores apropiados. </para>
    <para>
Si la conección no pudo ser hecha por alguna razón (ej: privilegios insuficientes, postmaster no se está ejecutando sobre el servidor, etc.), 
    <application>psql</application>retornará un error y terminará.
    </para>
  </refsect2>
  <refsect2 id="R2-APP-PSQL-4">
    <refsect2info>
      <date>1998-09-26</date>
    </refsect2info>
    <title>Entrando Consultas</title>
    <para>
En operación normal,
 <application>psql</application>provee un prompt con el nombre de la base de datos que <application>psql</application> esta en ese momento conectada seguido por la cadena "=>". Por ejemplo,
<programlisting>
$ <userinput>psql testdb</userinput>
Bienvenido ha psql, la terminal interactiva de PostgreSQL.
Tipee:
       \copyright Para terminos de distribución
       \h Para hayuda con comandos de SQL
       \? Para hayuda sobre tajadas internas de comandos
       \g o terminar con punto y coma para ejecutar la consulta
       \q para salir
testdb=>
</programlisting>
    </para>
    <para>
En el prompt, el usuario debe tipear en consultas <acronym>SQL</acronym>.
Normalmente, las lineas de entradas son enviadas hacia el backend cuando un punto y coma de terminación de consulta es encontrado. ¡Un final de linea no termina la consulta!  
Así las consultas pueden ser extendidas sobre varias lineas por claridad. Si la consulta fue enviada y sin errores, los resultados de la consulta son mostrados en la pantalla.
    </para>
    <para>
cuando una consulta es ejecutada, 
<application>psql</application> 
también vota por eventos de notificación asincrónica generados por 
    <xref linkend="SQL-LISTEN" endterm="SQL-LISTEN-title"> y
    <xref linkend="SQL-NOTIFY" endterm="SQL-NOTIFY-title">.
    </para>
  </refsect2>
</refsect1>
<refsect1 id="R1-APP-PSQL-2">
    <refsect1info>
      <date>1998-09-26</date>
    </refsect1info>
    <title>Meta-comandos<application>psql</application></title>
    <para>
Cualquier cosa que tu entres en <application>psql</application>
que comience con una repercución negativa sin comillas (unquoted backslash) es un mata-comando
 <application>psql</application> que es procesado por el mismo <application>psql</application> .
Estos comandos son los que hacen a  <application>psql</application>
interesante para administración o para hacer guiones (scripting).
Los menta-comandos son mas comunmente llamados slash o comandos backslash.
    </para>
    <para>
El formato de un comando <application>psql</application> es el backslash seguido inmediatamente por un verbo comando, luego cualquier argumento. Los argumentos están separados del verbo comando y cada uno mediante cualquier número de espacios en blancos
    </para>
    <para>
Para incluir un espacio en blanco en un argumento, tu debes encerrarlo entre comillas simles. Para incluir una comilla simple en un argumento semejante, precédelo mediante un backslash. Cualquier cosa contenida entre comillas simples es además sujeto a subtituciones c-like por
 <literal>\n</literal> (nueva linea), <literal>\t</literal>
     (tab), <literal>\</literal><replaceable>digitos</replaceable>,
    <literal>\0</literal><replaceable>digitos</replaceable>, y
    <literal>\0x</literal><replaceable>digitos</replaceable>
    (El caracter con el código dado, decimal, octal o hexadecimal).
    </para>
    <para>
Si un argumento que no está entre comillas empieza con dos puntos (<literal>:</literal>),
es tomado como un variable y el valor de la variable es tomado como el argumento cambiado.
    </para>
    <para>
Argumentos que están encerrados en <quote>backticks</quote> (<literal>`</literal>)
son tomados como una linea de comandos que es pasda hacia el shell. La salida del comando(con una
 nueva linea atras removida) es tomado como el valor del argumento. La secuencia de escape es también aplicada en backticks.
    </para>
    <para>
Algunos comandos toman el nombre de un identificador  <acronym>SQL</acronym>  (como el nombre de una tabla ) como argumento. Estos argumentos siguen las reglas de sintaxis de doble comilla de 
 <acronym>SQL</acronym> : un identificador sin doble comillas es forzado a un caso más bajo. Para todos los demás comandos, dobles comillas no son especiales y se convertirán en parte del argumento.
    </para>
    <para> 
Parsing for arguments stops when another unquoted backslash occurs. Este 
es tomado como el principio de un nuevo meta comando. La secuencia especial
<literal>\\</literal> (dos backslashes) marcan el final de los argumentos y continua parsing consultas  <acronym>SQL</acronym>, si hay alguna. De ese modo comandos <acronym>SQL</acronym> y
    <application>psql</application> pueden ser libremente mezclados sobre una line.
Pero en cualquier caso, los argumentos de un meta comando, no pueden continuar detrás de el final de la linea.
    </para>
    <para>
Los siguientes meta-comandos están definidos:
    <variablelist>
      <varlistentry>
        <term><literal>\a</literal></term>
        <listitem>
        <para>
	Si el formato de salida de la tabla corriente está sin alinear, cambialo a alineado. Si no está sin alinear, configuralo como sin alinear. Este comando es guardado para compatibilidad retrospectiva. Ver  <command>\pset</command> para una solución general.	
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\C</literal> [ <replaceable class="parameter">title</replaceable> ]</term>
        <listitem>
        <para>
Fija el título de cualquier tabla que está siendo impresa como el resultado de una consulta o
desconfigura cualquier título semejante. Este comando es equivalente a
   <literal>\pset title <replaceable class="parameter">title</replaceable></literal>.
(El nombre de este comando, deriva de  <quote>caption (título)</quote>, como fue previamente usado solamente para fijar el título en una tábla <acronym>HTML</acronym>.)
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\connect</literal> (o <literal>\c</literal>) [ <replaceable class="parameter">dbname</replaceable> [ <replaceable class="parameter">username</replaceable> ] ]</term>
        <listitem>
        <para>
Establece una conección hacia una nueva base de dato y/o bajo un nombre de usuario. La conección previa es cerrada.	
	Si <replaceable class="parameter">dbname</replaceable> es <literal>-</literal>
el nombre de la base de datos actual, es esumido.
	</para>
	<para>
Si <replaceable class="parameter">username</replaceable> es omitido, el actual nombre de usuario es asumido.
	</para>
	<para>
Como una regla especial, <command>\connect</command> sin ningún argumento, te conectará hacia una base de datos por defecto como a un usuario por defecto (como habrías obtenido arrancando <application>psql</application>sin ningun argumento).
	</para>
	<para>
Si el intento de conección falla (nombre de usario incorrecto, acceso denegado, etc.) la conección previa será mantenida,si y solamente si  <application>psql</application> está
en modo interactivo. Cuando ejecute un script no interactivo, el proceso se detendrá inmediatamente con un error. Esta destinción fue elejida como una conveniencia de usuario en contra de typos(??) por un lado, y un mecanismo  seguro ya que script no son accidentalmente accionados sobre la base de datos equivocada, por otro lado.
	</para>
        </listitem>
     </varlistentry>
      <varlistentry>
        <term><literal>\copy</literal> <replaceable class="parameter">table</replaceable>
        [ <literal>with oids</literal> ] { <literal>from</literal> | <literal>to</literal> }
	<replaceable class="parameter">filename</replaceable> | stdin | stdout
        [ <literal>with delimiters</literal> '<replaceable class="parameter">characters</replaceable>' ]
        [ <literal>with null as</literal> '<replaceable class="parameter">string</replaceable>' ]
        </term>
        <listitem>
        <para>
        Realiza una copia frontend (cliente). Esta es una operación que ejecuta un comando
	<acronym>SQL</acronym> <xref linkend="SQL-COPY" endterm="SQL-COPY-title">,
pero en vez de que el backend lea o escriba el archivo específico, y consecuentemente requiera acceso backend y privilegios de usuario especial, tan bien como siendo el límite de accesibilidad del sistema de archivos por el backend, <application>psql</application> lee o escribe el archivo y rutea los datos hacia o desde el backend hasta el sistema local de archivo.
	</para>
	<para>
La sintaxis del comando es en analogía del comando <acronym>SQL</acronym>
	<command>COPY</command>, ver su descripción para los detalles.
Nota que por esto, reglas de parsing especiales se aplican al comando <command>\copy</command>. En particular, las reglas de sustitución variables y los escapes backslash no se aplican.
	</para>
        <tip>
        <para>
Esta operación no es tan eficiente como el comando <acronym>SQL</acronym>	<command>COPY</command> porque todo los datos deben pasar a traves del IP cliente/servidor o de la conección socket. Para grandes cantidades de datos la otra técnica es preferible.
        </para>
        </tip>
        <note>
        <para>
	Nota la diferencia en la interpretación de  <literal>stdin</literal> y <literal>stdout</literal> entre copias frontend y backend:
En una copia frondend, estos siempre se refieren a cadenas de entrada y salida de 
        <application>psql</application>. En una copia backend <literal>stdin</literal> 
viene desde donde quierra que  <command>COPY</command> venga (por ejemplo, un script corrió con la opción <option>-f</option>),y <literal>stdout</literal> se refiere a la cadena de consulta de salida (ver el mentacomnado <command>\o</command> a continuación).
        </para>
        </note>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\copyright</literal></term>
        <listitem>
        <para>
Muestra los derechos de copia y los términos de distribución de <application>PostgreSQL</application>.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\d</literal> <replaceable class="parameter">relation</replaceable> </term>
        <listitem>
        <para>
	Muestra todas las columnas de la  <replaceable class="parameter">relación</replaceable>
	(que puede ser una tabla, vista, índice o secuencia), sus tipos y cualquier atributo especial como <literal>NOT NULL</literal>, si hay algunos.
Si la relación es, de echo, una tabla, cualquier índice definido es también listado.
Si la relación es una vista, la definición de la vista es también mostrada.
	</para>
	<para>
La forma de comando  <literal>\d+</literal> es idéntica, pero cualquier comenteario asociado con las columnas de la tabla son también mostrados.
	</para>
	<note>
	<para>
Si  <command>\d</command> es llamado sin argumentos, es equivalente a  <command>\dtvs</command> 
el cual mostrará un lista de todas las tablas, vistas y secuencias. Esta es puramente una medida conveniente.
	</para>
	</note>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\da</literal> [ <replaceable class="parameter">pattern</replaceable> ]</term>
        <listitem>
        <para>
Lista todas las funciones agregadas, junto con el tipo de datos sobre el cual ellas operan.
Si  <replaceable class="parameter">pattern</replaceable> (una expresión regular) es especificado, solamente los agregados emparejados son mostrados.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\dd</literal> [ <replaceable class="parameter">object</replaceable> ]</term>
        <listitem>
        <para>
Muestra la descripciones de <replaceable class="parameter">object</replaceable>
(la cual puede ser una expresión regular), o de todos los objetos si no es dado ningún argumento. 
        (<quote>Object</quote> cubre agregados, funciones, opoeradores, tipos, relaciones (tablas, vistas, índices, secuencias, objetos grandes), regla y gatillos.) Por ejemplo :
<programlisting>
=> <userinput>\dd version</userinput>
              Descripciones de objetos
  name   |   What   |        Description
---------+----------+---------------------------
 version | function | PostgreSQL version string
(1 row)
</programlisting>
        </para>
        <para>
Descrpciones para objetos pueden ser generadas con el comando <acronym>SQL</acronym>      
  <command>COMMENT ON</command>.
	</para>
        <note>
        <para>
        <productname>PostgreSQL</productname> almacena las descripciones de objeto en la tabla de sistema pg_description.
        </para>
        </note>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\df [ <replaceable class="parameter">pattern</replaceable> ]</literal></term>
        <listitem>
        <para>
Lista las funciones disponibles, junto con sus argumentos y tipos de retornos.     
Si <replaceable class="parameter">pattern</replaceable>
(una expresión regular) es especificada, solamente funciones emparejadas son mostradas. Si la forma <literal>\df+</literal> es usada, información adicional sobre cada función, encluyendo lenguaje y descripción es mostrada.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\distvS [ <replaceable class="parameter">pattern</replaceable> ]</literal></term>
	<listitem>
	<para>
Este no es el nombre de comando actual: Las letras i, s, t, v, S se hallan para índices, secuencia, tabla, vista y tabla de sistema respectivamente. Tu puedes especificar cualquier o todos ellos en cualquier orden para obtener un listado de ellos, junto con que es el dueño.
</para>
	<para>
Si<replaceable class="parameter">pattern</replaceable> es especificado, es una expresión regular restringiendo el listado de aquellos objetos cuyos nombres coincidan. Si uno agrega un <quote>+</quote> al nombre de comando, cada objeto es listado con su descripción asociada, si tiene alguna.
	</para>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\dl</literal></term>
	<listitem>
	<para>
Este es una alias para 	<command>\lo_list</command>, el cual muestra una lista de objetos grandes.
	</para>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\do [ <replaceable class="parameter">pattern</replaceable> ]</literal></term>
        <listitem>
        <para>
Lista los operadores disponibles con sus operandos y sus tipos de retornos.
Si <replaceable class="parameter">pattern</replaceable> es especificado, solamente operadores con el nombre serán mostrados. (desde que esta es una expresión regular, asegurate poner entre comillas todos los caracteres especiales en los nombres de tus operadores con backslasehs. Para prevenir la interpretación de los backslash como un nuevo comando, tu debes también poner entre comillas el argumento.)
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\dp</literal> [ <replaceable class="parameter">pattern</replaceable> ]</term>
	<listitem>
	<para>
Este es un alias para <command>\z</command> el cual fue incluido por su valor más nemotécnico
 (<quote>Muestra permisos</quote>).
	</para>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\dT [ <replaceable class="parameter">pattern</replaceable> ]</literal></term>
        <listitem>
        <para>
Lista todos los tipos de datos o solamente aquellos que concuerdan con el 
        Lists all data types or only those that match <replaceable class="parameter">patrón</replaceable>.
 La forma de comando <literal>\dT+</literal> muestra información extra.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\edit</literal> (o <literal>\e</literal>) [ <replaceable class="parameter">filename</replaceable> ]</term>
        <listitem>
        <para>
        Si <replaceable class="parameter">filename</replaceable>es especificado, el archivo es editado y después que el editor sale, su contenido es copiado otra ves hacia el buffer de consulta. Si ningún argumento es dado, el buffer actual de consulta es copiado hacia un archivo temporario el cual es luego editado en el mismo modo.
        </para>
        <para>
El nuevo buffer de consulta es entonces re-parsed acorde a las reglas normales de
        <application>psql</application>, donde el buffer entero es tratado como una simple linea. (Así tu no puedes hacer <quote>scripts</quote> en este modo, usa
 <command>\i</command>para eso.) Esto significa también que si la consulta finaliza con (o más bien contiene) un punto y coma, es inmediatamente ejecutada. En otros casos, solamente será esperada en el vuffer de consulta.
        </para>
        <tip>
        <para>
        <application>psql</application> busca las variables de ambiente
        <envar>PSQL_EDITOR</envar>, <envar>EDITOR</envar>, y <envar>VISUAL</envar>
(en ese orden) para que las usen en un editor. Si todas ellas están desconfiguradas,         
        <filename>/bin/vi</filename> es ejecutado.
        </para>
        </tip>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\echo</literal> <replaceable class="parameter">text</replaceable> [ ... ]</term>
        <listitem>
	<para>
	Imprime los argumentos en la salida estandar, separados por un espacio y seguidos por una nueva linea. Esto puede ser util para esparcir información en la salida de scripts. Por ejemplo:
<programlisting>
=> <userinput>\echo `date`</userinput>
Tue Oct 26 21:40:57 CEST 1999
</programlisting>
Si el primer argumento no está entre comillas <literal>-n</literal> la nueva linea que le sigue no es escrita.
	</para>
	<tip>
	<para>
Si tu usas el comando  <command>\o</command>  para redireccionar tu salida de consulta, tu puedes desear usar  <command>\qecho</command> en vez de este comando.
	</para>
	</tip>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\encoding</literal> [ <replaceable class="parameter">encoding</replaceable> ]</term>
        <listitem>
        <para>
fija la codificación del cliente, si tu estas usando multiples codificaciones.
Sin argumento, este comando muestra la codificación actual.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\f</literal> [ <replaceable class="parameter">string</replaceable> ]</term>
        <listitem>
        <para>
Fija el separador de campo para salidas de consultas desalineadas. El por defecto es       
<quote><literal>|</literal></quote> (un simbolo <quote>pipe</quote>). Ver también <command>\pset</command> para una forma genérica de fijar o configuar las opciones de salida.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\g</literal> [ { <replaceable class="parameter">filename</replaceable> | <literal>|</literal><replaceable class="parameter">command</replaceable> } ]</term>
        <listitem>
        <para>
Envia el buffer de entrada de la consulta actual hacia el backend y opcionalmente guarda la salida en  <replaceable class="parameter">filename</replaceable> o conduce la salida hacia un shell de Unix separado para ejecutar un <replaceable class="parameter">command</replaceable>.
Una  <literal>\g</literal> al descubierto es virtualmente equivalente a un punto y coma. Una
 <literal>\g</literal> con argumento es una alternativa
 <quote>one-shot (de un golpe)</quote> para el comando <command>\o</command>.
        </para>
        </listitem>
     </varlistentry>
      <varlistentry>
        <term><literal>\help</literal> (o <literal>\h</literal>) [ <replaceable class="parameter">command</replaceable> ]</term>
        <listitem>
        <para>
Da la ayuda sintactica sobre un comando específico de <acronym>SQL</acronym>.  
Si <replaceable class="parameter">command</replaceable> no es especificado, entonces
 <application>psql</application> listará todos los comandos para los cuales la ayuda sintáctica esté disponible. Si <replaceable class="parameter">command</replaceable>
es un asterisco (<quote>*</quote>), entonces ayuda sintáctica en todos los comandos <acronym>SQL</acronym>es mostrada.
        </para>
	<note>
	<para>
Para simplificar el tipeado, comandos que consisten en varias palabras no tienen que ser puestos entre comillas. Así, está bien tipear <userinput>\help alter table</userinput>.
	</para>
	</note>	
        </listitem>
     </varlistentry>
      <varlistentry>
        <term><literal>\H</literal></term>
        <listitem>
        <para>
Enciende el formato de salida de consulta  <acronym>HTML</acronym>. Si el formato
<acronym>HTML</acronym> está ya encendido, es cambiado otra vez hacia hacia el formato por defecto de texto alineado. Este es un comando para compatibilidad y conveniencia, pero ver 
 <command>\pset</command> acerca de configurar otras opciones de salida.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\i</literal> <replaceable class="parameter">filename</replaceable></term>
        <listitem>
        <para>
Lee la entrada desde el archivo  <replaceable class="parameter">filename</replaceable>
y lo ejecuta como si hubiese sido tipeado en el teclado.
        </para>
	<note>
	<para>
Si tu quieres ver las lineas sobre la pantalla a medida que estas son leidas, tu debes fijar la variable <envar>ECHO</envar> en  <literal>all</literal>.
	</para>
	</note>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\l</literal> (o <literal>\list</literal>)</term>
        <listitem>
        <para>
Lista todas las bases de datos en el servidor como también sus dueños. Agrega un        
<quote>+</quote> al nombre del comando para ver cualquier descripción sobre las bases de datos. Si tu instalación de  <productname>PostgreSQL</productname> fue compilada con soporte de codificación múltiple, el esquema de codificación de cada base de datos es también mostrado.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\lo_export</literal> <replaceable class="parameter">loid</replaceable> <replaceable class="parameter">filename</replaceable></term>
	<listitem>
	<para>
Lee el objeto grande con  <acronym>OID</acronym> <replaceable class="parameter">loid</replaceable> desde la base de datos y lo escribe en 
 <replaceable class="parameter">filename</replaceable>. Nota que esto es sutilmente diferente de la función de servidor <function>lo_export</function>,que actua con los permisos del usuario que el servidor de base de datos ejecuta y con el sistema de archivos del servidor.
	</para>
	<tip>
	<para>
Usa <command>\lo_list</command> para descubrir los <acronym>OID</acronym> de objetos grandes.
	</para>
	</tip>
	<note>
	<para>
Ver la descripción de la variable <envar>LO_TRANSACTION</envar> para información importante acerca de todas las operaciones de objetos grandes.
	</para>
	</note>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\lo_import</literal> <replaceable class="parameter">filename</replaceable> [ <replaceable class="parameter">comment</replaceable> ]</term>
	<listitem>
	<para>
Almacena el archivo en 	<quote>objeto grande</quote><productname>PostgreSQL</productname>.
Opcionalmente, se asociaa el comentario dado con el objeto. Ejemplo:
<programlisting>
foo=> <userinput>\lo_import '/home/peter/pictures/photo.xcf' 'a picture of me'</userinput>
lo_import 152801
</programlisting>
La respuesta indica que le objeto grande recibió id de objeto 152801 con un acerca de para recordar si alguna vez quieres acceder al objeto de nuevo.
Por esta razón se recomienda siempre asociar un comentario legible para una persona con cada objeto. Aquellos pueden ser vistos con el comando <command>\lo_list</command>.
	</para>
	<para>
Nota que este comando es sutilmente difernte del <function>lo_import</function> del lado del servidor, porque actua como un usuario local sobre un sistema de archivos local, en vez del usuario del servidor y el sistema de archivo.
	</para>
	<note>
	<para>
Ver la descripción de la variable <envar>LO_TRANSACTION</envar> para información importante aceral de todas las operaciones de objetos grandes.
	</para>
	</note>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\lo_list</literal></term>
	<listitem>
	<para>
Muestra una lista de todos los	<quote>objetos grandes</quote>
de  <productname>PostgreSQL</productname> actualmente almacenados en la base de datos con sus dueños.
	</para>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\lo_unlink</literal> <replaceable class="parameter">loid</replaceable></term>
	<listitem>
	<para>
Borra un objeto grande con <acronym>OID</acronym> <replaceable class="parameter">loid</replaceable> desde la base de datos.
	</para>
	<tip>
	<para>
	Usa <command>\lo_list</command>para descubrir los <acronym>OID</acronym>de los objetos grandes.
	</para>
	</tip>
	<note>
	<para>
Ver la descripción de la variable <envar>LO_TRANSACTION</envar> para información importante acerca de todas las operaciones de objetos grandes.
	</para>
	</note>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\o</literal> [ {<replaceable class="parameter">filename</replaceable> | <literal>|</literal><replaceable class="parameter">command</replaceable>} ]</term>
        <listitem>
        <para>
Guarda el resultado de la consulta futura en el archivo       
	<replaceable class="parameter">filename</replaceable> o dirige el resultado futuro hacia un shell separado de Unix para ejecutar	<replaceable class="parameter">commando</replaceable>.
Si no se especifican argumentos, la salida de la consulta será reestablecida hacia
        <filename>stdout</filename>.
        </para>
	<para>
	<quote>Resultados de consultas</quote>incluidas todas las tablas, respuestas de comandos y noticias obtenidas desde el servidor de base de datos, también como salidas de varios comandos backslash que consultan la base de datos (como  <command>\d</command>), pero no errores de mensajes.
	</para>
	<tip>
	<para>
Para esparcir salida de texto entre los resultados de consultas, usa<command>\qecho</command>.
	</para>
	</tip>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\p</literal></term>
        <listitem>
        <para>
Imprime el buffer de la consulta actual en la salida estandar.
        </para>
        </listitem>
      </varlistentry>
                                                            <varlistentry>
        <term><literal>\pset</literal> <replaceable class="parameter">parameter</replaceable> [ <replaceable class="parameter">value</replaceable> ]</term>
	<listitem>
	<para>
Este comando configura opciones afectando la salida de tablas de resultado de consulta.
	<replaceable class="parameter">parameter</replaceable> describe cual opción está por ser configurada. La semántica de  <replaceable class="parameter">value</replaceable>
depende de eso.
	</para>
	<para>
Las opciones ajustables de impresión son:
	<variablelist>
	  <varlistentry>
	  <term><literal>format</literal></term>
	  <listitem>
	  <para>
Fija el formato de salida en  <literal>sin alinear</literal>,
	  <literal>alineado</literal>, <literal>html</literal>, o <literal>latex</literal>.
Abreviaciones únicas son permitidas. (Que significaría, que una letra es suficiente.)
  </para>
	  <para>
	  <quote>Sin alinear</quote> escribe todos los campos de una tupla (fila) en una linea, serparados por le separador de campo actual activado. Esto es pensado para crear salidas que pueden ser pensadas para ser leidas en otros programas (separadas por tab, separadas por coma).

El modo <quote>Alineado</quote> es el estandar, legible por personas, texto de salida en un buen formato que es por defecto. Los modos
 <quote><acronym>HTML</acronym></quote> y <quote>LaTeX</quote> ponen fuera tablas que son pensadas para ser incluidas en documentos usando el lenguaje respectivo mark-up. No son documentos completos!(Esto no debe ser tan dramático en  <acronym>HTML</acronym>, pero en LaTex tu debes tener una envoltura de documento complea.)
	  </para>
	  </listitem>
          </varlistentry>
	  <varlistentry>
	  <term><literal>border</literal></term>
	  <listitem>
	  <para>
El segundo argumento debe ser un número. En general, el más grande de los números de los bordes y lineas la tabla tendrá, pero esto depende sobre el formato particular. En modo
 <acronym>HTML</acronym>, esto se traducirá directamente en el atributo
<literal>border=...</literal>, en otros, solamente valores 0 (sin bordes), 1(lineas devisoras internas), y 2 (marco de tabla) tienen sentido.
	  </para>
	  </listitem>
	  </varlistentry>
	  <varlistentry>
	  <term><literal>expanded</literal> (o <literal>x</literal>)</term>
	  <listitem>
	  <para>
Fija entre el formato regular y el expandido. Cuando el formato expandido está abilitado, todas las salidas tienen dos columnas con el nombre del campo sobre la izquierda y el dato sobre la derecha. Este modo es util si el dato no cabría sobre la pantalla en el modo normal
 <quote>horizontal</quote>.
	  </para>
	  <para>
El modo expandido es soportado por los cuatro modos de salida.
	  </para>
	  </listitem>
	  </varlistentry>
	  <varlistentry>
	  <term><literal>null</literal></term>
	  <listitem>
	  <para>
El segundo argumento es una cadena que debería ser impresa cada vez que un campo es nullo. Por defecto no se imprime nada, que puede ser facilmente confundida por una cadena vacia.
Así, uno debe escoger escribir <literal>\pset null "(null)"</literal>.
	  </para>
	  </listitem>
	  </varlistentry>
  <varlistentry>
	  <term><literal>fieldsep</literal></term>
	  <listitem>
	  <para>
Especifica el separador de campo a ser usado en el modo de salida desalineado. De ese modo, uno puede crear, por ejemplo, salidas separadas por tab o coma, que otros programas puedan preferir. Para fijar tab como serparador de campo, tipee	<literal>\pset fieldsep "\t"</literal>.
El separador de campo por defeco es  <quote><literal>|</literal></quote> (un simbolo <quote>pipe</quote>).
	  </para>
	  </listitem>
	  </varlistentry>
	  <varlistentry>
	  <term><literal>recordsep</literal></term>
	  <listitem>
	  <para>
Specifica el separador de (linea) grabado para usar en el modo de salida desaleneado. Por defecto es un caracter de linea nueva.
	  </para>
	  </listitem>
	  </varlistentry>
	  <varlistentry>
	  <term><literal>tuples_only</literal> (o <literal>t</literal>)</term>
	  <listitem>
	  <para>
(toggles) entre tuplas solamente y mostrar todo. Mostrar todo puede mostrar información extra como cabecera de columnas, títulos y varios footers. En modo de solamente tuplas, solamente son mostrado datos de la tabla actual.
	  </para>
	  </listitem>
	  </varlistentry>
	  <varlistentry>
	  <term><literal>title</literal> [ <replaceable class="parameter">text</replaceable> ]</term>
	  <listitem>
	  <para>
Fija el título de la tabla para cualquier subsecuencia de tablas impresas. Esto puede ser usado para dar etiquetas descriptivas a tu salida. Si no se dan argumentos, el título no es fijado.
	  the title is unset.
	  </para>
	  <note>
	  <para>
Esto antiguamente solamente afectó al modo  <acronym>HTML</acronym>. Tu puedes ahora fijar títulos en cualquier formato de salida.
	  </para>
	  </note>
	  </listitem>
	  </varlistentry>
	  <varlistentry>
	  <term><literal>tableattr</literal> (o <literal>T</literal>) [ <replaceable class="parameter">text</replaceable> ]</term>
	  <listitem>
	  <para>
Te permite especificar cualquier atributo para ser puesto dentro de la etiqueta de la <sgmltag>tabla</sgmltag>  <acronym>HTML</acronym>. Esto puede ser por ejemplo
	  <literal>cellpadding</literal> o <literal>bgcolor</literal>. Nota que tu probablemente no quieres especificar aquí  <literal>borde</literal>, como quello está tomado en cuenta por
 <literal>\pset border</literal>.
	  </para>
	  </listitem>
	  </varlistentry>
  <varlistentry>
	  <term><literal>pager</literal></term>
	  <listitem>
	  <para>
(Toggles ) la lista de un paginador para hacer salida de tabla. Si la variable de ambiente
<envar>PAGER</envar> está configurada, la salida es dirigida hacia el programa especificado.
De otro modo <filename>more</filename>es usado.
	  </para>
	  <para>
En cualquier caso, <application>psql</application> solamente usa el paginador si parece le parece apropiado. Eso significa entre otras cosas que la salida es hacia un terminal y que la tabla normalmente no entraria sobre la pantalla. Gracias a la naturaleza modular de las rutinas de impresión no es siempre posible predecir el número de lineas que actualmente serán impresas. Por esa razón  <application>psql</application> no debe parecer muy discriminador acerca de cuando usar el paginador y cuando no.
	  </para>
	  </listitem>
	  </varlistentry>
	</variablelist>
Ilustaciones sobre como estos formatos diferentes lucen, pueden ser vistas en la sección
 <xref linkend="APP-PSQL-examples" endterm="APP-PSQL-examples-title">.
	</para>
	<tip>
	<para>
Hay varios comandos de atajo para <command>\pset</command>.Ve
	<command>\a</command>, <command>\C</command>, <command>\H</command>,
	<command>\t</command>, <command>\T</command>, y <command>\x</command>.
	</para>
	</tip>
	<note>
	<para>
Es un error llamar <command>\pset</command> sin argumentos. En el futuro esta llamada debe mostrar es estado actual de todas las opciones de impresión.
	</para>
	</note>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\q</literal></term>
        <listitem>
        <para>
Sale del programa  <application>psql</application> .
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\qecho</literal> <replaceable class="parameter">text</replaceable> [ ... ] </term>
        <listitem>
        <para>
Este comando es idéntico a <command>\echo</command> exepto que todas las salidas serán escritas en el canal de salida de consulta, como fijadas por <command>\o</command>.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\r</literal></term>
        <listitem>
        <para>
Reestablece (limpia)  el buffer de consulta.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\s</literal> [ <replaceable class="parameter">filename</replaceable> ]</term>
        <listitem>
        <para>
Imprime o guarda la historia de linea de comando en
        <replaceable class="parameter">filename</replaceable>.
Si <replaceable class="parameter">filename</replaceable> es omitido, la historia es escrita en la salida estandar. Esta opción solamente está disponible si <application>psql</application> está configurada para usar librería histórica <acronym>GNU</acronym>.
        </para>
	<note>
	<para>
Como la versión 7.0 de <application>psql</application>no es lo necesariamente grande, en hecho, para salvar la historia de comandos como eso sería hecho automaticamente sobre la terminación del programa. La historia es entonces también automaticamente cargada cada vez que arranca
 <application>psql</application>.
	</para>
	</note>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\set</literal> [ <replaceable class="parameter">name</replaceable> [ <replaceable class="parameter">value</replaceable> [ ... ]]]</term>
	<listitem>
	<para>
Establece la variable de interna  <replaceable class="parameter">name</replaceable>
	en <replaceable class="parameter">value</replaceable> o, si más de un valor es dado, en la concatenación de todos ellos. Si no se ha dado el segundo argumento, la variable se establece sin valor. Para desestablecer la variable, usa el comando <command>\unset</command>.
	</para>
	<para>
Nombres de variables válidos pueden contener caracteres, dígitos y subrayado.
Ver la sección acerca de variables <application>psql</application> para detalles.
	</para>
	<para>
Sin embargo eres bienvenido para establecer cualquier variable con lo que tu quieras,
	<application>psql</application> te da muchas variables especiales.
Ellas son documentadas en la sección acerca de variables.
	</para>
	<note>
	<para>
Este comando es totalmente separado del comando  <acronym>SQL</acronym>
	<xref linkend="SQL-SET" endterm="SQL-SET-title">.
	</para>
	</note>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\t</literal></term>
        <listitem>
        <para>
(revisar linea)        Toggles la pantalla de nombre de cabeceras de columnas de salidas y filas cuentan footer.
Este comando es equivalente a
 <literal>\pset tuples_only</literal>  y es proveido por conveniencia
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\T</literal> <replaceable class="parameter">table_options</replaceable></term>
        <listitem>
        <para>
Te permite especificar opciones para  ser ubicadas en la etiqueta de la
         <sgmltag>table</sgmltag> en el modo de salida tabular<acronym>HTML</acronym>. Este comando es equivalente a <literal>\pset tableattr <replaceable class="parameter">table_options</replaceable></literal>.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\w</literal> {<replaceable class="parameter">filename</replaceable> | <replaceable class="parameter">|command</replaceable>}</term>
        <listitem>
        <para>
Saca el buffer de salida actual hacia  <replaceable class="parameter">filename</replaceable>
o lo dirige hacia un comando Unix <replaceable class="parameter">command</replaceable>.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\x</literal></term>
        <listitem>
        <para>
toggles modo de formato de fila extendida. Es equivalente a
	<literal>\pset expanded</literal>.
       </para>
       </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\z</literal> [ <replaceable class="parameter">patrón</replaceable> ]</term>
        <listitem>
        <para>
      Produce una lista de todas las tablas en la base de datos con sus apropiados permisos de accesos listados. Si un argumento se le  es dado, es tomado como una expresión regular que limita el listar aquellas tablas que marca.
        </para>
	<para>
<programlisting>
test=> <userinput>\z</userinput>
Permisos de acceso para la base de datos "test"
 Relation |           Access permissions
----------+-------------------------------------
 my_table | {"=r","joe=arwR", "group staff=ar"}
(1 row )
</programlisting>
        Lee esto como sigue:
	<itemizedlist>
          <listitem>
          <para>
          <literal>"=r"</literal>: <literal>PUBLIC</literal> tiene permiso de lectura
	  (<command>seleccionar</command>) sobre la tabla.
	  </para>
	  </listitem>
	  <listitem>
	  <para>
	  <literal>"joe=arwR"</literal>: Usuario <literal>joe</literal> tiene lectura,
	  escritura (<command>actualizar</command>, <command>borrar</command>),
	  <quote>agregar</quote> (<command>INSERTAR</command>) permisos,
	y permiso para crear reglas sobre la tabla.
	  </para>
	  </listitem>
	  <listitem>
	  <para>
	  <literal>"group staff=ar"</literal>: Group <literal>staff</literal>
	  tiene <command>SELECT</command> y <command>INSERT</command> permisos.
	  </para>
	  </listitem>
	</itemizedlist>
	</para>
	<para>
Los comandos	 <xref linkend="SQL-GRANT" endterm="SQL-GRANT-title"> y
	<xref linkend="SQL-REVOKE" endterm="SQL-REVOKE-title">
son usados para fijar los permisos de acceso.
	</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\!</literal> [ <replaceable class="parameter">command</replaceable> ]</term>
        <listitem>
        <para>
Escapar hacia un shell de unix separado o ejecutar el comando de unix
        <replaceable class="parameter">command</replaceable>.
Los argumentos no son extensamente interpretados, el shel los verá a ellos como son.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>\?</literal></term>
        <listitem>
        <para>
obtener información de ayuda acerca de los comandos slash (<quote>\</quote>).
        </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </para>
</refsect1>
**************** Colocar aquí la segunda parte del fichero.
**************** Dejar estas líneas para el coordinador.