**************Insertar aquí la primera parte del fichero.
**************Dejar estas líneas para el coordinador.

<refsect1 id="R1-APP-PSQL-3">
  <refsect1info>
    <date>1998-09-26</date>
  </refsect1info>

  <title>Command-line Options</title>

  <para>
  If so configured, <application>psql</application> understands both standard
  Unix short options, and <acronym>GNU</acronym>-style long options. The latter
  are not available on all systems.
  </para>

  <para>
  <variablelist>
    <varlistentry>
      <term>-a, --echo-all</term>
      <listitem>
      <para>
      Print all the lines to the screen as they are read. This is more useful for
      script processing rather than interactive mode.
      This is equivalent to setting the variable <envar>ECHO</envar> to <literal>all</literal>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-A, --no-align</term>
      <listitem>
      <para>
      Switches to unaligned output mode. (The default output mode is otherwise
      aligned.)
      </para>
      </listitem>
    </varlistentry>

	
    <varlistentry>
      <term>-c, --command <replaceable class="parameter">query</replaceable></term>
      <listitem>
      <para>
      Specifies that <application>psql</application>
      is to execute one query string, <replaceable class="parameter">query</replaceable>,
      and then exit.  This is useful in shell scripts.
      </para>
      <para>
      <replaceable class="parameter">query</replaceable> must be either a query string
      that is completely parseable by the backend (i.e., it contains no <application>psql</application>
      specific features), or it is a single backslash command. Thus
      you cannot mix <acronym>SQL</acronym> and <application>psql</application>
      meta-commands. To achieve this you could pipe the string into
      <application>psql</application>, like so:
      <literal>echo "\x \\ select * from foo;" | psql</literal>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-d, --dbname <replaceable class="parameter">dbname</replaceable></term>
      <listitem>
      <para>
      Specifies the name of the database to connect to. This is equivalent to specifying
      <replaceable class="parameter">dbname</replaceable> as the first non-option
      argument on the command line.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-e, --echo-queries</term>
      <listitem>
      <para>
      Show all queries that are sent to the backend.
      This is equivalent to setting the variable <envar>ECHO</envar>
      to <literal>queries</literal>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-E, --echo-hidden</term>
      <listitem>
      <para>
      Echos the actual queries generated by \d and other backslash commands.
      You can use this if you wish to include similar functionality into
      your own programs. This is equivalent to setting the variable
      <envar>ECHO_HIDDEN</envar> from within <application>psql</application>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-f, --file <replaceable class="parameter">filename</replaceable></term>
      <listitem>
      <para>
      Use the file <replaceable class="parameter">filename</replaceable>
      as the source of queries instead of reading queries interactively.
      After the file is processed, <application>psql</application> terminates.
      This in many ways equivalent to the internal command <command>\i</command>.
      </para>
      <para>
      Using this option is subtly different from writing
      <literal>psql &lt; <replaceable class="parameter">filename</replaceable></literal>.
      In general, both will do what you expect, but using <literal>-f</literal>
      enables some nice features such as error messages with line numbers.
      There is also a slight chance that using this option will reduce
      the startup overhead. On the other hand, the variant using the shell's
      input redirection is (in theory) guaranteed to yield exactly the same
      output that you would have gotten had you entered everything by hand.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-F, --field-separator <replaceable class="parameter">separator</replaceable></term>
      <listitem>
      <para>
      Use <replaceable class="parameter">separator</replaceable> as the field separator.
      This is equivalent to <command>\pset fieldsep</command> or <command>\f</command>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-h, --host <replaceable class="parameter">hostname</replaceable></term>
      <listitem>
      <para>
      Specifies the host name of the machine on which the
      <application>postmaster</application> is running.
      Without this option, communication is performed using
      local Unix domain sockets.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-H, --html</term>
      <listitem>
      <para>
      Turns on <acronym>HTML</acronym> tabular output. This is equivalent
      to <literal>\pset format html</literal> or the <command>\H</command>
      command.
      </para>
      </listitem>
    </varlistentry>

 
    <varlistentry>
      <term>-l, --list</term>
      <listitem>
      <para>
      Lists all available databases, then exits. Other non-connection options
      are ignored. This is similar to the internal command <command>\list</command>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-o, --output <replaceable class="parameter">filename</replaceable></term>
      <listitem>
      <para>
      Put all query output into file <replaceable class="parameter">filename</replaceable>.
      This is equivalent to the command <command>\o</command>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-p, --port <replaceable class="parameter">port</replaceable></term>
      <listitem>
      <para>
      Specifies the TCP/IP port or, by omission, the local Unix domain socket file
      extension on which the <application>postmaster</application>
      is listening for connections.  Defaults to the value of the
      <envar>PGPORT</envar> environment variable or, if not set, to the port
      specified at compile time, usually 5432.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-P, --pset <replaceable class="parameter">assignment</replaceable></term>
      <listitem>
      <para>
      Allows you to specify printing options in the style of <command>\pset</command>
      on the command line. Note that here you have to separate name and value with
      an equal sign instead of a space. Thus to set the output format to LaTeX, you
      could write <literal>-P format=latex</literal>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-q</term>
      <listitem>
      <para>
      Specifies that <application>psql</application> should do its work quietly.
      By default, it prints welcome messages and various informational output.
      If this option is used, none of this happens. This is useful with the
      <option>-c</option> option. Within <application>psql</application> you can
      also set the <envar>QUIET</envar> variable to achieve the same effect.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-R, --record-separator <replaceable class="parameter">separator</replaceable></term>
      <listitem>
      <para>
      Use <replaceable class="parameter">separator</replaceable> as the record separator.
      This is equivalent to the <command>\pset recordsep</command> command.
      </para>
      </listitem>
    </varlistentry>

 
    <varlistentry>
      <term>-s, --single-step</term>
      <listitem>
      <para>
      Run in single-step mode. That means the user is prompted before each query
      is sent to the backend, with the option to cancel execution as well.
      Use this to debug scripts.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-S, --single-line</term>
      <listitem>
      <para>
      Runs in single-line mode where a newline terminates a query, like a semicolon would do.
      </para>

      <note>
      <para>
      This mode is provided for those who insist on it, but you are not necessarily
      encouraged to use it. In particular, if you mix <acronym>SQL</acronym> and
      meta-commands on a line the order of execution might not always be clear to
      the unexperienced user.
      </para>
      </note>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-t, --tuples-only</term>
      <listitem>
      <para>
      Turn off printing of column names and result row count footers, etc.
      It is completely equivalent to the <command>\t</command>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-T, --table-attr <replaceable class="parameter">table_options</replaceable></term>
      <listitem>
      <para>
      Allows you to specify options to be placed within the <acronym>HTML</acronym>
      <sgmltag>table</sgmltag> tag. See <command>\pset</command> for details.
      </para>
      </listitem>
    </varlistentry>

 
    <varlistentry>
      <term>-u</term>
      <listitem>
      <para>
      Makes <application>psql</application> prompt for the user name and password
      before connecting to the database.
      </para>

      <para>
      This option is deprecated, as it is conceptually flawed. (Prompting for
      a non-default user name and prompting for a password because the
      backend requires it are really two different things.) You are encouraged
      to look at the <option>-U</option> and <option>-W</option> options instead.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-U, --username <replaceable class="parameter">username</replaceable></term>
      <listitem>
      <para>
      Connects to the database as the user <replaceable class="parameter">username</replaceable>
      instead of the default. (You must have permission to do so, of course.)
      </para> 
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-v, --variable, --set <replaceable class="parameter">assignment</replaceable></term>
      <listitem>
      <para>
      Performs a variable assignment, like the <command>\set</command> internal command.
      Note that you must separate name and value, if any, by an equal sign on the command
      line. To unset a variable, leave off the equal sign. These assignments are done
      during a very early state of startup, so variables reserved for internal purposes
      might get overwritten again.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-V, --version</term>
      <listitem>
      <para>
      Shows the <application>psql</application> version.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-W, --password</term>
      <listitem>
      <para>
      Requests that <application>psql</application> should prompt for a password
      before connecting to a database. This will remain set for the entire
      session, even if you change the database connection with the meta-command
      <command>\connect</command>.
      </para>

      <para>
      As of version 7.0, <application>psql</application> automatically issues a
      password prompt whenever the backend requests password authentication.
      Because this is currently based on a <quote>hack</quote>, the automatic
      recognition might mysteriously fail, hence this option to force a prompt.
      If no password prompt is issued and the backend requires password authentication
      the connection attempt will fail.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-x, --expanded</term>
      <listitem>
      <para>
      Turns on extended row format mode. This is equivalent to the command
      <command>\x</command>.
      </para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>-?, --help</term>
      <listitem>
      <para>
      Shows help about <application>psql</application> command line arguments.
      </para>
      </listitem>
    </varlistentry>

  </variablelist>
  </para>

</refsect1>


<refsect1 id="R1-APP-PSQL-4">
    <refsect1info>
      <date>1998-09-27</date>
    </refsect1info>

    <title>Advanced features</title>

  <refsect2 id="APP-PSQL-variables">
    <title id="APP-PSQL-variables-title">Variables</title>

    <para>
    <application>psql</application> provides variable substitution features
    similar to common Unix command shells. This feature is new and not very
    sophisticated, yet, but there are plans to expand it in the future.
    Variables are simply name/value
    pairs, where the value can be any string of any length. To set variables,
    use the <application>psql</application> meta-command <command>\set</command>:
<programlisting>
testdb=> <userinput>\set foo bar</userinput>
</programlisting>
    sets the variable <quote>foo</quote> to the value <quote>bar</quote>. To retrieve
    the content of the variable, precede the name with a colon and use it
    as the argument of any slash command:
<programlisting>
testdb=> <userinput>\echo :foo</userinput>
bar
</programlisting>
    </para>

    <note>
    <para>
    The arguments of <command>\set</command> are subject to the same substitution
    rules as with other commands. Thus you can construct interesting references
    such as <literal>\set :foo 'something'</literal> and get <quote>soft
    links</quote> or <quote>variable variables</quote> of <productname>Perl</productname>
    or <productname><acronym>PHP</acronym></productname> fame, respectively.
    Unfortunately (or fortunately?), there is not way to do anything useful
    with these constructs. On the
    other hand, <literal>\set bar :foo</literal> is a perfectly valid way to copy
    a variable.
    </para>
    </note>

    <para>
    If you call <command>\set</command> without a second argument, the variable is simply
    set, but has no value. To unset (or delete) a variable, use the command
    <command>\unset</command>.
    </para>

    <para>
    <application>psql</application>'s internal variable names can consist of
    letters, numbers, and underscores in any order and any number of them.
    A number of regular variables are treated specially by <application>psql</application>.
    They indicate certain option settings that can be changed at runtime
    by altering the value of the variable or represent some state of the application.
    Although you can use these
    variables for any other purpose, this is not recommended, as the
    program behavior might grow really strange really quickly.
    By convention, all specially treated variables consist of all upper-case letters
    (and possibly numbers and underscores). To ensure maximum compatibility in the
    future, avoid such variables. 
    A list of all specially treated variables follows.
    <variablelist>
      <varlistentry>
        <term><envar>DBNAME</envar></term>
	<listitem>
	<para>
        The name of the database you are currently connected to. This is set everytime
        you connect to a database (including program startup), but can be unset.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>ECHO</envar></term>
	<listitem>
	<para>
	If set to <quote><literal>all</literal></quote>, all lines entered or from a script
        are written to the standard output before they
	are parsed or executed. To specify this on program startup, use the switch
        <option>-a</option>. If set to <quote><literal>queries</literal></quote>,
        <application>psql</application> merely prints all queries as they are sent to the
        backend. The option for this is <option>-e</option>.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>ECHO_HIDDEN</envar></term>
	<listitem>
	<para>
	When this variable is set and a backslash command queries the database, the query
	is first shown. This way you can study the <productname>PostgreSQL</productname>
	internals and provide similar functionality in your own programs. If you set the
	variable to the value <quote>noexec</quote>, the queries are just shown but are
	not actually sent to the backend and executed.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>ENCODING</envar></term>
	<listitem>
	<para>
        The current client multibyte encoding. If you are not set up to use
        multibyte characters, this variable will always contain
        <quote>SQL_ASCII</quote>.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>HISTCONTROL</envar></term>
	<listitem>
	<para>
         If  this variable is set  to  <literal>ignorespace</literal>, lines which begin with a
         space are not entered into the history list. If set to a value of
         <literal>ignoredups</literal>, lines matching the previous history line are not
         entered. A value of <literal>ignoreboth</literal> combines the two
         options.  If unset, or if set to any other value than those above, all lines read
         in interactive mode are saved on the history list.
	</para>
        <note>
        <para>
        This feature was shamelessly plagiarized from <application>bash</application>.
        </para>
        </note>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>HISTSIZE</envar></term>
	<listitem>
	<para>
        The number of commands to store in the command history.
        The default value is 500.
	</para>
        <note>
        <para>
        This feature was shamelessly plagiarized from <application>bash</application>.
        </para>
        </note>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>HOST</envar></term>
	<listitem>
	<para>
        The database server host you are currently connected to. This is set everytime
        you connect to a database (including program startup), but can be unset.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>IGNOREEOF</envar></term>
	<listitem>
	<para>
         If unset, sending an EOF character (usually Control-D) to an interactive session of
         <application>psql</application> will terminate the application.
         If set to a numeric value, that many EOF characters are ignored before the application
         terminates. If the variable is set but has no numeric value, the default is 10.
	</para>
        <note>
        <para>
        This feature was shamelessly plagiarized from <application>bash</application>.
        </para>
        </note>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>LASTOID</envar></term>
	<listitem>
	<para>
        The value of the last affected oid, as returned from an <command>INSERT</command>
        or <command>lo_insert</command> commmand. This variable is only guaranteed to be
        valid until after the result of the next <acronym>SQL</acronym> command has been
        displayed.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>LO_TRANSACTION</envar></term>
	<listitem>
	<para>
	If you use the <productname>PostgreSQL</productname> large object
        interface to specially store data that does not fit into one tuple,
        all the operations must be contained in a transaction block. (See the
        documentation of the large object interface for more information.) Since
        <application>psql</application> has no way to keep track if you already
        have a transaction in progress when you call one of its internal
        commands <command>\lo_export</command>, <command>\lo_import</command>,
        <command>\lo_unlink</command> it must take some arbitrary action. This
        action could either be to roll back any transaction that might already
        be in progress, or to commit any such transaction, or to do nothing at
        all. In the latter case you must provide you own
        <command>BEGIN TRANSACTION</command>/<command>COMMIT</command> block or
        the results will be unpredictable (usually resulting in the desired
        action not being performed in any case).
	</para>

	<para>
	To choose what you want to do you set this variable to one of
	<quote>rollback</quote>, <quote>commit</quote>, or <quote>nothing</quote>.
        The default is to roll back the transaction. If you just want to load one
        or a few objects this is fine. However, if you intend to transfer many
        large objects, it might be advisable to provide one explicit transaction
        block around all commands.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>ON_ERROR_STOP</envar></term>
	<listitem>
	<para>
	By default, if non-interactive scripts encounter an error, such as a
	malformed <acronym>SQL</acronym> query or internal meta-command,
	processing continues. This is has been the traditional behaviour of
        <application>psql</application> but it is sometimes not desirable. If this variable
	is set, script processing will immediately terminate. If the script was
	called from another script it will terminate in the same fashion.
	If the outermost script was not called from an interactive <application>psql</application>
	session but rather using the <option>-f</option> option, <application>psql</application>
	will return error code 3, to distinguish this case from fatal
	error conditions (error code 1).
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>PORT</envar></term>
	<listitem>
	<para>
        The database server port you are currently connected to. This is set everytime
        you connect to a database (including program startup), but can be unset.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>PROMPT1</envar>, <envar>PROMPT2</envar>, <envar>PROMPT3</envar></term>
	<listitem>
	<para>
	These specify what the prompt <application>psql</application> issues is
	supposed to look like. See
	<quote><xref linkend="APP-PSQL-prompting" endterm="APP-PSQL-prompting-title"></quote>
	below.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>QUIET</envar></term>
	<listitem>
	<para>
	This variable is equivalent to the command line option <option>-q</option>.
	It is probably not too useful in interactive mode.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>SINGLELINE</envar></term>
	<listitem>
	<para>
	This variable is set be the command line options <option>-S</option>. You
	can unset or reset it at run time.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>SINGLESTEP</envar></term>
	<listitem>
	<para>
	This variable is equivalent to the command line option <option>-s</option>.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><envar>USER</envar></term>
	<listitem>
	<para>
        The database user you are currently connected as. This is set everytime
        you connect to a database (including program startup), but can be unset.
	</para>
	</listitem>
      </varlistentry>

    </variablelist>

    </para>

  </refsect2>


  <refsect2 id="APP-PSQL-sql-interpol">
    <title id="APP-PSQL-sql-interpol-title"><acronym>SQL</acronym> Interpolation</title>

    <para>
    An additional useful feature of <application>psql</application> variables
    is that you can substitute (<quote>interpolate</quote>) them into
    regular <acronym>SQL</acronym> statements. The syntax for this is again to prepend
    the variable name with a colon (<literal>:</literal>).
<programlisting>
testdb=> <userinput>\set foo 'my_table'</userinput>
testdb=> <userinput>SELECT * FROM :foo;</userinput>
</programlisting>
    would then query the table <literal>my_table</literal>. The value of the
    variable is copied literally, so it can even contain unbalanced quotes or
    backslash commands. You must make sure that it makes sense where you put it.
    Variable interpolation will not be performed into quoted <acronym>SQL</acronym>
    entities.
    </para>

    <para>
    A popular application of this facility is to refer to the last inserted
    <acronym>OID</acronym> in subsequent statement to build a foreign key
    scenario.
    Another possible use of this mechanism is to copy the contents of a file
    into a field. First load the file into a variable and then proceed as above.
<programlisting>
testdb=> <userinput>\set content '\'' `cat my_file.txt` '\''</userinput>
testdb=> <userinput>INSERT INTO my_table VALUES (:content);</userinput>
</programlisting>
    One possible problem with this approach is that <filename>my_file.txt</filename>
    might contain single quotes. These need to be escaped so that
    they don't cause a syntax error when the third line is processed. This
    could be done with the program <application>sed</application>:
<programlisting>
testdb=> <userinput>\set content `sed -e "s/'/\\\\\\'/g" < my_file.txt`</userinput>
</programlisting>
    Observe the correct number of backslashes (6)! You can resolve it this way: After
    <application>psql</application> has parsed this line, it passes
    <literal>sed -e "s/'/\\\'/g" < my_file.txt</literal> to the shell. The shell
    will do it's own thing inside the double quotes and execute <filename>sed</filename>
    with the arguments <literal>-e</literal> and <literal>s/'/\\'/g</literal>.
    When <application>sed</application> parses this it will replace the two
    backslashes with a single one and then do the substitution. Perhaps at
    one point you thought it was great that all Unix commands use the same
    escape character. And this is ignoring the fact that you might have to
    escape all backslashes as well because <acronym>SQL</acronym> text constants
    are also subject to certain interpretations. In that case you might
    be better off preparing the file externally.
    </para>

    <para>
    Since colons may legally appear in queries, the following rule applies: If the variable
    is not set, the character sequence <quote>colon+name</quote> is not changed. In any
    case you can escape a colon with a backslash to protect it from interpretation.
    (The colon syntax for variables is standard <acronym>SQL</acronym> for embedded
    query languages, such as <application>ecpg</application>. The colon syntax for
    array slices and type casts are <productname>PostgreSQL</productname> extensions,
    hence the conflict.)
    </para>

  </refsect2>


  <refsect2 id="APP-PSQL-prompting">
    <title id="APP-PSQL-prompting-title">Prompting</title>

    <para>
    The prompts <application>psql</application> issues can be customized to
    your preference. The three variables <envar>PROMPT1</envar>, <envar>PROMPT2</envar>,
    and <envar>PROMPT3</envar> contain strings and special escape sequences
    that describe the appearance of the prompt. Prompt 1 is the normal prompt
    that is issued when <application>psql</application> requests a new query.
    Prompt 2 is issued when more input is expected during query input because
    the query was not terminated with a semicolon or a quote was not closed.
    Prompt 3 is issued when you run an <acronym>SQL</acronym> <command>COPY</command>
    command and you are expected to type in the tuples on the terminal.
    </para>

    <para>
    The value of the respective prompt variable is printed literally, except where
    a percent sign (<quote>%</quote>) is encountered. Depending on the next
    character, certain other text is substituted instead. Defined substitutions are:

    <variablelist>
      <varlistentry>
        <term><literal>%M</literal></term>
	<listitem><para>The hostname of the database server (or <quote>.</quote>
         if Unix domain socket).</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%m</literal></term>
	<listitem><para>The hostname of the database server truncated after the
         first dot.</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%&gt;</literal></term>
	<listitem><para>The port number at which the database server is listening.</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%n</literal></term>
	<listitem><para>The username you are connected as (not your local system
         user name).</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%/</literal></term>
	<listitem><para>The name of the current database.</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%~</literal></term>
	<listitem><para>Like <literal>%/</literal>, but the output is <quote>~</quote>
         (tilde) if the database is your default database.</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%#</literal></term>
	<listitem><para>If the current user is a database superuser, then a
         <quote>#</quote>, otherwise a <quote>&gt;</quote>.</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%R</literal></term>
	<listitem><para>
	In prompt 1 normally <quote>=</quote>, but <quote>^</quote> if in single-line
        mode, and <quote>!</quote> if the session is disconnected from the database
        (which can happen if <command>\connect</command> fails). In prompt 2 the
        sequence is replaced by <quote>-</quote>, <quote>*</quote>, a single quote,
	or a double quote, depending on whether <application>psql</application>
        expects more input because the query wasn't terminated yet, because you are
        inside a <literal>/* ... */</literal> comment, or because you are inside
        a quote. In prompt 3 the sequence doesn't resolve to anything.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%</literal><replaceable class="parameter">digits</replaceable></term>
	<listitem><para>
	If <replaceable class="parameter">digits</replaceable> starts with
        <literal>0x</literal> the rest of the characters are interpreted at a
        hexadecimal digit and the character with the corresponding code is
        subsituted. If the first digit is <literal>0</literal> the characters are
        interpreted as on octal number and the corresponding character is
        substituted. Otherwise a decimal number is assumed.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%:</literal><replaceable class="parameter">name</replaceable><literal>:</literal></term>
	<listitem><para>
	The value of the <application>psql</application>, variable <replaceable
        class="parameter">name</replaceable>. See the section
	<quote><xref linkend="APP-PSQL-variables" endterm="APP-PSQL-variables-title"></quote>
	for details.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%`</literal><replaceable class="parameter">command</replaceable><literal>`</literal></term>
	<listitem><para>
	The output of <replaceable class="parameter">command</replaceable>, similar to
	ordinary <quote>back-tick</quote> substitution.</para>
	</listitem>
      </varlistentry>

    </variablelist>

    To insert a percent sign into your prompt, write <literal>%%</literal>. The
    default prompts are equivalent to <literal>'%/%R%# '</literal> for prompts 1
    and 2, and <literal>'&gt;&gt; '</literal> for prompt 3.
    </para>

    <note>
    <para>
    This feature was shamelessly plagiarized from <application>tcsh</application>.
    </para>
    </note>

   </refsect2>

  <refsect2 id="APP-PSQL-MISC">
    <title id="APP-PSQL-MISC-title">Miscellaneous</title>

    <para>
    <application>psql</application> returns 0 to the shell if it finished normally,
    1 if a fatal error of its own (out of memory, file not found) occurs, 2 if the
    connection to the backend went bad and the session is not interactive, and 3 if
    an error occurred in a script and the variable <envar>ON_ERROR_STOP</envar> was
    set.
    </para>

    <para>
    Before starting up in interactive mode, <application>psql</application> attempts
    to read and execute commands from the file <filename>$HOME/.psqlrc</filename>. It
    could be used to set up the client or the server to taste (using the <command>\set
    </command> and <command>SET</command> commands).
    </para>

  </refsect2>

  <refsect2>
    <title><acronym>GNU</acronym> readline</title>

    <para>
    <application>psql</application> supports the readline and history libraries for
    convenient line editing and retrieval. The command history is stored in a file
    named <filename>.psql_history</filename> in your home directory and is reloaded when
    <application>psql</application> starts up.
    Tab-completion is also supported, although
    the completion logic makes no claim to be an <acronym>SQL</acronym> parser.
    When available, <application>psql</application> is automatically built to use these
    features. If for some reason you do not like the tab completion, you can turn if off
    by putting this in a file named <filename>.inputrc</filename> in your
    home directory:
<programlisting>
$if psql
set disable-completion on
$endif
</programlisting>
    (This is not a <application>psql</application> but a <application>readline</application>
    feature. Read its documentation for further details.)
    </para>

    <para>
    If you have the readline library installed but <application>psql</application>
    does not seem to use it, you must make sure that <productname>PostgreSQL</productname>'s
    top-level <filename>configure</filename> script finds it. <filename>configure</filename>
    needs to find both the library <filename>libreadline.a</filename>
    (or <filename>libreadline.so</filename> on systems with shared libraries)
    <emphasis>and</emphasis> the header files <filename>readline.h</filename> and
    <filename>history.h</filename> (or <filename>readline/readline.h</filename> and
    <filename>readline/history.h</filename>) in appropriate directories. If
    you have the library and header files installed in an obscure place you
    must tell <filename>configure</filename> about them, for example:
<programlisting>
$ ./configure --with-includes=/opt/gnu/include --with-libs=/opt/gnu/lib  ...
</programlisting>
    Then you have to recompile <application>psql</application> (not necessarily
    the entire code tree).
    </para>

    <para>
    The <acronym>GNU</acronym> readline library can be obtained from the <acronym>GNU</acronym>
    project's <acronym>FTP</acronym> server at <ulink URL="ftp://ftp.gnu.org">ftp://ftp.gnu.org</ulink>.
    </para>
  </refsect2>



</refsect1>


<refsect1 id="APP-PSQL-examples">
  <title id="APP-PSQL-examples-title">Examples</title>

  <note>
  <para>
  This section only shows a few examples specific to <application>psql</application>.
  If you want to learn <acronym>SQL</acronym> or get familiar with
  <productname>PostgreSQL</productname>, you might wish to read the Tutorial that
  is included in the distribution.
  </para>
  </note>

  <para>
  The first example shows how to spread a query over several lines of input.
  Notice the changing prompt.
<programlisting>
testdb=> <userinput>CREATE TABLE my_table (</userinput>
testdb-> <userinput> first integer not null default 0,</userinput>
testdb-> <userinput> second text</userinput>
testdb-> <userinput>);</userinput>
CREATE
</programlisting>
  Now look at the table definition again:
<programlisting>
testdb=> <userinput>\d my_table</userinput>
             Table "my_table"
 Attribute |  Type   |      Modifier
-----------+---------+--------------------
 first     | integer | not null default 0
 second    | text    |

</programlisting>
  At this point you decide to change the prompt to something more
  interesting:
<programlisting>
testdb=> <userinput>\set PROMPT1 '%n@%m %~%R%# '</userinput>
peter@localhost testdb=>
</programlisting>
  Let's assume you have filled the table with data and want to take a look at it:
<programlisting>
peter@localhost testdb=> SELECT * FROM my_table;
 first | second
-------+--------
     1 | one
     2 | two
     3 | three
     4 | four
(4 rows)

</programlisting>
  Notice how the int4 colums in right aligned while the text column in left aligned.
  You can make this table look differently by using the <command>\pset</command>
  command.
<programlisting>
peter@localhost testdb=> <userinput>\pset border 2</userinput>
Border style is 2.
peter@localhost testdb=> <userinput>SELECT * FROM my_table;</userinput>
+-------+--------+
| first | second |
+-------+--------+
|     1 | one    |
|     2 | two    |
|     3 | three  |
|     4 | four   |
+-------+--------+
(4 rows)

peter@localhost testdb=> <userinput>\pset border 0</userinput>
Border style is 0.
peter@localhost testdb=> <userinput>SELECT * FROM my_table;</userinput>
first second
----- ------
    1 one
    2 two
    3 three
    4 four
(4 rows)

peter@localhost testdb=> <userinput>\pset border 1</userinput>
Border style is 1.
peter@localhost testdb=> <userinput>\pset format unaligned</userinput>
Output format is unaligned.
peter@localhost testdb=> <userinput>\pset fieldsep ","</userinput>
Field separator is ",".
peter@localhost testdb=> <userinput>\pset tuples_only</userinput>
Showing only tuples.
peter@localhost testdb=> <userinput>SELECT second, first FROM my_table;</userinput>
one,1
two,2
three,3
four,4
</programlisting>
  Alternatively, use the short commands:
<programlisting>
peter@localhost testdb=> <userinput>\a \t \x</userinput>
Output format is aligned.
Tuples only is off.
Expanded display is on.
peter@localhost testdb=> <userinput>SELECT * FROM my_table;</userinput>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four
</programlisting>
  </para>

</refsect1>


<refsect1>
  <refsect1info>
    <date>1999-10-27</date>
  </refsect1info>

  <title>Appendix</title>

  <refsect2>
    <title>Bugs and Issues</title>

    <itemizedlist>
      <listitem>
      <para>
      In some earlier life <application>psql</application> allowed the first
      argument to start directly after the (single-letter) command. For
      compatibility this is still supported to some extent but I am not
      going to explain the details here as this use is discouraged. But
      if you get strange messages, keep this in mind. For example
<programlisting>
testdb=> <userinput>\foo</userinput>
Field separator is "oo".
</programlisting>
      is perhaps not what one would expect.
      </para>
      </listitem>

      <listitem>
      <para>
      <application>psql</application> only works smootly with servers of the
      same version. That does not mean other combinations will fail outright,
      but subtle and not-so-subtle problems might come up.
      </para>
      </listitem>

    </itemizedlist>

  </refsect2>

</refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
