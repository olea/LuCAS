<Chapter Id="arch-pg">
	<TITLE>Arquitectura</TITLE>

<Sect1>
<Title>Conceptos de Arquitectura de <ProductName>Postgres</ProductName></Title>

<Para>
     Antes de continuar, debería usted conocer la arquitectura básica del sistema 
     <ProductName>Postgres</ProductName>. El conocimiento de como interactúan las partes 
     de <ProductName>Postgres</ProductName> debería aclararse algo durante el siguiente capítulo.
     En la jerga de las bases de datos, <ProductName>Postgres</ProductName> utiliza un simple modelo 
     cliente/servidor de "proceso por usuario".  Una sesión de <ProductName>Postgres</ProductName> 
     consiste en los siguientes procesos Unix (programas) cooperando:

<ItemizedList>
<ListItem>
<Para>
        Un proceso demonio supervisor (<Application>postmaster</Application>),
</Para>
</ListItem>
<ListItem>
<Para>
        la aplicación de interface del usuario (frontend en inglés) (por ejemplo, el programa <Application>psql</Application>), y
</Para>
</ListItem>
<ListItem>
<Para>
        los uno o más procesos servidores de acceso a la base de datos (backend en inglés) 
        (el proceso <Application>postgres</Application> mismo).
</Para>
</ListItem>
</ItemizedList>
</para>
<Para>
     Un único <Application>postmaster</Application> maneja una colección dada de bases de datos en 
     único host.  Tal colección se denomina una instalación o un site.  Las aplicaciones de frontend 
     que quieren acceder a una base de datos dada en una instalación realizan llamadas a la librería. 
     La librería envía el requerimiento del usuario a través de la red al <Application>postmaster</Application>
(<XRef LinkEnd="PGARCH-CONNECTIONS" EndTerm="PGARCH-CONNECTIONS">(a)), 
quien en su turno arranca un nuevo proceso servidor de backend
(<XRef LinkEnd="PGARCH-CONNECTIONS" EndTerm="PGARCH-CONNECTIONS">(b)) 
     
<Figure Id="PGARCH-CONNECTIONS">
<Title>Cómo se establece una conexión</Title>
<Graphic Align="center" FileRef="connections.gif" Format="GIF"></Graphic>
</Figure>

     y se conecta el proceso cliente al nuevo servidor
(<XRef LinkEnd="PGARCH-CONNECTIONS" EndTerm="PGARCH-CONNECTIONS">(c)).
>
A partir de aquí, el proceso cliente y el servidor se comunican entre ellos sin intervención del 
<Application>postmaster</Application>.  En consecuencia, el proceso 
<Application>postmaster</Application> está siempre corriendo, esperando llamadas, mientras que los 
procesos cliente y servidor vienen y van.  La librería <FileName>libpq</FileName> permite a un único 
proceso cliente tener múltiples conexiones con procesos servidores.  Sin embargo, la aplicación cliente 
sigue siendo un proceso mono-hebra.  Las conexiones con multihebrado cliente/servidor no están 
actualmente soportadas en <FileName>libpq</FileName>.  Una implicación de esta arquitectura es que el 
<Application>postmaster</Application> y los servidores siempre corren en la misma máquina 
(el servidor de base de datos), mientras que el cliente puede correr en cualquier sitio.  
Debe usted tener esto en cuenta, ya que los ficheros que pueden estar accesibles en una máquina cliente, 
pueden no estarlo (o estarlo sólo con un nombre de fichero diferente) en la máquina servidor.  
Debería tener también en cuenta que <Application>postmaster</Application> y los servidores postgres 
corren bajo el user-id del "superusuario" de <ProductName>Postgres</ProductName>.
Nótese que el superusuario de <ProductName>Postgres</ProductName> no tiene porqué ser un usuario 
especial (es decir, un usuario llamado "postgres"), aunque en muchos sistemas esté instalado así. 
Más aún, el superusuario de <ProductName>Postgres</ProductName> definitivamente 
¡no debe de ser el superusuario de Unix, "root"! En cualquier caso, todos los ficheros relacionados 
con una base de datos deben encontrarse bajo este superusuario de <ProductName>Postgres</ProductName>.
</Para>
</sect1>
</Chapter>
