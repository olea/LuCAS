<appendix label="DG1" id="cvs"> 
 <docinfo>
  <authorgroup>
   <author>
    <firstname>Marc</firstname>
    <surname>Fournier</surname>
   </author>
   <author>
    <firstname>Tom</firstname>
    <surname>Lane</surname>
   </author>
   <author>
    <firstname>Thomas</firstname>
    <surname>Lockhart</surname>
   </author>
  </authorgroup>
  <date>1999-05-20</date>
 </docinfo>

 <title>El Repositorio del <productname>CVS</productname></title>

 <para>
  El código fuente de <productname>Postgres</productname> se almacena y administra
  utiliando el sistema de gestión de código <productname>CVS</productname>.
 </para>

 <para>
  Hay al menos dos métodos, CVS anónimo y <productname>CVSup</productname>, utilizables
  para copiar el árbol del código de <productname>CVS</productname> desde el servidor de
  <productname>Postgres</productname> a su máquina local.
 </para>

 <sect1>
  <title>Organización del árbol de <productname>CVS</productname></title>

  <para>
   <note>
    <title>Author</title>
    <para>
     Escrito por <ulink url="mailto:scrappy@hub.org">Marc G. Fournier</ulink> el 1998-11-05.
    </para>
   </note>
   <note>
    <title>Traductor</title>
    <para>
     Traducido por <ulink url="mailto:doc-postgresql-es@listas.hispalinux.org">Equipo de traducción de PostgreSQL</ulink> el 2001-03-14.
    </para>
   </note>
  </para>

  <para>(N. del T: Ismael Olea ha escrito un estupendo documento llamado 
  <emphasis><quote>Micro-cómo empezar a trabajar con cvs</quote></emphasis>, muy facil de 
  entender y de utilizar, y que puede resultar muy interesante para los que sólo deseen 
  utilizar un cliente de CVS de modo genérico. Como él
  también colabora en la traducción, no puedo por menos de recomendarlo.
  </para>

  <para> Lo pueden conseguir en su <ulink
  url="http://slug.HispaLinux.ES/~olea/micro-como-empezar-con-cvs.html">página
  personal</ulink> y desde luego pidiendoselo directamente a él <ulink
  url="mailto:olea@hispafuentes.com">olea@hispafuentes.com</ulink>.  Fin de
  la N. del T.) </para>

  <para>
   El comando <command>cvs checkout</command> tiene un indicador (flag), <option>-r</option>,
   que le permite comprobar una cierta revisión de un módulo. Este indicador facilita también,
   por ejemplo, recuperar las fuentes que formaban la release 1.0 del módulo `tc' en cualquier
   momento futuro:

   <programlisting>
$ cvs checkout -r REL6_4 tc
   </programlisting>

   Esto es utilizable, por ejemplo, si alguien asegura que hay un error (un bug) en esa 
   release, y usted no es capaz de encontrarlo en la copia de trabajo actual.

   <tip>
    <para>
     También puede usted comprobar un módulo conforme era en cualquier momento dado 
     utilizando la opción <option>-D</option>.
    </para>
   </tip>
  </para>

  <para>
   Cuando etiquete usted más de un fichero con la misma etiqueta, puede usted pensar en 
   las etiquetas como "una línea curva que recorre una matriz de nombres de ficheros contra
   número de revisión". Digamos que tenemos 5 ficheros con las siguientes revisiones:
   
   <programlisting>
             fich1   fich2   fich3   fich4   fich5
     
             1.1     1.1     1.1     1.1  /--1.1*      <-*-  TAG (etiqueta)
             1.2*-   1.2     1.2    -1.2*-
             1.3  \- 1.3*-   1.3   / 1.3
             1.4          \  1.4  /  1.4
                           \-1.5*-   1.5
                             1.6
   </programlisting>

   donde la etiqueta <quote><literal>TAG</literal></quote> hará referencia a 
   fich1-1.2, fich2-1.3, etc.

   <note>
    <para>
     Para crear la rama de una nueva release, se emplea de nuevo el comando -b, 
     del mismo modo anterior.</para>
   </note>
  </para>

  <para>
   De este modo, para crear la release v6.4, hice lo siguiente:

   <programlisting>
$ cd pgsql
$ cvs tag -b REL6_4
   </programlisting>

   lo cual creará la etiqueta y la rama para el árbol RELEASE.
  </para>

  <para>
   Ahora, para aquellos con acceso <productname>CVS</productname>, también es sencillo.
   Primero, cree dos subdirectorios, RELEASE y CURRENT, de forma que no mezcle usted los
   dos. A continuación haga:

   <programlisting>
cd RELEASE
cvs checkout -P -r REL6_4 pgsql
cd ../CURRENT
cvs checkout -P pgsql
   </programlisting>

   lo que dará lugar a dos árboles de directorios, <filename>RELEASE/pgsql</filename> y
   <filename>CURRENT/pgsql</filename>. A partir de este momento, 
   <productname>CVS</productname> tomará el control de qué rama del repositorio se encuentra
   en cada árbol de directorios, y permitirá actualizaciones independientes de cada árbol.
  </para>

  <para>
   Si usted <emphasis>sólo</emphasis> está trabajando en el árbol fuente 
   <literal>CURRENT</literal> hágalo todo tal como empezamos antes etiquetando
   las ramas de la release.

   If you are <emphasis>only</emphasis> working on the <literal>CURRENT</literal>
   source tree, you just do
   everything as before we started tagging release branches.
  </para>

  <para>
   Una vez que usted realiza el checkout (igualado, comprobación, descarga)
   inicial en una rama, 

   <programlisting>
$ cvs checkout -r REL6_4
   </programlisting>

   todo lo que usted haga dentro de esa estructura de directorios se restringe a esa rama.
   Si usted aplica un patch a esa estructura de directorios y hace un

   <programlisting>
cvs commit
   </programlisting>

   mientras usted se encuentra dentro de ella, el patch se aplica a esa rama y 
   <emphasis>sólo</emphasis> a esa rama.
  </para>
 </sect1>

 <sect1>
  <title>Tomando Las Fuentes Vía <productname>CVS</productname> Anónimo</title>

  <para>
   Si quisiera usted mantenerse proximo a las fuentes actuales de una forma regular, 
   podría usted ir a buscarlos a nuestro propio servidor <productname>CVS</productname>
   y utilizar entonces <productname>CVS</productname> para recuperar las actualizaciones
   de tiempo en tiempo.
  </para>

  <procedure>
   <title>CVS Anónimo</title>

   <step>
    <para>
     Necesitará usted una copia local de <productname>CVS</productname> 
     (Concurrent Version Control System, Sistema de Control de Versiones 
     Concurrentes -simultáneas-), que puede usted tomar de 
     <ulink url="http://www.cyclic.com/">http://www.cyclic.com/</ulink> o 
     cualquier otra dirección que archive software GNU.
     Actualmente recomendamos la versión 1.10 (la más reciente en el momento de escribir).
     Muchos sistemas tienen una versión reciente de <application>cvs</application> 
     instalada por defecto.
    </para>
   </step>

   <step>
    <para>
     Haga una conexión (login) inicial al servidor <productname>CVS</productname>:

     <programlisting>
$ cvs -d :pserver:anoncvs@postgresql.org:/usr/local/cvsroot login
     </programlisting>

     Se le preguntará us password; introduzca '<literal>postgresql</literal>'.
     Sólo necesitará hacer esto una vez, pues el password se almacenará en 
     <literal>.cvspass</literal>, en su directorio de defecto (your home directory).
    </para>
   </step>

   <step>
    <para>
     Descargue las fuentes de <productname>Postgres</productname>:
     <programlisting>
cvs -z3 -d :pserver:anoncvs@postgresql.org:/usr/local/cvsroot co -P pgsql
     </programlisting>

     lo cual instala las fuentes de <productname>Postgres</productname> en un 
     subdirectorio <filename>pgsql</filename> del directorio en el que usted 
     se encuentra.

     <note>
      <para>
       Si tiene usted una conexión rápida con Internet, puede que no necesite
       <option>-z3</option>, que instruye a <productname>CVS</productname>
       para utilizar compresión gzip para la transferencia de datos. Pero en una
       conexión a velocidad de modem, proporciona una ventaja muy sustancial.
      </para>
     </note>
    </para>

    <para>
     Esta descarga inicial es un poco más lenta que simplemente descargar un fichero
     <filename>tar.gz</filename>; con un modem de 28.8K, puede tomarse alrededor de 
     40 minutos. La ventaja de <productname>CVS</productname> no se muestra hasta que 
     intenta usted actualizar nuevamente el fichero.
    </para>
   </step>

   <step>
    <para>
     Siempre que quiera usted actualizar las últimas fuentes del 
     <productname>CVS</productname>, <command>cd</command> al subdirectorio 
     <filename>pgsql</filename>, y ejecute
     <programlisting>
$ cvs -z3 update -d -P
     </programlisting>

     Esto descargará sólo los cambios producidos desde la última actualización realizda.
     Puede usted actualizar en apenas unos minutos, típicamente, incluso con una línea de
     velocidad de modem.
    </para>
   </step>

   <step>
    <para>
     Puede usted mismo ahorrarse algo de tecleo, creando un fichero 
     <filename>.cvsrc</filename> en su directorio de defecto que contenga:

     <programlisting>
cvs -z3
update -d -P
     </programlisting>

     Esto suministra la opción <option>-z3</option> a todos los comandos al cvs, 
     y las opciones <option>-d</option> y <option>-P</option> al comando cvs update.  
     Ahora, simplemente tiene que teclear
     <programlisting>
$ cvs update
     </programlisting>

     para actualizar sus ficheros.
    </para>
   </step>
  </procedure>

  <caution>
   <para>
    Algunas versiones anteriores de <productname>CVS</productname> tenían un error que 
    llevaba a que todos los ficheros comprobados se almacenasen con permisos de escritura
    para todo el mundo (777) en su directorio. Si le ha pasado esto, puede usted hacer 
    algo como 
    <programlisting>
$ chmod -R go-w pgsql
    </programlisting>
    para colocar los permisos adecuadamente.
    Este error se fijó a partir de la versión 1.9.28 de <productname>CVS</productname>.
   </para>
  </caution>

  <para>
   <productname>CVS</productname> puede hacer un montón de otras cosas, 
   del tipo de recuperar revisiones previas de los fuentes de 
   <productname>Postgres</productname> en lugar de la última versión de 
   desarrollo. Para más información, consulte el manual que viene con 
   <productname>CVS</productname>, o mire la documentación en línea en 
   <ulink url="http://www.cyclic.com/">http://www.cyclic.com/</ulink>.
  </para>
 </sect1>

 <sect1>
  <title>Tomando Los Fuentes Vía <productname>CVSup</productname></title>

  <para>
   Una alternativa al uso de CVS anónimo para recuperar el árbol fuente de 
   <productname>Postgres</productname> es <productname>CVSup</productname>.
   <productname>CVSup</productname> fué desarrollado por 
   <ulink url="mailto:jdp@polstra.com">John Polstra</ulink> para distribuir 
   repositorios CVS y otro árboles de ficheros para 
   <ulink url="http://www.freebsd.org">El proyecto FreeBSD</ulink>.
  </para>

  <para>
   Una ventaja importante de utilizar <productname>CVSup</productname> 
   es que puede replicar de forma eficaz el repositorio 
   <emphasis>entero</emphasis> en su sistema local,
   permitiendo un acceso local rápido a las operaciones de cvs como <option>log</option>
   y <option>diff</option>. Otras ventajas incluyen sincronización rápida al servidor
   de <productname>Postgres</productname> debido a un eficiente protocolo de 
   transferencia de cadenas que sólo envía los cambios desde la última actualización.
  </para>

  <sect2>
   <title>Preparando un Sistema Cliente <productname>CVSup</productname></title>

   <para>
    Se requieren dos áreas para que <productname>CVSup</productname>
    pueda hacer su trabajo: un repositorio local de <productname>CVS</productname>
    (o simplemente un área de directorios si usted está tomando una foto fija (snapshot)
    en lugar de un repositorio; vea más abajo) y área local de anotaciones de 
    <productname>CVSup</productname>. Estas dos áreas pueden coexistir en 
    el mismo árbol de directorios.
   </para>

   <para>
    Decida donde quiere usted conservar su copia local del repositorio 
    <productname>CVS</productname>. En uno de nuestros sistemas, recientemente hemos
    instalado un repositorio en <filename>/home/cvs/</filename>, 
    pero anteriormente lo teníamos bajo un árbol de desarrollo de 
    <productname>Postgres</productname> en <filename>/opt/postgres/cvs/</filename>. 
    Si desea usted mantener su repositorio en <filename>/home/cvs/</filename>,
    incluya

    <programlisting>
setenv CVSROOT /home/cvs
    </programlisting>

    en su fichero <filename>.cshrc</filename>, o una línea similar en su fichero
    <filename>.bashrc</filename> o <filename>.profile</filename>, dependiendo de su shell.
   </para>

   <para>
    Se debe inicializar el área del repositorio de <application>cvs</application>.
    Una vez que se fija <envar>CVSROOT</envar>, se puede hacer esto con un único comando:

    <programlisting>
$ cvs init
    </programlisting>

    tras lo cual, debería usted ver al menos un directorio llamado 
    <filename>CVSROOT</filename> cuando liste el directorio
    <envar>CVSROOT</envar>:

    <programlisting>
$ ls $CVSROOT
CVSROOT/
    </programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Ejecutando un Cliente <productname>CVSup</productname></title>

   <para>
    Verifique que <application>cvsup</application> se encuentra en su path;
    en la mayoría de los sistemas, puede usted hacer esto tecleando

    <programlisting>
which cvsup
    </programlisting>

    Entonces, simplemente ejecute <application>cvsup</application> utilizando:

    <programlisting>
$ cvsup -L 2 <replaceable class="parameter">postgres.cvsup</replaceable>
    </programlisting>

    donde <option>-L 2</option> activa algunos mensajes de status para que pueda
    usted monitorizar el progreso de la actualización, y 
    <replaceable class="parameter">postgres.cvsup</replaceable> es la ruta y el nombre
    que usted ha dado a su fichero de configuración de
    <productname>CVSup</productname>.
   </para>

   <para>
    Aquí le mostramos un ficheros de configuración de <productname>CVSup</productname>
    modificado para una instalación específica, y que mantiene un repositorio 
    <productname>CVS</productname> local completo:

    (N. del T: voy a traducir los comentarios a modo de documentación del fichero. 
     Obviamente, no traduciré los comandos, lo que puede dar una imagen algo complicada,
     pero me parece que puede valer la pena. Agradeceremos sus comentarios a
     doc-postgresql-es@hispalinux.es)

    <programlisting>
# Este fichero representa el fichero de distribución estandar de CVSup
# para el proyecto de ORDBMS PostgreSQL.
# Modificado por lockhart@alumni.caltech.edu 1997-08-28
# - Apunta a mi foto fija local del árbol fuente.
# - Recupera el repositorio CVS completo, y no sólo la última actualización.
#
# Valores de defecto que se aplican a todas las recolecciones.
*default host=postgresql.org
*default compress
*default release=cvs
*default delete use-rel-suffix
# activar la línea siguiente para tomar la última actualización.
#*default tag=.
# activar la línea siguiente para tomar todo lo que se ha especificado antes
# o por defecto en la fecha especificada a continuación.
#*default date=97.08.29.00.00.00

# el directorio base apunta a donde CVSup almacenará sus ficheros de marcas.
# creará un subdirectorio sup/
#*default base=/opt/postgres # /usr/local/pgsql
*default base=/home/cvs

# el directorio prefijo apunta a donde CVSup almacenará la/s distribución/es actuales.
*default prefix=/home/cvs

# la distribución completa, incluyendo todo lo siguiente.
pgsql

# distribuciones individuales contra 'el paquete completo'
# pgsql-doc
# pgsql-perl5
# pgsql-src

   </programlisting>
   </para>

   <para>
    El siguiente fichero de configuración de <productname>CVSup</productname>
    se sugiere en el
    <ulink url="ftp://ftp.postgresql.org/pub/CVSup/README.cvsup">servidor ftp de Postgres</ulink>
    y descargará únicamente la foto fija actual:

    <programlisting>
# Este fichero representa el fichero de distribución estandar de CVSup
# para el proyecto de ORDBMS PostgreSQL.
#
# Valores de defecto que se aplican a todas las recolecciones, a todas las descargas.
*default host=postgresql.org
*default compress
*default release=cvs
*default delete use-rel-suffix
*default tag=.

# el directorio base apunta a donde CVSup almacenará sus ficheros de marcas.
*default base=<replaceable class="parameter">/usr/local/pgsql</replaceable>

# el directorio prefijo apunta a dnde CVSup almacenará las distribuciones actuales.
*default prefix=<replaceable class="parameter">/usr/local/pgsql</replaceable>

# distribución completa, incluyendo todo lo siguiente.
pgsql

# distribuciones individuales contra 'el paquete completo'
# pgsql-doc
# pgsql-perl5
# pgsql-src

    </programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Instalando <productname>CVSup</productname></title>

   <para>
    <productname>CVSup</productname> se puede adquirir como ficheros fuentes,
    binarios preconstruidos o RPM,s de Linux. Es mucho más facil utilizar un binario
    que construirlo a partir de los fuentes, principalmente porque el compilador 
    Modula-3, muy capaz pero también muy voluminoso, se necesita para la construcción.
   </para>

   <procedure>
    <title>Instalación a partir de Binarios de <productname>CVSup</productname></title>

    <para>
     Puede usted utilizar los binarios si tiene una plataforma para la que los binarios
     se hayan remitido al 
     <ulink url="ftp://postgresql.org/pub">servidor ftp de <productname>Postgres</productname></ulink>,
     o si está usted utilizando FreeBSD, para el que 
     <productname>CVSup</productname> está disponible como una adaptación (porting).
     <note>
      <para>
       <productname>CVSup</productname> fue desarrollado originariamente como 
       una herramienta para la distribución del árbol fuente de 
       <productname>FreeBSD</productname>. Está disponible como una adaptación, 
       y para aquellos que utilizan FreeBSD, si esto no es suficiente para decirles como 
       obtenerlo e instalarlo, les agradeceremos que nos aporten un procedimiento eficaz.
      </para>
     </note>
    </para>

    <para>
     En el momento de escribir, se disponen binarios para
     Alpha/Tru64, ix86/xBSD,
     HPPA/HPUX-10.20, MIPS/irix,
     ix86/linux-libc5, ix86/linux-glibc,
     Sparc/Solaris, and Sparc/SunOS.
    </para>

    <step>
     <para>
      Adquiera el fichero tar con los binarios para
      <application>cvsup</application>
      (<application>cvsupd</application> no se requiere para ser un cliente)
      adecuado para su plataforma.
     </para>

     <substeps>
      <step performance="optional">
       <para>
       Si utiliza usted FreeBSD, instale la adaptación de <productname>CVSup</productname>.
       </para>
      </step>
      
      <step performance="optional">
       <para>
       Si tiene usted otra plataforma, localice y descargue los binarios apropiados desde el
	<ulink url="ftp://postgresql.org/pub">servidor ftp de <productname>Postgres</productname></ulink>.
       </para>
      </step>
     </substeps>
    </step>

    <step>
     <para>
      Compruebe el fichero tar para verificar el contenido y la estructura de directorios, si 
      la hay. Al menos para el fichero tar de linux, los binarios estáticos y las páginas man 
      se incluyen sin ningún empaquetado de directorios.
     </para>

     <substeps>
      <step>
       <para>
      Si el binario se encuentra en el nivel superior del fichero tar, simplemente
      desempaquete el fichero tar en su directorio elegido:

	<programlisting>
$ cd /usr/local/bin
$ tar zxvf /usr/local/src/cvsup-16.0-linux-i386.tar.gz
$ mv cvsup.1 ../doc/man/man1/
	</programlisting>
       </para>
      </step>

      <step>
       <para>
      Si hay una estructura de directorios en el fichero tar, desempaquete el fichero tar
      en /usr/local/src, y mueva los binarios a la dirección adecuada como antes.
       </para>
      </step>
     </substeps>
    </step>

    <step>
     <para>
      Asegúrese de que los nuevos binarios se encuentran en su path.

      <programlisting>
$ rehash
$ which cvsup
$ set path=(<replaceable>path a cvsup</replaceable> $path)
$ which cvsup
/usr/local/bin/cvsup
      </programlisting>
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2>
   <title>Instalación a partir de los Fuentes.</title>

   <para>
    La instalación a partir de los fuentes de <productname>CVSup</productname> no es
    totalmente trivial, principalmente porque la mayoría de sistemas necesitarán 
    antes el compilador Modula´3.
    Este compilador se encuentra disponible como <productname>RPM</productname> de Linux,
    como paquete FreeBSD, o como código fuente.

    <note>
     <para>
      Una instalación limpia de Modula-3 se lleva aproximadamente 200 MB de espacio en disco,
      de los que se pueden recuperar unos 50 MB cuando se borren los fuentes.</para>
    </note>
   </para>

   <procedure>
    <title>Instalación en Linux</title>

    <step>
     <para>
      Instale Modula-3.
     </para>

     <substeps>
      <step>
       <para>
      Tome la distribución de <productname>Modula-3</productname> desde
	<ulink url="http://m3.polymtl.ca/m3">Polytechnique Montréal</ulink>,
      quien mantiene activamente el código base originalmente desarrollado por
	<ulink
	url="http://www.research.digital.com/SRC/modula-3/html/home.html">the DEC Systems Research Center</ulink>.
      La distribución <productname>RPM</productname> <quote>PM3</quote> está comprimida
      aproximadamente unos 30 MB. En el momento de escribir, la versión 1.1.10-1 se instalaba
      límpiamente en RH-5.2, mientras que la 1.1.11-1 estaba construída aparentemente para 
      otra versión (¿RH-6.0?) y no corría en RH-5.2.

	<tip>
	 <para>
        Este empaquetado rpm particular tiene 
	  <emphasis>muchos</emphasis> ficheros <productname>RPM</productname>,
        de modo que seguramente quiera usted situarlos en un directorio aparte.
	 </para>
	</tip>
       </para>
      </step>

      <step>
       <para>
	Instale los rpms de Modula-3:

	<programlisting>
# rpm -Uvh pm3*.rpm
	</programlisting>
       </para>
      </step>
     </substeps>
    </step>

    <step>
     <para>
     Desempaquete la distribución de cvsup:

      <programlisting>
# cd /usr/local/src
# tar zxf cvsup-16.0.tar.gz
      </programlisting>
     </para>
    </step>

    <step>
     <para>
      Construya la distribución de cvsup, suprimiento la interface gráfica
      para evitar la necesidad de las librerías X11:

      <programlisting>
# make M3FLAGS="-DNOGUI"
      </programlisting>

      Y si quiere construir un binario estático para trasladarlo a sistemas en los cuales
      no pueda tener instalado Modula-3, intente:

      <programlisting>
# make M3FLAGS="-DNOGUI -DSTATIC"
      </programlisting>
     </para>
    </step>

    <step>
     <para>
      Instale el binario construido:

      <programlisting>
# make M3FLAGS="-DNOGUI -DSTATIC" install
      </programlisting>
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
</appendix>

<!--
> Está claro que he tenido problemas con mi instalación de m3; algunas librerías X11
> no se encontraron correctamente.

Por el momento, puede usted construir el cliente sin la interface gráfica haciendo esto
en el subdirectorio del cliente:

    m3build -DNOGUI

Si lo construye de esta forma, no necesitará las librerías X11, y será un poco más pequeño.
La interface gráfica es agradable para vigilar, pero no es muy utilizable. Yo la implementé
inicialmente porque hace mucho más sencilla la depuración del programa cliente multi-hebra.

Para construir un programa cliente linkado estáticamente, edite
 <filename>client/src/m3makefile</filename>
para añadir <literal>build_standalone()</literal>
justo antes de la entrada <literal>program()</literal> próxima al final del fichero:

<programlisting>
build_standalone()
program(cvsup)
</programlisting>

Ahora, si ya se había construido antes cvsup, elimine el directorio de la construcción
específica de esta máquina (e.g. <filename>LINUXELF/</filename>), y reconstruyalo:

<programlisting>
rm -rf LINUXELF
m3build -DNOGUI -v
cp -p LINUXELF/cvsup /usr/local/bin
</programlisting>

> De cualquier forma, con la reinstalación y el patch de dos líneas anterior,
> y el atajo de la añadido de un fichero de include _POSIX_SOURCE de un intento
> anterior), parece que se construye límpiamente.

¡Bien!

> Ahora, sólo necesito un servidor en cualquier sitio para probar.

Si quiere intentarlo, hay servidores públicos para el repositorio de las 
fuentes de FreeBSD en cvsup.freebsd.org y cvsup2.freebsd.org.
Le sugiero este supfile:

*default host=cvsup.freebsd.org compress
*default release=cvs
*default base=/home/jdp/cvsup-test	# FIX THIS
*default delete use-rel-suffix
# *default tag=.
src-bin

Esto le descargará el repositorio fuente para los programas que están instalados 
en "/bin". Lo he elegido proqeu es uno de los más pequeños del sistema. Cree
un directorio vacío en algún sitio para probar, y cambie la línea marcada "FIX THIS" 
para especificar ese directorio tras la "base=".

Si dispone usted de una línea T1 o mejor, probáblemente borre la clave "compress" de la
primera línea.

Como se muestra, esto descargará los ficheros del repositorio (RCS). Si descomenta usted
la línea que contiene "tag=.", en lugar de esto comprobará la última versión de cada fichero.
Hay mucha más información sobre todo lo que puede usted hacer en 
<ulink url="http://www.freebsd.org/handbook/cvsup.html">the CVSup Handbook</ulink>.

Hay otra idea que quiero transmitirle, pero no esta noche. He descubierto por el camino 
dificil que necesitará usted un paquete malloc que sea hebra segura con respecto al
paquete de hebras de Modula-3. El runtime de Modula-3 tiene cuidado de hacer una mútua
exclusión sobre todas las llamadas que hace de malloc. Sin embargo, si llama usted a ciertas
funciones de la librería C nativa que a su vez llaman a malloc, se evita la mútua exclusión.
Esto puede llevar a un raro pero desconcertante core dump (volcado de memoria: el programa aborta y
graba toda su información en cierto fichero en disco para su estudio posterior por un
analista de sistemas, en su caso. N. del T.).

Para FreeBSD, he resuelto este problema añadiendo un paquete de hebra segura de malloc en
el ejecutable de Modula-3. El paquete es muy portable, y estoy seguro de que trabajará bien 
en Linux con muy pocos cambios (probablemente ninguno). Deseo enviarselo con instrucciones
para hacerlo una parte de la librería "libm3core". Es muy simple, pero ya he sobrepasado
mis límites por esta noche. :-) Una vez tenga usted este malloc en su sitio, el sistema
CVSup debería ser sólido como una roca. Tenemos servidores que han estado levantados durante
semanas y han servido a muchos millares de clientes sin mostrar ningún problema.

> Espero tener el árbol Postres utilizando CVSup durante un mes o así, 
> y espero retirar sup en Septiembre...

¡Grande!  Me ocuparé de dar el máximo para asegurarme que usted no lo lamenta.

John

Tom,

Estoy añadiendo los fuentes para la versión de hebra segura de malloc sobre la que 
te hablé. Creo que simplemente compilaré y trabajará bajo Linux, pero nunca he tenido 
una oportunidad de probarlo aquí. Te urjo a colocarlo en tu sistema Modula-3; de otro
modo, te garantizas encontrarte misteriosos volcados de memoria (core dumps) ocasionales
de cvsupd.

Como primer paso, sugiero simplemente intentar compilarlo bajo linux, algo como:

    cc -O -c malloc.c

Esto no debería producir ningún error ni warning. Si se te producen, contacta conmigo antes 
de invertir más tiempo en ello.

Asumiendo que todo compila OK, copia malloc.c en este directorio de tu árbol fuente Modula-3:

    m3/m3core/src/runtime/LINUXELF

En ese mismo directorio, edita "m3makefile" y añade esta línea al final del fichero:

    c_source       ("malloc")

Cambiate entondes al directorio "m3/m3core" del árbol Modula-3 y teclea
"m3build".  (Estoy asumiento que ya tienes una instalación trabajando de Modula-3).
Una vez esto finaliza, entra como root y teclea "m3ship" para instalarlo.

Esto es todo lo que tienes que hacer. Si construyes cvsup y cvsupd para utilizar
librerías compartidas, incluso no necesitas relinkarlas. Directamente tomará los 
cambios de la librería compartida actualizada.

Cuentame si lo ejecutas sin ningún problema.

Por el momento, esta es una malloc muy buena para su utilidad. Se la puede utilizar
incluso junto a la seguridad de hebras.

Saludos,
John

He depositado un ejecutable cliente cvsup construido estáticamente (y las páginas man
y la configuración de prueba) en

  /pub/incoming/cvsup-15.1-client-linux.tar.gz

Ha sido construido y linkado en Linux/v2.0.30, RH/v4.2, gnulib/v5.3.12 e incluye el 
malloc de hebra segura proporcionado por John Polstra. Le remitiré el código de malloc 
y un correo electrónico adicional para su instalación de John.

La instalación de Modula-3 toma una buena cantidad de espacio (¿~50MB?) y el ambiente de
construcción es único para Modula-3, pero sorprendentemente trabaja muy bien.

Los Makefiles de cvsup no trabajan en mi máquina (no son portables todavía), pero cada
paquete mayor (hay 4) puede ser construido sin necesitar los makefiles con dos comandos
cada uno. No hay ninguna dificultad en ello. John da algunas pistas en su correo sobre como
construir un ejecutable estático, y como redudir el tamaño de este ejecutable retirandole
el soporte gráfico. De nuevo, muy fácil de hacer.

Mi prueba sobre un cliente, tomando un subárbol de la distribución de FreeBSD, trabajo 
perfectamente. No he probado a ejecutar un servidor.

Gracias a John por ayudarme a continuar.

			- Tom


Para el malloc de hebra segura, haz lo siguiente:
1) instale Modula-3
2> añada el fichero incluido "malloc.c" a m3/m3core/src/runtime/LINUXELF
3) edite la última línea de m3makefile en el mismo directorio para añadir
     c_source       ("malloc")
4) ejecute un "m3build" y un m3ship desde el directorio adecuado.

Según lo que dice John, el problema del malloc puede ser importante para los
servidores que ejecutan cvsupd. Los clientes pueden no necesitarlo.

Desgraciadamente, debo haber perdido las buenas instrucciones originales de John 
para esto, y lo estoy haciendo de memoria. Quizá necesite preguntarle a 
John para tener las instrucciones de nuevo...

			- Tom

-->


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
