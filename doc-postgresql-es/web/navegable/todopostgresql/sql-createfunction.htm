<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>   CREATE FUNCTION
  </TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.18"><LINK
REL="Casa"
TITLE="PostgreSQL"
HREF="postgres.htm"><LINK
REL="Arriba"
TITLE="SQL Commands"
HREF="sql-commands.htm"><LINK
REL="PREVIOUS"
TITLE="   CREATE DATABASE
  "
HREF="sql-createdatabase.htm"><LINK
REL="Proxima"
TITLE="   CREATE GROUP
  "
HREF="sql-creategroup.htm"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sql-createdatabase.htm"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sql-creategroup.htm"
>Proxima</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
>CREATE FUNCTION</H1
><DIV
CLASS="REFNAMEDIV"
><H2
>Nombre</H2
>   CREATE FUNCTION
   &#8212;    Definir una funci&oacute;n nueva
  </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><PRE
CLASS="SYNOPSIS"
>CREATE FUNCTION <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>ftype</I
></TT
> [, ...] ] )
    RETURNS <TT
CLASS="REPLACEABLE"
><I
>rtype</I
></TT
>
    [ WITH ( <TT
CLASS="REPLACEABLE"
><I
>attribute</I
></TT
> [, ...] ) ]
    AS <TT
CLASS="REPLACEABLE"
><I
>definition</I
></TT
>   
    LANGUAGE '<TT
CLASS="REPLACEABLE"
><I
>langname</I
></TT
>'


CREATE FUNCTION <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>ftype</I
></TT
> [, ...] ] )
    RETURNS <TT
CLASS="REPLACEABLE"
><I
>rtype</I
></TT
>
    [ WITH ( <TT
CLASS="REPLACEABLE"
><I
>at</I
></TT
> [, ...] ) ]
    AS <TT
CLASS="REPLACEABLE"
><I
>obj_file</I
></TT
> , <TT
CLASS="REPLACEABLE"
><I
>link_symbol</I
></TT
>  
    LANGUAGE 'C'
  </PRE
><DIV
CLASS="REFSECT2"
><H3
>    Entradas
   </H3
><P
>&#13;    <P
></P
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></DT
><DD
><P
>       El nombre de la funci&oacute;n a crear.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>ftype</I
></TT
></DT
><DD
><P
>       El tipo de dato de los argumentos de la funci&oacute;n.
        El tipo de datos de entrada ser&aacute; b&aacute;sico, complejo u
        <I
CLASS="FIRSTTERM"
>opaque</I
>.
        <TT
CLASS="LITERAL"
>opaque</TT
> indica que la funci&oacute;n accepta argumentos de un tipo
        no valido como por ejemplo.<SPAN
CLASS="TYPE"
>char *</SPAN
>.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>rtype</I
></TT
></DT
><DD
><P
>       El tipo de datos que ser&aacute; devuelto.
        El tipo de datos que ser&aacute; devuelto puede ser declarado como
	tipo b&aacute;sico, complejo, tipo
        <TT
CLASS="LITERAL"
>setof <TT
CLASS="REPLACEABLE"
><I
></I
></TT
></TT
>
        u <TT
CLASS="LITERAL"
>opaque</TT
>.
        Modificadores <TT
CLASS="LITERAL"
>setof</TT
>
        indican que la funci&oacute;n devolver&aacute; un grupo de objetos,
        antes que un solo objeto.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>attribute</I
></TT
></DT
><DD
><P
>       Atributo opcional con informaci&oacute;n sobre la
        funci&oacute;n, usado para optimar. El &uacute;nico atributo
	soportado hasta el momento es  
        <TT
CLASS="LITERAL"
>iscachable</TT
>.
        <TT
CLASS="LITERAL"
>iscachable</TT
> indica que la funci&oacute;n
        devuelve el mismo resultado siempre que reciba los mismos valores
	de entrada (p.e., no hace busquedas de base de datos o usa de otra
	manera informaci&oacute;n que no est&aacute; presente en su lista
	de par&aacute;metros). El optimador usa <TT
CLASS="LITERAL"
>iscachable</TT
> para saber si es seguro pre-evaluar una ejecuci&oacute;n de la funci&oacute;n
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>definition</I
></TT
></DT
><DD
><P
>       Una cadena de letras que define la funci&oacute;n y cuyo sentido
	depende del lenguaje. Puede ser un nombre interno de funci&oacute;n,
	el sendero a un fichero de objeto, una cuesti&oacute;n en SQL o texto
en un lenguaje procedural.        </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>obj_file</I
></TT
> , <TT
CLASS="REPLACEABLE"
><I
>link_symbol</I
></TT
></DT
><DD
><P
>       Esta forma de la clausula <B
CLASS="COMMAND"
>AS</B
> se usa para funci&oacute;nes C de enl&aacute;ce din&aacute;mico
        siempre que el nombre de la funci&oacute;n en el codigo fuente
	C no es el mismo que el nombre de la funci&oacute;n SQL.
        La cadena de letras <TT
CLASS="REPLACEABLE"
><I
>obj_file</I
></TT
> es el nombre del fichero que contiene el objecto que puede ser cargado
        de modo din&aacute;mico, y <TT
CLASS="REPLACEABLE"
><I
>link_symbol</I
></TT
>, es el s&iacute;mbolo del enlace al objecto que puede ser cargado de forma
 din&aacute;mica, cuyo nombre es el mismo que el nombre de la funci&oacute;n  
 en el codigo fuente C.        </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>langname</I
></TT
></DT
><DD
><P
>       Puede ser '<TT
CLASS="LITERAL"
>C</TT
>', '<TT
CLASS="LITERAL"
>sql</TT
>',
        '<TT
CLASS="LITERAL"
>internal</TT
>'
        o '<TT
CLASS="REPLACEABLE"
><I
>plname</I
></TT
>',
        donde '<TT
CLASS="REPLACEABLE"
><I
>plname</I
></TT
>'
        es el nombre de un lenguaje procedural creado. Ver         <A
HREF="sql-createlanguage.htm#SQL-CREATELANGUAGE-TITLE"
><I
>CREATE LANGUAGE</I
></A
>
        para m&aacute;s detalles.
       </P
></DD
></DL
>
   </P
></DIV
><DIV
CLASS="REFSECT2"
><H3
>    Salidas
   </H3
><P
>&#13;    <P
></P
><DL
><DT
><TT
CLASS="COMPUTEROUTPUT"
>CREATE
       </TT
></DT
><DD
><P
>      Esto ser&aacute; devuelto siempre que la orden termina con exito.
       </P
></DD
></DL
>
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><H2
>   Descripci&oacute;n
  </H2
><P
>   <B
CLASS="COMMAND"
>CREATE FUNCTION</B
> permite a un usuario de
   <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> 
   registrar una funci&oacute;n con la base de datos. 
   Despu&eacute;s este usuario ser&aacute; tratado como propietario de
   esta funci&oacute;n.
  </P
><DIV
CLASS="REFSECT2"
><H3
>    Notas
   </H3
><P
>    Preste atenci&oacute;n al cap&iacute;tulo en la
   <I
CLASS="CITETITLE"
>PostgreSQL guia del programador</I
>
    de como desenvolver
    <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> con funci&oacute;nes para m&aacute;s informaci&oacute;n sobre como  
    escribir funci&oacute;nes externas.
   </P
><P
>    Usar <B
CLASS="COMMAND"
>DROP FUNCTION</B
>
    para borrar funci&oacute;nes definidas por el usuario.
   </P
><P
>    <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> permite "sobrecarga" de funci&oacute;nes;
    quiere decir, que un solo nombre puede ser usado para definir distintas
    funci&oacute;nes mientras tengan distintos tipos de argumentos.
    Esta capacidad tiene que ser usada con precauci&oacute;n con 
    funci&oacute;nes <TT
CLASS="LITERAL"
>internal</TT
> y 
    funci&oacute;nes C.    
        </P
><P
>    Dos funci&oacute;nes<TT
CLASS="LITERAL"
>internal</TT
>
    no pueden tener el mismo nombre C sin causar errores en el momento de
enlance. Para poder esquivar este hecho, hay que definir nombres diferentes C
(p.e. usando los tipos de argumentos como parte de los nombres C) y
despu&eacute;s declarar los nombres en la clausula AS de      
<B CLASS="COMMAND"
>CREATE FUNCTION</B
>.
    Siempre que la clausula AS quede en blanco,<B
CLASS="COMMAND"
>CREATE FUNCTION</B
>
    supone que el nombre C de la funci&oacute;n es el mismo que el nombre SQL.
   </P
><P
>    Cuando se sobrecargan funci&oacute;nes SQL con funci&oacute;nes C, hay
que dar a cada instancia de la funci&oacute;n un nombre distinto y usar la
forma alternativa the la clausula <B
CLASS="COMMAND" >AS</B
> en el s&iacute;ntaxis de
    <B
CLASS="COMMAND"
>CREATE FUNCTION</B
> para asegurar que los nombres de las funci&oacute;nes SQL sobrecargadas
    sean relacionados con los objetos de enlace din&aacute;mico correctos.
   </P
><P
>    Una funci&oacute;n C no puede devolver una serie de valores.
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><H2
>   Uso
  </H2
><P
>   Para crear una funci&oacute;n SQL simple:

  <PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION one() RETURNS int4
    AS 'SELECT 1 AS RESULT'
    LANGUAGE 'sql';
SELECT one() AS answer;

   <TT
CLASS="COMPUTEROUTPUT"
>    answer 
    ------
    1
   </TT
>
  </PRE
>
  </P
><P
>   Este ejemplo crea una funci&oacute;n C ejecutando una rutina de una
libreria distribuida creada por el usuario. Esta rutina particular calcula
un digito de prueba y devuelve TRUE (SI), simpre que el digito de prueba
en la funci&oacute;n es correcto. La intenci&oacute;n es usar esta
funci&oacute;n en un constraint CHECK.</P ><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION ean_checkdigit(bpchar, bpchar) RETURNS bool
    AS '/usr1/proj/bray/sql/funcs.so' LANGUAGE 'c';
    
CREATE TABLE product (
    id        char(8) PRIMARY KEY,
    eanprefix char(8) CHECK (eanprefix ~ '[0-9]{2}-[0-9]{5}')
                      REFERENCES brandname(ean_prefix),
    eancode   char(6) CHECK (eancode ~ '[0-9]{6}'),
    CONSTRAINT ean    CHECK (ean_checkdigit(eanprefix, eancode))
);
  </PRE
><P
>   Este ejemplo crea una funci&oacute;n que hace una conversi&oacute;n
entre el tipo definido por el usuario complejo y el tipo interno point.
La funci&oacute;n es implementada por un objeto cargado d&iacute;namico
que fue compilado de codigo fuente C. Para que <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> encuentre automaticamente una funci&oacute;n de conversi&oacute;n de tipos,
la funci&oacute;n SQL debe llamarse igual que el tipo a devolver y sobrecarga
es inevitable. El nombre de la funci&oacute;n es sobrecargado usando la 
segunda forma de la clausula <B
CLASS="COMMAND" >AS</B
> de la definici&oacute;n SQL
  </P
><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION point(complex) RETURNS point
    AS '/home/bernie/pgsql/lib/complex.so', 'complex_to_point'
    LANGUAGE 'c';
  </PRE
><P
>  La declaraci&oacute;n de la funci&oacute;n ser&iacute;a:
  </P
><PRE
CLASS="PROGRAMLISTING"
>Point * complex_to_point (Complex *z)
{
        Point *p;

        p = (Point *) palloc(sizeof(Point));
        p-&#62;x = z-&#62;x;
        p-&#62;y = z-&#62;y;
                
        return p;
}
  </PRE
></DIV
><DIV
CLASS="REFSECT1"
><H2
>   Compatibilidad
  </H2
><DIV
CLASS="REFSECT2"
><H3
>    SQL92
   </H3
><P
>    <B
CLASS="COMMAND"
>CREATE FUNCTION</B
> es
    una extensi&oacute;n de lenguaje <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> .
   </P
></DIV
><DIV
CLASS="REFSECT2"
><H3
>    SQL/PSM
   </H3
><P
>&#13;    <BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Nota: </B
>      PSM significa Persistent Stored Modules (m&oacute;dulos archivados
persistentes). Es un lenguaje procedural y se esperaba que PSM fuera
ratificado como est&aacute;ndar oficial a &uacute;ltimos de 1996. Hasta
mediados de 1998 esto a&uacute;n no ha ocurrido, pero se espera que PSM
llegue a ser finalmente est&aacute;ndar.      
</P ></BLOCKQUOTE
>

    SQL/PSM <B
CLASS="COMMAND"
>CREATE FUNCTION</B
> tiene el siguiente sintaxis:
    <PRE
CLASS="SYNOPSIS"
>CREATE FUNCTION <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>
    ( [ [ IN | OUT | INOUT ] <TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> [, ...] ] )
     RETURNS <TT
CLASS="REPLACEABLE"
><I
>rtype</I
></TT
>
     LANGUAGE '<TT
CLASS="REPLACEABLE"
><I
>langname</I
></TT
>'
     ESPECIFIC <TT
CLASS="REPLACEABLE"
><I
>routine</I
></TT
>
     <TT
CLASS="REPLACEABLE"
><I
>SQL-statement</I
></TT
>
    </PRE
>
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createdatabase.htm"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="postgres.htm"
>Casa</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-creategroup.htm"
>Proxima</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE DATABASE</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.htm"
>Arriba</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE GROUP</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
