<HTML
><HEAD
><TITLE
>Operadores</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Manual del usuario de PostgreSQL"
HREF="user.htm"><LINK
REL="UP"
TITLE="Conversión de tipos"
HREF="typeconv.htm"><LINK
REL="PREVIOUS"
TITLE="Conversión de tipos"
HREF="typeconv.htm"><LINK
REL="NEXT"
TITLE="Funciones"
HREF="x3370.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Manual del usuario de PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="typeconv.htm"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. Conversión de tipos</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x3370.htm"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN3307"
>Operadores</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3309"
>Procedimiento de conversión</A
></H2
><DIV
CLASS="PROCEDURE"
><P
><B
>Operador de evaluación</B
></P
><OL
TYPE="1"
><LI
><P
>Inspecciona en busca de un ajsute exacto en el catálogo del sistema pg_operator.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
><P
>Si un argumento de un operador binario es <SPAN
CLASS="TYPE"
>unknown</SPAN
>,
entonces se asume que es del mismo tipo que el otro argumento.</P
></LI
><LI
><P
>Invierte los argumentos, y busca un ajuste exacto con un operador el cual
apunta a él mismo ya que es commutativo.
Si lo halla, entonces invierte los argumentos en el arbol del analizador y usa
este operador.</P
></LI
></OL
></LI
><LI
><P
>Busca el mejor ajuste.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
><P
>Hace una lista de todos los operadores con el mismo nombre.</P
></LI
><LI
><P
>Si solo hay un operador en la lista usa este si el tipo de la entrada puede
ser forzado, y genera un error si el tipo no puede ser forzado.</P
></LI
><LI
><P
>Guarda todos los operadores con los ajustes más explícitos de tipos. Guarda todo
si no hay ajustes explícitos y salta al siguiente paso.
Si solo queda un candidato, usa este si el tipo puede ser forzado.</P
></LI
><LI
><P
>Si algún argumento de entrada es "unknown", categoriza los candidatos de entrada
como boolean, numeric, string, geometric, o user-defined. Si hay una mezcla de
categorías, o más de un tipo definido por el usuario, genera un error porque la elección
correcta no puede ser deducida sin más pistas.
Si solo está presente una categoría, entonces asigna el tipo preferido
a la columna de entrada que previamente era "unknown".</P
></LI
><LI
><P
>Escoge el candidato con los ajustes de tipos más exactos, y que ajustan el "tipo preferido"
para cada categoría de columna del paso previo. Si todavía queda más de un candidato, o si
no queda ninguno, entonces se genera un error.</P
></LI
></OL
></LI
></OL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3334"
>Ejemplos</A
></H2
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3336"
>Operador exponente</A
></H3
><P
>Solo hay un operador exponente definido en el catálogo, y toma argumentos <SPAN
CLASS="TYPE"
>float8</SPAN
>.
El examinador asigna un tipo inicial <SPAN
CLASS="TYPE"
>int4</SPAN
> a ambos argumentos en la 
expresión de esta consulta:
<PRE
CLASS="PROGRAMLISTING"
>tgl=&#62; select 2 ^ 3 AS "Exp";
Exp
---
  8
(1 row)</PRE
>
De esta manera, el analizador hace una conversión de tipo sobre ambos operadores y
la consulta es equivalente a
<PRE
CLASS="PROGRAMLISTING"
>tgl=&#62; select float8(2) ^ float8(3) AS "Exp";
Exp
---
  8
(1 row)</PRE
>

or

<PRE
CLASS="PROGRAMLISTING"
>tgl=&#62; select 2.0 ^ 3.0 AS "Exp";
Exp
---
  8
(1 row)</PRE
>

<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Esta ultima forma es la que tiene menos sobrecarga, ya que no se llama a funciones
para hacer un conversión implícita de tipo. Esto no es una ventaja para pequeñas
consultas, pero puede tener un gran impacto en el rendimiento de consultas que
abarquen muchas tablas.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3346"
>Concatenación de cadenas</A
></H3
><P
>Una sintaxis similar es usada tanto para trabajar con tipos alfanumericos como
con tipos complejos extendidos.
Las cadenas alfanumericas con tipo sin especificar son ajustadas con los operadores candidatos
afines.</P
><P
>Un argumento sin especificar:
<PRE
CLASS="PROGRAMLISTING"
>tgl=&#62; SELECT text 'abc' || 'def' AS "Text and Unknown";
Text and Unknown
----------------
abcdef
(1 row)</PRE
></P
><P
>En este caso el analizador mira si existe algún operador que necesite el
operador <SPAN
CLASS="TYPE"
>text</SPAN
> en ambos argumentos. Si existe, asume que el segundo
operador debe ser interperatado como de tipo <SPAN
CLASS="TYPE"
>text</SPAN
>.</P
><P
>Concatenación con tipos sin especificar:
<PRE
CLASS="PROGRAMLISTING"
>tgl=&#62; SELECT 'abc' || 'def' AS "Unspecified";
Unspecified
-----------
abcdef
(1 row)</PRE
></P
><P
>En este caso hay ninguna pista inicial sobre que tipo usar, ya que no se han 
especificado tipos en la consulta. De esta manera, el analizador busca en todos los
operadores candidatos aquellos en los que todos los argumentos son de tipo alfanumerico. Elige
el "tipo preferido" para las cadenas alfanumericas, <SPAN
CLASS="TYPE"
>text</SPAN
>, para esta consulta. </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Si un usuario define un nuevo tipo y define un operador <SPAN
CLASS="QUOTE"
>"||"</SPAN
> para
trabajar con el, entonces esta consulta tal como esta escrita no tendrá exito. El analizador
tendría ahora tipos candidatos de dos categorias, y no podría decidir cual de ellos usar.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3361"
>Factorial</A
></H3
><P
>Este ejemplo ilustra un interesante resultado. Tradicionalmente, el operador factorial
está definido solo para enteros. El catalogo de operadores de <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
tiene solamente una entrada para el factorial, que toma un entero como operador.
Si recibe un argumento numerico no entero, <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> intentará
convertir este argumento a un entero para la evaluación del factorial.

<PRE
CLASS="PROGRAMLISTING"
>tgl=&#62; select (4.3 !);
?column?
--------
      24
(1 row)</PRE
>

<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Por supuesto, esto conduce a un resultado matemáticamente sospechoso, debido a que en principio
el factorial de un número no entero no está definido. De cualquier modo, el papel de una base
de datos no es enseñar matemáticas, sino más bien ser una herramienta para manipular datos.
Si un usuario decide obtener en factorial de un número real, <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
intentará hacerlo.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="typeconv.htm"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="user.htm"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x3370.htm"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Conversión de tipos</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="typeconv.htm"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Funciones</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>