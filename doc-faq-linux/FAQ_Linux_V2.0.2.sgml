<!doctype linuxdoc system>

<article>

<title>FAQ sobre Linux - es.comp.os.linux.*
<author>
Rafael Martínez, <tt/rafael@viewpoint.no/ &nl 
A. Gustavo Gonzalez, <tt/agonzale@cica.es/ &nl  
Mario Teijeiro Otero, <tt/asimovi@teleline.es/ &nl  
Manuel Constantino, <tt/constan@bart.us.es/ &nl  
Santiago Romero Iglesias, <tt/sromero@unix-shells.com/ &nl  
César Ballardini/Hispafuentes <tt/cballard@santafe.com.ar/ &nl 
Ignacio Arenaza <tt/inaki.arenaza@jet.es/ &nl 

<date>04 septiembre 2000 / Versión 2.0.2
<abstract>
Este documento intentará dar respuesta a las preguntas y problemas más 
comunes que un principiante se hace antes de instalar linux, y al empezar 
a trabajar con Linux.
</abstract>
      
<toc>
<!-- **************************** -->
<!-- **************************** -->
<!--     SECCIÓN INTRODUCCIÓN     -->
<!-- **************************** -->
<!-- **************************** -->

<sect>Introducción e información general


<!-- **************************** -->
<!--   SUBSECCIÓN Introducción    -->
<!-- **************************** -->

<sect1>Introducción
<p>
Este documento pretende dar respuesta, a las preguntas más habituales, 
que los usuarios suelen hacerse cuando empiezan a trabajar con Linux. 
La idea surgió en el antigüo grupo de noticias es.comp.os.linux, y la primera versión 
fue publicada el 03 de junio de 1999.
La FAQ ha sido creada por el coordinador de la misma, 
<url url="mailto:rafael@viewpoint.no" name="Rafael Martínez"> 
y por los colaboradores de la FAQ, 
<url url="mailto:agonzale@cica.es" name="A. Gustavo Gonzalez">, 
<url url="mailto:asimovi@teleline.es" name="Mario Teijeiro Otero">, 
<url url="mailto:constan@bart.us.es" name="Manuel Constantino">, 
<url url="mailto:sromero@unix-shells.com" name="Santiago Romero Iglesias">,
<url url="mailto:cballard@santafe.com.ar" name="César Ballardini/Hispafuentes"> y
<url url="mailto:inaki.arenaza@jet.es" name="Ignacio Arenaza">.
<p>
La página principal de la FAQ es <url url="http://www.linux-es.com/Faq/" name="http://www.linux-es.com/Faq/">, 
aquí podreis encontrar la última versión de la misma en formato HTML, PS, DVI, TEXTO y SGML. 
También es posible encontrarla en <url url="http://lucas.hispalinux.es/" name="LUCAS"> 
y en los servidores espejos del mismo.
<p>
Si quereis colaborar y aportar ideas o sugerencias, ponerse en contacto con el 
<url url="mailto:rafael@viewpoint.no" name="coordinador"> de este documento.
<p>
Debido a que existen diferentes distribuciones de Linux y a que estas distribuciones muchas 
veces configuran ciertas cosas de manera diferente, en muchos casos no existe una receta válida 
al 100% para todos los sistemas. Hemos intentado realizar las explicaciones lo mas general posible, 
intentando dar una base para la solución de problemas. Esperamos que este documento os ayude 
a encontrar respuesta a vuestros problemas y que vuestro sistema mejore día a día. 


<!-- **************************** -->
<!--    SUBSECCIÓN QUE ES LINUX   -->
<!-- **************************** -->

<sect1>¿Qué es Linux?<label id="que_es_linux">
<p>
LINUX es un sistema operativo, compatible Unix. Dos características muy peculiares 
lo diferencian del resto de los sistemas que podemos encontrar en el mercado, 
la primera, es que es <em>libre</em>, esto significa que no tenemos que pagar ningún 
tipo de licencia a ninguna casa desarrolladora de software por el uso del mismo, 
la segunda, es que el sistema viene acompañado del <em>código fuente</em>. 
El sistema lo forman el Núcleo (Leer sección <ref id="nucleo" name="Kernel/Núcleo">) 
del sistema mas un gran número de programas / librerias que hacen posible su utilización. 
<p>
Linux se distribuye bajo la <url url="http://www.gnu.org/copyleft/gpl.html" name="GNU General Public License">, 
por lo tanto, el código fuente tiene que estar siempre accesible. 
<p>
El sistema ha sido diseñado y programado por multitud de programadores alrededor del mundo. 
El núcleo del sistema sigue en continuo desarrollo bajo la coordinación de Linus Torvalds, 
la persona  de la que partio la idea de este proyecto, a principios de la década de los noventa. 
<p>
Día a día, más y más programas / aplicaciones estan disponibles para este sistema, 
y la calidad de los mismos aumenta de versión a versión. La gran mayoria de los mismos 
vienen acompanados del código fuente y se distribuyen gratuitamente bajo los términos 
de licencia de la GNU Public License, aunque también existen programas comerciales, los 
cuales hay que comprar y que no se distribuyen bajo la licencia GNU.
<p>
En los últimos tiempos, ciertas casas de software comercial han empezado a distribuir 
sus productos para Linux y la presencia del mismo en empresas aumenta rapidamente por 
la excelente relación calidad-precio que se consigue con Linux. 
<p>
Las plataformas en las que en un principio se puede utilizar Linux son 386-, 486-. 
Pentium, Pentium Pro, Pentium II/III, Amiga y Atari, también existen versiones para su 
utilización en otras plataformas, como Alpha, ARM, MIPS, PowerPC y SPARC


<!-- **************************** -->
<!-- SUBSECCIÓN HISTORIA LINUX    -->
<!-- **************************** -->

<sect1>Historia de Linux
<p>
LINUX hace su aparición a principios de la década de los noventa, era el año 1991, 
por aquel entonces un estudiante de informática de la Universidad de Helsinki, 
llamado Linus Torvalds empezó, -como una afición y sin poderse imaginar a lo que 
llegaría este proyecto, a programar las primeras lineas de código de este 
sistema operativo llamado LINUX. 
<p>
Este comienzo estuvo inspirado en MINIX, un pequeño sistema Unix desarrollado por Andy Tanenbaum.
Las primeras discusiones sobre Linux fueron en el grupo de noticias <tt>comp.os.minix</tt>, 
en estas discusiones se hablaba sobre todo del desarrollo de un pequeño sistema Unix 
para usuarios de Minix que querian mas. 
<p>
Linus nunca anuncio la versión 0.01 de Linux (agosto 1991), esta versión no era 
ni siquiera ejecutable, solamente incluía los principios del núcleo del sistema, 
estaba escrita en lenguaje ensamblador y asumía que uno tenía acceso a un sistema 
Minix para su compilación. 
<p>
El 5 de octubre de 1991, Linus anuncio la primera versión "Oficial" de Linux, -versión 0.02. 
Con esta versión Linus pudo ejecutar Bash (GNU Bourne Again Shell) y gcc (El compilador GNU de C) 
pero no mucho mas funcionaba. En este estado de desarrollo ni se pensaba en los términos 
soporte, documentación, distribución y desarrollo.
<p>
Despues de la versión 0.03, Linus salto en la numeración hasta la 0.10, 
mas y mas programadores a lo largo y ancho de internet empezaron a trabajar 
en el proyecto y despues de sucesivas revisiones, Linus incremento el número de 
versión hasta la 0.95 (Marzo 1992). Mas de un año despues (diciembre 1993) 
el núcleo del sistema estaba en la versión 0.99 y la versión 1.0 no llego 
hasta el 14 de marzo de 1994. 
<p>
Desde entonces no se ha parado de desarrollar, la versión actual del núcleo es la 2.2 
y sigue avanzando dia a dia con la meta de perfeccionar y mejorar el sistema.


<!-- *********************************** -->
<!-- SUBSECCIÓN CARACTERISTICAS DE LINUX -->
<!-- *********************************** -->

<sect1>Características de Linux
<p>
Aquí teneis una lista bastante completa con las características de LINUX   &nl   
<em/[Fuente: Infosheet-Como. Autor: Ivan Casado]/ : 
<itemize>
<item>Multitarea: La palabra multitarea describe la habilidad de ejecutar varios programas al mismo tiempo.  &nl    
LINUX utiliza la llamada multitarea preeventiva, la cual asegura que 
todos los programas que se están utilizando en un momento dado serán ejecutados, 
siendo el sistema operativo el encargado de ceder tiempo de microprocesador a cada programa.
<p>
<item>Multiusuario: Muchos usuarios usando la misma máquina al mismo tiempo.
<p>
<item>Multiplataforma: Las plataformas en las que en un principio se puede 
utilizar Linux son 386-, 486-. Pentium, Pentium Pro, Pentium II/III, Amiga y Atari, 
también existen versiones para su utilización en otras plataformas, como Alpha, 
ARM,MIPS, PowerPC y SPARC.
<p>
<item>Multiprocesador: Soporte para sistemas con mas de un procesador 
está disponible para Intel y SPARC.
<p>
<item>Funciona en modo protegido 386.
<p>
<item>Protección de la memoria entre procesos, de manera que uno de 
ellos no pueda colgar el sistema.
<p>
<item>Carga de ejecutables por demanda: Linux sólo lee del disco aquellas 
partes de un programa que están siendo usadas actualmente.
<p>
<item>Política de copía en escritura para la compartición de páginas entre ejecutables: 
esto significa que varios procesos pueden usar la misma zona de memoria para ejecutarse. 
Cuando alguno intenta escribir en esa memoria, la página (4Kb de memoria) se copia a otro lugar. 
Esta política de copia en escritura tiene dos beneficios: aumenta la velocidad y reduce el uso de memoria.
<p>
<item>Memoria virtual usando paginación (sin intercambio de procesos completos) a disco:  
A una partición o un archivo en el sistema de archivos, o ambos, con la posibilidad de 
añadir más áreas de intercambio sobre la marcha  Un total de 16 zonas de intercambio 
de 128Mb de tamaño máximo pueden ser usadas en un momento dado con un límite teórico 
de 2Gb para intercambio. Este limite se puede aumentar facilmente con el cambio de 
unas cuantas lineas en el codigo fuente.
<p>
<item>La memoria se gestiona como un recurso unificado para los programas de usuario 
y para el caché de disco, de tal forma que toda la memoria libre puede ser usada 
para caché y ésta puede a su vez ser reducida cuando se ejecuten grandes programas.
<p>
<item>Librerías compartidas de carga dinámica (DLL's) y librerías estáticas.
<p>
<item>Se realizan volcados de estado (core dumps) para posibilitar los análisis 
post-mortem, permitiendo el uso de depuradores sobre los programas no sólo en 
ejecución sino también tras abortar éstos por cualquier motivo.
<p>
<item>Compatible con POSIX, System V y BSD a nivel fuente.
<p>
<item>Emulación de iBCS2, casi completamente compatible con SCO, SVR3 y SVR4 a nivel binario.
<p>
<item>Todo el código fuente está disponible, incluyendo el núcleo completo 
y todos los drivers, las herramientas de desarrollo y todos los programas de 
usuario; además todo ello se puede distribuir libremente. Hay algunos programas 
comerciales que están siendo ofrecidos para Linux actualmente sin código fuente, 
pero todo lo que ha sido gratuito sigue siendo gratuito.
<p>
<item>Control de tareas POSIX.
<p>
<item>Pseudo-terminales (pty's).
<p>
<item>Emulación de 387 en el núcleo, de tal forma que los programas no tengan 
que hacer su propia emulación matemática. Cualquier máquina que ejecute Linux 
parecerá dotada de coprocesador matemático. Por supuesto, si el ordenador ya 
tiene una FPU (unidad de coma flotante), esta será usada en lugar de la emulación, 
pudiendo incluso compilar tu propio kernel sin la emulación matemática y conseguir 
un pequeño ahorro de memoria.
<p>
<item>Soporte para muchos teclados nacionales o adaptados y es bastante fácil 
añadir nuevos dinámicamente.
<p>
<item>Consolas virtuales múltiples: varias sesiones de login a través de la 
consola entre las que se puede cambiar con las combinaciones adecuadas de 
teclas (totalmente independiente del hardware de video).  Se crean 
dinámicamente y puedes tener hasta 64.
<p>
<item>Soporte para varios sistemas de archivo comunes, incluyendo minix-1, 
Xenix y todos los sistemas de archivo típicos de System V, y tiene un avanzado 
sistema de archivos propio con una capacidad de hasta 4 Tb y nombres de archivos 
de hasta 255 caracteres de longitud.
<p>
<item>Acceso transparente a particiones MS-DOS (o a particiones OS/2 FAT) 
mediante un sistema de archivos especial: no es necesario ningún comando 
especial para usar la partición MS-DOS, esta parece un sistema de archivos
 normal de Unix (excepto por algunas restricciones en los nombres de archivo, 
permisos, y esas cosas). Las particiones comprimidas de MS-DOS 6 no son 
accesibles en este momento, y no se espera que lo sean en el futuro. El 
soporte para VFAT, FAT32 (WNT, Windows 95/98) se encuentra soportado 
desde la version 2.0 del nucleo y el NTFS de WNT desde la version 2.2 
(Este ultimo solo en modo lectura).
<p>
<item>Un sistema de archivos especial llamado UMSDOS que permite que 
Linux sea instalado en un sistema de archivos DOS.
<p>
<item>Soporte en sólo lectura de HPFS-2 del OS/2 2.1
<p>
<item>Sistema de archivos de CD-ROM que lee todos los formatos estándar de CD-ROM.
<p>
<item>TCP/IP, incluyendo ftp, telnet, NFS, etc.
<p>
<item>Appletalk.
<p>
<item>Software cliente y servidor Netware.
<p>
<item>Lan Manager / Windows Native (SMB), software cliente y servidor.
<p>
<item>Diversos protocolos de red incluidos en el kernel: TCP, IPv4, 
IPv6, AX.25, X.25, IPX, DDP, Netrom, etc. 
</itemize>



<!-- **************************** -->
<!-- SUBSECCIÓN LINUX COPYRIGHT   -->
<!-- **************************** -->

<sect1>Linux Copyright 
<p>
El copyright del kernel de linux pertenece a Linus Torvalds. Este se distribuye 
bajo la <em><url url="http://www.gnu.org/copyleft/gpl.html" name="GNU General Public License"></em>, 
esto significa básicamente, que cualquiera puede libremente, copiarlo, 
cambiarlo y distribuirlo, pero sin posibilidad de aplicar restricciones 
en futuras distribuciones y teniendo que incluir el código fuente.
<p>Las licencias de los programas y aplicaciones que acompañan al núcleo 
varian, muchos pertenecen al proyecto GNU y se distribuyen bajo GPL, y otros no.


<!-- ******************************* -->
<!-- ******************************* -->
<!-- SECCIÓN ANTES DE LA INSTALACIÓN -->
<!-- ******************************* -->
<!-- ******************************* -->
<sect>Antes de la instalación


<!-- **************************** -->
<!-- SUBSECCIÓN ES LINUX PARA MI? -->
<!-- **************************** -->

<sect1>¿Es linux para mí?
<p>
Aunque parezca muy simple, esta pregunta conlleva otra serie de cuestiones 
anejas, que hemos de considerar para responder con verosimilitud al profano 
en este sistema. Por otra parte, aunque convencidos abogados de este sistema 
operativo frente a los que no son de código abierto, también hemos de aceptar 
las limitaciones del mismo con respecto a los nuevos usuarios.
<p>
En un principio, linux era para gurús, hackers y desarrolladores...y hay muchos 
que piensan que debería seguir siendo así. No obstante, las facilidades que 
tanto en instalación, configuración y gestión del sistema, han proporcionado 
las distribuciones en sus versiones más recientes han acercado mucho al usuario 
final al mundo linux.
<p>
Cuando pensamos en esta FAQ, lo hicimos considerando que los "novatos" en este 
sistema podían ser de diversas procedencias; algunos podrían ser grandes 
conocedores de informática, programadores y administradores de sistemas "no-linux", 
quienes se adaptarían fácilmente. Otros podrían ser usuarios finales de algún otro 
sistema operativo, que utilizan el ordenador para correr aplicaciones, como algunos 
conductores usan el vehículo sólo como medio para acceder a lugares lejanos en 
tiempos cortos, pero no quieren saber nada de mecánica ni electricidad del 
automóvil...Al preguntarnos ¿Es linux para mí? queremos decir más bien 
<em>¿Me conviene usar Linux? ¿Para que lo quiero?</em>
<p>
Hemos leído muchos libros y un gran número de documentos acerca de linux 
en relación con el usuario. Uno de ellos, titulado "<em/Linux for the masses 
and other popular myths/" de Todd Burgess 
(<tt><url url="http://eddie.cis.uoguelph.ca/~tburgess" name="http://eddie.cis.uoguelph.ca/~tburgess"></tt>) 
trata en profundidad el tema de los tránsfugas de sistemas operativos 
por cuestiones de moda (Cool people use linux=la gente güai usa linux) y nos dice:
<p>
<em/Usa linux/:
<itemize>
<item>Si lo requiere la aplicación que necesitas
<item>Si deseas aumentar tu conocimiento acerca de sistemas operativos
<item>Si no te importa investigar "per se", como imperativo categórico
</itemize>
<p>
<em/No uses linux/:
<itemize>
<item>Si no estás ducho en sistemas operativos
<item>Solo porque no es Microsoft
<item>Si piensas que por eso eres más güai, inteligente o mejor que el usuario medio
</itemize>
<p>
En una línea similar, encontramos otro interesante documento que 
(<tt><url url="http://source.syr.edu/~jdimpson/linux/usage/nouse.html" name="http://source.syr.edu/~jdimpson/linux/usage/nouse.html"></tt>) mantenía que: 
<p>
<em/No deberíamos usar linux/:
<itemize>
<item>Si nuestras necesidades están cubiertas con nuestro sistema actual 
y pensamos que continuará así en el futuro.
<item>Si trabajamos en un ambiente comercial/industrial/profesional donde 
no se usa linux y no disponemos de apoyo técnico por parte de nuestra 
plantilla técnica ni pensamos poder proporcionar dicho apoyo nosotros mismos.
<item>Si alguna aplicación importante y necesaria para nuestro trabajo, no
 está disponible en linux ni hay sustitutos adecuados.
</itemize>
<p>
Mucha gente que lea esta FAQ en el futuro, provendrá del ambiente Microsoft 
(Windows 95/98/NT/2000). En tal caso, aquéllos que usaren su computador 
básicamente para el procesamiento de textos y el empleo de hojas de cálculo, 
deberían quedarse como están. A pesar de todos sus fallos, Windows es fácil 
de usar, más aún de aprender y <em/Dispone de una ingente cantidad de softtware/. 
Los que tienen otras ambiciones, pueden <em/plantearse cambiar a linux por 
10 importantes razones/ 
(<tt><url url="http://www.croftj.net/~goob/local/why.html" name="http://www.croftj.net/~goob/local/why.html"></tt>)
<p>
<enum>
<item>Las distribuciones de Linux no son costosas: pueden obtenerse 
gratis de los lugares apropiados de internet o bien comprar los CDs 
por muy poco dinero comparado con otros sistemas comerciales.

<item>Linux es un sistema operativo completo con tres grandes características: 
<em/Estable/ (es muy raro que colapse una aplicación en linux), 
<em/Fidedigno/ (un servidor linux puede funcionar durante cientos de días 
sin necesidad de reiniciarse, lo que no es común en otros sistemas) y <em/Extremadamente potente/.

<item>Tiene un entorno de programación completo, incluyendo C, C++, Pascal, 
compiladores Fortran, utilidades como Qt y lenguajes de guiones (scripts) 
como Perl, gwak y sed. (un simple compilador C para Windows cuesta cientos de dólares)

<item>Presenta una excelentes prestaciones para conexión en red, permitiendo 
compartir PPUs y módems.

<item>Constituye el entorno ideal para hacer funcionar servidores web (Apache) o FTP (oran).

<item>Además del software "libre", hay también bastante software comercial para linux.

<item>Se actualiza y mantiene fácilmente.

<item>Admite múltiples procesadores como norma.

<item>Es realmente multitarea (a diferencia de Windows).

<item>Tiene un excelente servidor XWindow y numerosos gestores de ventanas X.
</enum>
<p>
y además, por instalar linux no tendremos que renunciar a Windows: es 
posible gestionar linux + otros sistemas operativos en el mismo ordenador. 
<p>Para terminar, me gustaría copiar literalmente un trozo de la introducción 
de un libro titulado "<em/Manual Avanzado de linux/" de Raúl Montero Rivero 
(Ed. Anaya) que viene como anillo al dedo al nuevo usuario de nuestro sistema:
<p>
<em>"Aprenderás qué es linux, sus virtudes y sus defectos, cómo puedes 
conseguirlo, qué distribución elegir a la hora de instalarlo, cómo 
administrar tu sistema correctamente, cómo trabajar con XWindow, 
cómo conectarte con él a Internet...Pero no todo va a ser tan fácil 
con linux, porque como comprobarás, no es un sistema hecho para cobardes. 
Tendrás que ser valiente"</em>
<p>
Si te da miedo formatear tu disco duro, linux no es para tí. Si te 
acobarda tener que reinstalar todo de nuevo sólo porque has cometido 
un pequeño error en el proceso de instalación, abandona y no sigas. 
Si te aterra la mera idea de particionar tu disco duro, apaga y vámonos. 
Y si te vas pasar todo el rato pensando que al configurar la frecuencia 
de tu monitor para que funcione X windows, te lo puedes cargar, mejor 
que vuelvas a tu Windows de siempre.
<p>
Ahora seguro que ya sabes si linux es para tí...  ¡Bienvenido!


<!-- ********************************** -->
<!-- SUBSECCIÓN CUANTO ESPACIO NECESITO -->
<!-- ********************************** -->

<sect1>¿Cuanto espacio necesito en mi disco duro, para instalar Linux?
<p>
Esto depende en gran medida de la cantidad de programas/paquetes 
que quieras instalar, del espacio que reserves para swap (espacio de intercambio) 
y del espacio libre que quieras tener para datos/documentos. 
Hay que puntualizar que los datos que se dan en esta subsección hacen 
referencia al sistema en si, mas programas.
<p>
<itemize>
<item>Una instalación super mínima, necesitará alrededor de unos 10MB (Existen
algunas minidistribuciones que caben en un disquete de 1.44Mb) ;-)
<item>Una instalación mínima con las X incluidas, alrededor de los 80Mb.
<item>Para tener un sistema completo (sistema/librerias/programas/aplicaciones/espacio 
para almacenamiento de datos), funcional y siendo realistas, habría 
que tener de 500Mb a 1,5Gb de espacio en el disco duro. Como en cualquier 
sistema, si quieres instalar todos los programas que pasen por tus manos 
o si la cantidad de información con la que trabajas es muy grande, necesitaras
 más y más espacio y siempre te parecerá poco el que tienes ;-)
</itemize>

Con el precio de los discos actuales, no deberiamos tener problemas de espacio. No
es dificil encontrarse hoy en día con máquinas en las que es normal tener 
6-12 Gb de espacio de almacenamiento.



<!-- ********************************** -->
<!-- SUBSECCIÓN CUANTA MEMORIA NECESITO -->
<!-- ********************************** -->

<sect1>¿Cuanta memoria necesito, para usar Linux?
<p>
Esto dependerá también en gran medida del uso que le vayas a dar 
a tu máquina, cuanta mas memoria, mejor trabajara. Aqui tienes unos 
datos orientativos sobre la cantidad de memoria necesaria:
<p><itemize>
<item>Como mínimo se necesitan 4Mb de memoria RAM para utilizar Linux, 
esta cantidad es como se indica mínima y no apta para trabajar con sistemas gráficos.
<item>Para trabajar con las XWindow de una manera semi-decente 
(dependerá del entorno gráfico utilizado) se necesitará como minimo 16Mb.
<item>Para un uso intensivo y para trabajar con programas que requieren 
muchos recursos, se recomienda de 32Mb en adelante. Cuanta mas memoria 
se tenga, mas suelto trabajará nuestro sistema y mas programas podremos 
tener cargados en memoria.
</itemize>

Al igual que la capacidad del disco duro no es un problema hoy en día, 
tampoco la memoria suele serlo, ya que
la mayoría de máquinas que se venden actuálmente vienen al menos con 64 Mb de RAM.


	 
<!-- ***************************************** -->
<!-- SUBSECCIÓN FUNCIONARA MI EQUIPO CON LINUX -->
<!-- ***************************************** -->

<sect1>¿Funcionará mi equipo con linux?
<p>
Hoy en día, la gran mayoría de hardware está soportado por Linux, 
asi que no deberiais tener problemas. De todas maneras, existen 
configuraciones que no están soportadas y quizas últimos modelos 
de tarjetas gráficas, controladoras, etc, que tampoco lo estén. 
<p>
Día a día se trabaja para dar soporte a nuevo hardware y lo que no 
este soportado hoy, probablemente está soportado muy pronto. En un 
pasado, muchas casas de productos no apoyaban a linux, con el consiguiente 
retraso en el soporte a estos productos, con respecto a otros sistemas 
operativos, pero ultimamente esto está cambiando rápidamente.
<p>
Si quereis comprobar si vuestro hardware esta soportado por linux o no, 
leer el <url url="http://users.bart.nl/~patrickr/hardware-howto/Hardware-HOWTO.html" name="Hardware-Howto">, 
un documento con el hardware soportado por linux. También os podeis 
pasar por esta excelente web, <url url="http://www.linuxhardware.net/" name="Linuxhardware.net">, 
donde podreis consultar sobre vuestro hardware.


<!-- ***************************** -->
<!-- SUBSECCIÓN COMO CONSIGO LINUX -->
<!-- ***************************** -->

<sect1>¿Cómo consigo Linux?
<p>
Linux es un sistema de libre distribución por lo que podeis encontrar 
todos los ficheros/programas necesarios para su funcionamiento en multitud de 
servidores conectados a Internet. La tarea de reunir todos los ficheros/programas
necesarios, asi com instalarlos en tu sistema puede ser una tarea bastante
complicada y no apta para muchos. Por esto mismo, nacieron las llamadas distribuciones
de Linux, empresas que se dedican a hacer el trabajo "sucio" para nuestro
beneficio y comodidad.
<p>
Una distribución no es otra cosa, que una recopilación de programas y ficheros, organizados y preparados 
para su instalación. Estas distribuciones se pueden obtener a traves de Internet,
o comprando los CDs de las mismas, los cuales contendrán todo lo necesario 
para instalar un sistema Linux bastante completo y en la mayoría de los casos un programa de instalación 
que nos ayudara en la tarea de una primera instalación. Casi todos los principales 
distribuidores de Linux, ofrecen la posibilidad de bajarse sus distribuciones, via FTP (sin cargo alguno).
<p>
Existen varias distribuciones creadas por diferentes empresas a unos 
precios bastantes asequibles (si se compran los CDs, en vez de bajársela via FTP), 
las cuales deberiais de poder encontrar en tiendas de informática o librerías. 
En la siguiente dirección teneis una lista con las empresas que distribuyen distribuciones 
en España y Centro/Sur américa, 
<url url="http://www.linux-es.com/distribuidores.php" name="http://www.linux-es.com/distribuidores.php">
En el peor de los casos siempre podeis encargarlas directamente 
por Internet a las empresas que las crean. A veces, las revistas de 
informática sacan una edición bastante aceptable de alguna distribución. 
<p>
Si vais a instalar el sistema por primera vez, os recomiendo haceros 
con una de estas distribuciones y en un futuro cuando querais actualizar 
el sistema con las últimas versiones y actualizaciones del núcleo y 
programas que utiliceis, usar Internet. 
<p>
Para mas información sobre las distintas distribuciones de Linux 
podeis leer la <url url="http://metalab.unc.edu/mdw/HOWTO/Distribution-HOWTO.html" name="Linux Distribution HOWTO">
<p>
A continuación teneis una lista con las principales distribuciones de linux:
<p>
<itemize>
<item>
<bf>Redhat</bf>   &nl   
Pagina web: <url url="http://www.redhat.com" name="http://www.redhat.com">   &nl    
FTP principal: <url url="ftp://ftp.redhat.com/pub/" name="ftp://ftp.redhat.com/pub/">   &nl    
<p>

<item>
<bf>Debian</bf>   &nl   
Pagina web: <url url="http://www.debian.org/" name="http://www.debian.org/">   &nl    
FTP principal: <url url="ftp://ftp.debian.org/debian/" name="ftp://ftp.debian.org/debian/">   &nl    
<p>

<item>
<bf>SuSE</bf>   &nl   
Pagina web: <url url="http://www.suse.de/es/" name="http://www.suse.de/es/">   &nl    
FTP principal: <url url="ftp://ftp.suse.com/" name="ftp://ftp.suse.com/">   &nl    
<p>

<item>
<bf>Caldera Openlinux</bf>   &nl   
Pagina web: <url url="http://www.caldera.com/" name="http://www.caldera.com/">   &nl    
FTP principal: <url url="ftp://ftp.caldera.com/pub/OpenLinux/" name="ftp://ftp.caldera.com/pub/OpenLinux/">   &nl    
<p>

<item>
<bf>Slackware</bf>   &nl   
Pagina web: <url url="http://www.slackware.com/" name="http://www.slackware.com/">   &nl    
FTP principal: <url url="ftp://ftp.cdrom.com/pub/linux/slackware" name="ftp://ftp.cdrom.com/pub/linux/slackware">   &nl    
<p>

<item>
<bf>Mklinux</bf>   &nl   
Pagina web: <url url="http://www.mklinux.apple.com/" name="http://www.mklinux.apple.com/">   &nl    
FTP principal: <url url="ftp://ftp.mklinux.apple.com/pub/" name="ftp://ftp.mklinux.apple.com/pub/">   &nl    
<p>

<item>
<bf>Mandrake (español)</bf>   &nl   
Pagina web: <url url="http://www.linux-mandrake.com/es/" name="http://www.linux-mandrake.com/es/">   &nl    
FTP principal: <url url="ftp://sunsite.uio.no/pub/unix/Linux/Mandrake/" name="ftp://sunsite.uio.no/pub/unix/Linux/Mandrake/">   &nl    
<p>

<item>
<bf>Hispafuentes (español)</bf>   &nl   
Pagina web: <url url="http://www.hispafuentes.com/home.php3" name="http://www.hispafuentes.com/home.php3">   &nl    
<p>

<item>
<bf>Conectiva (español)</bf>   &nl   
Pagina web: <url url="http://www.conectiva.com/" name="http://www.conectiva.com/">   &nl    
FTP principal: <url url="ftp://ftp.conectiva.com/pub/conectiva/" name="ftp://ftp.conectiva.com/pub/conectiva/">   &nl    
<p>

<item>
<bf>Eurielec (español)</bf>   &nl   
Pagina web: <url url="http://www.eurielec.etsit.upm.es/linux/" name="http://www.eurielec.etsit.upm.es/linux/">   &nl    
FTP principal: <url url="ftp://ftp.dit.upm.es/linux/" name="ftp://ftp.dit.upm.es/linux/">   &nl   
<p>

<item>
<bf>Esware (español)</bf>   &nl   
Pagina web: <url url="http://www.esware.com/" name="http://www.esware.com/">   &nl    
FTP principal: <url url="ftp://ftp.hardlogic.es/pub/ " name="ftp://ftp.hardlogic.es/pub/ ">   &nl   

</itemize>
<p>

<!-- *************************************** -->
<!-- SUBSECCIÓN QUE DISTRIBUCIÓN ES LA MEJOR -->
<!-- *************************************** -->

<sect1>¿Qué distribución es la mejor?
<p>
Esta pregunta se podría denominar <em>"la pregunta del millon"</em>. 
Son muchos los usuarios que la hacen y la respuesta no es fácil de hacer.
<p>
Como ya se ha explicado en la sección <ref id="que_es_linux" name="Qué es Linux?">, 
un sistema Linux esta formado por el núcleo (Leer sección <ref id="nucleo" name="kernel/núcleo">) 
más una serie de programas y librerias que hacen posible tener un sistema 
productivo y operativo. Tanto el núcleo, como las librerias y programas 
necesarios estan disponibles libremente en internet. 
<p>
Con esto, cualquiera con conocimientos, puede instalarse un sistema Linux 
sin necesidad de adquirir una distribución, o crear una nueva distribución 
desde cero. No hace falta decir, que hacer esto es una tarea que requiere 
muchos conocimientos y tiempo. Lo que hacen las empresas que crean una 
distribución es precisamente esto, poner todos los componentes necesarios 
juntos, con esto nos evitamos el tener que hacerlo nosotros.
<p>
Las distribuciones suelen traer un programa de instalación, generalmente 
creado por la empresa que crea la distribución, manuales con documentación, 
una serie de programas/librerias para poder usar el sistema, un kernel, 
y en algunas ocasiones aplicaciones diversas y soporte técnico.
<p>
Sabido esto, podemos afirmar que la diferencia entre una distribución u 
otra es la calidad de lo incluido en la misma; algunos programas de 
instalación pueden ser mas intuitivos que otros o más fáciles de utilizar, 
la calidad de la documentación, que el conjunto de programas/librerias 
esten bien comprobados y funcionen bien juntos (diferentes versiones, librerias, etc), 
soporte eficiente, etc, el kernel/núcleo es el mismo en todas las distribuciones, 
excepto en la versión, es decir, una distribución A con el kernel/núcleo 2.2.9 y 
otra distribución distinta B con el kernel/núcleo 2.2.9 están utilizando exactamente 
el mismo kernel/núcleo, el kernel/núcleo es común a todas las distribuciones y no existe 
un kernel para una distribución y otro para otra.
<p>
A continuación teneis unos comentarios sobre las distribuciones mas usadas. 
No son en absoluto todas, pero si son las que forman el mayor porcentaje de 
sistemas Linux instalados:

<p>
<bf/Redhat/:
<itemize>
<item>Más extendida, buena calidad.
<item>Fácil de instalar, incluye programas de configuración que simplifican ciertas tareas.
<item>Buena documentación (en inglés).
<item>Buen seguimiento de fallos y correcciones de los mismos pueden bajarse de su web.
</itemize>

<p>
<bf/Debian/:
<itemize>
<item>Muy buena calidad. No está sometida a presiones comerciales, 
cuidan mucho la calidad antes de su lanzamiento.
<item>Definida típicamente como la distribución de los usuarios avanzados. 
Puede ser un poco difícil de instalar para el usuario no iniciado y sin conocimientos de informática.
<item>Buena documentación (en inglés).
<item>Buen seguimiento de fallos y correcciones de los mismos pueden bajarse de su web.
</itemize>

<p>
<bf/SuSE/:
<itemize>
<item>Buena calidad germana.
<item>Fácil de instalar, incluye programas de configuración que simplifican ciertas tareas.
<item>Buena documentación (gran parte en castellano).
<item>Buen seguimiento de fallos y correcciones de los mismos pueden bajarse de su web.
</itemize>

<p>
<bf/Caldera/:
<itemize>
<item>Buena calidad.
<item>Fácil de instalar.
<item>Buena documentación (en ingles).
<item>Buen seguimiento de fallos y correcciones de los mismos pueden bajarse de su web
</itemize>

<p>
<bf/Slackware/:
<itemize>
<item>Esta distribución fue de las primeras y durante un largo tiempo fue 
la que más se utilizó. Ha tenido un tiempo en que no se ha actualizado mucho y eso 
le ha hecho perder seguidores. Parece que ha vuelto con fuerza. 
<item>Un poco mas complicada de configurar que la media.
<item>Documentación en inglés.
</itemize>

<p>
<bf/Mandrake/:
<itemize>
<item>Buena calidad
<item>Fácil de instalar
<item>Optimizada para procesadores Pentium y superiores.
<item>Ganando mucha cuota de mercado últimamente.
</itemize>

<p>
<bf/Conectiva/:
<itemize>
<item>Buena calidad
<item>Fácil de instalar
<item>Ha entrado con mucha fuerza en el mercado suramericano y español.
</itemize>

<p>
<bf/Hispafuentes/:
<itemize>
<item>Buena calidad, basada en Redhat Deluxe y compatible 100% con la misma.
<item>Fácil de instalar
<item>Ha entrado con mucha fuerza en el mercado español.
<item>Incluye toda la documentación disponible sobre linux en castellano.
</itemize>


<!-- ************************************************* -->
<!-- SUBSECCIÓN PUEDO TENER MAS DE UN S.O EN MI EQUIPO -->
<!-- ************************************************* -->

<sect1>¿Puedo tener más de un sistema operativo en mi equipo?
<p>
La respuesta es si, no es ningún problema el tener más de un sistema operativo 
en tu máquina. Es mas, hay mucha gente que tiene incluso 3 y 4 sistemas.
<p>
Para hacer esto, hay que tener claro como se instalan los sistemas que queremos 
tener, como realizar particiones en el disco duro (Leer sección 
<ref id="durante_instalacion" name="Durante la instalación">) 
y en que orden deberiamos instalarlos para que no tengamos problemas.
<p>
Existen unos documentos Howtos y MiniHowtos que explican muy bien 
como tener diferentes sistemas en tu ordenador, los podreis encontrar
 en cualquier servidor que contenga la documentación de Linux. 
Mas información en la subsección <ref id="documentacion" name="¿Dónde encuentro documentación sobre linux?">:
<p>
Algunos documentos a tener en cuenta:
<itemize>
<item>Linux-DOS-Win95-OS2 
<item>Linux + FreeBSD
<item>NT Loader+Linux 
<item>Linux+Win95
<item>Loadlin+Win95
</itemize>


<!-- *************************************************************** -->
<!-- SUBSECCIÓN FUNCIONAN MIS PROGRAMAS/JUEGOS PARA WINDOWS EN LINUX -->
<!-- *************************************************************** -->

<sect1>¿Funcionan mis programas/juegos para Windows en Linux?
<p>
Como primera afirmación, podemos decir que no, tus programas para 
Windows no funcionaran en Linux. Windows y Linux/Unix no son compatibles 
y programas compilados en una u otra plataforma no funcionarán en 
otra plataforma que no sea en la que el programa se compiló para su utilización.
<p>
Como segunda afirmación, podemos decir, que en algunos casos es posible 
ejecutar programas para Windows en Linux, si hacemos uso de un emulador
 de windows para Linux. Un emulador es un programa que se ejecuta en 
Linux y que crea una máquina virtual windows, engañando al programa 
windows, que creera que se está ejecutando en un sistema Windows.
<p>
Existen dos emuladores de uso común, Wine (libre) y WMware (comercial). 
De estos dos parece ser que WMware es de una calidad superior y que 
funciona sin grandes problemas.
<p>
Podemos aconsejar, el no usar emuladores para evitar problemas. A no 
ser que tengas necesidad de usar una aplicación muy especial, existen 
versiones de programas con características similares a los de Windows, 
nativos de Linux, con lo que probablemente te funcionen mejor, más rápido 
y no te consuman tantos recursos. La elección es vuestra ;-)


<!-- ****************************************************** -->
<!-- SUBSECCIÓN QUE TENGO QUE SABER ANTES DE INSTALAR LINUX -->
<!-- ****************************************************** -->

<sect1>¿Qué tengo que saber antes de instalar linux?
<P>
<bf/Introducción/
<p>
Si nos ceñimos a esta FAQ, en la primera sección se proporciona una 
información de carácter general acerca de qué es Linux, su historia, 
características,.... En la segunda sección se añaden otros aspectos 
fundamentales como ¿Para qué quiero linux?, ¿Qué espacio y memoria necesito?, 
¿Funcionará en mi equipo?, ¿Cómo lo consigo?, 
¿Qué distribución es la que más me conviene?, etc. 
<p>
Lo que se ha abordado en esta sección son los datos relativos al sistema donde 
vamos a instalar linux. Muchos usuarios desconocen por completo 
qué es lo que están usando: no saben que placa base tienen, 
ni que tipo de memoria, qué tarjeta de vídeo, si su ratón es serie o ps2, ... 
y por supuesto otras más sutiles como el refresco vertical de la pantalla de su monitor. 
Es necesario conocer el tipo de hardware de nuestro sistema informático 
para ver si es compatible con la distribución de linux que vamos a instalar. 
<p>	
Hay un par de libros de la editorial <em/Anaya/ que son excelentes para prepararse: 
<p>
<itemize>
<item> Patrick Volkerding, Kevin Reichard y Eric Foster-Johnsos, 
<em/Instalación y configuración de Linux/, Anaya, Madrid, 1999
<item> Naba Barkakati, <em/RedHat Linux a fondo/, Anaya, Madrid,1999
</itemize>
<p>
Antes de instalar Linux hay que preparar el PC para la instalación. 
Puede que ya dispongamos de un PC con algún sistema operativo 
instalado como MS-DOS, Windows o OS/2 o puede ocurrir que vayamos 
a comprarnos un PC nuevo para instalar Linux en él. En este último 
caso podremos elegir el hardware y los periféricos compatibles con 
linux. De todos modos en el apartado siguiente nos dedicaremos a 
considerar el hardware soportado por el sistema operativo linux.
<p>
<bf/Los componentes fundamentales/
<p>
En la tabla adjunta se indican los requerimientos mínimos (M) y 
óptimos (O) para los componentes más típicos de un PC
<p>
<itemize>
<item> Procesador : Intel 80386 (M); Pentium, i486 y cualquier clónico de Intel (O)
<item> RAM: 8 MB (M); de 32 MB a 2 GB
<item> Tarjeta gráfica: VGA (M); SVGA o tarjeta soportada por las XFree86 (O)
<item> Disco duro: 125 MB (M); 500 MB o más (O)
<item> Bus: Todos (M = O)
<item> Lector CD-ROM: velocidad de x2 (M); x8 o mayor (O)
<item> Ratón: Microsoft, Logitech o compatible (M=O)
<item> Tarjeta de red: Ninguna (M); Cualquiera soportada (O)
</itemize>
<p>
A continuación veremos todo desde un punto de vista mucho más pormenorizado.
<p>
<em/La Unidad Central de Procesos/:   &nl  
 Linux funcioma bien con cualquier procesador a partir de i386, 
especialmente i486, Pentium, Pentium Pro Pentium II/III y los Intel 
compatibles AMD y Cyrix, tambien existen versiones para Alpha, ARM,MIPS, PowerPC y SPARC.
No funcionará con ningún i286 o inferior porque no son de 32 bits 
(Aunque existen proyetos por ahi para hacerlo funcionar en 8086 /80286).
<p>
<em/Buses/:   &nl  
Linux los admite todos: ISA, VLB, EISA, PCI, PS/2 y MCA 
(este último desde la versión 2.0.7). El bus USB estará totalmente
soportado en la serie 2.4.x del kernel/núcleo. 
<p>
Hay dos placas base que 
no funcionan con linux: La Supermicro P5MMA y la Supermicro P5MMA98. 
Para que lo hagan es necesario descargar de la red BIOS adecuadas: 
<em/ftp.supermicro.com/mma9051.zip y ftp.supermicro.com/a98905.zip/
<p>
<em/Memoria RAM/:   &nl  
 Para que el sistema con XWindow funcione decentemente debería 
disponer de al menos 16 MB de RAM. Como máximo puede gestionar 2 GB de RAM, 
pero a partir de 1 GB, pueden aparecer grandes limitaciones en 
la celeridad si no se instala memoria caché adicional en el PC (Este tema
esta sufriendo grandes cambios en las últimas versiones del kernel/núcleo). 
Si la memoria es superior a 64 MB habrá de indicarse al sistema 
en el fichero de configuración de LILO <tt>/etc/lilo.conf</tt> 
como una línea (Esto no es necesario a partir de la serie 2.2.x del kernel); 
p.ej., si tenemos 128 MB pondremos
<verb>
  append="mem=128M"
</verb>
<em/Discos duros/:   &nl  
Linux funciona con cualquier disco duro compatible con el 
BIOS del PC. Para instalar linux en el PC, no vendría mal disponer de 
una partición de alrededor de 1 GB para el linux native. Si se usa un disco duro
 de gran capacidad (que tenga más de 1024 cilindros), entonces habremos 
de situar LILO, el kernel y los archivos de configuración en los 
primeros 1023 cilindros. Realmente linux no trabaja con los discos 
directamente, sino con los controladores del disco. Linux funciona 
con todos los controladores IDE e IDE/ATAPI, ciertos controladores EIDE 
(que gestionan hasta cuatro dispositivos sean discos duros o CD-ROMs)
 y los controladores SCSI a excepción de los adaptadores SCSI de puerto paralelo.
<p>
<em/Miscelánea/:   &nl  
La gran mayoría del hardware soportado por linux puede consultarse en las direcciones
<tt><url url="http://users.bart.nl/~patrickr/hardware-howto/Hardware-HOWTO.html" name="http://users.bart.nl/~patrickr/hardware-howto/Hardware-HOWTO.html"></tt>,<tt><url url="http://www.xfree86.org/" name="http://www.xfree86.org/"></tt> 
y <tt><url url="http://linuxhardware.net/" name="http://linuxhardware.net/"></tt>
<p>
Todo sobre controladores EIDE, SCSI, Lectores y grabadores CD-ROM, 
Unidades de cinta, Unidades extraíbles, ratones (trackballs y touchpads), 
tarjetas de red (Ethernet, RDSI, Token-Ring, ARCnet...), 
tarjetas gráficas incluídas en la última lista de XFree86, 
tarjetas de sonido, dispositivos PCMCIA, etc. , se encuentra en 
estas direcciones y deben consultarse para evitar sorpresas.
<p>
<bf/El peligro de Windows: Impresoras y modems/
<p>
Existe un peligro en lo que respecta a ciertas impresoras y modems 
llamados winprinters y winmodems que no funcionan en linux.
<p>
Hay dos tipos de impresoras que definitivamente no funcionan con linux: 
todas las impresoras <tt/Hewlett-Packard Desjet 820xx/ y la <tt/Sharp JX-9210/ 
que solo funcionan con Windows 95. El resto son compatibles con linux, aunque
 en ciertos casos hace falta descargar controladores (Canon BJC600/800; HP Deskjet 500/.../855C) 
o programas que mejoran la calidad de impresión (como el free-lj4 para la serie HP Laserjet 4)
<p>
El problema de los winmodems es que parte del hardware es sustituido
 por software y ese software solamente es de Windows, con lo cual no
 pueden funcionar en linux. Lo malo es que al comprar un modem nos 
venden un winmodem sin avisar. Si tenemos uno de ellos lo mejor es 
reemplazarlo por otro que funcione en linux. Para ello lo mejor es 
consultar en la dirección <tt><url url="http://www.o2.net/~gromitkc/winmodem.html" name="http://www.o2.net/~gromitkc/winmodem.html"></tt> para escoger uno adecuado.
<p>
Existen proyectos para soportar estos dispositivos tambien en linux, <url url="http://www.linmodems.org/" name=Winmodems>.
<p>
<bf/Antes de la instalación/
<p>
Antes de comenzar la instalación, es necesario recoger la información 
necesaria para llevar a buen término el proceso:
<p>
<itemize>
<item> Controlador marca y modelo del CD-ROM
<item> Marca y modelo de la tarjeta ethernet
<item> Modelo, fabricante y puerto usado por el ratón
<item> Modelo Chipset y fabricante de la tarjeta gráfica
<item> Servidor X compatible con la tarjeta gráfica
<item> Memoria de la tarjeta gráfica
<item> Modelo, fabricante y datos de la tarjeta de sonido
<item> Intervalos de trabajo de barrido horizontal (kHz) y de refresco vertical (Hz) del Monitor.
<item> Fabricante, modelo y puerto serie usado por el modem
<item> Fabricante y modelo de impresora
<item> Nombre del computador
<item> Nombre del dominio de red
<item> Dirección IP asignada al computador
<item> Dirección de red de area local
<item> Dirección de la máscara de red
<item> Dirección de transmisión de la red
<item> Dirección del encaminador
<item> Dirección del servidor de nombres
</itemize>
<p>
Todos estos datos serán necesarios para instalar convenientemente 
el hardware y configurar las XWindow.
<p>
Por último, antes de comenzar sería bueno haber leído un poco de linux 
o --mejor aún-- tener un amigo que ya conozca el sistema y que se digne 
a acompañarnos durante la instalación y configuración de nuestra distribución.


<!-- ************************************* -->
<!-- ************************************* -->
<!--    SECCIÓN DURANTE LA INSTALACIÓN     -->
<!-- ************************************* -->
<!-- ************************************* -->

<sect>Durante la instalación <label id="durante_instalacion">


<!-- ************************************* -->
<!--  SUBSECCIÓN DONDE INSTALO LINUX  -->
<!-- ************************************* -->

<sect1>¿Dónde instalo Linux?
<p>
Linux se puede instalar en cualquier disco que tengas en tu sistema
 y en cualquier partición del disco duro (Primaria o extendida).   &nl  
No podras tener Linux en una partición compartida con otro sistema 
operativo, Linux necesita su propia partición/es para funcionar. 

<!-- ************************************* -->
<!--  SUBSECCIÓN QUE ES UNA PARTICIÓN      -->
<!-- ************************************* -->

<sect1>¿Qué es una partición? ¿Cómo creo una partición?
<p>
Particionar el disco duro es una manera de dividir el disco físico 
en varios discos lógicos. O lo que es lo mismo, al particionar un disco, 
dividimos el disco en varias partes independientes unas de otras, 
creando la ilusión de que tenemos diferentes discos, cuando en realidad 
lo que tenemos es un solo disco físico dividido en partes. Una partición 
es una de estas partes (divisiones) del disco.
<p>
Existen dos clases de particiones: primarias y extendidas. 
En un disco solo podras tener como maximo 4 particiones primarias o 
3 primeras y 1 extendida.
 En la partición extendida se podrán definir todas (bueno también existe 
un límite, pero es alto) las unidades lógicas que queramos. Con este sistema 
podemos tener una gran cantidad de particiones en nuestro disco.
Cualquier disco que tengamos en nuestro ordenador tiene al menos una 
partición primaria, que en la mayoría de los casos tiene un tamaño 
equivalente al total del disco. 
<p>
Unos ejemplos aclararan las cosas:
<itemize>
<item>Un disco de 1Gb con una sola partición, tendra una partición 
primaria de 1Gb (total del disco).
<item>Ese mismo disco podria tener 4 particiones primarias de 0.25Gb 
cada una, dando la ilusion de que tenemos 4 discos duros de 0.25Gb en 
vez de un solo disco de 1Gb. 
<item>Otra combinación posible podría ser 3 particiones primarias de 
0.10Gb y 1 extendida con 7 unidades logicas de 0.10Gb, en este caso 
parecería que tenemos 10 discos duros de 0.10Gb cada uno. 
</itemize>
<p>
Las combinaciones son múltiples y variadas y dependerán de nuestros 
gustos y de lo que necesitemos. 
<p>
Casi todos los sistemas operativos traen un programa con el que 
podemos crear, modificar y borrar las particiones de nuestro disco. 
En Ms-Dos/Windows de llama <tt>fdisk</tt>, este programa solo puede trabajar 
con particiones de Ms-Dos/Windows. En Linux también se llama 
fdisk (<tt>/sbin/fdisk</tt>), pero es un programa más potente, capaz de 
trabajar y crear particiones tanto para Linux como otros sistemas operativos.
Si vas a trabajar con Linux, es recomendable el uso del fdisk 
que viene con tu distribución, para evitar problemas.
<p>
Al contrario que Ms-Dos, Windows, OS/2, las diferentes particiones 
en linux no se denominan C:, D:, E:, ...., etc, existe una denominación propia:
<p>
Si los discos son IDE:
<itemize>
<item><bf>/dev/hda</bf>: Disco duro IDE como master en el canal IDE 1.  &nl 
/dev/hdaX: (X=1,2,3 o 4) Partición primaria X en /dev/hda (o extendida) &nl 
/dev/hdaX: (X=5,6,7,....,16) Unidad lógica X en /dev/hda 
<p>
<bf>Nota:</bf> Como hemos dicho antes, si utilizamos una partición extendida,
solo podremos tener 3 particiones primarias. Cuando se utiliza la partición
extendida el disco duro suele quedar de la siguiente forma:  &nl 
/dev/hda1 (primaria), /dev/hda2 (primaria), /dev/hda3 (primaria), /dev/hda4 (extendida),
/dev/hda5 (primera unidad logica), /dev/hda6 (segunda unidad lógica), .....etc.
<p>
<item><bf>/dev/hdb</bf>: Disco duro IDE como esclavo en el canal IDE 1.
<item><bf>/dev/hdc</bf>: Disco duro IDE como master en el canal IDE 2.
<item><bf>/dev/hdd</bf>: Disco duro IDE como esclavo en el canal IDE 2.

</itemize>
<p>
Si los discos son SCSI:
<itemize>
<item><bf>/dev/sda</bf>: Disco duro SCSI nr.1.
<item><bf>/dev/sdb</bf>: Disco duro SCSI nr.2.
<item>etc.
</itemize>
<p>
<bf/IMPORTANTE/: Es muy importante saber lo que se está haciendo 
cuando trabajeis con programas que modifican la tabla de particiones 
de un disco. Al cambiar la tabla de particiones de vuestro disco, 
se pierden los datos contenidos en las particiones afectadas. 
Realizar copias de seguridad de los datos que querais mantener 
antes de usar FDISK.


<!-- *************************************************** -->
<!--  SUBSECCIÓN PORQUE NECESITO DIFERENTES PARTICIONES  -->
<!-- *************************************************** -->

<sect1>¿Porqué necesito diferentes particiones?
<p>
El particionar el disco, es símplemente una manera de organizar 
tu disco duro. Podrás organizarlo con una sola partición o en varias. 
Es el usuario el que deberá decidir cuantas particiones tendrá su disco, 
y el tamaño de las mismas, hay que recordar, que al menos hay que tener
 una partición primaria.
<p>
Desventajas de tener vuestro disco dividido en diferentes particiones.
<itemize>
<item>Ninguna
</itemize>
<p>
Ventajas en tener vuestro disco particionado en varias particiones:
<itemize>
<item>Si teneis un error/problema en una de ellas, las demas no se 
verán afectadas.
<item>Poder tener diferentes sistemas operativos en vuestra máquina, totalmente independientes unos de otros.
<item>Poder tener vuestros archivos de datos en particiones totalmente independientes.
<item>Poder borrar/cambiar el contenido de una partición, sin que esto afecte a las demás.
</itemize>


<!-- ***************************************** -->
<!--  SUBSECCIÓN CUANTAS PARTICIONES NECESITO  -->
<!-- ***************************************** -->

<sect1>¿Cuantas particiones necesito para Linux?
<p>
La respuesta rápida y fácil es: recomendable al menos dos, una para el sistema/datos 
y otra para Swap. Usualmente se suelen tener tres, una para el sistema/programas 
(<tt>/</tt>), otra para los datos (<tt>/home</tt>) y otra para swap.
<p>
La respuesta larga y no tan fácil es mas complicada de explicar: 
Todo dependerá muchisimo del uso que se le vaya a dar al sistema. 
<p>
Para sistemas que se utilicen de forma particular y por uno o pocos usuarios 
bastará con las dos/tres particiones antes mencionadas, esto evitará los problemas 
de saber que cantidad de espacio necesitan las diferentes particiones y el quedarnos 
sin espacio en alguna partición vital, mientras que nos sobra en otras. 
<p>
Para sistemas servidores, con gran cantidad de servicios y usuarios es muy 
recomendable tener varias particiones/discos. Existe un documento (HOWTO: Multi Disk System Tuning) 
muy bueno y quizas complicado para el principiante que explica cuantas particiones 
y discos y que tamaño deberian tener en función del uso que se le vaya a dar al sistema, 
lo podeis encontrar en <url url="http://www.nyx.net/~sgjoen/disk.html" name="http://www.nyx.net/~sgjoen/disk.html"> 
o en cualquier servidor con documentación Howto. Otro documento (HOWTO: Linux Partition) 
más sencillo, se puede encontrar en <url url="http://www.linux-es.com/docs/HOWTO/mini/Partition" name="http://www.linux-es.com/docs/HOWTO/mini/Partition">.


<!-- **************************************** -->
<!--  SUBSECCIÓN QUE ES LA SWAP?              -->
<!-- **************************************** -->

<sect1>¿Qué es la Swap?
<p>
La swap es un espacio reservado en tu disco duro para poder usarse como 
una extension de memoria virtual de tu sistema. Es una técnica utilizada 
desde hace mucho tiempo, para hacer creer a los programas que existe mas memoria RAM 
de la que en realidad existe. Es el propio sistema operativo el que se encarga 
de pasar datos a la swap cuando necesita más espacio libre en la RAM y viceversa.
<p>
En Linux, la memoria total disponible por el sistema está formada por la 
cantidad de memoria RAM instalada + la swap disponible. El acceso a la swap (disco duro) 
es más lento que el acceso a la memoria RAM, por lo que si nuestro ordenador 
esta muy cargado de trabajo y hace un uso intensivo de la swap, la velocidad 
del sistema disminuirá. Un uso muy intensivo y continuado de la swap es un 
indicativo de que necesitamos más memoria en nuestro sistema para que funcione 
desahogado con el uso que le estamos dando.
<p> 
En linux generalmente se usa como minimo una partición dedicada a swap 
(aunque también se puede tener un fichero swap).


<!-- **************************************** -->
<!--  SUBSECCIÓN CUANTA SWAP NECESITO?        -->
<!-- **************************************** -->

<sect1>¿Cuanta Swap necesito?
<p>
Esta es otra pregunta que es difícil de contestar: Todo dependerá del uso 
que se le vaya a dar al sistema y del espacio libre que tengamos.
<p>
Si vas a utilizar muchos programas a la vez y tienes poca memoria RAM, 
necesitarás más swap, si tienes mucha RAM, no necesitaras tanta swap. 
Hay que recordar que un uso no intensivo de la swap es normal y no afectará 
mucho a la velocidad del sistema, pero como hemos dicho antes, un uso 
muy intensivo y continuado es un indicativo de que necesitamos mas memoria RAM.
<p>
No existe una fórmula mágica para saber cuanto espacio deberiamos reservar para swap. 
Hay que recordar que la memoria total disponible en Linux es RAM + Swap. 
Como datos orientativos podriamos decir que como mínimo, esta combinación 
debería ser de 32MB para sistemas que se utilicen en modo texto y de 64MB 
en adelante para sistemas que se utilicen en modo gráfico. 
<p>
Aquí teneis una serie de consejos sobre la swap:
<itemize>
<item>Es recomendable el tener siempre algo de swap instalada, incluso 
en sistemas con mucha memoria.
<item>En linux no se puede tener más de 128MB en una partición swap, si 
necesitas mas de 128MB de swap, puedes tener mas de una partición dedicada a swap, por ejemplo, dos de 128MB
(Esto ya no es necesario a partir del kernel/núcleo 2.2.X)
<item>Si tienes más de un disco, instala la swap en el que trabaje mas rápido.
<item>Si tienes más de un disco que se puedan acceder simultáneamente 
(por ej. dos SCSI, o dos IDE en diferentes canales IDE), se puede ganar 
algo de velocidad teniendo una partición swap en cada uno de estos discos.
</itemize>
<p>
Para un uso privado "normal-alto" del sistema, aquí teneis unos ejemplos 
orientativos, segun nuestra experiencia, de la cantidad de swap recomendable:
<itemize>
<item>16MB RAM + 64MB Swap
<item>32MB RAM + 96MB Swap
<item>64MB RAM + 64MB Swap
<item>128MB RAM + 128MB Swap
<item>256MB RAM + 128MB Swap
</itemize>
<p>
Como dato anecdótico, decir que existen servidores, en donde 
la cantidad de swap llega a ser de 256MB y hasta 512MB aunque 
yo tengo ordenadores con 16MB de RAM y 16MB de Swap como servidores
 de impresión que funcionan sin ningún problema. 
<p>
En fin, cada uno debe de saber el uso que le va a dar a su sistema y analizar 
la cantidad de memoria necesaria, aunque si teneis espacio de sobra en el disco, 
más vale tener más Swap disponible que la necesaria, por lo que pueda ocurrir 
en un futuro, como dice el dicho, más vale que sobre que no que falte.


<!-- *********************************************** -->
<!--  SUBSECCIÓN NO TENGO SITIO EN EL HD, QUE HAGO?  -->
<!-- *********************************************** -->

<sect1>No tengo sitio en mi disco duro, ¿Qué hago?
<p>
Si tienes todo el espacio de tu disco ocupado por otros sistemas operativos, 
deberás conseguir espacio para poder crear la particion/es donde instalar Linux. 
Existen tres maneras de hacer esto:
<p>
La primera, comprar un disco duro he instalarlo.
<itemize>
<item><em/Ventajas/: Es la manera más fácil y segura de conseguir más espacio. 
<item><em/Desventajas/: Es la más cara ;-), tienes que instalar un nuevo disco duro.
</itemize>
<p>
La segunda, es borrar todas las particiones de tu disco duro, con lo 
que perderás toda la información que contiene, y empezar desde cero a 
definir las diferentes particiones del disco. Asi podras definir las 
particiones para Linux y otros sistemas operativos si vas a tenerlos. 
<itemize>
<item><em/Ventajas/: Es la manera más fácil y barata de conseguir mas espacio, 
no necesitas comprar otro disco. 
<item><em/Desventajas/: Pierdes la información que ya tengas en el disco, más 
trabajo, ya que si tienes más de un sistema operativo, tienes que instalarlos 
también aparte de Linux.
</itemize>
<p>
La tercera, existen unos programas que permiten cambiar la tabla de particiones 
del disco, sin perder los datos de las mismas. Si tienes por ejemplo una partición 
de 1GB con 500MB libres, puedes utilizar uno de estos programas para "robarle" 
espacio a la partición y crear una nueva particion, teniendo al final 
por ej. una partición de 600MB con la información de la partición original 
y una nueva partición con el resto de espacio liberado 400MB.
<itemize>
<item><em/Ventajas/: Liberas espacio sin perder datos, no tienes que instalar 
de nuevo la informacion/sistema operativo contenido en la partición original.
<item><em/Desventajas/: Estas jugando con la tabla de particiones del disco, 
hay que saber muy bien lo que se hace y como utilizar estos programas 
"ladrones de espacio". Si algo va mal, puedes perder la información que 
tenias en la partición original y deberás empezar de cero como en el caso segundo.
</itemize>
<p>
Existen dos programas "ladrones de espacio" que se suelen utilizar normalmente en el caso tercero:
<itemize>
<item><bf/Partition Magic/: Pagina web principal <url url="http://www.powerquest.com/partitionmagic/" name="http://www.powerquest.com/partitionmagic/">
<item><bf/FIPS/: Pagina web principal <url url="http://bmrc.berkeley.edu/people/chaffee/fips/fips.html" name="http://bmrc.berkeley.edu/people/chaffee/fips/fips.html">
</itemize>
<bf>IMPORTANTE:</bf> Hacer copias de seguridad, cada vez que vayais a cambiar, modificar o "jugar" 
con la tabla de particiones de vuestros discos duros. Un fallo en el sistema, o un error vuestro 
puede haceros perder información importante. 


<!-- ************************************************* -->
<!--  SUBSECCIÓN COMO CONFIGURAR EL ARRANQUE EN LINUX  -->
<!-- ************************************************* -->

<sect1>¿Cómo configurar el arranque de Linux?
<p>
La manera más fácil de arrancar Linux es con LILO. Pasate por la sección 
<ref id="lilo" name="Sobre LILO"> para más información.

<!-- ************************************************************ -->
<!--  SUBSECCIÓN COMO UTILIZAR LOADLIN PARA ENTRAR EN EL SISTEMA  -->
<!-- ************************************************************ -->

<sect1>¿Cómo utilizar LoadLin para el arranque de Linux?
<p>
A veces ciertos programas o "sistemas operativos" están
diseñados para modificar el <em/Master Boot Record/ (MBR) del
ordenador sin tener en cuenta los contenidos actuales del
mismo, lo que suele redundar en la eliminación de LILO y
la imposibilidad del usuario de entrar en Linux. Para solucionar
estos problemas, o por si simplemente deseamos entrar en
Linux desde msdos, está disponible el programa LOADLIN.
<p>
Loadlin es un programa de MSDOS que podemos encontrar en el
directorio dosutils de los CDs de Linux (en la propia distribución).
Este programa permite arrancar Linux desde MSDOS a partir de
él mismo, un fichero kernel de Linux (como vmlinuz, bzImage o
zImage) y una partición Linux. Mediante él podemos hacernos
un disco de seguridad para arrancar Linux cuando LILO sea
borrado por otros S.O.:
<p>
Creamos un directorio <tt>a:\loadlin</tt> y copiamos alli el ejecutable
<tt/Loadlin.exe/. Copiamos también cualquier kernel/núcleo de linux que
tengamos disponible (por ejemplo <tt>\vmlinuz</tt> o <tt>\boot\bzImage</tt>) al
mismo diskette.
<p>
Cuando necesitemos arrancar desde el diskette, arrancamos
en msdos y ejecutamos lo siguiente:
<p>
Formato de uso:
<verb>
  loadlin kernel root=particion
</verb>
En nuestro caso:
<verb>
  a:
  loadlin bzImage root=/dev/hda4
</verb>
 (cambiando cada cosa por su nombre correcto de fichero de
kernel y partición donde tengamos instalado Linux). Esto lo
podemos escribir en el mismo diskette en un fichero linux.bat,
por ejemplo. Tras ejecutarlo, Linux arrancará normalmente con
dicho kernel/núcleo y con los datos de la partición indicada, lo
cual permite restaurar el MBR original (con LILO) ejecutando
de nuevo LILO (mediante <tt>/sbin/lilo</tt>, o <tt>/sbin/lilo -v</tt>).



<!-- ***************************** -->
<!-- ***************************** -->
<!--      SECCIÓN SOBRE LILO       -->
<!-- ***************************** -->
<!-- ***************************** -->

<sect>Sobre LILO<label id="lilo">


<!-- *********************************************** -->
<!-- SUBSECCIÓN QUE ES LILO Y PARA QUE SIRVE         -->
<!-- *********************************************** -->

<sect1>¿Qué es LILO y para qué sirve?
<p>
LILO, literalmente, <em/el cargador de linux/ (LInux LOader) es un gestor 
de arranque muy versátil que permite iniciar un sistema operativo (SO) 
cargando el sector de arranque de una partición del disco duro (o de un disquete). 
<p>
Esto lo pueden hacer otros gestores de botado, pero sólo LILO puede cargar 
el kernel de linux y arrancar linux presentando además la posibilidad de 
pasar parámetros al kernel mediante líneas de comando.
<p>
LILO tiene una serie de componentes que se cargan de manera secuencial. 
En primer lugar, se carga la primera parte (el comienzo del código) del 
cargador en el sector de arranque. Cuando este primer tramo del cargador 
se ha iniciado, aparece una "L" en el monitor. Entonces, el resto 
(la mayor parte del código) del cargador (que junto con la primera parte 
del código se encuentra en el fichero <tt>/boot/boot.b</tt>) procede a iniciarse. 
Justo antes de que se cargue este segundo tramo de código, se presenta "I" en la pantalla.
 Si todo ha ido bien, después de haberse cargado, la siguiente letra 
de LILO, "L", aparecerá en la pantalla. Después de esto, se produce 
la carga de la tabla de descriptores a partir del fichero <tt>/boot.map</tt>, 
donde se establecerán las ubicaciones de los posibles kernels de 
linux así como los sectores de arranque correspondientes a otros SOs que 
también gestione LILO. Por último, se carga el SO seleccionado, que en 
principio será el kernel de linux. Si todo ha funcionado sin problemas, 
aparecerá una "O" en el monitor y se habrá escrito en la pantalla la palabra LILO. 
<p>
Si hubieren problemas en el proceso de arranque la presencia o ausencia 
de las letras de LILO junto con algunos otros mensajes serán claves para diagnosticar la causa del fallo.


<!-- *********************************************** -->
<!-- SUBSECCIÓN DONDE SE INSTALA LILO                -->
<!-- *********************************************** -->

<sect1>¿Dónde se instala LILO?
<p>
Dependiendo de las necesidades que tengamos, podremos instalar LILO:
<p>
<itemize>
<item>En el <em/sector de arranque/ de un disquete (floppy) (<tt>/dev/fd0</tt>)

<item>En el <em/sector de arranque/ (superbloque) de una partición raíz 
de linux (primaria o extendida) (<tt>/dev/hda1</tt>, p.ej. para 
(E)IDE ó <tt>/dev/sda1</tt> p.ej. para SCSI)

<item>En el <em/MBR/ (Master Boot Record) o <em/Sector Maestro de Arranque/ (primer sector) 
del primer disco duro (<tt>/dev/hda</tt>, p.ej. para (E)IDE ó <tt>/dev/sda</tt> p.ej. para SCSI)
</itemize>
<p>
La opción de instalar LILO en un disquete ("de arranque") es el procedimiento 
más seguro, pero también el más lento de cargar linux en nuestra máquina. 
<p>
Si solamente tenemos linux en nuestro ordenador, la opción idónea sería 
instalar LILO en el MBR del primer disco duro. Si vamos a disponer de 
otros SOs coexistiendo en nuestra máquina (MS-DOS, Windows), también 
podemos escoger la instalación de LILO en el MBR, y gestionar con él 
la carga de los SOs. Pero con esto hay que tener ciertas precauciones.
 <p>
Si ya tenemos un SO en una partición, p. ej. Windows 95, cuando instalemos
 LILO en el MBR, sobreescribiremos dicho sector y ya no podremos arrancar Windows 95,
 si no lo gestiona el propio LILO. Si tenemos linux instalado con LILO en el MBR 
y después instalamos p. ej., Windows 95, se borrará LILO del MBR y no podremos 
arrancar linux. En tal caso, para poder usar LILO como gestor común, habría 
que cargar linux con un disquete de arranque y reinstalar, desde linux 
LILO en el MBR. Por lo tanto, si vamos a meter varios SOs en nuestra máquina, 
es mejor instalar primero los otros y luego linux, usando después LILO como
 gestor de arranque de todos los SOs.
<p>
Si nos planteamos iniciar los diversos SOs, incluído linux desde otro gestor 
de arranque, como por ejemplo el moderno BootMagic del PartitionMagic 4.0 
(Englobado ya en El Caldera OpenLinux 2.2), la mejor opción sería escribir
 LILO en el sector de arranque de la partición linux nativa correspondiente. 
En tal caso, cuando instalemos linux, deberemos marcar dicha partición raíz 
como activa (usando el comando "a" de <tt>fdisk</tt> o el "b" de <tt>cfdisk</tt>).


<!-- *********************************************** -->
<!-- SUBSECCIÓN LIMITACIONES DE LA BIOS A LILO       -->
<!-- *********************************************** -->

<sect1>¿Qué limitaciones impone el BIOS a LILO?
<p>
Excepto en el caso de que LILO sea el gestor de otros SOs, será el BIOS u otro cargador 
el responsable de ejecutar el sector de arranque de la partición. El BIOS (Basic Input Output System) 
cuando encendemos el ordenador, lleva a cabo el POST (Power-On Self Test) para comprobar 
los parámetros de la configuración de hardware que se encuentran permanentemente salvados 
en el chip CMOS (Complementary Metal Oxyde Semiconductor) RAM (continuamente alimentado 
por una batería aunque el ordenador se apague): memoria instalada, disqueteras, discos duros, cd-roms,...
<p>
Despues del test, BIOS muestra en la pantalla los valores de los parámetros de hardware 
y procede a arrancar el SO. En el caso de un disco duro toma el MBR del disco primario y 
de él se cargará el programa gestor de arranque. Antaño, el MBR contenía el sistema de 
arranque del único sistema operativo instalado. Hoy día como es posible cargar más de 
un SO, para arrancar, hace falta un gestor de arranque múltiple, como por ejemplo LILO. 
Por lo tanto, LILO está limitado por las opciones del BIOS. Además, LILO depende del BIOS 
para cargar los ficheros /boot/boot.b; /boot.map; los diversos kernels; los sectores de 
arranque de los otros Sos y el mensaje de arranque de LILO si se ha definido. 
<p>
Las restricciones más importantes que afectan LILO eran en el caso de BIOS antiguos la 
limitación a los dos primeros discos duros y la imposibilidad de acceder más allá de 
1024 cilindros por disco, lo cual se vulneraba en cuanto el disco duro superaba los 504 Mbytes, 
por lo que convenía tener la partición raíz que contuviera los kernels en las primeras 
posiciones de la tabla. Los BIOS de las modernas placas base ya soportan hasta cuatro 
dispositivos (discos duros o cdroms). Así, cuando la partición de arranque de linux se 
encuentra en el segundo, tercero o cuarto disco duro, LILO imprime un mensaje de 
precaución pero continúa. El límite de los 1024 cilindros no ha cambiado con los 
nuevos BIOS, pero los controladores de disco con soporte de LBA (Logical Block Address) 
o LARGE(IDEs con más de 1024 cilindros, la mayoría de EIDEs y todos los SCSI) pueden 
"traducir" o "remapear" la geometría del disco en otra equivalente de manera que parezca 
que el sistema tiene menos de los 1024 cilindros y se puedan gestionar hasta casi 8 Gbytes. 
Si la información acerca de la geometría del disco que hay en el menú del BIOS 
(remapeada con p.ej. LBA) no es la misma (en cuanto a cilindros/cabezas/sectores) 
que la que nos da fdisk, entonces se producirá un problema de "geometry mismatch" 
(no equivalencia de geometría) y LILO abortará el arranque a menos que se utilice 
la opción "linear" en la configuración de LILO.


<!-- *********************************************** -->
<!-- SUBSECCIÓN COMO SE INSTALA Y CONFIGURA LILO     -->
<!-- *********************************************** -->

<sect1>¿Cómo se configura e instala LILO?
<p>
La configuración de LILO se hace en <tt>/etc/lilo.conf</tt>, pero antes que editar 
y escribir manualmente la configuración en este archivo, existen interfaces o programas 
capaces de preparar una configuración conveniente para el usuario, de manera que solamente 
en el caso de incorporar opciones avanzadas tenga que editar y modificar a mano el archivo. 
<p>
En primer lugar existe un programa llamado "Quickinst" que acompaña la distribución 
original del programa LILO. Se trata de un guión (shell script) que produce una 
configuración mínima de LILO que luego conviene actualizar. Por otra parte la mayor 
parte de las distribuciones proporcionan un asistente durante la instalación que ayuda 
a la configuración  de LILO. RedHat en su "INSTALL" dedica una parte importante a la 
configuración de LILO. El"SETUP" de Slackware también lo permite. Distribuciones como 
Caldera OpenLinux o SuSE disponen de herramientas de instalación que permiten una cómoda 
configuración de LILO para el usuario (LISA y LIZARD para OpenLinux 1.3 y 2.2, y YAST 
para SuSE). Quizá Debian ha sido un poco más espartana (al menos hasta Hamm 2.0) en su 
utilidad de instalación para la configuración de LILO: se limita a escribir una configuración 
básica de LILO sin soporte para otros SOs ni otros kernels. 
<p>
El fichero <tt>/etc/lilo.conf</tt> solo debería ser leído por el superusuario administrador, 
ya que podría contener contraseñas. En caso de duda, deberíamos hacer (como root) 
<verb>
  chmod 600 /etc/lilo.conf
</verb>
<bf>Escribiendo /etc/lilo.conf</bf>
<p>
El fichero <tt>/etc/lilo.conf</tt> comienza con una "global section" (sección general) 
seguida de una o más "system sections" (secciones para cada SO que LILO gestione) 
que comenzarán por image= (si es un kernel linux) u other= (si es otro SO). Los 
comentarios en el fichero comienzan con el símbolo de la almohadilla (#).
<p>
Consideremos a continuación las líneas más importantes de <tt>/etc/lilo.conf</tt>:
<p>
<em>Sección general</em>
<p>
<itemize>
<item>
<tt>boot=<em>dispositivo</em></tt> indica el dispositivo donde se instalará LILO. 
<em>dispositivo</em> puede ser un disquete (<tt>/dev/df0</tt>), una partición 
(p.ej. <tt>/dev/hdc2</tt>) o el disco completo (p.ej <tt>/dev/hda</tt>) que 
corresponde a la instalación en el MBR
<p>
<item>
<tt>install=<em>ficheroarranque</em></tt> instala el fichero especificado como 
nuevo sector de arranque. Por defecto es <tt>/boot/boot.b</tt>
<p>
<item>
<tt>map=<em>ficheromapa</em></tt> establece la ubicación del fichero de mapeado. 
Por defecto es <tt>/boot/map</tt>.
<p>
<item>
<tt>prompt</tt> ordena a LILO que muestre un indicador (boot:) al momento de 
iniciarse el arranque que permita seleccionar el SO a iniciar. Si en este 
punto pulsamos la tecla TAB, aparecerán los nombres dados a los correspondientes SOs.
<p>
<item>
<tt>timeout=<em>tiempo</em></tt> indica el tiempo en décimas de segundo que 
LILO debe mostrar el indicador anterior. Si pasado ese tiempo, no se indicase 
nada, LILO cargaría el primer SO configurado.
</itemize>
<p>
<em>Sección linux</em>
<p>
<itemize>
<item>
<tt>image=<em>kernelimagen</em></tt> donde introducimos el fichero que contiene 
el kernel, incluyendo la ruta de directorio. Lo más normal es que sea <tt>/vmlinuz</tt> o <tt>/boot/vmlinuz</tt>
<p>
<item>
<tt>label=<em>nombre</em></tt> donde escribimos un nombre para el SO en 
cuestión, p. ej., "linux" para linux, pero para otros, puede ser "DOS", 
"win98"...como máximo pueden ser cadenas de 15 caracteres. Introduciendo 
ese nombre cuando LILO presenta el indicador (boot:) se selecciona el SO a iniciar.
<p>
<item>
<tt>root=<em>partición root</em></tt> donde indicamos el nombre de la partición 
linux nativa de nuestro sistema linux, p. ej., /dev/hdc2.
<p>
<item>
<tt>read-only</tt> indica al kernel que ha de montar inicialmente la partición 
raíz en modo de sólo lectura. Es necesario indicar esta opción para la partición 
donde se montará el sistema de ficheros raíz.
</itemize>
<p>
<em>Sección otros SOs</em>
<p>
<itemize>
<item>
<tt>other=<em>partición</em></tt> donde indicamos esta vez la partición de 
inicio del SO en cuestión, p.ej., <tt>/dev/hda1</tt>.
<p>
<item>
<tt>label=<em>nombre</em></tt> tal como se indicó antes, será el nombre con 
que etiquetemos dicho SO.
<p>
<item>
<tt>loader=<em>gestor de arranque</em></tt> Para cargar el SO, LILO construye 
un pseudo MBR en su fichero de mapeo. Esta opción especifica el fichero donde 
tomar el código del pseudo MBR. Por defecto el fichero es <tt>/boot.chain.b</tt> 	
<p>
<item>
<tt>table=<em>tabla</em></tt> establece el dispositivo fuente para la tabla 
de partición escrita en el pseudo MBR, usualmente <tt>/dev/hda</tt> o <tt>/dev/sda</tt>.
</itemize>
<p>
<em>Otras opciones interesantes (solo algunas)</em>
<p>
<itemize>
<item>
<tt>vga=<em>modo</em></tt> selecciona el modo VGA al inicio. Los modos válidos 
son "normal" (80x25), "ext" (extendido, 80x50) o "ask" (preguntar).
<p>
<item>
<tt>linear</tt> hace que las referencias a los sectores se escriban como 
direcciones lógicas en lugar de físicas. Se emplea cuando LILO no reconoce 
correctamente la geometría del disco duro (debido a un remapeado por parte del BIOS).
<p>
<item>
<tt>message=<em>ficheromensaje</em></tt> establece el fichero cuyo texto se 
mostraría durante el arranque. No debe tener más de 24 líneas.
<p>
<item>
<tt>append=<em>parámetro</em></tt> permite pasar parámetros y componentes de 
hardware al kernel como cadena de caracteres. Por ejemplo, si nuestra memoria 
RAM es superior a 64 Mbytes, por ejemplo, 128, debemos pasarle el dato al kernel 
durante el arranque mediante (no necesario a partir de la serie 2.2.x)
<verb>
  append="mem=128M"
</verb>
<item>
<tt>delay=<em>tiempo</em></tt> establece el tiempo en décimas de segundo que LILO 
esperará antes de arrancar el primer SO. Generalmente se usa cuando se arranca un 
único SO, pues si no, la opción prompt es mucho mejor. Por defecto (sin la opción) 
LILO no espera y se inicia el SO inmediatamente.
</itemize>
<p>
Después de haber escrito el fichero <tt>/etc/lilo.conf</tt>, es necesario lanzar 
el "map installer" haciendo:
<verb>
  /sbin/lilo
</verb>
con lo cual LILO escribe un backup del sector de arranque, escribe la primera 
parte de su código en él y crea un nuevo fichero de mapeado (/boot/map). LILO 
anuncia entonces por la pantalla los SOs que gestiona, añadiendo una estrella 
al que se arrancará por defecto. Hay que recalcar que si cualquiera de los 
componentes de LILO cambia o se modifica su configuración mediante /etc/lilo.conf, 
es necesario volver a reinstalar LILO con /sbin/lilo.
<p>
<bf>Configuración mínima de LILO y configuración para gestionar linux y otro 
sistema operativo (win95)</bf>
<p>
Consideremos el siguiente fichero <tt>/etc/lilo.conf</tt> únicamente para arrancar <bf>linux</bf>:
<verb>
  #
  #Fichero de configuración /etc/lilo.conf
  #
  # Sección general
  boot=/dev/hda
  delay=100
  vga=normal

  # Partición linux

    image=/vmlinuz
    root=/dev/hda1
    label=linux
    read-only  
</verb>
Este ejemplo se interpreta de la siguiente forma: 
<p>
LILO se va a instalar en el MBR del disco duro <tt>/dev/hda</tt>. El modo de video EGA 
es 80x25, el sistema linux nativo se encuentra en la primera partición del disco duro 
(<tt>/dev/hda1</tt>) y la imagen del kernel se encuentra en el fichero /vmlinuz. 
Despues de 10 segundos, arrancará el sistema linux, cuyo nombre es "linux". Si 
hacemos <tt>/sbin/lilo</tt>, entonces aparecerá en el monitor:
<verb>
  Added linux*
</verb>
Veamos ahora otro fichero de configuración para gestionar linux y win95:
<verb>
  #
  # Fichero de configuración /etc/lilo.conf
  #
  # Sección general

  boot=/dev/hda
  prompt
  timeout=100
  vga=normal

  # Partición linux

    image=/vmlinuz
    root=/dev/hdc1
    label=linux
    read-only  

  # Partición Windows 95

    other=/dev/hda1
    label=win95
    table=/dev/hda
</verb>
En este caso, LILO también está en el MBR del primer disco duro (<tt>/dev/hda</tt>) 
y hay dos sistemas operativos: linux en la partición <tt>/dev/hdc1</tt> y Windows 
95 en la partición <tt>/dev/hda1</tt>. La tabla de partición para el gestor de 
arranque corresponde al dispositivo <tt>/dev/hda</tt>.

si hacemos <tt>/sbin/lilo</tt>, aparecerá el mensaje:
<verb>
  Added linux*
  Added win95
</verb>

lo que significa que LILO va a gestionar los dos sistemas operativos y que 
por defecto el primero en arrancar será linux.
<p>
Cuando reinicialicemos el sistema, si todo ha ido bien aparecerá la palabra 
LILO seguida del indicador de arranque

<verb>
  LILO boot:
</verb>
y así permanécera durante unos 10 segundos, pasados los cuales si no hemos 
escrito el nombre de uno de los SOs, cargará por defecto linux. 
<p>
Si antes del tiempo, pulsamos la tecla TAB, entonces aparecerán en pantalla 
los nombres de los SOs gestionados:
<verb>
  linux       win95
</verb>


<!-- ********************************** -->
<!--  SUBSECCIÓN DESINSTALANDO LILO     -->
<!-- ********************************** -->

<sect1>¿Cómo desinstalo LILO?
<p>
Hay razones para desear desinstalar LILO. Una, desinstalar el sistema linux 
de nuestra máquina. Otra imperativa: porque algo va mal. LILO es un programa 
que, mal manejado, puede hacer al sistema no arrancable si se instala en el MBR. 
Mal configurado, impedirá el acceso al cualquier SO. En tales casos es indispensable 
disponer de disquetes de arranque para dichos SO. Por lo tanto es conveniente 
hacer el disco de arranque de Windows y el de arranque de linux (en el momento 
adecuado de la instalación del sistema) de manera que nos permita acceder via 
disquetera al sistema correspondiente en caso de imposibilidad de arrancar. 
Nótese que en el BIOS el arranque deberá comenzar por defecto en la disquetera A:.
<p>
Una vez que hemos arrancado el SO, hay muchas maneras de desinstalar LILO del MBR. 
Si nos encontramos en DOS o Windows, basta con ejecutar el comando MS-DOS

<verb>
  FDISK /MBR (ó SYS C: si C: es el disco duro en cuyo MBR se instaló LILO)
</verb>
si estamos en OS/2
<verb>
  FDISK /NEWMBR
</verb>
que escriben los primeros 446 bytes (el código de arranque) en el MBR y dejando 
las particiones ilesas.
<p>
si estamos en linux, basta con hacer
<verb>
  /sbin/lilo -u	
</verb>
para restaurar el MBR anterior a la instalación de LILO
<p>
Además de todo esto puede hacerse otra cosa: Cuando LILO sobreescribe el MBR, 
salva una copia de backup en <tt>/boot/boot.xxxx</tt>, donde <tt/xxxx/ es un número 
mágico del dispositivo donde se ha instalado. Veamos algunos ejemplos
<verb>
  Disco		/dev/zzz		xxxx
  IDE primario	/dev/hda		0300
  SCSI primario	/dev/sda		0800
  floppy	/dev/fd0		0200
</verb>
así, si queremos desinstalar LILO del sector de arranque de alguno de estos dispositivos, 
bastará con hacer:
<verb>
  dd if=/boot/boot.xxxx of=/dev/zzz bs=446 count=1
</verb>
Si LILO se ha instalado en una partición raíz, no hará no arrancable ningún otro sistema 
operativo. Únicamente, si está mal instalado, hará que no arranque linux. Si deseamos 
restaurar el sector de arranque de la partición /dev/yyyy (p.ej. /dev/hda1) podemos 
reescribir el sector de botado haciendo:
<verb>
  dd if=/dev/yyyy of=New-file bs=512 count=1
  dd if=Backup-Date of=/dev/yyyy
</verb>
si lo que queremos es desinstalar linux, borraremos la partición root con fdisk.


<!-- ************************************* -->
<!-- SUBSECCIÓN LILO NO FUNCIONA BIEN      -->
<!-- **************************************-->

<sect1>LILO no funciona bien. Diagnóstico de errores.
<p>
Cuando LILO se inicia, si todo ha ido bien, presenta en la pantalla las cuatro letras 
"LILO". Como ya vimos, cada letra correspondía a una acción. Si LILO no ha funcionado, 
las letras que presente en pantalla junto con ciertos mensajes, serán la clave para saber 
donde está el problema. Veamos los más comunes:
<p>
<itemize>
<item>
<bf>"L" error</bf>: El primer tramo del código ha sido cargado pero no el segundo. 
Esto se debe generalmente a un error físico en el sector de botado o a un problema 
de geometría del disco.
<p>
<item>
<bf>"LI"</bf>:El segundo tramo del código ha sido invocado, pero no ha podido iniciarse. 
Esto sucede cuando hay un error de geometría de disco o se ha movido <tt>/boot/boot.b</tt> 
sin reinstalar LILO (<tt>/sbin/lilo</tt>).
<p>
<item>
<bf>"LIL"</bf>:El segundo tramo del código se ha iniciado pero no puede ubicar los datos 
que necesita en el fichero de mapeado. Esto puede deberse a un error físico del dispositivo 
de arranque o a un problema en la geometría del disco.
<p>
<item>
<bf>"LIL?"</bf>:El segundo tramo del código se ha cargado en una dirección de memoria equivocada. 
Esto se debe a un error en la geometría del disco o cuando se ha movido <tt>/boot/boot.b</tt> 
sin reinstalar LILO (<tt>/sbin/lilo</tt>).
<p>
<item>
<bf>"LIL-"</bf>:Los datos en el fichero de mapeado no son válidos. Las causas son 
las mismas que en el caso anterior.
</itemize>
<p>
La mayor parte de las veces, no se trata de un problema físico del dispositivo 
de botado, sino errores debidos a la no equivalencia entre la geometría del disco 
que fdisk presenta y que el BIOS ha remapeado. En tal caso el uso del parámetro 
"linear" en <tt>/etc/lilo.conf</tt> puede funcionar. Otras veces puede deberse 
a que se ha intentado instalar LILO en una partición lógica. Y otras veces a 
causas más sutiles. Por ejemplo: Yo arranco linux junto a otros sistemas operativos 
con el gestor de arranque de Partition Magic y tengo LILO en una partición raíz. 
Una vez hice un "resize" y cambié el tamaño de mi partición linux nativa porque 
necesitaba espacio para instalar nuevos programas. Al terminar e intentar arrancar 
linux de su partición, apareció en la pantalla "LI". Eso se debió a que después de 
haber hecho el cambio de tamaño, había movido <tt>/boot/boot.b</tt> y no había lanzado 
el map installer <tt>/sbin/lilo</tt>. Cogí mi disquete de arranque de linux, y 
cuando entré ejecuté la orden y reinicié el sistema. Todo funcionó.


<!-- *************************************** -->
<!-- *************************************** -->
<!--         SECCIÓN KERNEL/NUCLEO           -->
<!-- *************************************** -->
<!-- *************************************** -->

<sect>Kernel / Núcleo<label id="nucleo">


<!-- *************************** -->
<!-- SUBSECCIÓN QUE ES EL KERNEL -->
<!-- *************************** -->

<sect1>¿Qué es el kernel/núcleo?
<p>
El kernel o núcleo de linux se podría definir como el corazón de este sistema 
operativo. Es el encargado de que el software y el hardware de tu ordenador 
puedan trabajar juntos. 
<p>
Las <em>funciones más importantes</em> del mismo, aunque no las unicas, son: 
<itemize>
<item>Administración de la memoria, para todos los programas en ejecución.  
<item>Administración del tiempo de procesador, que estos programas en ejecución 
utilizan.     
<item>Es el encargado de que podamos acceder a los periféricos/elementos de 
nuestro ordenador de una manera comoda.        
</itemize>
Existen dos <em>versiones</em> del Linux kernel: 
<itemize>
<item><em>Versión de producción</em>: La versión de producción, es la versión 
estable hasta el momento. Esta versión es el resultado final de las versiones de desarrollo o experimentales. 
<p>
Cuando el equipo de desarrollo del núcleo experimental, decide que ha conseguido 
un núcleo estable y con la suficiente calidad, se lanza una nueva versión de produción 
o estable. Esta versión es la que se debería utilizar para un uso normal del sistema, 
ya que son las versiones consideradas más estables y libres de fallos en el momento de su lanzamiento. 

<item><em>Versión de desarrollo</em>: Esta versión es experimental y es la que utilizan 
los desarrolladores para programar, comprobar y verificar nuevas características, 
correcciones, etc. Estos núcleos suelen ser inestables y no se deberian usar, 
a no ser que sepas lo que haces. 
</itemize>
Cómo <em>interpretar los números de las versiones</em>: Las versiones del núcleo se 
numeran con 3 números, de la siguiente forma: <tt>XX.YY.ZZ</tt> 
<itemize>

<item><tt>XX</tt>: Indica la serie principal del núcleo. Hasta el momento solo 
existen la 1 y 2. Este numero cambia cuando la manera de funcionamiento del 
núcleo ha sufrido un cambio muy importante.       
<item><tt>YY</tt>: Indica si la versión es de desarrollo o de producción. 
Un número impar, significa que es de desarrollo, uno par, que es de producción.       
<item><tt>ZZ</tt>: Indica nuevas versiones dentro de una versión, en las que 
lo unico que se ha modificado, son fallos de programación /bugs.
</itemize>
Unos <em>ejemplos</em> nos ayudarán a entenderlo mejor: 
<itemize>
<item><tt>ej1</tt>: versión del núcleo 2.0.0: Núcleo de la serie 2 (XX=2), 
versión de producción 0 (YY=0 par), primera versión de 2.0 (ZZ=0)       
<item><tt>ej2</tt>: versión del núcleo 2.0.1: Núcleo de la serie 2, version 0, 
en el que se han corregido errores de programación presentes en la versión 2.0.0 (ZZ=1)       
<item><tt>ej3</tt>: version del nucleo 2.1.100: version 100 del nucleo de desarrollo 2.1.
</itemize>

<!-- *************************************** -->
<!-- SUBSECCIÓN DONDE CONSIGO EL KERNEL      -->
<!-- *************************************** -->

<sect1>¿Dónde consigo el kernel/núcleo? <label id="donde_kernel">
<p>
El núcleo se puede bajar de un gran número de servidores en internet. 
El servidor principal es <url url="http://www.kernel.org/" name="http://www.kernel.org/"> 
y la página de servidores espejos es <url url="http://www.kernel.org/mirrors/" name="http://www.kernel.org/mirrors/">.
<p>
Si tienes problemas accediendo a estas páginas, aquí tienes una copia en otro 
servidor <url url="http://www.linux-es.com/lista_kernel.html" name="http://www.linux-es.com/lista_kernel.html">


<!-- ************************************************ -->
<!-- SUBSECCIÓN COMO SE CONFIGURA E INSTALA EL KERNEL -->
<!-- ************************************************ -->

<sect1>¿Cómo se configura e instala el kernel/núcleo?<label id="configuracion_kernel">
<p>
Este es uno de los temas que más asustan a los nuevos usuarios de linux. Lo primero 
deciros que no hay razón para asustarse, la configuración e instalación de un 
nuevo núcleo en nuestro sistema es más fácil de lo que suena. 
<p>
Lo que si hay que hacer, es tener claro una serie de cosas antes de ponernos a 
trabajar, para asi evitar problemas. A continuación teneis una pequeña guia 
sobre como configurar e instalar un nuevo núcleo en tu sistema. 
<p>
Si habeis decidido instalar un nuevo núcleo en tu sistema, esto es lo que teneis que hacer? 
<enum>

<item>
Bajarse la última versión. De donde? Leerse la <ref id="donde_kernel" name="subsección anterior">. 
<p>
<bf>NOTA</bf>: Si vais a instalar un núcleo de la serie 2.2.x, teneis que 
tener en cuenta que algunas distribuciones no están/estaban preparadas para 
hacer uso de esta serie. Si vuestra distribución no es de las que vienen preparadas, 
teneis que actualizar una serie de paquetes/programas antes de instalar el nuevo 
núcleo (mas información en la documentación que acompaña al nucleo). Las últimas
distribuciones vienen todas preparadas para los núcleos de la serie 2.2.x y posteriores, esta
nota solo es para los que tengan una distribución antigüa.
<p>
<item>
Tener claro lo que vamos a hacer, leerse el documento HOWTO sobre el núcleo 
(<url url="http://www.linux-es.com/docs/HOWTO/Kernel-HOWTO" name="Ingles"> / 
<url url="http://www.linux-es.com/docs/HOWTO/translations/es/Kernel-Como" name="Castellano">) 
<p>
<item>Tener claro las opciones que tenemos que configurar, para poder 
utilizar el hardware de nuestro sistema, asi como las características 
que queremos utilizar. Por ejemplo, si no utilizamos un dispositivo SCSI, 
no tenemos que configurar nada en el apartado SCSI de nuestro núcleo. 
Asi nos ahorramos espacio y tiempo.
<p>
<item>
Entrar como root: <tt><bf>su root</bf></tt> 
<p>
<item>
Ir al directorio <tt>/usr/src/</tt>: <tt><bf>cd /usr/src/</bf></tt>
<p>
<item>
Copiar el archivo que os habeis bajado al directorio <tt>/usr/src</tt>: <tt><bf>cp linux-xx.yy.zz.tar.gz .</bf></tt> 
<p>
<item>
Descomprimirlo y desempaquetar: <tt><bf>tar -xvzpf linux-xx.yy.zz.tar.gz</bf></tt>
<p>
<bf>NOTA</bf>: El archivo <tt>linux-xx.yy.zz.tar.gz</tt> se desempaquetará 
en el directorio <tt>/usr/src/linux</tt>. Si ya existe un directorio llamado 
<tt>/usr/src/linux</tt> en tu sistema, renombrarlo, p.ej: <tt>mv linux linux-old</tt> . 
En algunas distribuciones, <tt>usr/src/linux</tt> es un enlace simbólico a <tt>linux-x.y.z</tt>, 
borrar este enlace simbólico. Es importante que no exista ningún directorio/enlace 
simbólico llamado linux, antes de desempaquetar la nueva versión. Si te has 
bajado el kernel comprimido con bzip2, tendras que descomprimirlo con 
<tt>bunzip2 linux-xx.yy.zz.tar.bz2</tt> antes de desempaquetarlo con <tt>tar -xvf linux-xx.yy.zz.tar</tt>
<p>
<item>
Entrar en <tt>/usr/src/linux</tt>: <tt><bf>cd /usr/src/linux</bf></tt> 
<p>
<item>
Configurar el núcleo, esto se puede hacer de tres maneras diferentes:
<p>
<itemize>
<item><tt><bf>make config</bf></tt> (modo texto) 
<item><tt><bf>make menuconfig</bf></tt> (modo texto con menus)
<item><tt><bf>make xconfig</bf></tt> (XWindow version) 
</itemize>
<P>
Si teneis XWindow instalado, os recomiendo el último comando, si no, el segundo.
Os recomiendo que las opciones que vienen por defecto no las toqueis  
si no sabeis lo que haceis, podeis pulsar <tt>Help</tt> en cada opción 
para obtener una descripción de la misma. Configurar las opciones que 
querais tener en vuestro nuevo núcleo. Una vez terminada la configuración, 
grabar los cambios y salir del programa de configuración.
<p>
<item>
Una vez terminado el proceso de configuración, tenemos que compilar 
nuestro nuevo núcleo. Para ello hay que hacer lo siguiente: 
<p>
<tt><bf>make dep   &nl   
make clean   &nl    
make bzImage</bf></tt>
<p>
<item>
Si en el proceso de configuración, elegimos alguna opción como módulo, 
tendremos que compilar/instalar dichos módulos: 
<p> 
<tt><bf>
make modules   &nl   
make modules_install</bf></tt>
<p>
<bf>NOTA</bf>: No olvidar ejecutar como root el comando <tt><bf>depmod -a</bf></tt> 
la primera vez que arranqueis con vuestro nuevo núcleo, para computar las 
dependencias entre módulos.
<p>
<item>
Ya tenemos el núcleo y los módulos compilados, ahora tenemos que instalarlo. 
Casi todo el mundo utiliza LILO para arrancar el sistema, por ello explicaré 
como instalarlo utilizando LILO. 
<p>
Todavia estamos en <tt>/usr/src/linux</tt> ,  ejecutar el comando <tt><bf>make install</bf></tt> , 
esto copiará el núcleo que acabamos de crear, a el directorio <tt>/boot</tt> 
de nuestro sistema, con el nombre <tt>vmlinuz</tt>, o como un enlace simbóolico 
<tt>vmlinuz -> vmlinuz-xx.yy.zz</tt> 
<p>
<item>
Ahora tenemos que configurar LILO para que reconozca el nuevo núcleo. 
Tendremos que modificar el fichero <tt>/etc/lilo.conf</tt>. Aquí teneis un ejemplo, 
del fichero <tt>/etc/lilo.conf</tt> antes de modificarlo: 
<verb>
  boot=/dev/hda 
  prompt 
  timeout=50 
  image=/boot/vmlinuz-2.0.34 
     label=linux 
     root=/dev/hda1 
     read-only 
</verb>

Y aqui como quedaría despues de la modificación, para que reconozca nuestro 
nuevo núcleo al arrancar: 
<verb>
  boot=/dev/hda 
  prompt 
  timeout=50 
  image=/boot/vmlinuz 
     label=nuevokernel 
     root=/dev/hda1 
     read-only 
  image=/boot/vmlinuz-2.0.34 
     label=linux 
     root=/dev/hda1 
     read-only 
</verb>
<item>                
Ahora solo tenemos que ejecutar el comando <tt><bf>/sbin/lilo</bf></tt> y arrancar 
el sistema de nuevo. Si tuviesemos algún problema con el nuevo núcleo, 
siempre podriamos arrancar con el antiguo escribiendo <tt>linux</tt> y 
pulsando <tt>ENTER</tt> cuando arrancamos y nos sale en pantalla <tt>lilo:</tt> 
De esta manera podemos entrar y ver que es lo que ha fallado.
<p>
<bf>NOTA</bf>: Recordar que existen multitud de opciones para configurar LILO, 
y que los ejemplos anteriores, son ejemplos. Puede que vuestro sistema necesite 
diferentes parámetros y opciones. Leeros los documentos HOWTOS sobre el núcleo y 
LILO antes de cambiar nada en vuestro sistema. Al final de esta sección teneis 
enlaces a los mismos. Suerte y espero que tengais las cosas un poco mas claras.
</enum>
 

<!-- *************************************** -->
<!-- SUBSECCIÓN QUE SON LOS PARCHES           -->
<!-- *************************************** -->

<sect1>¿Qué son los parches (patchs)? ¿Cómo se instalan? 
<p>

<bf>¿Qué son los parches y para qué sirven?</bf>: 
<p>
Un parche para el núcleo no es más, que un fichero que solamente contiene información, 
sobre las lineas de código que han cambiado desde la versión precedente del núcleo. 
De esta manera, solamente os teneis que bajar un fichero con los cambios, en vez,
del núcleo al completo. El ahorro en cantidad de Mb bajados es bastante considerable, 
sobre todo para aquellos que dependen del módem y no tienen una conexión buena a internet. 
<p>
Algo a tener muy en cuenta si vais a actualizar el núcleo por medio de parches, 
en vez de bajaros el núcleo al completo, es que teneis que ir actualizando de versión 
a versión. Para que se entienda un poco mejor, aqui teneis un ejemplo: 
<p>
Si teneis el núcleo 2.2.0 y vais a actualizarlo al 2.2.1, os podeis bajar el fichero 
patch-2.2.1.gz [70Kb] en vez, del núcleo 2.2.1 al completo [12.5Mb]. Pero si teneis 
el nucleo 2.2.0 y vais a actualizar al 2.2.4, <bf>NO</bf> os vale bajaros el fichero patch-2.2.4.gz 
nada más, tendriais que bajaros el 2.2.1, 2.2.2, 2.2.3 y 2.2.4. Esto es porque los ficheros 
patch solamente contienen los cambios de versión a versión. 
<p>
Si la diferencia entre la versión que teneis y la que quereis instalar, es muy grande 
(p.ej: del 2.2.0 al 2.2.10), no os merece la pena actualizar por medio de parches, 
en este caso bajaros la versión completa. 

<bf>¿Qué hacer con un fichero patch-XX.YY.ZZ.gz?</bf>: 
<p>
Ya os habeis bajado el fichero patch (se pueden bajar del mismo subdirectorio donde 
está la versión completa), que necesitas para actualizar el núcleo, y ahora, ¿qué hacemos?.
Ahora, hay que aplicarlo al núcleo que teneis y compilar de nuevo. El procedimiento 
para actualizar el núcleo por medio de ficheros patch es el siguiente: 
<itemize>
<item>Copiar el fichero patch-XX.YY.ZZ.gz al directorio <tt>/usr/src/</tt> : <tt>cp patch-XX.YY.ZZ.gz /usr/src/</tt> 
<item>Cambiar a este subdirectorio y descomprimir el fichero: <tt>cd /usr/src/; gunzip patch-XX.YY.ZZ.gz</tt> 
<item>Aplicar el parche: <tt>patch -s -p0 < patch-XX.YY.ZZ </tt> 
<item>La opción -s hara que solo se impriman mensajes de error. Si no recibís ningún 
mensaje de error (como debería de ser ;-)) solamente os queda entrar en <tt>/usr/src/linux</tt>: <tt>cd /usr/src/linux</tt> 
<item>Y ejecutar <tt>make clean, make xconfig, make dep, make bzImage</tt>, el resto 
es igual que en la <ref id="configuracion_kernel" name="sección anterior"> a partir del punto 11)
</itemize> 


<!-- *************************************** -->
<!-- SUBSECCIÓN ALGUN CONSEJO                -->
<!-- *************************************** -->

<sect1>¿Algún consejo sobre el kernel/núcleo?
<p>
<bf>Pregunta:</bf> ¿Necesito actualizar el núcleo que utilizo, cada vez 
que una nueva versión aparece?  &nl 
<bf>Respuesta:</BF> No. ¿Porqué? La explicación es la siguiente: 
<p>
Cuando un nuevo núcleo aparece, puede ser por las siguientes causas: 
<p>
<itemize>
<item> Nuevas características se han añadido.       
<item> Fallos de programación se han corregido.      
<item> Fallos de seguridad se han corregido.       
<item> Nuevo hardware es soportado.       
</itemize>
<p>
Si las características que se han añadido, no las vamos a utilizar, es evidente 
que no necesitamos actualizar. Si los fallos de programación que se han corregido  
afectan a características/drivers que no utilizamos, no necesitamos actualizar. 
Si no utilizamos el nuevo hardware soportado, tampoco necesitamos actualizar. 
<p>
De todas maneras es recomendable, actualizar de vez en cuando, sobre todo cuando 
se corrigen fallos de seguridad o cuando los cambios en el nuevo núcleo afectan 
a características/funciones/hardware que utilicemos. El código esta ahí, libre 
y esperando a ser compilado en un nuevo ordenador, cada usuario debe de decidir 
cuando es hora de una actualización.
<p>
             
<bf>Pregunta:</bf> ¿Soy nuevo en Linux y acabo de instalar una distribución, 
como actualizo el núcleo?  &nl 
<bf>Respuesta:</bf> Te aconsejo que esperes un poquito. La distribución que 
acabas de instalar (si es de las últimas) viene con un núcleo de los "últimos", 
totalmente funcional y que te sirve sin problemas. Utiliza el sistema un tiempo, 
familiarizate con el nuevo sistema que acabas de instalar, y cuando comprendas 
un poco más como funcionan las cosas, actualiza el núcleo.  Un buen punto de partida 
para encontrar información sobre el núcleo, lo tienes en estas páginas.


<!-- *************************************** -->
<!-- SUBSECCIÓN ENLACES SOBRE EL KERNEL      --> 
<!-- *************************************** -->

<sect1>Enlaces sobre el kernel 
<p>
<itemize>
<item><url url="http://www.kernel.org/" name="The LinuxKernel Archives">: Página principal/oficial sobre el núcleo.
<item><url url="http://kt.linuxcare.com/" name="Kernel Traffic">: Información sobre la lista de correo sobre el núcleo.
<item><url url="http://www.kernelnotes.org/" name="KernelNotes">: Mucha información sobre núcleo.
<item><url url="http://www.linuxmama.com/" name="LinuxMama">: Actualizaciones no oficiales. 
<item><url url="http://www.linux-es.com/docs/HOWTO/Kernel-HOWTO" name="Kernel Howto"> (Inglés) 
<item><url url="http://www.linux-es.com/docs/HOWTO/translations/es/Kernel-Como" name="Kernel Howto"> (Castellano)
<item><url url="http://www.linux-es.com/docs/HOWTO/mini/LILO" name="LILO MiniHowto"> (Inglés)
<item><url url="http://metalab.unc.edu/LDP/LDP/lkmpg/mpg.html" name="Guía de programación">: de módulos para el núcleo (Inglés)
<item><url url="http://metalab.unc.edu/LDP/LDP/tlk/tlk.html" name="The Linux Kernel">: Libro (Inglés)
</itemize>


<!-- ************************************* -->
<!-- ************************************* -->
<!--           SECCIÓN X-WINDOS            -->
<!-- ************************************* -->
<!-- ************************************* -->

<sect>XWindow / Gestores de ventanas


<!-- ************************************* -->
<!--   SUBSECCIÓN QUE ES XWindow          -->
<!-- ************************************* -->

<sect1>¿Qué es XWindow?
<p>
El protocolo XWindow fue desarrollado a mediados de los años 80 como respuesta a la necesidad de un interfaz gráfico transparente sobre todo para sistemas Unix. 
<p>
XWindow es el encargado de visualizar la información de manera gráfica y es totalmente independiente del sistema operativo (los sistemas Unix/Linux no necesitan de XWindow para funcionar, pudiendo trabajar en modo texto). La gran diferencia entre XWindow y la interfaz gráfica de otros sistemas operativos es que XWindow distribuye el procesamiento de aplicaciones, especificando un enlace cliente-servidor. El cliente X especificará "Que hacer" al servidor X, que se encargará de "Como hacerlo".
<p>
Pero dejémonos de teoría y pasemos a un ejemplo práctico. La gran ventaja de XWindow es que el servidor X de una aplicación y el cliente X donde trabajamos no tienen porque estar en la misma máquina. Podemos estar utilizando XWindow en nuestra máquina, conectarnos a otra remota, ejecutar un programa en esta máquina remota y utilizar/ver este programa en nuestra máquina local. Todo esto independientemente de la plataforma/sistema operativo que el ordenador remoto utilice. Como veis las posibilidades son muchas y potentes.  

<verb>
     Cliente X
        |
        |
       Xlib
        |
        |
    Servidor X
        |
        |
Sistema operativo
</verb>


<!-- *************************************** -->
<!-- SUBSECCIÓN COMO CONFIGURO XWindow      -->
<!-- *************************************** -->

<sect1>¿Cómo configuro XWindow?
<p>
Para utilizar el sistema en modo gráfico es necesario instalar XWindow en tu sistema. Existen servidores comerciales y bajo licencia GNU. En estos apartados nos basaremos en XWindow bajo licencia GNU, XFree86, ya que es el que se incluye en todas las distribuciones de Linux. 
<p>
Una vez instalado XWindow tendremos que configurarlo para que funcione en nuestro sistema. El fichero de configuración del XWindow se llama <tt>XF86Config</tt> y generalmente se encuentra en el directorio <tt>/etc/X11/</tt>.
<p>
Unos datos que teneis que saber antes de configurar XWindow son:
<itemize>
<item>Datos técnicos de la tarjeta gráfica que utiliceis, o por lo menos el nombre de la tarjeta. El programa <tt>/usr/X11R6/bin/SuperProbe</tt> os puede ayudar a obtener información sobre vuestra tarjeta.
<item>Datos técnicos del monitor que teneis, resoluciones/frecuencias de refresco verticales/horizontales a las que puede trabajar. Este punto es importante para evitar problemas posteriores con vuestro monitor. Estos datos deberian de estar explicados en la documentacion que viene con vuestro monitor.
</itemize>
<p>
Antes de lanzar XWindow mediante el comando
<tt>startx</tt> debemos asegurarnos de la correcta configuración de
los diferentes parámetros del mismo (teclado, ratón, tarjeta
de vídeo, etc.). Hay diferentes métodos para hacer esto.
<p>
 En primer lugar tenemos los programas de configuración
semi-automática. Según la distribución de Linux que utilicemos
tendremos a nuestra disposición una serie de programas que
nos permitirán realizar la configuración de XWindow de una
manera más o menos sencilla:
<itemize>
<item><bf>/usr/X11R6/bin/xf86config</bf> - Todas las distribuciones: Programa en modo texto.
<item><bf>/usr/X11R6/bin/XF86Setup</bf> -  SuSe, Redhat, Slackware: Programa en modo gráfico, tiene que arrancarse en una consola texto.
<item><bf>/usr/X11R6/bin/Xconfigurator</bf> Redhat: Programa semi-gráfico con menus.
</itemize>
<p>
 Estos programas nos preguntarán cosas básicas sobre el
teclado, el monitor, la videomemoria o la tarjeta de vídeo
instalada (lo harán cuando no sean capaces de detectarlas
por sí mismos). Debemos responder siempre la opción más
acertada y en cuanto a monitores, nunca especificar
características superiores de las que disponemos. Un caso
muy habitual en tarjetas muy nuevas es no encontrar un
soporte exacto para los últimos chipsets, problema que
se suele corregir acudiendo al soporte de framebuffer del
kernel o esperando a que quienes trabajan en XFree86
obtengan por parte de los fabricantes
la información sobre cómo programar sus tarjetas.
<p>
 En ciertos casos también se nos puede preguntar si deseamos
que el sistema arranque directamente en XWindow o incluso
testear los diferentes modos de vídeo para ver que si
son correctamente soportados.
<p>
 Además para que estos programas realicen una correcta
configuración el sistema debe estar ya correctamente
configurado en cuanto a modo texto se refiere. Por ejemplo,
Xconfigurator no activará el teclado en castellano para
XWindow si no hemos especificado que el idioma en que queremos
usar nuestro Linux es este mismo, mediante la orden
<verb>
  export LANG=es_ES
</verb>
 bien en la línea de comandos, o en el fichero <tt>/etc/profile</tt>.
Cuando <tt/Xconfigurator/ detecta esta variable de entorno ya sabe
qué lenguaje utiliza el usuario y por tanto configurará
XWindow para el correcto uso del teclado en este lenguaje.
Otras variables indican el tipo de ratón, etc. y suelen
ser correctamente especificadas por el programa de instalación.
En el caso de <tt/XF86Setup/ la configuración permite una mayor
participación por parte del usuario, ya que en lugar de
realizar una configuración automática proporciona una lista
de opciones para cada apartado, de modo que si conocemos
nuestro hardware es la mejor manera de configurar el sistema.
Además, a la hora de elegir resoluciones de vídeo, este
programa permite especificar cual es la resolución por
defecto deseada mientras que <tt/Xconfigurator/ deja marcada
la menor de ellas como "por defecto" (o la primera que
seleccionemos).
<p>
 El programa de configuración <tt/xf86config/ es el más antiguo de
todos, y realiza la configuración mediante preguntas que se
responderán con teclado. Nos preguntará la tarjeta de vídeo,
monitor, rango de frecuencias del monitor, videomemoria y
resoluciones de trabajo deseadas, así como el mapa del teclado
a utilizar (es 102 = España 102 teclas).
<p>
 Como siempre, el método más eficaz de configurar XWindow es
directamente editando los ficheros de configuración.Y es que
otro método de configuración básico es sencillamente editar
el fichero <tt>/etc/X11/XF86Config</tt>, que es en realidad lo que
hacen todos los programas comentados anteriormente. En este
fichero la configuración está dividida en secciones y mediante
cualquier editor de texto llano es posible cambiar cualquier
parámetro de XWindow.
<p>
 Este fichero se divide en varias categorías o secciones
(todas ellas con más subopciones muy bien comentadas en
dicho fichero de configuración):
<itemize>
<item>Sección Files: Indica los caminos hacia las fuentes o ficheros de colores.
<verb>
  RgbPath "/usr/X11R6/lib/X11/rgb"
  FontPath   "/usr/X11R6/lib/X11/fonts/75dpi:unscaled"
  (etc.)
</verb>
<item>Sección ServerFlags: Opciones varias sobre el servidor.
<item>Sección KeyBoard:Configuración del teclado. Para teclados en castellano las opciones son similares a las siguientes:
<verb>
  Protocol       "Standard"
  LeftAlt         Meta
  RightAlt        Meta
  ScrollLock      Compose
  RightCtl        Control
  XkbKeycodes     "xfree86"
  XkbTypes        "default"
  XkbCompat       "default"
  XkbSymbols      "us(pc101)"
  XkbGeometry     "pc"
  XkbRules        "xfree86"
  XkbModel        "pc101"
  XkbLayout       "es"
</verb>
<item>Sección Pointer: Configuración del ratón:
<verb>
  # Para un ratón microsoft mouse o un genius:
  Protocol    "Microsoft"
  Device      "/dev/mouse"
</verb>
<item>Sección Monitor: Datos sobre el monitor (frecuencias).
<item>Sección Device: Indica el servidor X a utilizar: Por ejemplo para una tarjeta con chipset Mach64:
<verb>
  Section "Device"
      Identifier  "Mach64 GB"
      VendorName  "ATI"
      BoardName   "ATI 3d Rage II"
      VideoRam    8192
  EndSection
</verb> 
<item>Sección Screen: Modos de vídeo seleccionados:
  Por ejemplo para activar 320x200, 640x480, 800x600 y 1024x768
  tanto a 8 como a 16 bpp de color, siendo usado por defecto el
  modo 1024x768x16 (el primero que aparezca en la lista):
<verb>
  Section "Screen"
     Driver      "accel"
     Device      "Mach64 GB"
     Monitor     "My Monitor"
     DefaultColorDepth 16
     Subsection "Display"
         Depth       16
         Modes       "1024x768" "800x600" "640x480" "320x200"
         ViewPort    0 0
         Virtual     1024 768
     EndSubsection
     Subsection "Display"
         Depth       8
         Modes       "1024x768" "800x600" "640x480" "320x200"
         ViewPort    0 0
         Virtual     1024 768
     EndSubsection
  EndSection
</verb>
</itemize>
 Una vez creado este fichero, entramos en XWindow mediante
el comando startx.
<p>
 Del entorno XWindow se puede salir en cualquier momento
mediante la combinación de teclas <tt>Ctrl+Alt+Borrar</tt>, o bien
seleccionando LOGOUT en el menú del gestor de ventanas que
utilicemos.
<p>
 Para volver a las consolas de texto bastará con utilizar
la combinación de teclas <tt>Ctrl+Alt+F1</tt>, <tt>+F2</tt>, etc (hasta <tt>F6</tt>
en las instalaciones por defecto). Para volver al terminal
gráfico se utiliza de F7 en adelante (<tt>Ctrl+Alt+F7</tt>, <tt>+F8</tt>, etc.).
<p>
 Si durante la instalación (o en la línea apropiada del
fichero <tt>XF86Config</tt>) seleccionamos varias resoluciones de vídeo,
es posible cambiar entre ellas mediante las teclas <tt>Ctrl+Alt+'+'</tt>
y <tt>Ctrl+Alt+'-'</tt> (los signos del teclado numérico).
<p>
 Además, si por defecto marcamos 8bpp (o 16 bpp) en las opciones,
nada nos impide lanzar posteriormente XWindow en la profundidad
de color deseada:
<verb>
  [sromero@localhost]# startx -- -bpp 8
  [sromero@localhost]# startx -- -bpp 16
  etc.
</verb>
 También es posible establecer la profundidad de color por
defecto mediante una línea DefaultColorDepth = 16 en el fichero
de configuración <tt>XF86Config</tt>, sección Screen.
<p>
 Por último, saber que podemos lanzar más de una sesión de
XWindow simultáneamente (en las consolas accesibles desde
<tt>Ctrl+Alt+F8</tt>, <tt>+F9</tt>, etc.), mediante:
<verb>
  [sromero@localhost]# startx -- :1
  [sromero@localhost]# startx -- :2
  etc.
</verb>


<!-- ************************************************ -->
<!-- SUBSECCIÓN COMO CAMBIO LA RESOLUCIÓN POR DEFECTO -->
<!-- ************************************************ -->

<sect1>¿Cómo cambio la resolución por defecto?
<p>
En el fichero <tt>/etc/X11/XF86Config</tt> en la sección screen correspondiente al servidor que se está utilizando actualmente, en la subsección Display
correspondiente a la Depth en que estemos trabajando, buscamos la linea:
<verb>
  Modes "resolución_1" "resolución_2"...
</verb>
Un ejemplo:
<verb>
  Modes       "1024x768" "800x600" "640x480" "320x200"
</verb>
Entonces ponemos la resolución que queramos que sea por defecto de primera. Estas resoluciones puestas aquí son entre las que podremos cambiar si queremos al pulsar <tt>Ctrl+ Alt+ '+'</tt> ó <tt>Ctrl+Alt+'-'</tt>, una vez arrancado XWindow.


<!-- ******************************************** -->
<!-- SUBSECCIÓN COMO CAMBIO EL ESCRITORIO VIRTUAL -->
<!-- ******************************************** -->

<sect1>¿Cómo cambio el escritorio virtual?
<p>
En el fichero <tt>/etc/X11/XF86Config</tt>, en la sección screen correspondiente al servidor que se está utilizando actualmente, en la
subsection Display correspondiente a la Depth en que estemos trabajando, añadimos la línea:
<verb>
  Virtual tamaño_x tamaño_y  #en píxeles
</verb>
Un ejemplo:
<verb>
  Virtual     1024 768
</verb>
Hay que puntualizar que si existe una resolución definida de <tt/Modes/ mayor que el escritorio virtual, esta no se podra utilizar. Resumiendo, no se puede tener una resolución de trabajo mayor que el escritorio virtual.


<!-- ******************************************* -->
<!-- SUBSECCIÓN COMO CAMBIO EL NUMERO DE COLORES -->
<!-- ******************************************* -->

<sect1>¿Cómo cambio el numero de colores por defecto?
<p>
Hay dos maneras:
<p>
Mediante la línea de comandos:
<verb>
  [user@localhost]# startx --bpp resolución  (dónde resolución es 8, 16,24 ó 32) 
</verb>
Mediante el fichero de configuración:
<p>
En el fichero <tt>/etc/X11/XF86Config</tt>, en la sección screen correspondiente al servidor que se está utilizando actualmente, añadimos la línea:
<verb>
  DefaultColorDepth depth_que_queramos_utilizar
</verb>
Un ejemplo:
<verb>
  DefaultColorDepth 16
</verb>
Un Depth con valor 8 significa que trabajaremos a 256 colores, uno con valor 32 truecolor. No todas las tarjetas graficas podran utilizar todos los Depth disponibles en todas las resoluciones, todo dependera de la tarjeta grafica y de la memoria que esta tenga.


<!-- ************************************************* -->
<!-- SUBSECCIÓN COMO ARRANCO DIRECTAMENTE EN XWindow  -->
<!-- ************************************************* -->

<sect1>¿Cómo arranco directamente en XWindow?
<p>
En Linux es perfectamente posible pedir que el arranque del
sistema se haga en modo gráfico, y que el login y password se
introduzcan directamente en una ventana XWindow para la posterior
carga del gestor de ventanas habitual que use dicho usuario.
<p>
Es decir, podremos identificarnos y aparecer directamente bajo
X sin necesidad de ejecutar <tt>startx</tt>.
<p>
Para arrancar directamente en XWindow (o no hacerlo) todo el
proceso de configuración gira en torno a cambiar el runlevel
(o nivel de ejecución en que arranca Linux).
<p>
El runlevel es, dicho de una manera sencilla, el modo en que
arranca Linux. Por defecto el runlevel suele ser el 2 ó el 3,
es decir, arranque en modo texto o consola ó en modo gráfico. Para cada distribución
suele haber una lista de runleves y sus significados, aunque casi
se puede decir que son similares para todas ellas. Para Redhat,
por ejemplo, la lista es la siguiente:
<verb>
  # Porción del fichero /etc/inittab
  # Default runlevel. The runlevels used by RHS are:
  #   0 - halt (Do NOT set initdefault to this)
  #   1 - Single user mode
  #   2 - Multiuser, without NFS (The same as 3)
  #   3 - Full multiuser mode
  #   4 - unused
  #   5 - X11
  #   6 - reboot (Do NOT set initdefault to this)
</verb>
Como puede verse, el arranque normal por defecto para que
puedan acceder usuarios a Linux es 2 (si no tenemos red)
o 3 si queremos usar servicios de red, siendo normalmente
este el runlevel por defecto. Como puede verse, X11 tiene
asignado el runlevel al 5. Si cambiamos el runlevel por
defecto para que arranque en el 5, nos aparecerán directamente
X Window.
<P>
 Para cambiar este runlevel por defecto hay que editar el
fichero <tt>/etc/inittab</tt>, y acudir a la siguiente línea:
<verb>
  id:3:initdefault:
</verb>
El valor numerico antes de initdefault indica el runlevel
de arranque por defecto. Si lo cambiamos de 3 a 5, la próxima
vez que arranquemos Linux arrancará en X Window:
<verb>
  id:5:initdefault:
</verb>
Para que el proceso se ejecute correctamente debe tener
instalado un gestor de arranque en runlevel 5, que es el
programa encargado de pedir el login+passwd y arrancar el
gestor de ventanas adecuado. Puede elegir entre xdm (el
que viene por defecto con XWindow), kdm (version de kde del
mismo) y gdm (versión aportada por gnome). Cada una de ellas
dispone de ciertos ficheros de configuración o ejecutables
para cambiar el fondo del login, el lenguaje, gestor de ventanas,
etc. Consulte los ficheros en los paquetes relacionados.
<p>
Haga "man runlevel" para mas información sobre runlevels.
<p>
En las últimas versiones de Redhat, el programa <tt>Xconfigurator</tt>
le permite elegir si desea o no arrancar directamente en XWindow
(él mismo modifica el runlevel por defecto) mediante una simple
pregunta a la que se debe responder SI (Si desea arrancar en
runlevel 5) o NO (si desea arrancar en runlevel 3). Esta pregunta
se le suele realizar al finalizar la selección de resoluciones y
antes de salir de <tt>Xconfigurator</tt>.
<p>
Una vez arranque en XWindow, puede volver a cualquier consola
de texto mediante las teclas <tt>Ctrl+Alt+F1, Ctrl+Alt+F2, etc</tt>.
(por defecto entre F1 y F6 tendrás 6 consolas de texto), y
volver a XWindow en cualquier momento mediante <tt>Ctrl+Alt+F7</tt>
en adelante.
<p>
En algunas distribuciones puede ser necesario indicarle a
inittab dónde está el gestor de runlevel 5 que debe arrancar:
<p>
Para xdm:
<verb>
  #Run xdm in runlevel 5
  x:5:respawn:/usr/X11R6/bin/wdm -nodaemon
</verb> 
Para gdm:
<verb>
  x:5:respawn:/etc/X11/prefdm -nodaemon
</verb>
Estas líneas suelen ser automáticamente incluidas en el fichero
por los rpm/deb instaladores de xdm, kdm y gdm. Consulte en la
ayuda de dichos programas para más información.


<!-- ********************************************** -->
<!-- QUE ES UN GESTOR DE VENTANAS?                  -->
<!-- ********************************************** -->

<sect1>¿Qué es un gestor de ventanas?
<p>
Un gestor de ventanas no es otra cosa que el conjunto de programas, ventanas, funcionalidades, .... que hacen posible que el usuario pueda interactuar con el sistema de forma gráfica y no en modo texto.
<p>
Para usar un gestor de ventanas, hay que tener configurado un <em/servidor X/. También hay que decir que el <em/gestor de ventanas/ utilizado es totalmente independiente del <em/servidor X/ utilizado. 
<p>
<verb>
  Gestor de ventanas
        |
        |
     Cliente X
        |
        |
       Xlib
        |
        |
    Servidor X
        |
        |
Sistema operativo
</verb>
Al contrario que en otros sistemas operativos, en Linux no es necesario utilizar un <em/servidor X/ - <em/gestor de ventanas/ para usar el sistema. El sistema operativo y el conjunto <em/servidor X/ - <em/gestor de ventanas/ usado, son cosas totalmente diferentes, independientes entre si. Es más, existen usuarios que trabajan en modo texto sin ningun problema y sin usar un interfaz gráfico. 
<p>
Existen numerosos y variados gestores de ventanas para Linux, unos mejores y otros más desarrollados y estables. Es el usuario el que tiene que decidir que gestor satisface mejor sus necesidades, pudiendo incluso tener mas de uno instalado. Para aclarar un poco las cosas, podriamos decir que, si un ordenador es usado por varios usuarios, todos utilizarán el mismo <em/servidor X/ pero no necesariamente el mismo <em/gestor de ventanas/.


<!-- ***************************************************************** -->
<!-- SUBSECCIÓN ¿COMO ELIJO EL GESTOR DE VENTANAS QUE QUIERO ARRANCAR? -->
<!-- ***************************************************************** -->

<sect1>¿Cómo elijo el Gestor de ventanas que quiero arrancar?
<p>
 Una vez configurado X se hace necesario decirle a XWindow
qué gestor de ventanas debe arrancar. Dicho de una manera
sencilla, XWindow es la conjunción de 3 componentes:
<itemize>
<item>El entorno de ventanas XWindow: Es quien implementa
     las llamadas internas de XWindow, el protocolo X,
     etc., es decir, el sistema de comunicaciones entre
     aplicaciones.
<p>
<item>El servidor gráfico X. Es un programa (un fichero
     ejecutable) encargado de responder a las órdenes
     gráficas encargadas por el entorno de ventanas. Es
     el encargado de dibujar rectángulos, puntos de color
     o pixels, rellenar zonas, dibujar imágenes, etc.
     La manera de decirle a XWindow qué ejecutable es el
     que deseamos usar es crear un enlace simbólico llamado
     <tt>/usr/X11R6/bin/X</tt> que apunte al servidor que usemos:
<verb>
  Ej: ln -s /usr/X11R6/bin/XF86-S3 /usr/X11R6/bin/X
  (le diría que utilice el servidor de las S3).
</verb>
     Este enlace es creado por el programa de configuración
     cuando seleccionamos la tarjeta en la lista que nos presenta.
<p>
<item>El gestor de ventanas es el módulo encargado de
     decidir que aspecto, forma, funcionalidades, atajos
     de teclado, opciones y menúes debe tener XWindow.
</itemize>
 Así, al dividir XWindow en estos 3 módulos se nos
permite cambiar cualquiera de ellos para dotar a XWindow
del aspecto o funcionalidades que deseemos. El entorno
de ventanas no suele cambiarse nunca (es XFree86), y el
servidor X tampoco, ya que éste último es siempre el
ejecutable apropiado para manejar nuestra tarjeta gráfica
(XFree86-SVGA, XFree86-S3, etc.), pero el último es
totalmente seleccionable entre multitud de opciones y es
lo que nos permite cambiar radicalmente el aspecto de
XWindow. Cambiando el gestor de ventanas (o Window Manager)
podemos cambiar prácticamente el funcionamiento completo
de XWindow.
<p>
 Gestores de ventanas hay muchos: kde, afterstep, gnome,
WindowMaker, icewm, etc, y todos tienen sus respectivos
ejecutables: startkde, afterstep, gnome-session, wmaker, icewm,
etc. Toda esta explicación se ha dado por un motivo muy
sencillo: la posibilidad de elegir el Gestor de Ventanas
deseado es parte de la configuración activa de XWindow, y
vamos a ver la manera de decirle a XWindow qué gestor
deseamos utilizar.
<p>
 Para ello, simplemente debemos ir al directorio HOME
del usuario en cuestion (<tt>/home/usuario</tt>) o de root (<tt>/root</tt>)
y editar (creándolo si no existe) el fichero de texto
.xinitrc . En este fichero pondremos una línea que indicará
el Gestor de Ventanas que deseamos utilizar, en el formato:
<verb>
  exec ejecutable_del_gestor_de_ventanas
</verb>
 Además podemos utilizar líneas de comentarios que comiencen
por el carácter '#' y que XWindow ignorará:
<p>
 Ejemplos de ficheros <tt>.xinitrc</tt>:
<verb>
  # utilizar afterstep
  exec afterstep
</verb>
 otro ejemplo podría ser lanzar kde:
<verb>
  # utilizar KDE
  exec startkde
</verb>
 Así, dependiendo del ejecutable que lancemos (startkde,
gnome-session, icewm, wmaker, ctwm, fvwm2, wmaker, blackbox,
etc.) podremos arrancar el WM deseado.
<p>
<bf>NOTA</bf>: Si tenemos nuestro sistema configurado para arrancar directamente en XWindow, tendremos que
utilizar el fichero <tt>.Xclients</tt> en vez de <tt>.xinitrc</tt>, el formato es igual en los
dos ficheros.
<p>

<!-- **************************************************** -->
<!-- SUBSECCIÓN DONDE CONSIGO UN NUEVO GESTOR DE VENTANAS -->
<!-- **************************************************** -->

<sect1>¿Dónde consigo un nuevo gestor de ventanas?
<p>
Muchas distribuciones incluyen en sus CDes una serie de gestores de ventanas. 
También os lo podeis bajar de sus respectivos servidores web:
<p>
<itemize>
<item><bf>AfterStep</bf>: <url url="http://www.afterstep.org" name="http://www.afterstep.org">
<item><bf>Gnome</bf>: <url url="http://www.gnome.org/" name="http://www.gnome.org/">
<item><bf>KDE</bf>: <url url="http://www.kde.org" name="http://www.kde.org">
<item><bf>FVWM</bf>: <url url="http://www.hpc.uh.edu/fvwm/" name="http://www.hpc.uh.edu/fvwm/">
<item><bf>Enlightenment</bf>: <url url="http://www.rasterman.com/" name="http://www.rasterman.com/">
<item><bf>WindowMaker</bf>: <url url="http://www.windowmaker.org/" name="http://www.windowmaker.org/">
<item><bf>mlvwm</bf>: <url url="http://www.bioele.nuee.nagoya-u.ac.jp/member/tak/mlvwm.html" name="http://www.bioele.nuee.nagoya-u.ac.jp/member/tak/mlvwm.html">
<item><bf>TkDesk</bf>: <url url="http://people.mainz.netsurf.de/~bolik/tkdesk/" name="http://people.mainz.netsurf.de/~bolik/tkdesk/">
<item><bf>eXode</bf>: <url url="http://www.simplicity.net/exode/" name="http://www.simplicity.net/exode/">
<item><bf>wm2</bf>: <url url="http://www.all-day-breakfast.com/wm2/" name="http://www.all-day-breakfast.com/wm2/">
<item><bf>icewm</bf>: <url url="http://www.kiss.uni-lj.si/~k4fr0235/icewm/" name="http://www.kiss.uni-lj.si/~k4fr0235/icewm/">
</itemize>


<!-- *************************************** -->
<!-- *************************************** -->
<!--      SECCIÓN ADMINISTRACIÓN             -->
<!-- *************************************** -->
<!-- *************************************** -->

<sect>Administración


<!-- *********************************************** -->
<!-- SUBSECCIÓN PUEDO TRABAJAR NORMALMENTE COMO ROOT -->
<!-- *********************************************** -->

<sect1>¿Puedo trabajar normalmente como root?
<p>
Un consejo, solo utilizar la cuenta de root (administrador) para tareas 
de administración. Para trabajar normalmente con el sistema NO hacerlo como 
root, ya que se tiene acceso completo a todo el sistema y es fácil de estropear 
cosas si no se sabe lo que se hace.
<p>
Aqui teneis un ejemplo que le ocurrio al autor de esta subsección trabajando como root: 
<quote><em>
"Sólo utilizo la cuenta de root para administración del sistema, pero un día 
estuve demasiado tiempo trabajando con ella para intentar empaquetar un rpm, 
resulta que lo instalé mal y creé el directorio <tt>/usr/src/redhat/usr/src/redhat/SRC/</tt>, 
eso no era lo que quería, así que tecleé: </em>
<verb> 
  [root@asimovI src]$ cd .. ; rm -rf * 
</verb>
<em>Yo pensaba que estaba dentro del segundo usr, pero estaba en el primero, menos mal 
que me di de cuenta pronto y pulsé <tt/Ctrl+c/ para abortar el comando de borrado mientras 
se estaba borrando el directorio <tt/X11R6/, así que no corrompí/destrocé por completo el 
sistema, sólo tuve que volver a instalar algunos paquetes. Pero ¿y si no me doy cuenta?, 
pues que no podría haber hecho nada ya que hubiese borrado todo el contenido de <tt>/usr</tt> 
no existirían librerías, comandos, etc, teniendo que haber instalado el sistema operativo de nuevo." 
</em></quote>
<p>
Después de este ejemplo, volvemos a recomendar lo que dijimos al principio, utilizar la 
cuenta de root solo en los casos necesarios y siempre teniéndole un respeto al poder que da. 
Estar seguros al 100% de lo que haceis como root, para no estropear el sistema. 
Una buena costumbre es nunca hacer login con root, sino trabajar como un usuario normal 
y cuando se necesite ser root hacer un <tt/su/, y tan pronto como deje de ser necesario 
tener el privilegio hacer un <tt/exit/, para volver a trabajar como usuario normal.


<!-- *************************************** -->
<!-- SUBSECCIÓN COMO ABRO/CIERRO UNA CUENTA  -->
<!-- *************************************** -->

<sect1>¿Cómo abro/cierro una nueva cuenta?
<p>
Aquí veremos como abrir y cerrar una cuenta de usuario.
<p>
<bf/Abrir una nueva cuenta/.
<p>
El abrir una nueva cuenta, no es más que añadir una entrada en el archivo<tt>/etc/passwd</tt> 
del sistema. Una entrada en este archivo tiene la siguiente forma:
<verb>
  <user>:<encrip>:<UID>:<GID>:<informacion>:<home>:<shell>

  user:        Es el nombre de usuario.
  encrip:      Es la clave encriptada.
  UID:         Es el número UID con el que nos identificará el kernel.
  GID:         El numero de grupo principal GID al que pertenecemos.
  información: Información varia, tal como nombre completo del usuario, 
               número de teléfono, e-mail, etc.
  home:        Es el directorio home del usuario, es decir, el directorio al que 
               accedemos justo después de hacer entrar en el sistema.
  shell:       Es el shell que se abrirá para ejecutar las órdenes que de el usuario.
</verb>
Hay utilidades que hacen que añadir cuentas de usuario sea más fácil. Entre ellas 
están el comando <tt>/usr/sbin/adduser</tt> o <tt>/usr/sbin/useradd</tt> y <tt>/usr/bin/passwd</tt>. 
Lo pasos para crear un usuario son:
<verb>
  [root@asimovI /root] /usr/sbin/adduser mario
  [root@asimovI /root] passwd mario
</verb>
Para más información hacer <tt/man adduser/, sobre todo si se quiere poner caducidad a las claves. 
<p>
Hay otras utilidades más vistosas y fáciles de usar e intuitivas ya que son bajo 
XWindow, un ejemplo de éstas son en el <tt/contol-panel/ de redhat, el YaST en SuSE, 
el gestor de usuarios de Kde, etc.
<p>
Hay que aclarar que si el campo de la clave encriptada del fichero <tt>/etc/passwd</tt> 
no contiene ningun valor, no sera necesario la utilización de una clave para entrar en el 
sistema. Esto es totalmente desaconsejable por los problemas de seguridad que puede crear.
<p> 
Sin embargo es útil, por ejemplo, cuando nos olvidamos de la clave de root, 
la solución es arrancar con un disket de rescate, luego montar la partición 
de linux, y borrar la clave encriptada de la entrada de root en el fichero 
<tt>/etc/passwd</tt>. Luego reiniciamos el equipo, entramos como root y ejecutamos 
<tt/passwd root/ para poner la nueva contraseña.
<p>
<bf>NOTA</bf>: Este sistema de cambio de clave para la cuenta root no siempre funciona, 
dependiendo de la distribución que tengamos ó de como tengamos configurada la seguridad
en nuestro sistema.
<p>
<bf/Borrar una cuenta de usuario/.
<p>
El comando a utilizar es <tt>/usr/sbin/userdel</tt> el cual tiene la siguiente sintaxis:
<verb>
  userdel [-r][login]
</verb>
Este comando borra el usuario <em>login</em>, y si se añade 
la opción <tt/-r/ también borra su directorio de usuario.
<p>
Para borrar una cuenta de usuario también se pueden utilizar las 
utilidades gráficas que comentamos antes, de una forma muy intuitiva.


<!-- ******************************************************* -->
<!-- SUBSECCIÓN TENGO UN EJECUTABLE QUE NO QUIERE EJECUTARSE -->
<!-- ******************************************************* -->

<sect1>Tengo un ejecutable que no quiere ejecutarse.
<p>
A todos nos a ocurrido alguna vez, que al intentar ejecutar un comando/programa 
hemos obtenido como respuesta <tt/command not found/.
<p>
Esto significa que el shell/intérprete de comandos no encontró el comando que 
queríamos ejecutar. Las causas más comunes suelen ser:
<itemize>
<item>El ejecutable no está en un subdirectorio incluido en el &dollar PATH.    &nl  
La solución es escribir el ejecutable con la ruta completa ó cambiar al directorio donde
 este el programa y escribir <tt>./programa</tt>, donde programa es el nombre del ejecutable.
<p>
<bf>NOTA</bf>: Algunos usuarios tienen el sistema configurado para que no sea necesario
esto último que hemos explicado. Para ello tienen incluido en el &dollar PATH <tt>"."</tt>.
Esto hará que podamos ejecutar cualquier programa independientemente del directorio donde
se encuentre. Esta práctica es totalmente desaconsejable por los problemas de seguridad
que puede dar.  

<item>El comando/programa que habeis escrito no existe.

<item>Faltan variables de entorno.   &nl  
Busca ficheros de documentación del programa, o prueba <tt/comando --help/, 
para ver si hace falta añadir variables de entorno, para el uso del mismo.
</itemize>
Otra respuesta que podemos obtener al intentar ejecutar un comando/programa es <tt/Permission denied/. 
<p>
El error es bien claro, el ejecutable existe pero no tenemos permiso para ejecutarlo, 
comprueba que lo podemos ejecutar, es decir, tiene una x en el grupo al que 
pertenezcamos: dueño, grupo, u otros. Mas información sobre permisos en 
la subsección <ref id="permisos" name="¿Cómo se cambian los permisos de ficheros y directorios?">. 
<p>
Por ultimo, podemos obtener un error en el que se nos informa que cierta librería no se encuentra.
<p>
Ejecuta el comando:
<verb>
  [asimov@asimovI bin] ldd comando
</verb>
Esto mostrará todas las librerías compartidas que el comando/programa utiliza/necesita para funcionar. 
<p>
Si no tenemos algunas, las tenemos que instalar, pero si las tenemos tenemos que comprobar 
que <tt>/sbin/ld</tt> (el cargador de librerías dinámicas) sabe donde están, 
para ello hemos de añadir una entrada en el fichero <tt>/etc/ld.so.conf</tt> 
que consiste en poner el directorio donde esta la librería, luego ejecutamos 
<tt>/sbin/ldconfig -D</tt> para cerciorarnos que la lee.


<!-- ******************************************** -->
<!-- SUBSECCIÓN COMO FORMATEAR DISKETTES EN LINUX -->
<!-- ******************************************** -->

<sect1>¿Cómo dar formato a un disquete en Linux?
<p>
El formato de disquetes en Linux depende del tipo de formato
que se le desee dar al disquete (tipo MSDOS, tipo FAT32/VFAT,
tipo Ext2 de Linux, minix, etc.). En general solo hay
que usar uno de los comandos <tt>mkfs</tt> disponibles, que creará el
sistema de ficheros pertinente:
<p>
Para formatear disquetes en formato Linux-ext2
<verb>
  mkfs.ext2 [opciones] /dev/fd0
</verb>
o bien su equivalente:
<verb>
  mke2fs [opciones] /dev/fd0
</verb>
El usuario que formatee deberá tener permiso de escritura para la
disquetera (normalmente <tt>/dev/fd0</tt>). Para eso debe estar en el grupo
de usuarios floppy o que <tt>/dev/fd0</tt> tenga permisos 666 (para todo el
mundo).
<p>
Para formatear disquetes en formato msdos
<verb>
  mkfs.msdos [opciones] /dev/fd0
</verb>
o bien:
<verb>
  mkdosfs [opciones] /dev/fd0
</verb>
Otro comando disponible si tenemos instaladas las mtools es mformat:
<verb>
  mformat a:
</verb>
Este ultimo comando formateara el disquete en formato ms-dos.
<p>
Por último, existen otros programas como <tt>fdformat</tt> o <tt>superformat</tt> 
(ver paquete fdutils) que también sirven para dar formato a disquetes.
<p>
<bf/NOTA/: Formatos del tipo ext2 y ms-dos son los que se utilizan más usualmente 
en linux. Hay que aclarar que un disquete con formato ext2 <em/No será posible leerlo/ 
bajo ms-dos o Windows, solamente bajo Linux. Un disquete con formato ms-dos podrá ser 
leido indistintamente por ms-dos, windows o Linux (si tenemos soporte en el kernel/núcleo 
para trabajar con este formato).
 

<!-- ********************************************************** -->
<!-- SUBSECCIÓN COMO PUEDO MONTAR Y DESMONTAR UNIDADES EN LINUX -->
<!-- ********************************************************** -->

<sect1>¿Cómo puedo montar y desmontar unidades en Linux?
<p>
Montar un sistema de ficheros/dispositivo a nivel usuario no es más que hacerlo 
disponible en el árbol de directorios de nuestro sistema. Como ya sabeis, en Linux 
vemos todos los sistemas de ficheros/dispositivos en un sólo árbol de directorios, 
no existen letras a:, c:, etc., de esta manera nos da igual que el contenido de un 
directorio sea un sistema de ficheros msdos, vfat, ext2, se encuentre en diferentes 
discos/particiones, esté en una máquina remota, etc. Esta abstracción tiene un 
inconveniente, hay que montarlo, es decir, indicarle al kernel de Linux que a través 
del directorio XXXX, accedemos al sistema de ficheros/dispositivo yyy. 
Esto se hace con el comando mount (<tt>man mount</tt>, para detalles).
<p>
Montar un sistemas de ficheros/dispositivo a nivel kernel, no es más que rellenar 
unas tablas de registro. Es decir, ver si el sistema de ficheros está soportado, o lo que es lo mismo, 
si existe la tabla de funciones con las que manejarlo. Luego registrar estas funciones 
y enlazar el directorio al sistema de ficheros. Esto es más bien lo que hace 
la llamada al sistema mount, la cual es llamada mediante el comando del mismo nombre.
<p>
Los parametros necesarios para montar un sistema de ficheros son:
<itemize>
<item><em>Tipo de sistema de ficheros</em>: Es necesario indicarle el tipo 
de sistemas de ficheros a registrar. Así sabrá que funciones utilizar.

<item><em>Tipo de acceso</em>: Si es de sólo lectura, sólo escritura o ambos.

<item><em>Dispositivo</em>: Indicar el dispositivo sobre el que está físicamente 
el sistema de ficheros,( p.e.: <tt>/dev/hda1, /dev/hdb, /dev/sda1</tt>,..., none si es el <tt>/proc</tt>, 
ya que se realiza sobre la memoria).

<item><em>Directorio</em>: Indica el directorio sobre el que se va a montar, es decir, 
el directorio mediante el cual accederemos al sistema de archivos.
</itemize>

Ejemplo: Montar el cdrom en el directorio /dev/cdrom.
<verb>
  mount -t <sistema de ficheros> <Dispositivo> <Directorio>
  mount -t iso9660 /dev/hdb /mnt/cdrom
</verb>
Supongo que ya comprendereis el inconveniente de esto: Cada vez que se quiere 
acceder a un cdrom se ha de ejecutar el comando anterior, en vez de teclear <tt>d:</tt> 
(como en otros sistemas operativos). Pero la versatilidad y la flexibilidad que ofrece 
hace que no se tenga en cuenta ese inconveniente (como usuario accedo dentro de un directorio 
sin que me pase por la cabeza por ejemplo que ese fichero está al otro lado del planeta 
utilizando para ello el protocolo nfs). 
<p>
Existen otras formas de reducir la línea de comandos, para ello (entre otras cosas) 
existe el fichero <em>/etc/fstab</em>. En él se indican los sistemas de ficheros sobre 
los que trabajamos normalmente: el sistema de ficheros en el que tenemos los directorios 
de linux, el /proc, la partición dos, el cdrom, y el floppy.<p>
El fichero <em>/etc/fstab</em> funciona de la siguiente manera:
<p>
Partimos de un ejemplo de contenido de <tt>/etc/fstab</tt>:
<verb>
  # <device> <mountpoint> <filesystemtype> <options>                        <dump> <fsckorder>

  /dev/hda2  /            ext2             defaults                            1       1
  /dev/hda3  /usr         ext2             defaults                            1       2
  /dev/sda1  /home        ext2             defaults                            1       2
  /dev/hdb   /mnt/cdrom   iso9660          user,noexec,nodev,nosuid,ro,noauto  0       0
  /dev/fd0   /mnt/floppy  vfat             user,noexec,nodev,nosuid,rw,noauto  0       0
  none       /proc        proc             defaults                            0       0
  /dev/hda4  swap         swap             defaults                            0       0
  /dev/hda1  /mnt/dos     vfat             exec,dev,suid,rw,auto               0       0                      
</verb>
Con la información contenida en este fichero, el sistema haria lo siguiente al arrancar el sistema:
<itemize>
<item>La partición <tt>/dev/hda1</tt> se montaria en el subdirectorio <tt>/mnt/dos</tt>
<item>La partición <tt>/dev/hda2</tt> se montaria en el subdirectorio <tt>/</tt>
<item>La partición <tt>/dev/hda3</tt> se montaria en el subdirectorio <tt>/usr</tt>
<item>La partición <tt>/dev/hda4</tt> se montaria en el subdirectorio como <tt>swap</tt>
<item>La partición <tt>/dev/sda1</tt> se montaria en el subdirectorio <tt>/home</tt>
<item><tt>Proc</tt> se montaria en el subdirectorio <tt>/proc</tt>
<item>El sistema tendria información sobre como montar un disquete <tt>/dev/fd0</tt> 
y un CD-Rom <tt>/dev/hdb</tt>, aunque no los monta automaticamente al arrancar 
por haber definido la opción <tt>noauto</tt>.
</itemize>
Veamos la explicación de los parametros usados en <tt>/etc/fstab</tt>:
<p>
En la columna de dispositivo (device) se indica el dispositivo/partición a montar, 
en la punto de montaje (mountpoint) se indica el directoria mediante el cual vamos a acceder 
al sistema de archivos. En la columna de tipo de sistema de ficheros (filesystemtype) se 
indica el sistema de ficheros que se usara sobre el dispositivo. 
<p>
Las opciones (options) significan lo siguiente:
<itemize>
<item><em>user,nouser</em>: permite/no permite a un usuario ordinario montar el sistema de ficheros. 

<item><em>suid,nosuid</em>: Permite/no permite tener ficheros con el bit de usuario definido.

<item><em>auto/noauto</em>: Indica que sí/no se monta cuando hacemos mount -a.

<item><em>defaults</em>: Aplica las opciones rw,suid,dev,exec,auto,nouser,async.

<item><em>exec/noexec</em>: Permite/no permite la ejecución de binarios.

<item><em>ro,rw</em>: Montar sólo lectura, lectura-escritura.

<item><em>sync/async</em>: Todos los accesos I/0 al sistema de ficheros se realizarán 
en modo sincrono/asincrono.

<item><em>dev/nodev</em>: Interpreta/no interpreta los dispositivos especiales de bloques/caracteres 
en el sistema de ficheros.
</itemize>

El fichero <tt>/etc/fstab</tt> de nuestro ejemplo nos permitiría hacer lo siguiente para montar un disquete o CD-Rom:
<verb>
  mount /mnt/cdrom 
  mount /mnt/floppy
</verb>
Cuando dejamos de utilizar un sistema de ficheros, tenemos que darlo de baja (desmontarlo), para eliminar todas las referencias del kernel a él. El comando utilizado para esto es <tt>umount</tt>. 
<p>
Para desmontar un sistema de ficheros/dispositivo:
<verb>
  umount <directorio|dispositvo>
</verb>
ej:
<verb>
  umount /mnt/floppy  
  umount /dev/fd0 
</verb>

<bf>NOTA</bf>: Es necesario ejecutar el comando <tt>umount</tt> cada vez que cambiemos un disquete, ya que no siempre cuando se escribe en un dispositivo, se realiza automáticamente un volcado al dispositivo (por eso se pueden perder datos si se apaga el ordenador a lo bruto). Además si cambiamos el disquete sin hacer umount, el kernel piensa que hay el sistema de ficheros anterior y cuando guarda alguna información lo hace con referencia al retirado, perdiéndose todo. 
<p>
Este es un punto a tener en cuenta con el uso de disquetes, ya que, el mecanismo para retirar un disquete es mecánico, no existe posibilidad de impedir por medio de software que álguien saque un disquete de la disquetera. No ocurre lo mismo con el CD-Rom, ya que el sistema bloqueará la posibilidad de extraerlo cuando este montado.

<!-- ******************************************************** -->
<!-- SUBSECCIÓN COMO CREAR UN DISKETTE DE ARRANQUE PARA LINUX -->
<!-- ******************************************************** -->

<sect1>¿Cómo se crea un disquete de arranque para Linux?
<p>
Solo tenemos que ejecutar los siguientes comandos con un
disquete vacío dentro de la disquetera:
<verb>
  [sromero@localhost]$ /sbin/mke2fs /dev/fd0
  [sromero@localhost]$ [ -d /fd ] || mkdir /fd
  [sromero@localhost]$ mount /dev/fd0 /fd
  [sromero@localhost]$ cp /boot/boot.b /fd
  [sromero@localhost]$ cp /vmlinuz /fd
  [sromero@localhost]$ echo image=/fd/vmlinuz label=linux | /sbin/lilo -C - -b /dev/fd0 -i /fd/boot.b -c -m /fd/map
  [sromero@localhost]$ umount /fd
  [sromero@localhost]$ rmdir /fd
</verb>
Lo que hacen estos comandos es:
<verb>
  /sbin/mke2fs /dev/fd0    -> Formatea el disquete con formato ext2
  [ -d /fd ] || mkdir /fd  -> Si no existe el directorio /fd lo crea
  mount /dev/fd0 /fd       -> monta el disquete en dicho directorio.
  cp /boot/boot.b /fd
  cp /vmlinuz /fd          -> Copia el kernel de Linux y el archivo
                              de boot al disquete. Si nuestro kernel no
                              se llama vmlinuz (por ej bzImage o zImage)
                              o no está en el raíz debemos cambiar esto.
  echo image=...           -> Activa el kernel en el disquete.
  umount /fd               -> Desmontamos el disco
  rmdir /fd                -> Borramos el dir /fd
</verb>
Si alguno de los paths o nombres cambia los deberemos cambiar dentro del diquete.


<!-- ***************************************************************** -->
<!-- SUBSECCIÓN  ¿COMO SE UTILIZAN LOS EMPAQUETADORES-DES/COMPRESORES? -->
<!-- ***************************************************************** -->

<sect1>¿Cómo se utilizan los empaquetadores-des/compresores?
<p>
Los ficheros tar no son ficheros comprimidos, sino empaquetados.
Tar es un empaquetador, es decir, es algo parecido a un compresor
como arj o zip, pero sin compresión. Se dedica a incluir todos los
ficheros juntos en el mismo archivo, preservando las estructuras
de directorios y permisos de los mismos. Como veremos, lo podremos
comprimir gracias al programa GZip.
<p>
Hay 2 operaciones básicas con tar: empaquetado y desempaquetado.
Si estamos en un directorio y queremos empaquetar todos los ficheros
de este directorio y los que cuelgan de él, basta con ejecutar
la orden:
<verb>
  tar -cvf fichero.tar *

  c = compress  (más bien, empaquetar)
  v = verbose   (para que nos diga lo que hace)
  f = file      (empaquetar en un fichero)
  *             (empaquetar todos los ficheros, podría haber sido *.doc, etc.)
</verb>
Si disponemos de un fichero .tar y queremos desempaquetarlo:
<verb>
  tar -xvf fichero.tar
               
  x = eXtract   (desempaquetar).
</verb>
También es posible listar los contenidos de un fichero .tar antes
de desempaquetarlo, mediante la orden <tt>tar -tvf fichero.tar</tt> .
<p>
 Por otra parte, el ficheros con extensión gz son ficheros
comprimidos.
A diferencia de arj o zip, el contenido de un fichero GZ es un solo
fichero, es decir, cuando comprimimos fichero.txt con este compresor
(llamado gzip) obtenemos un fichero.txt.gz de tamaño mucho menor. Con
GZ no es posible empaquetar ficheros, es decir, la compresión se
realiza a un sólo fichero.
<p>
Para comprimir un fichero con gz, se utiliza el comando:
<verb>
  gzip fichero
</verb>
Para descomprimirlo:
<verb>
  gunzip fichero.gz
</verb>
La combinación de tar y gz es lo que permite el tener multiples
ficheros comprimidos en un sólo archivo. Es decir, si empaquetamos
un directorio con tar y luego comprimimos ese archivo tar con gz,
obtenemos un tar.gz comprimido con múltiples ficheros.
<p>
La compresión y descompresión es posible hacerla en 2 pasos (primero
tar y luego usar gz) o bien usar el flag -z de tar para ello:
<p>
Compresión:
<verb>
  tar -cvzf fichero.tar.gz *
</verb>
Descompresion:
<verb>
  tar -xvzf fichero.tar.gz
</verb>
Otro formato que se ha puesto de moda es bzip2, con el mismo
sistema de funcionamiento que Gzip, y cuyos nombres de ejecutable
son <tt/bzip2/ (comprimir) y <tt/bunzip2/ (descomprimir). Este compresor
obtiene mejor compresión que Gzip y su funcionamiento es igual
de sencillo, aunque tarda mas en comprimir y utiliza mas recursos.
<p>
 Estos compresores/descompresores/empaquetadores son una gran
y libre alternativa a formatos comerciales como <tt/zip, arj/ y <tt/rar/,
también disponibles para Linux (comandos zip, unzip, rar y unarj).
<p>
 Para descomprimir ficheros arj mediante unarj, simplemente
hace falta ejecutar el comando <tt/unarj x fichero.arj/. El compresor
es shareware y se debe obtener en la Web de sus programadores.
<p>
 Zip es el programa destinado a hacer Linux capaz de leer y
escribir los ficheros en formato .zip (generados por <tt>pkzip o
winzip</tt>): Para ello tenemos los comandos zip e unzip, que nos
permitiran comprimir y descomprimir ficheros sueltos, directorios
completos, directorios con recursividad, etc:
<p>
Para comprimir todos los ficheros de un directorio en un zip:
<verb>
  zip fichero.zip *
</verb>
Para comprimir este directorio y todos los que cuelguen del mismo:
<verb>
  zip -r fichero.zip *
</verb>
La descompresión se realiza mediante unzip:
<verb>
  unzip fichero.zip
</verb>
El programa rar también es un buen compresor que podemos encontrar
en diferentes formatos (rpm, deb, tar.gz) en Internet. Su uso es
identico a la versión MSDOS:
<p>
Comprimir:     
<verb>
  rar a fichero.rar *
</verb>
Descomprimir:  
<verb>
  rar x fichero
</verb> 
Para más información sobre cualquiera de los des/compresores basta
con consultar la página man del mismo, mediante "man <em/comando/".


<!-- ****************************************************** -->
<!-- SUBSECCIÓN COMO SE INSTALAN Y DESINSTALAN PAQUETES RPM -->
<!-- ****************************************************** -->

<sect1>¿Cómo instalo, desinstalo o actualizo paquetes rpm?
<p>
Los paquetes rpm son archivos que llevan incluidos dentro de ellos
todos los ficheros que componen un determinado programa. Internamente
están comprimidos, pero nosotros sólo debemos pensar en ellos en
términos de Instalación, Actualización, Borrado y Consultas. Dentro
del rpm van los ficheros del programa a instalar, su descripcion,
a que directorios van a ir instalados, scripts de auto-configuración
en algunos casos, etc.
<p>
La sintaxis de rpm es <tt>rpm -acción nombre_del_paquete</tt>
<p>
Acciones:
<verb>
  rpm -i  archivo   (instalar)
  rpm -e  paquete   (desinstalar)
  rpm -u  paquete   (actualizar)
  rpm -qi paquete   (pedir info)
</verb>
Ejemplos:
<verb>
  rpm -i  Par-1.50-1.i386.rpm
  rpm -e  Par
  rpm -u  Par
  rpm -qi Par
</verb>
 Supongamos el fichero <tt>programa-1.0.rpm</tt> que no tenemos instalado
y que acabamos de bajar de Internet. Procedemos a su instalación:
<verb>
  rpm -i programa-1.0.rpm
</verb>
 Tras eso el programa estará instalado en nuestro Linux y podremos
ejecutarlo y usarlo normalmente. Tal vez nuestro problema es que
no sabemos como se llama el ejecutable y los demás ficheros de
configuración que le acompañan. Para solucionar eso hacemos una
consulta (query) del paquete ya instalado:
<verb>
  rpm -ql programa
</verb>
 La acción -ql significa "query list", y nos mostrará en pantalla
la lista de ficheros instalados de este programa y sus directorios
destinos. Si por ejemplo deseamos ver sólo los fichero sean instalados
en los directorios bin (los ejecutables) podemos hacer uso de grep,
la herramienta de Linux que sólo nos mostrará aquellas líneas que
contengan una cadena determinada:
<verb>
  rpm -ql programa | grep bin
</verb>
 Esto nos mostrará sólo los ficheros de "programa" que hayan sido
instalados en directorios bin.
<p>
 Si queremos saber que hace un paquete instalado, podemos verlo con
la opción "query info" (-qi):
<verb>
  rpm -qi programa
</verb>
Como ejemplo, veamos la salida para el paquete fetchmail de Linux:
<verb>
  Name        : fetchmail               Relocations: (not relocateable)
  Version     : 5.0.0                   Vendor: Red Hat Software
  Release     : 1
  Install date: dom 30 may 1999 16:00:12 CEST
  Group       : Applications/Internet
  Size        : 565413
  Packager    : Red Hat Software http://developer.redhat.com/bugzilla
  Summary     : A remote mail retrieval and forwarding utility.
  Description :
  Fetchmail is a remote mail retrieval and forwarding utility intended
  for use over on-demand TCP/IP links, like SLIP or PPP connections.
  Fetchmail supports every remote-mail protocol currently in use on the
  Internet (POP2, POP3, RPOP, APOP, KPOP, all IMAPs, ESMTP ETRN) for
  retrieval.  Then Fetchmail forwards the mail through SMTP, so you can
  read it through your normal mail client.
</verb>
Si el programa no nos gusta, la deinstalación es muy sencilla:
<verb>
  rpm -e programa
</verb>
Obviamente, no tenemos porqué instalar los programas para ver su
contenido o información. Los podremos ver antes de la instalación
insertando un comando p antes de la acción:
<verb>
  rpm -qpi fichero.rpm
  rpm -qpl fichero.rpm
</verb>
Si queremos ver la lista de RPMs instalados disponemos del
comando "query all" (-qa):
<verb>
  rpm -qa
</verb>
Para verlo en formato pausado, podemos usar una tubería:
<verb>
  rpm -qa | less
</verb>
 Es posible que tras un tiempo obtengamos la versión 2.0 del
programa que ya disponemos instalado. En esto caso hay 2
opciones: bien eliminar el programa anterior (-e) e instalar
este nuevo (-i), o, simplemente, actualizar el programa a la
versión 2.0 con el comando -U (de Update):
<verb>
  rpm -U programa-2.0.rpm
</verb>
Por último, si al tratar de instalar un paquete rpm aparece
el siguiente error:
<verb>
  Data type X not supprted
</verb>
Esto es debido a que nuestra versión de rpm es muy antigua,
al menos más que el rpm que estamos tratando de instalar, y
que este tiene algún tipo de compresión o elemento que nuestro
rpm no entiende. Bastará entonces con actualizar nuestro
ejecutable del RPM.
<p>
 Cabe decir que también existen front-ends al programa rpm, es
decir, programas en modo gráfico (o texto) que realizan las
acciones del programa RPM mediante pulsaciones nuestras del
ratón. Es el front-end el que se encarga de pasarle a RPM los
parámetros correctos para que se realice la acción pedida por
el usuario. Entre estos programas tenemos glint, gnorpm,
purp, kpackage, xrpm, etc.


<!-- *************************************** -->
<!-- SUBSECCIÓN COMO INSTALAR PAQUETES .DEB  -->
<!-- *************************************** -->

<sect1>¿Cómo instalo paquetes .deb de debian?
<p>
Al igual que el formato RPM, los .DEB encapsulan todos los ficheros
y scripts vinculados a un determinado programa pero para la
distribución Debian. Además de disponer de herramientas de instalación como
dselect, se incluye la posibilidad de instalación manual mediante las
diferentes opciones del programa <tt/dpkg/:
<p>
Instalación de paquetes deb:   
<verb>
  dpkg -i nombre_del_paquete.deb
</verb>
Para hacer consultas:
<verb>
  dpkg -s nombre_del_paquete (admite comodines)
</verb>
Para desinstalar:  
<verb>   
  dpkg -r nombre_del_paquete
</verb>
El resto de opciones de dpkg puede verse con <tt/man dpkg/.


<!-- ********************************************************** -->
<!-- SUBSECCIÓN COMO CONVERTIR PAQUETES ENTRE RPM, DEB y TAR.GZ -->
<!-- ********************************************************** -->

<sect1>¿Cómo se convierten paquetes entre RPM, DEB y TGZ con alien?
<p> 
Alien es un programa que permite convertir un paquete
binario entre los formatos rpm (Redhat, Suse), deb (Debian)
y tgz (Slackware):
<p>
Conversion a .DEB:
<verb> 
  alien --to-deb paquete.elquesea
</verb>
Conversion a .RPM:
<verb> 
  alien --to-rpm paquete.elquesea
</verb>
Conversion a .TGZ:
<verb> 
  alien --to-tgz paquete.elquesea
</verb>
 Existen otros flags (como -i) que permiten directamente tras la
conversión realizar la instalación del paquete generado. Alien
realiza la conversión descomprimiendo el paquete original y
generando el nuevo paquete, diciéndonos el lugar del árbol de
directorios donde dejará el paquete recién generado, según la
distribución (por ejemplo, en Redhat en <tt>/usr/src/redhat/RPMS/</tt>).


<!-- ***************************************** -->
<!-- SUBSECCIÓN COMO INSTALO UN NUEVO PROGRAMA -->
<!-- ***************************************** -->

<sect1>¿Cómo instalo un nuevo programa?
<p>
En esta sección consideraremos las posibilidad de instalar un nuevo programa 
en nuestro sistema linux.
 
<bf>La oferta de programas en linux y los formatos de paquete</bf>
<p>
En la red podemos encontrar una enorme cantidad de software para linux 
el cual podemos encontrarlo como archivos en código fuente, que han de compilarse 
antes de su instalación, o en formato binario, listos para ser instalados.
En formato binario encontraremos los paquetes que instalan las diversas 
distribuciones linux y -evidentemente- el software comercial: no iban a desvelar su 
código fuente ;-))!.
<p>
La idea fundamental que justifica la necesidad de paquetes de software 
para linux estriba en que:
<p>
<itemize>
<item>Se comprueban las dependencias de funcionamiento del paquete y éste no
 se instala si no están instalados los necesarios para que la aplicación funcione.

<item>La instalación y desinstalación es automática y no deja "basura" en 
el sistema al desinstalar paquetes.

<item>Actualización automática de paquetes.
  
<item>Control de los archivos de configuración.
 </itemize>

<p>
Existen varios sistemas o formatos de paquetes, que fueron establecidos 
por ciertas distribuciones de linux y que merecen discutirse separadamente: 
el sistema de paquetes Debian, RedHat y Slackware
<p>

<bf>El sistema de paquetes Debian</bf>
<p>
Este sistema fue el primero en aparecer, exclusivo de Debian y muy potente: 
su sistema de dependencias es el más completo y flexible que existe. Lo usa 
la propia Debian y Corel Linux. Los paquetes debian tienen la extensión 
<em>.deb</em> y la herramienta de gestión de dichos paketes es <em>dpkg</em>. 
Una descripción mínima de las posibilidades de dpkg se indica a continuación
<p>
<bf><tt>Instalación</tt></bf>
<p>
<tt>-i|--install</tt>

<verb>
   dpkg -i &lt; nombre del paquete.deb &gt; ; por ejemplo:

   dpkg -i icewm_0.8.12-1.deb
</verb>

Si deseamos instalar toda una seie de paquetes que se encuentran en un 
directorio determinado, por ejemplo, <tt>/usr/local/Debian/archive, </tt>
es posible hacerlo de manera recurrente con la opción -R:

<verb>
    dpkg -i -R /usr/local/Debian/archive
</verb>

sin embargo, esta opción puede no ir bien a causa de posibles dependencias 
entre paquetes ya que dpkg los va instalando conforme los encuentra, y ese 
quizás no sea el orden requerido para las dependencias. Mejor es entonces 
hacer la instalación en dos etapas con las opciones --unpack y --configure:

<verb>
   dpkg --unpack /usr/local/Debian/archive
</verb>

desempaqueta todos los ficheros .deb del directorio. Si solamente queremos 
configurar algunos de ellos, haremos entonces

<verb>
   dpkg --configure &lt; nombre del paquete &gt;
</verb>

pero si queremos instalar todos los paquetes desempaquetados del directorio haremos:

<verb>
   dpkg --pending

o de manera más corta,

   dpkg -a
</verb>

<p>
<bf><tt>Actualización</tt></bf>
<p>
Para actualizar se usa la misma opción -i que en la instalación. Si por 
ejemplo tenemos instalado el paquete icewm_0.8.11-1.deb y hacemos

<verb>
   dpkg -i icewm_0.8.12-1.deb
</verb>

en lugar de instalarse separadamente actualiza el sistema a esta última versión.

<p>
<bf><tt>Desinstalación</tt></bf>
<p>
<tt>-r|--remove</tt>

<p>
Esta opción borra un paquete determinado, pero no borra los ficheros de 
configuración. Esto puede interesarnos cuando pensemos reinstalar el paquete 
en el futuro, pues ya dispondríamos de los ficheros de configuración. 
Así si queremos eliminar el paquete icewm_0.8.12-1.deb que tenemos instalado dejando 
sus ficheros de configuración haremos

<verb>
   dpkg -r icewm
</verb>

<bf>NOTA</bf>: nótese que sólamente hay que escribir el cabecero del paquete, no su versión
 ni su extensión.

<p>
<tt>--purge</tt>
 <p>
En este caso el paquete se borra junto con todos sus ficheros de configuración 
asociados. El paquete queda completamente erradicado del sistema:

<verb>
   dpkg --purge icewm
</verb>

<p>
<bf><tt>Consultas</tt></bf>
<p>
 
<itemize>
  
<item><tt>dpkg -l</tt>: da un listado de todos los paquetes instalados en el sistema, 
con la versión y una breve descripción
  
<item><tt>dpkg -I</tt> &lt; nombre del paquete.deb &gt; : proporciona información sobre 
el paquete
  
<item><tt>dpkg --print avail</tt> &lt; nombre del paquete &gt; : proporciona información 
sobre el paquete
  
<item>
dpkg -L &lt;nombre del paquete&gt; : da una lista de los distintos ficheros 
que se crearon en la instalación del paquete
  
<item>
dpkg -S &lt; fichero &gt;: proporciona el nombre del paquete al que pertenece 
el fichero (dar la ruta completa: /usr/bin/wget)
 
</itemize>
<p>
Existe una utilidad que funciona como interfaz de usuario para la gestión 
de paquetes debian llamada <em>dselect</em>, que nos sirve cuando hay que 
navegar entre la multitud de paquetes de un CD debian o en los directorios remotos mediante 
ftp. Pero aunque se trata de una herramienta poderosa en manos del usuario 
medio y avanzado, es muy temida por el neófito habida cuenta de su poco intuitivo 
manejo. Para evitar esta reacción del usuario novel, los desarrolladores de
Debian han creado la utilidad <em>apt</em>, que en la nueva liberación 
Debian 2.2 debería encontrarse plenamente activa junto con un propio <em>front-end</em>. 
Mientras tanto los novicios har=EDan bien en consultar el manual de dselect para novatos 
<url url="http://www.debian.org/releases/stable/i386/dselect-beginner.html" name="http://www.debian.org/releases/stable/i386/dselect-beginner.html">.

<p>
<bf>El sistema de paquetes RedHat</bf>
<p>
El formato de paquetes diseñado por RedHat, lo usan además todas las 
distribuciones basadas en él como Caldera Openlinux, Mandrake, Esware, Hispafuentes y 
también SuSE, aunque esta última no se trata de una "emanación" de RedHat. La extensión
 de los paquetes es .rpm y la herramienta de gestión de paquetes se llama también
 rpm, cuyas posibilidades se muestran a continuación:

<p>
<bf><tt>Instalación</tt></bf>
 <p>
<tt>-i</tt>
<verb>
   rpm -i nombre_del_paquete.rpm; por ejemplo:
   dpkg -i wget-1.4.5-2.rpm
</verb>

Sin embargo, el paquete solamente se instalará si se han satisfecho las 
posibles dependencias con otros paquetes. Es posible forzar la instalación 
rechazada a causa de dependencia con otros paquetes usando la opción -nodeps, 
pero no es aconsejable.

<p>
<bf><tt>Actualización</tt></bf>
<p>
<tt>-U</tt>

<verb>
   rpm -i nombre_del_paquete_actualizado.rpm
   rpm -U wget-1.5.3-1.rpm
</verb>

de este modo se desinstala el paquete obsoleto wget-1.4.5-2 y se instala 
la nueva versión wget-1.5.3-1. Si el programa rpm encuentra un fichero 
de configuración que no ha sido cambiado por el administrador hasta el 
momento de la actualización, sobreescribe el nuevo fichero de configuración 
en él, pero si encuentra el fichero de configuración modificado por 
el administrador, entonces salva el fichero de configuración antiguo 
con la extensión <em>.rpmorig</em> y lo reemplaza por el nuevo.

<p>
<bf><tt>Desinstalación</tt></bf>
 <p>
<tt>-e</tt>

<verb>
   rpm -e nombre_del_paquete
   rpm -e wget
</verb>

<bf>NOTA</bf>: Nótese que sólamente hay que escribir el cabecero del paquete, no su versión 
ni su extensión.

<p>
<bf><tt>Consultas</tt></bf>
 <p>
Para realizar una consulta disponemos de la orden

<verb>
   rpm -q &lsqb;parámetros&rsqb; &lsqb;opciones&rsqb; &lsqb;nombre del paquete&rsqb;
</verb>

<itemize>
  
<item><tt>rpm -q -a </tt>: lista todos los paquetes instalados
  
<item><tt>rpm -q &lt; nombre del paquete &gt;</tt> : informa del nombre, versión y número 
de desarrollo del paquete
  
<item><tt>rpm -q -i &lt; nombre del paquete &gt;</tt> : proporciona información verbosa 
acerca del paquete instalado.
  
<item><tt>rpm -q -l &lt; nombre del paquete &gt;</tt> : muestra la lista de archivos 
correspondiente al paquete

<item><tt>rpm -q -f &lt;fichero&gt;</tt> : muestra el paquete al que corresponde el fichero
 (especificar la ruta completa: <tt>/usr/bin/wget</tt>)

</itemize>
<p>
Antaño (hasta la versión de RedHat 5.2), había una herramienta estupenda 
para la gestión de paquetes rpm mediante interfaz gráfica de usuario: se llamaba 
<em>glint</em>, y fue muy aplaudido por los neófitos y administradores por su facilidad 
para manipular los paquetes. Hoy día ya no disponemos de él, pero si se utilizan 
Escritorios como KDE o GNOME, podemos usar sus utilidades <em>kpackage</em> o <em>gnorpm</em>, 
respectivamente.

<p>
<bf>El sistema de paquetes de Slackware</bf>
<p>
En cuanto al "sistema de paquetes .tgz" de Slackware, hay cierta distancia 
con respecto a los ya vistos y es que no hace comprobación de dependencias, 
labor que corresponde al usuario o administrador. El sistema de paquetes sirve 
fundamentalmente para instalar o desinstalar de manera rápida los paquetes. 
La ventaja de esta estrategia es que los usuarios de Slackware pueden instalar 
los paquetes inmediatamente sin esperar a que pasen el filtro de las dependencias.
Por ello, Slackware es una distribución orientada a usuarios algo avanzado, 
con una idea diáfana de lo que necesitan. El sistema de paquetes de Slackware 
utiliza ficheros tar comprimidos, tar.gz o tgz, existiendo un programa interactivo 
para gestionarlos llamado <tt>pkgtool</tt>. Pero también dispone de utilidades en línea 
de comando para manejar los paquetes.

<p>
<bf><tt>installpkg</tt></bf>
 <p>
Escribiendo

<verb>
   installpkg &lsqb; opciones &rsqb; archivo.tgz
</verb>
instalamos el paquete en Slackware. Las opciones son:

<p>
<itemize>
  
<item><tt>-warn</tt>: Proporciona un informe de lo que ocurriría si instalamos el paquete 
que envía a la salida estándar.
  
<item><tt>-m</tt>: Empaqueta el contenido del directorio de trabajo y sus subdirectorios 
en el archivo.
 
</itemize>

<p>
<bf><tt>removepkg</tt></bf>
 <p>
Escribiendo

<verb>
   removepkg &lsqb; opciones &rsqb; archivo.tgz
</verb>
desinstalamos el paquete del sistema completamente, eliminando además los 
scripts, librerías, ficheros y directorios anejos. Las opciones son:
<p>
<itemize>
  
<item><tt>-warn</tt>: Proporciona un informe de lo que ocurrir=EDa si desinstalamos 
el paquete y lo envía a la salida estándar.
  
<item><tt>-preserve</tt>: Reconstruye el árbol de directorios del paquete en 
<tt>/temp/preserved_packages/packagename</tt> (packagename es el nombre del paquete, 
en nuestro caso genérico, "archivo").
  
<item><tt>-copy</tt>: Es equivalente a -warn -preserve; es decir no lo desinstala pero 
informa y guarda el árbol de directorios.
  
<item><tt>-keep</tt>: Salva los ficheros temporales creados por removepkg. Útil 
para <em>debugging</em>.
 
</itemize>

<p>
<bf><tt>upgradepkg</tt></bf>
<p>
Esta utilidad permite actualizar un paquete instalado con otro especificado. 
Si tienen el mismo nombre, basta con hacer:
<p>
<tt>upgradepkg packagename</tt>, pero si el nombre es distinto hay que escribir: 
<tt>upgradepkg oldpackagename &percnt; newpackagename</tt>.


<bf>Otros gestores y conversión de paquetes</bf>

Las opciones: Midnight Commander y FileRunner
<p>
Existen dos herramientas que pueden ayudarnos a instalar paquetes .rpm, .deb o.tgz, 
mediante el uso del llamado sistema virtual de ficheros. Se trata 
del Midnight Commander (MC) y de FileRunner (FR). Estas herramientas permiten 
acceder al contenido de los paquetes como si fueran directorios, explorando 
su interior, y vislumbrando los archivos presentes. El conocido MC, se encuentra 
ya integrado en GNOME y puede descargarse desde 
<url url="http://www.gnome.dk/mc/index.html" name="http://www.gnome.dk/mc/index.html">. 
El FR es otra fantástica utilidad desarrollada en tcl/tk que puede conseguirse en 
<url url="http://www.cd.chalmers.se/~hch/filerunner.html" name="http://www.cd.chalmers.se/~hch/filerunner.html">.

<p>
<bf>El octavo pasajero</bf>
<p>
Sí, a veces, dada la inexistencia de un sistema estándar de paquetes hay 
utilidades que los desarrolladores de un sistema han producido y preparado 
y que no encontramos en una determinada distribución. Así, puede haber un archivo
 .rpm que no existe como .deb o .tgz. En estos casos existe una herramienta 
inestimable que permite convertir unos paquetes en otros: <em>Alien</em>.
 
<p>
<em>Alien</em>, creado por <url url="mailto:giovanni@linux.nauta.it" name="Giovanni Quadriglio"> 
no debería utilizarse intentando reemplazar paquetes importantes del sistema, 
como las bibliotecas compartidas, el sistema de inicio (sistemv o BSD), etc, 
que son esenciales para el funcionamiento del mismo.
Por otra parte, no se elabora del mismo modo un paquete para Debian que para 
RedHat. Más aún! Puede haber diferencias en los paquetes .rpm dependiendo 
que sean de Caldera, SuSE o RedHat; así que Tened cuidado ahí fuera! ;-).
<p>
Alien puede descargarse de <url url="http://kitenet.net/programs/alien" name="http://kitenet.net/programs/alien">, 
en cualquiera de los formatos conocidos. Para usar alien se necesitan 
otras utilidades. La primera, ya que alien está escrito en <em>perl</em>, 
será disponer de perl instalado. Para la versión actual de alien (6.99) 
nos bastará perl 5.004. Para convertir paquetes a rpm o desde rpm, necesitaremos 
tener instalado el RedHat Package Manager; para el caso de deb, necesitamos 
dpkg, dpkg-deb, debmake, gcc y make. Todos estos archivos "extra" que nos harán 
falta para las múltiples posibilidades de alien pueden descargarse de 
<url url="ftp://ykbsb2.yk.psu.edu/pub/alien/" name="ftp//ykbsb2.yk.psu.edu.pub/alien/"> como 
un paquete llamado "alien-extra", en cualquier formato de paquete. Las fundamentales 
acciones conversoras de alien podemos extraerlas del man:

<verb>
   alien &lsqb; opciones &rsqb; paquete a convertir
</verb>
Las opciones son <tt>-d</tt> para transformar cualquier formato a .deb (por defecto), 
<tt>-r</tt> para convertir a .rpm y <tt>-t</tt> para pasar a .tgz (también es posible pasar a 
.slp de Stampede con <tt>--to-slp</tt>).

<p>
<bf>Instalando a las bravas</bf>
<p>
A menudo, especialmente en el caso de la programación libre de código abierto 
(free software, source code), se dispone del código original (fuente), que 
generalmente se suministra en forma de un archivo "empaquetado" que contiene 
"pegados" todos los ficheros y directorios que nos harán falta y que muy a menudo 
se encuentra además comprimido, para reducir el tamaño del mismo. Para empaquetar 
ficheros y directorios en un único archivo se usa el programa <em>tar</em> (produciendo 
un archivo .tar) y para comprimirlo se usan las utilidades <em>compress, gzip o bzip2</em> 
(dando lugar a los archivos .z o .Z, .gz y .bz2, respectivamente). 
De este modo, podemos encontrar nuestros archivos fuente como .tar únicamente 
en el caso de programas no muy grandes, pues si no hay que comprimirlos para 
que la gente los descargue con mayor facilidad o quepan más archivos en un 
medio de almacenamiento como un CDrom. Por eso es más frecuente encontralos 
con el formato .tar.Z, .tar.gz (también escritos como .tgz y conocidos familiarmente 
como "tarballs") o .tar.bz2. Una vez que hemos descargado alguno de estos archivos 
o lo hemos copiado a nuestro disco duro desde un CDrom ó un floppy, habremos 
de descomprimirlos/desempaquetarlos en un directorio para proceder a su instalación.
<p>
En los siguientes epígrafes vamos a considerar los pasos que hay que dar para 
instalar felizmente la aplicación escogida.

<p>
<bf><tt>Ubicación de los archivos fuente</tt></bf>
<p>
Normalmente el código fuente de los programas se sitúan en <tt>/usr/local/src</tt>. 
Para que cualquier usuario ubique ahí sus propios directorios el administrador 
debe otorgar los siguientes permisos (como al <tt>/tmp</tt>):

<verb>
   chmod 1777 /usr/local/src
</verb>

De este modo todos los usuarios pueden poner archivos ahí, pero solamente 
los propietarios pueden borrar sus ficheros. No obstante, en otros casos, 
únicamente es el administrador el que se encarga de la selección e instalación 
del software y entonces los permisos deben ser 755 propietario root y grupo root.

<p>
<bf><tt>Descompresión y desempaquetado simultáneo con tar</tt></bf>
<p>
La utilidad tar nos permite descomprimir (caso que sea necesario) y desempaquetar 
los archivos. Dependiendo del formato del archivo se utilizará una u otra opción. 
Recomiendo que hagais man tar para ver el variado plumaje de sus opciones.
Las más usuales son:

<p>
<itemize>
<item><tt>z</tt> para descomprimir un archivo comprimido .Z, .z o .gz
  
<item><tt>y</tt> para descomprimir un archivo comprimido .bz2
  
<item><tt>x</tt> para extraer el contenido del archivo (sus ficheros y 
directorios empaquetados)
  
<item><tt>v</tt> (verbose) para ver lo que está sucediendo en la pantalla
  
<item><tt>f</tt> (en útimo lugar y seguido del nombre del archivo fuente) para dirigir 
la salida de tar a ese archivo
  
<item><tt>t</tt> lista el contenido del archivo

</itemize>
<p>
De este modo podemos efectuar las siguientes acciones:

<verb>
   tar xvf archivo.tar

   tar zxvf archivo.tar.Z
   
   tar zxvf archivo.tar.gz (ó tgz)
 
   tar yxvf archivo.tar.bz2
</verb>

No obstante, antes de proceder a la descompresión/desempaquetado del archivo 
fuente es de recibo hacer un tar tzf al archivo fuente para ver si los ficheros 
se expanden dentro de un subdirectorio o directamente en <tt>/usr/local/src</tt>. 
En este último caso (algo raro), se debe crear un subdirectorio en <tt>/usr/local/src</tt> 
copiar el fichero tar a este subdirectorio y proceder a desempaquetarlo.
<p>
<bf>NOTA</bf>: Este último caso no es muy común, pero se dan algunos casos en los que
el creador del fichero tar, queriendo o sin querer, comete el fallo de no empaquetar los
ficheros dentro de su propio directorio. Esto a sido causa de que a más de uno de nosotros 
se nos haya llenado p.ej. el directorio <tt>/usr/local/src</tt> de un monton de "basura" 
y que hayamos pasado un "ratito" limpiando dicho directorio.

<p>
<bf><tt>Instalación</tt></bf>
<p>
Una vez que hemos descomprimido y desempaquetado ficheros y directorios, 
debemos buscar y leer cuidadosamente los archivos README e INSTALL, donde se 
nos indicará paso a paso como habrá de hacerse la instalación. En muchos casos 
se nos advierte de que hay que modificar el Makefile o escoger algunos directorios 
determinados para la ruta de bibliotecas ó de ciertos ejecutables o hacer algún 
enlace simbólico o copiar algún archivo en un directorio dado. De cualquier 
forma, lo más común es ejecutar lo siguiente.

<p>
<descrip>
<tag>./configure</tag>: Este programa analiza la configuración del sistema
 y genera un archivo <em>Makefile</em>. Dicho archivo indica los pasos que el programa 
<tt>make</tt> ha de seguir para compilar la aplicación. En algunos casos no hay archivo
 configure y hemos de editar nosotros el Makefile o el config.h para establecer 
las opciones que nos interesen. No está de más echar un vistazo de todas maneras. 
Una vez realizado este primer paso debemos ejecutar
  
<tag>make</tag>: Este programa invoca al compilador siguiendo las instrucciones 
del fichero Makefile. Algunas veces habrá que hacer <tt>make all</tt> o <tt>make nombre_del_programa</tt>, 
como indique el archivo README o INSTALL. Mientras se compila, aparecen en 
la pantalla mensajes indicadores de las tareas que se están realizando. Pueden 
aparecer muchos <em>warnings</em>, pero pueden ignorarse, ya que no darán problemas. 
La compilación habrá terminado con éxito si no se detiene con algún mensaje 
de Error. De este modo se habrá creado el fichero ejecutable. Para instalarlo 
convenientemente ejecutaremos el comando su para transformarnos en superusuario 
y entonces escribiremos
  
<tag>make install</tag> : Generalmente el ejecutable se copia a <tt>/usr/local/bin</tt>, 
las bibliotecas en <tt>/usr/local/lib</tt> y la página de manual en <tt>/usr/local/man</tt>. 
Si queremos que se copien en otro directorio hay que cambiar la línea correspondientes 
en el Makefile o hacer <tt>./configure --prefix=/directorio_de_instalación</tt>. En 
otros casos, no hay que hacer <tt>make install</tt> y copiamos a mano los archivos a 
los correspondientes directorios o hacemos un enlace simbólico a los mismos. 
Existen otras opciones que pueden realizarse después como <tt>make clean</tt>, etc, 
que vendrán indicadas en el fichero README o INSTALL.

</descrip>
<p>
<bf>NOTA</bf>: Este proceso que puede parecer muy complicado al principio, no lo es
tanto cuando lo hayas hecho unas cuantas veces. Lo importante es leerse detenidamente los
ficheros README o INSTALL que vengan con el programa.


<!-- *************************************** -->
<!-- SUBSECCIÓN COMO SE CAMBIAN LOS PERMISOS -->
<!-- *************************************** -->

<sect1>¿Cómo se cambian los permisos de ficheros y directorios?<label id="permisos">
<p>
Lo primero que hay que decir es que para conseguir toda la información 
sobre los comandos involucrados en el tema de permisos podeis consultar
<tt> man chmod, man chown</tt> y <tt>man chgrp</tt> 
<p>
<bf>Información de un fichero/directorio</bf>
<p>
Cuando obtienes información sobre un fichero/directorio, existen 
diferentes campos que te dicen que clase de permisos el fichero/directorio tiene.
<verb>
  Ej:

  [user@localhost]# ls -l
  -rwxr-x---   1 pepito depart1     4348 Nov 24 16:19 test
</verb>
En la <em>primera columna</em> se pueden ver una serie de letras 
<tt>-rwxr-x---</tt>, estas letras nos dicen quien en el sistema, 
y que clases de permisos tiene el fichero <tt>test</tt>.
<p>
Estas letras están agrupadas en tres grupos con tres posiciones cada uno, 
más una primera posición que nos dice de que clase de archivo se
trata (los mas normales (d) directorios, o (-) archivos de datos). 
En nuestro ejemplo la primera posición es (-) con lo cual el archivo test, 
es un archivo de datos (binario/ejecutable en este ejemplo).
<p>
El primer grupo de tres (rwx en nuestro caso) nos dice que clase 
de permisos tiene el dueño del fichero (u)(user/owner)).   &nl  
El segundo grupo de tres (r-x en nuestro caso) nos dice que 
clase de permisos tiene el grupo del fichero (g)(group).   &nl  
Y el último grupo de tres (--- en nuestro caso) nos dice que clase 
de permisos tienen todos los demás usuarios del sistema sobre 
este fichero(o)(others).  &nl 
 
<verb>
  r :significa permiso para leer 
  w :significa permiso para escribir  
  x :significa permiso para ejecutar  
</verb>

La <em>segunda columna</em> <tt>pepito</tt>, nos dice quien es el 
dueño del fichero,(pepito en este caso).  &nl  
La <em>tercera columna</em> <tt>depart1</tt>, nos dice cual es el 
grupo del fichero (depart1 en este caso).  &nl 
La <em>cuarta columna</em> <tt>4348</tt>, nos dice el tamaño del fichero.  &nl  
La <em>quinta columna</em> <tt>Nov 24 16:19</tt>, nos dice cual es 
la fecha y hora de la última modificación.  &nl 
La <em>sexta columna</em> <tt>test</tt>, nos dice cual es el nombre del fichero/directorio.  &nl  
<p>
Asi pues, el fichero <tt>test</tt> de nuestro ejemplo tiene los siguientes permisos:
<itemize>
<item><em>pepito</em> puede leer, escribir/modificar, y ejecutar el fichero test.   &nl   
<item><em>depart1</em> puede leer, y ejecutar pero no escribir/modificar.   &nl   
<item>Los <em>demás usuarios</em> no pueden hacer nada, ni leerlo, ni escribir/modificar, ni ejecutarlo.   &nl   
</itemize>

<bf>Como cambiar los permisos/dueño/grupo de un fichero/directorio?</bf>:
<p>
Para cambiar el dueño del fichero: <tt>chown <em>usuario</em> <em>fichero</em> </tt>   &nl   
Para cambiar el grupo del fichero: <tt>chgrp <em>grupo</em> <em>fichero</em></tt>   &nl   
Para cambiar los permisos se utiliza el comando: <tt>chmod <em>permisos</em> <em>fichero</em></tt>   &nl   
<p>
Los permisos se pueden especificar de diferentes maneras, una serie de ejemplos, es lo mejor para comprenderlo:
<verb>
  chmod ugo+rwx test (da permisos rwx a todos, user,group,others)
  chmod ugo-x test (quita permiso x (ejecucion) a todos, user,group,others) 
  chmod o-rwx test (quita permisos rwx a others) 
  chmod u=rwx,g=rx test (da permisos rwx a user, rx a group y ninguno a others) 
</verb>
Asi podriamos continuar con todas las posibles combinaciones de 
letras, es cuestión de usar la imaginación ;-)
<p>
Existe otro metodo que utiliza numeros, en vez de letras para asignar 
permisos, la siguiente tabla nos puede ayudar un poco a comprender esta manera:
<p>
<verb>
  r w x  VALOR DECIMAL

  0 0 0  0 (000 binario es 0 en decimal)
  0 0 1  1  .........
  0 1 0  2  .........
  0 1 1  3  .........
  1 0 0  4 (100 binario es 4 en decimal)
  1 0 1  5  .........
  1 1 0  6  .........
  1 1 1  7 (111 binario es 7 en decimal)
</verb>
<p>
1 significa activado y 0 desactivado, o sea 101 activa <tt>r</tt> y <tt>x</tt>, y desactiva <tt>w</tt>.
<p>
Sabiendo esto solo tenemos que usar el valor decimal, un ejemplo aclarara esto.
<verb>
  chmod 750 test 

  da permisos rwx al usuario (7=111)  
  da permisos r-x al grupo (5=101)  
  da permisos --- a los demas (0=000)  
</verb>


<!-- ******************************************* -->
<!-- SUBSECCIÓN COMO APAGO MI EQUIPO             -->
<!-- ******************************************* -->

<sect1>¿Cómo apago mi equipo?
<p>
Para apagar el equipo tienes que hacerte superusuario y hacer:
<verb>
  [asimovI@localdomain root]#  shutdown -t3 -h now 
</verb>

Esto pararía todos los procesos en curso, haría <tt/sync/, entraría en 
el runlevel 0, y desmontaría todas las particiones. El proceso de parada 
llegaría cuando se observa <tt/system halted/, y si la fuente lo permite 
y se compiló el kernel con esa opción, el ordenador se apaga automaticamente 
sin necesidad de pulsar el botón de apagado.

La opción h viene de <tt/halt/ (parar), y hace que se mantenga parado después 
de todo el proceso de apagado. La opción <tt/now/ indica que lo haga ahora, 
esta opción se puede sustituir por un número que define los minutos a esperar 
antes de realizar el <tt/shutdown/.
<p>
Para reiniciar  el equipo tienes que hacerte superusuario y hacer:
<verb>
  [asimovI@localdomain root]#  shutdown -t3 -r now  
</verb>
Pues como habías imaginado hace lo mismo que la anterior pero en vez 
de ponerse en <tt/system halted/ se pone en <tt/system reboot/ y reinicia. 
<p>
Existe otro método que consiste el accionar tres teclas, sí, esas que 
tanto hay que usar en otros sistemas operativos, las CAS (Ctrl+Alt+Supr), en una de
las consolas de texto del sistema.
Estas tres letras se configuran en el proceso de arranque de Linux, cuando 
se lee <tt>/etc/inittab</tt> existe una entrada que asocia 
estas tres teclas al comando <tt>shutdown</tt>
<verb>
  # Trap CTRL-ALT-DELETE
  ca::ctrlaltdel:/sbin/shutdown -t3 -r now
</verb>
Un consejo:
<p>
En los métodos anteriores es necesario ser superusuario ya que el comando 
<tt/shutdown/ lo requiere. Cosa lógica ya que sino cualquier usuario de la máquina la 
podría echar abajo. Esto hace bastante incómodo el apagarlo, por lo que un consejo 
práctico es editar <tt>/etc/inittab</tt> y cambiar la <tt/-r/ por la <tt/-h/ del comando 
que se une a las CAS, esto asociará el apagar el sistema a las tres teclas y no al 
reiniciarlo. Con esto ya no es necesario hacerse superusuario, sino estar sentado 
delante del ordenador a apagar.
<p>
Nota: En los kerneles 2.2.x hay que modificar una línea en el <tt>/etc/rc.d/*halt</tt>. En dónde llame al halt, hay que añadirle la opción -p. Si no lo que hace es reboot.

<!-- ***************************** -->
<!-- ***************************** -->
<!-- SECCIÓN INTERNET/REDES/MODEMS -->
<!-- ***************************** -->
<!-- ***************************** -->

<sect>USB

<!-- ********************************************** -->
<!-- SUBSECCIÓN USB-MOUSE-TECLADO                   -->
<!-- ********************************************** -->

<sect1>USB ratón-teclado
<p>
Esta sección está fuertemente basada en el capítulo 2 del documento 
<bf><url url="http://www.linux-usb.org/FAQ.html" name="The Linux USB sub-system"> 
</bf>y me centro en el ratón y teclado, supongo que el resto de componentes no debiera 
tener ningún problema añadido (exceptuando dispositivos de puerto pararelo).

<p>
Se supone que se trabaja con el kernel 2.2.16 (es en el que probó el autor, 
aunque debiera de funcionar con el 2.2.14).

<p>
<bf>¿Cómo puedo saber si mi adaptador USB es OHCI o UHCI ?</bf>
<p>
Si tu placa madre usa chipsets Intel, PIIX4, VIA,... el adaptador USB es 
UHCI, y si usa Compaq, iMacs, OPTi, Sis,Ali,... el adaptador USB es OHCI. En 
caso de no conocer que chipsets tiene tu ordenador hay dos opciones: lo abres 
y/o (lo más cómodo) y suponiendo que tengas un kernel compilado con la entrada 
<tt>/proc/pci</tt> activada, puedes hacer un <tt>cat /proc/pci</tt>, si la entrada 
USB es de la forma 0xHHHH (16 bits) es UHCI, si es 0xHH000000 (32 bits) entonces es OHCI.

<p>
<bf>No me aparecen las opciones de compilación de USB en el kernel 2.2.16</bf>
<p>
Los drivers de USB están en contínuo desarrollo y se arreglan muchos bugs 
de una versión a otra, al igual que se añaden muchas características nuevas. 
Actualmente, el desarrollo de USB se centra para la serie de kerneles 2.4 y 
los que vienen de serie con el 2.2.x están muy anticuados. Para ello hay un 
backport de los drivers USB de la seria 2.4 al 2.2.16. Estos funcionarán con 
los dispositivos soportados a excepción de los que usen el puerto paralelo, 
por necesitar éstos del driver partport que sufrió muchas modificaciones.

<p>
Entonces lo que tendremos que hacer es descargar el parche de 
<bf><url url="http://www.suse.cz/development/usb-backport/usb-2.4.0-test2-pre2-for-2.2.16-v3.diff.gz" name="http://www.suse.cz/development/usb-backport/usb-2.4.0-test2-pre2-for-2.2.16-v3.diff.gz"></bf>
y aplicarlo al árbol de fuentes del kernel 2.2.16 mediante los comandos:

<verb>
   [22:55:17 asimov@asimovi download]$ cd /usr/src/linux-2.2.16/
   [22:55:17 asimov@asimovi download]$ gzip -dc /tmp/usb-2.4.0-test2-pre2-for-2.2.16-v3.diff.gz|patch -p1
</verb>

Ahora ya podremos hacer un <tt>make xconfig</tt> o un <tt>make menuconfig</tt>, 
el make config se lo dejo a los arriesgados o a los que no tienen más remedio 
(aunque si se tiene usb, se tiene máquina suficiente ;-).

<p>
<bf>¿Qué opciones marco?</bf>
<p>
La primera opción a seleccionar es la de <tt>Support USB</tt> (recomiento la opción 
como módulo), y la opción <tt>Preliminary USB device filesystem</tt> para la opción de 
/proc/usb, a continuación si se sabe ya si es OHCI o UHCI pues seleciona <tt>UHCI 
(Intel PIIX4, VIA, ...)</tt> ó <tt>ohci-hcd (Compaq, iMacs,OPTi, SiS, ALi,...)</tt> aunque 
si se va a utilizar el script de este howto, mejor seleccionar los dos (siempre como módulo).

<p>
Necesitarás marcar qué dispositivos quieres usar: 
<p>
<itemize>
<item>
<tt>Human Interface Device (HID) support</tt> : (es en la que nos centramos en este 
howto) útil para teclado, ratón, joystick USB.

<item>
<tt>Mouse support </tt>: Selecciona esta opción en caso de tener un ratón USB, no 
selecciones <tt>USB HIDBP Mouse support.</tt>
  
<item>
<tt>Keryborard support: </tt>Selecciona esta opción en caso de tener un teclado 
USB, no selecciones <tt>USB HIDBP Keyboard support.</tt>
  
<item>
<tt>USB Scanner support </tt>:

<item>
....
</itemize>

<p>
<bf>¿Dónde está el dispositivo del ratón, y cómo le digo a las X donde está?</bf>
<p>
El dispositivo de un PS/2 es el <tt>/dev/psaux</tt>, el de uno serie es el 
<tt>/dev/ttySx</tt>, en realidad da igual el nombre, lo importante son 
los números mágicos mayores y menores. En el script que se adjunta más abajo, 
crea el directorio <tt>/dev/input/</tt> y en él dispositivo con <tt>mknod /dev/input/mice c 13 63</tt>.

<p>
Para utilizar el ratón USB con las X, hay que editar el fichero <tt>/etc/X11/XF86Config</tt>
<p>
<descrip>
<tag>
  Versión</tag>XFree86&gt;=4.0
</descrip>

<verb>
   Section "InputDevice"
             Identifier "Ratón USB"
             Driver "mouse"
             Option "Protocol" "IMPS/2"
             Option "Device" "/dev/input/mice"
             Option "ZAxisMapping" "4 5"
EndSection
</verb>
Y en la seccion ServerLayout:
<verb>
             InputDevice "Ratón USB" "CorePointer"
</verb>
<descrip>
<tag>
  Versión</tag>XFree86 3.3x
</descrip>

<verb>
   Section "Pointer"
             Protocol "IMPS/2"
             Device "/dev/input/mice"
             ZAxisMapping 4 5
EndSection
</verb>

<p>
<bf>¿Como cargo los módulos compilados y como monto el sistema de ficheros /proc/usb?</bf>
 <p>
Yo cogí el fichero que viene en la Mandrake 7.1, y lo modifiqué un poco, ya que éste 
viene para cargar los módulos antiguos, y modifiqué tambien la detección de si es UHCI o OHCI. 
Aquí está:

<verb>
&num;!/bin/sh
if &lsqb; ! -f /etc/conf.modules -o ! -f /etc/sysconfig/usb &rsqb;;then
        echo &quot;No existe /etc/sysconfig/usb&quot;;
        exit 1;
fi
. /etc/rc.d/init.d/functions
. /etc/sysconfig/usb
&num;Esta función mete el alias correspondiente en /etc/conf.modules
function sed_usb_interface () &lcub;
        local module
        module=&dollar;1
        &num;echo &quot;alias usb-interface &dollar;module&quot;
        echo &quot;alias usb-interface &dollar;module&quot;&gt;&gt;/etc/conf.modules
        touch /lib/modules/&dollar;(uname -r)/modules.dep
&rcub;
&num;Esta funcion detecta el tipo de interfaz usb que tenemos (uhci_t o ohci_t)
function probe_usb_interface () &lcub;
        local t pci_f uhci_t ohci_t
        if ! grep -q &quot;USB&quot; /proc/pci  ;then
        return 1;
        fi
        if &lsqb; &dollar;(cat /proc/pci |sed -n '/USB/,&dollar;p'|sed -n '3p'|awk  '&lcub;print &dollar;3;&rcub;'|wc -c|sed -e 's/&bsol; *//') -gt 7 &rsqb;;then 
                sed_usb_interface usb-ohci      
                return 0;
        else    
                sed_usb_interface usb-uhci      
                return 0;
        fi
&rcub;       
 
function get_usb_interface () &lcub;
        if ! grep -q &quot;^alias usb-interface&quot; /etc/conf.modules; then
                echo -n &quot;Detectando interfaz USB    &quot;
                if ! probe_usb_interface; then
                        echo_failure;
                        echo
                        exit 1;
                else
                        echo_success
                        echo
                fi
        fi
&rcub;
 
function mount_proc_usb () &lcub;
        if grep -q usbdevfs /proc/filesystems; then
                if ! grep -q /proc/bus/usb /proc/mounts; then
                        action &quot;Montando sistema de ficheros USB&quot; mount -t usbdevfs /proc/bus/usb /proc/bus/usb
                fi
        fi              
&rcub;
 
function umount_proc_usb () &lcub;
        if grep -q usbdevfs /proc/filesystems;then
                if grep -q /proc/bus/usb /proc/mounts;then
                        action &quot;Desmontando sistema de ficheros USB&quot; umount /proc/bus/usb
                fi
        fi
&rcub;
 
 
&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;
&num;           Main                               &num;
&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;&num;
 
PKLVL=`sed -e 's/^&bsol;(.&bsol;).*/&bsol;1/'&lt;/proc/sys/kernel/printk`
case &dollar;1 in
        start)
        get_usb_interface;
        sysctl -w kernel.printk=0
        action &quot;Cargando interfaz USB&quot; /sbin/modprobe usb-interface
        if &lsqb; &quot;&dollar;MOUSE&quot; = &quot;yes&quot; &rsqb;;then
                sleep 2
                if &lsqb; ! -d /dev/input &rsqb;;then
                        mkdir /dev/input
                fi
                if &lsqb; ! -c /dev/input/mice &rsqb;;then
                        mknod /dev/input/mice c 13 63
                fi
                action &quot;Cargando ratón USB&quot; /sbin/modprobe input &amp;&amp; /sbin/modprobe hid &amp;&amp; /sbin/modprobe mousedev
        fi
        if &lsqb; &quot;&dollar;KEYBOARD&quot; = &quot;yes&quot; &rsqb;;then
                sleep 2
                action &quot;Cargando teclado USB&quot; /sbin/modprobe input &amp;&amp; /sbin/modprobe hid &amp;&amp; /sbin/modprobe keybdev
        fi
        sleep 1 &amp;&amp; sysctl -w kernel.printk=&dollar;PKLVL
        mount_proc_usb;
        ;;
        stop)
        sysctl -w kernel.printk=0
        if &lsqb; &quot;&dollar;MOUSE&quot; = &quot;yes&quot; &rsqb;;then
                action &quot;Descargando ratón USB&quot; /sbin/modprobe -r mousedev &amp;&amp; /sbin/modprobe -r hid &amp;&amp; /sbin/modprobe -r input 
    fi
    if &lsqb; &quot;&dollar;KEYBOARD&quot; = &quot;yes&quot; &rsqb;;then
                action &quot;Descargando teclado USB&quot; /sbin/modprobe -r keybdev &amp;&amp; /sbin/modprobe -r hid &amp;&amp; /sbin/modprobe -r input 
    fi
    action &quot;Descargando interfaz Usb&quot; /sbin/modprobe -r usb-interface
    sleep 1 &amp;&amp; sysctl -w kernel.printk=&dollar;PKLVL
    ;;
    status)
    if fgrep -q usbcore /proc/modules; then
            echo &quot;USB Cargado.&quot;
    else 
            echo &quot;USB no cargado.&quot;
    fi  
    exit 0
    ;;
    restart)
    &dollar;0 stop
    &dollar;0 start
    ;;
    *)
    echo &quot;Uso: &dollar;(basename &dollar;0) start|stop|restart|status&quot;
    exit 0
    ;;
esac
exit 0
 </verb>

Este archivo se puede meter en <tt>/etc/rc.d/init.d/usb</tt>, y hacerle un enlace 
desde el nivel de ejecución, bien sea a mano, o mediante el ksysv o cualquier 
otro editor de niveles de arraque. Este fichero funcionará en redhat y derivadas. 
Para que funcione en el resto hay que eliminar la línea . /etc/rc.d/init.d/functions 
y sustituir la expresión action &lt;cadena&gt; por echo &lt;cadena&gt;';'.

<p>
El fichero supone que existe el fichero <tt>/etc/sysconfig/usb</tt>, en el que estarán 
las claves MOUSE y KERYBOARD, con yes o cualquier otra cosa.

<p>
Básicamente los módulos a cargar son:

<p>
usbcore.o, usb-uhci.o o usb-ohci.o, input.o, hid.o, y mousedev.o y/o keybdev.o

<p>
<bf>Direcciones de interés</bf>
<p>
<descrip>
<tag>
http://www.linux-usb.org.</tag>Aquí está todo lo que se necesita (para qué se quiere más).
</descrip>



<!-- ***************************** -->
<!-- ***************************** -->
<!-- SECCIÓN INTERNET/REDES/MODEMS -->
<!-- ***************************** -->
<!-- ***************************** -->

<sect>Internet / Modems


<!-- ********************************************** -->
<!-- SUBSECCIÓN  QUE ES UN MODEM? Y UN PUERTO SERIE?-->
<!-- ********************************************** -->

<sect1>¿Qué es un modem? ¿Y un puerto serie?
<p>
¿Por qué los modems están normalmente asociados a puertos serie? Lo
impone el hecho que cuando uno usa un modem, la línea telefónica a 
la que está conectado sólo tiene un cable por el que enviar la información.
Para transmitir simultáneamente los 8 bits de los que consta un byte, que
es la unidad de información usual en los ordenadores, harían falta 8 cables 
(8 líneas telefonicas). Una solución alternativa es enviar los 8 bits 
sucesivamente uno detrás del otro a intervalos de tiempo regulares. 
Precisamente esto es lo que hace un puerto serie.
<p>
El corazón del puerto serie es un chip del ordenador llamado UART 
(Receptor-Transmisor Asíncrono Universal) el cual se encarga de todo
el trabajo, tanto para recibir datos como para enviarlos. Así, la 
potencia de dicha UART y lo bien configurada que esté influirán en la 
calidad de la comunicación.
<p>
El flujo de bits generado por la UART/puerto serie no puede introducirse 
directamente en la línea telefónica al no estar preparada para ello. 
La solución es utilizar un aparato intermedio que tome los bits que
llegan del puerto serie y emita un tono u otro por la línea telefónica 
según le llegue un bit 0 o un 1. Esto es lo que se conoce como "modular una 
señal". Al otro lado del hilo telefónico otro aparato similar 
interpretaría estos tonos y generaría unos o ceros en función del tono 
recibido. Éste sería el paso opuesto, "demodular la señal". Como 
normalmente se deseará enviar y recibir, el aparato intermedio deberá 
realizar ambas funciones: MOdular y DEModular (MO-DEM). Así funcionaban 
los modems antiguos. Los modernos se basan en los mismos principios
aunque son infinitamente más versátiles y potentes.
<p>
Los modems modernos realizan la modulación y demodulación utilizando
chips especiales llamados DSP (Procesadores Digitales de Señales en
castellano). Son como microprocesadores, pero muy rápidos y optimizados 
para tratamiento de señales. Los modems modernos también incorporan sistemas 
de compresión de datos que aceleran las transferencias, sistemas de
corrección de errores, cambios automáticos de velocidad de transferencia
si la calidad de la señal mejora o empeora, etc...
<p>
Existen dos clases de modems: Los internos y los externos. Los externos
van conectados a un puerto serie del ordenador por lo que simplemente
se limitan a las funciones descritas de modulación-demodulación, compresión, 
correción, etc. Los modems internos "de verdad", al no ir conectados a un 
puerto serie incorporan una UART como las de dichos puertos serie, de forma
que a ojos del ordenador se trata de un puerto serie más.


<!-- ******************************************* -->
<!-- SUBSECCIÓN ENTONCES QUE ES UN WINMODEM      -->
<!-- ******************************************* -->

<sect1>Entonces, ¿Qué es un winmodem, modem HSP o modem software ? ¿Funcionan los winmodem en Linux ? ¿Y los modems PCI?
<p>
Son modems internos "capados". Los fabricantes les quitan chips para que sean 
más baratos. Por ejemplo, algunos no tienen UART, a otros les quitan los 
protocolos de compresión, etc. Para que tengan las mismas funciones que los 
modems "de verdad", las funciones correspondientes a los chips retirados
las tienen que realizar drivers del sistema operativo, o sea el 
microprocesador del ordenador.
<p>
Los fabricantes de los distintos modems sólo ofrecen drivers para Windows
y no dan especificaciones de como se programan, y así desarrollar versiones
para Linux. Por tanto estos modems no funcionan en Linux.
<p>
<bf>NOTA</bf>: Ya existe un proyecto para soportar estos modems en linux. No están
todos soportados pero si muchos de ellos. En <url url="http://www.linmodems.org/" name="http://www.linmodems.org/">
existe informacion detallada sobre este proyecto.
<p>
Al contrario que hace un tiempo, ya existen en el mercado modems PCI totalmente soportados y que son modems "de verdad". 
asi que el tener un modem PCI no es sinónimo de problemas actualmente. En esta página 
<url url="http://www.o2.net/~gromitkc/winmodem_es.html" name="http://www.o2.net/~gromitkc/winmodem_es.html"> teneis más informacion sobre los winmodems.


<!-- ********************************************* -->
<!-- SUBSECCIÓN COMO SE CONFIGURA EL PUERTO SERIE? -->
<!-- ********************************************* -->

<sect1>¿Cómo se configura el puerto serie ?
<p>
La primera pregunta sería: ¿ Debo configurar mis puertos serie ?
<p>
En general, sólo deberás configurar los puertos serie en estos casos:
<itemize>
<item>Tu modem es interno y Plug'n'Play. Deberás configurar el modem y al menos 
el puerto serie que incorpora.

<item>Tienes más de dos puertos serie, contando además con los que incorporan los 
modems internos (si tienes alguno). Por lo general deberás configurar todos
los puertos a partir del COM3 incluido.

<item>Un tercer caso, más raro, que consistiría en tener un modem interno
en COM1 o COM2 y que no usara los recursos estandar (puerto 3f8 e
interrupción 4 para COM1, y puerto 2f8 e interrupción 3 para COM2). Los
recursos utilizados por el modem pueden consultarse en el Panel de Control de 
Windows 95 (Sistema -> Administrador de dispositivos -> Puertos COM y LPT ->
el puerto que sea -> Recursos). Entonces deberás configurar el puerto del 
modem.
</itemize>
Si no cumples ninguna de estas condiciones, puedes ignorar el resto de la
sección.
<p>
Un puerto serie (más exactamente, la UART del puerto serie) usa un rango 
de direcciones de entrada-salida y una solicitud de interrupción para 
comunicarse con el sistema operativo. Para el correcto funcionamiento del 
ordenador y del sistema operativo, ningún otro dispositivo del ordenador 
puede usar alguno de esos valores. Nuestro objetivo será conseguir esto, 
y en segundo lugar, hacer que el sistema operativo atienda a ese rango de 
entrada-salida y esa interrupción para comunicarse con el modem.
<p>
Tradicionalmente la elección del rango de entrada-salida y la interrupción
se realizaba a través de una serie de microinterruptores manuales situados 
en el modem. Conocida la posición de estos interruptores, se configuraba
el sistema operativo para que usara esos valores. Hoy en día casi la totalidad
de los modems internos son Plug'n'Play, lo cual significa que el sistema
operativo puede, por software, decirle a la tarjeta qué valores debe usar.
<p>
<bf/Configuración de modems Plug'n'Play en Linux/
<p>
Si tienes un modem Plug'n'Play, lo primero que habrá que hacer es
decirle que rango de entrada-salida y que interrupción debe usar. Lo más
cómodo en este caso es usar los mismos valores que Windows 95. Para ello
arranca Windows 95, y haz Inicio->Configuración->Panel de control. Una vez
en el Panel de control, elige el icono 'Sistema' y dentro de él, el
'Administrador de dispositivos'. Dentro del apartado 'Puertos COM y LPT'
elige el correspondiente al puerto COM donde tienes el modem. Busca en
'Recursos' el rango de entrada-salida y la interrupción que use y apúntalos.
<p>
Con esos valores en la mano, puedes configurar tu modem Plug'n'Play en Linux.
Eso se hace con el programa 'isapnp'. Entra en Linux y busca si tienes
un archivo llamado <tt>/etc/isapnp.conf</tt>. Si no lo tienes haz lo siguiente:
<verb>
  pnpdump > /etc/isapnp.conf
</verb>
Esto generará el esqueleto de un archivo de configuración para 'isapnp'.
Este programa generará un listado con todas las posibles posibilidades
de configuración que permiten tus dispositivos Plug'n'Play, pero 
todas deshabilitadas con un '#' al principio de cada línea. Los dispositivos
aparecen por secciones por lo que es fácil encontrar los correspondientes
a tu modem.
<p>
Así tu misión se reducirá a encontrar en la sección correspondiente a tu modem
del archivo <tt>/etc/isapnp.conf</tt>, dos líneas así:
<verb>
  # (IO 0 (BASE 0x0NNN))
  # (INT 0 (IRQ MM (MODE +E)))
</verb>
donde NNN sea el rango de entrada-salida que use el modem en Windows y MM
la interrupción. Las líneas no tienen por qué ser consecutivas ni ir en ningún
orden especial. Cuando las encuentres, quítales el '#' inicial. Luego, al
final de la sección del modem encontrarás una línea parecida a esta:
<verb>
  # (ACT Y)
</verb>
De la misma forma, le quitas el '#' inicial. Ya está. Listo para enviar
dichos valores al modem. Esto lo hace la orden <tt>isapnp /etc/isapnp.conf</tt>
y deberá aparecer en los scripts de arranque de Linux para enviar los
valores cada vez que enciendas el ordenador. Las distribuciones más
recientes (Red-Hat 5.0 y posteriores, Debian 2.0 y posteriores) ya incluyen
dicha invocación por lo que no necesitarás tocar los scripts de arranque.  
En caso de tener una distribución antigua, será necesario añadir dicha
orden. Un buen sitio para incluirla sería el script <tt>rc.local</tt>, que suele
estar situado en uno de los subdirectorios de <tt>/etc</tt>.
<p>
De todas formas será necesario ejecutar <tt>isapnp /etc/isapnp.conf</tt> si queremos 
activar los cambios en este momento y nos queremos ahorrar el rearrancar la 
máquina.
<p>
Ahora hay que decirle al sistema operativo que debe usar esos valores para 
comunicarse con el modem. En el caso de los modems Plug'n'Play lo que viene
a continuación es imprescindible.
<p>


<bf/Configuración de los puertos serie a ojos del sistema operativo/
<p>
Lo primero que hay que saber es que Linux no llama a los puertos serie
de la misma forma que el DOS o Windows. Así existe la siguiente 
correspondencia:
<verb>
  DOS-Windows			  Linux
  -----------			----------
     COM1			/dev/ttyS0
     COM2			/dev/ttyS1
     COM3			/dev/ttyS2
     COM4			/dev/ttyS3
</verb>
Ojo a las mayúsculas y las minúsculas del nombre de Linux. Son importantes.
<p>
Para leer la configuración y configurar los puertos serie se usa
la orden 'setserial'. Para leer la configuración, hay que ejecutar
<tt>setserial</tt> con el puerto serie que deseamos ver como único parámetro.
<p>
Por ejemplo:
<verb>
  setserial /dev/ttyS1
</verb>
nos muestra la configuración de COM2 y se obtendrá algo como esto:
<verb>
  /dev/ttyS1, UART: 16550A, Port: 0x02f8, IRQ 3
</verb>
o sea, el puerto serie (<tt>/dev/ttyS1</tt>), el tipo de chip UART que lleva (16550A), 
el puerto base de entrada-salida (2f8) y la solicitud de interrupción (3). 
Nótese que estos son los valores que el sistema operativo CREE que debe 
utilizar para comunicarse con el modem/puerto serie. Es posible que ahora no
coincidan con los reales, incluso que ni siquiera detecte la UART, lo cual no 
es raro en caso de modems Plug'n'Play.
<p>
Si no coinciden, asignaremos los valores adecuados. Por fortuna, por lo 
general no será necesario indicar la dirección base de entrada-salida. Salvo
casos muy, muy excepcionales COM1 usa la dirección base 3f8, COM2 la 2f8,
COM3 la 3e8 y COM4 la 2e8, y eso setserial lo sabe. Así, al indicar el
puerto serie, setserial implícitamente sabe cual es la dirección base.
En cambio, en caso de tener un puerto COM5 o superior sí será necesario 
indicar la dirección base.
<p>
Así para COM1-COM4 sólo indicaremos la interrupción. Por ejemplo,
supongamos que tenemos un modem en COM3 que usa la interrupción 5.
La orden a introducir sería.
<verb>
  setserial /dev/ttyS2 irq 5 autoconfig
</verb> 
Y si quisiéramos indicar también la dirección base de entrada-salida
(por tener el modem en COM5, por ejemplo) se haría así.
<verb>
  setserial /dev/ttyS4 port 0x2e8 irq 10 autoconfig
</verb>
lo cual hace que el sistema operativo use un rango de direcciones desde
la 2e8, y la interrupción 10. Nótese que el '0x' antes de la dirección base
es importante.
<p>
Por último sólo queda ver que los cambios han surtido efecto. Para ello
bastará usar de nuevo setserial de la primera forma que se indicó.
<p>
Por desgracia esta configuración durará hasta que apaguemos el ordenador.
Por tanto será necesario incluir la línea o líneas de configuración 
<tt>setserial /dev/ttyS2 irq 5...</tt> en uno de los scripts de arranque de
Linux para que los puertos se configuren cada vez que se inicie el sistema 
operativo. Un buen candidato es <tt>rc.local</tt>, que estará en uno de los 
subdirectorios de <tt>/etc</tt>. En caso de ser necesario incluir en <tt>rc.local</tt> tanto 
el <tt>isapnp /etc/isapnp.conf</tt> para configurar un modem Plug'n'Play, y el 
<tt/setserial.../ de los puertos serie, deberá colocarse el <tt/isapnp.../ en 
primer lugar.
<p>
También habrá que usar <tt/setserial/ de la misma forma si el ordenador tuviera 
más de dos puertos serie, (contando los que traen los modems internos en caso 
de disponer de alguno). El motivo es que por alguna extraña razón de diseño del
PC, COM1 y COM3 por defecto comparten la misma interrupción, y a pesar de que
esa configuración no es deseable, Linux por defecto busca COM3 en la misma
interrupción que COM1, por lo que habría que cambiar la de COM3. Lo mismo 
ocurre con COM2 y COM4 por lo que habría que cambiar COM4. Si no se hiciera 
esto, podrían ocurrir cosas muy raras, como ratones y modems que dejan de 
funcionar, modems que funcionan "a pedales" (cuando se mueve el ratón), etc...


<!-- ******************************************************** -->
<!-- SUBSECCIÓN COMO COMPRUEBO QUE TODO ESTA BIEN CONFIGURADO -->
<!-- ******************************************************** -->

<sect1>¿ Cómo compruebo que todo está bien configurado ?
<p>
Una vez activados los cambios con el comando isapnp para los modems
Plug'n'Play y el/los comando(s) setserial necesarios para configurar el/los
puerto(s) serie, o se ha reiniciado el ordenador con los scripts de arranque
modificados para que ejecuten dichas órdenes (es más seguro hacer lo primero),
se puede probar si todo va bien. La forma más sencilla es usar un programa
de comunicaciones y enviarle comandos al modem para ver si responde.
<p>
Así un programa adecuado sería <tt/minicom/ que es un terminal de comunicaciones
tipo Telix. No es complicado de configurar. Pulsando <tt/Ctrl+a/ y luego z sale
un menú. Una de las opciones 'cOnfigure minicom' dará paso a otro menú donde
la opción "Serial port setup" nos permitirá elegir el puerto serie, la 
velocidad con la que nos comunicaremos con él (no la velocidad del modem) y
otras opciones más. Lo normal es usar 115200 o 57600 para la velocidad, 8N1,
"Hardware Flow Control: Yes" y "Software Flow control: No". Una vez 
configurado y sin ningún menú sobre la pantalla escribes 'AT' (Las dos
en mayúsculas o las dos en minúsculas) y pulsas ENTER. Si el modem responde
al instante 'OK' o con un número cero, indicaría que el modem funciona y
que responde bien. Para completar la faena puedes probar a conectarte a una
BBS o a tu nodo de infovia plus (los nodos de infovia plus permiten una
conexión tipo terminal, aunque no sé que se puede hacer con ella) y así
probar que todo va bien.
<p>
Si el modem tarda en responder al 'AT', o no responde, algo ha fallado en
la configuración del modem o del puerto serie y habría que revisar lo hecho.
<p>
Un comentario sobre el 'AT'. Cuando se escriben estas dos letras pueden
ocurrir varias cosas.
<itemize>
<item>Que salga el AT mientras lo escribes (lo normal).
<item>Que no te salga el AT, pero al pulsar <tt/ENTER/ el modem responda con OK. Para
solucionar esto  deberías activar el eco local del terminal con <tt/Ctrl+a e/
o escribir a ciegas "ATE1" y pulsar <tt/ENTER/.
<item>Que te salga AATT y todo lo que pongas por duplicado. No es problema
porque el modem sólo recibirá 'AT'. Para quitar esto, desactiva el eco local
del terminal con <tt/Ctrl+a e/ o escribe "ATE0" aunque te salga duplicado.
Cuando pulses ENTER tras el ATE0 ya funcionará bien.
</itemize>

<!-- ******************************************* -->
<!-- SUBSECCIÓN  COMO CONECTO CON PPPD           -->
<!-- ******************************************* -->

<sect1>¿Cómo conecto a internet con pppd ?
<p>
¿Que es pppd? Se trata de la primera posibilidad de conexión a internet
que ofrece Linux. Es una conexión a internet que gasta pocos recursos
y con posibilidad de hacerla desde la consola, sin necesidad de entrar en
modo gráfico. Cualquiera que aspire a obtener al máximo rendimiento de la
conexión a internet, por ejemplo automatizando la conexión, automatizando
la recogida de correo, noticias, ftp, etc... casi seguro no tendrá más 
remedio que pasar por aquí.
<p>
Como inconvenientes, tiene unos cuantos. El más destacable es la falta
total y absoluta de interactividad o de información en pantalla de cómo
va la conexión, siendo necesario el uso de otros comandos (como <tt/ifconfig/)
o la observación de archivos históricos (<tt>/var/log/messages</tt>) para averiguar si 
la conexión se ha realizado con éxito o ha habido algún error.
<p>
La configuración de pppd se basa en la creación de una serie de archivos.
<p>
<tt><bf>/etc/ppp/options </bf></tt>: Configuración de la conexión y del puerto serie   &nl  
<tt><bf>/etc/ppp/marcado </bf></tt>: Configuración del modem y marcado del número de teléfono    &nl  
<tt><bf>/etc/ppp/pap-secrets </bf></tt>: Claves de acceso para identificación con PAP    &nl  
<tt><bf>/etc/ppp/chap-secrets </bf></tt>: Claves de acceso para identificación con CHAP    &nl  
<tt><bf>/etc/resolv.conf </bf></tt>: Servidores de nombres (DNS)    &nl  
<p>
Así un posible <tt>/etc/ppp/options</tt> sería así:
<verb>
  -----------------------------------------------------------------
  connect "/usr/sbin/chat -v -f /etc/ppp/marcado"
  name mi_login@mi_proveedor
  defaultroute
  noipdefault
  modem
  crtscts
  asyncmap a0000
  mru 576
  /dev/ttySx
  115200
  --------------------------------------------------------------------
</verb>
Comentarios:
<itemize>
<item>En mi_login@mi_proveedor irá el login y el proveedor (el proveedor sin
dominio, por ejemplo: fulanito@arrakis)

<item>Donde pone <tt>/dev/ttySx</tt>, la 'x' indica el puerto serie: <tt>/dev/ttyS0 = COM1,
/dev/ttyS1 = COM2</tt>, etc...

<item>La velocidad 115200 <em/NO es la velocidad del modem/, es la velocidad entre el
modem y el puerto serie, que no tiene por qué coincidir con la velocidad
en el lado de la línea telefónica. <em/La velocidad del modem (33600, 28800...)
NO hay que ponerla en ningun sitio/. Algunos modems no soportan esa velocidad
entre el modem y el puerto serie y habrá que probar con 57600 o incluso con
38400. Si se tiene una UART 16450 o 8250, utilizar 38400 (usar 
<tt>setserial /dev/ttySx</tt> para conocer la UART del modem o del puerto serie, 
donde 'x' indica el puerto serie de la misma forma que antes). Nótese que el 
valor óptimo es 115200 y conforme menor sea dicho valor, menos rendimiento 
le sacaremos al modem.
</itemize>
<tt>/etc/ppp/marcado</tt>:
<verb>
  --------------------------------------------------------------
  ABORT "BUSY"
  ABORT "NO CARRIER"
  ABORT "NO DIALTONE"
  ABORT "ERROR"
  ""
  "AT&amp F" TIMEOUT 5 OK
  "ATW1DTnumero_de_telefono" TIMEOUT 100 CONNECT
  ---------------------------------------------------------------
</verb>
Comentarios:
<itemize>
<item>Los ABORT iniciales sirven para que, si el modem encuentra una situación
anómala (no hay tono de llamada, comunicando...) y responde alguno de esos
mensajes (BUSY, NO CARRIER...), el pppd pare y no pierda tiempo hasta fallar
el TIMEOUT 100 que sería el que acabase la conexión. El problema es que no
todos los modems responden de la misma forma (por ejemplo, el mío responde
"NO DIAL TONE" en vez de "NO DIALTONE") y la correspondencia debe ser exacta.
Por tanto, para una configuración correcta, será necesario consultar en el
manual del modem cómo son estos mensajes.

<item>El "AT&amp F" es la cadena de inicialización del modem. La que se indica es 
de las más estandar. No obstante, en algunos modems puede ser mejor "ATZ"
o variantes de "AT&amp F" (como "AT&amp F1", "AT&amp F2"...). Como referencia, se debe
usar aquella que configure el modem para usar control de flujo hardware
(RTS/CTS). En caso de no acertar en la configuración del modem, es posible
que se produzcan algunos efectos indeseables (el modem no cuelga al cortar
la comunicación, conexión lenta...). Una posibilidad es "fusilar" la que
use windows. Se puede ver dentro del directorio de windows un archivo
llamado modemlog.txt o modemdet.txt.

<item>El numero_de_telefono es precisamente eso. El número de telefono del
nodo de Infovia Plus, el de Iddeo, etc...
</itemize>

<tt>/etc/ppp/pap-secrets</tt> y <tt>/etc/ppp/chap-secrets</tt>
<p>
Existen dos formas posibles de identificación cuando nos conectamos a
un proveedor: PAP y CHAP. PAP es la más sencilla y es la que usaba por
ejemplo Infovia. CHAP es muy usada en Infovia Plus.
<p>
El formato de ambos archivos es el mismo:
<verb>
  ------------------------------------------------------------------------
  mi_login@mi_proveedor	*	password
  ------------------------------------------------------------------------
</verb>
Comentarios:
<itemize>
<item>mi_login@mi_proveedor debe ser exactamente lo mismo que se puso como
parámetro de la opción 'name' en <tt>/etc/ppp/options</tt>.

<item>Los campos <em/Van separador por TABULADORES no por espacios/.

<item>Si se dispone de más cuentas en otros proveedores, se pueden añadir
nuevas líneas con el mismo formato.
</itemize>
¿Cual uso, pap-secrets o chap-secrets? Si sabes que tu proveedor usa PAP,
grábalo como <tt>pap-secrets</tt>. Si usa CHAP, grábalo como <tt>chap-secrets</tt>. Si no
sabes cual usa, puedes hacer prueba-y-error o crearte los dos, o crearte
uno sólo y hacer un enlace simbólico de uno al otro. Por ejemplo, si has
creado chap-secrets, para hacer un enlace desde pap-secrets se haría:
<verb>
  cd /etc/ppp
  ln -s chap-secrets pap-secrets
</verb>
Esto en teoría haría que pppd y tu proveedor se pusieran de acuerdo
para elegir PAP o CHAP según prefieran.
<p>
<tt>/etc/resolv.conf</tt> :
<p>
Aquí irían las direcciones de los DNS primario y secundario. El formato
es muy sencillo:
<verb>
  -------------------------------------------------------
  nameserver DNS_primario
  nameserver DNS_secundario
  -------------------------------------------------------
</verb>
Por ejemplo, <tt/nameserver 195.5.65.2/
<p>
Comentarios:
<itemize>
<item>En lugar de DNS_primario y DNS_secundario, se pondrán las direcciones
numéricas de los DNS primario y secundario respectivamente. Los DNS
primarios y secundarios deberás preguntarlos a tu proveedor y deberán
dártelos, pues no son secretos. 

<item>Si no tuvieras DNS_secundario, puedes ahorrarte la segunda línea.
</itemize>
Una vez creados los scripts, la conexión se efectuaría al escribir
<tt/pppd/ o <tt>/usr/sbin/pppd</tt>.
<p>
Para comprobar si la conexión tiene éxito, se puede usar el
comando <tt>/sbin/ifconfig</tt> y ver si al cabo de un minuto o dos aparece
un bloque nuevo <tt/ppp0/.
<p>
Otra forma es consultando periódicamente el fichero <tt>/var/log/messages</tt>
hasta ver si aparece algo como esto:
<verb>
  Local  IP address xxx.xxx.xxx.xxx
  Remote IP address yyy.yyy.yyy.yyy
</verb>
Lo cual indicaría una conexión con éxito. Una forma de hacer esto sería
con la orden <tt>tail -f /var/log/messages</tt> y pulsar <tt>Ctrl+C</tt> cuando veamos
que la conexión ha funcionado o fallado.
<p>
La desconexión se realizaría introduciendo la orden <tt>killall pppd</tt>.
<p>
En caso de necesitar ayuda, remitir la duda a es.comp.os.linux.misc o
es.comp.os.linux.redes mandando copia de los scripts (ocultando los
passwords, claro) y lo que haya salido en <tt>/var/log/messages</tt> durante
la conexión fallida.
<p>
<bf/NOTA IMPORTANTE/: Los ficheros arriba descritos han de crearse desde cero
con un editor de Linux. Crearlos con un editor de DOS o de Windows, o
con operaciones de cortar-y-pegar en Windows añade un caracter no visible
al final de cada línea que Linux confundiría con un caracter normal, 
inutilizando los scripts.


<!-- ******************************************* -->
<!-- SUBSECCIÓN COMO CONECTO A INTERNET CON KPPP -->
<!-- ******************************************* -->

<sect1>¿Cómo conecto a internet con KDE-kppp?
<p>
Después de haber utilizado diversos sistemas para conectar con Internet a través de InfovíaPlus mediante módem y haber constatado en el grupo de noticias <em/es.comp.os.linux/ la gran cantidad de veces que se pregunta acerca de cómo conectarse mediante kppp, hemos pensado que este breve resumen sobre como establecer la conexión usando el kppp podría ser interesante para algunos que se inician en linux y disfrutan del entorno grafico KDE. Las notas que escribo a continuación se refieren a la versión KDE 1.0 (las diferencias con respecto al KDE 1.1 son mínimas)y por lo tanto voy a partir de la base de que el usuario de linux ha instalado ya el KDE y le funciona sin problemas de ningún tipo.
<p>
<bf/Guía paso a paso de conexión a internet a través de InfovíaPlus con kppp/. 
<p>
<em/Antes de comenzar/
<p>
El módem debe estar correctamente instalado y su funcionamiento verificado (usando por ejemplo el programa minicom). El dispositivo asociado al módem dependerá del puerto serie al que está conectado. Si está conectado al "COM2" (en jerga DOS) el dispositivo será <tt>/dev/ttyS1</tt>, y podemos hacer un enlace simbólico a <tt>/dev/modem</tt>:
<verb>
  ln -s /dev/ttyS1 /dev/modem
</verb>
Además debemos saber su velocidad máxima. Si el módem es de más de 28,8Kbps podemos tomar 115200.
<p>
Otros datos fundamentales son los que tienen que ver con nuestro proveedor de internet:
<itemize>
<item><em/"Domain name"/ (Nombre de dominio del servidor de acceso) seguido por un punto y la extensión del país: por ejemplo proveedor.es (se trata de un nombre inventado para ilustrar el procedimiento)

<item><em/"DNS IP"/ (Dirección IP del servidor de nombres de dominio: en nuestro caso será (inventado también) 194.150.24.25

<item><em/Login:/ compuesto por nuestro indicador de usuario (p.ej. user) y "Domain name" sin extensión separados por arroba: user@proveedor

<item><em/Número de teléfono/ que corresponda según nuestro nodo de conexión. Cuando existía Infovía este número era el 055, pero con InfovíaPlus, dependiendo del lugar hay un teléfono de acceso, por ejemplo (para Sevilla) 954547000
</itemize>

<em/Comenzamos/ 
<p>
Invoquemos kppp mediante acción sobre el correspondiente icono del menú del KDE o escribiendo en un terminal 
<verb>
  [user@localhost]# kppp
</verb>
Para que programa funcione para un usuario normal el propietario y el grupo deben ser root y el ejecutable debe tener el bit SETUID activado, para poder abrir el dispositivo del módem. Si no es así se pone uno superusuario
<verb>
  [user@localhost]# su root

  (... da la password... y entonces hacemos)

  [user@localhost]# chown root.root kppp
  [user@localhost]# chmod +s kppp
  [user@localhost]# exit

  (...para volver a usuario normal...)
</verb>
Si todo ha ido bien aparecerá la ventana del kppp y con el ratón accionaremos la tecla
<verb>
  setup
</verb>
Entonces se abrirá la ventana kppp configuration con varias pestañas indicando secciones: Accounts; Device; Modem; PPP y About. Comenzaremos por la primera sección
<itemize>
<item><bf><em>Sección ACCOUNTS</em></bf>
<p>
Accionamos la tecla new y aparece una nueva ventana llamada new account con otra serie de subsecciones: desde Dial hasta Accounting.
<p>
<bf><em>Subsección DIAL</em></bf> 
<p>
Esta sección contiene el Dial Setup que debemos rellenar:  &nl  
<em/Connection name/: Ponemos el nombre que queramos dar a la conexión; por ejemplo INFOPLUS  &nl  
<em/Phone number/: 954547000  &nl  
<em/Authentication/: La autenticación puede realizarse de cuatro modos; script-based, PAP, terminal-based o CHAT; debemos elegir la opción PAP   &nl  
<em/Store password/: Si no quieres tener que teclear la password cada vez que te conectes deja activada esta opción
<em/Execute program upon connect/: Debe tener su casillero vacío. No escribas nada.  &nl  
<em/Execute program upon disconnect/: Debe tener su casillero vacío. No escribas nada.  &nl  
<em/Edit pppd arguments/: Una vez activada la opción los argumentos se introducen escribiéndolos en el casillero "arguments" y pulsando la tecla "add". Deben estar los siguientes:
<verb>
  detach
  defaultroute
  asyncmap a0000
  noipdefault
  ipcp-accept-local
  ipcp-accept-remote
</verb>
cuando hayamos terminado, pulsamos "close" y pasamos a las subsecciones siguientes
<p>
NOTA: Estos argumentos los tenía así establecidos para cuando conectaba con Infovía. Al pasar a InfovíaPlus, alguno puede quedar superfluo, pero ¡funciona!, así que no quité ninguno.
<p>
<bf><em>Subsección IP</em></bf>
<p>
Contiene el IP setup. La única opción que debe estar activada es 
<em/Dynamic IP address/
<p>
<bf><em>Subsección DNS</em></bf>
<p>
Aquí tenemos el menú del DNS Server:  &nl  
<em/Domain name/: proveedor.es  &nl  
<em/DNS IP address/: La(s) introducimos en este casillero: 194.150.24.25 y pulsando la tecla "add" la(s) pasamos al DNS address list. Al menos debe haber una.  &nl  
<em/Disable existing DNS servers during connection/: Esta opción debe estar activada  &nl  
<p>
<bf><em>Subsección GATEWAY</em></bf>
<p>
Contiene el Gateway setup las opciones que deben activarse son:  &nl  
<em/Default Gateway/  &nl  
<em/Assign the default route to this gateway/  &nl  
<p>
<bf><em>Subsección LOGIN SCRIPT</em></bf>
<p>
¡Principiantes Ni tocarlo! El edit script deberá estar vacío, con el primer casillero de opciones presentando la opción "EXPECT".
<p>
<bf><em>Subsección ACCOUNTING</em></bf>
<p>
La opción <em/Enable accounting/ debe estar activada. Selecciona entonces con la opción "Selected" : Spain y dentro de ella, Telefónica Local y deja la opción "Volume accounting: No accounting" desactivada.
<p>
Entonces, una vez que hemos rellenado todas las subsecciones de la sección ACCOUNTS, accionamos el botón OK de la ventana "new account" y volvemos a la de kppp configuration. Hay que rellenar el resto de las secciones.
<p>
<item><bf><em>Sección DEVICE</em></bf>
<p>
Aquí está el menú Serial device:   &nl  
<em/Modem device/: pon el dispositivo correspondiente, p.ej. /dev/ttyS1 (para modem en puerto serie com2)  &nl  
<em/Flow control/: CRTSCTS (hardware flow control)  &nl  
<em/Line termination/: La que corresponda. Generalmente es CR/LF  &nl  
<em/Connection speed/: La que corresponda, p.ej. 115200  &nl  
<em/Modem lock file/: /var/lock/LCK..modem  &nl  
<p>
 Este fichero debe estar por defecto. No lo cambies si no sabes lo que haces, pues algunos programas como mgetty dependen de la existencia de tal fichero y kppp no funcionará.
<p>
<item><bf><em>Sección MODEM</em></bf>
<p>
<em/Busy wait/: 0 seconds  &nl  
<em/Modem Asserts CD line/: opción desactivada  &nl  
<em/Modem commands/: Deja los valores por defecto y no cambies nada  &nl  
<em/Query modem/: Pulsando este botón kppp insta al módem a que se identifique. Sirve para probar el módem.  &nl  
<em/Terminal/: También sirve para comprobar si el módem negocia bien el protocolo de conexión. De todos modos no te detengas en esto si no sabes lo que haces y sigue adelante.
<p>
<item><bf><em>Sección PPP</em></bf>
<p>
Presenta el ppp setup:
<p>
<em/pppd timeout/: 60 seconds  &nl  
<em/Dock into the panel on connect/: opción desactivada  &nl  
<em/Automatic redial on disconnect/: opción generalmente desactivada  &nl  
<em/Show clock on caption/: opción activada  &nl  
<em/Disconnect on X-server shutdown/: opción activada  &nl  
<em/Quit on disconnect/: opción desactivada  &nl  
<em/Minimize window on connect/: opción activada  &nl  
</itemize>
<p>
La sección ABOUT evidentemente es para mirar solamente. Por último accionamos el botón OK de la ventana kppp configuration. Con ello volvemos a la inicial de kppp. Activamos "Show log window". En el casillero "Connect to" deberá aparecer el nombre de nuestra conexión (en el ejemplo INFOPLUS). El login ID será en nuestro ejemplo user@proveedor. Escribimos la password en su casillero: ****** y por último pulsamos "connect"
<p>
Si todo va bien, aparecerán dos ventanas: una con el marco superior indicando "Connecting to: INFOPLUS" que mostrará Dialing 954547000 y otra mayor, a la derecha de la primera indicando en su marco superior "Login Script Debug Window" y presentando una serie de acciones: 
<verb>
  ATZ
  OK
  ATD954547000

  (Mientras está "Expecting Connect")
</verb>
cuando se ha establecido la conexión, aparece en esa misma pantalla
<verb>
  CONNECT 115200
</verb>
e indicará en su marco inferior "running pppd" mientras la otra ventana indica "Logging on the network". Cuando la ventana mayor presente en su marco inferior "Done"; la otra más pequeña, que en su marco superior exhibirá el nombre de la conexión (INFOPLUS), se minimizará y ya estamos conectados.
<p>
Si restauramos la ventana de conexión INFOPLUS en un momento dado nos mostrará la siguiente información:
<verb>
  Connected at 115200
  Time connected ....
  Session bill...PTAS
  Total bill ....PTAS
</verb>
y dos teclas "Details" (para ver los detalles de la conexión con nuestro proveedor) y "Disconnect" evidentemente para desconectarnos. Si la pulsamos, aparecerá de nuevo la ventana kppp y entonces, para salir, presionaremos la tecla "quit".
<p>
<bf>Preguntas habituales</bf>
<p>
<itemize>
<item>kppp muestra "pppd has died unexpectly" o "data timeout has expired" (pppd ha muerto inesperadamente o ha pasado el tiempo de espera)
<p>
Estos mensajes pueden aparecer alguna que otra vez, aisladamente. Si siempre se producen, entonces hay un problema. Hemos de comprobar que:
<p>
- pppd es realmente un binario y no un script   &nl  
- pppd tiene el bit setuid activado   &nl  
- el fichero <tt>/etc/pppd/options</tt> existe pero está VACÍO   &nl  
- que no has usado la opción "lock" como argumento del pppd en la configuración del kppp   &nl  
- no uses el enlace simbólico <tt>/dev/modem</tt>; en su lugar usa el dispositivo real que corresponda, p.ej., <tt>/dev/ttyS1</tt>   &nl  
- asegúrate que tienes los permisos necesarios   &nl  
<p>
en caso de seguir igual, invoca:
<verb>
  [user@localhost]# tail /var/log/messages
</verb>
para considerar las causas de posibles fallos. Es muy conveniente leer el dossier sobre kppp que aparece pulsando la tecla help de la ventana de kppp.
<p>
<item>kppp indica "sorry, can't open the modem" (perdón, no puedo abrir el modem)
<p>
Esto significa que kppp no tiene permisos para abrir el dispositivo modem o que se ha seleccionado un dispositivo incorrecto en el cuadro del modem. Comprueba que el dispositivo sea correcto y luego dale el bit setuid a kppp.
<p>
<item>kppp muestra "I can't create a modem lock file" (no puedo crear el fichero de cerradura)
<p>
O bien le das a kppp el bit setuid o das acceso al fichero /var/lock a los usuarios normales 	
<p>
<item>kppp sólo espera (Expecting OK)
<p>
- ¿Has jugado con la configuración de CR/LF?   &nl  
- El modem quizá necesita más tiempo para inicializarse. Ve al cuadro "Modem commands" y aumenta el "Init Delay Time".  
<p>
<item>La conexión funciona, pero no se pueden arrancar aplicaciones
<p>
Puede ser que esté activada la opción "Auto configure hostname" y el servidor X tiene problemas para conectar con tu nuevo servidor. Si no hay más remedio que usar dicha opción, tendrás que proporcionar los permisos adecuados tecleando xhost + antes de realizar la conexión. Pero ¡MUCHO CUIDADO! porque cualquier otra persona tendrá acceso a tu servidor de X.
<p>
<item>kppp funciona, pero Netscape indica que "There is not a DNS entry for this server" (El servidor no tiene una entrada DNS)
<p>
Intenta hacer un ping al número IP de otro servidor. Si funciona entonces hay que comprobar si le diste al kppp al menos una dirección DNS o si en el fichero <tt>/etc/host.conf</tt> hay una línea indicando algo parecido a <tt>order hosts, bind</tt>. (Debe haberla para que se consulte al servidor de nombres cuando se busca una dirección)
</itemize>


<!-- ********************************************************* -->
<!-- SUBSECCIÓN MI MODEM CUELGA DURANTE LA NEGOCIACIÓN INICIAL -->
<!-- ********************************************************* -->

<sect1>Mi modem cuelga durante la negociación inicial.
<p>
La negociación se puede distinguir por ser la fase en la que suenan
los modems. Si cuelga bruscamente puede ser debido a un TIMEOUT demasiado
corto en el script de marcado. Se puede subir a TIMEOUT 100 o a TIMEOUT 150. 
En caso de seguir colgando, se puede intentar añadir <tt>S7=100</tt> o <tt>S7=150</tt> entre
el <tt/AT/ y el <tt/DTnumero_de_telefono/ en el script de marcado.


<!-- ******************************************* -->
<!-- SUBSECCIÓN MI MODEM SUENA MUY FUERTE        -->
<!-- ******************************************* -->

<sect1>Mi modem suena muy fuerte ¿Cómo le bajo el volumen?
<p>
Depende de lo que quieras. Si simplemente quieres bajar el volumen del
modem, basta añadir L1 o L0 a la cadena de inicialización del modem. 
Un posible sitio para colocarlo seria entre el "AT" y el 
<tt/DTnumero_de_telefono/ en el script de marcado.
<p>
Si lo que quieres es que no suene para nada (por ejemplo, si quieres
automatizar la conexión para que se realice de madrugada) deberás añadir
M0 a la cadena de inicialización del modem. Puedes colocarla en el mismo
sitio que se indicó para L1 o L0.


<!-- *************************************************** -->
<!-- SUBSECCIÓN CONECTO A INTERNET PERO NO LOGRO NAVEGAR -->
<!-- *************************************************** -->

<sect1>Conecto a internet, pero no logro ir a ningún sitio.
<p>
Lo primero que hay que tener en cuenta es que no hay conexión hasta
que no aparece por <tt>/var/log/messages</tt> lo de <tt>Local IP Address xxx.xxx.xxx.xxx</tt>
y <tt>Remote IP Address yyy.yyy.yyy.yyy</tt> (o el bloque <tt/ppp0/ al escribir <tt/ifconfig/.
Esto viene al caso de que a veces la autentificación inicial falla, por ejemplo 
porque haya caído el proveedor o esté saturado. En esos casos Infovia Plus no 
corta la conexión y puede parecer que el modem está conectado a internet cuando 
en realidad ni siquiera ha llegado a contactar con el proveedor. En ese caso 
habría que revisar las claves de acceso que se hubiesen introducido en 
<tt/pap-secrets/ o <tt/chap-secrets/ o intentarlo más tarde.
<p>
En caso de aparecer <tt/Local IP Address.../ y <tt/Remote IP Address.../ en
<tt>/var/log/messages</tt>, pero no conseguir conectar a ningún sitio habría que
revisar en primer lugar <tt>/etc/resolv.conf</tt> y ver si las direcciones allí
introducidas son correctas. Una forma de averiguar si es culpa de los DNS 
es probar a conectar usando una dirección numérica. Por ejemplo se puede 
probar con la dirección 130.206.1.2 que corresponde a www.rediris.es . Si 
conecta, es un problema en <tt>/etc/resolv.conf</tt> (o del DNS de tu proveedor).
<p>
Si se descarta el DNS, comprueba que tienes la opción <em/defaultroute/
en <tt>/etc/ppp/options</tt>. En caso afirmativo, comprueba <tt>/var/log/messages</tt>
y mira si aparece algún mensaje tipo <tt>ppp not replacing existing default 
route to ...</tt>. Este último caso es típico si se tiene alguna tarjeta de red
y has definido alguna dirección de gateway. Lo normal es eliminar dicho
gateway. Averigua como introduciste el gateway y elimínalo. Una forma
de eliminarlo sería por ejemplo con linuxconf, que viene con Red-Hat.


<!-- ******************************************* -->
<!-- SUBSECCIÓN UNSUPPORTED PROTOCOL 0x31        -->
<!-- ******************************************* -->

<sect1>¿Qué significa eso de "Unsupported protocol 0x31"?
<p>
Es un mensaje que aparece en <tt>/var/log/messages</tt> típico de Infovia Plus
y debido a un protocolo de red llamado IPX. No debe suponer ningún problema
para la conexión, pero si resultara molesto se podría añadir la opción
<em/noipx/ a <tt>/etc/ppp/options</tt>.

<!-- ******************************************* -->
<!-- SUBSECCIÓN MI MODEM NO CUELGA               -->
<!-- ******************************************* -->

<sect1>Mi modem no cuelga ¿Qué hago?
<p>
Asegúrate de que tienes (si usas pppd) la opción <em/modem/ en <tt>/etc/ppp/options</tt>.

En caso de que la tuvieras, comprueba que has puesto una cadena de 
inicialización al modem en el script de marcado (por ejemplo at&amp f, atz...). 
<p>
En caso de que así siguiese sin colgar, tendrás que echar mano del manual 
del modem y buscar el comando "que haga que el modem cuelgue (o se resetee) 
cuando cambie la línea DTR". Normalmente es &amp Dx donde 'x' es un numero 
(que es lo que deberás buscar en el manual del modem, si prefieres 
prueba-y-error 'x' normalmente estará entre 0 y 4). Luego deberás
editar el script de marcado del modem y colocar dicho "&amp Dx" entre el "AT"
y el "DTnumero_de_telefono". Al usar el caracter '&', no olvides poner todo 
el conjunto (desde el AT hasta el final del número de teléfono) entre comillas 
dobles (p.e.: "AT&amp D3DT055").


<!-- ********************************************* -->
<!-- SUBSECCIÓN INTERNET ME VA MAS LENTO CON LINUX -->
<!-- ********************************************* -->

<sect1>Internet me va mucho mas lento con Linux que con Windows.
<p>
Esto puede deberse a muchas causas:
<p>
Deberás verificar la configuración del modem y del puerto serie. Sigue
la descripción que se da en la sección correspondiente de la FAQ.
<p>
Comprueba que la velocidad que has puesto en <tt>/etc/ppp/options</tt> NO es
la velocidad del modem (nada de 28800, 33600 o lo que sea, no es eso lo que 
debes poner ahí). Pon 115200 o 57600, preferiblemente la primera. Si tienes 
una UART 16450 u 8250 pon 38400 y asegúrate de NO poner el flag 'spd_hi' o 
'spd_vhi' con setserial (si has seguido las instrucciones de la FAQ desde 
el principio no hace falta que compruebes esto). El tipo de UART que tienes 
lo podrás ver haciendo <tt>setserial /dev/ttySx</tt> donde 'x' es 0 para COM1, 
1 para COM2, etc...

Si sigue lento o conectando mal, asegúrate de poner una cadena de 
inicialización al modem ("at&amp f", "atz") y que la opción <em/crtscts/ aparece
en <tt>/etc/ppp/options</tt>. En caso de continuar los problemas deberás echar 
mano del manual del modem y buscar las opciones que "activen el control de 
flujo RTS/CTS". Suelen ser de la familia de las que empiezan por '&'. En 
algunos modems es una sola orden (por ejemplo "&amp K3") y en otros hay que 
activar el RTS y el CTS separadamente. Colocar el o los comandos entre el "AT" 
y el "DTnumero_de_telefono". Si usas el caracter '&', asegúrate de poner todo 
el conjunto (desde el AT hasta el final del número de teléfono) entre comillas 
dobles (p.e. "AT&amp K3DT055").


<!-- ******************************************* -->
<!-- SUBSECCIÓN  TENGO MAS DE UN PROVEEDOR       -->
<!-- ******************************************* -->

<sect1>Tengo más de un proveedor de internet ¿Qué hago para poder elegir por cual me conecto?
<p>
Una posible forma sería eliminar de <tt>/etc/ppp/options</tt> la opción
<em/name mi_login@mi_proveedor/. De esta forma, si hemos puesto en <tt>pap-secrets</tt>
o <tt>chap-secrets</tt>, el login y el password de todos nuestros proveedores,
bastaría con escribir <tt>pppd name login@proveedor</tt> para elegir a cual
nos queremos conectar.
<p>
Esto funciona si todos los proveedores comparten el mismo número de
teléfono (por ejemplo, si todos están en infovía plus). En caso de
tener diferentes números de teléfono, habría que eliminar en 
<tt>connect "/usr/sbin/chat -v -f /etc/ppp/marcado"</tt> de <tt>/etc/ppp/options</tt>,
crearse un fichero de marcado particular para cada proveedor y crearse
un fichero para cada proveedor en <tt>/etc/ppp</tt> con las dos opciones personalizadas
que le correspondan. O sea:
<verb>
  /etc/ppp/nombre_del_proveedor:

  ------------------------------------------------------------
  connect "/usr/sbin/chat -v -f /etc/ppp/marcado_proveedor"
  name login@proveedor
  ------------------------------------------------------------
</verb>
Y ejecutar pppd así:
<verb>
  /usr/sbin/pppd file /etc/ppp/nombre_del_proveedor
</verb>
Las DNS de todos los proveedores se podrían poner en <tt>/etc/resolv.conf</tt>,
añadiendo nuevas líneas "nameserver xxx.xxx.xxx.xxx". Es conveniente
ordenar los nameservers poniendo primero todos los DNS primarios de todos
los proveedores y después los DNS secundarios. También conviene poner en
primer lugar los correspondientes a los proveedores más usados.

<!-- ******************************************* -->
<!-- SUBSECCIÓN  SOLO PUEDO CONECTAR COMO ROOT   -->
<!-- ******************************************* -->

<sect1>Solo puedo usar internet como root. ¿Qué hago para poder hacerlo como usuario?
<p>
Hay dos formas de hacerlo. La forma "buena", sería usando el programa <tt/sudo/
el cual permite ejecutar como usuario algunos programas que sólo podrían
funcionar como root. Esto supondría que cada vez que uno quisiera conectarse
a internet debería introducir un password, lo cual es útil en caso de que
otros tuvieran acceso a nuestro ordenador. Para lo configuración de sudo
consultar <tt/man sudo/.
<p>
La forma "mala", y digo mala porque es más insegura en caso de que otros
tengan acceso a nuestra máquina, consistiría en poner pppd "suid root"
lo cual posibilita que un usuario normal tuviera acceso al programa de
una forma similar que root.
<p>
Para esto último, habría que empezar por localizar <tt/pppd/. Suele estar en el
directorio <tt>/usr/sbin</tt>. Luego haría falta echar un vistazo para ver que permisos
tiene. Esto se hace con la orden <tt>ls -l pppd</tt> y debe arrojar algo parecido
a esto.
<verb>
  -rws--x--x   1 root	ppp	70336	May 18	1996 pppd
</verb>
Lo que se persigue es que la tercera letra sea una 's', como en el ejemplo.
Si el programa no está "suid root", la tercera letra será una 'x'. Entonces
en este caso habría que hacer <tt/chmod 4711 pppd/ para conseguirlo.

Los scripts de <tt>/etc/ppp</tt> necesitarían también acceso libre para los usuarios
así que habría que hacer <tt>chmod 755 /etc/ppp</tt> y <tt>chmod a+r /etc/ppp/*</tt>. El
efecto secundario que esto tiene es que cualquier usuario del sistema puede
leer las claves de acceso a nuestro proveedor de internet. Existe la 
posibilidad de limitar la conexión a internet (y a los scripts de conexión
y claves de acceso), leer la sección <ref id="permisos" name="¿Cómo se cambian los permisos de ficheros y directorios? ">
<p>
<bf/NOTA/: Aún así, es posible que no seamos capaces de conectar con internet 
como usuario normal. Una posible causa de fallo sería intentar conectar 
a internet escribiendo <tt/pppd/ en vez de <tt>/usr/sbin/pppd</tt>. Para root funciona
la primera, pero para el resto de usuarios no. El motivo es que el PATH 
(el conjunto de directorios en los que Linux busca un ejecutable) es 
diferente para root que para los usuarios normales. Los usuarios normales 
no tienen <tt>/usr/sbin</tt> dentro del PATH así que deberán hacer <tt>/usr/sbin/pppd</tt> 
para conectarse a internet o hacer un enlace simbólico a <tt>/usr/sbin/pppd</tt> 
desde otro directorio que sí esté en el PATH de usuario (como por ejemplo 
<tt>/usr/bin</tt>), o hacernos un script (pequeño programa) que se limite a ejecutar 
<tt>/usr/sbin/pppd</tt>. Para el enlace simbólico bastaría hacer:
<tt>ln -s /usr/sbin/pppd /usr/bin/pppd</tt>

<!-- ***************************** -->
<!-- ***************************** -->
<!--     SECCIÓN RSDI CON LINUX    -->
<!-- ***************************** -->
<!-- ***************************** -->

<sect>Internet / RSDI
<p>

<!-- ****************************** -->
<!--  SUBSECCIÓN RSDI INTRODUCCION  -->
<!-- ****************************** -->

<sect1>Introducción a RSDI
<p>

Esta sección pretende dar algunos detalles de como utilizar ciertas tarjetas RSDI con el sistema operativo Linux.
En concreto se centrará en aquellas tarjetas que estén soportadas con el driver HiSax, del paquete isdn4linux.
Los ejemplos concretos usados a lo largo del documento harán referencia a una tarjeta Elsa QuickStep 1000 y a
un sistema Debian GNU/Linux 2.0, ya que ésta es la configuración que posee el autor. Sin embargo el uso de
cualquier otra tarjeta de las gestionadas con el driver HiSax o de otra distribución debería plantear cambios
mínimos en los ejemplos. 
<p>
Se ha añadido una nueva subsección al documento que indica como conectarse a Infovia+ con Linux y RDSI, ya que a
Telefónica le ha dado por cambiar el protocolo de conexión de bajo nivel, sin consultar a nadie. Bueno, en realidad
simplemente ha eliminado el antiguo sistema de conexion, ya que en la Infovia tradicional funcionaban tanto el
método antiguo como el nuevo, necesario ahora por imperativo legal. 
<p>
Los pasos que se indican aquí sirven para usar la tarjeta RDSI de dos formas diferentes: 

<itemize>
<item>Emulando un módem analógico tradicional, de forma que podamos usar el demonio pppd 
habitual y los scripts de conexión tradicionales. 

<item>Emulando una interfaz de red, para lo cual hay que usar las idsnutils y el 
demonio ipppd (observe la diferencia en el nombre) que permite usar PPP síncrono. 
Este modo de funcionamiento es necesario para usar Infovia+ con Linux, y los scripts
de conexion son bastante diferentes. 
</itemize>

Aun cuando la segunda forma de trabajar está descrita en el RDSI-COMO de 
<url url="http://lucas.hispalinux.es/" name="LUCAS">, hay algunos usuarios 
que están teniendo problemas para ponerla en marcha. Voy a tratar de plasmar 
en esta página como he realizado yo la configuración en mi instalación de 
Debian 2.0 con un núcleo 2.0.36. 
<p>

<!-- ******************************************** -->
<!--  SUBSECCIÓN RSDI CONFIGURACION DEL HARDWARE  -->
<!-- ******************************************** -->

<sect1>Configuración del hardware.
<p>
Como paso previo a cualquiera de los dos modos de funcionamiento, 
es requisito indispensable que el núcleo reconozca nuestra tarjeta RDSI 
y nos deje usarla. De esto se encargan varios componentes del núcleo que 
será necesario compilar. Para ello, recomiendo usar un núcleo de linux igual 
o posterior al 2.0.36. De esta forma el driver de HiSax más reciente ya viene 
incorporado en el núcleo y no hay que conseguirlo aparte y parchear el mismo. 
<p>
<bf>Pasos a seguir para la compilación del soporte de la tarjeta en el núcleo</bf>
<p>
Una vez que dispongamos de las fuentes del núcleo tenemos que realizar 
las siguiente operaciones: 
<itemize>
<item>Compilar el núcleo de Linux que hemos obtenido en el punto anterior 
(puede ver las intrucciones necesarias para compilarlo en <tt>/usr/src/linux/README</tt> 
una vez que lo haya descomprimido en <tt>/usr/src</tt>). 
<p>
<bf>Nota:</bf>En el núcleo, para 
referirse a RDSI se utilizan las siglas ISDN (Integrated Services Digital Network). 

<item>A la hora de especificar las características que queremos incluir en 
el núcleo, debemos seleccionar por lo menos las siguientes (los nombres que 
aparecen en la lista corresponden a las etiquetas mostradas al ejecutar 
<tt>make config</tt> con un núcleo de la serie 2.0.x, los comentarios del autor 
aparecen entre paréntesis).
<verb>
   CONFIG_EXPERIMENTAL=y 
   (Necesario para que nos pregunte todas las opciones) 

   CONFIG_MODULES=y 
   (El driver HiSax es obligatorio usarlo como módulo, así que...) 

   CONFIG_NET=y 
   (Para que podamos usar servicios de red) 

   CONFIG_SYSVIPC=y 
   (Necesario para usar kerneld) 

   CONFIG_KERNELD=y 
   (Kerneld se encarga de cargar los módulos automáticamente...) 

   CONFIG_INET=y 
   (Soporte para TCP/IP)
 
   CONFIG_NETDEVICES=y 
   (Dipositivos de red) 

   CONFIG_PPP=m 
   (Soporte para PPP, yo prefiero cargarlo como módulo, pero puede 
   ser compilado en estático respondiento "Y" en vez de "M"). 

   CONFIG_ISDN=m 
   (Soporte para RDSI en módulo) 

   CONFIG_ISDN_PPP=y 
   (OPCIONAL: compilar si vamos a usar PPP sincrono, 
   p.ej. con Infovia+) 

   CONFIG_ISDN_DRV_HISAX=m 
   (Soporte para el driver HiSax) 
   
   CONFIG_HISAX_EURO=y 
   (Importante, usamos protocolo Euro-DSS1 o Euro-ISDN) 

   CONFIG_HISAX_ELSA=y 
   (Soporte para la Elsa QuickStep 1000)
 
   CONFIG_PROC_FS=y 
   (Para diagnósticos e informacion del sistema en general) 
</verb>

<item>Una vez se han indicado las opciones imprescindibles (más el resto de ellas 
necesarias para el sistema de cada uno), compilamos el núcleo y hacemos los pasos 
necesarios para poder arrancar con el núcleo recién compilado.

<item>Ahora podemos arrancar con el nuevo núcleo. Hay que reinicializar 
la máquina para que los cambios surjan efecto. Todo debería ir como antes 
(si hemos compilado todo lo que teníamos antes más el soporte para PPP y RDSI). 

<item>Podemos usar el comando dmesg para ver los mensajes de arranque 
del núcleo. No debería haber nada raro (ya que el soporte para RDSI se 
carga como módulo cuando es necesario y todavía no hemos intentado usarlo). 

</itemize>
<p>
<bf>Pasos necesarios para la configuración de la tarjeta</bf>
<itemize>

<item>Si la tarjeta no es Plug&amp Play, sera necesario editar el fichero 
<tt>/etc/lilo.conf</tt> (si usted usa lilo) para indicarle al núcleo los 
valores de irq, e/s y otros detalles. Vea los ficheros de 
<tt>/usr/src/linux/Documentation/isdn/</tt> para los detalles concretos 
de cada tarjeta. 

<item>Si la tarjeta RDSI es Plug&amp Play (caso de la Elsa QuickStep1000) 
es necesario configurar el hardware antes de poder usarla. Para ello 
necesitamos la ayuda de dos herramientas: pnpdump e isapnp. 
Los pasos a seguir son: 
<p>
Ejecutar: <tt>pnpdump> /tmp/isapnp.conf</tt>
<p>
Esto creará un fichero con un contenido similar al siguiente 
(suponiendo que ésta sea la única tarjeta Plug&amp Play del sistema; 
si hubiera otras el fichero contendría más líneas). Hay que editar 
el fichero obtenido eliminando los comentarios de las líneas con la 
configuración deseada, para obtener algo similar a lo que aparece aquí. 
Para más detalles, consulte la documentación de <tt>isapnp</tt> y <tt>pnpdump</tt>. 
<verb>
   # Trying port address 0203
   # Board 1 has serial identifier 2a 00 00 00 00 33 01 93 15
   #(DEBUG)
   (READPORT 0x0203)
   (ISOLATE)
   (IDENTIFY *)

   # Card 1: (serial identifier 2a 00 00 00 00 33 01 93 15)
   # ELS0133 Serial No 0 [checksum 2a]
   # Version 1.0, Vendor version 0.0
   # ANSI string -->ELSA QuickStep 1000<--
   #
   (CONFIGURE ELS0133/0 (LD 0
   (IO 0 (BASE 0x0160))     <--- Indicar aquí la dirección de E/S.
   (INT 0 (IRQ 15 (MODE +E))) <--- Indicar aquí la IRQ a usar
   (ACT Y)
   ))
   # End tag... Checksum 0x00 (OK)
</verb>
Ejecutar: <tt>isapnp /tmp/isapnp.conf</tt>
<p>
Esto configurará la tarjeta Plug and Play. 

<item>Si no ha habido ningún error, ahora puede copiar el fichero 
<tt>/tmp/isapnp.conf</tt> a <tt>/etc/isapnp.conf</tt>. Si ha instalado 
correctamente las pnptools las próximas veces que arranque el sistema, 
la configuración de la(s) tarjeta(s) PNP será automática. 

<item>A la hora de elegir las direcciones de E/S e IRQ a usar, 
puede ver cuales están ya ocupadas haciendo: 
<verb>
   cat /proc/ioports
   cat /proc/interrupts 
</verb>

<item>Ya tenemos la mitad del camino hecho. Tenemos la tarjeta lista 
para ser usada y tenemos compilado el soporte para RDSI en el núcleo. 
Ahora sólo falta unir las dos cosas. Para ello vamos a indicar al núcleo 
que queremos usar el driver HiSax. Si al cargar el módulo éste detecta la 
tarjeta ya tenemos la batalla casi ganada. Sino, habrá que repasar los puntos 
anteriores para ver si hemos compilado el soporte adecuado o si las direcciones 
de E/S, IRQ u otras están siendo ya usadas por otros dispositivos. 

<item>Para cargar el módulo de la tarjeta RDSI en el núcleo hacemos: 
<verb>
   modprobe hisax type=7 io=0x160 irq=15 protocol=2 id=qs1000
</verb>
Para ver cuáles son los números mágicos a usar en el comando anterior 
tiene que leer el fichero <tt>/usr/src/linux/Documentation/isdn/README.HiSax</tt>. 
En concreto, en la línea anterior le indicamos que queremos usar una tarjeta 
Elsa QuickStep 1000 (type=7), cuya dirección de E/S es la 0x160 (la misma que 
en el fichero <tt>/etc/isapnp.conf</tt>), que la interrupción a usar es la 15 (como se 
indica en <tt>/etc/isapnp.conf</tt>) y que el tipo de protocolo a usar es EURO-DSS1, que 
es el usado en España. El último valor es sólo un identificativo asignado a esta 
tarjeta (ya que existe la posibilidad de usar varias simultáneamente). 

<item>Si nos dice que el driver ha sido cargado y la tarjeta detectada, ¡ya está casi 
todo listo! (si no apareciera nada en pantalla, puede usar el comando dmesg para ver 
los mensajes del núcleo)

<item>Si le parece demasiado pesado tener que teclear todo esto cada vez que 
quiera usar la tarjeta RDSI, tiene razón. Lo que puede hacer es añadir las 
siguientes líneas al fichero <tt>/etc/conf.modules</tt>: 
<verb>
   # 01.02.1999 Ignacio Arenaza. Añada las siguientes líneas para que 
   # el módulo de la tarjeta RDSI se cargue automáticamente bajo demanda.
   alias char-major-43 hisax
   alias char-major-45 isdn
   options hisax type=7 io=0x160 irq=15 protocol=2 id=qs1000
</verb>
Por supuesto debe cambiar los parámetros type, io, irq, protocol e id 
para que se ajusten a su configuración. 
<p>
Además, si quiere que el módulo se cargue en el núcleo de forma automática, 
deberá compilar el soporte de kerneld en el núcleo y editar el fichero <tt>/etc/modules</tt> 
e incluir la palabra auto justo despues de las líneas de comentarios 
(en caso de que esté usando Debian GNU/Linux). 

</itemize>

<!-- ****************************************************** -->
<!--  SUBSECCIÓN METODO DE EMULACION DE MODEM ANALOGICO     -->
<!-- ****************************************************** -->

<sect1>El método de emulación de módem analógico (PPP asíncrono)
<p>
Para usar la tarjeta RDSI emulando un módem analógico convencional 
necesitaremos un demonio pppd reciente (el que venga con su distribución 
valdrá seguramente). También será de gran ayuda el documento "eng-i4l-faq", 
disponible en <url url="http://www.isdn4linux.de/" name="http://www.isdn4linux.de/">). 
Hay sendas versiones en alemán e inglés.
<p>
En este momento ya está disponible la tarjeta RDSI para su uso. 
Para ello, en los scripts de configuración de pppd tenemos que realizar 
un par de cambios o tres. Estos son: 
<itemize>
<item>En lugar de usar el dispositivo <tt>/dev/ttyS0</tt>, <tt>/dev/ttyS1</tt>, ... 
que representan los puertos serie donde suelen estar conectados los módems 
convencionales, usaremos el dispositivo <tt>/dev/ttyI0</tt> 
                             
<item>En el script de conexión de chat, es necesario añadir un par de 
comandos AT para inicializar el valor del MSN/EAZ (ver eng-i4l-faq para detalles) 
así como el protocolo de nivel 2 usado para la conexión 
(cuyo valor por defecto es incorrecto). 

<item>También es conveniente indicar el tamaño máximo del 
bloque de tranmisión, para no desbordar los buffers de la tarjeta. 
</itemize>

A continuación adjunto una copia de mis ficheros <tt>/etc/ppp/peers/provider</tt> 
(fichero de configuración de pppd en Debian GNU/Linux 2.0) y <tt>/etc/chatscripts/provider</tt> 
(fichero de conexión de chat en Debian GNU/Linux 2.0). 

-------------------------------- &nl 
Fichero: /etc/ppp/peers/provider &nl  
Permisos: chmod 640 &nl 
Propietario: root &nl 
Grupo: dip &nl 
--------------------------------
<verb>                              
   connect "/usr/sbin/chat -v -f /etc/chatscripts/provider" 
   passive 
   user inaki.arenaza@jet 
   noipdefault 
   debug 
   defaultroute 
   asyncmap 00000 
   mtu 576 
   mru 576 
   /dev/ttyI0 
   115200 
   :172.16.1.96 
   ipcp-accept-local 
   ipcp-accept-remote 
</verb>
<p>
------------------------------------- &nl 
Fichero: /etc/chatscripts/provider &nl 
Permisos: chmod 640 &nl 
Propietario: root &nl 
Grupo: dip &nl 

Nota: Lo que aparece entre paréntesis &nl 
son comentarios que no deben incluirse  &nl 
en el fichero real. &nl 
--------------------------------------
<verb>                                     
   "" "ATS14=3" (usar HDLC como protocolo de nivel 2) 
   "" "AT&amp B2000" (Tamaño máximo del bloque de transmisión) 
   "" "AT&amp E900123456" (MSN/EAZ = número de teléfono propio 
                       incluyendo prefijo). 
   ABORT BUSY 
   ABORT "NO CARRIER" 
   ABORT VOICE 
   ABORT "NO DIALTONE" 
   "" ATD055 
   CONNECT "" 
</verb>
<p>

------------------------------------- &nl 
Fichero: /etc/ppp/pap-secrets &nl 
Permisos: chmod 600 &nl 
Propietario: root &nl 
Grupo: root &nl 
-------------------------------------
<verb>
   inaki.arenaza@jet    *     mi_contraseña  
</verb>

Entre el nombre del usuario, el asterisco y la contraseña debe 
haber un tabulador (ojo, no usar espacios en blanco). 
<p>
En este momento debe asegurarse de que tiene creados los ficheros de 
dispositvo <tt>/dev/ttyI0</tt>, <tt>/dev/ttyI1</tt>, etc. Si no es así, 
puede crearlos con el comando <tt>MAKEDEV</tt> que se haya en el directorio 
<tt>/dev</tt>, o a mano con el comando <tt>mknod</tt>. Si usa <tt>MAKEDEV</tt> 
(al menos la versión de Debian GNU/Linux), basta con que ejecute lo 
siguiente en el directorio <tt>/dev</tt>: 

<verb>
   ./MAKEDEV isdn-tty
   ./MAKEDEV isdn-io 
</verb>
       
Si ya tiene creados los dispositivos <tt>/dev/ttyI*</tt>, y tiene instalado 
<tt>pppd</tt> y <tt>chat</tt>, ya puede probar su conexión a Internet. 
En concreto, con la configuración de ejemplo de este documento y usando
un sistema Debian GNU/Linux, basta con teclear pon, y se lanzará la 
ejecución del demonio pppd que establecerá la conexión con su proveedor 
a través de Infovía. Puede ver un registro de la conexión en <tt>/var/log/ppp.log</tt> 
(en los sistema Debian GNU/Linux). Si la conexión falla por alguna razón, 
en ese fichero aparecerá el porqué. 
<p>
Ahora ya puede usar su navegador favorito o el lector de correo. 
Para cortar la conexión, basta con ejecutar el comando <tt>poff</tt> 
(en los sistemas Debian GNU/Linux). 


<!-- ********************************* -->
<!--  SUBSECCIÓN INFOVIA+ PPP SINCRONO -->
<!-- ********************************* -->

<sect1>Infovia+ (PPP síncrono)
<p>
Todo lo explicado en las anteriores subsecciones está muy bien, pero .... 
¡¡ya no sirve para Infovia+!!. Por alguna razón que al común de los mortales 
se nos escapa, Telefónica ha decidido eliminar de un plumazo el soporte de 
PPP asíncrono en la nueva Infovia+. Así que la mayoría de los usuarios de 
RDSI con Linux nos hemos visto forzados a cambiar toda la configuración 
del subsistema RDSI para poder usar el protocolo estrella de Infovia+: el PPP síncrono. 
<p>
<bf>Qué nos hace falta</bf>
<p>
Para poder usar el PPP síncrono con Linux es necesario:
<itemize>
<item>Haber compilado el soporte para PPP síncrono en el núcleo como se 
indica al comienzo de este documento. 

<item>Disponer del paquete isdnutils, presente en la mayoría de las distribuciones 
de Linux. No obstante, si usted ha actualizado su núcleo a una versión posterior a 
la que venía con su distribución, mi recomendación (obligación en el caso de usar 2.0.36 o posterior) 
es que se pase por <url url="ftp://ftp.franken.de/pub/isdn4linux/" name="ftp://ftp.franken.de/pub/isdn4linux/"> 
y que obtenga la última versión disponible del paquete isdnutils para el 
tipo de núcleo que esté usando actualmente. Los ultimos nucleos de la serie 2.2.x 
ya vienen con este paquete incluido en las fuentes del nucleo.

</itemize>

<bf>Compilación del paquete isdn4k-utils</bf>
<p>
<itemize>
<item>Obtener una copia del fichero isdn4k-utils-3.0beta2.tar.gz de la URL citada arriba. 
Descomprimirlo en <tt>/usr/src</tt> y leer el fichero README. 
                                
<item>Ejecutar <tt>make config</tt>. 
           
<item>Aparece un sistema de configuración similar al que aparece cuando configuramos 
el núcleo con la opción <tt>make menuconfig</tt>. Las únicas modificaciones que 
yo realizo a los valores por defecto son:  En la opción "General Configurations", 
dar el valor "/usr/sbin" al campo "Directory to install admin binaries".
 
<item>Guardar la configuración y salir del programa de configuración. 
Tras unos minutos en los que la utilidad <tt>autoconf</tt> de GNU hace de las 
suyas, volvemos al prompt del sistema. 

<item>Ahora ejecutar <tt>make</tt>. Comienza la compilación de todas las 
utilidades que hayamos configurado. Paciencia, se toma su tiempo.
</itemize>

<bf>Instalación y configuración de isdn4k-utils</bf>
<p>
Las operaciones anteriores podían hacerse como un usuario normal. 
Sin embargo, los pasos a realiza a partir de ahora deben hacerse como usuario root. 

<itemize>
<item>Instalar el paquete isdnutils que viene con mi distribución (Debian GNU/Linux) 
para tener todos los ficheros de configuración en su sitio y con el formato que le gusta mi distribución.

<item>Ejecutar <tt>make install</tt> para instalar las isdnutils que acaba de compilar. 
                                
<item>Ejecutar la utilidad <tt>isdnconfig</tt>. Esta utilidad es específica de Debian GNU/Linux 
y sirve para configurar más fácilmente todo el subsistema de RDSI con PPP síncrono. 
Para ver si existe una utilidad similar en su distribución, consulte la documentación 
que acompaña al paquete isdnutils que viene con su distribución. Sino, siempre puede cambiarse a Debian ;-) 
                                
<item>Los pasos a realiza con isdnconfig son los siguientes: 


Aparecerá la siguiente pantalla, que es la pantalla principal. 
<verb>
   Isdnutils configuration
   =======================

   1       network devices
   2       synchronous ppp daemon
   3       modem emulation
   4       isdnlog configuration
   5       voice box configuration

   Q       Quit

   Your choice : 
</verb>

Elegir la opción "1.- network devices". Aparecerá la pantalla: 
<verb>
   Isdnutils configuration network interfaces
   ======================= ------------------

   Searching for existing configuration files...
   Found : NONE

   Devices should be named :
   - rawip interface               isdn0 isdn1 ...
   - synchronous ppp interface     ippp0 ippp1 ... 

   Name for new interface : 
</verb>

Teclear como nombre de la nueva interfaz "ippp0" y pulsar Enter. Pulsar de nuevo Enter para retornar a la pantalla principal.
<p> 
Ahora elegir la opción "2.- synchronous ppp daemon". Aparecerá la pantalla: 
<verb>
   Isdnutils configuration synchronous ppp daemon
   ======================= ----------------------

   Searching for existing configuration files...
   Found : NONE

   Normal setup: one ipppd for all devices: /dev/ippp0 /dev/ippp1

   ll ippp* network interfaces are handled by a
   single ipppd process using a single config
   file.

   Special setup: one ipppd for each device: /dev/ippp0 /dev/ippp1

   Each ippp* network interface is handled by its
   own ipppd process, using a specific config file
   for each.
   You need to use pppbind on each network
   interface to select which /dev/ippp* device
   will be used.

   Usually only a single ippp interface is used (for connecting to an ISP), so the
   above isn't really relevant to most users.

   Name for new configuration (ippp0 ippp1 ...): 
</verb>

Teclear como nombre de la nueva configuración "ippp0" (mismo nombre que el de la interfaz del paso 3) 
y pulsar Enter. Pulsar de nuevo Enter para retornar a la pantalla principal. 
<p>
Si en alguún momento nos interesa usar la tarjeta RDSI como un módem analógico convencional, podemos 
elegir la opción "3.- modem emulation". Se nos informará de que ha instalado el fichero de datos necesario 
para usar iprofd y deberemos pulsar Enter para retornar a la pantalla principal.
<p> 
Ahora elegir la opción "4.- isdnlog configuration". Aparecerá la pantalla: 
<verb>
   Isdnutils configuration isdnlog
   ======================= -------
   Installing example configuration files ...
   /etc/isdn/isdn.conf already exists,preserving original version.
   callerid.conf installed.

   Searching for existing configuration files...
   Found : NONE

   You need one options file per isdn card. This file is named like the device it
   uses to get the data. isdnctrl0 isdnctrl2 ... An exception is if you want to run
   isdnlog in "dual mode"; this means thesecond isdn card is connected "in reverse"
   so that it can monitor _outgoing_ traffic. In that case, only specify one options
   file

   Name of the device: 
</verb>

Teclear como nombre de la nueva configuración "isdnctrl0" y pulsar Enter. 
Pulsar de nuevo Enter para retornar a la pantalla principal. 
</itemize>

Con esto ya hemos creado el esqueleto de los ficheros de configuración. 
Ahora tenemos que editarlos para adaptarlos a nuestras necesidades. 
Todos estos ficheros están situados en el directorio <tt>/etc/isdn</tt>. 
Los ficheros que hay que editar son: 
<verb>
   /etc/isdn/callerid.conf 
   /etc/isdn/device.ippp0 
   /etc/isdn/ipppd.ippp0 
   /etc/isdn/isdn.conf 
   /etc/isdn/isdnlog.isdnctrl0 
</verb>

Le recomiendo que lea con atención los comentarios de los ficheros para saber 
para que sirve cada uno de ellos. Un detalle muy importante a la hora de editar 
estos ficheros es que hay que eliminar (no vale con que sean comentarios) las líneas que dicen: 

<verb>
   # REMOVE the next line once configuration is complete ####################
   echo "Warning! $0 not configured yet! Aborting..."; exit 1
   # REMOVE the above line once configuration is complete ###################
</verb>

de todos los ficheros en los que aparezcan, ya que de lo contario las funciones 
de configuración del sistema RDSI suponen que sus ficheros siguen sin configurar 
y no activan ni la interfaz RDSI ni el resto de los servicios RDSI. 
<p>
No use el fichero <tt>device.ippp0</tt> tal cual. Debe editarlo y cambiar los valores de 
LOCALMSN por su número de teléfono y REMOTEMSN por el número de teléfono del nodo de Infovia+ que use. 
<p>
Por último, necesita el fichero de inicio de todas las utilidades para que todo quede 
correctamente configurado en cada arranque del sistema. El fichero que se encarga de 
todo esto en Debian GNU/Linux es <tt>/etc/init.d/isdnutils</tt>. En Redhat deberia de estar
en <tt>/etc/rc.d/init.d/</tt>
<p>

<bf>Puesta en marcha (por fín ;-)</bf>
<p>
Ya tenemos todo listo. Ahora llega el momento de comprobar que todo este montaje funciona. 
<p>
Antes de indicar como hacer para activar y desactivar la conexión a Infovia+, 
le recuerdo que Infovia+ solicita por defecto la autentificación por medio de CHAP, 
así que le recomiendo que edite su fichero <tt>/etc/ppp/chap-secrets</tt> y añada allí sus credenciales. 
<p>
Para activar la conexión debemos ejecutar el comando: 
<verb>
   /usr/sbin/isdnctrl dial ippp0 
</verb>

Esto hará que la tarjeta marque el número indicado en REMOTEMSN 
(en el fichero <tt>/etc/isdn/device.ippp0</tt>) y que comience todo 
el proceso de conexión y negociación del protocolo. 
<p>
Yo personalmente no tecleo este comando cada vez que quiero conectar. 
Me he creado un pequeño script al que llamo ipon (puesto que Debian GNU/Linux 
incluye un script llamado pon usado para conectar con módems analógicos con 
pppd, yo llamo al mío ipon porque usa ipppd). El script está situado en 
<tt>/usr/bin</tt> y sus permisos son: 
<verb>
   -rwxr-xr-x   1 root     root           41 Jan 24 10:58 /usr/bin/ipon 

   Su contenido es: 

   #!/bin/sh
   /usr/sbin/isdnctrl dial ippp0
   /usr/bin/tail -f /var/log/syslog
</verb>

La segunda línea es opcional, y sirve para visualizar el registro de 
eventos del sistema, para ver si todo va correctamente. 
<p>
Ahora puede ejecutar el script y ver si puede hacer unos cuantos pings 
a algunas maquinas de Internet. Si todo ha ido correctamente, ya puede 
usted navegar (o lo que más le guste) por Internet. ¡Enhorabuena! 
<p>
Sino, una atenta revisión de los ficheros de configuración junto con 
los mensajes de error que aparezcan en el registro del sistema deberían 
dar con el error en poco tiempo. 
<p>
Por ultimo, para indicarle al sistema que deseamos cortar la conexión, basta con teclear: 
<verb>
   /usr/sbin/isdnctrl hangup ippp0 
</verb>
De nuevo, yo he creado un script similar al anterior, al que llamo <tt>ipoff</tt>, 
situado en el mismo directorio y con los mismos permisos. Su contenido es: 
<verb>
   #!/bin/sh
   /usr/sbin/isdnctrl hangup ippp0
</verb>

<!-- ***************************** -->
<!-- ***************************** -->
<!--      SECCIÓN  FTP / TELNET    -->
<!-- ***************************** -->
<!-- ***************************** -->

<sect>FTP/Telnet


<!-- ***************************** -->
<!--  SUBSECCIÓN QUE ES FTP        -->
<!-- ***************************** -->

<sect1>¿Qué es el protocolo FTP?
<p>
El Protocolo de Transferencia de Ficheros (File Transfer Protocol o, para abreviar, FTP) es uno de los pilares de Internet
junto con el acceso a páginas Web (http). Durante mucho tiempo ha sido el servicio TCP/IP de Internet más utilizado, debido a
que cualquier distribución Linux (así como en otros Sistemas Operativos) incluye el software necesario, muy fácil de usar y
configurar, y de reducido tamaño.
<p>
Tal y como se comenta en la documentación (man ftp), "el Protocolo de Transferencia de Ficheros (FTP) es un protocolo de
la familia TCP/IP usado para transferir ficheros entre máquinas que ejecutan TCP/IP (aunque hay programas estilo FTP para otros
protocolos). Este protocolo permite transferir ficheros y manipular directorios en máquinas remotas. No está diseñado para permitir
el acceso a otra máquina con el fin de ejecutar programas (para eso tenemos telnet), pero resulta la mejor utilidad para manipulación
de ficheros.".
<p>
Esto quiere decir que una máquina con un servidor de ftp dispone de una estructura de directorios con ficheros y que
además es capaz de permitir a cientos o miles de usuarios la recogida de ficheros o envío de nuevos ficheros al
servidor.
<p>
Cuando hablamos de FTP estamos hablando (para explicarlo de una manera sencilla) de la descarga o subida de ficheros en Internet
entre 2 máquinas, y es lo que permite entrar en ftp.idsoftware.com, por ejemplo, y bajarse la última versión del ejecutable de Quake
II para Linux. También nos permite, por ejemplo, entrar en nuestro directorio privado en nuestro Proveedor de Servicios de Internet
para poner allí nuestra página Web con el fin de que sea accesible desde el exterior. Para hacer esto disponemos de múltiples
posibilidades debido a la disponibilidad de software para ello en Linux, desde ftp hasta ncftp, wget, etc..
<p>
Así pues, no es necesario utilizar el navegador de WWW para descargar programas de direcciones que comienzan por ftp://, ya
que disponemos en nuestro sistema de herramientas mucho más potentes para tales menesteres: los programas de ftp.
Aquí aprenderemos los comandos básicos así como la manera de instalar nuestro propio ftp anónimo para que otros accedan a
nuestros ficheros desde el exterior.


<!-- ***************************** -->
<!--  SUBSECCIÓN COMANDO FTP       -->
<!-- ***************************** -->

<sect1>El comando FTP
<p>
Comenzaremos hablando del programa ftp (lo que muchos habituales de Internet llaman «el típico ftp de toda la vida», conocido en las
Universidades y sencillos terminales en modo texto cuando no se disponía (o no se necesitaba) del entorno gráfico.
<p>
Si se necesita transferir un fichero a otra máquina de una red o recuperarlo desde otra (y la red bien puede ser Internet), lo que
necesitamos es un programa como ftp. Ftp es un programa sencillo y que viene en cualquier distribución de Linux (en el caso del
autor, el paquete instalado es ftp-0.10-2.rpm). Como la mejor manera de aprender es con ejemplos (antes de ver todas las
posibilidades que ofrece) supongamos que un compañero nos comenta que es posible obtener la última version de Netscape Communicator
en el ftp de la dirección ftp://ftp.juan.es/pub/programas. Sería muy sencillo introducir esta URL (dirección de recurso de Internet)
en Netscape Navigator para que éste nos haga de cliente de FTP, pero supongamos que no estamos dentro de XWindow (o que no nos apetece
arrancar el navegador, o incluso que nos apetece bajarnos este fichero en varias sesiones, tal y como hacen GetRight y NetVampire
para Windows, y que podremos hacer con ftp). Para conseguir nuestro objetivo hacemos:
<verb>
  [root@localhost sromero]# ftp ftp://ftp.juan.es
  Connected to ftp.juan.es.
  220 Juan FTP server (Version wu-2-41) ready.
  Name (ftp.juan.es:sromero):_
</verb>
En ese momento el programa habrá accedido a la máquina remota, quien nos está pidiendo que nos identifiquemos (Name) con nuestro
nombre de usuario (también podríamos haber entrado con ftp y abrir el servidor con open ftp.juan.es). Si no somos usuarios habituales
de dicha máquina (no poseemos ninguna cuenta especial en la misma), tendremos que identificarnos como anonimo (anonymous) y como
password o palabra clave dar nuestra dirección de correo electrónico, proceso conocido como login o ftp anónimo, y que nos
permitirá entrar en la máquina remota si ésta tiene permitido el acceso anónimo. Así pues contestamos:
<verb>
  Name (ftp.juan.es:sromero) anonymous
  331 Guest login ok, send your complete e-mail address as password.
  Password:  sromero@unix-shells.com
</verb>
 Con lo que la máquina remota nos dará acceso a su sistema de ficheros ftp.
<verb>
  230- ¡Bienvenido al servidor FTP de Juanito!
  230 Guest login ok, access restrictions apply.
  Remote system type is UNIX.
  Using binary mode to transfer files.
  ftp> _
</verb>
En ese momento nos percatamos de que la terminal de texto se ha quedado en espera de introducción de comandos por nuestra parte.
Ante la pregunta de «¿qué puede hacerse ahora?» surge la respuesta: «estamos en un sistema Unix», con lo que nada nos impide (si están
dentro de aquel sistema) desplazarnos entre los distintos subdirectorios (ls, cd, etc.):
<verb>
  ftp> ls
  200 PORT command successful.
  150 Opening ASCII mode data connection for /bin/ls.
  total 6
  drwxr-xr-x   6 root     root    1024 Jul 17 10:47  .
  drwxr-xr-x   6 root     root    1024 Jul 17 10:47  ..
  drwxr-xr-x   2 root     root    1024 Jul 17 10:47  bin
  drwxr-xr-x   2 root     root    1024 Jul 17 10:47  etc
  drwxr-xr-x   2 root     root    1024 Jul 17 10:47  lib
  drwxr-xr-x   2 root     ftp     1024 Jul 31 09:17  pub
  226 Transfer complete.
</verb>
A la vista de los directorios disponibles, vamos a pub/programas como se nos había especificado.
<verb>
  ftp> cd pub
  250 CWD command successful.
  ftp> cd programas
  250 CWD command successful.
  ftp> ls
  200 PORT command successful.
  150 Opening ASCII mode data connection for /bin/ls.
  total 3
  drwxr-xr-x   6 root     root         1024 Jul 17  09:18   .
  drwxr-xr-x   6 root     root         1024 Jul 17  09:18   ..
  drwxr-xr-x   6 root     root  10221024 Jul 17  09:18  netscape.rpm
</verb>
Es posible hacer uso del comando get para descargar un fichero (o mget para múltiples ficheros), pero antes nótese que uno de los
mensajes que se leyó al hacer el login fue "Using binary mode to transfer files", lo cual nos indica que hay 2 maneras de bajarse
ficheros: los de formato texto y los binarios, y que debemos especificar el modo correcto para bajarse ficheros de cada tipo
(el comando ascii especifica formato ascii mientras que binary especifica formato binario). En este caso no tendremos que teclear
binary pues el sistema ya nos avisa de que por defecto se descargan ficheros en binario, de modo que ejecutamos get para obtener el
fichero:
<verb>
  ftp> get netscape.rpm
</verb>
Con lo que obtendremos el fichero en nuestra máquina tras esperar el tiempo necesario y tras el cual nos avisará el propio programa de ftp.


<!-- *********************************************************** -->
<!--  SUBSECCIÓN COMO BAJARSE FICHEROS EN VARIAS SESSIONES       -->
<!-- *********************************************************** -->

<sect1>Como bajarse ficheros en varias sesiones con FTP
<p>
¿y si cuando llevamos 1 hora de conexión necesitamos apagar el sistema o se corta la conexión? ¿Y si simplemente
queremos bajarnos un fichero de gran tamaño en diferentes sesiones, conectándonos por ejemplo media hora diaria?
<p>
Nada nos impide continuar la descarga de un fichero otro día y desde el punto en que nos quedamos (sin perder ni un sólo bit)
aunque se nos haya cortado la conexión en anteriores intentos. Para hacer esto disponemos del comando reget (con la misma
sintaxis de uso que el comando get), el cual comprobará la existencia de un fichero con el mismo nombre que el que
pretendemos bajarnos en el directorio actual de tal modo que en caso de existir continuará la descarga en el punto
en que se quedo nuestro fichero incompleto, lo cual nos permitirá hacer de una manera muy cómoda y sencilla la descarga
de grandes programas en varias sesiones, algo incluido en un programa con mucho tiempo y experiencia a sus espaldas y
que algunos programas para Windows 95 pretenden vender como una gran novedad (véase GetRight o NetVampire).
<p>
Dicho de una manera sencilla: podemos comenzar a bajarnos un programa con get, cortar la descarga mediante CONTROL+C, salir
del programa de ftp con quit, entrar al día siguiente y continuar con reget, repitiendo el proceso hasta completar la descarga o
download del fichero.
<verb>
  ftp> get netscape.rpm
  (al rato CTRL+C)

  (Otro dia:)
  ftp> reget netscape.rpm
</verb>


<!-- ***************************** -->
<!--  SUBSECCIÓN COMANDOS FTP      -->
<!-- ***************************** -->

<sect1>Listado de comandos FTP
<p>
Otros comandos del ftp estándar son:
<p>
<tt><bf>!</bf></tt>: Ejecuta la shell para permitirnos la entrada de comandos en nuestro Linux. Con exit volveremos de nuevo al programa de ftp matando el shell. Si se especifica tras la admiración un comando de Linux, éste será ejecutado en la shell abierta.
<p>      
Ejemplos:   &nl  
!ls : haría un dir en nuestra máquina.   &nl  
!xterm &  lanzaría otra xterm   &nl  
etc.
<p>
<tt><bf>ascii</bf></tt>: especifica tipo de transferencia de ficheros ASCII, en contraposición a ficheros binarios (no texto).
<p>
<tt><bf>binary</bf></tt>: especifica tipo de transferencia binaria (por defecto).
<p>
<tt><bf>bell</bf></tt>: le indica al sistema que ejecute un pitido (bell) cuando se finalicen la ejecución de los comandos. Así podemos ejecutar bell, y dejar un fichero de gran tamaño descargándose, sabiendo que tras su finalización oiremos un BEEP, lo cual nos permite dejar la ventana minimizada y hacer cualquier otra tarea.
<p>
<tt><bf>bye, quit</bf></tt>: termina la sesión ftp y sale.
<p>
<tt><bf>cd, dir, ls, list, mkdir, rmdir, pwd</bf></tt>: órdenes básicas de acceso a directorios, equivalentes a la del propio Sistema Operativo.
<p>
<tt><bf>close</bf></tt>: termina la sesión ftp sin salir del programa.
<p>
<tt><bf>delete y mdelete</bf></tt>: borran uno o varios ficheros en la máquina remota.
<p>
Ejemplos:   &nl  
delete netscape.rpm   &nl  
mdelete *.doc   &nl  
<p>
<tt><bf>get y mget</bf></tt>: recibir uno o varios ficheros de la máquina remota.
<p>
Ejemplos:   &nl    
mget *.doc   &nl  
get "datos.doc"   &nl  
<p>
<tt><bf>reget</bf></tt>: continuar bajando un fichero cortado anteriormente.
<p>
Ejemplo:   &nl     
reget datos.doc
<p>
<tt><bf>put y mput</bf></tt>: enviar ficheros desde nuestra máquina a la máquina remota.
<p>
Ejemplo:   &nl  
put fichero.html
<p>
<tt><bf>open</bf></tt>: conectar a un ftp remoto (ej: open ftp.xoom.com).
<p>
<tt><bf>rename</bf></tt>: renombrar fichero en la máquina remota.
<p>         
Ejemplo: 
rename juan.html index.html
<p>
<tt><bf>user y pass</bf></tt>: especificar nuestro nuevo nombre y password.
<p>
<tt><bf>verbose</bf></tt>: activar o desactivar modalidad informativa.
<p>
<tt><bf>lcd</bf></tt>: Cambiar directorio local. Su utilidad radica en que cuando hacemos un download, éste irá a parar al directorio local donde estemos, de modo que cambiando de directorio podemos dejar los ficheros que nos bajamos en los lugares adecuados.
<p>      
Ejemplo:   &nl  
lcd /home/sromero/downloads
<p>
<tt><bf>help, ?</bf></tt>: imprimir información de ayuda del programa local.
<p>
Se puede obtener más información sobre estos comandos en la página man de ftp (man ftp), aunque la mayoría de los comandos
de ftp son bastante explicativos y suelen coincidir con sus equivalentes en Linux.


<!-- ****************************************** -->
<!--  SUBSECCIÓN COMO SUBIR PAG WEB AL ISP      -->
<!-- ****************************************** -->

<sect1>Como subir paginas Web a nuestro ISP
<p>
Una de las cosas que pregunta mucha gente en los diferentes canales del IRC o en las news consiste en la subida de su página
Web (creada en casa) a su directorio personal en su proveedor para que sea accesible al resto de usuarios de Internet. Aún
hay mucha gente que no sabe realizar este proceso con lo que deja su espacio (que suele ser de 2Mb o más, dependiendo del
servidor) libre en el servidor, y no aprovecha este servicio de Internet.
<p>
Lo primero de todo es crear nuestra página Web, que no es más que un directorio (con sus posibles subdirectorios) lleno de
htmls, imágenes, y un fichero index.html que será la página inicial de la Web. Pero... ¿Cómo se pone dicha página en nuestro
ISP?
<p>
Para solucionar esto disponemos de nuestro potente programa de ftp, que sirve también para este tipo de acciones.
Para ello una vez creada nuestra página en casa, hacemos ftp a nuestro servidor (ejemplo: ftp ftp.arrakis.es), y el sistema
nos pedirá la habitual identificación.
<p>
En lugar de identificarnos como anónimo (anonymous), lo hacemos con nuestro login y password (a veces necesitaremos utilizar
los comandos user nombre, pass password) de acceso a nuestro servidor, con lo que tras la autentificación entramos al servidor
dentro de nuestro directorio personal (si contratamos en su día el servicio de página Web), donde podremos preparar los
directorios para nuestra página mediante los comandos mkdir y cd, que actúa sobre el servidor remoto, y lcd, que actúa cambiando
de directorio en nuestra propia máquina.
<p>
Para ello hacemos <tt>lcd /home/usuario/donde_sea/web</tt> con lo cual ponemos el directorio actual en el especificado.
<p>
Una vez seleccionados lo directorios correctos, está disponible el comando put nombrefichero (o mput, para multiples ficheros)
para subir la página (como otro fichero cualquiera) al servidor. Recuerde que la página principal de su Web debería llamarse
index.html si quiere que haya alguna página por defecto en su dirección WWW, y que a partir de ésta debe estar la misma jerarquía
de directorios que creó en su PC durante la creación de la misma.
<p>
Una vez subida la página, salga del programa de ftp con quit y haga un sencilla prueba mediante su navegador habitual.


<!-- ***************************** -->
<!--  SUBSECCIÓN SERVIDOR FTP      -->
<!-- ***************************** -->

<sect1>Como instalar nuestro propio servidor FTP
<p>
Lo que se va a comentar a continuación es una manera muy sencilla de instalar un servidor de FTP anónimo para que otros
usuarios puedan acceder a él mientras estemos conectados a Internet. Esto implica que podrán recoger ficheros así como
dejarnos los ficheros que nosotros deseemos aceptar.
<p>
Para ello, y siguiendo la manera más sencilla posible, instalamos los paquetes anon-ftp y wu-ftpd y permitimos que estos habiliten
la carga de los daemons necesarios en memoria (cosa que los paquetes rpm harán automáticamente al instalarlos con el parámetro -i):
<verb>
  [root@localhost sromero]# rpm -i anonftp-2.5-1.rpm
  [root@localhost sromero]# rpm -i wu-ftpd-2.4.2b16-4.rpm
</verb>
Si no disponemos de dichos paquetes los podemos obtener del ftp de RedHat (ftp.redhat.com), del subdirectorio pub/manhattan/contrib/i386,
en formato rpm, para convertirlo a otros formatos de instalación (deb o tar.gz) mediante el script alien si fuera necesario. El primer
paquete contiene la estructura básica de un servidor ftp mientras que el segundo contiene el servidor de ftp (un daemon) propiamente
dicho.
<p> 
El primero de los paquetes creará en <tt>/home/ftp</tt> una estructura de directorios que será el directorio raíz de nuestro ftp, siendo por
defecto los siguientes:
<verb>
  [root@localhost home/ftp]# ls   
  bin    etc    lib    pub
</verb>
Este directorio (/home/ftp) será el directorio raíz de los usuarios de nuestro ftp, es decir, que cuando el usuario realice un dir al
directorio raíz estará viendo los mismos directorios que nosotros en /home/ftp. La forma de añadir o quitar programas a nuestro ftp
resulta, pues, muy sencilla, y se reduce a añadir programas y directorios en el directorio /home/ftp/pub, que es de donde los
usuarios remotos deben coger los ficheros. En este subdirectorio crearemos los distintos directorios (ej: juegos, fotos, tutoriales,
etc.) e incluiremos los ficheros que queremos que sean accesibles desde el exterior. Tras esto y un reset (o un simple reinicio del
daemon) tendremos instalado nuestro servidor de ftp.
<p>
A la hora de decirle a alguien que puede entrar en nuestro servidor, recordemos que un usuario «de a pie» no suele disponer de una
dirección de Internet propia (como ftp.netscape.com o ftp.idsoftware.com), sino que de lo único de que disponemos es (a menos que hayamos
contratado nuestro propio dominio y dns) de una dirección IP a través de la cual somos accesibles desde el exterior. Si queremos
que alguna persona del IRC (o, en general, cualquier usuario de Internet) entre en nuestro ftp, le deberemos comunicar nuestra
IP ya que es perfectamente posible acceder a un ordenador remoto especificando la dirección IP en lugar del nombre. Para averiguar
nuestra dirección IP basta con extraerla del archivo /var/log/messages, de los datos de la última conexión (al final del fichero):
<verb>
  fecha localhost pppd[393]: Remote message: 
  fecha localhost pppd[393]: local IP address 195.5.78.128
</verb>
Si estamos dentro del IRC otra manera de obtener nuestra dirección IP es mediante comandos del IRC (como /whois,
/dns, etc.) con nuestro nick identificativo (/whois Jose). Dicha IP se la comunicaremos a la persona que quiere entrar
en nuestro ftp para que pueda hacerlo mediante la orden ftp dir_IP:
<verb>
  [pepe@OtraMaquina home]# ftp 195.5.78.128
</verb>
Obviamente, parece muy incómodo tener que especificar cada vez nuestra nueva dirección IP, pero esto es así debido a que
las direcciones IP asignadas por nuestro servidor varían en cada conexión, con las excepciones de que hayamos contratado
una dirección IP fija (en cuyo caso no variará y todo el mundo podrá acceder a nuestro ftp usando la misma dirección) o de
que hayamos contratado un nombre de dominio (como ftp.miftp.org), de manera que se pueda acceder al mismo desde esta notación
nominal (mucho más sencillo). También es posible disponer de algún servicio de redirección de nombres a IPs, y hacer un
ftp a dicho nombre.
<p>
Mediante el anterior comando, cualquier persona conectada a Internet (y mientras lo estemos nosotros), podrá acceder a
nuestra jerarquía de directorios /home/ftp, y subir o descargar ficheros, así como utilizar todos los comandos de ftp que hemos
visto en el presente artículo, y desde cualquiera de los clientes de ftp comentados (incluyendo, por ejemplo, Netscape)
convirtiendo a nuestro ordenador en un servidor de ftp como otro cualquiera.
<p>
Si queremos testear si hemos configurado correctamente el ftp, podemos hacer un ftp sobre nuestra propia máquina de manera que
se active nuestro servidor y podamos testear el servicio. Para ello especificaremos nuestra dirección IP de loopback
(la dirección IP de nuestra máquina, 127.0.0.1), o el nombre de nuestra máquina (por ejemplo, localhost):
<verb>
  [root@localhost sromero]# ftp 127.0.0.1
  [root@localhost sromero]# ftp localhost
</verb>
En principio no debemos tener ningún problema en el test, aunque en caso de obtener un mensaje de «Connection refused», será
necesario comprobar la existencia de la siguiente línea en el archivo de seguridad /etc/inetd.conf:
<verb>
  ftp  stream  tcp  nowait  root  /usr/sbin/tcpd  in.ftpd -l -a
</verb>
El objetivo de esto es permitir que nuestra máquina sea accesible vía FTP desde el exterior.
<p>
Existe un documento Howto sobre FTP anonimo que profundiza en la configuración del mismo, haciendo especial incapie en los aspectos de seguridad.


<!-- ******************************************** -->
<!--  SUBSECCIÓN OTROS PROGRAMAS FTP EN M.TEXTO   -->
<!-- ******************************************** -->

<sect1>Otros programas de FTP en modo texto
<p>
Pese a la gran versatilidad que tiene ftp, en Linux se disponen de algunos programas que pueden facilitar y acelerar algunas de las
funciones de ftp, como ncftp (un cliente de ftp más avanzado que el sencillo ftp) y wget, (un programa que permite descargar ficheros
de cualquier recurso WWW).
<p>
Ncftp  se utiliza de forma similar a ftp, pero con la salvedad de que es capaz de hacer logins automáticos (user anonymous y password email), que permite edición de líneas anteriormente escritas (history de comandos), que dispone de un modo visual (a pantalla completa) y en línea (al estilo ftp), con una barra de estado que nos informará en todo momento de qué hace el programa, que recuerda URLs (si entramos una vez en hyper.unc.edu.es, bastaría en otra conexión especificar "open hyper" o incluso "open hy" para que recuerde la URL completa), y con un comando get algo especial. El get que usa ncftp es capaz de saltarse los ficheros de los que ya disponemos, de coger múltiples ficheros (por ejemplo, get *),
de bajar un programa a trozos sin necesidad de reget (mediante get -C nombre_fichero), bajarnos ficheros de X días de antigüedad
o menos ( get -n X *.txt ), o incluso la posibilidad de hacer un get recursivo que entre en subdirectorios remotos y
que restaure la misma jerarquía de directorios en nuestra máquina, así como los ficheros que contenga (get -R /pub/juegos).
Además permite entrar directamente a ftps y directorios. Por ejemplo, en el programa de ftp básico, para entrar en
ftp.test.com/pub/linux habría que hacer "ftp ftp.test.com" y luego "cd pub/linux", mientras que con ncftp podemos hacer
directamente desde la línea de comandos:
<verb>
  ncftp ftp.test.com/pub/linux
</verb>
Además ncftp recuerda el último directorio de cada site donde entremos, de modo que la siguiente vez que entremos en, por
ejemplo, ftp.test.com apareceremos directamente en pub/linux. Dispone de muchas más funcionalidades, como un cálculo de
tiempo esperado de download del fichero (ETA), una barra de progresión de downloads, etc. (para más información, consultar
la página man).
<p>
Todo ello con un tamaño en disco de 174.000 bytes para la versión 2.4.3 (ncftp-2.4.3-3.i386.rpm), lo que lo hace ideal para bajarse
cientos de imágenes de un directorio sin ir una por una, o subir multiples ficheros a una máquina remota (como cuando
subimos nuestra página Web a nuestro ISP).
<p>
Wget es un programa que hace algo similar a get y reget pero desde la línea de comandos del Linux y que también sirve para
direcciones http. La sintaxis de wget es la siguiente:
<verb>  
  wget [opciones] dirección_de_Internet
</verb>
Entre las opciones disponibles las más útiles son:
<p>
<tt><bf>-r</bf></tt>: wget recursivo (entra en directorios y links)
<tt><bf>-L</bf></tt>: sólo entra en los links locales.
<tt><bf>-c</bf></tt>: para bajarse un fichero en varias sesiones o continuar desde donde se quedó si se corta la conexión. Esta opción hace que si existe en el directorio actual un fichero con el mismo nombre que el que se pretende bajar, pero con menor tamaño, wget continue bajando datos sólo desde el final del fichero local (solo los datos que faltan para la finalización del download).
<p>
 Un par de ejemplos de uso del programa podrían ser:
<verb>
  wget -c ftp.juan.es/pub/programas/netscape.rpm
  wget -r ftp.juan.es/pub/fotos/paisajes
  wget -rL www.8052.com
</verb>
El primer ejemplo se bajaría el fichero netscape.rpm directamente al directorio actual, pudiendo cortarlo en cualquier momento con
CTRL+C para continuar su download otro dia desde el punto en que se quedó (como reget, NetVampire, etc) utilizando el mismo comando.
El segundo ejemplo se bajaría todos los ficheros que hubieran en el directorio pub/fotos/paisajes del ftp especificado, y el tercero se
bajaría la web www.8052.com completa (incluyendo fotos, subdirectorios, etc) para poder navegar por ella en el disco duro offline.
<p>
Existen multitud de opciones (ver página del manual) que lo hacen indispensable y sumamente útil. Cuenta con un frontend para GTK
en modo gráfico (Gwget) por si no nos gusta la línea de comandos, pero en sí wget es un programa ideal cuyo uso está justificado,
pues podemos correrlo en diferentes xterm o consolas obteniendo ficheros de Internet a la máxima velocidad posible.
<p>
Otro programa bastante interesante y similar a Wget (pero que trabaja en forma de caché-proxy) es WWWoffle, que permite descargar
ficheros y páginas Web completas para navegar por ellas después en modo desconectado. También es posible marcarle páginas en modo
desconectado para que se las baje cuando conectemos (sin ser necesaria mediación alguna por nuestra parte) de forma transparente al usuario.
<p>
Cftp (Comfortable FTP) es otro programa que nos permitirá navegar por el ftp mediante las teclas de los cursores, de forma que pulsando
INTRO entraremos en los directorios sobre el que situemos el cursor virtual, o nos bajaremos el fichero sobre el que estemos.
<p>
Lftp es un programa al estilo ncftp con multitud de opciones de uso e ideal para la realización de mirrors (hacer una copia
exacta de un ftp o de un subdirectorio del mismo) y mirrors inversos (copiar a un ftp el contenido exacto de un subdirectorio local, ideal
para subir páginas Web completas con subdirectorios, ya que él mismo detecta qué ficheros locales son más nuevos que los presentes en el
ordenador remoto, actualizando éstos). Como características fundamentales tiene: soporte de alias, caché, bookmarks, busqueda de ficheros, mirror
(con opciones de continuación, recursión, borrado, etc.) mirror inverso, y sencillos ficheros de configuración.


<!-- **************************************** -->
<!--  SUBSECCIÓN PROGRAMAS FTP GRAFICOS       -->
<!-- **************************************** -->

<sect1>Programas graficos de FTP
<p>
Si lo que queremos es que nuestro programa de ftp tenga un aspecto impecable y que sea una utilidad gráfica, disponemos
en Linux de múltiples posibilidades (no sólo de texto vive el hombre, aunque siempre resulte lo más rápido y estable).
<p>
Entre los ftps más vistosos destacan gftp (del entorno gnome), IglooFTP, WX-ftp (clon de Wsftp) o el mismo Netscape Navigator.



<!-- ***************************** -->
<!-- ***************************** -->
<!--     SECCIÓN MAIL/NEWS         -->
<!-- ***************************** -->
<!-- ***************************** -->

<sect>Mail/News


<!-- ***************************** -->
<!-- SUBSECCIÓN CORREO ELECTRONICO -->
<!-- ***************************** -->

<sect1>¿Qué es el correo electronico?
<p>
El correo electrónico es casi probablemente el servicio más útil para muchos de los usuarios de Internet, permitiendo intercambio de información casi instantáneamente. Este servicio consiste, dicho de una manera sencilla, en el envío de un bloque de información de texto (aunque puede llevar incluida información multimedia o en general cualquier otro fichero adjunto) de un remitente a un destino, de igual modo que el correo convencional. La diferencia radica en que en lugar de necesitar lapiz y papel, nuestro correo electronico (email, de electronic mail) es generado normalmente por nuestro programa de correo como un bloque de texto a enviar con el siguiente formato:
<verb>
  From:     <direccion_email_del_remitente>
  To:       <direccion_destino_del_email>
  Subject:  <tema_del_que_se_habla>
  Otros:    <otros_campos_de_informacion>
  <texto_que_deseamos_enviar.>
  .
</verb>
Las direcciones de email son direcciones en servidores de correo igual que las direcciones postales lo son para la localización geográfica (por ejemplo, mi email es sromero@unix-shells.com, y un mensaje a dicha dirección llegaría a mi máquina servidora de correo de donde yo lo recogería para su lectura).
<p>
Un ejemplo de email seria el siguiente:
<verb>
  From: agonzalo@server.es
  Date: Wed, 12 May 1999 22:19:24 +0200
  Organization: Universidad de Sevilla
  To: sromero@unix-shells.com
  Subject: Una pregunta sobre configuraciones...

  Hola, te queria hacer una pregunta...
  ¿me puedes ayudar con fetchmail?
</verb>
Este bloque de texto se envia al servidor de correo de nuestro proveedor (o al nuestro, como ahora veremos) quien se encargara de moverlo por Internet hasta llegar al destinatario de nuestro mensaje. Podemos dividirlo en 2 partes: la cabecera del mensaje (todos los campos From, To, etc.), necesaria para el correcto envio del mismo, y el cuerpo del mensaje (el texto en si) que es lo que deseamos enviar.
<p>
Obviamente no tenemos que generar nosotros todo eso en un fichero de texto y despues realizar las operaciones para su envio (o recepción), sino que existen programas (clientes de correo) en los cuales introducimos el mensaje y éstos generan las cabeceras necesarias para los programas, permitiendonos además su envio y recepción. Ejemplos de clientes de correo son Pine, Netscape Communicator, MailX, Kmail, etc.

<!-- **************************************************** -->
<!-- SUBSECCIÓN COMO LEER Y CONTESTAR CON MAIL            -->
<!-- **************************************************** -->

<sect1>¿Cómo puedo leer y contestar correo con mail/mailx?
<p>
El correo electrónico en Linux no puede considerarse como un extra al sistema operativo, sino que forma parte del mismo pues es una característica casi inherente a todo Linux. Esto quiere decir que aunque no hayamos instalado ningún cliente de correo como Netscape o Pine, probablemente dispondremos en el sistema de herramientas ya preparadas para ello.
<p>
Dentro de casi cualquier sistema Linux disponemos de un programa básico de email en consola (modo texto) llamado Mailx que nos permitirá el envio, lectura y contestación de mensajes de correo electrónico. En resumen, posibilita el envío de texto y datos dentro de una estructura coherente llamada mensaje, con su cabecera (campos: FROM (persona que envía el mensaje), TO (persona destinataria del mismo), SUBJECT (tema del que trata el mensaje) y CC o carbon copy (lista de personas que recibirán una copia del mismo).) y su BODY (cuerpo del mensaje), pudiendo incluir además ficheros añadidos que vienen incluidos dentro del paquete del mensaje (attach).
<p>
Para explicar el uso de mailx se va a usar un sencillo ejemplo en un máquina con un sólo usuario: sromero, además del obligatoriamente existente root (puede obternerse la lista de usuarios presentes en el sistema y en qué terminal están trabajando simplemente ejecutando la orden who). Suponga os que somos el usuario sromero y queremos enviarle un mensaje a root para testear las capacidades de envio de email. La manera más sencilla de enviar un mensaje a un usuario de la red es ejecutar mail :
<verb>
  [sromero@localhost info]$ mail root
  Subject: Prueba de MailX.
  Esto es el cuerpo del mensaje. Es una prueba de mailx.
  Un mensaje se acaba con un punto (.) al principio de línea.
  .
  Cc: (intro) 
</verb>
Al ejecutar mail root se nos ha preguntado el tema (subject), el cuerpo del mensaje (acabado en punto (.)), y a quién se le deseaba enviar copias del mismo (Cc), cosa que hubiera sido bastante útil si nuestro mensaje fuera una invitación a un grupo de amigos o una información para un grupo concreto de personas. Tras escribir esto, el mensaje escrito se graba como un fichero de texto (con el mismo nombre que el destinatario del mensaje, y al que se añadirán más mensajes conforme se le vayan enviando a dicho destinatario) en el directorio /var/spool/mail, a la espera de que el usuario destino los lea y vayan siendo eliminados del mismo.
<p>
Si root está conectado o entra más tarde en cualquier terminal del sistema, recibirá un mensaje de aviso indicando que el sistema ha detectado la llegada de correo para el usuario:
<verb>
  You have mail.
</verb>
Para realizar la lectura del correo electrónico, simplemente se invoca al programa mail, obteniendo una lista del correo pendiente y esperando el programa a que el usuario lo lea, responda, borre o almacene para más tarde:
<verb>
  [root@localhost /root]# mail
  Mail version 8.1 6/6/93.  Type ? for help.
  "/var/spool/mail/root": 3 messages 3 new
  >N  1 sromero   Thu Jul 30 17:04  17/55   "Prueba de MailX."
   N  2 sromero   Thu Jul 30 17:15  17/50   "Pregunta sobre adm"
   N  3 sromero   Thu Jul 30 17:16  15/44   "Felices vacaciones!"
  & _
</verb>
Como puede verse, mail nos muestra los mensajes pendientes (en este caso 3) por responder, con su usuario de origen (sromero), la fecha y el tema, con el cursor virtual (>) situado sobre el primero (es decir, indicando sobre cual actuará una orden de lectura, respuesta o borrado), y con un promtp (el carácter &) a la espera de recepción de órdenes sobre qué hacer con dicho correo.
<p>
Estas órdenes son:
<verb>
  'número' -> Listar el mensaje .
  't' -> lista el mensaje actual (el apuntado por >)
  'n' -> Pasar al siguiente mensaje y visualizarlo.
  'd' -> Borrar mensaje.
  'e' -> Editar mensaje
  'r' -> Responder mensaje.
  'q' -> Salir de mailx.
</verb>
A la mayoría de estas opciones se les puede pasar un nº de mensaje (desde 1 hasta n) para indicar sobre qué mensaje realizar la acción (ejemplo 'd 3' o 'delete 3'). Otras opciones, obtenidas mediante la ayuda de mailx, son:
<verb>
  & ?
  Mail Commands
  t    listar mensaje
  n    ir al mensaje especificado y listarlo.
  e    editar mensaje
  f    ver cabeceras del mensaje
  d    borrar mensaje
  s    añadir mensajes a un fichero
  u    recuperar mensajes borrados
  R    Responder a los remitentes del mensaje
  r    Responder al remitente y a todos los destinatarios.
  pre  hacer ir los mensajes de nuevo a /usr/spool/mail
  m    enviar mensaje a los usuarios especificados.
  q    salir grabando mensajes en mbox
  h    mostrar cabeceras activas.
  !    permite ejecutar una shell o comandos de shell
</verb>
En el caso de no disponer de correo en ese momento, mail nos avisa con un:
<verb>
  [root@localhost root]# mail
 No mail for root
</verb>
Otro fichero asociado es el fichero .signature de nuestro directorio home, utilizado como fichero de firmas y cuyo contenido es incluido al
final de los emails escritos y respondidos por nosotros, pudiendo editarse y rellenarse con cualquier editor estándar de Linux para
incluir nuestra firma personal. Este fichero es utilizado por la mayoría de gestores de correo de Linux como fichero de firmas por
defecto, tal y como hace Mail, Pine, Netscape, Kmail, etc.


<!-- ***************************** -->
<!--      SUBSECCIÓN SENDMAIL      -->
<!-- ***************************** -->

<sect1>Envio de correo: Sendmail basico
<p>
Una de las necesidades básicas en nuestros sistemas Linux es el envio de correo electrónico o email a direcciones fuera de nuestra red local
(a Internet, por ejemplo) o, en general,  de nuestra propia máquina. Cuando escribimos un email en mailx, en Netscape, o en cualquier otro
cliente de news, hace falta alguien que lleve dicho mensaje hasta el servidor de correo saliente (SMTP) de nuestro proveedor de Internet
para que éste deje cada mensaje en el buzón destino correcto. Esta es una de las tareas que sendmail puede realizar en nuestras máquinas.
<p>
En nuestros envios de mensajes, pues, necesitamos un agente que extraiga dicho correo de <tt>/var/spool</tt> y lo envie a nuestro Proveedor de
Servicios de Internet (por ejemplo, a smtp.arrakis.es). Sendmail es un programa tan completo que su estudio dispone de libros de cientos de paginas
(incluso hay alguno que llega al millar de ellas) para abordar su gestión completa. Ya que muchos disponemos de Linux en nuestras propias máquinas (y somos también root de ellas), vamos a exponer el método más sencillo de configuración para uso con un sólo Proveedor de Servicios de Internet (ISP).
<p>
Lo primero es saber si lo tenemos instalado y con el daemon funcionando. Normalmente dicho paquete estará instalado y funcionado ya que es un
daemon básico en todas las distribuciones Linux. Para arrancar el daemon (si no lo tenemos ya funcionando) y de paso chequear si está instalado,
basta con ir a <tt>/etc/rc.d/init.d</tt> en el caso de Redhat (en otras distribuciones puede variar el directorio) y ejecutar:
<verb>
  /etc/rc.d/init.d/sendmail stop
  /etc/rc.d/init.d/sendmail start
</verb>
Obtendremos lo siguiente.
<verb>
  [root@compiler /root]# /etc/rc.d/init.d/sendmail stop
  Shutting down sendmail: sendmail
  [root@compiler /root]# /etc/rc.d/init.d/sendmail start
  Starting sendmail: sendmail
</verb>
También podemos observar simplemente si durante el arranque y lanzamiento de los daemons del sistema sendmail es iniciado con lo que no haría falta
su lanzamiento manual.
<p>
Tras asegurarnos de disponer de sendmail instalado y si somos root de nuestra máquina procederemos a la configuración más básica y sencilla
del mismo (también es posible contactar con el administrador o root de la misma si no lo somos), que consiste en la edición del fichero de
configuración <tt>/etc/sendmail.cf</tt>, (por ejemplo con el editor joe, emacs, jed, etc) con el fin de modificar algunas líneas del mismo y configurar
sendmail para nuestro uso:
<itemize>
<item>Buscamos una línea similar a la siguiente:
<verb>
  # "Smart" relay host (may be null)
  DS
</verb>
Esta línea hay que cambiarla de forma que referencie a nuestro servidor de correo saliente o smtp (para que sendmail envie a dicho servidor
nuestro correo). A título de ejemplo, mi servidor de correo saliente es smtp.arrakis.es, por lo que la línea debe quedar como:
<verb>
  # "Smart" relay host (may be null)
  DSsmtp.arrakis.es
</verb>
La dirección del servidor de correo saliente puede ser otra, pero suelen tener todas el mismo formato (stmp.ctv.es, smtp.arrakis.es, etc). De todas
formas nuestro proveedor debe de facilitarnos el nombre de la máquina servidora de correo saliente al inscribirnos en dicho ISP.
<p>
<item>Ahora tenemos que enmascarar nuestra dirección de correo (es decir, modificar el fichero de configuración para que las direcciones de retorno de emails no sean las que tenemos en nuestra máquina (como sromero@localhost), sino las direcciones de retorno reales. Para ello buscamos la siguiente línea:
<verb>
  # Who I masquerade as (null for no masquerading)
  DM
</verb>
A esta línea se le añade el dominio de nuestra dirección de correo. Si mi dirección email es sromero@arrakis.es, el dominio es arrakis.es:
<verb>
  # Who I masquerade as (null for no masquerading)
  DMarrakis.es
</verb>
</itemize>
Con estos cambios estamos forzando a que cuando se escribe un email, la dirección de retorno del mismo tenga el dominio correcto, cosa que se podría modificar de igual manera (sin el retoque de sendmail.cf) si nuestro programa para leer/contestar el correo permite hacerlo (en PINE, por ejemplo, modificamos la cabecera FROM en las opciones, en CUSTOMIZED-HEADERS). Para un usuario medio (acceso a Internet, recogida y envio de correo en un
proveedor, etc.), el método comentado del sendmail.cf es más que suficiente. Además existen otros métodos e incluso otros MTAs (agendes de correo) como qmail o smail, que pueden realizar el mismo papel de una manera más sencilla.
<p>
Una vez realizada la configuración, supongamos que desde un usuario cualquiera enviamos un email a jose@proveedor.es, mediante el comando mail
jose@proveedor.es. Dicho email se grabará en <tt>/var/spool/mqueue</tt> a la espera de ser enviado a nuestro ISP quien a su vez lo enviará al usuario juan. Es decir, los emails que enviemos a Internet se guardarán en el directorio del correo hasta que se realice su envio mediante sendmail en la próxima conexión a Internet, gracias al comando "sendmail -q". Los mensajes en cola de envío se encuentran en <tt>/var/spool/mqueue</tt> (por si queremos releerlos o borrar alguno), y podemos consultarlos mediante el comando mailq.
<p>
Sendmail es un daemon o demonio, es decir, está ejecutandose en nuestra consola continuamente tratando de enviar el correo cada X tiempo. Para evitar esto, y obligarle a que el envío se realice manualmente por nuestra parte, debemos modificar el arranque de sendmail en el fichero <tt>/etc/rc.d/init.d/sendmail</tt> cambiándolo para que arranque con las siguientes opciones:
<verb>
  daemon /usr/sbin/sendmail -bd -oDeliveryMode=d
</verb>
Otro problema común es recibir una advertencia (warning) cada vez que un mensaje lleve más de X hroas sin ser enviado (4 por defecto). Para evitar eso tan sólo hay que editar /etc/sendmail.cf y comentar (colocando un símbolo # al principio de la línea, y, por tanto, deshabilitándola) la siguiente opción:
<verb>
  Timeout.queuewarn=4h
</verb>
Otra opción a comentar (añadiendo # al principio de la línea correspondiente en sendmail.cf) es la siguiente:
<verb>
  Timeout.queuereturn=5d
</verb>
Esta opción especifica que si el correo no ha podido ser enviado durante 5 días debe ser devuelto a sendmail. Esto puede ser util si estamos enviando los emails a un proveedor y se pierden, con lo que gracias a la devolución podrían ser reenviados, pero en nuestro caso no va a ser necesario pues los mensajes residiran en nuestro disco duro hasta el momento en que los enviemos.
<p>
En resumen: sendmail es un agente de transporte de correo (MTA) que recoge nuestros emails y los deja temporalmente como simples ficheros de texto que son en /var/spool/mqueue a la espera de realizar su distribución a los destinatarios especificados. Esta entrega se puede hacer bien mediante el comando "sendmail -q" o bien esperando a que el sistema llame a sendmail (lo llama cada X tiempo, siendo este tiempo programable) para que lo distribuya. Este tiempo, así como los restantes parámetros de configuración (como el servidor SMTP, que es el lugar a donde sendmail debe enviar los mensajes, es decir, nuestro proveedor de Internet) se pueden especificar en el fichero de configuración /etc/sendmail.cf .
<p>
Gracias a sendmail podremos enviar mensajes de corre electronico estando desconectados de Internet, mensajes que serán enviados por él cuando se realice la próxima conexión. Esto nos permitirá responder el correo electrónico desde nuestro cliente de correo, con el siguiente mecanismo: una vez configurado sendmail, en nuestro cliente de correo ponemos como SMTP la dirección IP de nuestra máquina (nuestra IP de red, nuestro nombre de máquina o bien 127.0.0.1 o localhost) de modo que cuando escribamos un mensaje en Netscape y pulsemos en Enviar, éste será enviado *a nuestra propia máquina* de tal forma que sendmail se encargará de enviarlo durante la próxima conexión a Internet cuando se ejecute mediante "sendmail -q" o como daemon temporal. Esto nos permite contestar el correo electronico en nuestro cliente favorito, sin gasto de teléfono por nuestra parte, y pudiendo simplemente enviar los mensajes y dejar que sendmail los distribuya al conectar a Internet.


<!-- ***************************** -->
<!--   SUBSECCIÓN  FETCHMAIL       -->
<!-- ***************************** -->

<sect1>Recogida de correo: Fetchmail

<p>
Si con programas como sendmail es posible enviar el correo a nuestra máquina estando desconectados de Internet para su posterior distribución
cuando se conecte a la Red, con Fetchmail es posible hacer el proceso inverso, es decir, recoger TODO el correo de todos los servidores POP
o IMAP deseados para su posterior recogida desde nuestra máquina y lectura en modo desconectado.
<p>
Fetchmail es el daemon encargado de la recogida de correo, para posteriormente pasárselo a sendmail, que es quien lo distribuye. La
forma más sencilla de configurar fetchmail es creando un fichero .fetchmailrc en el directorio personal del usuario (ya sea <tt>/home/usuario</tt>
o incluso <tt>/root</tt>), de forma que sea el mismo usuario quien recoja el correo y se lo pase al usuario/usuarios que deban leerlo. Dicho fichero tiene un formato como el que sigue:
<verb>
  defaults
  fetchall
  flush
  pass8bits

  poll servidor_de_correo
  proto pop3
  user usuario
  pass password
  to usuario_local
</verb>
(pueden haber más bloques poll/proto/user/pass/to si hay mas servidores de correo de donde deseemos recoger el mismo)
<p>
Las opciones incluidas en este fichero son las siguientes:
<itemize>
<item>defaults:  establece los valores por defecto para fetchmail.

<item>fetchall:  recoge todos los mensajes pendientes en el servidor de correo.

<item>flush: una vez recogidos los mensajes son borrados del servidor de correo. Para nuestras primeras pruebas es recomendable  cambiar este parámetro por keep, para que los mantenga y así no los perdamos en caso de un error de configuración.

<item>pass8bits: Indica que el mensaje puede contener carácteres de 8 bits (acentos, eñes, etc.).

<item>Bloque poll/proto/user/pass: Indica las características de nuestro servidor de correo. Si disponemos de más de un servidor de correo, se deben incluir tantos bloques de este tipo (repetir la estructura para ambos) como servidores dispongamos.

<item>poll: Indica el servidor de correo entrante (POP o IMAP) de donde leer el correo (en mi caso se trata simplemente de anteponer pop al dominio de mi ISP, quedando pop.arrakis.es).

<item>proto pop3: Indica que nuestro servidor de correo entrante utiliza POP para la recogida del correo (alternativo a IMAP).

<item>user y pass: Indican la cuenta del correo y password del usuario. Algunas cuentas de correo típicas son como las siguientes:
<verb>
  user sromero@arrakis       <- en arrakis
  user sromero               <- en CTV
</verb>
(consultar con nuestro ISP cual es el login de nuestra cuenta de correo). Si nuestro password es numérico tal vez haga falta encerrarlo entre comillas dobles "".

<item>to usuario: Indica a qué cuenta de usuario se le ha de pasar el correo. Usuario ha de ser una cuenta de nuestro sistema Linux, tales como sromero, o root.
</itemize>
<p>
Un ejemplo de fichero .fetchmailrc para un usuario sromero@arrakis.es en /home/sromero sería el siguiente:
<verb>
  defaults
  flush
  fetchall
  pass8bits
  poll pop.arrakis.es
  proto pop3
  user sromero@arrakis
  pass mipassword
  to sromero
</verb>
Además, este fichero tiene que tener unos permisos de lectura/escritura concretos, debido a que posee nuestro password de correo, cosa que se
realiza con la orden chmod:
<verb>
  [sromerolocalhost sromero]#   chmod 0600 .fetchmailrc
</verb>
La forma de recoger el correo es, estando conectado, ejecutar la orden "fetchmail".
<p>
Por último, podemos hacer que fetchmail corra en forma de demonio (el equivalente en MSDOS sería como un programa residente), y que recoja
el correo sólo cada X segundos, cosa muy sencilla de realizar añadiendo la siguiente opción al fichero .fetchmailrc:
<verb>
  set daemon X
 
  (ejemplo: set daemon 300)
</verb>
Esto haria que fetchmail buscara correo nuevo cada 300 segundos sin necesidad de ser lanzado por nuestra parte con el comando "fetchmail".
<p>
Una vez recogidos los mensajes (ya sea en forma manual o como daemon), éstos son depositados por sendmail en <tt>/var/spool/mail</tt>, de manera que
puedan ser accedidos por cualquier programa de correo del sistema (mailx, pine, y, como veremos ahora, Netscape). Simplemente debemos
configurar nuestro cliente de correo especificando como servidor POP nuestra propia máquina (localhost, 127.0.0.1, etc). Tras haber recogido
todos los mensajes con fetchmail y ya desconectados de la Red, en el cliente de correo (por ejemplo Netscape) le damos a GET NEW
MESSAGES (Obtener nuevos mensajes) y aparecerán ante nosotros los emails recogidos por fetchmail dispuestos para ser respondidos totalmente offline.


<!-- ************************************* -->
<!-- SUBSECCIÓN SENDMAIL/FETCHMAIL:OFFLINE -->
<!-- ************************************* -->

<sect1>Sendmail y Fetchmail: Todo Offline
<p>
Con fetchmail y sendmail, trabajar con el correo electrónico en modo desconectado (tanto leer como contestar el correo OFFLINE, con el
consiguiente ahorro de dinero en tiempo de conexión) consiste simplemente en lo siguiente:
<verb>
  [root@localhost root]# pppd
  [root@localhost root]# sendmail -q
  [root@localhost root]# fechmail
  [root@localhost root]# killall pppd
</verb>
Con la primera línea conectamos a Internet, para posteriormente enviar el correo pendiente en la cola de mensajes (los enviados por nosotros a nuestramáquina), así como recoger el correo entrante en nuestro ISP con fetchmail (y dejarlo en nuestra máquina listo para recogerlo con Netscape, Pine o nuestro cliente de correo).
<p>
Gracias a esto en apenas unos minutos de conexión enviamos todo el correo saliente y recogemos los nuevos mensajes, dejándolos en nuestro sistema listos para su contestación con el modem desconectado. Otra opción es incluir las llamadas a las funciones de envío y recogida en el fichero /etc/ppp/ip-up, de manera que la recogida sea automática al realizarse la conexión. Además podremos utilizar procmail para distribuir el correo, de manera que todos los usuarios de una red tengan la misma dirección de email en Internet pero luego puedan enviarse mensajes a usuarios individuales con esa misma dirección, etc. Las posibilidades de actuación de Linux son infinitas en este campo, pudiendo crear listas de correo, filtros anti-spam, etc.


<!-- ***************************** -->
<!-- SUBSECCIÓN NETSCAPE OFFLINE   -->
<!-- ***************************** -->

<sect1>¿Cómo configuro Netscape para trabajar Offline?
<p>
Si disponemos de nuestros emails en <tt>/var/spool/mails</tt> nada nos impide utilizar Netscape para trabajar con ellos, y así de paso trabajar en modo
desconectado u offline. Para ello tan sólo hemos de ir a las opciones del programa (edit->preferences), y modificar los datos que especifican nuestro servidor de correo entrante y saliente.
<p>
Para ello vamos a la pestaña Mail & Groups, submenú Mail Server y como Outgoing mail (SMTP) server especificamos localhost (nuestro ordenador), de
manera que al enviar emails con Netscape vayan a parar al directorio <tt>/var/spool/mail</tt>. Como Mail server type especificamos la opción
"Movemail Application", y seleccionamos Built in, para que utilice la herramienta interna de Netscape para la recogida del correo, tal y como
se puede ver en la figura adjunta.
<p>
Por último como root habremos de cambiar los permisos del directorio /var/spool/mail para que Netscape pueda escribir en ellos:
<verb>
  [root@localhost root]# cd /var/spool
  [root@localhost spool]# chmod 01777 mail
</verb>
(otra posibilidad es buscar la aplicación movemail y darle permisos de root.root y atributos +s para que tome privilegios de administrador).
<p>
Una vez realizado esto, todas las recepciones y envíos se realizan sobre el directorio /var/spool/mail y /var/spool/mqueue, con lo que podremos
leer y responder desde Netscape los emails recogidos con fetchmail, y cuyas respuestas serán enviadas por sendmail en la siguiente conexión a
Internet. De la misma manera, podemos especificar localhost como servidor de correo entrante (pop) y saliente (smtp) en otros programas de correo
para que accedan a nuestra máquina y podamos trabajar en modo desconectado, como en el programa Kmail incluido en KDE, en Pine, etc.

 
<!-- ************************************************ -->
<!-- SUBSECCIÓN QUE SON LAS NEWS O GRUPOS DE NOTICIAS -->
<!-- ************************************************ -->

<sect1>¿Qué son las news o grupos de noticias?
<p>
Las news (grupos de noticias) son un interesante servicio de Internet que
permite el intercambio de mensajes en un foro común sobre un determinado
tema de interés para todos sus lectores. En cuanto a formato, son algo
similar a los emails: simples mensajes de texto formados por la cabecera
del mensaje seguida del cuerpo, y donde a su vez la cabecera se divide
en diferentes campos que indican el remitente, el grupo destinatario o
el tema del mensaje.
<p>
 Si se busca información de un determinado tema (programación, electrónica,
diseño, imágenes, etc.), sólo es necesario apuntar nuestro programa de news
(por ejemplo, Collabra Discussion Groups, de Netscape, incluido con
Communicator) hacia el grupo adecuado para disponer de la posibilidad de
intercambio de información e intereses comunes entre un gran grupo de
usuarios interesados en el mismo tema. Apuntándose, por ejemplo, al
grupo es.comp.os.linux estaremos en conexión con un grupo temático
dedicado exclusivamente al habla sobre este S.O. Si enviamos un mensaje
al grupo, todas las personas suscritas al mismo podrán leerlo y contestarlo
(algo así como enviar emails pero a un lugar donde lo pueden leer todas
las personas interesadas en el tema) tanto personalmente como al grupo
en general, pudiendo por tanto aprender mucho sobre el tema tratado.
La variedad de temas disponibles en los diferentes grupos permiten nuestra
participación activa, yendo desde la simple lectura (de la que se puede
aprender mucho) hasta la colaboración con el grupo respondiendo a preguntas
que ayuden a otros lectores a desarrollarse.


<!-- ************************************** -->
<!-- SUBSECCIÓN ¿COMO SE ACCEDE A LAS NEWS? -->
<!-- ************************************** -->

<sect1>¿Cómo se accede a las news?
<p>
 En general, basta con instalar un cliente de news e indicarle la
dirección de nuestro servidor de news (el nombre o IP de la máquina
que contiene los grupos), tal como news.arrakis.es, news.ctv.es, o
como quiera que se llame nuestro proveedor de servicios de Internet.
También existen diferentes servidores de news gratuitos, algunos de
ellos sin limitaciones y otros que sólo permiten postear mensajes de
un determinado nº de líneas, o donde el nº de líneas de texto nuevo
sea mayor que el texto al que se contesta, ya que al ser como un
email, se puede dejar el texto anterior al contestar:
<verb>
  Ejemplo:

  --------------------------------------------------
  > JuanJO preguntó:
  > ¿alguien sabe como hacer esto?

   Pues tienes que ir al directorio... [etc]
  --------------------------------------------------
</verb>
 Sabido ya nuestro servidor de news y el puerto de acceso (general-
mente el 119) la configuración del acceso simplemente consiste en
ir a las opciones del cliente de news que deseemos usar e indicarle
como "Servidor de News" la dirección de nuestro server, y como puerto,
el apropiado para el mismo.
<p>
 Una vez realicemos la configuración, el cliente de news se bajará
del servidor remoto una lista de todos los grupos temáticos disponibles
y de las descripciones de los contenidos, para que posteriormente
podamos seleccionar aquellos de nuestro interés. Suelen haber miles
o decenas de miles de grupos diferentes, ordenados por tematicas.
 Los grupos de news son como una jerarquía donde cada grupo se divide
en subgrupos hasta llegar a aquel de la tematica deseada:
<verb>
  es.*                   -> todos los grupos de news en castellano
                            (hay miles de ellos)
  es.ciencia.*           -> grupos de news sobre ciencia.
                            (hay unas decenas, de electrónica,
                             matemáticas, biología, etc)
  es.ciencia.electronica -> grupo de news sobre electronica en castellano.

  o bien:
 
  es.comp.*              -> grupos relacionados con ordenadores.
  es.comp.os.*           -> grupo de news dedicados a S. Operativos.
  es.comp.os.linux       -> grupo de news sobre el S.O. Linux.
  es.comp.os.windows     -> grupo de news sobre el "S.O." Windows
  (etc...)
</verb>
Esta lista de grupos y sus descripciones se almacena en nuestro PC
para que posteriormente a su download completo (suele tardar bastante
al ser muy extensa) podamos suscribirnos a aquellos grupos que más
nos interesen. En el caso del autor, y como ejemplo, uso Netscape
Communicator y estoy suscrito a es.ciencia.electronica, es.comp.os.linux
y rec.games.programmer, los cuales recibo en diferentes carpetas para
leer mensajes de cada uno de los temas por separado (cada vez que conecto
a Internet recojo los nuevos mensajes de cada grupo y envio mis respuestas).
<p>
 Tanto Netscape Communicator como otros lectores/clientes de noticias
(Slrn, Krn, Xrn) dan acceso a la lectura y gestión de artículos de las
news siempre y cuando estemos conectados a Internet (trabajando online),
es decir, hay que estar conectado, recoger los nuevos mensajes, y leerlos
y contestarlos estando conectados lo cual conlleva un gasto (innecesario
como veremos) de teléfono a la hora de leer, responder y descartar los
mensajes que nos interesen.
<p>
Existen algunos programas que permiten hacer algo más ahorrativo: al entrar
en el grupo de news que nos interesa, podremos leer las cabeceras de los
mensajes disponibles (como por ejemplo en el programa HY-News), marcar los
que nos interesen y posteriormente bajarlos para leerlos una vez
desconectados de la línea, si bien el marcado de cabeceras requiere un tiempo
de lectura y elección que puede llegar a bastantes minutos si estamos suscritos
a diferentes grupos, aunque siempre es mejor esto que responder todos los
artículos online.
<p>
 En Linux disponemos de la posibilidad (de nuevo formando parte gratuita
del Sistema Operativo y no como un extra a añadir al mismo) de instalar
clientes de news (y servidores) que nos permitirán trabajar en modo
desconectado de la misma manera que se puede hacer con el correo (en
aquel caso mediante fetchmail y sendmail). Estos programas funcionan
bajandose TODOS los nuevos articulos/mensajes de news (a gran velocidad
al ser conexion directa al servidor) para luego en nuestro cliente de
correo especificar como servidor de news nuestro propio PC (localhost)
de modo que podremos leer y contestar las news totalmente offline.
<p>
 En este aspecto podemos elegir principalmente entre leafnode
e inn+suck. Éstos 2 ultimos paquetes (inn y suck) son muy potentes y
mucho más avanzados para nuestros propósitos iniciales, de modo que
si nuestro uso de las news es sencillo (no queremos montar nuestro
propio servidor sino simplemente obtener un medio para leer las news
offline) nos quedaremos con leafnode mucho más sencillo de instalar y
configurar.


<!-- ************************************************ -->
<!-- SUBSECCIÓN LEAFNODE COMO SERVIDOR DE NNTP        -->
<!-- ************************************************ -->

<sect1>Leafnode como servidor de NNTP
<p>
Como puede leerse en la página del manual (man fetch) leafnode es un
paquete de trabajo con news diseñado para ordenadores pequeños con pocos
usuarios, de manera que no ocupa mucho espacio y permite la gestión de
muchos grupos. El diseño de leafnode está pensado para que sea capaz
de autoreparar errores cuando ocurran, y que no necesite mantenimiento
manual. Es decir: nos encontramos ante un programa que requiere poco
espacio y mantenimiento, pero que en cambio nos proporciona total acceso
a la gestión de grupos de noticias, gracias a leafnode (un servidor de NNTP),
fetch, el programa que se encarga de recoger las news de Internet y dejarlas
en nuestro disco duro para su posterior lectura por parte del programa que
deseemos, y texpire, que se encarga de eliminar los mensajes viejos para
recuperar disco duro y deshacernos de los artículos no deseados según el
tiempo de expiración que hayamos configurado.
<p>
 Leafnode es un programa incluido en la mayoría de las distribuciones Linux
(sobre todo en las de RedHat), y si no disponemos de él puede encontrarse
en ftp.redhat.com en el directorio pub/manhattan/contrib/i386 (versión 1.5)
o en la sección de viejos RPMs (la versión 1.4). Algunas (caso de algunas
distribuciones Manhattan) versiones tienen un fallo con Netscape, pero al
autor le consta que a partir de la versión 1.9 este fallo fue corregido
completamente (NOTA: El autor usa leafnode 1.4 ya que le sigue funcionando
perfectamente y no ve ninguna necesidad de actualizar a la version 1.9 :).
La instalación en formato rpm es mediante el comando rpm -i, y para
paquetes .deb y tar.gzs también se debe seguir el método habitual de instalación
ya conocido por los que usan distribuciones Debian o Slackware, además de poder
convertir el paquete de rpm a cualquier otro formato mediante el script alien,
incluido en muchas distribuciones y que podemos encontrar en el home de Debian.


<!-- ************************************ -->
<!-- SUBSECCIÓN CONFIGURACIÓN DE LEAFNODE -->
<!-- ************************************ -->

<sect1>Configuración de Leafnode
<p>
 Una vez instalado leafnode se debe proceder a configurarlo. Como root
entramos en el directorio /usr/lib/leafnode y editamos el fichero config,
donde leeremos algo similar a lo siguiente (fichero de configuración de
la versión 1.4):
<verb>
  # This is the NNTP server leafnode fetches its news from.
  # You need read and post access to it.
  server = news.arrakis.es

  # Unread discussion threads will be deleted after this many days if
  # you don't define special expire times. Mandatory.
  expire = 5

  # Non-standard expire times (no regex possible)
  #groupexpire comp.linux.misc = 5   # group too big to hold articles 20 day
  #groupexpire any.newsgroup = 100  # very interesting, hold articles longe

  # Never fetch more than this many articles from one group in one run.
  maxfetch = 2000

  # Specifies an upper limit on how many groups an article may be posted to. 
  maxcrosspost = 0
</verb>
El significado de las diferentes opciones es muy descriptivo:
<p>
La opción server indica el servidor de donde leafnode ha de leer las
noticias. En este caso se tiene especificado como servidor
news.arrakis.es. En principio esta línea no contendrá ningún valor
si es la primera vez que lo configuramos, así que será necesario
incluir aqui el nombre de nuestro servidor de noticias habitual
(news.ctv.es, news.arrakis.es, etc.).
<p>
Con expire=5 le indicamos a leafnode que si un tema (thread o hebra)
   de artículos no ha sido tratado durante 5 días o más, debe borrarlo
   (lo haremos con texpire). Es decir, si un hipotético tema llamado
   «Pregunta simple», y sus respuestas «Re: Pregunta simple» llevan 5
   días sin ser tratados, todos estos mensajes son eliminados del disco
   duro para ahorrar espacio (debido a que es considerado como tema
   antiguo). El número de días puede ser modificado a nuestro gusto
   mediante esta opción.
<p>
Las 2 opciones groupexpire comentadas permiten especificar excepciones
   a diferentes grupos (por ejemplo, si queremos que en un determinado grupo
   se guarden los artículos más días) con respecto al tiempo considerado para
   eliminar artículos. En este sentido, se utiliza para hacer una excepción
   para un grupo concreto sobre el valor de expire generalizado para todos
   los grupos (por ejemplo, si un grupo tiene un flujo muy grande de mensajes
   puede no interesarnos que caduquen a los 5 dias sino a los 3).
<p>
El parámetro maxfetch especifica el máximo número de artículos a recoger
   cada vez de cada grupo. La primera vez que recojamos los mensajes de un
   grupo nos recogerá este número de posts, así que es recomendable ponerlo
   a 500 inicialmente y despues de la primera recogida de grupos dejarlo
   en el valor deseado.
<p>
La opción maxcrosspost indica el número máximo de grupos a los que un
   artículo puede ir dirigido (para evitar el crossposting o repeticion
   del mismo mensaje en diferentes grupos), o cero para no indicar límite
   de grupos.
<p>
  Una vez configurado el programa conectamos a Internet y
   ejecutamos el programa de recogida de news (fetch) mediante la orden:
<verb>
  [root@localhost root]#   fetch -v
</verb>
Mediante esta orden, y al ser la primera vez que llamamos al programa,
fetch se dedicará a bajarse de nuestro servidor de news todos los nombres y
descripciones de los grupos de noticias existentes para que posteriormente
podamos suscribirnos a cualquiera de ellos.
<p>
 Si queremos seguir el proceso y saber que hace en todo momento
leafnode, podemos ejecutar el siguiente comando en otra consola
virtual o xterm:
<verb>
  tail -f /var/log/messages
</verb>
Veremos algo similar a:
<verb>
  Jan 2 11:07:00 localhost fetch: Registered group arrakis.binarios
  Jan 2 11:07:00 localhost fetch: Registered group arrakis.consultas
  Jan 2 11:07:00 localhost fetch: Registered group arrakis.general
  Jan 2 11:07:00 localhost fetch: Registered group arrakis.noticias
  Jan 2 11:07:00 localhost fetch: Registered group a.bsu.programming
  Jan 2 11:07:00 localhost fetch: Registered group a.bsu.religion
  (y un largo etc).
</verb>
 El parámetro -v (verbose) le indica a leafnode que muestre mensajes en pantalla
indicando qué hace en cada momento. Hay diferentes niveles de explicación
(-v, -vv, ...-vvvvv) que nos permitirán saber qué hace el programa y observar
la progresión del mismo. Tras un tiempo (dependiendo de la velocidad de nuestro
modem), el programa terminará de recoger los nombres de los newsgroups
(proceso largo, debido a la gran cantidad de ellos, así que tendremos que
tener paciencia esta primera vez de ejecución), y habremos de resetear el
inetd para que se active nuestro servidor de news (leafnode):
<verb>
  [root@localhost root]#   /etc/rc.d/init.d/inet  restart
</verb>
 Por último (aunque suele ser realizado automáticamente al instalar el
paquete), debemos asegurarnos de que tenemos abierto el puerto de nntp (de
nuestro servidor de noticias) en el archivo /etc/inetd.conf, simplemente
comprobando si existe (y creando en caso negativo) una línea similar a la
siguiente:
<verb>
  nntp  stream  tcp  nowait  news  /usr/sbin/tcpd  /usr/sbin/leafnode
</verb>
Tras esto podemos desconectar de Internet y prepararnos para elegir los
grupos a los que deseamos suscribirnos, como veremos a continuación.
<p>
 Nota: Es posible que si instalamos leafnode desde un fichero tar.gz,
el path destino de instalación sea /usr/local/sbin/leafnode, de modo
que la linea anterior debe cambiar para ajustarse al path donde leafnode
este disponible.
<verb>
  nntp  stream  tcp  nowait  news  /usr/sbin/tcpd  /usr/local/sbin/leafnode
</verb>
 Las ultimas versiones llevan un mayor número de opciones las cuales
podemos (y deberíamos) consultar en la página man de fetch.


<!-- ************************************************ -->
<!-- SUBSECCIÓN SUSCRIPCIÓN A LOS GRUPOS DESEADOS-->
<!-- ************************************************ -->

<sect1>Suscripción a los grupos de noticias deseados
<p>
Una vez tenemos la lista de grupos y sus descripciones (Active List) en
nuestro disco duro, llega el momento de suscribirse a los grupos que
deseamos recoger. Para ello nos vamos a /var/spool/news/interesting.groups
y creamos allí ficheros con los nombres de los grupos a los que nos queremos
suscribir. Dicho de una manera sencilla, si nos queremos suscribir a
es.comp.os.linux y es.ciencia.electrónica, por ejemplo, dentro de
/var/spool/news/interesting.groups creamos dichos ficheros sin contenido
alguno:
<verb>
  [root@localhost root]#   touch  es.comp.os.linux
  [root@localhost root]#   touch  es.ciencia.electronica
</verb>
El comando touch sirve para actualizar la fecha de un fichero, y si no
existe se encarga de crearlo (vacío, de cero bytes). El directorio
interesting.groups es para leafnode una base de datos de los grupos que
debe bajarse, estando especificados en forma de ficheros. Después de los
2 touch, el contenido del directorio es el siguiente:
<verb>
  [root@localhost interesting.groups]# ls -l
  total 0
  -rw-r--r--   1 news     news     es.ciencia.electronica
  -rw-r--r--   1 news     news     es.comp.os.linux
</verb>
 Mediante esto, cada vez que recojamos los artículos llamando a fetch
(como ahora veremos), leafnode se bajará los artículos nuevos de estos 2
grupos. Por supuesto, es posible suscribirse a tantos grupos como sea
necesario, creando los ficheros con touch (o creandolos con cualquier
editor de texto y grabándolos vacíos).
<p>
 Tras esto ya estamos suscritos a diferentes grupos en el leafnode, lo
cual significa que leafnode se bajará los mensajes de dichos grupos.
El siguienet paso sería ir al cliente de news y poner como Groups
Server (servidor de news, de nntp o de grupos) el nombre o IP de nuestra
propia máquina, como 127.0.0.1 o localhost. Tras esto veremos aparecer
en el cliente de news (por ejemplo en Netscape Communicator) la lista
de grupos que hay en nuestro sistema (la que se bajó leafnode) y nos
podremos suscribir a los grupos que deseamos leer en nuestro netscape
(Join Discussion Groups).
<p>
 Es decir, primero con Leafnode nos suscribimos a los grupos que
deseamos recibir en el sistema, y luego cada usuario, en su cliente
de news, se suscribe, de dichos grupos que se reciben, a los que
desea leer en su cliente.


<!-- ****************************** -->
<!-- SUBSECCIÓN  RECOGIDA DE NEWS   -->
<!-- ****************************** -->

<sect1>Recogida de news
<p>
 Una vez configurado todo el sistema de leafnode, veamos el proceso que
se seguiría cada vez que se deseen recoger los artículos de las news cada
día (o cada vez que se use Internet). Para ello, conectamos a Internet (por
ejemplo, ejecutamos pppd, enviamos nuestro correo con sendmail, recogemos
los mensajes nuevos con fetchmail, etc.) y ejecutamos el siguiente comando:
<verb>
  [root@localhost root]#   fetch -v
</verb>
 En ese momento, leafnode enviará los artículos que hayamos respondido (si
es la primera vez, no habremos escrito nada todavía) y después comenzará
a bajarse todos los artículos nuevos de los grupos a los que nos hayamos
suscrito en <tt>/var/spool/news/interesting.groups</tt>. Nótese que leafnode la
primera vez se bajará unos 2000 mensajes de cada grupo (depende de la
opción maxfetch especificada en el fichero de configuración, por lo que
recomendamos que inicialmente se deje en 500 para colocarla en 2000 tras
la primera recogida), pero a partir de ese momento en la siguiente conexión
sólo se bajará los artículos nuevos.
<p>
 Nótese también que leafnode se baja todo el grupo (todos los mensajes, no
siendo necesario marcar cabeceras), con lo que no es necesario pasar
tiempo marcando los artículos deseados, sino que posteriormente dispondremos
de todo el grupo para su lectura en offline. Además leafnode es muy rápido
bajando los artículos, pues lo hace a altas velocidades y permite también
ser añadido al script ip-up para su recogida automática tras la conexión.
<p>
 Una vez recogidos los artículos estos son dejados en <tt>/var/spool/news</tt> (en
nuestro disco duro) para que puedan ser accedidos por cualquier cliente de
news, como Krn, Xrn, Netscape, etc. Por otra parte, una vez por semana
leafnode realiza una actualización de la lista de grupos y descripciones
(no recogida completa sino actualización) aunque esto se puede evitar si
así lo deseamos, como veremos más adelante.
<p>
 Otra de las ventajas de que la recogida se haga por medio de un comando
de consola es que podemos colocar en un script de shell (como ya dijimos,
algo similar a un BATCH de MSDOS, pero mucho más potente), que nos haga la
recogida automática de correo y news para nuestro ordenador. Para ello
creamos un fichero "recoge" con el siguiente contenido:
<verb>
  # Script para recogida de correo
  echo Enviando correo pendiente...
  sendmail -q
  echo Recogiendo correo entrante...
  fetchmail
  echo Posteando y recogiendo news...
  fetch -v
</verb>
 Tras crear este fichero, le damos permisos de ejecución (chmod +x recoge),
y ya puede ser utilizado en alguna consola virtual o xterm para recoger el
correo+news automáticamente (enviar y recoger correo y news), mientras
navegamos o trabajamos con el resto del sistema.


<!-- *********************************************************************** -->
<!-- SUBSECCIÓN CONFIGURACIÓN DEL CLIENTE DE NEWS PARA TRABAJAR CON LEAFNODE -->
<!-- *********************************************************************** -->

<sect1>Configuración del cliente de news para trabajar con leafnode
<p>
 La configuración del cliente que utilicemos es muy sencilla, y consiste en
cambiar el servidor de news que tuvieramos especificado en las opciones del
programa (por ejemplo, news.arrakis.es) por nuestra propia máquina (localhost),
con lo que cuando sea pulsado el botón de "Coger nuevos mensajes", por ejemplo,
se estará accediendo a nuestra máquina (concretamente a leafnode) para leer
dichos nuevos mensajes de <tt>/var/spool/news</tt>, es decir, los artículos recogido
por fetch.
<p>
 En Netscape Communicator esto se especifica en el menú Edit, opción
Preferences, pestaña Mail & Groups, subopción Groups Server, donde
especificaremos 127.0.0.1 (o localhost) como Groups Server y nuestro home
(<tt>/home/sromero</tt> en mi caso) en la opción Discussion Groups (news) directory.
Tras eso nos suscribiremos a los grupos deseados (cada usuario puede elegir
cualquier grupo de los especificados en interesting.groups) mediante la
opción Join Discussion Groups del menú File. El proceso es similar para
otros clientes como Krn, Slrn (con un sencillo fichero de configuración) o
incluso el editor de texto Emacs (que puede utilizarse también para gestionar
las news).
<p>
Una vez realizado esto, al pulsar sobre "Get new messages" estaremos
accediendo a nuestro disco duro para leer los ultimos artículos recogidos
por leafnode, y al enviar un mensaje en realidad estará siendo grabado como
un fichero de texto en el directorio /var/spool/news/out.going, donde se
almacenan todos los mensajes enviados offline hasta que en la próxima
conexión fetch los envíe a nuestro servidor de news (y por tanto, sean
posteados en Internet).


<!-- ***************************************************** -->
<!-- SUBSECCIÓN ELIMINACIÓN DE NOTICIAS ANTIGUAS (TEXPIRE) -->
<!-- ***************************************************** -->

<sect1>Eliminación de noticias antiguas (Texpire)
<p>
 Cada cierto tiempo debemos limpiar nuestro disco duro para eliminar
mensajes antiguos. Esto no significa que debamos entrar en el directorio
news para comprobar qué mensajes están atrasados y eliminarlos, porque
como ya se ha comentado, leafnode es un programa diseñado para automatizar
todo este tipo de procesos. Para ello sólo tendremos que ejecutar el
programa texpire (incluido con leafnode), que se encarga de recorrer todos
los grupos de que dispongamos en nuestro disco duro y eliminar aquellos
threads que sobrepasen sin actualizar el número de días indicado en el
fichero de configuración de leafnode (en nuestro ejemplo indicamos 10 días).
Al ejecutar texpire la salida suele ser algo parecido a lo siguiente
(la aparición de varios grupos a los que no estamos suscritos es debido a
que hay mensajes con crossposting, dirigidos a varios grupos):
<verb>
  [root@localhost root]# texpire
  es.ciencia.electronica: 10 articles deleted, 182 kept
  es.ciencia.misc: 21 articles deleted, 25 kept
  es.comp.hackers: 1 articles deleted, 10 kept
  es.comp.lenguajes.java: 10 articles deleted, 1 kept
  es.comp.os.linux: 100 articles deleted, 690 kept
  total: 142 articles deleted, 1012 kept
</verb>
Realizando esto regularmente mantendremos nuestro disco duro sólo con los
últimos mensajes deseados en lugar de ir llenándolo con la acumulación de
mensajes antiguos. La cantidad de días a los que hayamos configurado texpire
variará el nivel de limpieza de artículos viejos. Texpire es automáticamente
ejecutado por "cron" (la parte de Linux que se encarga de ejecutar procesos
a determinadas horas), pero para que cron tenga utilidad es necesario tener
conectado el ordenador todo el dia (cron hace las cosas a unas determinadas
horas), cosa que viene muy bien en las estaciones de trabajo pero que a
nosotros no obliga a usar el "anacron" (no necesita tener el ordenador
permanentemente conectado) o a hacerlo manualmente (la forma más sencilla,
simplemente llamando a texpire cada 15 días, ejecutándolo en la línea
de comandos del sistema).
<p>
 Normalmente a texpire le costará cerca de un mes de uso empezar a borrar
artículos, de modo que aunque inicialmente veamos que al llamarlo no
borra los artículos antiguos, debemos dejarlo porque eso quiere decir
que ninguno de los artículos ha expirado aún (o que hemos puesto un
tiempo de expiración muy grande. Un tiempo razonable es 5 dias, pero
eso depende fundamentalmente del tráfico del grupo en cuestión).
Además texpire está basado en detectar TEMAS caducados (no artículos).
Esto implica que un TEMA caduca cuando no se postee ningún
mensaje sobre él (o respuesta) en el tiempo especificado, tras el
cual será borrado. Estar basado en temas hace que se tarde más
(inicialmente) en comenzar a borrar artículos viejos, pero que a partir
de la primera expiración de artículos el proceso sea contínuo y eficiente.
<p>
 Por Internet es posible encontrar también un programa en PERL llamado
texpire.pl el cual hace un borrado artículo por artículo (no basado
en cuando un TEMA caduca sino en cuando un ARTICULO caduca) que también
puede utilizarse para este fin. No obstante el uso de texpire es más
adecuado ya que viene integrado con leafnode y su funcionamiento es
excelente.


<!-- ******************************************************************* -->
<!-- SUBSECCIÓN  COMO HACER QUE LEAFNODE NO ACTUALICE LA LISTA DE GRUPOS -->
<!-- ******************************************************************* -->

<sect1>¿Cómo hacer que leafnode no actualice la lista de grupos?
<p>
 Por otra parte, si no queremos que leafnode trate de actualizar los
grupos de news cada semana es posible modificar el código fuente del
programa, aunque lo más sencillo es actualizar la fecha del fichero de
grupos para que leafnode lo trate como si se acabara de actualizar.
Esto se hace mediante la siguiente orden, que podemos poner en cualquier
fichero del sistema (por ejemplo en /etc/rc.d/rc.local):
<verb>
  touch -m /var/spool/news/active.read
</verb>
 Este fichero (active.read) lo usa leafnode para saber cuándo fue la
última vez que buscó nuevos grupos de news en el servidor. Cuando
pasa una semana (fetch mirará para ello la fecha del fichero),
leafnode tratará de bajarse de nuevo la lista de grupos para ver
si hay grupos nuevos (proceso que suele tardar bastante). Para
evitar esto, touch actualiza la fecha del archivo y fetch nunca
detecta que haya pasado una semana, no actualizando la lista de
grupos y descripciones.
<p>
 En las últimas versiones, posiblemente podamos forzar a leafnode
a no leer la lista de grupos o a releerla de nuevo usando algún switch
de línea de comandos (al estilo fetch -n), para lo cual siempre es
aconsejable la lectura de la página man correspondiente (man fetch).


<!-- ******************************************* -->
<!-- SUBSECCIÓN PROBLEMAS DE ACCESO CON LEAFNODE -->
<!-- ******************************************* -->

<sect1>Problemas de acceso con Leafnode
<p>
  Si al recoger las news con Netscape o cualquier otro cliente de news
obtenemos el siguiente mensaje de error:
<verb>
  "An error occurred with the News server.
  If you are unable to connect again, contact the
  administrator for this server."
</verb>
 Lo primero que deberemos hacer será comprobar si leafnode está
correctamente funcionando en el puerto 119 de nuestra máquina,
haciendo un telnet localhost 119:
<verb>
  [root@compiler]  telnet localhost 119
  Trying 127.0.0.1...
  Connected to localhost.
  Escape character is '^]'.
  Connection closed by foreign host.
</verb>
 En ese caso, debemos modificar los ficheros <tt>/etc/hosts.allow</tt> y
<tt>/etc/hosts.deny</tt> para permitir a nuestros usuarios que tengan
acceso a leafnode. Una manera es dejar vacíos ambos ficheros (así
es como lo tengo yo) permitiendo a cualquier el acceso a leafnode,
y otra es modificar el hosts.deny (nunca he necesitado realizarlo
así pero es otra manera de solucionarlo) es dejar el siguiente
contenido en el fichero <tt>/etc/hosts.deny</tt>:
<verb>
  # /etc/hosts.deny
  # The PARANOID wildcard matches any host whose name does not
  # match its address.
  ALL: PARANOID
  #-- leafnode begin
  leafnode: ALL
  #-- leafnode end
</verb>
 Una salida de "telnet localhost 119" correcta debería ser:
<verb>
  [root@compiler]  telnet localhost 119
  Trying 127.0.0.1...
  Connected to localhost
  Escape character is '^]'.
  200 Leafnode NNTP Daemon, version 1.4 running at localhost
</verb>


<!-- ***************************** -->
<!-- ***************************** -->
<!--         SECCIÓN IRC           -->
<!-- ***************************** -->
<!-- ***************************** -->

<sect>IRC


<!-- ***************************** -->
<!-- SUBSECCIÓN QUE ES EL IRC   -->
<!-- ***************************** -->

<sect1>¿Qué es el IRC?
<p>
El IRC, acrónimo de Internet Relay Chat, es un sistema de
conversación en línea para usuarios de Internet
 Si disponemos de una conexión a Internet que ofrezca
este servicio (cosa muy común en todos los distribuidores
de Internet), será posible disfrutar de charlas en tiempo
real sobre cualquier tema (de entre los cientos e incluso
miles de canales que tendremos disponibles) con una gran
cantidad de usuarios.
<p>
 Para ello tan sólo necesitaremos un
cliente de IRC, como ircII (incluido con Linux en casi
todas las distribuciones) o, como veremos, con variantes
más visuales como BitchX, Zircon, cIRCus o Kirc. Mediante
la simple ejecución de nuestro cliente IRC entraremos en
nuestro servidor de IRC (previa configuración del programa
cliente para que busque en la dirección correcta) y se nos
dará la posibilidad de entrar en cualquiera de los canales
(channels, agrupaciones temáticas), descritos por sus
títulos (topics o títulos «del dia») donde encontraremos
otros usuarios y algunos operadores (ops). También existe
la posibilidad de hablar en privado con otro usuario,
de enviar y recibir ficheros (vía DCC) así como unos
usuarios especiales (que llevan una arroba (@) delante
de su nombre) llamados operadores del canal (que han
sido nombrados operadores por estar registrados en el
canal o por otros operadores), que suelen estar ahi para
controlar que la conversación gire en torno al tema
establecido en el canal, aunque por desgracia en algunas
ocasiones (en determinados canales) se dediquen a tirar
gente del canal (acciones conocidas como ban o kick).
<p>
Los programas clientes de IRC suelen constar de una celdilla
de texto en la parte inferior de la pantalla donde el
usuario (nosotros) introduce el texto que tras pulsar
ENTER es enviado al canal, apareciendo en la ventana de
la conversación (prácticamente el resto de la pantalla),
donde se pueden leer las frases escritas por todos los
contertulios del canal en el orden en que éstas llegaron
al servidor. Esto permite tener conversaciones, disputas
y cooperaciones entre los diferentes miembros del canal
(a veces apareciendo en una ventana en la parte derecha
de la pantalla).
<p>
 Mediante lo que el usuario escribe (que
leen los demás) y mediante lo escrito por los demas
(leído por nosotros), se forma una discusión que va
desde las conversaciones sobre linux en el canal #linux
hasta las discusiones sobre DirectX u OpenGL en el canal
#programacion.
<p>
 El aspecto de una conversación en el IRC es similar
al siguiente:
<verb>
  -----------------------------------------------------------
  TALKING on #programacion:
  <Gans> y yo, y yo
  <blad> ese log es oro
  <Gans> yo quiero que volverá para despedirse
  <iXnay_> perar que lo pase a tos los que quieran XDD
  <Surf_> yo mismo ixnay
  <iCorreca_> bueno, me voy pa #linux :-)
  <iCorreca_> alli nos vemos... :-)
  <iXnay_> esperar un poco 

  >>> _
  -----------------------------------------------------------
</verb>
 El IRC constituye pues un medio más rápido
de comunicación (y por tanto muy útil) que las news o el
email, donde necesitaremos algunas horas (tal vez 1 ó 2
días) para recibir respuesta a nuestra pregunta Lo primero
que debemos averiguar es el nombre de nuestro servidor de
IRC, tal como lo es irc.arrakis.es, el servidor irc de
arrakis (consultar con nuestro proveedor de Internet). La
mayoría de IRCs de España están interconectados dando lugar
a lo que se conoce como el IRC Hispano, que será nuestro
punto de encuentro con otros usuarios del IRC Español
<p>
 Si entre nuestras necesidades de utilización de Internet
está la de mantener conversaciones (escritas) con varios
interlocutores organizándolas por canales aludiendo a
diferentes temas, entonces el Internet Relay Chat (IRC) es
nuestro servicio.


<!-- ***************************** -->
<!-- SUBSECCIÓN CLIENTE IRC IRCII  -->
<!-- ***************************** -->

<sect1>El cliente de IRC IRCII (o EPIC)
<p>
 IrcII es uno de esos programas pequeños y sencillos que
proporcionan gran efectividad para su tarea, tal y como
lo es ftp para la transferencia de ficheros. IrcII es
un cliente de IRC que de nuevo es casi parte del S.O.
Linux, ya que lo encontraremos en cualquier distribución
de GNU/Linux existente. Muchos de los que están leyendo
esto probablemente habrán utilizado ya el IRC mediante el
programa MIRC (o PIRCH) de Windows95... pues hay que decir
ante todo que IRCii es la antítesis de MIRC; es decir: ircII
es en modo texto, en principio no soporta colores, y todo
funciona a base de comandos (aunque con la posibilidad de
crear menúes y alias), pero es uno de esos programas que
resultan esenciales, sobre todo en sistemas pequeños (como
la gente que se lleva un diskette de arranque de Linux con
soporte para redes y con el ircII para disfrutar del IRC en
las Universidades, donde no todo el mundo dispone de una
cuenta Unix, o donde no se suele permitir la instalación de
clientes de IRC ni juegos de rol). Lo más probable es que
ya se disponga de él en el sistema, aunque siempre puede
buscarse en el ftp de programas Linux habitual
<p> 
La instalación en formato rpm o deb no necesita comentarios,
mientras que para los ficheros .tar.gz suele haber (una vez
descomprimidos con tar xvzf nombre_fichero) un script de
instalación (easyinst) que realizará el proceso de copia de los
ficheros a sus directorios correspondientes. Una vez instalado,
y si estamos conectados a Internet, basta con llamar al cliente
de IRC ircII para tratar de conectar con un servidor de IRC,
mediante la invocación del ejecutable irc:
<verb>
  [root@localhost sromero]# irc
</verb>
O mejor, especificando el nombre que tendremos dentro del
IRC (nickname) y el servidor a utilizar:
<verb>
  [root@localhost sromero]# irc SuperJuan irc.encomix.es
</verb>
Al ejecutarlo tratará de conectarnos (si no le hemos
especificado servidor en la línea de comandos) a cualquiera
de los servidores de IRC que tiene establecidos por
defecto (y que podremos cambiar editando el fichero
<tt>/usr/lib/irc/ircII.servers</tt>), aunque también es posible
especificarlo manualmente (tras ejecutar irc) mediante la
siguiente orden:
<verb>
  /server irc.ctv.es
</verb>
Server es uno de los múltiples comandos de ircII (también
disponibles en el resto de clientes de IRC, por supuesto),
mediante el cual le indicamos al programa que conecte con
un servidor determinado. El hecho de llevar una barra (/)
antes del comando le indica al IRC que estamos tratando de
ejecutar el comando server en vez de tratar de escribir la
cadena "server irc.arrakis.es" en pantalla).Esto prentende
ser una sencilla introducción a los distintos comandos del
IRC, de manera que se puedan utilizar estos en cualquiera de
los clientes de IRC visuales (con ventanitas y menúes) que
podamos tener instalados en el sistema.
 

<!-- ****************************************** -->
<!-- SUBSECCIÓN COMO ENTRAR EN CANALES DEL IRC  -->
<!-- ****************************************** -->

<sect1>Como entrar en canales del IRC
<p>
 Una vez conectados al IRC ya es posible entrar en un canal
de conversación. Es posible listar los canales del IRC con
el comando /list, aunque no es recomendable debido a la gran
cantidad de ellos. Por contra es mejor conocer los canales
a los que queremos entrar (como #linux, #programacion,
#programacion_d_juegos, #hacking, #emuladores, o, si tenemos
problemas, #ayuda_irc). Para entrar en un canal se utiliza
el comando /join seguido del canal al que se desea entrar:
<verb>
  /join  #linux
</verb>
Tras ejecutar esto, nos encontraremos dentro de un canal
muy poblado hablando sobre el mejor Sistema Operativo
existente hasta el momento. Cualquier frase que tecleemos
en este momento (es decir, cualquier cosa que no sea un
comando, precedido por '/'), será enviado al canal y leido
por el resto de usuarios del canal. Si es nuestra primera
sesión de IRC, mejor algo de nettiquete y una sencilla
presentación y saludo al canal, seguido de cualquier duda
o ayuda que se quiera dar al resto de usuarios. Para saber
quien está conectado en un determinado canal, entramos en
él y ejecutamos el comando /who * (aunque también puede
hacerse mediante el comando /names #canal, en este caso,
/names #linux) Si en cualquier momento deseamos salir del
canal, basta con ejecutar el comando /part (o /leave) para
abandonar el canal actual, (o part #canal) ya que, como
veremos a continuación, no se está limitado a hablar en un
sólo canal temático


<!-- ********************************** -->
<!-- SUBSECCIÓN MULTIVENTANA CON IRCII  -->
<!-- ********************************** -->

<sect1>Multiventana con IRCII
<p>
 El IRC no está diseñado para hablar en un único canal.
Mediante /join podemos entrar en más de un canal, aunque en
principio los textos provenientes de uno u otro se mezclarán
en la misma pantalla (con una indicación acerca de cuál es
el canal de procedencia), además de que para hablar en uno
u otro canal se necesitará utilizar el comando /msg (con lo
cual dirigiremos los mensajes a un canal u otro):
<verb>
  /join #linux
  /join #emuladores
  /msg #linux Hola a los usuarios de Linux!
  /msg #emuladores Hola! Ha salido algun emulador hoy?
  /msg pepe Hola Juan!
</verb>
 Con IRCii no estamos obligados a leer todo el texto
en la misma ventana, sino que es posible crear diferentes
ventanas virtuales (escondidas, de manera que sólo vemos
una en pantalla, o partidas en la misma pantalla), mediante
el comando /window new, y cerrar la ventana actual mediante
/window kill. Podemos cambiar entre ventanas mediante las
teclas <tt>Ctrl+x p</tt> (ventana anterior o previous, mediante
<tt>Ctrl+x</tt> simultáneamente, soltar, y luego pulsar 'p') y
<tt>Ctrl+x n</tt> (siguiente o next). Veamos como cambia la cosa:
<verb>
  /join #linux
  /window new
  /join #emuladores
  (ctrl+x p -> estamos en #linux)
  Hola a los usuarios de Linux!
  (ctrl+x n -> estamos en #emuladores)
  Hola! Ha salido algun emulador hoy?
  /window new
  /query Juan
  Hola Juan!
</verb>
Tras esto dispondremos de 3 ventanas entre las que podremos
cambiar en cualquier momento, una en la que se habla
en #linux, la de #emuladores, y una tercera donde se
mantiene una conversación privada con Juan (mediante el
comando /query). Mediante /window hide es posible hacer
una ventana oculta (en vez de partir la ventana actual).
Es muy recomendable tener instalado el paquete screen para
el soporte multiventana, o trabajar en xterms, donde este
soporte también se da. De otro modo, el soporte multiventana
se dará en pantalla partida (tantas secciones como ventanas
dispongamos).


<!-- *************************************** -->
<!-- SUBSECCIÓN RESUMEN DE COMANDOS DEL IRC  -->
<!-- *************************************** -->

<sect1>Resumen de comandos del IRC
<p> 
Entre los comandos más habituales del IRC están aquellos
que podemos ver en el cuadro siguiente (donde lo denotado entre
corchetes [ y ] especifica que dicho parámetro es opcional).
<verb>
  /help [comando]             Proporciona ayuda en línea sobre el
                              comando especificado.

  /join #canal                Entra en el canal especificado
                              Ej: /join #linux).

  /list [#cadena]             Lista los canales disponibles en el
                              servidor, con la posibilidad de especificar
                              una cadena de búsqueda. (#cadena).
  
  /whois [usuario]            Proporciona datos acerca del usuario que
                              se le especifique, como su nombre (si configuró
                              correctamente su cliente de IRC), dirección
                              email o dirección IP.
                              Ej: /whois NoPito

  /me [frase]                 Indica al resto del canal lo que piensas,
                              resaltándolo. Es el responsable de leer frases como:
                              «_Juan_ piensa que esta conversación es muy tonta.».
                              (Ejemplo: /me esta aburrido!).
  
  /part [#canal]              Abandona un canal (o el canal actual si no se
                              especifica otro).

  /msg [usuario] [mensaje]    Envía el mensaje especificado al usuario que se le
                              indique (ej: /msg juan Hasta luego!).

  /dmsg [usuario] [mensaje]   Similar a msg, pero para un chat dcc.
  
  /query [usuario] [mensaje]  Permite iniciar una conversación privada
                              (un query) con otro usuario.
                              Ej: /query NoPete

  /query                      Cierra la conversación privada actual.

  /nick [nombre]              Permite cambiar nuestro nickname al especificado.

  /dcc send [usuario] [fichero]
                              Permite el envío de un fichero al
                              usuario especificado
                              Ej: /dcc send Juan /etc/dosemu.conf
 
  /dcc get [usuario] [fichero]
                              Permite recibir un fichero de un usuario.

  /dcc chat [usuario]         Permite iniciar un chat (conversación directa)
                              con un usuario.

  /dcc close chat [usuario]   Cerrar el chat previamente abierto.

  /quit [razon]               Sale del programa y, opcionalmente, muestra un mensaje
                              con la razón del abandono
                              Ej: /quit Me tengo que ir!

  /away [razon]               Avisa al resto de usuarios de que nos vamos a ausentar
                              momentáneamente del IRC.
                              Ej: /away El telefono!

  /invite [usuario] [#canal]  Invita al usuario especificado al canal que se le indica.

  /who *                      Muestra los nombres de los usuarios del canal actual.

  /clear                      Limpia la ventana de texto actual.

  /date o /time               Muestran la fecha u hora actual.

  /exec -out [comando]        Ejecuta el comando especificado (por ejemplo, ls),
                              y saca los resultados por la pantalla del canal.

  /flush                      Hace parar la salida obtenida desde el servidor.
                              Muy util para teclearlo, por ejemplo, ante un /list.

  /ignore [usuario] [tipo_de_mensaje]:
                              Ignora los mensajes enviados por determinados
                              usuarios (es decir, no aparecen sus frases en
                              pantalla). En él usuario pueden especificarse
                              comodines (*), mientras que el tipo de mensaje
                              puede ser ALL (todos), NOTICES (notificaciones),
                              PUBLIC (conversación normal del canal),
                              INVITES (invitaciones) o NONE (ninguno).
                              Ejemplo: /ignore Pepe ALL -PUBLIC
                              (ignorar todos los mensajes de Pepe excepto
                              (-) los que vayan al canal (publicos)).

  /leave [#canal]             Deja el canal especificado o el actual si no
                              se especifica ninguno.

  /mode                       Permite a los operadores cambiar modos (ver /help mode).

  /names [#canal]             Muestra los nombres de los usuarios del canal
                              especificado (o de todos si no se especifica).

  /notice [#canal] [mensaje]  Envía un mensaje privado a todos los usuarios
                              de un canal.

  /notify [usuario]           Permite especificar una lista de usuarios para que al
                              entrar al IRC se nos avise de si estos están presentes,
                              o de si entran o salen del IRC (para encontrar siempre al
                              amiguete de turno). Ej: /notify pepito.

  /ping [usuario]             Envía un ping (una señal con la hora actual) a un
                              usuario para que este la devuelta y podamos saber (por el
                              tiempo transcurrido) la velocidad de respuesta de la red
                              (si está lenta, rápida...).

  /save [opciones] [fichero]  Salva las opciones actuales del IRC en un fichero
                              (ver /help save).

  /say y /send +texto         Imprime el texto especificado en el canal, permitiendo
                              alias, binds, etc.

  /set log on                 Permite guardar en un fichero de texto lo hablado en
                              las sesiones.

  /set logfile [fichero]      Permite especificar el fichero a usar
                              (ej: /set logfile /home/somero/milog.txt).

  /window log on              Permite guardar en un fichero de texto lo hablado
                              en la ventana actual.

  /window logfile [fichero]   Permite especificar el fichero a usar
                              (ej: /set logfile /home/somero/milog.txt).

  /alias [comandos]           Crea un alias para [comandos].
                              También permite parámetros.
</verb>
Aparte de los comandos especificados, otro comando muy
útil es /alias, que nos permitirá crear atajos a órdenes
habituales:
<verb>
  /ALIAS  Hola  MSG #linux Hola a todos los usuarios del canal!
  /ALIAS  Hola  MSG  $0  Hola, $0! $1
</verb>
 Para este último alias, tras ejecutarlo, si tecleamos
«/Hola Juan Que tal?», será expandido a «/msg Juan Hola,
Juan! Que tal?», con lo que dicho saludo aparecerá en
la pantalla de Juan como mensaje privado dirigido a él.
Otros comandos interesantes (ver lista) son los comandos
de DCC, que nos permitirán enviar y recibir ficheros a/de
otros usuarios del IRC El resto de comandos del IRC (y una
ayuda y descripción de todos ellos), puede encontrarse en
el propio programa (/help comando), o en el subdirectorio
<tt>/usr/lib/irc/help</tt>, de donde cuelga toda una estructura de
directorios con ficheros de ayuda en texto puro (editables
con cualquier procesador de textos o listables con cat
o less) con el nombre de los distintos comandos. Todas
estas opciones se suelen incluir en scripts (similares a
ficheros de comandos) que son cargados durante el arranque
y añaden nuevas opciones y funcionalidades al programa.
Otra referencia es <tt>/usr/doc/irc*</tt>, donde hay ejemplos de
menúes, la página man de ircII y los cambios que han ido
habiendo en el programa desde su versión inicial


<!-- ************************************** -->
<!-- SUBSECCIÓN RESUMEN DE TECLAS DE IRCII  -->
<!-- ************************************** -->

<sect1>Resumen de teclas de IRCII
<p>
 Las teclas más utilizadas en ircII son las siguientes:
<verb>
  Ctrl+x p      :   ir a la ventana virtual anterior
                    (o comando /window previous).
  Ctrl+x s      :   ir a la ventana virtual siguiente
                    (o comando /window next).
  Ctrl+x [nº]   :   abrir N ventanas
                    (o comando /window add N>.
  Ctrl+x c      :   crea una nueva ventana
                    (o comando /window add).
  Ctrl+x a      :   va a la última ventana.
  Ctrl+x k      :   cierra la ventana actual.
  Alt+p         :   subir por la pantalla actual.
  Alt+n         :   bajar por la pantalla actual.
  Ctrl+b        :   escribir en negrita.
  Ctrl+_        :   escribir en subrayado.
</verb>
Además disponemos de <tt>Ctrl+c</tt> para interrumpir el programa.


<!-- ************************************ -->
<!-- SUBSECCIÓN CLIENTES GRAFICOS DE IRC  -->
<!-- ************************************ -->

<sect1>Clientes graficos de IRC
<p>
 Como veremos en la próxima entrega, existen otros clientes
de IRC para X Window con un sistema de manejo más sencillo:
soportando multiventana, autoraise (es decir, que cuando
cambia el contenido de una ventana esta cambia a primer
plano), colores, menúes para los comandos más habituales,
etc. Los veremos en versiones X Window, de txto (aunque más
avanzados que ircII, como BitchX) e incluso específicos
para KDE (kirc, kvirc), y nos harán la comunicación en el
IRC mucho más sencilla, sin olvidar los comandos que hemos
aprendido hoy, que complementarán todo lo que les falte a
estos clientes (al disponer de unas opciones determinadas
se nos limita el control a lo dispuesto por el programa,
mientras que mediante los comandos IRC, comentados hoy,
podremos suplir cualquier necesidad que no esté disponible
en los menúes).
<p>
<bf/TkIRC/ no es un cliente de IRC en sí mismo, sino que utiliza
como programa de IRC el famoso ircII, proporcionando un
front-end gráfico (una especie de menúes encargados de
interactuar con el propio ircII), facilitando enormemente
las tareas más habituales en el IRC. El programa puede
obtenerse desde la página Web de sus creadores,
www.north.de/~atte/tkirc, y ocupa apenas unos 100Kb.
Para su utilización es necesario tener instalado el
propio programa ircII, y el intérprete de Tcl/Tk, que es el
lenguaje con el que está programado este front-end para
XWindow. Además es posible añadirle scripts (ficheros con
nuevos comandos y opciones) en tcl, lo cual le quita muchas
limitaciones al programa (siempre puede ser ampliado por el
usuario).
<p>
<bf/Kirc y Ksirc/ son 2 clientes de IRC para el Window Manager KDE.
Son bastante visuales y disponen de interesantes opciones.
Pueden obtenerse versiones estables de los mismos en www.kde.org,
en la página de aplicaciones de KDE.
<p>
<bf/KvIRC/ es uno de los clientes de IRC más visuales y sencillos
de manejar de todos: soporta colores, nick-completion (relleno
de los nombres de las personas a las que hablamos cuando sólo
escribimos las letras iniciales de los mismos), imágenes
de fondo, configuración por medio de menúes, acceso sencillo
a los comandos básicos del IRC por medio de una barra de iconos,
integración con KDE, capacidad de lanzar netscape (o cualquier
otro navegador) pinchando sobre cualquier dirección que aparezca
en la conversación, sencilla instalación, mantenimieno y
configuración, y un aspecto muy amigable (bastante similar al
programa Mirc de Windows en cuanto a funcionamiento). Puede
obtenerse en www.kvirc.org.
<p>
<bf/cIRCus/ es uno de los más sencillos clientes de
IRC de Linux. Puede obtenerse en diferentes formatos
(tar.gz y rpm) en la página Web de sus creadores,
http://www.nijenrode.nl/~ivo/circus_data/download.html. En
tiene características multiventana (al estilo de mIRC para
Windows), la utilización de colores distintos para nuestros
comentarios y los del resto de participantes en el IRC,
así como la posibilidad de activar autoraise en las
ventanas que deseemos. Autoraise es una propiedad que
hace que cuando el contenido de una ventana cambia,
ésta pase al primer plano, y sepamos que quien está
hablando con nosotros ha dicho una nueva frase. Además
soporta correctamente todos los acentos y carácteres
españoles, y permite copiar/pegar con el mouse, sin olvidar
que puede usarse arriba y abajo en los cursores para ir
adelante y atrás en el historial de órdenes, pudiendo
repetir así cualquier frase dicha en el pasado. Por otra
parte, cIRCus tiene un sencillo menú en la parte superior
con botones que sustituyen a las opciones de conexión,
desconexión, entrada en canales (join), dar op, quitar op,
dejar un canal, o salir del programa, pudiendo ejecutar
además los comandos de IRC aprendidos el mes pasado, con
lo que se puede decir que este programa aporta sencillez
y funcionalidad a la potencia de los comandos del IRC.
Su configuración se realiza editando un fichero de texto
llano en nuestro directorio HOME (<tt>/home/nombre/.circusrc</tt>),
desde donde podemos cambiar cualquier aspecto del programa:
fuentes, menúes o identidades (al final del fichero,
secciones Nick, IRCNAME, notify y Server List, las cuales
nos permitirán especificar nuestro nick, nombre del
cliente, lista de notificaciones y lista de servidores de
IRC por defecto).
<p>
<bf/Zircon/ (http://catless.ncl.ac.uk/Programs/Zircon/) es
otro cliente de IRC basado en Tcl/Tk (aunque este no
necesita ircII para funcionar sino que utiliza las propias
facilidades de red de este lenguaje). Necesitaremos al menos
la versión 8.0.3 de este intérprete para su instalación, que
se realiza desde un script de Tcl/Tk llamado installZircon
quien se encargará de la correcta ubicación del programa en
nuestro disco duro, además de permitirnos la lectura de
documentos de ayuda y FAQs sobre Zircon.
<p>
 Existen multitud de clientes de IRC gráficos y de texto
para Linux. Una manera de ir directamente a un listado de
clientes para poder seleccionar el que más nos interese
es mediante www.freshmeat.net, tecleando irc en la celdilla
de texto de búsqueda y pulsando Intro. Freshmeat nos mostrará
toda la lista de programas relacionados con el IRC (muchos de
ellos clientes) que haya en su base de datos, así como las
direcciones de download y páginas de los mismos. Otro
repositorio de clientes IRC para Linux está disponible en
www.linuxberg.com, en la sección Software.


<!-- ***************************** -->
<!-- SUBSECCIÓN EL CLIENTE BITCHX  -->
<!-- ***************************** -->

<sect1>El cliente de IRC, BitchX
<p>
 Uno de los clientes de IRC más potentes de los comentados
aquí es BitchX, que trabaja en consolas de texto pero con
facilidades propias de los clientes gráficos. Incluye gran
cantidad de comandos y scripts, de tal modo que los
más usados scripts de ircII han sido incluidos en este
cliente como comandos del mismo. Es posible obtenerlo de
ftp://ftp.bitchx.org (aunque también
hay disponibles versiones rpm en el ftp de redhat).
Asimismo, podemos obtener scripts y opciones adicionales
para BitchX en http://www.phantasy.com/~markm/bitchx y
http://scripts.bitchx.com. Está disponible tanto en rpm
como en deb, tgz y código fuente, siendo éste último el
más recomendable si deseamos habilitar el soporte para
la fuente con caracteres en castellano o LATIN1.
<p>
 Aunque por su nombre y la X final del mismo pudiera
parecer que es un programa para XWindow, en realidad
BitchX funciona en consolas de tipo texto o xterm,
con lo que no necesitaremos el entorno de ventanas X para
hacerlo funcionar (lo cual lo hace ideal para muchos usuarios).
BitchX incluye una serie de características que lo hacen
generalmente apreciado como cliente de IRC, gracias a opciones
como NickCompletion, inclusión de los scripts más utilizados
como comandos estándar del mismo, soporte multiventana (tanto
partida como en ventanas virtuales), soporte de colores
para distinguir los textos dirigidos a nosotros del resto
de frases, modo historia de todo lo escrito (es decir, que
se puede recorrer todo lo escrito mediante las teclas del
cursor arriba y abajo, pudiendo reentrar cualquier frase al
canal), tratamiento de la ventana como un buffer (con lo
cual se puede subir y bajar por la misma con <tt/AvPág/ y <tt/RePág/),
etc.
<p>
 Otra de sus principales características es que cuando
alguien trata de floodearnos (es decir, enviarnos mucho
texto muy rápidamente, tal vez tratando de molestarnos o
estropear nuestra conexión), BitchX lo tira automáticamente
de la conversación, además de incluir opciones de autoentrada
en canales si alguien nos tira del mismo.
<p>
 Asi pues, debe quedar claro que BitchX es uno de los clientes
de IRC más completos y funcionales, con muchos seguidores (aunque
también hay gente que no le gusta). Para iniciar BitchX se
hace, pues, desde la línea de comandos, indicándole en esta
el nickname que deseemos usar en el IRC, el servidor de IRC
y el puerto (esto último opcional), todo ello en formato
BitchX Nick Server:Puerto. Ejemplo:
<verb>
  [sromero@compiler BitchX]$ BitchX  Juan  irc.arrakis.es
</verb>
 Si no queremos especificar esto desde la línea de comandos
es posible utilizar variables de entorno que definan el
Nick, Servidor, y nombre del usuario para poder invocar al
cliente de IRC simplemente mediante BitchX. Para ello
BitchX proporciona al usuario la posibilidad de incluir
estos datos en las variables de entorno IRCNAME, IRCNICK e
IRCSERVER, tanto en ficheros de inicialización (.bashrc,
.profile) como en la línea de comandos, tal y como puede
verse en el siguiente ejemplo:
<verb>
  [sromero@compiler BitchX]$  export IRCNAME="Juan Sanchis"
  [sromero@compiler BitchX]$  export IRCNICK="JuanChis"
  [sromero@compiler BitchX]$  export IRCSERVER="irc.arrakis.es"
</verb>
 Además hay otros parámetros que podemos consultar en
la página man de BitchX, como la autoentrada en canales:
<verb>
  BitchX -c \#linux
</verb>


<!-- *********************************************************** -->
<!-- SUBSECCIÓN COMO OBTENER EL TECLADO EN CASTELLANO EN BITCHX  -->
<!-- *********************************************************** -->

<sect1>Como obtener el teclado en castellano en BitchX
<p>
 Si el BitchX que estamos usando no dispone de soporte para
caracteres latinos (acentos, eñes, etc.), podemos forzar a
BitchX a que los visualice correctamente editando el fichero
config.h de los fuentes del programa, habilitando (como
pone en el README del programa) la opción para LATIN1, y
recompilando el programa.


<!-- ******************************* -->
<!-- SUBSECCIÓN   COMANDOS DE BITCHX -->
<!-- ******************************* -->

<sect1>Comandos de BitchX
<p>
Con BitchX es perfectamente posible utilizar los comandos
básicos del IRC vistos el mes pasado mediante ircII, es
decir, /server, /quit, /join, /part, /query, etc.
<p>
 Aparte de estos, ahora sí que es posible la utilización del
comando /list para listar los canales del servidor de IRC.
Recordemos que este comando también estaba disponible en
ircII, pero la salida por pantalla era tan rápida que era
imposible ver los canales disponibles. En BitchX la salida
es igual de rápida, pero disponemos de las teclas AvPág
y RePág para subir y bajar en el buffer de la ventana, y
por tanto ver los canales una vez listados (o leer textos
anteriormente escritos en un canal, consultar algo que
dijimos, etc.).
<p>
 Una vez se entra a un canal (con /join #canal), es posible
ver la lista de operadores del canal mediante la tecla F2,
y la lista de usuarios mediante F3
(aunque sigue pudiendo usarse el comando /names #canal).
<p>
 Por último, y en cuanto a texto se refiere, cabe nombrar el
soporte de colores y estilos de BitchX. Por ejemplo, para
escribir un texto en negrita, basta con pulsar Ctrl+b (de
bold, resaltado), y despues escribir el texto en cuestión,
que aparecerá en negrita (ojo con esto pues los usuarios
de ircII no lo verán así), y para escribir frases en
colores, en cualquier punto de la frase puede utilizarse
Ctrl+C y a continuación introducir en la frase el número de
color (soltando Ctrl+C), con lo que aparecerá en el color
correspondiente. Ejemplo:
<verb>
  > Hola a <CTRl+C>2todos!
</verb>
Hará que aparezca "todos" en azul. Otros comandos que pueden.
utilizarse en BitchX son /shell (para ejecutar copias de
nuestra shell de comandos) /telnet (para hacer telnet a
cualquier servidor desde dentro de BitchX), y /ftp (para
hacer ftp desde el IRC), comandos no habituales en los
restantes clientes de IRC
<p>
 En BitchX también es posible la transferencia de ficheros
vía DCC, para ello se disponen del típico comando /dcc
send "nick fichero", del que ya disponíamos en ircII. La
novedad de BitchX es que incluye por defecto la opción de
aceptar todos los ficheros que te sean enviados, opción que
se puede cambiar mediante /dcc auto off, de tal modo que
cuando se nos envie un fichero, en lugar de ser aceptado
automáticamente se nos informará de esto y mediante la
tecla F5 se podrá obtener la lista de ficheros que nos son
enviados, para aceptar cualquiera de ellos si nos interesa.
<p>
 Otro comando importante es /set, que nos permitirá cambiar
parámetros de configuración de BitchX, como por ejemplo
desactivar el pitido que suena cuando nos hacen un Query
en otra ventana (/set beep off). Más información mediante
/help set o en la documentación del programa.


<!-- ************************************* -->
<!-- SUBSECCIÓN NICK COMPLETION EN BITCHX  -->
<!-- ************************************* -->

<sect1>Nick Completion en BitchX
<p>
 Una de las cosas más molestas en el IRC al haber diferentes
personas en un canal y querer referirnos a una de ellas
suele ser escribir el nombre del mismo, pues la mayoría
de nombres en el IRC contienen carácteres extraños, son
combinaciones de mayúsculas y minúsculas, o simplemente,
puede apetecernos no escribir dicho nombre pero que esa
persona sepa que le hablamos a ella. Para ello BitchX
incorpora una funcionalidad conocida como Nick Completion,
o completado de nicks, que consiste en que al pulsa la
combinación de teclas CTRL+R, BitchX tratará de completar
el nick que hayamos comenzado a escribir en la línea de
comandos, esta tecla puede usarse en cualquier momento de
la frase, y sus efectos se pueden observar en el siguiente
ejemplo. Supongamos que existe un usuario en el IRC llamado
AvIaToR, al cual queremos contestar o comentarle algo:
<verb>
  > Av<CTRL+R>: Como estas?
  > Ya te lo he dicho antes, Av<CTRL+R>...
</verb>
Estas 2 frases se expanderán automáticamente a:
<verb>
  > AvIaToR: Como estas?
  > Ya te lo he dicho antes, AvIaToR...
</verb>
 Otra posibilidad es utilizar la combinación de teclas
Control más la tecla de '+' (<tt>Ctrl+'+'</tt>), que al principio
de una frase completa el nick que hayamos comenzado a
escribir y lo completa con 2 puntos (:), para dirigir frases
directamente a cualquier usuario:
<verb>
  > Av<CTRL+'+'> lo estoy buscando...
</verb>
Se expande a: 
<verb>
  > AvIaToR: lo estoy buscando...
</verb>
Una última posibilidad es la utilización de la tecla TAB al
principio de una frase, que se expanderá a un /msg Nick,
donde Nick será uno de los usuarios del canal y cambiará
dependiendo del número de veces que sea pulsada (una vez,
aparece el primer usuario, otra vez, el segundo, etc.).
Esto nos permitirá enviar mensajes con relativa facilidad a
cualquier usuario del canal.


<!-- **************************************** -->
<!-- SUBSECCIÓN BITCHX: SOPORTE MULTIVENTANA  -->
<!-- **************************************** -->

<sect1>BitchX: Soporte multiventana
<p>
 Una de las características principales de BitchX es el
soporte multiventana nativo. Al igual que en ircII,
es posible entrar en varios canales o conversaciones
simultáneamente, y que aparezcan todos ellos en la ventana
principal de BitchX, con una indicación al principio de
cada uno de ellos que nos indique de qué canal viene cada
frase. Esto es muy molesto y bastante inviable, y además
solo hay un canal activo (al que va el texto que escribimos)
que podemos cambiar mediante la tecla CTRL+X (con lo que
irá cambiando entre los diferentes canales a cada pulsación
de la misma).
<p>
 Para evitar esto BitchX incluye soporte
multiventana tanto en pantalla partida como en ventanas
virtuales, es decir, es posible partir la pantalla en
diferentes secciones y disponer de un canal o un query en
cada una de ellas, así como crear diferentes pantallas
virtuales (de la que sólo vemos una, la visible) y cambiar
entre ellas, con lo que dispondríamos de una ventana aislada
para cada canal, y el texto no se mezclaría.
<p>
 Para partir la pantalla es posible utilizar el comando
/window new, y para crear una pantalla virtual (mucho más
recomendable) se utiliza el comando /window new hide. Este comando
puede ser utilizado tantas veces como pantallas virtuales se
deseen, de tal modo que irán siendo numeradas desde el 2 (la 1 es
la pantalla que aparece por defecto) hasta n (donde n es
el número de pantallas creadas). Una vez se han creado las
diferentes ventanas es posible cambiar entre ellas mediante
ALT+nº (ALT+1, ALT+2, etc.) en la consola de texto
o mediante ESC-nº si estamos en XWindow (en este último caso,
no consiste en pulsar ambas teclas simultáneamente sino en
pulsar ESC, liberar la tecla y pulsar un número de la fila
superior de números, no del teclado numérico).
<p>
 De esta forma, si deseamos disponer de 3 ventanas virtuales,
con el canal #linux en la primera, #programación en la segunda,
y una conversación privada en la tercera, es posible hacer lo
siguiente:
<verb>
  > /window new hide
  > /window new hide
  > /join #linux
  > ALT+2 o ESC-2
  > /join #programacion
  > ALT+3 o ESC-3
  > /query JuanChis
</verb>
 Una vez hecho esto dispondremos de las 3 ventanas creadas
y ya podremos ir a cualquiera de ellas a decir las frases
relativas a cada canal, sin que las salidas se mezclen en
pantalla ya que BitchX nos separará la salida de las mismas
a cada canal. Se puede decir, pues, que cada comando /join,
/part o /query se aplica a la pantalla virtual que tengamos
activa en ese momento. A continuación se ofrece un extracto
de la ayuda en línea proporcionada por BitchX para el uso de
combinaciones de teclas y la diferentes opciones relativas
a ventanas (tanto secciones de pantallas partidas como
ventanas virtuales):
<verb>
  > Control+W+'-' = Hace la sección actual una línea más estrecha.
  > Control+W+'+' = Hace la sección actual una línea más ancha.
  > Control+W+l     = Lista las ventanas disponibles.
  > Control+W+k    = Elimina la ventana/sección actual.
  > Control+W+h    = Oculta la ventana/sección actual.
  > Control+W+b    = Iguala el tamaño de las secciones.
  > Control+W+n    = Cambia a la ventana siguiente.
  > Control+W+p    = Cambia a la ventana anterior.
</verb>
 Aparte de estas teclas, están disponibles AvPág y RePág
para moverse por el buffer de cualquier ventana y los
cursores arriba y abajo para recuperar frases anteriormente
escritas.


<!-- ******************************************* -->
<!-- SUBSECCIÓN  COMO UTILIZAR SCRIPTS EN BITCHX -->
<!-- ******************************************* -->

<sect1>Como utilizar scripts en BitchX
<p>
 Para utilizar scripts en BitchX (funciones y comandos nuevos
para un cliente de IRC), tan sólo hay que copiarlos en el
directorio .BitchX y cargarlos luego en el programa mediante
/load script, teniendo el comando disponible a partir de
ese momento. Lo importante de BitchX es que los scripts
pueden proporcionar un aspecto diferente al entorno del
programa, al ser este totalmente programable, con lo que las
posibilidades de BitchX son realmente ilimitadas.
<p>
 Los scripts se pueden obtener a partir de la página Web
del propio programa, http://www.bitchx.com o en
http://scripts.bitchx.com.


<!-- *************************************** -->
<!-- SUBSECCIÓN INSTALAR UN SERVIDOR DE IRC  -->
<!-- *************************************** -->

<sect1>Instalar un servidor de IRC
<p>
 Mediante Linux no sólo podemos conectarnos a los IRC
existentes (como el IRC Hispano, por ejemplo) utilizando
clientes de irc, sino que también es posible obtener
*servidores* de IRC para convertir nuestra máquina en
punto de encuentro de amiguetes o usuarios varios. Para
ello simplemente hay que obtener, instalar y configurar
un servidor de IRC en nuestra máquina, como ircd. La
versión que utiliza el autor es la 10.02, (fichero
ircu2.10.02-LinuxELF.tar.gz, ver
http://www.argo.es/~jcea/irc/ircd.html, una estupenda
página sobre redes e IRC), que consiste en un fichero tar.gz
descomprimible con «tar -xvzf ircu2.10.02-LinuxELF.tar.gz»,
con los siguientes ficheros:
<verb>
  [sromero@compiler ircd]$ ls
  Authors       LICENCE       config.h      ircd*
  ircd.motd     ircd.rehash*  INDEX         README
  example.conf  ircd.conf     ircd.off*     remote.motd
</verb>
 (pueden cambiar según versiones, y también está disponible
en formato deb y rpm en los sites correspondientes).
<p>
Una vez descomprimido (aunque también están disponibles las
fuentes para compilar el programa adaptándolo a nuestras
necesidades), y como se comenta en el README del programa,
basta con editar el fichero de configuración ircd.conf y
adaptarlo a las funcionalidades necesarias, para luego
ejecutar el daemon ircd. Esto se hace mediante la
ejecución del programa con el comando./ircd, y como un
usuario que no sea root, preferentemente llamado irc)
para realizar la inicialización del daemon, y así permitir
hasta 252 conexiones a nuestro sistema. Lo más recomendable
es instalar la versión rpm (o deb, conviertiendola mediante
alien) creando previamente un usuario llamado irc (con
adduser) y cambiando su password a nada (a una cadena vacía,
editando <tt>/etc/passwd</tt> o mediante el comando passwd), haciendo lo
siguiente:
<verb>
  [sromero@compiler ircd]$  adduser irc
  [sromero@compiler ircd]$  rpm -i  ircd.rpm
</verb>
 Para finalizar el uso del daemon de irc basta con ejecutar
el script ircd.off. Este rpm (creado por Pablo Saratxaga,
habitual de es.comp.os.linux) puede obtenerse de la
Web de S.u.S.E (www.suse.com), entrando en su FTP, o
desde cualquiera de sus mirrors:
ftp://ftp.tu-chemnitz.de/pub/linux/suse/5.3/i386.de/suse/n1/
(fichero ircd.rpm), así como en los FTPs de las otras
distribuciones Linux (Redhat, Debian, etc.). La versión
empaquetada por Pablo Saratxaga dispone además
del fichero ircd.conf correctamente configurado para el
servidor de IRC, y tan sólo habremos de modicarlo si
queremos que ircd corra en una red de servidores. Otro
fichero interesante es ircd.motd, que nos permitirá
variar el mensaje a la entrada de nuestro IRC. Una vez
instalado el daemon/servidor de irc, es posible
testear nuestro servidor accediendo a nuestra propia
máquina:
<verb>
  [sromero@compiler ircd]$  irc  Juan  localhost:6667
</verb>
 Si todo está correctamente instalado será posible entrar
en diferentes consolas virtuales y repetir el proceso para
tener varios usuarios en nuestro IRC. Ya sólo nos falta,
pues, editar el fichero ircd.conf para dotar a nuestro irc
de los canales, comandos y datos que tengamos pensados para
él, y dar nuestra dirección IP a las personas que queramos
que se conecten al mismo.

<!-- *************************************** -->
<!-- *************************************** -->
<!--   SECCIÓN BASH-SHELL/COMANDOS BASICOS   -->
<!-- *************************************** -->
<!-- *************************************** -->

<sect>Bash shell/Comandos básicos

<!-- *************************************** -->
<!--  SUBSECCIÓN QUE ES UN SHELL             -->
<!-- *************************************** -->

<sect1>¿Qué es un shell? / Historia sobre Bash
<p>
<bf>¿Qué es un shell?</bf>
<p>
Lo que ocurre internamente en tu ordenador cuando este ejecuta una acción, 
tal como, leer un fichero, grabar un documento, acceder al CD-Rom o ejecutar 
un programa, es un proceso bastante complicado y que requiere una serie de 
acciones por parte de tu sistema operativo. Por si esto no es suficiente, necesitamos 
también, una manera de poder comunicarnos con nuestro sistema operativo para decirle que 
es lo que queremos hacer. Es aqui donde un intérprete de comandos (shell) hace su trabajo.
<p>
Un shell o intérprete de comandos es el proceso encargado de traducir los 
comandos que los usuarios introducen, a instrucciones que el sistema operativo 
entiende. Es el programa que se encuentra entre el sistema operativo y el usuario 
,el cual nos hace la vida mas fácil. 
<p>
Todo usuario que quiera profundizar en un sistema Unix/linux tendrá más tarde ó temprano
que familiarizarse con el shell de su sistema, el cual se convertirá en una herramienta
imprescindible en la administración diaria del sistema, tanto por su potencia como versatilidad.
<p>
<bf>NOTA</bf>: En esta sección nos centraremos en el intérprete de comandos llamado BASH, por ser uno de
los más extendidos, usado por defecto en muchas distribuciones linux, así como potente y fiable
(Puede que esta afirmación, no sea compartida por algunos usuarios ;-). Si tú eres uno de ellos, 
colabora con esta Faq y mándame una sección, con por ejemplo, informacion sobre C-shell (csh/tcsh) ó
Korn-shell (ksh), te aseguro que será publicada).
<p>
<bf>Historia sobre bash</bf>
<p>
El "Bourne Again shell" (Bash) fue creado para usarlo en el proyecto 
<url url="http://www.gnu.org" name="GNU">. La intención fue que fuese el
intérprete de comandos estandar en el sistema GNU. "Nació" oficialmente el
domingo, 10 de enero de 1988. Brian Fox fué quien programó las primeras versiones de Bash
y continuó actualizándolo hasta 1993. A principios de 1989, Chet Ramey empezó a ayudar a 
Brian y fué el responsable de muchos arreglos en el código y nuevas características.
<p>
Chet Ramey es ahora el mantenedor oficial del shell bash sindo la última versión la 2.x.


<!-- **************************************** -->
<!--  SUBSECCIÓN FICHEROS CONFIGURACIÓN BASH  -->
<!-- **************************************** -->

<sect1>/etc/profile, .bash_profile, .bashrc, .bash_logout
<p>
Existen tres ficheros en el directorio de un usuario que tienen un significado 
especial para el shell Bash. Estos ficheros permiten al usuario configurar el entorno 
de su cuenta automaticamente cuando entra en el sistema, cuando arranca un subshell 
o ejecutar comandos cuando sale del sistema.
<p>
Los nombres de estos ficheros son <tt>.bash_profile</tt>, <tt>.bashrc</tt> y <tt>.bash_logout</tt>. 
Si ninguno de estos ficheros existe en el directorio del usuario, <tt>/etc/profile</tt> 
es utilizado por el sistema como fichero de configuracion de bash.
<p>
<tt><bf>.bash_profile</bf></tt> es el el mas importante de los tres. Es leido y los comandos incluidos en el, 
ejecutados, cada vez que el usuario entra en el sistema. Cualquier cambio hecho en este fichero 
no tendra efecto hasta que salgamos y entremos en el sistema de nuevo. Una alternativa para no 
tener que salir del sistema es ejecutar el comando <tt>source .bash_source</tt>.
<p>
Bash permite dos sinonimos para este fichero, <tt>.bash_login</tt> (derivado del C shell) 
y <tt>.profile</tt> (derivado del Bourne y Korn shell). Si <tt>.bash_profile</tt> no existe, 
el sistema buscara primero <tt>.bash_login</tt> y luego <tt>.profile</tt>. Solamente 
uno de estos ficheros es leido, en el caso que existan simultaneamente.
<verb>
   # .bash_profile

   # Get the aliases and functions
   if [ -f ~/.bashrc ]; then
           . ~/.bashrc
   fi

   # User specific environment and startup programs

   BASH_ENV=$HOME/.bashrc
   USERNAME=""
   PATH=$PATH:/usr/local/pgsql/bin
   MANPATH=$MANPATH:/usr/local/pgsql/man
   PGLIB=/usr/local/pgsql/lib
   PGDATA=/usr/local/pgsql/data

   export USERNAME BASH_ENV PATH MANPATH PGLIB PGDATA
</verb>
<p>
<tt><bf>.bashrc</bf></tt> es leido cuando el usuario arranca un subshell, escribiendo por 
ejemplo <tt>bash</tt> en la linea de comandos. Esto nos permite ejecutar diferentes 
comandos para la entrada al sistema o para la ejecucion de un subshell. Si el usuario necesita 
los mismos comandos tanto a la entrada como en subshells, podemos incluir la siguiente linea en 
<tt>.bash_profile</tt>:
<verb>
    source .bashrc
</verb>
<p>
<verb>
   # .bashrc

   # User specific aliases and functions

   alias ll="ls -l --color"
   alias lal="ls -la --color"
   alias faq="cd /home/rafael/EL_RINCON/FAQ/"
   alias php="cd /home/rafael/EL_RINCON/PHP/"

   # Source global definitions
   if [ -f /etc/bashrc ]; then
           . /etc/bashrc
   fi
</verb>
 
<tt><bf>.bash_logout</bf></tt> es el fichero leido por Bash, cuando salimos del sistema. Podemos definir, 
por ejemplo que se borren los ficheros temporales creados en nuestra ultima sesion o registrar el 
tiempo que hemos estado utilizando el sistema. Si <tt>.bash_logout</tt> no existe, ningun comando 
sera ejcutado a nuestra salida.
<verb>
   # ~/.bash_logout

   clear
</verb>


<!-- *************************************** -->
<!--  SUBSECCIÓN PERO HAY QUE SABER COMANDOS -->
<!-- *************************************** -->

<sect1>¿Pero hay que saber comandos?
<p>
La respuesta a esta pregunta es sencilla, todo depende de como vayas a utilizar 
el sistema, de las ganas de aprender que tengas y de lo que quieras profundizar en el sistema.
<p>
Hay que diferenciar entre <em/tareas de administración/ y <em/uso habitual del sistema/.
<p>
Si vas a realizar tareas de administración del sistema, deberias saber, o mejor dicho, 
tendrás que aprender una serie de comandos para realizar estas tareas. Si vas a utilizar 
el sistema a nivel usuario, no necesitaras saber ningún comando, solamente tendras que 
aprender a utilizar los programas que uses.
<p>
Lo que ocurre habitualmente es que el usuario de la máquina y el administrador, son la misma 
persona, con lo cual tendrán que saber una serie de comandos mínimos.
<p>
Como anecdota, os puedo contar que en lugar donde trabajo, hay usuarios que utilizan Linux 
y no tienen ni idea de administración del sistema (y no solo en linux), no saben comandos y 
tampoco los necesitan. Trabajan en modo gráfico, saben utilizar los programas que necesitan 
y tienen a alguien (yo en este caso ;-)) que se hace cargo de las tareas de 
administración/configuración del sistema.


<!-- *************************************** -->
<!-- ESTO NO LO PUEDO HACER EN MODO GRAFICO  -->
<!-- *************************************** -->

<sect1>¿Esto no lo puedo hacer en modo gráfico?
<p>
Como regla general, se podriía decir lo siguiente: <em/"Todo lo que se puede 
hacer en modo gráfico, se puede hacer también en modo texto, a base de comandos. 
Pero no todo lo que se puede hacer en modo texto, se puede hacer en modo gráfico/".
<p>
Cada día aparecen más y más programas, que permiten hacer en modo gráfico, a golpe 
de ratón y ventanas, lo que se hace en modo texto a base de comandos. Es mas, lo único 
que estos programas hacen, es crear una versión gráfica que hace uso de los comandos 
que se utilizan en modo texto. Gestores de vaentanas como Gnome y Kde, vienen con una 
serie de programas gráficos que hacen esto.
<p>
Para terminar esta sección, solo decir a aquellos que quieran profundizar en el sistema, 
que hasta el momento, ningun programa gráfico, supera en versatilidad y potencia, a 
una consola de texto donde ejecutar comandos directamente.

<!-- ********************************************* -->
<!-- SUBSECCIÓN COMBINACIONES ESPECIALES DE TECLAS -->
<!-- ********************************************* -->

<sect1>Combinaciones especiales de teclas
<p>
<itemize>
<item><tt>[Ctrl]+[Alt]+[Del]</tt>: Shutdown. Apaga el sistema de forma organizada desde una terminal texto. 
<p>
<item><tt>[Ctrl]+[Alt]+[F1]</tt>: Cambia a la primera terminal de texto.
<p>
<item><tt>[Ctrl]+[Alt]+[Fn]</tt>: Cambia a la terminal de texto numero <tt>n (n=1,...,6)</tt>
<p>
<item><tt>[Ctrl]+[Alt]+[F7]</tt>: Cambia a la primera terminal X (si se esta usando alguna)   &nl   
<p>
NOTA:Si estamos en XWindow y por alguna razón nuestro entorno gráfico dejase de funcionar, siempre podriamos entrar en una terminal texto con <tt>[Ctrl]+[Alt]+[Fn]</tt>, terminar los procesos que esten dando problemas y volver a las X con <tt>[Ctrl]+[Alt]+[F7]</tt>.
<p>
<item><tt>[Ctrl]+[Alt]+[Fn]</tt>: Cambia a la terminal X numero <tt>n (n=7,...,11)</tt>
<p>
<item><tt>[Tab]</tt>: Autocompleta el nombre de un comando, fichero, directorio, programa, cuando trabajamos en una terminal texto. P.ej: Si vamos a usar el programa "programa_de_prueba", podemos escribir progr y pulsar <tt>[Tab]</tt>, el sistema se encargará de rellenar el resto. 
<p>
<item><tt>[ArrowUp]</tt>: (Flecha arriba) Va editando la historia de comandos que hemos escrito anteriormente en terminal texto.<tt>[Enter]</TT> para ejecutar. 
<p>
<item><tt>[Shift][PgUp]</tt>: Scroll la salida de la terminal hacia arriba, en terminal texto. 
<p>
<item><tt>[Shift][PgDown</tt>: Scroll la salida de la terminal hacia abajo, en terminal texto.
<p>
<item><tt>[Ctrl]+c</tt>: Termina el proceso actual. Cuando lo comenzamos sin &amp (<tt>[localhost]&dollar proceso</tt>)
<p>
<item><tt>[Ctrl]+d</tt>: Termina la terminal actual.
<p>
<item><tt>[Ctrl]+s</tt>: Para la transferencia a la terminal.
<p>
<item><tt>[Ctrl]+z</tt>: Manda el proceso actual (comenzado sin &amp) a "Background". Lo mismo que si comenzamos el proceso con &amp (<tt>[localhost]&dollar proceso &amp</TT>).

</itemize>


<!-- ********************************************* -->
<!-- SUBSECCIÓN COMANDOS - INFORMACIÓN DEL SISTEMA -->
<!-- ********************************************* -->

<sect1>Lista de comandos mas usados
<p>
Todos los comandos citados en este apartado, pueden usarse con multitud de opciones. Para conseguir información detallada de cada comando utilizar <tt>man <em>comando</em></tt>. A continuación teneis la manera mas sencilla de utilización.
<p>
<bf/Información del sistema/
<itemize>
<item><tt>hostname</tt>: Devuelve el nombre de la máquina. 
<p>
<item><tt>uptime</tt>: Devuelve la cantidad de tiempo trascurrido desde la ultima vez que se arranco el sistema, la cantidad de usuarios trabajando en el sistema y el load average (carga del sistema).
<p>
<item><tt>uname -a</tt>: Información sobre el sistema operativo de la maquina. 
<p>
<item><tt>dmesg|more</tt>: Imprime el "ring buffer" del kernel.
<p>
<item><tt>free -tm</tt>: Información sobre la cantidad de memoria disponible y usada. 
<p>
<item><tt>df -h</tt>: Información sobre todo los dispositivos montados en la máquina.
<p>
<item><tt>du -bh /|more</tt>: Información sobre el espacio ocupado por cada subdirectorio, comenzando en el directorio raiz /.
<p>
<item><tt>ps</tt>: Información sobre los procesos del actual usuario, que se estan ejecutando.  
<p>
<item><tt>ps axu</tt>: Información sobre todos los procesos que se estan ejecutando en la máquina. 
<p>
<item><tt>top</tt>: Información sobre el uso de cpu y memoria de los procesos del sistema.
<p>
<item><tt>cat /proc/cpuinfo</tt>: Información sobre el microprocesador.
<p>
<item><tt>cat /proc/interrupts</tt>: Información sobre las interrupciones en uso.
<p>
<item><tt>cat /proc/dma</tt>: Información sobre dma en uso.
<p>
<item><tt>cat /proc/filesystems</tt>: Información sobre los sistemas de archivos que se pueden utilizar (compilados en el kernel).
<p>
<item><tt>/sbin/lsmod</tt>: Información sobre los modulos en uso. 
<p>
<item><tt>finger <em>usuario</em></tt>: Información sobre el usuario <em>usuario</em>.
<p>
<item><tt>who</tt>: Información sobre los usuarios usando el sistema.
<p>
<item><tt>id <em>usuario</em></tt>: Información sobre UID, GID y GROUPS del usuario <em>usuario</em>
<p>
<item><tt>last</tt>: Información sobre los ultimos usuarios que han usado el sistema. 
<p>
<item><tt>set|more</tt>: Información sobre el entorno de usuario actual.
<p>
<item><tt>ping <em>maquina</em></tt>: Para comprobar si tenemos contacto con la máquina <em>maquina</em> (<em>maquina</em>: nombre o IP)
<p>
<item><tt>/sbin/route</tt>: Tabla de enrutamiento de nuestro sistema.
<p>
<item><tt>/sbin/ifconfig</tt>: Información sobre los distintos dispositivos de red
<p>
<item><tt>netstat</tt>: Información valiosa sobre la conexión de red (Este comando tiene muchas posibilidades, ejecutar <tt>man netstat</tt>

</itemize>
<p>
<bf/Administracion/

<itemize>
<item><tt>su</tt>: Te conviertes en administrador(root) despues de introducir la clave de acceso. Ideal para realizar alguna tarea de administración sin necesidad de salir del sistema y entrar de nuevo como root.
<p>
<item><tt>/usr/sbin/adduser <em>usuario</em></tt>: Registra y crea una cuenta de usuario. 
<p>
<item><tt>/usr/sbin/userdel <em>usuario</em></tt>: Borra la cuenta de usuario <em>usuario</em>.  
<p>
<item><tt>passwd</tt>: Cambia la clave de acceso para el usuario actual. Root puede cambiar la clave de cualquier usuario <tt>passwd <em>usuario</em></tt>
<p>
<item><tt>/usr/sbin/groupadd <em>grupo</em></tt>: Crea un nuevo grupo.
<p>
<item><tt>/usr/sbin/groupdel <em>grupo</em></tt>: Borra un grupo.
<p>
<item><tt>more /etc/passwd</tt>: Muestra el fichero de claves del sistema. (Si no se usa shadow password) 
<p>
<item><tt>more /etc/group</tt>: Muestra los grupos registrados en el sistema.
<p>
<item><tt>chmod <em>permisos fichero/directorio</em></tt>: Cambia los permisos de ficheros/directorios 
<p>
<item><tt>cp <em/fichero1 fichero2/</tt>: Copia fichero1 como fichero2  
<p>
<item><tt>rm <em/fichero/</tt>: Borra fichero  
<p>
<item><tt>rm -R <em/directorio/</tt>: Borra el contenido completo (ficheros/subdirectorios) de directorio
<p>
<item><tt>mv <em/fichero1 fichero2/</tt>: Cambia el nombre de fichero1 a fichero2 
<p>
<item><tt>mkdir <em/directorio/</tt>: Crea un subdirectorio
<p>
<item><tt>rmdir <em/directorio/</tt>: Borra un subdirectorio
<p>
<item><tt>shutdown -t3 -r now</tt>: Reinizializa el sistema (hay que hacerlo como root).
<p>
<item><tt>shutdown -t3 -h now</tt>: Apaga el sistema (hay que hacerlo como root).

</itemize>


<!-- ********************************* -->
<!-- ********************************* -->
<!-- SECCIÓN PROBLEMAS -->
<!-- ********************************* -->
<!-- ********************************* -->

<sect>¿Problemas diversos?


<!-- ******************************** -->
<!-- SUBSECCIÓN QUIEN ME PUEDE AYUDAR -->
<!-- *********************************-->

<sect1>¿Quien me puede ayudar a resolver un problema?
<p>
Lo mejor que se puede hacer para encontrar solución a un problema con linux es leer, 
leer la documentación existente. En la siguiente subsección teneis información 
sobre donde encontrar documentación.
<p>
Si despues de leer la documentación, sigues sin poder solucionar tu problema, 
te aconsejamos que mandes un mensaje a alguna lista de correos o a un grupo de noticias, 
que trate sobre linux. 
<p>
<itemize>
<item>
Información sobre diferentes listas de correo sobre linux, se puede encontrar en 
<url url="http://www.linux-es.com/listas.php" name="http://www.linux-es.com/listas.php">.
<p>
<item>
Información sobre diferentes grupos de noticias sobre linux se puede encontrar en 
<url url="http://www.linux-es.com/news.php" name="http://www.linux-es.com/news.php">. 
Los grupos de noticias en castellano <tt/es.comp.os.linux.instalacion, es.comp.os.linux.misc, 
es.comp.os.linux.programacion, es.comp.os.linux.redes/ es uno de los mejores sitios 
para conseguir ayuda. Existen unas páginas con información sobre estos grupos de noticias 
en <url url="http://www.linux-es.com/es.comp.os.linux.*/" name="http://www.linux-es.com/es.comp.os.linux.*/">.
</itemize>
<p>
Como nota adicional decir que, si has comprado una distribución de Linux, existen varias 
(RedHat, SuSE, OpenLinux, Hispafuentes ...) que dan soporte de instalación por un periodo de tiempo determinado.


<!-- **************************************** -->
<!-- SUBSECCIÓN DONDE ENCUENTRO DOCUMENTACIÓN -->
<!-- **************************************** -->

<sect1>¿Dónde encuentro documentación sobre linux? <label id="documentacion">
<p>
Existe un proyecto de documentación de Linux (LDP), que se encarga de coordinar/distribuir 
todos los documentos existentes sobre linux y temas relacionados, los famosos manuales, 
Howtos y Mini-Howtos.
<p>
<itemize>
<item><bf/En castellano/ tenemos a <url url="http://lucas.hispalinux.es/" name="Lucas"> e 
<url url="http://www.insflug.org/" name="Insflug">, dos proyectos que se dedican a la 
creación de documentación en castellano y a la traducción de los documentos en ingles del LDP.
<p>
<item><bf/En ingles/ tenemos el <url url="http://metalab.unc.edu/LDP/" name="Linux Documentation Project (LDP)">.
<p>
<item>En <url url="http://www.linux-es.com/documentacion.html" name="http://www.linux-es.com/documentacion.html"> 
teneis un mirror (copia espejo) de todos estos documentos.

</itemize>


<!-- ******************************************* -->
<!-- SUBSECCIÓN MI QUIPO USA TODA LA MEMORIA     -->
<!-- ******************************************* -->

<sect1>Mi ordenador usa siempre toda la memoria disponible ¿Qué es lo que ocurre? 
<p>
Una pregunta habitual de los que comienzan a usar Linux, es ¿Porqué mi equipo 
usa siempre toda la memoria disponible incluso cuando solamente estoy usando unos pocos 
programas?.
<p>
En un principio, puede parecer un fallo del sistema, el cual esta usando toda la 
memoria, cuando no estamos usando muchos programas. Pero la respuesta a esta pregunta es 
sencilla, Linux aprovecha al maximo el harware de tu ordenador, y no existe ningún 
problema cuando siempre estas usando toda la memoria. ¿Pórque desperdiciar memoria libre 
que se puede utilizar para hacer funcionar tu sistema mas rápido?.
<p>
Un pequeño ejemplo nos aclarara las cosas. Si tienes 96MB y solo necesitas 
usar 32MB para los programas que estas ejecutando, Linux utilizará la memoria 
restante como buffers y caché para que las cosas funcionen mas rápidas y automáticamente y 
reducirá/ajustará los valores "buff", "shared" y "cached" cuando necesitemos mas memoria para ejecutar 
nuestros programas.
<p>
Aquí teneis un ejemplo conseguido con <tt>top</tt> despues de un rato de uso en un ordenador 
con X, un par de terminales en uso, Netscape y Emacs:
<verb>
   Mem:   95568K av,  93208K used,   2360K free,  21368K shrd,   8300K buff
   Swap: 136512K av,   5716K used, 130796K free                 60364K cached
</verb>
Unos momentos despues, cerramos Netscape:
<verb>
   Mem:   95568K av,  87884K used,   7684K free,  10544K shrd,   8308K buff
   Swap: 136512K av,   5704K used, 130808K free                 60528K cached
</verb>
y para terminar, abrimos netscape y Acrobad reader:
<verb>
   Mem:   95568K av,  93176K used,   2392K free,  26328K shrd,   3336K buff
   Swap: 136512K av,   5340K used, 131172K free                 64064K cached
</verb>
Como podeis observar, los valores "buff", "shared" y "cached" se van ajustando automáticamente 
a las necesidades de memoria del momento. Asi que no preocuparos si veis que la memoria 
en uso es practicamente la totalidad de la memoria disponible.

<!-- ******************************************* -->
<!-- SUBSECCIÓN SIGNAL 11                        -->
<!-- ******************************************* -->

<sect1>Fatal signal 11
<p>
No es la primera vez que un usuario recibe este mensaje de error "Fatal signal 11", 
al intentar instalar Linux o compilar un programa grande (kernel, gcc, glibc, ...). 
<p>
Las consecuencias de este error suelen ser graves, si te ocurre en la instalacion, no 
podras terminar de instalar el sistema y si te ocurre compilando un programa, no podras 
terminar de compilarlo y consecuentemente, no podras utilizarlo. A veces puede ser el 
causante de una caida del sistema y que el sistema se cuelgue.
<p>
La causa de este error suele ser un fallo del hardware de tu sistema, memoria, caché, 
CPU, disco, las causas pueden ser muchas y variadas. Existe un documento excelente y 
muy extenso sobre este problema, eso si en ingles. Lo podeis encontrar en 
<url url="http://www.bitwizard.nl/sig11/" name="http://www.bitwizard.nl/sig11/">.


<!-- ********************************* -->
<!-- ********************************* -->
<!--        SECCIÓN GLOSARIO           -->
<!-- ********************************* -->
<!-- ********************************* -->

<sect>Glosario de terminos
<p>
Esta sección tiene un pequeño glosario de terminos informaticos usados 
habitualmente por usuarios de Linux.


<!-- **************************************** -->
<!--     SUBSECCIÓN GLOSARIO A-D           -->
<!-- **************************************** -->

<sect1>Glosario A-D
<P>
<itemize>
<item>
<bf>Alan Cox</bf>: Junto con Linus Torvalds, unos de los desarrolladores mas activos del kernel.

<p><item>
<bf>Alpha</bf>: La computadora de arquitectura RISC (<em>R</em>educed
<em>I</em>nstruction <em>S</em>et <em>C</em>omputer) (Computadora con juego
de instrucciones reducido) desarrollada por Digital Equipment
Corporation.

<p><item>
<bf>Aplique</bf>: Normalmente se trata de un pequeño programa diseñado 
para ser ejectuado empotrado en otro programa anfitrión.

<p><item><bf>Applet</bf>: Inglés. Vea «aplique».

<p><item><bf>Arranque dual</bf>: El acto de configurar un ordenador para
que pueda arrancar más de un sistema operativo.  El nombre es algo
confuso, pues es posible arrancar más de dos sistemas operativos, a
diferencia de lo que implica la palabra «dual».  En inglés:
«<em>Dual Boot</em>».

<p><item><bf>Arranque</bf>: Proceso por el cual un ordenador comienza a
ejecutar un sistema operativo cuando se le aplica la energía de
alimentación. En inglés: «<em>bootstrap</em>» o más comúnmente
«<em>boot</em>».

<p><item><bf>ATAPI</bf>: Sigla de <em>AT</em> <em>A</em>ttachement
<em>P</em>acket <em>I</em>nterface  (interfaz de paquetes para conectar a AT).  ATAPI es
el protocolo mediante el cual las unidades de CD-ROM se comunican con
la computadora sobre la interfaz IDE.

<p><item><bf>Biblioteca</bf>: Cuando se habla de ordenadores, se refiere al
conjunto de rutinas que realizan las operaciones usualmente requeridas
por los programas.  Las bibliotecas pueden ser compartidas, lo que
quiere decir que las rutinas de la biblioteca residen en un fichero
distinto de los programas que las utilizan.  Las rutinas de biblioteca
pueden «enlazarse estáticamente» al programa, en cuyo caso se agregan
físicamente las copias de las rutinas que el programa necesita.  Estos
binarios enlazados estáticamente no requieren de la existencia de ningún
fichero de biblioteca para poder funcionar.  Los programas enlazados
con bibliotecas compartidas no funcionarán a menos que se instalen las
bibliotecas necesarias.  En inglés: «library».

<p><item><bf>Binario</bf>: Aunque se denomina binario al sistema de
numeración en base dos que usan las computadoras, con frecuencia la
palabra se refiere a la forma ejecutable de un programa.  Lo contrario
a «código fuente».  En inglés: «<em>binary</em>».

<p><item><bf>Binary</bf>: Inglés, vea «binario».

<p><item><bf>BIOS</bf>: Sigla de <em>B</em>asic
<em>I</em>nput/<em>O</em>utput <em>S</em>ystem (sistema de entrada/salida
básico).  En los sistemas compatibles con PC, el BIOS se utiliza para
realizar todas las funciones necesarias para colocar en estado inicial
el hardware del sistema cuando se lo conecta a la alimentación de
energía.  El BIOS controla el proceso de arranque, proporciona rutinas
de entrada/salida de bajo nivel (de aquí su nombre) y (usualmente)
permite que el usuario modifique los detalles de la configuración del
hardware del sistema.

<p><item><bf>Boot Diskette</bf>: Inglés, vea «disquete de arranque».

<p><item><bf>Boot</bf>: Abreviatura de «bootstrap».  Vea «arranque».

<p><item><bf>Bootstrap</bf>: Inglés, vea «arranque».

<p><item><bf>Cabeza</bf>: Cuando se refiere a unidades de disco, la cantidad
de cabezas de una unidad de disco.  En cada platina de una unidad de
disco, hay dos cabezas -- una en cada superficie -- aunque una de las
superficies no se utilice.  En inglés: «<em>head</em>».  Vea también
«geometría». 

<p><item>
<bf>Carga del sistema</bf>: Es una medida que nos indica la carga que 
estan produciendo los procesos que estan usando la CPU en un momento 
determinado. Si ejecutamos un solo proceso que consuma el 50% de CPU 
tendriamos una carga de 0.50. Si ejecutamos un solo proceso que requiere 
toda la potencia de CPU disponible (100%) tendriamos una carga de 1.00. 
Si ejecutamos dos procesos con las caracteristicas del anterior, cada uno 
consumiria el 50% de la potencia de la CPU y la carga subiria a 2.00.  
y asi sucesivamente. La carga del sistema se puede consultar con los 
comandos <tt>top</tt> y <tt>w</tt>.

<p><item><bf>Cilindro</bf>: Cuando se refiere a unidades de disco,
corresponde a la cantidad de distintas posiciones que pueden ocupar
las cabezas de lectura/escritura sobre la platina del disco.  Cuando
se mira desde arriba de las platinas, cada posición de una cabeza
describe un círculo imaginario con diferentes diámetros sobre la
superficie de la platina, pero cuando se mira de costado, estos
círculos pueden pensarse como una serie de cilindros anidados uno
dentro de otro, y de allí el término.  En inglés: «<em>cylinder</em>».
Vea también «Geometría».

<p><item><bf>CISC</bf>: Sigla de <em>C</em>omplex <em>I</em>nstruction
<em>S</em>et <em>C</em>omputer (computadora con juego de instrucciones
  complejo).  Se trata de una filosofía de diseño de ordenadores en
  la cual el procesador se diseña para ejecutar una cantidad
  relativamente grande de instrucciones diferentes, cada una de las
  cuales tarda distinto tiempo en ejecutarse (de acuerdo a la
  complejidad de la instrucción).  Lo contrario de «RISC».

<p><item><bf>CMOS</bf>: En un principio la sigla de <em>C</em>omplementary
<em>M</em>etal <em>O</em>xide <em>S</em>emiconductor (semiconductor de óxido metálico
complementario) -- la tecnología de semiconductores que se
utiliza en muchos circuitos integrados.  Ahora con frecuencia designa
al hardware de bajo nivel que contiene la configuración del BIOS y el
reloj por hardware de la computadora.

<p><item><bf>Código fuente</bf>: El formato entendible por las personas de
las instrucciones que conforman un programa.  También se lo conoce
como «fuentes».  Sin los fuentes de un programa es muy difícil
modificarlo.  En inglés: «source code».

<p><item><bf>Consola virtual</bf>: Las consolas virtuales proporcionan
múltiples «pantallas» en las cuales el usuario puede ingresar y
ejecutar programas.  El monitor del ordenador muestra una pantalla
a la vez; hay una secuencia de teclas para alternar entre las
distintas consolas virtuales.  En inglés: «virtual console».

<p><item><bf>Controlador de dispositivo</bf>: Software que controla un
dispositivo que está conectado a, o es parte de, una computadora. (En
inglés: <em>device driver</em>.

<p><item><bf>Cylinder</bf>: Inglés, vea «cilindro».

<p><item><bf>Daemon</bf>: Inglés, ver «Demonio».

<p><item><bf>Demonio</bf>: Un demonio es un programa que funciona sin
intervención humana, para cumplir una tarea determinada.  Por ejemplo,
<tt>lpd</tt> es un demonio que controla el flujo de los trabajos de
impresión en una impresora.

<p><item><bf>Dependencias</bf>: Cuando se refiere a paquetes, las
dependencias son requerimientos que existen entre paquetes.  Por
ejemplo, el paquete <tt><em>foo</em></tt> puede requerir ficheros que son
instalados por el paquete <tt><em>bar</em></tt>.  En este ejemplo, <tt><em>bar</em></tt> debe
estar instalado, pues sino <tt><em>foo</em></tt> tendrá dependencias sin
resolver.  Normalmente, RPM no permitirá que se instalen paquetes con
dependencias sin resolver.

<p><item><bf>Desmontaje</bf>: El acto de revocar el acceso a un sistema de
ficheros.  (Debe usted advertir que el programa que desmonta los sistemas
de ficheros se denomina <tt>umount</tt>.)  En inglés: «unmount».

<p><item><bf>Device Driver</bf>: Inglés, vea «controlador de dispositivo».

<p><item><bf>Dirección IP</bf>: Las direcciones IP son el método mediante el
cual se identifican los ordenadores individuales (o, en una
interpretación más estricta, las interfaces de red de dichos
ordenadores) dentro de un red TCP/IP.  Todas las direcciones IP
consisten en cuatro números separados por puntos, donde
cada número está entre 0 y 255.

<p><item><bf>Disco duro</bf>: Un disco rígido contiene un medio magnético
rotante (en forma de discos) que gira rápidamente.  Hay pequeñas
cabezas que flotan sobre la superficie de cada disco, y sirven para
leer y escribir en el disco a medida que rota.  En inglés:
«<em>Hard Disk</em>».

<p><item><bf>Disk Drive</bf>: Inglés, vea «disco rígido».

<p><item><bf>Disk Druid</bf>: Disk Druid (Druida de disco) es un componente
del programa de instalación de RHL que se utiliza para realizar las
particiones de las unidades de disco durante el proceso de instalación.

<p><item><bf>Diskette</bf>: Inglés, vea «disquete».

<p><item><bf>Disquete de arranque</bf>: El disquete que se utiliza para
arrancar distintas instalaciones RHL.  En inglés: «<em>boot diskette</em>». 

<p><item><bf>Disquete de rescate</bf>: Disquete que contiene un entorno de
sistema rudimentario.  Como el nombre sugiere, el disquete de rescate
se utiliza normalmente en un intento de «rescatar» un sistema dañado
para evitar la reinstalación total del sistema operativo.  En inglés:
«Rescue Diskette». 

<p><item><bf>Disquete para soporte PCMCIA</bf>: El disquete necesario para
las instalaciones de RHL que requieren el uso de un dispositivo
PCMCIA durante la instalación.  En inglés: «PCMCIA Support Diskette».

<p><item><bf>Disquete suplementario</bf>: Un disquete que se requiere en
algunas clases de instalaciones de RHL.  En inglés: «Supplemental Diskette».

<p><item><bf>Disquete</bf>: Dispositivo de almacenamiento masivo de pequeña
capacidad, que viene en un cartucho intercambiable, con el propósito
de leer y/o escribir en el mismo, mediante su uso en una unidad
compatible.  En inglés «<em>diskette</em>».

<p><item><bf>Distribución</bf>: Un sistema operativo (en general Linux), que
se ha empaquetado para facilitar su instalación.  En inglés:
«<em>distribution</em>». 

<p><item><bf>Distribution</bf>: Inglés, vea «distribución».

<p><item><bf>Domain name</bf>: Inglés, vea «Nombre de dominio».

<p><item><bf>Driver</bf>: Vea «Controlador de dispositivo».

<p><item><bf>Dual Boot</bf>: Inglés, vea «arranque dual».

</itemize>


<!-- **************************************** -->
<!--     SUBSECCIÓN GLOSARIO E-H           -->
<!-- **************************************** -->

<sect1>Glosario E-H
<p>
<itemize>
<item>
<bf>EIDE</bf>: Sigla de <em>E</em>nhanced <em>I</em>ntegrated
<em>D</em>rive <em>E</em>lectronics (electrónica de unidad integrada
mejorada), y es la nueva versión de la interfaz estándar integrada y
otra nomenclatura para una implementación particular de interfaces
IDE.  Con EIDE se pueden tener discos más rápidos y de mayor
capacidad; la mayoría de los sistemas que se venden hoy día utilizan
EIDE. 

<p><item>
<bf>Errata</bf>: Errata es el original en latín de
«¡auch!».  Cuando se detectan
errores en el software, se realiza la
reparación de los errores y los cambios con frecuencia
se entregan como errata.  RHL no es
una excepción a esta regla; disponemos de una página web para las Errata en
<url url="http://www.redhat.com/errata" name="http://www.redhat.com/errata">.

<p><item>
<bf>Extended Partition</bf>: Inglés, vea «partición extendida».

<p><item>
<bf>FAQ</bf>: Sigla de <em>F</em>requently <em>A</em>sked
<em>Q</em>uestions (Preguntas Frecuentes).  La información acerca de
Linux se presenta generalmente en forma de listas de preguntas y sus
respuestas, denominadas FAQs.

<p><item>
<bf>Fdisk</bf>: <tt>fdisk</tt> es un programa de utilidad que se usa
para crear, borrar o modificar las particiones en una unidad de disco.
Hay que tener mucho cuidado al usar este programa, ya que, un uso inapropiado 
del mismo puede hacernos perder nuestra información en el disco duro. 

<p><item>
<bf>Filesystem</bf>: Inglés, vea «Sistema de ficheros».

<p><item>
<bf>Floppy</bf>: Término con connotaciones históricas para referirse
a un disquete.  Vea «disquete».

<p><item>
<bf>Formatear</bf>: Dar formato.  El acto de escribir un sistema de
ficheros en una unidad de disco.

<p><item>
<bf>Formatting</bf>: Inglés, vea «formatear».

<p><item>
<bf>FQDN</bf>: Sigla de <em>F</em>ully <em>Q</em>ualified
<em>D</em>omain <em>N</em>ame (Dominio completamente expresado).  Un FQDN
es un nombre entendible por personas que incluye el nombre de la
computadora y el nombre de dominio asociado a la misma.  Por ejemplo,
dada la computadora llamada «foo» y el nombre de dominio «bar.com», el
FQDN será «foo.bar.com».

<p><item>
<bf>FTP</bf>: Sigla de <em>F</em>ile <em>T</em>ransfer
<em>P</em>rotocol (Protocolo de transferencia de ficheros).  También es
el nombre del programa que, tal como su nombre indica, permite copiar
ficheros desde un sistema a otro a través de la red.

<p><item>
<bf>Gateway</bf>: Inglés, vea «pasarela».

<p><item>
<bf>Geometría</bf>: Cuando se refiere a unidades de disco, las
características físicas de su organización interna.  Debe usted
advertir que la unidad de disco puede informar una «geometría lógica»
que es diferente de su «geometría física», normalmente para evitar las
limitaciones impuestas por el BIOS.  En inglés «<em>Geometry</em>».  Vea
además «cilindro», «cabeza» y «sector».

<p><item>
<bf>Geometry</bf>: Inglés, vea «geometría».

<p><item>
<bf>GID</bf>: Abreviatura de <em>G</em>roup <em>ID</em> (Identificador
de grupo).  Por medio del GID se identifica la pertenencia de un
usuario a un grupo.  Los GIDs son números, aunque se almacenan nombres
entendibles para personas en el fichero
<tt><em>/etc/group</em></tt>.

<p><item>
<bf>Group</bf>: Inglés, vea «grupo».

<p><item>
<bf>Grupo</bf>: El grupo es la manera de asignar derechos de acceso
específicos a ciertas clases de usuarios.  Por ejemplo, todos los
usuarios que trabajan en el Proyecto X pueden agregarse al grupo
<tt><em>proyx</em></tt>.  Los recursos del sistema (como por ejemplo espacio en
disco) que se dedican al Proyecto X se pueden configurar entonces para
permitir su acceso total sólo a los miembros de <tt><em>proyx</em></tt>.  En
inglés: «<em>group</em>».

<p><item>
<bf>Hard Disk</bf>: Inglés, vea «disco rígido».

<p><item>
<bf>Head</bf>: Inglés, vea «cabeza».

<p><item>
<bf>Hostname</bf>: Inglés, vea «nombre de máquina». 

</itemize>
<p>
<!-- **************************************** -->
<!--     SUBSECCIÓN GLOSARIO I-L           -->
<!-- **************************************** -->

<sect1>Glosario I-L
<p>
<itemize>
<item>
<bf>I18n</bf>: Una «i» seguida de 18 letras, seguida de una «n», que
corresponde a una abreviatura de la palabra inglesa
«internationalization» (internacionalización).  Vea
«internacionalización».

<p><item>
<bf>IDE</bf>: Sigla de <em>I</em>ntegrated <em>D</em>rive
<em>E</em>lectronics (electrónica de unidad integrada), que denota la
interfaz estándar usada para conectar fundamentalmente unidades de
disco y CD-ROM a un ordenador.  Vea también «EIDE» y «ATAPI».

<p><item>
<bf>Intel</bf>: Compañía responsable de la producción de los
microprocesadores más usuales en las computadoras personales
compatibles con PC.  Estos procesadores incluyen el 80386, 80486,
Pentium, Pentium Pro, Pentium II y Pentium III.

<p><item>
<bf>Intercambio</bf>: También se lo conoce como «espacio de
intercambio» («<em>swap space</em>»).  Cuando un programa necesita más
memoria de la que hay disponible físicamente en el ordenador, la
información que no se está utilizando en ese momento se puede escribir
en un búfer temporal en el disco, denominado «swap», y de esa manera
se libera memoria.  Algunos sistemas operativos admiten el intercambio
contra un fichero específico, pero Linux normalmente realiza los
intercambios contra una partición dedicada al intercambio.  El término
«swap» está mal elegido, pues en Linux se lo usa para denotar el
intercambio de páginas según la demanda («<em>demand paging</em>»).  En
inglés: «Swap».

<p><item>
<bf>Internacionalización</bf>: La práctica de diseñar y escribir
programas que pueden configurarse fácilmente para interactuar con el
usuario en más de un idioma.  Con frecuencia se lo denomina «i18n», a
causa de la cantidad de letras entre la «i» de arranque y la «n»
final.  En inglés: «<em>Internationalization</em>».

<p><item>
<bf>Internationalization</bf>: Inglés, vea «internacionalización».

<p><item>
<bf>ISP</bf>: Inglés, siglas de <em>I</em>nternet <em>S</em>service <em>P</em>rovider. 
Vea «psi».

<p><item>
<bf>Kernel</bf>: Inglés, vea «núcleo».

<p><item>
<bf>Library</bf>: Inglés, vea «biblioteca».

<p><item>
<bf>LILO</bf>: Cargador de arranque muy utilizado en sistemas Linux
que se basan en procesadores compatibles con los de Intel.

<p><item>
<bf>Linus Torvalds</bf>: Creó Linux en 1991 mientras era estudiante
universitario.

<p><item>
<bf>Linux</bf>: Sistema operativo completo, robusto, disponible
libremente, que fue desarrollado originalmente por Linus Torvalds. 

<p><item>
<bf>Linuxconf</bf>: Versátil programa de configuración del sistema
escrito por Jacques Gelinas.  Linuxconf proporciona un enfoque basado
en menúes para la configuración del sistema a través de distintas
interfaces de usuario.

<p><item>
<bf>Llamada al sistema</bf>: Es una rutina que cumple una función a
nivel del sistema en nombre de un proceso.  En inglés: «System Call».

<p><item>
<bf>Load Average</bf>: Inglés, vea «carga del sistema».

<p><item>
<bf>Logical Partition</bf>: Inglés, vea «partición lógica».

</itemize>
<p>
<!-- **************************************** -->
<!--     SUBSECCIÓN GLOSARIO M-O           -->
<!-- **************************************** -->

<sect1>Glosario M-O
<p>
<itemize>
<item>
<bf>Máscara de red</bf>: Una máscara de red es un conjunto de cuatro
números separados por puntos.  Cada número se representa normalmente
como el equivalente decimal de un número binario de 8 bits, lo que
significa que cada número puede tomar valores entre 0 (todos los bits
en cero) y 255 (todos los bits en uno).  Cada dirección IP consiste de
dos partes (la dirección de red y el número de máquina).  La máscara
de red se usa para determinar el tamaño de cada una de estas partes.
Las posiciones de los bits en uno de la máscara se consideran parte
del espacio reservado para la dirección de red, mientras que los bits
que están puestos a cero se consideran parte del espacio apartado para
el número de máquina.  En inglés: «netmask».

<p>
<item>
<bf>Master Boot Record<</bf>: Inglés, vea «Registro de arranque
maestro».

<p>
<item>
<bf>Memoria</bf>: Cuando se refiere a ordenadores, la memoria (en
general) es cualquier hardware capaz de almacenar datos para
recuperarlos posteriormente.  En este contexto, la memoria en general
se refiere específicamente a la RAM.

<p>
<item>
<bf>MILO</bf>: Cargador que se usa generalmente para sistemas Linux
basados en el procesador Alpha.

<p>
<item>
<bf>Module</bf>: Inglés, vea «módulo».

<p>
<item>
<bf>Módulo</bf>: En Linux, un módulo es un conjunto de rutinas que
realizan funciones a nivel de sistema, y que pueden cargarse y
descargarse dinámicamente desde el núcleo cuando sea requerido.  Los
módulos con
frecuencia contienen controladores de dispositivos, y están
fuertemente ligados a la versión del núcleo; la mayorías de los
módulos construidos con una versión dada de núcleo, no se cargarán de
manera apropiada en un sistema que corra un núcleo con versión
distinta.  En inglés: «module».

<p>
<item>
<bf>Montaje</bf>: El acto por medio del cual los sistemas de fichero
se hacen accesibles a los usuarios del sistema.  En inglés: «mount».

<p>
<item>
<bf>Mount Point</bf>: Inglés, vea «punto de montaje».

<p>
<item>
<bf>Mount</bf>: Inglés, vea «montaje».

<p>
<item>
<bf>Mouse</bf>: Inglés: ratón.  Vea «ratón serie» y «ratón PS/2».

<p>
<item>
<bf>Nameserver</bf>: Inglés, vea «Servidor de nombres».

<p>
<item>
<bf>Netmask</bf>: Inglés, vea «máscara de red».

<p>
<item>
<bf>NFS</bf>: Sigla de <em>N</em>etwork <em>F</em>ile <em>S</em>ystem, NFS
es un método para lograr que un sistema de ficheros de una máquina
remota sea accesible para el sistema local.  Desde la perspectiva del
usuario, un sistema de ficheros montado por NFS es indistinguible de
un sistema de ficheros que reside en una unidad de disco directamente
adosada a la máquina.


<p>
<item>
<bf>Nombre de dominio</bf>: El nombre de dominio se utiliza para
expresar que las computadoras pertenecen a una determinada
organización.  Los nombres de dominio son jerárquicos por naturaleza,
y cada nivel de la jerarquía se separa de los otros niveles mediante
un punto.  Por ejemplo, el departamento de Finanzas de la Corporación
Foo puede usar un dominio «finanzas.foo.com». En inglés:
«<em>Domain Name</em>».

<p>
<item>
<bf>Nombre de máquina</bf>: Es una cadena de caracteres entendible
para las personas que se usa para identificar una máquina computadora
en particular.  En inglés: «hostname». 

<p>
<item>
<bf>Núcleo</bf>: La parte central de un sistema operativo, sobre la
cual el resto del sistema se apoya.  En inglés: «kernel».

<p>
<item>
<bf>Operating System</bf>:Inglés, vea «sistema operativo».

</itemize>
<p>
<!-- **************************************** -->
<!--     SUBSECCIÓN GLOSARIO P-S           -->
<!-- **************************************** -->

<sect1>Glosario P-S
<p>
<itemize>
<item>
<bf>Packages</bf>: Inglés, vea «paquetes».

<p>
<item>
<bf>PAM</bf>: Sigla de <em>P</em>luggable <em>A</em>uthentication
<em>M</em>odules (Módulos enchufables de autenticación).  PAM es un
sistema de autenticación que controla el acceso a RHL.

<p>
<item>
<bf>Paquetes</bf>: Ficheros que contienen software;  están escritos
en un cierto formato que permite la fácil instalación y borrado del
software.  En inglés: «packages».

<p>
<item>
<bf>Partición</bf>: El segmento del espacio de almacenamiento de una
unidad de disco que puede accederse como si fuese un disco entero.  En
inglés: «partition». 

<p>
<item>
<bf>Partición extendida</bf>: Segmento de una unidad de disco que
contiene otras particiones.  En inglés: <em>Extended Partition</em>.
Vea también «partición».

<p>
<item>
<bf>Partición lógica</bf>: Partición que existe dentro de una
partición extendida.  Vea también: «partición» y «partición
extendida».  En inglés: «<em>Logical Partition</em>».

<p>
<item>
<bf>Partition Table</bf>: Inglés, vea «tabla de particiones».

<p>
<item>
<bf>Partition Type</bf>: Inglés, vea «tipo de partición».

<p>
<item>
<bf>Partition</bf>: Inglés, vea «partición».

<p>
<item>
<bf>Pasarela</bf>: En términos de redes, se refiere al dispositivo
que conecta uno o más ordenadores de una red a otra red.  El
dispositivo puede ser un hardware especializado (como un
<em>router</em>), o puede ser una computadora de propósito general que
se configura para actuar de pasarela.  En inglés: «<em>Gateway</em>». 

<p>
<item>
<bf>PC Card</bf>: Inglés, vea «PCMCIA».

<p>
<item>
<bf>PCMCIA</bf>: Sigla de <em>P</em>ersonal <em>C</em>omputer
<em>M</em>emory <em>C</em>ard <em>I</em>nternational <em>A</em>ssociation
(Asociación Internacional Tarjetas de Memoria para Computadoras
Personales).  Esta organización produce una serie de estándares que
definen las características físicas, eléctricas y de software para
pequeños dispositivos del tamaño de tarjetas de crédito que pueden
contener memoria, modems, adaptadores de red, etc.  También se las
conoce como «PC Cards» (tarjetas para PC), estos dispositivos se usan
principalmente en computadoras portátiles (aunque también algunos
sistemas de escritorio pueden utilizar tarjetas PCMCIA).

<p>
<item>
<bf>PCMCIA Support Diskette</bf>: Inglés, vea «Disquete para soporte
PCMCIA».

<p>
<item>
<bf>Permisos</bf>: El conjunto de identificadores que controlan el
acceso a los ficheros.  Los permisos constan de tres campos: usuario,
grupo y mundo.  El campo de usuario controla el acceso del propietario
del fichero, y el campo de grupo controla el acceso de cualquiera que
concuerda con la especificación de grupo del fichero.  Como el nombre
implica, el campo mundo controla el acceso de cualquier otro usuario.  Cada
campo contiene el mismo conjunto de bits que especifican las
operaciones que pueden o no realizarse, tales como lectura, escritura
y ejecución.

<p>
<item>
<bf>PLIP</bf>: Sigla de <em>P</em>arallel <em>L</em>ine
<em>I</em>nternet <em>P</em>rotocol (Protocolo de Internet para líneas
paralelas).  PLIP es un protocolo que permite comunicaciones TCP/IP
sobre el puerto paralelo de la computadora, mediante el uso de un
cable especialmente diseñado.

<p>
<item>
<bf>POSIX</bf>: Sigla un tanto forzada de <em>P</em>ortable
<em>O</em>perating <em>S</em>ystem <em>I</em>nterface (Interfaz portable de
sistema operativo).  Conjunto de estándares que crecieron a partir del
sistema operativo UNIX.

<p>
<item>
<bf>Proceso</bf>: Un proceso (en términos simplísticos en cierto
modo) es una instancia de un programa en ejecución sobre un sistema
Linux.  En inglés: «process».

<p>
<item>
<bf>Process</bf>: Inglés, vea «proceso».

<p>
<item>
<bf>PSI</bf>: Siglas de <em>P</em>roveedor de <em>S</em>servicios <em>I</em>nternet. 
Empresa u organización que ofrece acceso a Internet a usuarios finales y corporativos.

<p>
<item>
<bf>Punto de montaje</bf>: El directorio bajo el cual se puede
acceder a un sistema de ficheros luego de su montaje.  En inglés:
«Mount Point».

<p>
<item>
<bf>Raíz</bf>: (N. del T.) Traducción de la palabra «root».  En
determinados contextos se usa en castellano (ej.: «el directorio
<tt><em>raíz</em></tt>»), mientras que en otros su traducción es desaconsejada (ej.:
«el usuario root», en cuyo caso podría ser sinónimo de
«superusuario» o «administrador»).  Esta distinción favorece a los lectores
hispanos pues quita algunas de las ambigüedades del término inglés.

<p>
<item>
<bf>RAM</bf>: Sigla de <em>R</em>andom <em>A</em>ccess <em>M</em>emory
(Memoria de acceso directo).  La RAM se usa para mantener los
programas mientras se están ejecutando, y los datos mientras se los
procesa.  La RAM es volátil, lo que significa que la información
escrita en la RAM desaparecerá cuando se apague la alimentación de 
energía del ordenador.

<p>
<item>
<bf>Ratón PS/2</bf>: El ratón PS/2 toma su nombre a partir de la
computadora original donde se comenzó a utilizar, la IBM PS/2.  El
ratón PS/2 puede identificarse fácilmente por el pequeño conector
redondo en el extremo del cable.

<p>
<item>
<bf>Ratón serie</bf>: Un ratón serie es uno diseñado para conectarse
al puerto serie del ordenador.  El ratón serie puede identificarse
fácilmente por el conector de forma rectangular que posee en el
extremo de su cable.

<p>
<item>
<bf>Rearrancar</bf>: Recomenzar el proceso de arranque.  En inglés:
«reboot».  Vea también «arranque».

<p>
<item>
<bf>Reboot</bf>: Inglés, vea «rearrancar».

<p>
<item>
<bf>Red Hat Software</bf>: Compañía de software sita en North
Carolina.  Produce y pone en el mercado software para el sistema
operativo Linux, lo que incluye a Red Hat Linux.

<p>
<item>
<bf>Registro de arranque maestro</bf>: En inglés: «Master Boot
Record» o más conocido por su sigla «MBR», es una sección del espacio
de almacenamiento de la unidad de disco que se pone aparte con el
propósito de guardar la información necesaria para comenzar el
arranque en un ordenador personal.

<p>
<item>
<bf>Rescue Diskette</bf>: Inglés, vea «disquete de rescate».

<p>
<item>
<bf>RISC</bf>: Sigla de <em>R</em>educed <em>I</em>nstruction
<em>S</em>et <em>C</em>omputer (Computadora con juego reducido de
instrucciones).  Filosofía de diseño de computadoras en la cual el
procesador está optimizado para ejecutar un número relativamente
pequeño de instrucciones diferentes en una cantidad de tiempo
predeciblemente pequeña.

<p>
<item>
<bf>ROM</bf>: Sigla de <em>R</em>ead <em>O</em>nly <em>M</em>emory
(Memoria de sólo lectura).
La ROM se usa para mantener los programas y datos que deben sobrevivir
cuando se apaga el ordenador.  Como la ROM no es volátil, los datos
en la misma permanecerán sin cambios hasta la próxima vez que se
encienda la computadora.  Como el nombre implica, los datos no pueden
escribirse con facilidad en la ROM; dependiendo de la tecnología que
se usó en la ROM, la escritura puede requerir de un hardware especial,
o incluso ser imposible.  El BIOS del ordenador se almacena en
ROM. 

<p>
<item>
<bf>root</bf>: (raíz) El nombre de la cuenta de ingreso que da acceso
completo y total a todos los recursos del sistema.  También se usa
para describir el directorio denominado con «/», como en la expresión
«el directorio raíz».

<p>
<item>
<bf>RPM</bf>: Sigla de <em>R</em>ed Hat <em>P</em>ackage <em>M</em>anager
(Gestionador de paquetes de Red Hat).  <tt>rpm</tt> es también el nombre del
programa que permite la instalación, actualización y eliminación de
paquetes.

<p>
<item>
<bf>SCSI</bf>: Sigla de <em>S</em>mall <em>C</em>omputer
<em>S</em>ystem <em>I</em>nterface (Interfaz de sistema para pequeñas
computadoras), SCSI es una interfaz estándar para conectar una amplia
variedad de dispositivos a la computadora.  Los dispositivos SCSI más
populares son las unidades de disco, aunque también es común encontrar
unidades de cinta y «scaners».

<p>
<item>
<bf>Sector</bf>: Cuando se refiere a una unidad de disco, la
cantidad de áreas de tamaño fijo (normalmente 512 bytes) que se pueden
acceder mediante una cabeza de lectura/escritura, en una rotación del
disco, sin que la cabeza cambie su posición.  Vea también «geometría».

<p>
<item>
<bf>Servidor de nombres</bf>: En términos de redes TCP/IP, un
servidor de nombres es un ordenador que traduce un nombre
entendible por personas (como «foo.bar.com») en una dirección numérica
(como «10.0.2.14»).  En inglés: «nameserver».

<p>
<item>
<bf>setgid</bf>: Llamada al sistema que puede usarse para asignar el
GID de un proceso.  Los programas grabados con el atributo «setgid» pueden adoptar
el GID del grupo al cual pertenece el fichero programa.

<p>
<item>
<bf>setuid</bf>: Llamada al sistema que se usa para asignar el UID
de un proceso.  Los programas grabados con «setuid» pueden adoptar
el UID del usuario que es dueño del fichero programa.  Esto se considera
un posible problema de seguridad si el fichero es «setuid root».

<p>
<item>
<bf>Shadow Password</bf>: Normalmente, la contraseña de cada usuario
se almacena en forma cifrada en el fichero
<tt><em>/etc/passwd</em></tt>.  Este
fichero debe poderlo leer cualquier usuario para que ciertas funciones
del sistema trabajen correctamente.  Sin embargo, esto significa que
cualquiera puede obtener copias de las contraseñas cifradas de todos
los usuarios, con lo cual resulta sencillo ejecutar un programa que
adivine las contraseñas de los usuarios.  Las «shadow passwords», por
otro lado, almacenan la contraseña cifrada en un fichero distinto
altamente protegido, lo que hace mucho más difícil el «crackeo» de
contraseñas. 

<p>
<item>
<bf>SILO</bf>: Cargador que se usa generalmente para sistemas Linux
basados en el procesador SPARC.

<p>
<item>
<bf>Sistema de ficheros</bf>: Es el método mediante el cual se
almacena la información en las unidades de disco.  Los distintos
sistemas operativos normalmente usan diferentes sistemas de ficheros,
lo que dificulta el compartir los contenidos de una unidad de disco
entre ellos.  Sin embargo, Linux admite
múltiples sistemas de ficheros, lo cual hace posible la
lectura/escritura de particiones dedicadas a MS-Windows, por ejemplo.  En
inglés: «<em>Filesystem</em>» 

<p>
<item>
<bf>Sistema operativo</bf>: Conjunto de software que controla los
distintos recursos del ordenador.  En inglés: «operating system». 

<p>
<item>
<bf>SLIP</bf>: Sigla de <em>S</em>erial <em>L</em>ine <em>I</em>nternet
<em>P</em>rotocol (Protocolo de Internet para líneas serie).  SLIP es un
protocolo que permite la comunicación TCP/IP sobre líneas serie
(típicamente una conexión por módem a través de la red telefónica
conmutada).

<p>
<item>
<bf>SMB</bf>: Sigla de <em>S</em>erver <em>M</em>essage <em>B</em>lock
(Bloque de mensajes de servidor), SMB es el protocolo de comunicación
que usan los sistemas operativos basados en MS-Windows para permitir los
recursos compartidos a través de la red.

<p>
<item>
<bf>Source code</bf>: Inglés, vea «código fuente».

<p>
<item>
<bf>SPARC</bf>: Arquitectura RISC desarrollada por Sun Microsystems. 

<p>
<item>
<bf>Supplemental Diskette</bf>: Inglés, vea «disquete
suplementario».

<p>
<item>
<bf>Swap</bf>: Inglés, vea «intercambio». 

<p>
<item>
<bf>System Call</bf>: Inglés, vea «Llamada al sistema».

</itemize>
<p>
<!-- **************************************** -->
<!--     SUBSECCIÓN GLOSARIO T-W           -->
<!-- **************************************** -->

<sect1>Glosario T-W
<p>
<itemize>
<item>
<bf>Tabla de particiones</bf>: La tabla de particiones es la sección
del espacio de almacenamiento de la unidad de disco que se pone aparte
para definir las particiones que existen en dicha unidad de disco.  En
inglés: «partition table». 

<p>
<item>
<bf>TCP/IP</bf>: Sigla de <em>T</em>ransmission <em>C</em>ontrol
<em>P</em>rotocol/<em>I</em>nternet <em>P</em>rotocol (Protocolo de control
de transmisión/Protocolo de Internet), TCP/IP es el nombre dado al
estándar de redes de uso común en la actualidad en Internet.

<p>
<item>
<bf>Tipos de partición</bf>: Las particiones tienen un campo que se
usa para determinar el tipo de sistema de ficheros que se espera que
vaya a contener la partición.  El tipo de partición es en realidad un
número, aunque muchas veces nos referimos al tipo mediante un nombre.
Por ejemplo, el tipo de partición denominado «Linux Native» es el 82.
Tenga en cuenta que este número es hexadecimal.  En inglés: «Partition
Type». 

<p>
<item>
<bf>Torvalds, Linus</bf>: Vea «Linus Torvalds».

<p>
<item>
<bf>UID</bf>: Abreviatura de <em>U</em>ser <em>ID</em> (ID de usuario).
Es el medio por el cual se identifica a un usuario en las distintas
partes de un sistema RHL.  Los UIDs son numéricos, aunque hay nombres
en formato entendible por personas que se almacenan en el fichero
<tt><em>/etc/passwd</em></tt>.

<p>
<item>
<bf>Unidad de disco</bf>: Vea «disco rígido».

<p>
<item>
<bf>UNIX</bf>: Conjunto de sistemas operativos del estilo de Linux
que crecieron a partir de la versión original escrita por unos tipos
de una compañía  telefónica
<p>
(¡Es broma! ¡Gracias Ken Thompson y Dennis Ritchie de los «Bell Telephone Laboratories» por vuestro inspirado diseño de sistema operativo!). 

<p>
<item>
<bf>Unmount</bf>: Inglés, vea «desmontaje».

<p>
<item>
<bf>Virtual Console</bf>: Inglés, vea «consola virtual».

<p>
<item>
<bf>Widget</bf>: Representación estandarizada en pantalla de un
control que el usuario puede manipular.  Ejemplos de «widgets» son las
barras de desplazamiento, los botones y las cajas de texto.

</itemize>
<p>
<!-- **************************************** -->
<!--     SUBSECCIÓN GLOSARIO X-Z           -->
<!-- **************************************** -->

<sect1>Glosario X-Z
<p>
<itemize>
<item>
<bf>X Window System</bf>: (Sistema de ventanas X)  También
denominado «X», esta interfaz gráfica de usuario proporciona la bien
conocida metáfora de «ventanas sobre un escritorio», común a la
mayoría de los sistemas hoy en día.  Bajo X, los programas de
aplicación actúan como clientes y acceden al servidor X que gestiona
toda la actividad en pantalla.  Además, las aplicaciones X pueden
ejecutarse en un sistema distinto al del servidor X, lo que permite la
visualización remota de las aplicaciones.

<p>
<item>
<bf>XFree86</bf>: Implementación libre del «X Window System». 

</itemize>



<!-- **************************************** -->
<!-- **************************************** -->
<!--        SECCIÓN ENLACES DE INTERES        -->
<!-- **************************************** -->
<!-- **************************************** -->

<sect>Servidores FTP 
<p>
Aqui teneis una selección de servidores FTP, en donde es posible encontrar casi todo lo referente a Linux, programas, aplicaciones, distribuciones, documentacion, ....
<p>
<bf>Europa</bf>
<p>
<itemize>
<item><bf><url url="ftp://ftp.univie.ac.at/systems/linux/" name="ftp://ftp.univie.ac.at/systems/linux/"></bf>
<item><bf><url url="ftp://ftp.funet.fi/pub/Linux" name="ftp://ftp.funet.fi/pub/Linux"></bf>
<item><bf><url url="ftp://ftp.univ-angers.fr/pub/Linux" name="ftp://ftp.univ-angers.fr/pub/Linux"></bf>
<item><bf><url url="ftp://ftp.gwdg.de/pub/linux/" name="ftp://ftp.gwdg.de/pub/linux/"></bf>
<item><bf><url url="ftp://2cows.netsurf.de/pub" name="ftp://2cows.netsurf.de/pub"></bf>
<item><bf><url url="ftp://ftp.uni-paderborn.de/pub/Mirrors/sunsite.unc.edu" name="ftp://ftp.uni-paderborn.de/pub/Mirrors/sunsite.unc.edu"></bf>
<item><bf><url url="ftp://ftp.rz.uni-ulm.de/pub/systems/linux/" name="ftp://ftp.rz.uni-ulm.de/pub/systems/linux/"></bf>
<item><bf><url url="ftp://ftp.dfv.rwth-aachen.de/pub/linux" name="ftp://ftp.dfv.rwth-aachen.de/pub/linux"></bf>
<item><bf><url url="ftp://ftp.tu-dresden.de/Linux" name="ftp://ftp.tu-dresden.de/Linux"></bf>
<item><bf><url url="ftp://cnuce-arch.cnr.it/pub/Linux" name="ftp://cnuce-arch.cnr.it/pub/Linux"></bf>
<item><bf><url url="ftp://src.doc.ic.ac.uk/packages/linux/sunsite.unc-mirror" name="ftp://src.doc.ic.ac.uk/packages/linux/sunsite.unc-mirror"></bf>
<item><bf><url url="ftp://unix.hensa.ac.uk/mirrors/sunsite/pub/Linux" name="ftp://unix.hensa.ac.uk/mirrors/sunsite/pub/Linux"></bf>
<item><bf><url url="ftp://ftp.nvg.unit.no/pub/linux" name="ftp://ftp.nvg.unit.no/pub/linux"></bf>
<item><bf><url url="ftp://ftp.kfki.hu/pub/linux" name="ftp://ftp.kfki.hu/pub/linux"></bf>
<item><bf><url url="ftp://ftp.fi.muni.cz/pub/UNIX/linux" name="ftp://ftp.fi.muni.cz/pub/UNIX/linux"></bf>
<item><bf><url url="ftp://ftp.etsimo.uniovi.es/pub/linux" name="ftp://ftp.etsimo.uniovi.es/pub/linux"></bf>
<item><bf><url url="ftp://sunsite.cnlab-switch.ch/mirror/linux" name="ftp://sunsite.cnlab-switch.ch/mirror/linux"></bf>
<item><bf><url url="ftp://ftp.informatik.rwth-aachen.de/pub/gnu" name="ftp://ftp.informatik.rwth-aachen.de/pub/gnu"></bf>
</itemize>
<p>
<bf>America</bf>
<p>
<itemize>
<item><bf><url url="ftp://metalab.unc.edu/pub/Linux/ " name="ftp://metalab.unc.edu/pub/Linux/ "></bf>
<item><bf><url url="ftp://tsx-11.mit.edu/pub/linux" name="ftp://tsx-11.mit.edu/pub/linux"></bf>
<item><bf><url url="ftp://ftp.cc.gatech.edu/pub/linux" name="ftp://ftp.cc.gatech.edu/pub/linux"></bf>
<item><bf><url url="ftp://prep.ai.mit.edu/pub/gnu" name="ftp://prep.ai.mit.edu/pub/gnu"></bf>
</itemize>
<p>
<bf>Asia</bf>
<p>
<itemize>
<item><bf><url url="ftp://ftp.spin.ad.jp/pub/Linux" name="ftp://ftp.spin.ad.jp/pub/Linux"></bf>
</itemize>
<p>
<bf>Africa</bf>
<p>
<itemize>
<item><bf><url url="ftp://ftp.is.co.za/linux" name="ftp://ftp.is.co.za/linux"></bf>
</itemize>
<p>
<bf>Otros</bf>
<p>
<itemize>
<item><bf><url url="ftp://ftp.cdrom.com/pub/linux" name="ftp://ftp.cdrom.com/pub/linux"></bf>
<item><bf><url url="ftp://ftp.linux.org/pub/mirrors" name="ftp://ftp.linux.org/pub/mirrors"></bf>
<item><bf><url url="ftp://ftp.rge.com/pub/systems/linux" name="ftp://ftp.rge.com/pub/systems/linux"></bf>
<item><bf><url url="ftp://ftp.nuri.net/pub/Linux" name="ftp://ftp.nuri.net/pub/Linux"></bf>
<item><bf><url url="ftp://ftp.nus.sg/pub/unix/Linux" name="ftp://ftp.nus.sg/pub/unix/Linux"></bf>
<item><bf><url url="ftp://ftp.nectec.or.th/pub/mirrors/linux" name="ftp://ftp.nectec.or.th/pub/mirrors/linux"></bf>
<item><bf><url url="ftp://ftp.cs.cuhk.hk/pub/Linux" name="ftp://ftp.cs.cuhk.hk/pub/Linux"></bf>
</itemize>


<p>
<!-- ********************************* -->
<!-- ********************************* -->
<!--      SECCIÓN COLABORADORES        -->
<!-- ********************************* -->
<!-- ********************************* -->

<sect>Colaboradores<label id="colaboradores">
<p>
Ante todo dar las gracias a todos los colaboradores que han participado en la creación de este documento. Sin su ayuda, sin sus conocimientos y sin el tiempo que han dedicado, no hubiese sido posible crearlo. Mas adelante teneis una lista de las personas que han participado activamente en la redacción/creación de la FAQ sobre linux en castellano. 
<p>
Gracias a Hispafuentes (<url url="http://www.hispafuentes.com" name="http://www.hispafuentes.com">) y a César Ballardini por la aportación del glosario de terminos de la FAQ, y a Ignacio Arenaza por su aportación a la sección sobre RSDI.
<p>
Por último, gracias a B-52, U2, Aretha, B.B.King y Eric Clapton por haberme acompañado con su musica durante la creación/montaje de esta Faq.

<itemize>
<item>Rafael Martínez, rafael@viewpoint.no
  &nl  <tt>Coordinador, correcciones, revisión, montaje.   &nl   
Secciones 1, 5, 14, 15, 17, 18, 19, 20   &nl  
Subsecciones 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 6.1, 6.7, 6.9, 7.12
</tt> 
<p>
<item>A. Gustavo Gonzalez, agonzale@cica.es, Universidad de Sevilla
  &nl  <tt>Colaborador   &nl  
Sección 4  &nl  
Subsecciones 2.1, 2.9, 7.11, 9.6
</tt> 
<p>
<item>Mario Teijeiro Otero, asimovi@teleline.es
  &nl  <tt>Colaborador   &nl  
Sección 8 &nl
Subsección 6.3, 6.4, 6.5, 7.1, 7.2, 7.3, 7.5, 7.13 
</tt>
<p>
<item>Manuel Constantino, constan@bart.us.es
  &nl  <tt>Colaborador   &nl  
Subsecciones 9.1, 9.2, 9.3, 9.4, 9.5, 9.7, 9.8, 9.9, 9.10, 9.11, 9.12, 9.13, 9.14. 
</tt>
<p>
<item>Santiago Romero Iglesias, sromero@unix-shells.com
  &nl  <tt>Colaborador   &nl  
Secciones 11, 12, 13  &nl  
Subsecciones 3.9, 6.2, 6.6, 6.8, 7.6, 7.7, 7.8, 7.9, 7.10
</tt>
<p>
<item>César Ballardini/Hispafuentes, cballard@santafe.com.ar
  &nl  <tt>Aportación   &nl  
Sección 16
</tt>
<p>
<item>Ignacio Arenaza, inaki.arenaza@jet.es
  &nl  <tt>Aportación   &nl  
Sección 10
</tt>

</itemize>

<!-- **************************** -->
<!-- **************************** -->
<!--  SECCIÓN POR HACER/HECHO     -->
<!-- **************************** -->
<!-- **************************** -->

<sect>Cambios / Por hacer
<p>
<bf/Cambios de la versión 2.0.1 a la version 2.0.2/:
<itemize>
<item>Nueva sección sobre dispositivos USB
</itemize>
<p>
<bf/Cambios de la versión 2.0 a la version 2.0.1/:
<itemize>
<item>Actualización de direcciones de correo electrónico y www.
<item>Corrección de fallos en la sección ¿Cómo conecto a internet con pppd ?
<item>Corrección de fallos en la sección Entonces, ¿Qué es un winmodem, modem HSP o modem software ? ¿Funcionan los winmodem en Linux ? ¿Y los modems PCI? 
</itemize>
<p>
<bf/Cambios de la versión 1.0 a la version 2.0/:
<p>
<itemize>
<item>La sección "Comandos básicos" pasa a llamarse "Bash shell/Comandos básicos" y se amplia con nuevos contenidos.
<item>La sección "Internet/Modems/redes" pasa a llamarse "Internet/Modems"
<item>Nueva sección "Internet/RDSI"
<item>Nueva sección Glosario de terminos.
<item>Nueva subsección "¿Cómo instalo un nuevo programa?" (sección Administración)
<item>Nueva subsección "Mi ordenador usa siempre toda la memoria disponible ¿Qué es lo que ocurre?" (sección ¿Problemas diversos?).
<item>Nueva subsección "Fatal signal 11" (sección ¿Problemas diversos?).
<item>Actualización de URLs.
<item>Actualización de muchas de las subsecciones.
<item>Revisión general.
<item>Las fuentes en SGML se distribuyen con un fichero "Makefile" que nos ayudará a generar los diferentes formatos de la FAQ. Leer el archivo LEEME para más información.
</itemize>
<p>
<bf/Por hacer/:
<p>
Aquí teneis una lista con las secciones e ideas que tenemos pensado incluir en futuras versiones de este documento:
<itemize>
<item>Revisión de lo ya publicado, después de recibir comentarios de los usuarios.
<item>Sección Trucos y ajustes del sistema.
<p>
<item>Subsección Configurando Bash.
<item>Subsección Trucos y consejos sobre Bash.
<p>
<item>Subsección ¿Qué paquetes instalo?
<p>
<item>Subsección ¿Qué entorno gráfico es el mejor?
<p>
<item>Subsección ¿Cómo configuro la impresora?
<item>Subsección ¿Cómo instalo mi ZIP-drive?

</itemize>


<!-- **************************** -->
<!-- **************************** -->
<!--    SECCIÓN COPYRIGHT         -->
<!-- **************************** -->
<!-- **************************** -->

<sect>Copyright
<p>
Este documento se distribuye "tal como es" (as is). La información incluida en el mismo no esta garantizada por sus autores, aunque se ha realizado un gran esfuerzo para comprobar la información contenida en el mismo. Muchas de las operaciones que se describen en este documento son necesarias hacerlas con permisos "root" (administrador), con el riesgo que esto supone para las personas que no tengan claros ciertos conceptos de seguridad y forma de trabajo en sistemas Unix/Linux.
<p>
La "FAQ sobre Linux para principiantes" es Copyright (c) 1999-2000 por Rafael Martínez-rafael@viewpoint.no y los colaboradores de la FAQ, bajo los terminos de Licencia del Proyecto de documentación de Linux (LPD). En <url url="http://metalab.unc.edu/pub/Linux/docs/LDP/LDP-COPYRIGHT" name="http://metalab.unc.edu/pub/Linux/docs/LDP/LDP-COPYRIGHT">, teneis el texto de este copyright.
<p>
La "FAQ sobre Linux para principiantes" puede ser reproducida y distribuida total o parcialmente, siempre que no se cobre por el documento en si, sin la autorización del autor/es y se cumplan los terminos de Licencia bajo la que se distribuye. Esta restricción no prohibe el cobro por servicios de impresion o copia del documento. 


</article>








