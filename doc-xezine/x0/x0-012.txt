
-=|======================[ x-eZine x#0 / Art. 012 ]=======================|=-
-=|===============[ Introduccion a las arquitecturas RISC ]===============|=-
-=|===================[ By Raciel <raciel@x0und.net> ]====================|=-

		Introducción a las arquitecturas RISC
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	Introducción
	~~~~~~~~~~~~
	
	El desarrollo de  los  computadores  ha  sido  marcado conforme a los 
lenguajes de alto nivel (HLL) han ido  evolucionando. Según han ido evolucio-
nando estos lenguajes, su estudio ha dado lugar al diseño de un nuevo tipo de
 arquitectura, esta nueva arquitectura se conoce como arquitectura RISC o más
ampliamente dicho "computador de  repertorio  reducido  de instrucciones". El
precursor a esta  nueva  arquitectura  se  conoce  como  CISC  (Computador de
repertorio complejo de instrucciones)  cuya  fecha de desarrollo data de 1973
con el IBM 370 y posteriores  modelos  de  este  son el VAX 11/780 y el Intel
80486. Modificaciones posteriores de  RISC (SPARC y MIPS R4000) son conocidos
como superescalares (1973) con los PowerPC, Ultra SPARC y los MIPS R10000.

	Antes ya comenté que el desarrollo d este nuevo tipo de arquitecturas
viene marcado por los HLL, ya que  se  diferenciaban bastante sus operaciones
de las que realizaba entonces un  computador,  causando una gran ineficiencia
en la ejecución de los programas, un tamaño  excesivo y una mayor complejidad
en los compiladores. Para ello se decidió implementar muchas de las operacio-
nes definidas en HLL en  el  HW  del  computador,  con  lo cual facilitaba el
trabajo de los desarrolladores  de  compiladores  (se  rigen por autómatas de
estado que van interpretando  cada una de las órdenes que el programador vaya
a usar, como clausulas if, bucles while,  etcétera), mejorar la eficiencia de
la ejecución de los programas y dar un soporte a HLL de mayor complejidad.

	Con esto, más o menos  se ve la necesidad  de un nuevo tipo de arqui-
tectura de computador en la  que vaya a  implementar tales operaciones en las
que comunmente son  ASSIGN, LOOP, CALL,  IF y GOTO  que  ya permitian dar una
mayor facilidad a la hora de desarrollar un compilador y ganar en eficiencia.

	Amplio uso de registros
	~~~~~~~~~~~~~~~~~~~~~~~

	Debido al estudio de los HLL para el diseño de este tipo de arquitec-
turas, se contempla que en la  mayoría de  compiladores el paso de argumentos
en las funciones o llamadas a procedimientos  suele ser un numero entorno a 6
args por lo que supone el uso de  una gran  cantidad de registros donde poder
almacenarlos para tener un rapido acceso a los operandos de las funciones.

	La razón de almacenarlos en  registros  es  que es el dispositivo más
rápido disponible, aun más que la  memoria caché o la memoria principal, pero
a consecuencia conlleva un gran  coste,  de   ahí que cuando nosotros estemos
pensando en adquirir una máquina RISC, observemos un elevado coste.

	Aún pensar en usar muchos registros, en las arquitecturas RISC lo que
se va a hacer es que cuando se llame  a un  procedimiento va a conmutar a una
ventana con registros de tamaño fijo en vez de guardar los registros en memo-
ria. En caso de tratarse de  ventanas con  tres registros y en el caso de una
mayor necesidad de registros lo que se va a  hacer es solapar varias ventanas
para permitir el paso de todos los parametros sin necesidad de acudir a memo-
ria principal o a memoria caché.

	Estos registros no van a almacenar  unicamente los parametros a pasar
sino que van a contar con tres tipos de registros:

	* Registros de parámetros: Va a almacenar los parámetros que le pase-
	  mos a la funcion o procedimiento.

	* Registros de datos locales: Se van a almacenar variables locales de
	  la funcion que se le vaya a pasar.

	* Registros temporales: Se van  a usar  para  intercambiar parametros 
	  con el siguiente nivel más bajo,  es  decir,  la ventana con la que 
	  estemos solapando que será el procedimiento llamado por el procedi-
	  miento en curso.

	De tal manera, con un  programa  en  curso, nosotros vamos a tener un
puntero a la ventana actual CWP que  apunta  a la  ventana  del procedimiento 
actual y un SWP (puntero a la  ventana  guardada) que identifica a la ventana
de memoria guardada más recientemente, de forma que formará una especie ciclo
de ejecución con una serie de  ventanas  que  iremos  recorriendo conforme se 
vayan ejecutando procedimientos.

	A esta cantidad de registros se le llama globalmente "banco de regis-
tros" . Como ejemplo decir que RISC usa  8  ventanas de 16 registros cada una
y que todo esto tiene efecto a la hora  de variables locales pero el problema
está en que nosotros  queramos  usar  variables  globales por parte de varios
procedimientos. La solución a  esto  no  es  más  que  el uso de una serie de
registros globales.

	Una arquitectura en particular: SPARC
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	SPARC se corresponde a las  siglas  "Scalable Processor Architecture" 
(Arquitectura de Procesador  Escalable),  es  una  arquitectura  diseñada por
Sun Microsystem basada en una arquitectura  RISC I de Berkeley que cuenta con
el mismo modelo de instrucciones y de registros.

	Registros en SPARC
	~~~~~~~~~~~~~~~~~~

		Al igual que  una  arquitectura  RISC,  como la anteriormente
comentada, SPARC, va a contar  con ventanas de registros. Cada ventana cuenta
con 24 registros donde se van  a almacenar  variables locales mas otros siete
registros que están  destinados  para  variables  globales. De esta forma, un
proceso lo verá todo como bloques d 31 registros que utilizará dependiendo de
las variables que vaya a  utilizar, ya  habíamos  comentado  que entre los 24 
registros los dividirá en tres zonas, en la que cada zona será destinada para
un determinado propósito. De estos 24  registros lógicos, los registros 24-30 
son compartidos con  el  procedimiento  que  hace  la  llamada  (padre) y los 
registroslógicos del 8-15 son compartidos con el procedimiento llamado (hijo)
Luego quedarán los registros 16-23 que están destinados para almacenar varia-
bles locales, por lo que ni se comparten ni se superponen con otras ventanas,
son propios del proceso en sí.

	A la hora de superponer registros  y  llevar la solapación se necesi-
tara ir recorriendo sobre todas  las  ventanas,  eso  se hace a través de dos
punteros, el CWP (Current Window  Pointer)  que  apunta a la ventana actual y
guarda esta información en el registro  de estado del procesador y un puntero
SWP que guarda la ventana anterior de forma que se forme una especie de lista
y podamos ir recorriendo todas las ventanas.

	Formato de Instruccion
	~~~~~~~~~~~~~~~~~~~~~~
	El SPARC emplea un formato de instrucción de 32 bits, en las que todas
las instrucciones comienzan con un código de operaciones y el resto se utiliza
para almacenar datos de esa instrucción:

      +---------+--------+-------------------------------------------+
      | Llamada |   OP   |    DESPLAZAMIENTO RELATIVO A PC           |
      +---------+--------+-------------------------------------------+
		| 2 bits |           30 bits                         |
		+--------+-------------------------------------------+

      +--------------+----+---+----+---+-----------------------------+
      | Bifuraciones | OP | A |COND|OP2|DESPLAZAMIENTO RELATIVO A PC |
      +--------------+----+---+----+---+-----------------------------+
		     | 2  | 1 |  4 | 3 |           22                |
		     +----+---+----+---+-----------------------------+
      +-------+----------------+--------+----------------------------+
      | SETHI |  OP DEST (5)   | OP2 3  | CONSTANTE INMEDIATA 22     |
      +-------+-------+--------+--------+------+----------+----------+
      | Coma Flotante |  OP 2  | DEST 5 | OP 3 | Fuen-1 5 | Fuen-2 5 |
      +---------------+-+------+--------+------+----------+---+------+---+
      | Formato General | OP 2 | DEST 5 | OP 3 | Fuen-1 5 | 0 | Ignorado |
      +---------+-------+------+--------+------+----------+---+----------+
      | Fuen2 2 |
      +---------+

      Aclaración: A la derecha de cada  campo reservado para cada  formato se 
      muestran el tamaño en bytes de dichos campos.
      
	En la instrucción de llamada,  un  operando  inmediato  de 30 bits se 
amplia con dos bits a 0 a la derecha,  para  formar  una direccion de 32 bits
relativa a PC en complemento a dos.  Las  instrucciones se alinean en 32 bits
por lo que basta esta forma de direccionamiento.

	En la instrucción de bifuración  incluye  un  campo de condicion de 4 
bits que corresponden a los bits de  codigos  de  condicion normales, de modo
que se pueda comprobar cualquier  combinacion de condiciones. Luego el bit de
anulacion, que indica que se produzca  el  salto  en caso de no estar a 1, el
inconveniente es que se produce un  retardo  en su comprobacion, es lo que se
conoce como salto retardado.Luego los dos operandos del principio se le suman
a los 22 bits de la direccion  relativa  para poder representar esa dirección
en complemento a 2.

	La instruccion SETHI es una  instrucción que se utiliza para cargar o
almacenar un varlor de 32 bits. Se suele  utilizar para almacenar direcciones
o constantes grandes. Se utilizan los 22 bits para almacenar la constante, en
la que unicamente usa  12 para  almacenamiento, el resto los rellena a 0s. En
caso de tratarse de una instrucción almacena en los 12 o 13 primeros bytes el
dato y los otros 10 bits los utiliza para almacenar la instrucción.

	Luego el formato de coma flotante se utiliza para operaciones de coma
flotante donde se pasan dos registros, el registro origen y el registro 
fuente.

	Luego para las ultimas operaciones que utilizan cargas, almacenamien-
tos, operaciones aritméticas, lógicas, se utiliza el ultimo registro.

	¿Qué instrucciones tenemos en RISC?
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	Las instrucciones  disponibles  que  nos  va  a  permitir van a estar
contenidas en la ALU y se pueden agrupar como las siguientes:

	* Suma entera
	* Resta entera
	* Operaciones bit a bit (AND, OR, XOR y sus negaciones)
	* Desplazamientos lógicos y aritméticos.
	
	Luego todas  estas  operaciones  podrán  ajustarse  a  cuatro códigos
de condición que son los  anteriormente  comentados  que son (CERO, NEGATIVO,
DESBORDAMIENTO y ACARREO).

	A continuación se muestra las instrucciones válidas para SPARC:

	   +====================================================+
	   | Instrucciones de carga o almacenamiento.           | 
	   +=========+==========================================+
	   | LDSB    | Cargar bit con signo.                    |
	   | LDSH    | Cargar media palabra con signo.          |
	   | LDUB    | Cargar byte sin signo.                   |
	   | LDUH    | Caragar media palabra sin signo.         |
	   | LD      | Cargar palabra.                          |
	   | LDD     | Cargar doble palabra.                    |
	   | STB     | Almacenar byte.                          |
	   | STH     | Almacenar media palabra.                 |
	   | STD     | Almacenar palabra.                       |
	   | STDD    | Almacenar doble palabra.                 |
	   +=========+==========================================+
	   | Instrucciones de desplazamiento.                   |
	   +=========+==========================================+
	   | SLL     | Desplazamiento lógico a la izquierda.    |
	   | SRL     | Desplazamiento lógico a la derecha.      |
	   | SRA     | Desplazamiento aritmético a la derecha.  |
	   +=========+==========================================+
	   | Instrucciones booleanas.                           |
	   +=========+==========================================+
	   | AND     | Y.                                       |
	   | OR      | O.                                       |
	   | ANDN    | No Y.                                    |
	   | ORN     | No O.                                    |
	   | XOR     | OR exlusive.                             |
	   | XNOR    | NOR exclusive.                           |
	   +=========+==========================================+
	   | Instrucciones aritméticas.                         |
	   +=========+==========================================+
	   | ADD     | Sumar.                                   |
	   | ADDX    | Sumar con acarreo.                       |
	   | SUB     | Restar.                                  |
	   | SUBX    | Restar con borrow.                       |
	   +=========+==========================================+
	   | Instrucciones de salto/bifurcacion.                |
	   +=========+==========================================+
	   | BCC     | Bifurcar si condicion.                   |
	   | FBCC    | Bifurcar si condicion de coma flotante.  |
	   | CBCC    | Bifurcar si condición de procesador.     |
	   | CALL    | Llamar a procedimiento.                  |
	   | JMPL    | Saltar y enlazar.                        |
	   | TCC     | Interceptar si condicion.                |
	   | SAVE    | Avanzar ventana de registros.            |
	   | RESTORE | Mover ventanas hacia atrás.              |
	   | RETT    | Retornar de interceptación.              |
	   +=========+==========================================+
	   | Otras instrucciones.                               |
	   +=========+==========================================+
	   | SETHI   | Fijar los 22 bits más altos.             |
	   | UNIMP   | Interceptación.                          |
	   | RD      | Leer un registro especial.               |
	   | WR      | Escribir un registro especial.           |
	   | IFLUSH  | Vaciar la caché de instrucciones.        |
	   +=========+==========================================+ 


	A esto, hay que  añadirle  operaciones  derivadas  en las que se usan
operandos de condición como ANDCC, ANDNCC, etcétera.

Despedida
~~~~~~~~~

	Bueno, ya habiendo hablado de los registros, los tipos de instruccio-
nes,lo que es la arquitectura RISC, y  una espeficación como es SPARC, espero
que más o menos haya quedado  clara  una introducción a la arquitectura RISC. 
Espero que os haya gustado. Nos vemos pronto. Hasta otra :-)

----[Raciel <Raciel@x0und.net>
