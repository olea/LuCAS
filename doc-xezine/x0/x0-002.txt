
-=|=======================[ x-eZine #0 / Art. 002 ]=======================|=-
-=|=============================[ Entrevista ]============================|=-
-=|====================[ By Staff <xezine@x0und.net> ]====================|=-


Entrevista: William Lee Irwin III Enviada por rhron el Miércoles, 13 de Marzo
de 2002 - 02:14

William Lee Irwin III, mejor conocido  como "wli" en el canal de IRC de open-
projects,  #kernelnewbies , es  uno   de  los  desarrolladores  que  ayudan a
implantar una función de mapping inverso en el kernel de Linux.

    _________________________________________________________________

Randy Hron: ¿Por cuánto tiempo has estado trabajando con sistemas operativos?
¿Unix? ¿Linux?

William Lee Irwin III: Depende de lo  que  consideres trabajar con un sistema
operativo. La programación de sistemas, p.ej. escribir código que corre en el
kernel, sólo he estado haciendo eso desde  los días en que fui contratado por
la IBM.

He usado Linux como  entorno  para  programar  aplicaciones  de usuario final 
desde el 96, y mi primera  experiencia  computacional fué en los laboratorios
de sistemas del ECN Purdue  en 1993, que consistía en unas cuantas terminales
Visual Graphics X-19 e IPCs  de  Sun  que  servían  como  terminales para una
Sequent S-81. Antes del 2000 no tuve ninguna participación en la programación
del kernel. Principalmente, Solaris  fue mi entorno de programación principal
antes del 2000 (claro que entonces  yo  no hacía nada que tuviese que ver con
el kernel de Linux o cualquier otro), aunque también utilicé algo de IRIX.

rwh: ¿Por cuánto tiempo has estado en la IBM? ¿Cómo ha variado la posición de
Linux con IBM?

wli: He trabajado para IBM desde Abril de 2000. Cuando empecé, trabajaba para
Sequent, que estaba siendo absorbida por IBM. IBM es una compañía muy grande,
así que, en diferentes lugares, hay distintas áreas de especialidad. No puedo
fingir tener mucho conocimiento de la amplitud o la historia de los planes de
negocios de IBM, pero, al menos para  mí, el progreso pasó de DYNIX/ptx a AIX
y luego a Linux mientras aprendía cada vez más sobre programación d sistemas.
Durante algún tiempo, No había mucho interés en Linux en nuestro puesto, pero
en algún momento, se tomó la decisión de  hacerlo el centro de la atención de
nuestro puesto, y esto parece estar saliéndonos bien.

rwh: ¿En qué se diferencia Linux de otros proyectos en los que te hayas
involucrado?

wli: Pues, Linux tiene una base  de  usuarios  mucho mas amplia, así como mas
visibilidad. Por lo demás, los asuntos importantes son similares. Los kernels
de UNIX son programas enormes en todas  partes, y la programación involucrada
es de bajo nivel y compleja en todas  partes. Linux no es la excepción. Otros
asuntos son superficiales respecto  a  lo  que  se siente al participar en un
proyecto. Por ejemplo,  cosas  como  el  número  de  gente que participa y la
cantidad de líneas de  código  no  hacen  mucha diferencia a menos que sea de
varios órdenes de magnitud. Cosas como  el  estilo del código, aunque son muy
importantes, son también superficiales: cada proyecto tiene su propio estilo,
y tú lo sigues. En lo que respecta a sistemas operativos, las características
que definen a Linux no  parecen  tener  mucho  impacto  en  lo que respecta a
programarlo.

Hay una diferencia que parece importar, pero no afecta realmente la operación
cotidiana. Se trata de que  Linux  es  un  entorno  competitivo. Muchos otros
esfuerzos no tienen varias personas  presentando soluciones distintas para el
mismo problema, pero en Linux esto es común. La diferencia mas importante que
esto provoca es que  la  gente  que  no  concuerda  respecto  a  cómo debería
implementarse algo  tienen  código  que  funciona,  para  demostrar que puede
desplazar el tuyo.

rwh: ¿Que es lo que más disfrutas de la programación/matemática?

wli: Es extraño que lo  admita,  pero  creo  que  he descubierto mas sobre la
clase de programación que  me  gusta  hacer  y la clase de matemáticas que me
gustan ahora que estoy fuera de  la  escuela que dentro de ella. Ahora que he
estado bajo mi propia dirección, la clase de matemáticas en las que he tomado
interés han sido más computacionales, y la clase de programación en la que he
tomado interés ha sido más de  efecto-secundario que aquello que creía que me
interesaba. Específicamente, las  matemáticas que me interesan son cosas como
material del siglo 19  sobre  funciones  elípticas,  y la programación que ha
atraído mi interés ha sido (por supuesto) programación del kernel.
Esencialmente, he descubierto qe me gusta hacer cosas que producen resultados
concretos y observables.

Creo que la clave para comprender  lo que me gusta, es hacer cosas por capri-
cho, y luego analizar lo que  he hecho para descubrir lo que me gusta, y per-
mitirme gravitar naturalmente hacia lo que quiero hacer. Esto se contrapone a
hacer las cosas con una idea  preconcebida  de lo que me va a gustar, lo cual
creo que ha resultado en la pérdida  de  oportunidades para diversión y logro
en mis primeros años. Por supuesto, existen límites claros a qué tan lejos se
puede llevar esta idea.

Si analizo en retrospectiva lo  que  me  gusta de las matemáticas y lo que me
gusta de la programación, es  difícil  de  caracterizar en términos formales.
Lo siento por Dijkstra, pero tendré ke recurrir a una analogía. Es como si yo
fuese un niño en el reino de las demostraciones y los programas, silogismos e
hipótesis; los teoremas,  las  tablas  de hash y los árboles binarios son mis
ladrillos de  construcción,  y  juego  ensamblando  mis  juguetes  en enormes
catedrales, piedra por piedra, ladrillo por ladrillo.Y quizás algún día, tras
reconstruir el mundo dentro de la máquina muchas veces, llegará el momento en
que me salga bien y pueda vivir dentro d un palacio de cristal, pero sospecho
que la iteración no es un proceso finito.

rwh: Suena como si tuvieses conocimientos de ciencias computacionales. ¿Dónde
recibiste tu educación?

wli: Tengo un título de  bachiller  de  ciencias de la Universidad de Purdue,
donde me gradué en matemáticas y ciencias computacionales.

rwh: ¿Qué disfrutas hacer cuando no estas trabajando?

wli: Pues, el lio es que programar es mi  forma principal de entretenimiento.
Así que, desde cierto punto de vista,  me  pagan por holgazanear todo el dia.

Sin embargo, también hago  otras  cosas.  Hay  clubs  nocturnos que visitar y
asuntos que atender de vez en cuando, y  hago algunas cosas ordinarias que no
son programación, como ver animé y leer ficción y cosas así. Hay otras cosas,
pero solo están ahí.

Tambien esta el IRC, pero es mas  bien  un suplemento (o quizás un reemplazo)
de los grupos de Usenet y listas  de correo y llamar a la gente por teléfono,
y uno muy efectivo. Copiar y pegar  código para que lo vez gente al otro lado
del mundo es extremadamente conveniente,  así como la habilidad para discutir
algoritmos y diseños y todo eso.

rwh: Tienes un gusto ecléctico por la música. ¿Qué música te atrae más?

wli: No se qué decir a esto. No  soy particularmente experto en música. Cole-
cciono algo y colecciono lo  que  me  gusta  (por supuesto). Dar una lista de
los artistas y discos sería demasiado banal. Es difícil caracterizar la clase
de música que me gusta en  términos  de  género, pero hay un patrón definido.
Para mí el contenido de la música no  són  las palabras ni las notas, sino la
atmósfera ke crea y la respuesta emocional que activa. Ya sea calculado o una
coincidencia, técnicamente avanzado o  golpeando los instrumentos a lo tonto,
el valor de los sonidos resultantes se  juzga sólo por el poder de su efecto.

Al contemplar mis listas de  canciones,  parecen haber varios temas visibles.
Uno de ellos es un impulso grandiosamente hiperagresivo de liberación. Otro d
ellos es un grito de pena y llanto. Y  otro de ellos es un escapismo obtenido
por medio de la complejidad deliberada. Y, por supuesto, humor.

rwh: ¿Algún consejo para el aspirante a hacker?

wli: Pues, yo mismo soy aún un aspirante. =)

Todos dicen que la clave está en la persistencia, pero eso no basta. Una cosa
que he notado es que, como el kernel es responsable de mantener la integridad
de los datos y de la imágen del sistema el costo de un fallo (p. ej. bugs, y,
como con cualquier programación, son numerosos) es que se pierden datos y los
sistemas se cuelgan. Hay que superar el  gran temor a quebrantar la operación
correcta de un sistema o a perder datos. Cuando un kernel se cuelga, destruye
datos y el sistema se cuelga, y no puedes vivir con miedo a ke esto ocurra si
quieres llegar a alguna  parte. La  programación  es una actividad propensa a
errores, y uno debe estar preparado para cometer errores. Un obstáculo que yo
solía tener era ser demasiado  cuidadoso  y obsesionado con revisar el código
una y otra vez, para  asegurarme  de  que  el  sistema no se quedaría colgado
cuando intentase correrlo.

Esto no es nada efectivo.Un método mas efectivo sería crear una caja de arena
donde sólo haya datos sin importancia y el sistema no sea esencial y ejecutar
el código ahí y comprobar qué salió  mal  cuando el sistema se cuelgue. Y eso
no es fácil. Si no  cuentas  con  mucho  apoyo del hardware (lo cual requiere
demasiado dinero para  ser  práctico)  por lo general no es posible recuperar
mucho del estado del sistema después del evento, así que se requiere resolver
esto haciendo un volcado del estado del kernel a disco en momentos apropiados
o correrlo dentro de un  simulador  (por  suerte, bochs es libre y gratuito).
Existen algunas infraestructuras, como kgdb y kdb. Ya estoy mencionando cosas
que suelen ser consideradas herejía,  pero no me importa. Otro detalle es que
leer código es más difícil  que  escribirlo  (y  depurarlo es más difícil que
cualquiera de los dos) así que reescribir  algo desde cero será más fácil que
hallar los pequeños cambios ke se requieren para resolver problemas d verdad.
Para el hacking d kernel cotidiano, reescribir no te llevará a ninguna parte,
pues quienes escribieron el  código  original pondrán el grito en el cielo, y
quienes tienen que llamar a tus subrutinas están muertos d miedo ante la idea
de que tendrán que enfrentar nuevos  fallos en un código no familiar. Pero es
útil como muleta para resolver el problema d no ser muy capaz de leer código.
Quizás alguien me acusará  por  decir  estas  cosas, ya que es inevitable que
hayan reescrituras frívolas  de  todo  tipo  después de cualquier declaración
pública como ésta,  pero  si  la  gente  comienza  a mover el culo y dejan de 
duplicar  los  códigos  de  los  demás  de $VM + O(1) + basura  miscelánea  y
empiezan a escribir algo de código nuevo, valdrán la pena los flamazos.

Releo lo anterior, y me doy cuenta de que es un tanto pesado como para que la
intención sea clara para todos.  Escribe  algo y no permitas que el exceso de
cautela te atore, y comienza a hacer pruebas rápidamente.

¡Haz algo y haz algo nuevo!
