<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="es">
  <head>
    <meta name="generator" content="HTML Tidy for Linux/x86 (vers 1st June 2002), see www.w3.org">

    <title>Comunicación entre Procesos UNIX.</title>

    <style type="text/css">
 body {
  background-color: #FFFFFF;
  color: #000000;
 }
 :link { color: #0000FF }
 :visited { color: #800080 }
 :active { color: #FF0000 }
 p.c25 {color: #000000}
 td.c24 {color: #000000}
 div.c23 {color: #000000; text-align: right}
 div.c22 {color: #000000; font-weight: bold; text-align: center}
 b.c21 {color: #000000}
 i.c20 {font-family: Courier New; font-size: 80%}
 dd.c19 {color: #000000; font-weight: bold}
 pre.c18 {color: #000000}
 tt.c17 {color: #000000}
 dt.c16 {color: #000000}
 h4.c15 {color: #000000}
 div.c14 {margin-left: 2em}
 dd.c13 {color: #000000}
 dt.c12 {color: #000000; font-weight: bold}
 h3.c11 {color: #000000}
 h2.c10 {color: #000000}
 span.c9 {color: #000000}
 a.c8 {color: #000000}
 div.c7 {color: #000000; font-style: italic; font-weight: bold; text-align: center}
 p.c6 {color: #000000; font-style: italic; font-weight: bold}
 span.c5 {font-size: 120%}
 span.c4 {font-size: 144%}
 h1.c3 {color: #000000; font-style: italic; font-weight: bold}
 div.c2 {text-align: center}
 h1.c1 {color: #000000; font-size: 207%; font-style: italic}
            </style>
  </head>

  <body>
    <div class="c2">
      <h1 class="c1">Bienvenidos</h1>
    </div>

    <div class="c2">
      <h1 class="c3">ENTORNO DE<br>
       PROGRAMACIÓN EN UNIX:</h1>
    </div>

    <div class="c2">
      &nbsp;
    </div>

    <p class="c6"><span class="c4">E</span>n esta pagina presento una<span class="c5">&nbsp; "</span> <span class="c4">recopilación "&nbsp;</span> de programas en sistemas <span class="c4">UNIX</span>, la cual espero que sea de su provecho.</p>

    <div class="c7">
      Emilio J. Gómez
    </div>

    <p><a href="mailto:ejgo@hotmail.com" class="c8">ejgo@hotmail.com</a><br>
     <span class="c9">&nbsp;</span></p>

    <h2 class="c10">1. PROCESOS.</h2>

    <h3 class="c11">1,1. Conceptos generales.</h3>

    <dl>
      <dt class="c12">Proceso:</dt>

      <dd class="c13">programa o comando en ejecución.</dd>

      <dd class="c13">Características:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li>Un proceso consta de código, datos y pila.</li>

            <li>Los procesos existen en una jerarquía de árbol (varios Hijos, un sólo padre).</li>

            <li>El sistema asigna un identificador de proceso (PID) único al iniciar el proceso.</li>

            <li>El planificador de tareas asigna un tiempo compartido para el proceso según su prioridad (sólo <i>root</i> puede cambiar prioridades).</li>
          </ul>
        </div>
      </dd>

      <dt class="c12">Ejecución en 1er plano:</dt>

      <dd class="c13">proceso iniciado por el usuario o interactivo.</dd>

      <dt class="c12">Ejecución en 2o plano:</dt>

      <dd class="c13">proceso no interactivo que no necesita ser iniciado por el usuario.</dd>

      <dt class="c12">Demonio:</dt>

      <dd class="c13">proceso en 2o plano siempre disponible, que da servicio a varias tareas (debe ser propiedad del usuario <i>root</i>).</dd>

      <dt class="c12">Proceso zombi:</dt>

      <dd class="c13">proceso parado que queda en la tabla de procesos hasta que termine su padre. Este hecho se produce cuando el proceso padre no recoge el código de salida del proceso hijo.</dd>

      <dt class="c12">Proceso huérfano:</dt>

      <dd class="c13">proceso en ejecución cuyo padre ha finalizado. El nuevo identificador de proceso padre (PPID) coincide con el identificador del proceso <b>init</b> (1).</dd>
    </dl>
    <hr>

    <h3 class="c11">1,2. Ejecución de comandos.</h3>

    <h4 class="c15">1,2,1. Subrutina <i>system</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Llamada a un intérprete para ejecutar un comando.</dd>

      <dd class="c13">El proceso espera a que finalice la ejecución de la subrutina y devuelve la salida del programa ejecutado.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;stdlib.h&gt;</tt></dd>

      <dd><tt class="c17">int system (cadena)</tt></dd>

      <dd><tt class="c17">const char *cadena;</tt></dd>

      <dt class="c16">- Parámetro:</dt>

      <dd class="c13">cadena - Comando a ejecutar.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">Estado de salida del programa ejecutado. -1 o 127 en caso de error.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) Se crea un proceso hijo (<b>fork</b>) y se lanza (<b>exec</b>) <b>/usr/bin/bsh</b>, que interpreta el comando a ejecutar.</dd>

      <dd class="c13">b) Si la llamada se hace con camino seguro, la orden <b>exec</b> ejecuta el intérprete <b>/usr/bin/tsh</b>.</dd>

      <dd class="c13">c) Se ignoran las señales <b>SIGINT</b> y <b>SIGQUIT</b> y se bloquea la señal <b>SIGCHLD</b>.</dd>

      <dd class="c13">d) La salida de <b>system</b> no afecta a la salida de los procesos hijos del proceso ejecutor.</dd>
    </dl>
    <hr>

    <p><a name="system"></a><span class="c9">- Ejemplo:</span></p>
<pre class="c18">
/* system.c - Listar los procesos del usuario usando system. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main ()
    {
    int  salida;        /* Salida del comando */
    char comando[100];  /* Comando a ejecutar */

    printf ("Ejemplo de system.\n");
    sprintf (comando, "/bin/ps -fu %s", getenv ("USER"));
    salida = system (comando);
    printf ("Salida del comando: %d\n", salida);
    exit (salida);
    }



Ejemplo de system.
    USER     PID    PPID     TTY  CMD
   ramon    3638       1   hft/0  -ksh
   ramon   10089   10600   hfp/0  /bin/ps -fu ramon
   ramon   10600   11623   hft/0  bsh bsh bsh
   ramon   11623    3638   hft/0  system.e
Salida del comando: 0
</pre>
    <span class="c9">Suponiendo que no existe el comando MUSHO y sustituyendo la ejecución de <b>system</b> por la siguiente línea, se obtiene la salida mostrada a continuación.</span> 
<pre class="c18">
<b>salida = system ("MUSHO BETI");


</b>Ejemplo de system.
bsh: MUSHO: no encontrado.
Salida del comando: 256
</pre>
    <hr>

    <h4 class="c15">1,2,2. Subrutinas <i>exec</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Ejecuta un nuevo programa en el mismo proceso.</dd>

      <dd class="c13">Se crea un proceso imagen sustituyendo el programa actual por el nuevo.</dd>

      <dt class="c16">- Formatos:</dt>

      <dd><tt class="c17">#include &lt;unistd.h&gt;</tt></dd>

      <dd><tt class="c17">int execl (camino, arg0 [, arg1, ...] , 0)</tt></dd>

      <dd><tt class="c17">const char *camino, *arg0, *arg1, ...;</tt></dd>

      <dd><tt class="c17">int execle (camino, arg0 [, arg1, ...] , 0, p_entorno)</tt></dd>

      <dd><tt class="c17">const char *camino, *arg0, *arg1, ...;</tt></dd>

      <dd><tt class="c17">char *const p_entorno[];</tt></dd>

      <dd><tt class="c17">int execlp (fichero, arg0 [, arg1, ...] , 0)</tt></dd>

      <dd><tt class="c17">const char *fichero, *arg0, *arg1, ...;</tt></dd>

      <dd><tt class="c17">int execv (camino, val_args)</tt></dd>

      <dd><tt class="c17">const char *camino;</tt></dd>

      <dd><tt class="c17">char *const val_args[];</tt></dd>

      <dd><tt class="c17">int execve (camino, val_arg, p_entorno)</tt></dd>

      <dd><tt class="c17">const char *camino;</tt></dd>

      <dd><tt class="c17">char *const val_args[], *p_entorno[];</tt></dd>

      <dd><tt class="c17">int execvp (fichero, val_args)</tt></dd>

      <dd><tt class="c17">const char *fichero;</tt></dd>

      <dd><tt class="c17">char *const val_args[];</tt></dd>

      <dd><tt class="c17">int exect (camino, val_arg, p_entorno)</tt></dd>

      <dd><tt class="c17">char *camino, *val_args, *p_entorno[];</tt></dd>

      <dt class="c16">- Sufijos:</dt>

      <dd class="c13">L - usa lista de parámetros, el último debe ser 0.</dd>

      <dd class="c13">V - usa matriz de parámetros generada previamente, el último debe ser 0.</dd>

      <dd class="c13">T - trazado del programa con <b>ptrace</b> (en desuso).</dd>

      <dd class="c13">E - usa la matriz de variables de entorno.</dd>

      <dd class="c13">P - búsqueda utilizando la variable <b>PATH</b>.</dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">camino - Camino completo del fichero ejecutable.</dd>

      <dd class="c13">fichero - Nombre del fichero ejecutable.</dd>

      <dd class="c13">arg<i>N</i> - Argumento N-ésimo.</dd>

      <dd class="c13">val_args - Puntero a la matriz de argumentos.</dd>

      <dd class="c13">p_entorno - Puntero a la matriz del entorno.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">-1, en caso de error.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) La rutina principal (<b>main</b>) de un programa C ejecutable recibe los siguientes parámetros:</dd>

      <dd><tt class="c17">int main (cont_args, val_args, p_entorno)</tt></dd>

      <dd><tt class="c17">int cont_args; /* Contador de argumentos. */</tt></dd>

      <dd><tt class="c17">char *val_args; /* Puntero a la matriz de argumentos. */</tt></dd>

      <dd><tt class="c17">char *p_entorno; /* Puntero a la matriz del entorno. */</tt></dd>
    </dl>
    <span class="c9">Las variables <i>val_args</i> y <i>p_entorno</i> son similares a las utilizadas en las subrutinas <b>exec</b>.</span> 

    <dl>
      <dd class="c13">b) Esta rutina principal llama a una subrutina de iniciación que construye la variable de entrono. Dicha variable global es accesible desde el programa declarándola de la siguiente manera:</dd>

      <dd class="c19">extern char **environ;</dd>

      <dd class="c13">Las subrutinas <b>exec</b> que no usan el parámetro <i>p_entorno</i> utilizan la variable <b>environ</b>.</dd>

      <dd class="c13">c) Los descriptores de ficheros abiertos se pasan al nuevo proceso imagen, excepto los que tengan activo el bit <b>FD_CLOEXEC</b> (ver <b><u><a href="#322">fcntl</a></u></b>).</dd>

      <dd class="c13">d) Las señales capturadas se reasignan a sus acciones por defecto; las ignoradas, continúan siendo ignoradas (ver <b><u><a href="#232">sigaction</a></u></b>).</dd>

      <dd class="c13">e) Si el nuevo proceso imagen tiene activo el bit <b>SUID</b>, la identificación efectiva de usuario (EUID) del nuevo proceso toma el valor del identificador del propietario. Idem, si tiene activo el bit <b>SGID</b>.</dd>

      <dd class="c13">f) Los identificadores reales de usuario y de grupo (RUID y RGID) mantienen el valor que tenían en el proceso llamador.</dd>

      <dd class="c13">g) El párrafo anterior puede aplicarse a ficheros remotos (previa traducción de los identificadores).</dd>

      <dd class="c13">h) El párrafo e) no afecta a las <i>shell-scripts</i>.</dd>

      <dd class="c13">i) El proceso nuevo mantiene las siguientes características del proceso llamador:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li>Identificadores de proceso (PID), de proceso padre (PPID) y de grupo de procesos (PGID).</li>

            <li>Valores de prioridad (<b>nice</b>), de TTY y del bit de trazado.</li>

            <li>Directorio actual y directorio raíz.</li>

            <li>Máscara de ficheros, limites de longitud de ficheros, límites de recursos.</li>

            <li>Tiempos para activar alarmas y subrutinas <b>times</b>.</li>

            <li>Identificador de usuario de conexión.</li>
          </ul>
        </div>
      </dd>
    </dl>
    <hr>

    <p><a name="exec"></a><span class="c9">- Ejemplo:</span></p>
<pre class="c18">
/* exec.c - Listar los procesos del usuario usando exec. */
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main ()
    {
    int  salida;/* Salida del comando */

    printf ("Ejemplo de exec.\n");
    execl ("/bin/ps", "ps", "-fu", getenv ("USER"), 0);
    printf ("Salida del comando: %d\n", salida);

    exit (salida);
    }



Ejemplo de system.
    USER     PID    PPID     TTY  CMD
   ramon    3638       1   hft/0  -ksh
   ramon   10739    3638   hft/0  /bin/ps -fu ramon
</pre>
    <span class="c9">Suponiendo que no existe el comando <b>MUSHO</b> y sustituyendo la ejecución de <b>execl</b> por la siguiente línea, se obtiene la salida mostrada a continuación.</span> 
<pre class="c18">
<b>salida = execl ("MUSHO", "BETI", 0);


</b>Ejemplo de exec.
Salida del comando: -1
</pre>
    <hr>

    <h3 class="c11">1,3. Creación de procesos.</h3>

    <h4 class="c15">1,3,1. Subrutina <i>fork</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Crea un nuevo proceso (hijo), copia casi exacta del proceso generador (padre).</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;unistd.h&gt;</tt></dd>

      <dd><tt class="c17">pid_t fork ();</tt></dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">0 al proceso hijo y PID del hijo al proceso padre (-1, si error).</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) La versión BSD (en la librería <b>libbsd.a</b>) es:</dd>

      <dd><tt class="c17">int vfork ();</tt></dd>

      <dd class="c13">b) Atributos que hereda el proceso hijo.</dd>

      <dd>
        <div class="c14">
          <ul>
            <li>Entorno.</li>

            <li>Bit <b>FD_CLOEXEC</b> para cada descriptor de fichero.</li>

            <li>Señales capturadas.</li>

            <li>SUID y SGID.</li>

            <li>Estado de privilegios y prioridades.</li>

            <li>Librerías compartidas y segmentos de memoria compartida.</li>

            <li>PGID y TTYGID.</li>

            <li>Directorio actual y directorio raíz.</li>

            <li>Máscara y límites de medida para ficheros.</li>

            <li>Eventos y estado de auditoría.</li>

            <li>Estado de depuración.</li>
          </ul>
        </div>
      </dd>

      <dd class="c13">c) Atributos diferenciadores entre padre e hijo:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li>PID único.</li>

            <li>PPID distintos (el PPID del hijo coincide con el PID del padre).</li>

            <li>El proceso hijo tiene su propia copia de los descriptores de fichero del padre, pero comparte con éste un puntero a fichero para cada descriptor del proceso padre.</li>

            <li>Bloqueos de proceso, texto y datos no se heredan.</li>

            <li>Las subrutinas <b>times</b> se ponen a 0.</li>

            <li>Las alarmas pendientes toman su valor inicial.</li>

            <li>Se eliminan las señales pendientes para el proceso hijo.</li>
          </ul>
        </div>
      </dd>
    </dl>
    <hr>

    <p><a name="fork"></a><span class="c9">- Ejemplos:</span></p>
<pre class="c18">
/* fork.c - Ejecución conjunta de procesos padre e hijo */
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
main ()
    {
    printf ("Ejemplo de fork.\n");

    printf ("Inicio del proceso padre. PID=%d\n", getpid ());

    if (fork() == 0)

        {       /* Proceso hijo */
        printf ("Inicio proceso hijo. PID=%d, PPID=%d\n",
        getpid (), getppid ());
        sleep (1);
        }
    else
        {       /* Proceso padre */
        printf ("Continuación del padre. PID=%d\n", getpid ());
        sleep (1);
        }
    printf ("Fin del proceso %d\n", getpid ());
    exit (0);
    }


Ejemplo de fork.
Inicio proceso padre. PID=8153
Inicio proceso hijo. PID=6618, PPID=8153
Continuación proceso padre. PID=8153
Fin del proceso 6618
Fin del proceso 8153
</pre>
    <hr>

    <p><a name="forkhuerf"></a><span class="c9">- Ejemplo:</span></p>
<pre class="c18">
/* fork_huerf.c  - Ejemplo de proceso huérfano *
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
main ()
    {
    printf ("Ejemplo de proceso huérfano.\n");
    printf ("Inicio del proceso padre. PID=%d\n", getpid ());
    if (fork () == 0)
        {
        printf ("Inicio proceso hijo. PID=%d, PPID=%d\n",
        getpid (), getppid ());
        sleep (1);
        printf ("El proceso queda huérfano. PID=%d PPID=%d\n",
        getpid (), getppid ());
        }
    else
        printf ("Concinuación del padre. PID=%d\n", getpid ());
    printf ("Fin del proceso %d\n", getpid ());
    exit (0);
    }


Ejemplo de proceso huérfano.
Inicio proceso padre. PID=11330
Inicio proceso hijo. PID=6467, PPID=11330
Continuación proceso padre. PID=11330
Fin del proceso 11330
<i>$punto indicativo&gt;</i> El proceso queda huérfano. PID=6467, PPID=1
Fin del proceso 6467
</pre>
    <span class="c9">Notas:</span> 

    <ul>
      <li>En el ejemplo, el proceso padre no espera la finalización del proceso hijo y termina antes que éste.</li>

      <li>Cuando un proceso queda huérfano, el proceso de iniciación (<b>init</b>) se convierte en su padre.</li>

      <li>Una vez que finaliza el proceso padre, se devuelve el control al intérprete de comandos, de ahí que aparezca el mensaje del "punto indicativo". El proceso hijo no deberá mandar mensajes a la consola, como ocurre en este ejemplo.</li>
    </ul>
    <hr>

    <h4 class="c15">1,3,2. Subrutinas <i>wait</i> y <i>waitpid</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Espera a que pare o termine un proceso hijo, permitiendo obtener sus estados de salida.</dd>

      <dd class="c13">Una señal no bloqueada o no ignorada puede reactivar el proceso padre.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;sys/wait.h&gt;</tt></dd>

      <dd><tt class="c17">pid_t wait (estados)</tt></dd>

      <dd><tt class="c17">int *estados;</tt></dd>

      <dd><tt class="c17">pid_t wait ((void *) 0);</tt></dd>

      <dd><tt class="c17">pid_t waitpid (PID, estados, opciones)</tt></dd>

      <dd><tt class="c17">pid_t PID;</tt></dd>

      <dd><tt class="c17">int *estados, opciones;</tt></dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">PID - PID del proceso o grupo de proceso. Sus valores son:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li>-1: <b>waitpid</b> actúa igual que <b>wait</b>, esperando cualquier hijo.</li>

            <li>&gt;0: PID de un proceso hijo determinado.</li>

            <li>0: para cualquier hijo con el mismo grupo de procesos que el padre.</li>

            <li>&lt;-1: para cualquier hijo cuyo grupo de proceso sea igaul al valor absoluto de PID.</li>
          </ul>
        </div>
      </dd>

      <dd class="c13">opciones - Máscara de opciones. Sus bits son:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li><b>WNOHANG</b>: evita la suspensión del padre mientras esté esperando a algún hijo.</li>

            <li><b>WUNTRACED</b>: el padre obtiene información adicional si el hijo recibe alguna de las señales <b>SIGTTIN, SIGTTOU, SIGSSTP o SIGTSTOP</b> .</li>
          </ul>
        </div>
      </dd>

      <dd class="c13">estados - Puntero a una tabla con los estados de salida de los procesos.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">0, si no ha terminado ningún proceso.</dd>

      <dt class="c16">- Macros:</dt>

      <dd class="c13"><tt>WIFSTOPPED (estado) /* !=0, si</tt> <i class="c20">estado</i><tt>es de un hijo parado */</tt></dd>

      <dd><tt class="c17">pid_t estado;</tt></dd>

      <dd><tt class="c17">int WSTOPSIG (estado) /* Nú de señal que ha causado la parada */</tt></dd>

      <dd><tt class="c17">pid_t estado;</tt></dd>

      <dd class="c13"><tt>WIFEXITED (estado) /* !=0, si</tt> <i class="c20">estado</i><tt>es de salida normal */</tt></dd>

      <dd><tt class="c17">pid_t estado;</tt></dd>

      <dd><tt class="c17">int WEXITSTATUS (estado) /* 8 bits bajos del estado de salida */</tt></dd>

      <dd><tt class="c17">pid_t estado;</tt></dd>

      <dd class="c13"><tt>WIFSIGNALED (estado) /* !=0, si</tt> <i class="c20">estado</i><tt>es de salida anormal */</tt></dd>

      <dd><tt class="c17">pid_t estado;</tt></dd>

      <dd><tt class="c17">int WTERMSIG (estado) /* Nú de sañal que ha causado la slida */</tt></dd>

      <dd><tt class="c17">pid_t estado;</tt></dd>

      <dt class="c16">- Cometarios:</dt>

      <dd class="c13">a) Estas subrutinas pueden verse afectadas por la señal <b>SIGCHLD</b> (ver <b><u><a href="#232">sigaction</a></u></b>).</dd>

      <dd class="c13">b) La subrutina <b>wait</b> espera la terminación de cualquier proceso hijo.</dd>
    </dl>
    <hr>

    <p><a name="waitpid"></a><span class="c9">- Ejemplos:</span></p>
<pre class="c18">
/* waitpid.c - Esperar la terminación de un proceso hijo */
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;

main ()
    {
    pid_t id_padre;     /* PID del proceso padre */
    pid_t id_hijo;      /* PID del proceso hijo */
    int   estado;       /* Estado de salida */

    printf ("Ejemplo de waitpid.\n");
    printf ("Inicio proceso padre. PID=%d\n", getpid ());
    id_padre = getpid ();
    if ((id_hijo = fork ()) == 0)
        {               /* Proceso hijo */
        printf ("Inicio proceso hijo. PID=%d, PPID=%d\n",
        getpid (), id_padre);
        sleep (3);
        printf ("Salida proceso hijo. PID=%d\n", getpid ());
        exit (getpid () &gt; id_padre);        /* 1, si PID  PPID */
        }
    else
        {
        signal (SIGINT, SIG_IGN);        /* Ignorar CTRL-C */
        while (waitpid (id_hijo, &amp;estado, 0) != id_hijo);
        if (WIFSIGNALED (estado))
            printf ("El proceso hijo ha recibido la señal %d\n", WTERMSIG (estado));
        if (WIFEXITED (estado))
           {
           printf ("Estado de salida del proceso hijo: %d\n", WEXITSTATUS (estado));
           if (WEXITSTATUS (estado) == 1)
               printf ("PID hijo &gt; PID padre.\n");
           else
               printf ("PID padre &gt; PID hijo.\n");
           }
        printf ("Fin del proceso %d\n", getpid ());
        exit (0);
    }


Ejemplo de waitpid.
Inicio proceso padre. PID=24213
Inicio proceso hijo. PID=31638, PPID=24213
Fin proceso hijo. PID=31638
Estado de salida del proceso hijo: 1
PID hijo &gt; PID padre
Fin del proceso 24213
</pre>
    <span class="c9">La salida siguiente muestra el efecto de generar una señal de interrupción pulsando [CTRL][C]. Dicha señal provoca la terminación automática del proceso hijo, mientras que el proceso padre la ignora (ver <b><u><a href="#231">signal</a></u></b>).</span> 
<pre class="c18">
Ejemplo de waitpid.
Inicio proceso padre. PID=7240
Inicio proceso hijo. PID=5705, PPID=7240
^CEl proceso hijo ha recibido la señal: 2
Fin del proceso 7240
</pre>
    <hr>

    <h3 class="c11">1,4. Terminación de un proceso.</h3>

    <h4 class="c15">1,4,1. Subrutina <i>exit</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Termina la ejecución de un proceso.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;stdlib.h&gt;</tt></dd>

      <dd><tt class="c17">void exit (estado)</tt></dd>

      <dd><tt class="c17">int estado;</tt></dd>

      <dt class="c16">- Parámetro:</dt>

      <dd class="c13">Estado de salida del proceso.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) El proceso de salida de un proceso es el siguiente:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li>Llamada a la función <b>_cleanup</b> para limpiar las áreas de E/S.</li>

            <li>Llamada a la subrutina especificada en la subrutina <b>atexit</b>.</li>

            <li>Llamada a la subrutina <b>_exit</b> para finalizar el proceso.</li>
          </ul>
        </div>
      </dd>

      <dd class="c13">b) Si <b>_cleanup</b> no puede cancelar las peticiones de E/S asíncrona, la aplicación se bloquea hasta que se completen dichas peticiones.</dd>

      <dd class="c13">c) Se cierran todos los descriptores de fichero.</dd>

      <dd class="c13">d) Si el proceso padre está en espera (ver <b><u><a href="#132">wait</a></u></b>), se devuelve el valor de los 8 bits menos significativos del estado de salida.</dd>

      <dd class="c13">e) Se envía una señal <b>SIGCHLD</b> al proceso padre. La acción por defecto es ignorar esta señal. Si no se ignora, el proceso hijo puede quedar como proceso zombi.</dd>

      <dd class="c13">f) La salida de un proceso no provoca la terminación de sus hijos. El PPID de los hijos será el PPID del proceso <b>init</b> (1).</dd>

      <dd class="c13">g) Se eliminan los bloqueos de ficheros (ver <b><u><a href="#322">fcntl</a></u></b>).</dd>

      <dd class="c13">h) Si para un proceso perteneciente a un grupo huérfano, se envían las señales <b>SIGHUP</b> y <b>SIGCONT</b> a cada proceso del grupo de procesos huérfanos.</dd>
    </dl>
    <hr>

    <h4 class="c15">1,4,2. Subrutina <i>atexit</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Ejecuta una determinada función antes de la terminación del proceso.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;sys/limits.h&gt;</tt></dd>

      <dd><tt class="c17">int atexit (función)</tt></dd>

      <dd><tt class="c17">void (*función) (void);</tt></dd>

      <dt class="c16">- Parámetro:</dt>

      <dd class="c13">Puntero a la función llamada.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">0: si no hay errores.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) La <i>función</i> se ejecuta si se ha completado con éxito la subrutina <b>_cleanup</b>.</dd>
    </dl>
    <hr>

    <p><a name="atexit"></a><span class="c9">- Ejemplo:</span></p>
<pre>
<b class="c21">/* atexic.c - Ejecución de una rutina al salir de un programa */
#include &lt;stdio.h&gt;
#include &lt;sys/limits.h&gt;


int bucle=0;            /* Contador de vueltas del bucle */

void salida ();         /* Prototipo de la función de salida */

int main ()
   {
   int n;

   atexit (salida);
   printf ("Ejemplo de atexit.\n");
   for (bucle=1; bucle&lt;255; bucle++)
        {
        n=rand ();
        printf ("%d-%d\t", bucle, n);
        if (n &gt; 30000)
           exit (1);
        }
   exit (0);
   }

void salida ()
     {
     printf ("El bucle ha dado %d vueltas.\n");
     printf ("Hasta luega Lucas.\n");
     }


</b><span class="c9">Ejemplo de atexit.
1-16838 2-5758  3-10113 4-17515 5-31051
El bucle ha dado 5 vueltas.
Hasta luego Lucas.</span>
</pre>
    <hr>

    <h2 class="c10">2. SEÑALES.</h2>

    <h3 class="c11">2,1. Conceptos generales.</h3>

    <dl>
      <dt class="c12">Señal:</dt>

      <dd class="c13">Evento que debe ser procesado y que puede interrumpir el flujo normal de un programa.</dd>

      <dt class="c12">Capturar una señal:</dt>

      <dd class="c13">Una señal puede asociarse con una función que procesa el evento que ha ocurrido.</dd>

      <dt class="c12">Ignorar una señal:</dt>

      <dd class="c13">El evento no interrumpe el flujo del programa. Las señales <b>SIGINT</b> y <b>SIGSTOP</b> no pueden ser ignoradas (ver <a href="#22">tabla de señales</a>).</dd>

      <dt class="c12">Acción por defecto:</dt>

      <dd class="c13">Proceso suministrado por el sistema para capturar la señal (ver <a href="#22">tabla de señales</a>).</dd>

      <dt class="c12">Alarma:</dt>

      <dd class="c13">Señal que es activada por los temporizadores del sistema.</dd>

      <dt class="c12">Error:</dt>

      <dd class="c13">Fallo o acción equivocada que puede provocar la terminación del proceso.</dd>

      <dt class="c12">Error crítico:</dt>

      <dd class="c13">Error que provoca la salida inmediata del programa.</dd>
    </dl>
    <hr>

    <h3 class="c11">2,2. Lista de las señales más importantes.</h3>

    <table border bordercolor="#000000" summary="Lista de las señales más importantes">
      <caption>
        Lista de las señales más importantes
      </caption>

      <tr>
        <td valign="top">
          <div class="c22">
            Núm.&nbsp;
          </div>
        </td>

        <td valign="top">
          <div class="c22">
            Nombre&nbsp;
          </div>
        </td>

        <td valign="top">
          <div class="c22">
            Comentarios&nbsp;
          </div>
        </td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            1&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGHUP&nbsp;</td>

        <td valign="top" class="c24">Colgar. Generada al desconectar el terminar.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            2&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGINT&nbsp;</td>

        <td valign="top" class="c24">Interrupción. Generada por teclado.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            3&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGQUIT1&nbsp;</td>

        <td valign="top" class="c24">Salir. Generada por teclado.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            4&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGILL1&nbsp;</td>

        <td valign="top" class="c24">Instrucción ilegal. No se puede recapturar.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            5&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGTRAP1&nbsp;</td>

        <td valign="top" class="c24">Trazado. No se puede recapturar.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            6&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGABRT1&nbsp;</td>

        <td valign="top" class="c24">Abortar proceso.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            8&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGFPE1&nbsp;</td>

        <td valign="top" class="c24">Excepción aritmética, de coma flotante o división por cero.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            9&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGKILL1&nbsp;</td>

        <td valign="top" class="c24">Matar proceso. No puede capturarse, ni ignorarse.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            10&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGBUS1&nbsp;</td>

        <td valign="top" class="c24">Error en el bus.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            11&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGSEGV1&nbsp;</td>

        <td valign="top" class="c24">Violación de segmentación.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            12&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGSYS1&nbsp;</td>

        <td valign="top" class="c24">Argumento erróneo en llamada al sistema.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            13&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGPIPE&nbsp;</td>

        <td valign="top" class="c24">Escritura en una tubería que otro proceso no lee.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            14&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGALRM&nbsp;</td>

        <td valign="top" class="c24">Alarma de reloj.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            15&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGTERM&nbsp;</td>

        <td valign="top" class="c24">Terminación del programa.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            16&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGURG2&nbsp;</td>

        <td valign="top" class="c24">Urgencia en canal de E/S.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            17&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGSTOP3&nbsp;</td>

        <td valign="top" class="c24">Parada de proceso. No puede capturarse, ni ignorarse.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            18&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGTSTP3&nbsp;</td>

        <td valign="top" class="c24">Parada interactiva. Generada por teclado.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            19&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGCONT4&nbsp;</td>

        <td valign="top" class="c24">Continuación. Generada por teclado.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            20&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGCHLD2&nbsp;</td>

        <td valign="top" class="c24">Parada o salida de proceso hijo.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            21&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGTTIN3&nbsp;</td>

        <td valign="top" class="c24">Un proceso en 2o plano intenta leer del terminal.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            22&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGTTOU3&nbsp;</td>

        <td valign="top" class="c24">Un proceso en 2o plano intenta escribir en el terminal.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            23&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGIO2&nbsp;</td>

        <td valign="top" class="c24">Operación de E/S posible o completada.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            24&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGXCPU&nbsp;</td>

        <td valign="top" class="c24">Tiempo de UCP excedido.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            25&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGXFSZ&nbsp;</td>

        <td valign="top" class="c24">Excedido el límite de tamaño de fichero.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            30&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGUSR1&nbsp;</td>

        <td valign="top" class="c24">Definida por el usuario número 1.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            31&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGUSR2&nbsp;</td>

        <td valign="top" class="c24">Definida por el usuario número 2.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            34&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGVTALRM&nbsp;</td>

        <td valign="top" class="c24">Alarma de tiempo virtual.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            36&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">SIGPRE&nbsp;</td>

        <td valign="top" class="c24">Excepción programada. Definida por el usuario.&nbsp;</td>
      </tr>
    </table>
    <span class="c9">Notas sobre la acción por defecto para la señal.</span> 

    <ol>
      <li>Generar un fichero <b>core</b>.</li>

      <li>Ignorar la señal.</li>

      <li>Parar el proceso que recibe la señal.</li>

      <li>Reiniciar o continuar el proceso que recibe la señal.</li>
    </ol>
    <span class="c9">Las señales comprendidas entre la 37 y la 58 (ambas inclusive) están reservadas por el sistema.</span> 

    <p class="c25">El rango de señales en el UNIX de Berkeley (BSD) es de 1 a 31.</p>
    <hr>

    <h3 class="c11">2,3. Capturar señales.</h3>

    <h4 class="c15">2,3,1. Subrutina <i>signal</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Asocia una acción determinada con una señal.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;signal.h&gt;</tt></dd>

      <dd><tt class="c17">void (*signal (señal, acción)) ()</tt></dd>

      <dd><tt class="c17">int señal;</tt></dd>

      <dd><tt class="c17">void (*accón) ();</tt></dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">señal: Número de señal, excepto <b>SIGKILL</b>.</dd>

      <dd class="c13">acción: Puntero a la rutina asociada con la señal o uno de los valores:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li><b>SIG_DFL</b>: acción por defecto para dicha señal.</li>

            <li><b>SIG_IGN</b>: ignorar la señal,</li>
          </ul>
        </div>
      </dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">Valor de la acción anteriormente asociada; -1, en caso de error.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) Existe una versión de la subrutina <b>signal</b> compatible con el UNIX de Berkeley (BSD).</dd>

      <dd class="c13">b) No se permiten máscaras de bloqueo de señales y se activa el bit <b>SA_OLDSTYLE</b> (ver <b><u><a href="#22">sigaction</a></u></b>).</dd>
    </dl>
    <hr>

    <p><a name="signal"></a><span class="c9">- Ejemplo:</span></p>
<pre class="c18">
/* signal.c - Contar el número de CTRL-C en 15 segundos */
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;

int numcortes=0;        /* Contador de CTRL-C */
int enbucle=1;          /* Controlador de salida del bucle de espera */

void alarma ();         /* Captura la señal de alarma SIGALRM */
void cortar ();         /* Captura la señal de interrupción SIGINT */

int main ()
    {
    signal (SIGINT, cortar);
    signal (SIGALRM, alarma);
    printf ("Ejemplo de signal.\n");
    printf ("Pulsa varias veces CTRL-C durante 15 segundos.\n");
    alarm (15);
    while (bucle);
    signal (SIGINT, SIG_IGN);
    printf ("Has intentado cortar %d veces.\n", numcortes);
    printf ("Hasta luego Lucas.\n");
    exit (0);
    }

void alarma ()
     {
     signal (SIGALRM, SIG_IGN);
     bucle=0;           /* Salir del bucle */
     printf ("¡Alarma!\n");
     }

void cortar ()
     {
     signal (SIGINT, SIG_IGN);
     printf ("Has pulsado CTRL-C\n");
     numcortes++;
     signal (SIGINT, cortar);
     }


Ejemplo de signal.
Pulsa CTRL-C varias veces durante 15 segundo.
<i>^C</i>Has pulsado CTRL-C
<i>^C</i>Has pulsado CTRL-C
<i>^C</i>Has pulsado CTRL-C
<i>^C</i>Has pulsado CTRL-C
<i>^C</i>Has pulsado CTRL-C
¡Alarma!
Has intentado cortar 5 veces.
Hasta luego Lucas.
</pre>
    <hr>

    <h4 class="c15">2,3,2. Subrutina <i>sigaction</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Especifica la acción a realizar cuando un proceso recibe una señal.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;signal.h&gt;</tt></dd>

      <dd><tt class="c17">int sigaction (señal, acción, acción_salida) ()</tt></dd>

      <dd><tt class="c17">int señal;</tt></dd>

      <dd><tt class="c17">struct sigaction *accón, *acción_salida;</tt></dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">señal: Número de señal, excepto <b>SIGKILL</b>.</dd>

      <dd class="c13">acción: Acción especificada cuando se recibe la señal.</dd>

      <dd class="c13">acción_salida: Acción a realizar cuando termine la función <b>sigaction</b>.</dd>

      <dt class="c16">- Campos de la estructura <b>sigaction</b>:</dt>

      <dd class="c13"><tt>void (*sa_handler) ();</tt> Puntero a la rutina asociada con la señal o uno de los valores:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li><b>SIG_DFL</b>: acción por defecto para dicha señal.</li>

            <li><b>SIG_IGN</b>: ignorar la señal.</li>
          </ul>
        </div>
      </dd>

      <dd class="c13"><tt>sigset_t sa_mask;</tt> Especifica la máscara de las señales que serán bloqueadas durante la captura de la señal especificada.</dd>

      <dd><tt class="c17">int sa_flags;</tt></dd>

      <dd>
        <div class="c14">
          <ul>
            <li><b>SA_ONSTACK</b>: La captura de la señal se realiza en una pila de señales en vez de en la pila del proceso.</li>

            <li><b>SA_OLDSTYLE</b>: El parámetro <i>señal</i> se asocia con la ación por defecto (<b>SIG_DFL</b>) antes de llamar a la rutina de captura (no recomendable, la señal puede recurrir).</li>

            <li><b>SA_NOCLDSTOP</b>: Evita que el proceso padre reciba una señal <b>SIGCHLD</b> cuando para el proceso hijo.</li>
          </ul>
        </div>
      </dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">0, si es correcta; -1, en caso de error.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) Las siguientes funciones pueden ser llamadas sin problemas desde una rutina de captura de señales:</dd>
    </dl>
    <span class="c9">&nbsp;</span> 

    <table border="0" cellspacing="0" summary="funciones que pueden ser llamadas sin problemas desde una rutina de captura de señales">
      <tr>
        <td valign="middle"><tt class="c17">_exit&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">access&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">alarm&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">chdir&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">chmod&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">chown&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">close&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">creat&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">dup&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">dup2&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">exec&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">fcntl&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">fork&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">fstat&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">getegid&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">geteuid&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">getgid&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">getgroups&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">getpgrp&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">getpid&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">getppid&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">getuid&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">kill&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">link&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">lseek&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">mkdir&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">mkfifo&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">open&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">pause&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">pipe&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">readx&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">rename&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">rmdir&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">setgid&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">setpgrp&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">setuid&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">sigaction&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">sigaddset&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">sigdelset&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">sigfillset&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">sigismember&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">signal&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">sigpending&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">sigprocmask&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">sigsuspend&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">sleep&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">statx&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">tcdrain&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">tcflow&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">tcflush&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">tcgetattr&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">tcgetpgrp&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">tcsendbreak&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">tcsetattr&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">tcsetpgrp&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">time&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">times&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">umask&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">uname&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">unlink&nbsp;</tt></td>
      </tr>

      <tr>
        <td valign="middle"><tt class="c17">ustat&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">utime&nbsp;</tt></td>

        <td valign="middle"><tt class="c17">write&nbsp;</tt></td>

        <td valign="middle" class="c24">&nbsp;</td>

        <td valign="middle" class="c24">&nbsp;</td>

        <td valign="middle" class="c24">&nbsp;</td>
      </tr>
    </table>
    <span class="c9">&nbsp;</span> 

    <dl>
      <dd class="c13">b) Una vez que una <i>acción</i> está instalada para una <i>señal</i>, continúa hasta que haya otra llamada a <b>sigaction</b> o se llame a la subrutina <b>exec</b>, excepto si se ha activado el bit <b>SA_OLDSTYLE</b>.</dd>

      <dd class="c13">c) Las señales <b>SIGKILL</b> y <b>SIGSTOP</b> no pueden ser ignoradas.</dd>
    </dl>
    <hr>

    <h4 class="c15">2,3,3. Subrutina <i>kill</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Envía una señal a un proceso.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;signal.h&gt;</tt></dd>

      <dd><tt class="c17">int kill (proceso, señal)</tt></dd>

      <dd><tt class="c17">pid_t proceso;</tt></dd>

      <dd><tt class="c17">int señal;</tt></dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">proceso: Identificador del proceso o del grupo de procesos que recibirá la señal. Puede tomar los siguientes valores:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li>&gt;0: Identificador de un único proceso.</li>

            <li>0: Procesos cuyo identificador del grupo de procesos sea igual al PID del proceso actual.</li>

            <li>&lt;-1: Procesos cuyo identificador del grupo de procesos sea igaul al valor absoluto de <i>proceso</i>.</li>
          </ul>
        </div>
      </dd>

      <dd class="c13">señal: Número de señal enviada.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">0, si se ha completado correctamente; -1, en caso de error.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) La subrutina <b>raise</b> envía una señal al proceso actual.</dd>

      <dd><tt class="c17">#include &lt;sys/signal.h&gt;</tt></dd>

      <dd><tt class="c17">int raise (señal)</tt></dd>

      <dd><tt class="c17">int señal;</tt></dd>

      <dd class="c13">Este código es equivalente al mostrado a continuación:</dd>

      <dd><tt class="c17">error = kill (getpid (), señal);</tt></dd>

      <dd class="c13">b) La subrutina <b>killpg</b> envía una señal a un grupo de procesos. Esta subrutina es compatible con el UNIX de Berkeley (librería <b>libbsd.a</b>).</dd>

      <dd><tt class="c17">#include &lt;signal.h&gt;</tt></dd>

      <dd><tt class="c17">int killpg (int grupo_procesos, int señal);</tt></dd>

      <dd class="c13">El código anterior equivale al mostrado a continuación:</dd>
    </dl>

    <div class="c14">
<pre class="c18">
if (grupo_procesos &lt; 0)
   {
   errno = ESRCH;
   return (-1);
   }
return (kill(-grupo_procesos, señal));
</pre>

      <dl>
        <dd class="c13">c) Para enviar una señal a otro proceso deben coincidir el identificador de usuario (UID) real o efactivo de ambos procesos, o que el proceso emisor tenga prioridad de usuario <i>root</i>.</dd>
      </dl>
    </div>
    <hr>

    <p><a name="kill"></a><span class="c9">- Ejemplo:</span></p>
<pre class="c18">
/* kill.c - Ejecución con tiempo de espera usando kill */
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;

int espera;             /* Tiempo de espera */

void hijo ();           /* Controlador de fin de proceso hijo */

int main (int contargs, char *args[]);
    {
    pid_t pid;

    if (contargs &lt; 3)
       {
       printf ("Formato: %s segundos comando [opciones].\n", args[0]);
       exit (1);
       }
    printf ("Ejemplo de kill.\n");
    printf ("Ejecución con tiempo de espera.\n");
    signal (SIGCHLD, hijo);
    pid = fork ();
    if (pid == 0)
       {
       execvp (args[2]; &amp;args[2]);
       perror (args[0]);
       }
    else
        {
        espera = atoi (args[1]);
        sleep (espera);
        printf ("El hijo %d ha excedido el tiempo de %d s.\n",
                pid, espera);
        signal (SIGCHLD, SIG_IGN);
        kill (pid, SIGINT);
        }
    exit (1);
    }

void espera ()
     {
     int id_hijo, est_hijo;

     id_hijo = wait (&amp;est_hijo);
     printf ("El hijo %d ha terminado antes de %d s.\n",
                id_hijo, espera);
     exit (0);
     }


<i>$ kill.e 3 wc kill.c
</i>Ejemplo de kill.
Ejecución de un comando con tiempo de espera.
45 132 1065 kill.c
El hijo 10489 ha terminado antes de 3 s.

<i>$ kill.e 3 sleep 5
</i>Ejemplo de kill.
Ejecución de un comando con tiempo de espera.
El hijo 10851 ha excedido el tiempo de espera de 3 s.
</pre>
    <hr>

    <h3 class="c11">2,4. Alarmas y temporizadores.</h3>

    <h4 class="c15">2,4,1. Subrutinas <i>alarm</i> y <i>ualarm</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Genera alarmas de reloj (señal <b>SIGALRM</b>) para el proceso actual.</dd>

      <dt class="c16">- Formato</dt>

      <dd><tt class="c17">#include &lt;unistd.h&gt;</tt></dd>

      <dd><tt class="c17">unsigned int alarm (segundos)</tt></dd>

      <dd><tt class="c17">unsigned int segundos;</tt></dd>

      <dd><tt class="c17">unsigned int ualarm (valor, intervalo)</tt></dd>

      <dd><tt class="c17">unsigned int valor, intervalo;</tt></dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">segundos: Número de segundos para enviar al proceso la señal <b>SIGALRM</b>.</dd>

      <dd class="c13">valor: Número de señales generadas.</dd>

      <dd class="c13">intervalo: Intervalo (en ms.) entre las señales.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13"><b>alarm</b> devuelve el número de segundos que restan para generar la señal.</dd>

      <dd class="c13"><b>ualarm</b> devuelve el número de microsegundos que restan hasta la próxima señal.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) Sólo puede generarse una única alarma (no son aplilables).</dd>

      <dd class="c13">b) El parámetro <i>intervalo</i> no puede ser menor que 10 para un usuario sin privilegios.</dd>

      <dd class="c13">c) Estas 2 subrutinas son compatibles con las primeras versiones del AIX, con UNIX System V y con UNIX de Berkeley (BSD). En AIX, se han programado como llamadas a la subrutina <b>incinterval</b>.</dd>
    </dl>
    <hr>

    <p><a name="alarm"></a><span class="c9">- Ejemplo:</span></p>
<pre class="c18">
/* alarm.c - Esperar una alarma */
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
int main ()
    {
    printf ("Una alarma en 3 segundos.\n");
    alarm (3);
    printf ("Esperando...\n");
    while (1);
    printf ("Esta línea no se ejecutará nunca.\n");
    exit (0);
    }


Una alarma en 3 segundos.
Esperando...
Alarm clock
</pre>
    <hr>

    <h3 class="c11">2,5. Tratamiento de errores.</h3>

    <h4 class="c15">2,5,1. Lista de errores más importantes.</h4>

    <table border bordercolor="#000000" summary="Lista de errores más importantes">
      <tr>
        <td valign="top">
          <div class="c22">
            Núm.&nbsp;
          </div>
        </td>

        <td valign="top">
          <div class="c22">
            Nombre&nbsp;
          </div>
        </td>

        <td valign="top">
          <div class="c22">
            Descripción&nbsp;
          </div>
        </td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            1&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EPERM&nbsp;</td>

        <td valign="top" class="c24">Operación no permitida.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            2&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ENOENT&nbsp;</td>

        <td valign="top" class="c24">El archivo o directorio no existe.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            3&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ESRCH&nbsp;</td>

        <td valign="top" class="c24">El proceso no existe.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            4&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EINTR&nbsp;</td>

        <td valign="top" class="c24">Llamada al sistema interrumpida.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            5&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EIO&nbsp;</td>

        <td valign="top" class="c24">Error de E/S.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            6&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ENXIO&nbsp;</td>

        <td valign="top" class="c24">No existe dispositivo o dirección.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            7&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">E2BIG&nbsp;</td>

        <td valign="top" class="c24">Lista de argumentos demasiado larga.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            8&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ENOEXEC&nbsp;</td>

        <td valign="top" class="c24">Error en formato de ejecución.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            9&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EBADF&nbsp;</td>

        <td valign="top" class="c24">Descriptor de fichero erróneo.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            10&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ECHILD&nbsp;</td>

        <td valign="top" class="c24">No existe el proceso hijo.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            11&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EGAIN&nbsp;</td>

        <td valign="top" class="c24">Recurso no disponible temporalmente.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            12&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ENOMEM&nbsp;</td>

        <td valign="top" class="c24">No hay suficiente espacio de memoria.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            13&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EACCES&nbsp;</td>

        <td valign="top" class="c24">Permiso denegado.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            14&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EFAULT&nbsp;</td>

        <td valign="top" class="c24">Dirección de memoria errónea.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            15&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ENOTBLK&nbsp;</td>

        <td valign="top" class="c24">Se necesita un fichero de bloques.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            16&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EBUSY&nbsp;</td>

        <td valign="top" class="c24">Recurso ocupado.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            17&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EEXIST&nbsp;</td>

        <td valign="top" class="c24">Fichero existente.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            18&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EXDEV&nbsp;</td>

        <td valign="top" class="c24">Enlace impropio.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            19&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ENODEV&nbsp;</td>

        <td valign="top" class="c24">Dispositivo inexistente.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            20&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ENOTDIR&nbsp;</td>

        <td valign="top" class="c24">No es un directorio.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            21&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EISDIR&nbsp;</td>

        <td valign="top" class="c24">Es un directorio.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            22&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EINVAL&nbsp;</td>

        <td valign="top" class="c24">Argumento no válido.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            23&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ENFILE&nbsp;</td>

        <td valign="top" class="c24">Demasiados ficheros abiertos en el sistema.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            24&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EMFILE&nbsp;</td>

        <td valign="top" class="c24">Demasiados ficheros abiertos.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            26&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ETXBUSY&nbsp;</td>

        <td valign="top" class="c24">Fichero de texto ocupado.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            27&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EFBIG&nbsp;</td>

        <td valign="top" class="c24">Fichero demasiado largo.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            28&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ENOSPC&nbsp;</td>

        <td valign="top" class="c24">No queda espacio en el dispositivo.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            29&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ESPIPE&nbsp;</td>

        <td valign="top" class="c24">Búsqueda no válida.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            30&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EROFS&nbsp;</td>

        <td valign="top" class="c24">Fichero sólo de lectura.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            32&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EPIPE&nbsp;</td>

        <td valign="top" class="c24">Tubería rota.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            33&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EDOM&nbsp;</td>

        <td valign="top" class="c24">Error de dominio matemático.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            34&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ERANGE&nbsp;</td>

        <td valign="top" class="c24">Resultado fuera de rango.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            78&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">ETIMEDOUT&nbsp;</td>

        <td valign="top" class="c24">Excedido tiempo de conexión (NFS).&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c23">
            88&nbsp;
          </div>
        </td>

        <td valign="top" class="c24">EDQUOT&nbsp;</td>

        <td valign="top" class="c24">Cuota de disco excedida.&nbsp;</td>
      </tr>
    </table>
    <span class="c9">Nota: No se tratan aquí los errores relativos a comunicaciones, ni a <i>sockets</i>.</span> 
    <hr>

    <h4 class="c15">2,5,2. Subrutina <i>perror</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Escribe un mensaje explicando un error.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;errno.h&gt;</tt></dd>

      <dd><tt class="c17">void perror (cadne)</tt></dd>

      <dd><tt class="c17">char *cadena;</tt></dd>

      <dt class="c16">- Parámetro:</dt>

      <dd class="c13">Cadena de caracteres que explica el error.</dd>

      <dt class="c16">- Variables globales de <b>errno.h</b>:</dt>

      <dd class="c13"><tt>extern int errno;</tt> Número de error.</dd>

      <dd class="c13"><tt>extern char *sys_errlist[];</tt> Tabla con la descripción de los errores del sistema.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) Se imprime en la salida normal con un formato equivalente a la siguiente orden:</dd>

      <dd class="c13"><tt>printf ("%s: %s\n",</tt> <i class="c20">cadena</i><tt>, sys_errlist[errno]);</tt></dd>
    </dl>
    <hr>

    <h2 class="c10">3. <i>PIPES</i> (TUBERÍAS).</h2>

    <h3 class="c11">3,1. Conceptos generales.</h3>

    <dl>
      <dt class="c12">Descriptor de fichero:</dt>

      <dd class="c13">Número entero positivo usado por un proceso para identificar un fichero abierto. Esta traducción se realiza mediante una tabla de descriptores de fichero, ubicado en la zona de datos del proceso.</dd>

      <dt class="c12">Descriptores reservados:</dt>

      <dd>
        <ul>
          <li>0: entrada normal (<b>stdin</b>).</li>

          <li>1: salida normal (<b>stdout</b>).</li>

          <li>2: salida de error (<b>stderr</b>).</li>
        </ul>
      </dd>

      <dt class="c12">Redirección:</dt>

      <dd class="c13">Establecer copias del descriptor de ficheros de un archivo para encauzar las operaciones de E/S hacia otro fichero.</dd>

      <dt class="c12">Tubería:</dt>

      <dd class="c13">Mecanismo de intercomunicación entre procesos que permite que 2 o más procesos envíen información a cualquier otro.</dd>

      <dt class="c12">Tubería sin nombre:</dt>

      <dd class="c13">Enlace de comunicación unidireccional, capaz de almacenar su entrada (hasta 4 KB en BSD o hasta 40 KB en System V).</dd>

      <dt class="c12">Tuberías nombradas (FIFO):</dt>

      <dd class="c13">Permiten una comunicación menos restringida, ya que las colas FIFO existen en el sistema de archivos hasta que son borradas.</dd>

      <dd class="c13">Características:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li>Permite comunicar procesos no emparentados.</li>

            <li>Tiene una entrada en el sistema de archivos.</li>

            <li>Usa una política de colas "primero en llegar, primero en servirse".</li>

            <li>Sólo disponible en UNIX System V.</li>
          </ul>
        </div>
      </dd>
    </dl>
    <hr>

    <h3 class="c11">3,2. Redirección.</h3>

    <h4 class="c15">3,2,1. Subrutinas <i>dup</i> y <i>dup2</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Duplica un descriptor de fichero.</dd>

      <dt class="c16">- Formatos:</dt>

      <dd><tt class="c17">#include &lt;unistd.h&gt;</tt></dd>

      <dd><tt class="c17">#include &lt;fcntl.h&gt;</tt></dd>

      <dd><tt class="c17">#include &lt;sys/types&gt;</tt></dd>

      <dd><tt class="c17">int dup (desc_abierto)</tt></dd>

      <dd><tt class="c17">int desc_abierto;</tt></dd>

      <dd><tt class="c17">int dup2 (desc_abierto, desc_nuevo)</tt></dd>

      <dd><tt class="c17">int desc_abierto, desc_nuevo;</tt></dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">desc_abierto: Descriptor de fichero abierto.</dd>

      <dd class="c13">desc_nuevo: Nuevo descriptor de fichero devuelto por <b>dup2</b>.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13"><b>dup</b> devuelve el menor descriptor de fichero que esté libre.</dd>

      <dd class="c13"><b>dup2</b> devuelve el valor de <i>desc_nuevo</i>.</dd>

      <dd class="c13">Ambas subrutinas devuelven el valor -1 en caso de error.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) Las subrutinas <b>dup</b> y <b>dup2</b> son equivalentes a la subrutina <b>fcntl</b> de la siguiente forma:</dd>
    </dl>
    <span class="c9">&nbsp;</span> 

    <table border="0" cellspacing="0" summary="tabla de equivalencias dup/dup2 y fcntl">
      <tr>
        <td valign="middle">
          <div class="c22">
            dup:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24"><tt>fcntl (</tt><i class="c20">desc_abierto</i><tt>, F_DUPFD, 0);</tt>&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            dup2:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24"><tt>close (</tt><i class="c20">desc_nuevo</i><tt>); fcntl (</tt><i class="c20">desc_abierto</i><tt>, F_DUPFD,</tt> <i class="c20">desc_nuevo</i><tt>);</tt>&nbsp;</td>
      </tr>
    </table>
    <span class="c9">&nbsp;</span> 

    <dl>
      <dd class="c13">b) Puede redirigirse hacia un fichero cualquier descriptor especial.</dd>
    </dl>
    <hr>

    <p><a name="dup2"></a><span class="c9">- Ejemplo:</span></p>
<pre class="c18">
/* dup2.c - Redirección usando dup2 */
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main (int contargs, char *args[])
    {
    int desc_fich;

    if contargs &lt; 3)
       {
       printf ("Formato: %s fichero comando [opciones].\n", args[0]);
       exit (1);
       }
    printf ("Ejemplo de redirección.\n");
    desc_fich = open (args[1], O_CREAT|O_TRUNC|O_WRONLY, 0);
    dup2 (desc_fich, 1);                /* Redirige la salida normal */
    close (desc_fich);
    execvp (args[2], &amp;args[2];  /* Ejecuta comando */
    exit (1);
    }


<i>$ dup2.e dup2.sal ls *.c
</i>Ejemplo de redirección.

<i>$ chmod 600 dup2.sal; cat dup2.sal
</i>alarm.c         atexit.c        dup2.c          escritor_fifo.c
exec.c          fork.c          fork_huerf.c    kill.c
lector_fifo.c   pipe.c          pipe_conec.c    signal.c
system.c        waitpid.c
</pre>
    <hr>

    <h4 class="c15">3,2,2. Subrutina <i>fcntl</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Realiza operaciones de control sobre ficheros abiertos, tales como:</dd>

      <dd>
        <div class="c14">
          <ul>
            <li>duplicar el descriptor,</li>

            <li>poner o leer características del descriptor,</li>

            <li>poner o leer estado del fichero,</li>

            <li>gestionar bloqueos de registros,</li>

            <li>gestionar la propiedad de la E/S asíncrona,</li>

            <li>cerrar varios ficheros.</li>
          </ul>
        </div>
      </dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;unistd.h&gt;</tt></dd>

      <dd><tt class="c17">#include &lt;fcntl.h&gt;</tt></dd>

      <dd><tt class="c17">#include &lt;sys/types&gt;</tt></dd>

      <dd><tt class="c17">int fcntl (descriptor, comando, argumento)</tt></dd>

      <dd><tt class="c17">int descriptor, comando, argumento);</tt></dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">descriptor: Descriptor del fichero.</dd>

      <dd class="c13">comando: Operación ha realizar.</dd>

      <dd class="c13">argumento: Parámetro del <i>comando</i>.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">Valor devuelto por el <i>comando</i>; -1, en caso de error.</dd>

      <dt class="c16">- Operaciones:</dt>
    </dl>
    <span class="c9">&nbsp;</span> 

    <table border="0" cellspacing="0" summary="Tabla de operaciones">
      <tr>
        <td valign="top">
          <div class="c22">
            F_DUPFD:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Obtener el menor descriptor de fichero disponible que sea mayor que el parámetro <i>descriptor.</i> Mantiene el mismo puntero y las mismas características del fichero original.&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            F_GETFD:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Obtener características del <i>descriptor</i>.&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            F_SETFD:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Poner características del <i>descriptor</i>.&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            F_GETFL:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Obtener estado del fichero.&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            F_SETFL:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Poner estado del fichero.&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            F_GETLK:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Obtener información de bloqueo.&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            F_SETLK:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Poner bloqueo.&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            F_SETLKW:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Poner bloqueo en una zona bloqueada.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c22">
            F_GETOWN:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Obtener PID (&gt;0) o PGID (&lt;0) del proceso que recibe las señales <b>SIGIO</b> o <b>SIGURG</b>.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c22">
            F_SETOWN:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Poner PID (&gt;0) o PGID (&lt;0) del proceso gestor de la E/S asíncrona.&nbsp;</td>
      </tr>

      <tr>
        <td valign="top">
          <div class="c22">
            F_CLOSEM:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Cierra todos los descriptores desde <i>descriptor</i> hasta el valor máximo (<b>OPEN_MAX</b>).&nbsp;</td>
      </tr>
    </table>
    <span class="c9">&nbsp;</span> 

    <dl>
      <dt class="c16">- Características del descriptor de ficheros:</dt>

      <dd class="c13"><b>FD_CLOEXEC</b>: Indica si el <i>descriptor</i> se cerrará ante una función <b>exec</b>.</dd>

      <dt class="c16">- Estados del modo de acceso al fichero:</dt>
    </dl>
    <span class="c9">&nbsp;</span> 

    <table border="0" cellspacing="0" summary="Estados del modo de acceso al fichero">
      <tr>
        <td valign="middle">
          <div class="c22">
            O_RDONLY:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Abierto sólo para lectura.&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            O_RDWR:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Abierto para lectura y escritura.&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            O_WRONLY:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Abierto sólo para escritura.&nbsp;</td>
      </tr>
    </table>
    <span class="c9">&nbsp;</span> 

    <dl>
      <dt class="c16">- Bloqueos:</dt>
    </dl>
    <span class="c9">&nbsp;</span> 

    <table border="0" cellspacing="0" summary="Bloqueos">
      <tr>
        <td valign="middle">
          <div class="c22">
            F_RDLCK:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Bloqueo de lectura (compartido).&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            F_WRLCK:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Bloqueo de escritura (exclusivo).&nbsp;</td>
      </tr>

      <tr>
        <td valign="middle">
          <div class="c22">
            F_UNLCK:&nbsp;
          </div>
        </td>

        <td valign="middle" class="c24">Sin bloqueo.&nbsp;</td>
      </tr>
    </table>
    <span class="c9">&nbsp;</span> 

    <dl>
      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) Un bloqueo de lectura evita que otros procesos activen bloqueos de lectura en cualquier zona del área protegida. Sí se permiten otros bloqueos de lectura en toda el área o en partes de ella.</dd>

      <dd class="c13">b) Un bloqueo de escritura evita que otros procesos bloqueen dicha zona.</dd>

      <dd class="c13">c) Los "abrazos mortales" en un sistema distribuido no siempre son detectables. El programa deberá usar temporizadores para poder liberar sus bloqueos.</dd>
    </dl>
    <hr>

    <h3 class="c11">3,3. Comunicación entre procesos emparentados.</h3>

    <h4 class="c15">3,3,1. Subrutina <i>pipe</i></h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Crea un canal de comunicación entre procesos emparentados.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;unistd.h&gt;</tt></dd>

      <dd><tt class="c17">int pipe (descriptores)</tt></dd>

      <dd><tt class="c17">int descriptores[2];</tt></dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">Tabla que recibirá los descriptores de entrada y de salida de la tubería.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">0, si se ha completado correctamente; -1, en caso de error.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) <i>descriptores</i>[0] se abre para lectura y <i>descriptores</i>[1], para escritura.</dd>

      <dd class="c13">b) La operación de lectura en <i>descriptores</i>[0] accede a los datos escritos en <i>descriptores</i>[1] como en una cola FIFO (primero en llegar, primero en servirse),</dd>
    </dl>
    <hr>

    <p><a name="pipe"></a><span class="c9">- Ejemplos:</span></p>
<pre class="c18">
/* pipe.c - Tubería sin nombre entre procesos padre e hijo */
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define LEER            0
#define ESCRIBIR        1

int main ()
    {
    int descr[2];       /* Descriptores de E y S de la turbería */
    int  bytesleidos;
    char mensaje[100],
        *frase="Veremos si la transferecia es buena.";

    printf ("Ejemplo de tuberÍa entre padre e hijo.\n");
    pipe (descr);
    if (fork () == 0)
       {
       close (descr[LEER]);
       write (descr[ESCRIBIR], frase, strlen(frase));
       close (descr[ESCRIBIR]);
       }
    else
       {
       close (descr[ESCRIBIR]);
       bytesleidos = read (descr[LEER], mensaje, 100);
       printf ("Bytes leidos: %d\n");
       printf ("Mensaje: %s\n", bytesleidos, mensaje);
       close (descr[LEER]);
       }
    }


Ejemplo de tubería entre padre e hijo.
Bytes leídos: 36
Mensaje: Veremos si la transferencia es buena.
</pre>
    <hr>

    <p><a name="pipeconec"></a></p>
<pre>
<b class="c21">/* pipe_conec.c - Tubería entre 2 comandos usando pipe. */
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define LEER            0
#define ESCRIBIR        1

int main (int contargs, char *args[])
    {
    int descr[2];       /* Descriptores de E y S de la turbería */

    if (contargs != 3)
       {
       printf ("Formato: %s comando_ent comando_sal.\n", args[0]);
       exit (1);
       }
    pipe (descr);
    if (fork () == 0)
       {
       close (descr[LEER]);
       dup2 (descr[ESCRIBIR], 1);
       close (descr[ESCRIBIR]);
       execlp (args[1], args[1], NULL);
       perror (args[0]);
       }
    else
       {
       close (descr[ESCRIBIR]);
       dup2 (descr[LEER], 0);
       close (descr[LEER]);
       execlp (args[2], args[2], NULL);
       perror (args[0]);
       }
    }


</b><span class="c9"><i>$ pipe_conec.e ls wc
</i>37 37 354</span>
</pre>
    <hr>

    <h3 class="c11">3,4. Comunicación entre procesos no emparentados.</h3>

    <h4 class="c15">3,4,1. Subrutina <i>mkfifo</i>:</h4>

    <dl>
      <dt class="c16">- Descripción:</dt>

      <dd class="c13">Crea un canal FIFO de comunicaciones entre procesos que no necesitan estar emparentados.</dd>

      <dt class="c16">- Formato:</dt>

      <dd><tt class="c17">#include &lt;sys/mode.h&gt;</tt></dd>

      <dd><tt class="c17">int mkfifo (camino, modo)</tt></dd>

      <dd><tt class="c17">const char *camino;</tt></dd>

      <dd><tt class="c17">int modo;</tt></dd>

      <dt class="c16">- Parámetros:</dt>

      <dd class="c13">camino: Camino completo del fichero FIFO.</dd>

      <dd class="c13">modo: Tipo de fichero y permisos de acceso.</dd>

      <dt class="c16">- Devuelve:</dt>

      <dd class="c13">0, si se ha completado correctamente; -1, en caso de error.</dd>

      <dt class="c16">- Comentarios:</dt>

      <dd class="c13">a) La subrutina <b>mkfifo</b> es un interfaz de la rutina <b>mknod</b> para crear colas FIFO, las cuales no necesitan privilegios especiales del sistema.</dd>

      <dd class="c13">b) El comando <b>ls -al</b> identifica una tubería nombrada con el carácter descriptor <b>p</b></dd>
    </dl>
    <hr>

    <p><a name="lectorfifo"></a><span class="c9">- Ejemplos:</span></p>
<pre class="c18">
/* lector_fifo.c - Tuberia con nombre usando mkfifo */
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/mode.h&gt;

int linea (int df, char *cad);

int main ()
    {
    int descr;
    char cadena[100];

    unlink ("tuberia");
    mkfifo ("tuberia", 0);
    chmod ("tuberia", 460);
    descr = open ("tuberia", O_RDONLY);
    while (linea (descr, cadena))
         printf ("%s\n", cadena);
    close (descr);
    pritnf ("Fin del lector.\n");
    }

int linea (int df, char *cad)
    {
    int n;

    do
      {
      n = read (df, cad, 1);
      }
    while (n &gt; 0 &amp;&amp; *cad++ != NULL);
    return (n &gt; 0);
    }
</pre>
    <hr>
<pre>
<a name="escritorfifo"></a><b class="c21">#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/mode.h&gt;

int main ()
    {
    int descr, longmens, i;
    char mensaje[100];

    sprintf (mensaje, "Un saludo desde el proceso %d", getpid ());
    longmens = strlen (mensaje) + 1;
    do
      {         /* intentar la conexion */
      descr = open ("tuberia", O_WRONLY);
      if (descr == -1) sleep (1);
      }
    while (descr == -1);
    for (i=0; i&lt;3; i++)
        {
        write (descr, mensaje, longmens);
        sleep (3);
        }
    close (descr);
    printf "Fin del escritor %d\n", getpid ());
    }</b>
</pre>
    <hr>

    <div class="c14">
<pre>
<a name="fifo"></a><b class="c21">#!/bin/ksh
# fifo - Carga los procesos lector y escritor en 2o plano.
lector_fifo.e &amp;
escritor_fifo.e &amp;
escritor_fifo.e &amp;</b>

</pre>
    </div>
  </body>
</html>

