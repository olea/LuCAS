<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN">

<!-- Editado a mano en Emacs por Sebastián Gurin <cancerbero_sgx@ -->
<!-- users.sourceforge.net> -->


<article lang="es">
  <articleinfo>

    <title>Edición Estructurada en Emacs</title>

    <authorgroup>

      <author>
	<firstname>Alejandro </firstname>
	<surname>Imass</surname>
      </author>

    </authorgroup>


    <date>2002-11-12</date>

  </articleinfo>
  

  <epigraph>      
    <para>Una guía de novato a novato sobre
      <productname>DocBook</productname> y otros
      estándares <acronym>SGML/XML</acronym> haciendo hincapié
      en el uso de la edición directa y estructurada utilizando
    <productname>Emacs</productname>. </para>
  </epigraph>






  <section id="index">
    <title>Introducción</title>
    <para>Este artículo se centra en el uso de <productname>Emacs</productname> para editar archivos <acronym>SGML</acronym> y sus
      derivados, como por ejemplo <acronym>XML</acronym> y <acronym>HTML</acronym>. Si nunca ha usado <productname>Emacs</productname> o este
      programa le desagrada por alguna razón, no se preocupe, a mí
    también me desagradaba. Siempre me pregunté qué era lo que la
    gente veía en una cosa tan complicada y poco amigable como
    <productname>Emacs</productname>. Sin embargo, cuando empecé a escribir en <productname>Docbook</productname> comprendí
    inmediatamente la necesidad de una herramienta más sofisticada que
    un simple editor de textos a color. En un principio yo hacía mis
    trabajos utilizando <productname>Nedit</productname>, uno de mis
    editores de texto favoritos, pero no llegó a las expectativas de
    lo que debía ser, para mí, el perfecto editor de texto estructurado: con
    sangrado automático, que dejara bonitos los párrafos, que pudiera
    chequear la ortografía solamente de los datos y, lo más
    importante, que tuviera medios para la validación contextual en
    tiempo de ejecución de cualquier <acronym>DTD</acronym>. Ahora bien, ésta quizá
    parezca una lista de deseos muy larga y difícil de satisfacer,
    pero descubrí que <productname>Emacs</productname> puede hacer fácilmente todo esto y mucho,
    pero mucho más. Nunca advertí el poder y la flexibilidad de
    <productname>Emacs</productname> ya que nunca me impresionó como entorno, lo advertí en la
    edición de documentos <acronym>SGML</acronym>. De hecho, luego de descubrir <productname>Emacs</productname>
    gracias a la edición estructurada, este programa se ha convertido en mi
    navaja suiza y espero que, cuando usted termine de leer este
    artículo, también se convierta en la suya. </para>

    <para>Recientemente he probado <productname>LyX</productname> con
    <productname>Docbook</productname> y ahora puedo concluir que este intento también tiene
    futuro y facilita la transición de editores <acronym>WYSIWYG</acronym> <footnote>
	<para><acronym>WYSIWYG</acronym> son las siglas de <quote>What You See Is What
    You Get</quote> (<quote>Lo que ves es lo que
    obtienes</quote>). Esto hace referencia a la filosofía de editores
    de textos como <productname>MS-Word</productname>, <productname>Word Perfect</productname>, <productname>Kword</productname>, o <productname>Writer</productname> de
    <productname>OpenOffice</productname>, en los que el usuario debe preocuparse por la apariencia y
    estructuración del formato del documento. </para></footnote>a la
    manera estructurada de editar textos. Sin embargo, esta clase de
    cosas nunca nos darán la libertad, el poder y 
    la flexibilidad que nos pueden dar herramientas como <productname>Emacs</productname> + <acronym>PSGML</acronym>,
    especialmente si nos encontramos en un ambiente de programación y
    estamos habituados a encarar los proyectos desde ese punto de
    vista.  </para>

    <para>Sobre el alcance de este artículo sólo diré que no se trata
    de una guía para <acronym>SGML</acronym>, <productname>Docbook</productname> o <productname>Emacs</productname>. Como ya diré más adelante,
    el principal objetivo es introducir y discutir el modo principal<footnote>
	<para>De aquí en adelante se traducirá <quote>major mode</quote> y
	  <quote>minor mode</quote> al español como <quote>modo
	    principal</quote> y <quote>modo secundario</quote>,
	  respectivamente. Nota del Traductor. </para></footnote> <acronym>PSGML</acronym> de
      <productname>Emacs</productname> y las dificultades más importantes 
    con las que se encontraría cualquier usuario al editar documentos
    <acronym>SGML</acronym> y <acronym>XML</acronym>. Este artículo trata de ser una guía para principiantes por
    lo que la información que se proveerá aquí debería ser suficiente
    para poder entender todo sin necesidad de conocimientos
    previos. De todos modos espero poder estimular 
    al lector lo suficiente como para investigar aún más en el
    tema. Es por esto que se dan algunas referencias y enlaces a otros
    artículos y libros al final de este artículo. </para>

    <para>Recordemos también que <productname>Docbook</productname>, <acronym>SGML</acronym> y <acronym>XML</acronym> se están moviendo
    a un ritmo muy rápido y que ya han surgido varias
    tendencias. Recomiendo la lectura del excelente artículo de
    Eric Raymond sobre <productname>Docbook</productname> en el cual se explica
    en qué etapa se encuentra <productname>Docbook</productname> actualmente y hacia dónde
    apuntan varias de las tendencias (hay un enlace al final). También
    deseo aclarar que este documento discute sobre el uso de <acronym>SGML</acronym>
    <productname>Docbook</productname> y no de <acronym>XML</acronym> <productname>Docbook</productname>, formato que parece ser una nueva
    tendencia. De todos modos, cualquier cosa que aparezca en este
    artículo probablemente se aplique también para <acronym>XML</acronym> <productname>Docbook</productname> que en
    esencia es la misma cosa. Por lo que entiendo, el modo principal <acronym>PSGML</acronym>
    es capaz de analizar sintácticamente <acronym>DTD</acronym> de tipos <acronym>SGML</acronym> y <acronym>XML</acronym>
    (o <emphasis>esquemas</emphasis><footnote>
	<para>del término <quote>schemes</quote>. Nota del Traductor. </para>
      </footnote> que es el nombre que se le da en el mundo <acronym>XML</acronym>), lo
    que es otro motivo para pensar que todo lo que sea mostrado en
    este artículo se aplicará a ambas variantes de <productname>Docbook</productname>.</para>
  </section>


  <section id="fantasia_sec">
    <title>La Fantasía de los <emphasis>Procesadores de
    Texto</emphasis></title>
    <para>Yo nací en la era de los <quote>Procesadores de
    textos</quote> por lo que no tuve oportunidad de conocer
    lo que era componer tipográficamente hasta que descubrí <productname>UNIX</productname> y
    <productname>Troff</productname> hace cinco años. Aunque suene
    poco creíble, quedé encantado con la nueva forma de escribir
    usando marcas<footnote><para>traducción de
    <quote>tags</quote> al español.</para></footnote> y sin tener que
    preocuparme por el aspecto de mis documentos pero sí por el
    contenido y la estructura, lo cual debería ser el principal
    objetivo de todos los autores. Más adelante descubrí
    <productname>Ispell</productname> y el resto de la filosofía
    <productname>Unix</productname> al integrar muchas y pequeñas
    piezas que realmente, todas juntas, funcionan
    perfectamente. </para>

    <para>Quizá, como programador, esto sea natural para mi. Me
      agradó el hecho de poder escribir (y mantener!) mis documentos de la
      misma manera en que escribo mis programas. De todos modos no quiero
      aburrir al lector con mis experiencias frente a una computadora
      por lo que, para hacer corta esta historia, un día descubrí una
      vieja tradición en computación llamada <acronym>SGML</acronym><footnote><para>
	  <ulink url="http://articles.linuxguru.net/view/202#FTN.AEN17">
	  http://articles.linuxguru.net/view/202#FTN.AEN17</ulink>
	</para></footnote>, y no pude creer que las computadoras se volvieran
      <acronym>WYSIWYG</acronym> en vez de volverse <acronym>WYSIWYM</acronym> (un concepto extraído de la
      página de <productname>LyX</productname>). </para>
    
    <para>He sufrido mucho y en primera persona el calvario de usar
    <trademark>Microsoft Word</trademark> para trabajar con documentos
    y manuales, en realidad no muy largos. A continuación listo algunas
    de mis experiencias:</para>

    <itemizedlist>
      <listitem>
	<para>Los formatos de documentos son difíciles de
	integrar. Integrar el trabajo de varias personas casi siempre
	se convierte en una pesadilla de reformateo, terminando
	siempre con una docena de estilos diferentes que son difíciles
	de limpiar. Dar formato nuevo a un documento Ms-Word es una
	larga, manual y tediosa tarea. </para>
      </listitem>
      <listitem>
	<para>El número de estilos crece fuera de control y no hay
	manera de poner en vigor un formato. Un usuario principiante
	terminará con una docena de formatos distintos o simplemente
	los ignorará a todos. Por ejemplo, un novato en Ms-Word (o
	cualquier otro programa <acronym>WYSIWYG</acronym>) probablemente lo que hará es
	simplemente cambiar la fuente y el tamaño a mano,
	en lugar de usar los encabezados y estilos apropiados. </para>
      </listitem>
      <listitem>
	<para>En el caso de que las compañías deseen crear plantillas de
	documentos estándar, las mismas se impondrán muy poco y
	probablemente sean todas violadas o mal usadas. Es muy difícil
	organizar un estándar para la documentación a nivel de una
	corporación y probablemente las compañías terminen con una
	docena de diferentes <quote>estándares</quote> en todos los
	departamentos. Por ejemplo, los logotipos y otros tipos de
	gráficos de una corporación tienden a mutar con el tiempo en
	muchos tipos de formas, proporciones y tamaños. Al final, cada
	usuario termina con lo que él cree que es el estándar de la
	compañía y, antes de que alguien se de cuenta, nadie sabrá
	cuál es realmente el logo oficial. </para>
      </listitem>
      <listitem>
	<para>Al trabajar con documentos de cierto tamaño, el programa
	tiende a volverse muy inestable, especialmente si trabajamos
	con imágenes u otros objetos. Un error típico de Ms-Word es la
	misteriosa X que por alguna razón que nadie conoce reemplaza
	todos nuestros gráficos. Ante este error el documento es
	irrecuperable y se deberá reemplazar cada gráfico a mano. </para>
      </listitem>
      <listitem>
	<para>El formato de un documento Ms-Word es binario, por lo que
	es básicamente inútil tratar de extraer la información dentro
	de ellos. Si las universidades solicitaran trabajos como
	tesis en estos formatos (y créanme que las universidades de
	aquí piden formato Ms-Word), estos serán
	tan útiles como papeles y desfavorecerán la creación de
	bases de datos de información. Por otro lado, si las
	universidades fueran inteligentes, pedirían los trabajos en
	formato <acronym>SGML</acronym> para así, más adelante poder crear bases de datos
	de conocimiento para que otros estudiantes puedan consultarlas
	eficientemente. </para>
      </listitem>
      <listitem>
	<para>El formato binario <filename>.doc</filename> parece
	expandirse en tamaño fuera de control cuanto más lo
	usemos. Solía haber una opción para compactar estos documentos
	pero, al parecer, ha desaparecido en las nuevas versiones de
	MS-Word. Esto es un real desperdicio de los recursos de una
	compañía dado que un usuario común desconoce esta
	característica: la única manera de resolver este problema es
	crear un nuevo documento <filename>doc</filename> y copiar y
	pegar todo el contenido del viejo documento en el nuevo. </para>
      </listitem>
      <listitem>
	<para>Los servidores de las corporaciones que usan estos
	formatos se alborotan y desorganizan fácilmente. Encontrar
	algo que usar se vuelve parecido a buscar piezas esparcidas en
	un campo de chatarra: se gastan horas abriendo documentos aquí
	y allá hasta que por fin se encuentra algo de valor. </para>
      </listitem>
      <listitem>
	<para>La reutilización de documentos es algo difícil de llevar
	a cabo y mantener. Por ejemplo, las presentaciones estándar de
	una compañía o capítulos estándar son algo muy difícil de
	integrar en un documento ya empezado, por lo que estas
	plantillas tienden a ser copiadas y modificadas por toda la
	compañía. </para>
      </listitem>
      <listitem>
	<para>Si el archivo binario se corrompe (lo cual sucede muy
	frecuentemente), no hay manera de salvar <emphasis>nuestra</emphasis> información,
	la cual está embebida en un formato propietario<footnote>
	    <para>No olvidemos otro problema bastante grave de los
	formatos binarios como <filename>.doc</filename>, especialmente
	grave en nuestros días de correo electrónico. Un archivo binario puede traer
	embebidas en su código algunas sentencias que pueden ser
	ejecutadas sin que el usuario se dé cuenta. Esto puede ser utilizado
	con malas intenciones (especialmente en
	los sistemas operativos <productname>Windows</productname>): hay testimonios de
	contaminación de virus informáticos a través de archivos
	binarios como los de <productname>Office</productname>. Actualmente, los antivirus traen
	opciones para verificar esta clase de documentos antes de
	abrirlos. Nota del Traductor. </para> </footnote></para>
      </listitem>
      <listitem>
	<para>La información podrá ser exportada en varios tipos de
	formato, pero siempre utilizando herramientas propietarias
	para tal tarea. No se recomienda exportar a otros tipos de
	formato dado que, además de la pérdida de datos que esto supone,
	no será una tarea trivial. Si trabajamos con MS Word y
	distribuimos nuestros archivos, estamos obligando a estas
	personas a utilizar software propietario tanto para leer
	como para convertir nuestros documentos a otros formatos.  </para>
      </listitem>
    </itemizedlist>

    <para>De cualquier forma, podría seguir escribiendo páginas de
      todos los problemas que herramientas del tipo Lo Que Ves Es Lo
      Que Obtienes (<acronym>WYSIWYG</acronym>) han causado a compañías y a la gente
      durante años. Personalmente, tuve la experiencia de tener una
      secretaria que se tomaba una hora o más para escribir una simple
      carta (mientras buscaba el logo correcto, chequeaba virus,
      imprimía y tenía problemas con la red, etc), una tarea que hace
      diez años se realizaba en tres minutos en una máquina de
      escribir común que no usaba electricidad. He visto estudiantes
      que derrochan varios días en tratar de integrar las diferentes
      partes de un trabajo y a veces pierden meses de tiempo debido a
      la corrupción de sus documentos o por virus en los mismos. En
      cuanto a mí, he perdido días y semanas de trabajo en la edición
      de manuales largos o especificaciones de algún sistema y estoy
      seguro que cualquier lector al leer estas líneas se acuerda de
      algún caso parecido que le ha tocado vivir
      personalmente. </para>

    <para>En conclusión, las herramientas para <quote>procesamiento de
      textos</quote> del tipo <acronym>WYSIWYG</acronym> son excelentes para trabajos
      pequeños de oficina o para uso simple personal. En algunos
      aspectos no se les puede negar su poder y pueden encargarse de
      trabajos de peso mediano sin problemas. No fueron hechas para la
      edición profesional a gran escala y definitivamente no son
      recomendables para uso a nivel corporativo, en el mismo sentido
      en que las hojas de cálculo nunca fueron diseñadas para
      almacenar gran cantidad de datos de alguna corporación, una
      mala costumbre muy común en las empresas modernas.  </para>

    <para>Aunque las herramientas <acronym>WYSIWYG</acronym> son relativamente fáciles de
      usar por un principiante, cuando queremos implementar su uso
      en forma profesional la curva de entrenamiento se hace cada vez
      más inclinada y los estándares no pueden ser puestos en práctica
      con dichas herramientas. </para>

    <para>Cualquiera que haya tenido que darles un uso serio a estas
      herramientas estará de acuerdo con que hay algo mal en ellas y que de
      seguro debe existir una forma alternativa de realizar el trabajo
      ¿ Alguien no está de acuerdo con que crear la Enciclopedia
      Británica es prácticamente imposible con herramientas como <productname>MS Word</productname>
      o <productname>Adobe Page-Maker</productname> ? Cuando uno mira hacia atrás en la historia
      de las computadoras se da cuenta de que esas alternativas
      siempre estuvieron disponibles, pero por alguna razón nunca
      fueron populares entre los usuarios mortales de
      computadoras<footnote><para>creo que dicha razón toma en este caso el nombre de
	  publicidad. Nota del Traductor-Comentarista ;-) </para></footnote>
    </para>
  </section>


  <section>
    <title>El Mundo del Formateo de Textos</title>

    <para>Usaré el concepto <quote>Formateo de textos</quote>
    discriminándolo de <quote>Procesamiento de textos</quote><footnote>
	<para>Se han traducido <quote><emphasis>Text
	      Processing</emphasis></quote> y <quote><emphasis>Word
	      Processing</emphasis></quote> al español como <quote>Formateo de
	    Textos</quote> y <quote>Procesamiento de Textos</quote>
	  respectivamente. Aunque no parezcan las traducciones correctas,
	  existe una diferencia sutil entre ambos conceptos en
	  inglés: <quote>Word Processing</quote> hace referencia a editores
	  <acronym>WYSIWYG</acronym> como <productname>MS Word</productname> mientras que <quote>Text
	    Processing</quote> hace referencia a la edición de documentos en
	  formatos estructurados, p.ej: <acronym>SGML</acronym>-<productname>Docbook</productname>. Sin embargo, empresas
	  como Microsoft han traducido <quote>Word Processing</quote>
	  como <quote>Procesadores de Textos</quote>. Así, si usáramos
	  las traducciones literales de dichos términos causaríamos
	  no poca confusión en los lectores. </para>
      </footnote> tal como aprendí leyendo mi primer libro de  
      <productname>UNIX</productname>. Fue en ese libro donde
      por primera vez descubrí lo que era
      <productname>Troff</productname> y la filosofía que se esconde
      detrás del concepto de formateo de textos (vs. <acronym>WYSIWYG</acronym>). </para>

    <para>El formateo de textos diferencia los siguientes elementos en
      un documento:</para>
    <itemizedlist>
      <listitem>
	<para>Contenido</para>
      </listitem>
      <listitem>
	<para>Estructura</para>
      </listitem>
      <listitem>
	<para>Estilo</para>
      </listitem>
    </itemizedlist>
    <para>Básicamente, la filosofía se resume en que los autores deben
      concentrarse en el contenido y estructura antes que en el estilo
      de sus documentos. Dado que la mayoría de las veces la estructura está
      predefinida (o estandarizada en el caso de <productname>Docbook</productname>) para
      satisfacer el cometido del autor, éste termina concentrándose
      estrictamente en el contenido, lo cual debería ser su interés
      primario. </para>

    <para>En el formateo de textos los autores pueden usar las más
    simples herramientas, como un editor de textos, o pueden utilizar
      editores de textos estructurados y especializados, como
      <productname>LyX</productname> o
    <productname>Emacs</productname>. En cualquiera de los casos, su
    información siempre es almacenada en el más natural de los
    formatos de computadora: <emphasis>texto plano</emphasis>. Esto
    adquiere mucho sentido dadas todas las razones que se dieron en
      contra de los formatos binarios en <xref linkend="fantasia_sec"></para>


    <section>
      <title>¿Por qué <acronym>SGML</acronym>?</title>
      <para>Resumen corto de la historia</para>
      <para>Opuestamente a lo que la mayoría cree, <acronym>SGML</acronym> (el padre de
	<acronym>XML</acronym>) es un lenguaje muy antiguo, hasta tal punto que algunos lo
	llaman <quote>la venganza de los cuarentones</quote>. Este
	significado se debe a que hace algo más de 20 años hubo
	muchos entusiastas de computación que hicieron mucha fuerza en la comunidad para la
	implementación de estándares abiertos como <acronym>SGML</acronym>. Éstos fueron
	ignorados por el mercado o quizá anulados del mismo por
	intereses comerciales. De cualquier modo, <acronym>SGML</acronym> se ha usado en
	compañías e industrias muy importantes durante muchos años. De
	hecho, muchas corporaciones importantes han almacenado su
	experiencia y conocimiento corporacional en <acronym>SGML</acronym> desde hace ya
	mucho tiempo<footnote>
	  <para> <ulink url="http://xml.coverpages.org/general.html#faq">
	  http://xml.coverpages.org/general.html#faq</ulink> es un
	    buen enlace en donde se detalla la historia de <acronym>SGML</acronym>. </para>
	</footnote>.  </para>
      

      <para><acronym>XML</acronym> es simplemente un subconjunto simplificado de <acronym>SGML</acronym> lo
      que significa que cualquier documento <acronym>XML</acronym> es un <acronym>SGML</acronym> válido,
      pero no cumpliéndose necesariamente lo recíproco. El cometido
	básico de <acronym>XML</acronym> en nuestros días es superar lo que
	<acronym>HTML</acronym><footnote>
	    <para> <ulink url="http://articles.linuxguru.net/view/202#FTN.AEN74">
		http://articles.linuxguru.net/view/202#FTN.AEN74</ulink></para>
	  </footnote> ha sembrado tras la
	explosión de la web en los 90. Historias sobre estos lenguajes
	pueden ser encontradas por toda la web, por lo que no daré más
	detalles sobre este tema. De todos modos, en el resto del
	documento me estaré refiriendo a <acronym>SGML</acronym>, pero en este punto el
	lector probablemente se de cuenta de que <acronym>XML</acronym> es casi la misma
	cosa, sólo que más simple. Cuando hablamos de transformaciones a
	otros formatos,
	existen algunas distinciones importantes entre <acronym>SGML</acronym> y <acronym>XML</acronym>. <acronym>SGML</acronym>
	usa las hojas de estilo <acronym>DSSSL</acronym> las
	cuales son escritas en <productname>Scheme</productname>, un
	dialecto de <productname>Lisp</productname>. <acronym>XML</acronym> ha
	desarrollado un estándar más simple de transformación llamado
	<acronym>XSLT</acronym> el cual se escribe en <acronym>XML</acronym> lo
	cual hace que sea mucho más fácil de escribir y mantener. Dado
	que todo esto no es un punto fundamental de este artículo,
	recomiendo a los lectores interesados en el tema que lean el
	excelente artículo de Eric Raymond:</para>

      <para><ulink url="http://www.tldp.org/HOWTO/Docbook-Demystification-HOWTO/">
	  http://www.tldp.org/HOWTO/Docbook-Demystification-HOWTO/</ulink></para>

      <para>Finalmente y para aclarar la pregunta implícita en el
      título de esta sección, <acronym>SGML</acronym> (o <acronym>XML</acronym>) es una buena idea
      principalmente porque es un lenguaje extensible que puede ser
      fácilmente transformado en otros estándares cuando estos salgan
      al público. Esto significa que si usted escribe o mantiene sus
      documentos en <acronym>SGML</acronym>, se asegurará que sobrevivan a cualquier cambio
      en la tecnología o en los estándares y puedan ser transformados
      a cualquier otro tipo de estándar que eventualmente surja. Más
      aun, <acronym>SGML</acronym> es el antiguo y estable ISO 8879:1986. </para>


    </section>

    <section>
      <title>Breve vistazo a <acronym>SGML</acronym></title>
      <para>La denominación <acronym>SGML</acronym> viene de <emphasis>Standard Generalized Mark-up Language</emphasis> (algo
      así como Lenguaje Estándar Generalizado de Etiquetas). A su vez,
      <acronym>XML</acronym> viene de eXtensible Mark-up Language (Lenguaje Extensible de
      Etiquetas) y es simplemente un subconjunto simplificado de <acronym>SGML</acronym>
      (no una implementación, ver sección anterior). Es un lenguaje de
      computadoras, pero no es un lenguaje procedural (o sea, las
      instrucciones no son ejecutadas en algún orden específico), sino
      un lenguaje declarativo. </para>

      <para>Los lenguajes de etiquetas (Mark-up) se basan justamente en el uso de
       &lt;la etiqueta> (tag). Ésta define la estructura de un modo muy
      parecido a lo que sucede en las bases de datos. Todo lo demás es
	contenido o, para utilizar la jerga <acronym>SGML</acronym>, caracteres de datos
      (<wordasword>CDATA</wordasword>). Desde el punto de vista del
      estándar, <acronym>SGML</acronym> sólo define reglas básicas sobre el uso y
      anidación de las etiquetas. Por ejemplo, se encuentra explícito en el
      lenguaje que cada etiqueta debe tener una etiqueta de final (end
      tag) correspondiente y que la anidación de etiquetas debe ser
      perfecta, lo que significa que las etiquetas internas deben ser
      cerradas antes de las etiquetas externas. Por supuesto, las
      definiciones <acronym>SGML</acronym> son mucho más complejas que esto, pero
      básicamente esas son las reglas principales. <acronym>XML</acronym> también tiene
      reglas estrictas como éstas. Hay etiquetas excepcionales las
      cuales no tienen una etiqueta de final correspondiente y son del
      formato &lt;tag/>. Además, a las etiquetas también podemos
	pasarles parámetros como es el caso de la etiqueta
	<sgmltag>&lt;BODY></sgmltag> en <acronym>HTML</acronym>, en
      la cual se puede, por ejemplo, especificar el color de fondo de
	la página con el parámetro
      <parameter>BGCOLOR="WHITE".</parameter>. </para>

      <para>Dadas estas reglas básicas, todo lo demás se deja a
	discreción del usuario. Esto significa que el nombre de las
	etiquetas, sus parámetros y las implementaciones específicas
	de las reglas de anidación pueden ser realizadas por la
	persona que escribe en <acronym>SGML</acronym>. Ésta es la belleza verdadera del
	lenguaje ya que permite que cualquiera invente su propio
	estándar de etiquetas. Si lo pensamos detenidamente entonces
	<acronym>SGML</acronym> es en realidad un lenguaje para describir estructuras
	flexibles de datos que pueden ser fácilmente manipuladas y
	transformadas por herramientas, llamadas analizadores
	sintácticos (parsers). Las estructuras de datos <acronym>SGML</acronym> son, por
	mucho, más flexibles que las tablas
	<acronym>RDBMS</acronym> (aka
	<acronym>SQL</acronym>) para almacenar cosas
	complicadas como libros, pero no sólo se limitan a manipular
	documentación. De hecho, <acronym>SGML</acronym> y ahora también <acronym>XML</acronym>, están
	siendo utilizados para el almacenamiento en bases de datos de
	propósitos generales, desplazando varias implementaciones
	heredadas de <acronym>DBMS</acronym> de Relacionamiento de Objetos
	(Object-Relational <acronym>DBMS</acronym>). </para>

      <para>Ahora bien, si cualquiera puede realizar su propio
	lenguaje de etiquetas con <acronym>SGML</acronym>, tiene que haber un modo de
	poner en vigor las reglas que hemos inventado. Esto es
	implementado por lo que se denomina como <acronym>DTD</acronym> (Document Type
	Definition, o en español Definición del Tipo de Documento). Un
	<acronym>DTD</acronym> define los nombres de las etiquetas, el orden legal de las
	ocurrencias y las reglas de anidación para una implementación
	<acronym>SGML</acronym> particular. A la vez, los <acronym>DTD</acronym>s se escriben en <acronym>SGML</acronym> y se
	representan como un simple archivo en el sistema. En especial, <productname>Docbook</productname>
	es un <acronym>DTD</acronym> que se usa para definir <emphasis>libros</emphasis>
	y <emphasis>artículos</emphasis>.  </para>

      <para>El uso de <acronym>DTD</acronym>s impone ciertas condiciones. Primero sobre
      la persona que va a utilizarlas, o sea, la persona deberá tener
      algún conocimiento básico de la <acronym>DTD</acronym> antes de empezar a escribir
      en ese formato. También es conveniente usar un editor
      estructurado que tenga la capacidad contextual de
      validación. Estos editores son muy útiles ya que nos irán
      indicando las etiquetas que están permitidas en cierto punto de
      nuestro documento (irán analizando las reglas de la <acronym>DTD</acronym> por
      nosotros). Aún más, podremos usar un analizador sintáctico que
      valide los documentos usando un cierta <acronym>DTD</acronym> de nuestro sistema y
      que indique todas las inconsistencias. </para>

      <para>Bueno, esto es básicamente todo lo que se necesita saber
      para empezar a trabajar con <acronym>SGML</acronym>. Todos estos conceptos se
      clarificarán a medida que avancemos la lectura, especialmente en
      la siguiente sección que discute cómo crear un documento <acronym>SGML</acronym>
      usando <productname>Emacs</productname>. </para>
    </section>
  </section>

  <section>
    <title><acronym>SGML</acronym> usando <productname>Emacs</productname></title>
    <para>La palabra <productname>Emacs</productname> podría ahuyentar a mucha gente que lea este
    artículo. Yo los entiendo. No puedo entender por qué diablos
    un editor tiene que ser tan complicado y obscuro. Es por esto que
    nunca me esforcé mucho por aprender a usarlo. Soy tan sólo un
    hombre simple y haragán y amo a los editores simples y poderosos
    como Nedit, del cual pienso todavía que es un gran editor. Sin
    embargo, y créanme, cuando descubran la edición <acronym>SGML</acronym> utilizando
    <productname>Emacs</productname> (lo cual, con suerte aprenderán aquí),
    realmente se sorprenderán. De hecho, estoy seguro de que quedarán
    tan impresionados que nunca más querrán abandonar <productname>Emacs</productname> para
    ninguna de sus necesidades de edición. Están leyendo estas
    palabras de alguien que solía evitar <productname>Emacs</productname> a toda costa y ahora
    lo usa para todas las cosas que se puedan imaginar. </para>

    <para>Aprender <productname>Emacs</productname> es un viaje largo, pero no tiene por qué ser
    aburrido. Se debe entender que este programa no es tanto un editor
    de textos, sino todo un ambiente. Luego, si se lo lleva poco a
    poco, terminaremos por acostumbrarnos a él y, eventualmente
    amarlo. </para>

    <para>Antes de empezar con la parte práctica de esta guía se
    necesitará instalar todas las siguientes cosas para interpretar
    los ejemplos. </para>

    <section>
      <title>Requisitos del Sistema</title>
      <para>Necesitará verificar su sistema y asegurarse de que 
      cuenta con todas las herramientas descritas abajo instaladas y
      funcionando.  </para>
      <itemizedlist>
	<listitem>
	  <para>Alguna clase de sistema operativo <productname>UNIX</productname> o tipo-<productname>UNIX</productname>. Lo
	  siento, este artículo no es para usuarios de Windoze. No
	  estoy discriminando injustamente, es sólo que no tengo ni idea
	  de cómo funcionan las herramientas en este ambiente y
	  tampoco tengo intenciones de averiguarlo. Yo por ejemplo, uso el Sistema
	  Debian con el Núcleo Linux. <footnote>
	      <para>La sutil precisión de la oración tiene como
	  propósito impedir en este documento la confrontación Linux
	  vs. GNU/Linux. </para> </footnote>. </para>
	</listitem>
	<listitem>
	  <para>Se necesitará alguna versión de GNU
	  <productname>Emacs</productname>. Probablemente todo esto también funcione con
	  <productname>XEmacs</productname> pero francamente no sé
	  cuáles son las diferencias entre ambos paquetes. De todos
	  modos, si usted es
	  un usuario de <productname>XEmacs</productname>
	  probablemente sepa qué hacer para conseguir que todo esto
	  camine. Yo uso <productname>Emacs</productname> 21 el cual viene con unos coquetos
	  menús y una barra de herramientas en X. Esta última versión
	  probablemente sea la más adecuada para los principiantes.  </para>
	</listitem>
	<listitem>
	  <para><acronym>PSGML</acronym>: (Tomado de la documentación de <acronym>PSGML</acronym>) <quote>Es
	  un modo principal para editar documentos <acronym>SGML</acronym> y
	  <acronym>XML</acronym>. Funciona con GNU <productname>Emacs</productname>
	  <productnumber>19.34</productnumber>, <productnumber>20.3</productnumber>, o mayores o con
	  <productname>XEmacs</productname>
	  <productnumber>19.9</productnumber>. <acronym>PSGML</acronym> contiene un
	  simple analizador sintáctico <acronym>SGML</acronym> y puede trabajar con
	  cualquier <acronym>DTD</acronym>. Entre las funciones que provee se destacan
	  menús y comandos para insertar las etiquetas que sean contextualmente
	  válidas, identificación de errores estructurales, edición de
	  los valores de los atributos en una ventana aparte con
	  información sobre tipos estándar y una edición
	  estructurada. </quote></para>
	  <para>La discusión sobre este paquete y por qué <productname>Emacs</productname> puede
	    ser tan poderoso en la edición estructurada como <acronym>SGML</acronym> o <acronym>HTML</acronym>
	    será el principal objetivo de este artículo. De hecho, el modo
	    <acronym>HTML</acronym> de <productname>Emacs</productname> es muy poderoso y hace que la creación y edición
	    de páginas web sea una pasada. Doy ánimos a los usuarios a que,
	    después de leer este artículo prueben este modo principal de
	    <productname>Emacs</productname>. Algunas personas son perezosas y prefieren los editores
	    <acronym>HTML</acronym> de tipo visual. Si bien son muy fáciles de usar, no
	    son prácticos a la hora de crear páginas web dinámicas. El
	    código que generan casi siempre es muy sucio (en particular el
	    código generado por <productname>MS-FrontPage</productname> es horrible) o lleno de datos
	    inútiles. Esto hace que se haga difícil el cortar y pegar piezas
	    aquí y allá para crear páginas dinámicas usando, por ejemplo
	    <productname>Perl/CGI</productname> o
	    <productname>PHP</productname>. Además, si nos consideramos a
	    nosotros mismos programadores y admitimos la necesidad de una de
	    estas herramientas visuales, probablemente nos encontremos en el sitio
	    equivocado y deberíamos considerar cambiar nuestra carrera al
	    diseño gráfico. </para>
	</listitem>
	<listitem>
	  <para><productname>SGML-Base</productname> y <productname>SGML-Data</productname>: Así es como son
	  llamados en <productname>Debian</productname>. Se deberá
	  contar con la instalación equivalente en la distribución
	  usada. De cualquier modo, esto debería instalar el archivo de
	  catálogo de <acronym>SGML</acronym> base y los <acronym>DTD</acronym>s básicos (se explicará todo
	  esto más adelante). Estoy casi seguro de que esto es lo que
	  deja que nuestros documentos usen los identificadores
	  públicos en lugar de los identificadores del
	  sistema.</para>
	      <para>En cualquier documento <acronym>SGML</acronym>, la primera línea debe
	  ser una declaración <acronym>SGML</acronym> o una declaración DOCTYPE de la
		forma:</para>
<para><programlisting>&lt;!DOCTYPE article PUBLIC "-//OASIS//DTD Docbook V3.1//EN" ></programlisting></para>
	      <para>Esta línea le dirá al analizador sintáctico frente
		a qué tipo de documento se encuentra y contra qué <acronym>DTD</acronym> debe
		validar. En el ejemplo de arriba, el documento es un
		<quote>artículo</quote> definido en el <acronym>DTD</acronym> <productname>Docbook</productname>. Si
		todo está instalado correctamente, el sistema debería ser
		capaz  de encontrar el <acronym>DTD</acronym> sin que le tengamos que
		especificar caminos a los archivos. Si el encabezado de
		arriba no llegara a funcionar, todavía tendremos la
		posibilidad de agregar lo que se llama un
		<quote>identificador de sistema</quote> para que así el
		analizador sintáctico pueda encontrar el <acronym>DTD</acronym>. Los
		analizadores sintácticos toman la siguiente forma: </para>
<para><programlisting>&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook V4.1//EN"
		  "/usr/lib/sgml/dtd/docbook-3.1/docbook.dtd"></programlisting></para>
	      <para>Estoy bastante seguro de que los archivos de
		catalogos <acronym>SGML</acronym> que se piden como requisitos es lo que
		deja al usuario usar solamente identificadores públicos, lo
		que hace que los documentos sean mucho más portables. Si
		algún lector puede contribuir con algún comentario adicional
		en esta parte, agradecería la retroalimentación. </para>
	</listitem>
	<listitem>
	  <para><productname>SGML-Tools</productname>,
	    <productname>SGML-Tools Lite</productname>,
	    <productname>Docbook-Tools</productname>,
	    <productname>Debian-Doc</productname> o
	    <productname>Linux Doc Tools</productname>. Esto depende
	    de la distribución Linux usada y las tareas que se quieran
	    realizar. Estos paquetes se denominan de forma diferente en cada
	    distro pero realizan las mismas tareas. Se encargan de
	    instalar guiones que facilitan la conversión de <acronym>SGML</acronym> a
	    cualquiera de los formatos <acronym>HTML</acronym>, <acronym>PS</acronym>, <acronym>PDF</acronym>, <acronym>RTF</acronym>, TeX,
	    etc. Estos guiones probablemente causen dependencias a
	    otros paquetes como <productname>Jade</productname> y
	    <productname>TeX</productname>. También necesitaremos
	    instalar el <acronym>DTD</acronym> de <productname>Docbook</productname>, las hojas de estilo <acronym>DSSSL</acronym> de
	    <productname>Docbook</productname>, <acronym>XML</acronym> y <acronym>XSL</acronym> (si eventualmente queremos trabajar con
	    <acronym>XML</acronym>-<productname>Docbook</productname>) y el paquete
	    <productname>Docbook-Utilities</productname>. Después de que
	    hayamos instalado todas estas utilidades seremos capaces
	    de ejecutar órdenes como <command>db2ps</command>,
	    <command>db2html</command>,
	    <command>db2rtf</command> y demás. </para>
	  <para>He aquí algunas de las dependencias que puedo deducir
	    de la información provista por los paquetes en
	    <productname>Debian</productname>:</para>
	  <itemizedlist>
	    <listitem>
	      <para>La conversión a texto requiere
	      <productname>groff-base</productname></para>
	    </listitem>
	    <listitem>
	      <para>La conversión a LaTeX requiere
		<productname>tetex-base</productname>,
		<productname>tetex-bin</productname> y
		<productname>tetex-extra</productname>. </para>
	    </listitem>
	    <listitem>
	      <para>La conversión a Info requiere
	      <productname>Jade</productname>. </para>
	    </listitem>
	    <listitem>
	      <para>La conversión a PostScript requiere
		<productname>TeX</productname>,
		<productname>DVI</productname>,
		<productname>GhostScript</productname> y otras
		herramientas <acronym>PS</acronym>. A su vez, si queremos ver los
		archivos <filename>.ps</filename> deberemos tener
		instalado <productname>GhostView</productname> u otro
		programa equivalente. </para>
	    </listitem>
	  </itemizedlist>

	  <para>La lista de arriba debe tomarse como algo
	  representativo y variará según el sistema (si hablamos de
	  Linux dependerá en la distribución y versión). De todos
	  modos, dado que <acronym>SGML</acronym> y <productname>Docbook</productname> son herramientas bastante
	  estándar en los sistemas operativos libres, es muy común que
	  su sistema tenga un macro paquete  que instale todo lo que
	  necesitemos con relativa facilidad. </para>

	</listitem>
      </itemizedlist>
    </section>


    <section>
      <title>Hola Mundo</title>
      <para>A este punto el lector debería ser capaz de iniciar <productname>Emacs</productname>
	invocando <command>emacs</command> en el intérprete de órdenes o
      seleccionando la opción en nuestro escritorio. Notar que
      <productname>Emacs</productname> tendrá el mismo comportamiento tanto en X Window como en
      la consola de caracteres. Creo que la única diferencia es que en
      el modo de caracteres los menús deben ser activados con el
      teclado, en lugar de utilizar el ratón. En realidad no puedo
      explicar mucho sobre este punto ya que nunca he usado <productname>Emacs</productname> en
      modo de consola puro. </para>
      <para>Una vez que <productname>Emacs</productname> se haya ejecutado nos encontraremos en
	el búfer *scratch*.<footnote><para>El lector debe notar
      que este artículo no es una guía paso-a-paso sobre el uso de
      <productname>Emacs</productname>. Hay mucha información
      escrita sobre esto. Este artículo se enfocará en el uso del modo
      principal <acronym>PSGML</acronym> y el <acronym>DTD</acronym> <productname>Docbook</productname>. De todos modos se hará una
      reseña paso-a-paso sobre el conocimiento mínimo necesario para
      que un principiante pueda manejarse en este documento. El resto
      debería ser investigado por el lector. </para></footnote>
	Podremos crear un nuevo archivo usando los comandos
	<keycombo><keycap>C-x</keycap></keycombo><guimenu><accel>C-x C-f</accel></guimenu></para>
      <sidebar>
	<para>Nótese que <keycap>C-x</keycap>
	  hace referencia a presionar la tecla <keycap>Ctrl</keycap> y
	  luego la tecla <keycap>x</keycap>. La secuencia
	  <keycombo><keycap>M-x</keycap></keycombo> hace
	  referencia a presionar la tecla <keycap>Alt</keycap> y luego
	  la <keycap>x</keycap>. En <productname>Emacs</productname>, la tecla
	  <keycap>Alt</keycap> puede emularse presionando (y soltando)
	  primero la tecla <keycap>Esc</keycap> siguiendo la tecla que
	  corresponde. De hecho, en algunos sistemas la tecla
	  <keycap>Alt</keycap> no funcionará y nos veremos obligados a
	  usar la tecla <keycap>Esc</keycap>. </para>
      </sidebar>

      <para><productname>Emacs</productname> preguntará por el archivo en la parte inferior de la
	pantalla, la cual se llama mini-búfer. Si se escribe el
	nombre de un archivo que no existe en el directorio actual
	(casi siempre ~/), <productname>Emacs</productname> creará un nuevo archivo. Para
	empezar, escríbase <filename>hello.sgml</filename> y
	presiónese <keycap>enter</keycap>. </para>

      <sidebar>
	<para>Para la gente nueva en <productname>Emacs</productname>, este trajeteo entre
	cuadros puede resultar un poco confuso. Aunque, <productname>Emacs</productname>
	automatiza la mayoría de estas conmutaciones, si en algún
	punto nos encontramos perdidos, para volver a empezar podemos
	  hacer click en el mini-búfer y presionar
	<keycap>C-g</keycap> algunas veces. Esta orden le dice a
	<productname>Emacs</productname> que aborte las órdenes previas. </para>
	<para>Si por alguna razón nuestra pantalla está dividida en
	  más de un cuadro, podremos <quote>maximizar</quote>
	(para usar un término familiar) cualquiera de estos cuadros
	  simplemente haciendo click en él y luego presionando
	<keycap>C-x 1</keycap>. Además, podremos dividir la pantalla
	  de muchas maneras diferentes. Pruébese esto presionando
	  <keycap>C-x 2</keycap>, <keycap>C-x 3</keycap>, y demás
	  combinaciones. Estando en X-Window es realmente una buena
	idea tener la pantalla separada en cuadros, ya que podremos
	seleccionar cada uno de ellos por separado con un simple click
	de ratón. </para>
      </sidebar>

      <para>Si se ha instalado correctamente <acronym>PSGML</acronym> se debería ver
	<prompt>Loading psgml...done</prompt> en el
	mini-búfer. También, en la barra de estado (la línea que
	está justo arriba del mini-búfer), se debería ver
	<prompt>SGML</prompt> indicando que se ha activado el modo
	principal <acronym>SGML</acronym>. </para>

      <sidebar>
	<para><productname>Emacs</productname> trabaja en los modos principal y secundario. Sólo
	  puede haber un único modo principal activado a la vez. El
	  modo <acronym>SGML</acronym> en el modo principal en el cual estaremos
	  trabajando nosotros. Los modos secundarios se caracterizan
	  por realizar tareas específicas y se puede tener varios de
	  ellos ejecutándose dentro de un modo primario. Por ejemplo,
	  existen varios modos secundarios útiles como auto-fill-mode
	  e ispell-mode, los cuales nos ayudarán mucho cuando
	  trabajemos con archivos <acronym>SGML</acronym>. El modo secundario Ispell
	  verificará nuestra ortografía en tiempo real, mientras que
	  el modo secundario auto-fill nos ayudará a mantener nuestros
	  párrafos justificados correctamente. </para>
      </sidebar>

      <para>He aquí el archivo completo para un documento tipo
	<quote>Hola mundo</quote>:</para>

      <example id="ejemplo1">
	<title>Ejemplo de código para Hola Mundo</title>
<programlisting>&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook V3.1//EN" []>
&lt;book>
  &lt;title>Mi primer libro&lt;/title>
  &lt;chapter>
    &lt;title>Mi primer capítulo&lt;/title>
    &lt;sect1>
      &lt;title>Mi primer sección&lt;/title>
      &lt;para>
        Mi primer párrafo
     &lt;/para>
    &lt;/sect1>
  &lt;/chapter>
&lt;/book></programlisting>
      </example>

      <para>Se podría escribir este listado carácter a carácter en
      cualquier otro editor (excepto quizá con LyX), o se puede sacar
      provecho de las ventajas que tiene el modo principal <acronym>PSGML</acronym> de
      <productname>Emacs</productname> para la edición estructurada. Aquí es donde comienza la
      parte interesante... </para>

    </section>

    <section>
      <title>Primer Paso: La declaración del Documento</title>
      <para>La primera cosa que siempre se deberá hacer al editar un
      documento <productname>Docbook</productname> es escribir la Declaración del Tipo de
      Documento, y esto debe ser realizado manualmente. </para>

      <programlisting>&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook V3.1//EN" []></programlisting>

      <para>Esta primera línea en el documento le dirá a <productname>Emacs</productname> dónde
      encontrar la <acronym>DTD</acronym> para que pueda analizarlo sintácticamente
      cuando sea necesario. La <acronym>DTD</acronym> contiene todas las reglas para
      <productname>Docbook</productname> y permitirá a <acronym>PSGML</acronym> deducir qué cosas están permitidas,
      en qué lugares y cómo realizar el sangrado del documento. </para>

    </section>
    <section>
      <title>Empezar a usar <acronym>PSGML</acronym></title>
      <para>Ahora que se tiene la línea DOCTYPE, muévase el cursor
	justo debajo y presiónese <keycap>C-c C-e</keycap>. Si nos
      tardamos lo suficiente en el mini-búfer se podrá apreciar que
	<productname>Emacs</productname> ha elegido <emphasis>book</emphasis> como el elemento
      válido. Esto es así porque en ese punto del documento no hay
      otro elemento válido que podamos ingresar. Ahora, presiónese
      enter y veamos que ocurre. Si todo funciona bien, obtendremos el
      siguiente código:</para>

      <programlisting>
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook V3.1//EN" []>
&lt;book>
&lt;/book>
      </programlisting>

      <para>Ahora presiónese enter una vez más y luego <keycap>C-c
      C-e</keycap>. Obsérvese ahora que <productname>Emacs</productname> no es capaz de decidir
      qué etiqueta usar en este punto dado que existe más de una
	opción. Igual que en una shell se podrá presionar
      <keycap>Tab</keycap> para autocompletar pero, dado que existen
      muchas opciones se verá que la pantalla se divide mostrándonos
      una lista de las etiquetas válidas en ese punto del
      documento. </para>
      <para>Si se desea salir de dicha selección, simplemente
	presiónese <keycap>C-g</keycap> o escríbase las primeras
	letras de la etiqueta (por ejemplo, escríbase <quote>ti</quote>), y luego
	<keycap>Tab</keycap> y luego <keycap>Enter</keycap>. Lo que
      hemos hecho es crear una etiqueta para insertar el título del
      documento y <productname>Emacs</productname> ya ha ubicado el cursor justo donde los
	necesitamos! Escríbase el título y muévase el cursor al final
	de la línea (como en cualquier editor, se podrá presionar
	<keycap>End</keycap> con tal motivo), presiónese
	<keycap>Enter</keycap> y luego <keycap>C-c
	  C-e</keycap>. Escríbase ahora <quote>ch</quote> y luego
	presiónese <keycap>Tab</keycap>. ¡Acabamos de crear nuestro
      primer capítulo!. Sígase igual, hasta haber editado un documento
	parecido a <filename>hola-mundo.sgml</filename> listado en <xref
      linkend="ejemplo1"/>.
      </para>
      <para>Hasta el momento, se podrá empezar a apreciar lo que se quiso
      decir con un editor de textos estructurado. Y esto es sólo el
      comienzo, ya que la funcionalidad de <acronym>PSGML</acronym> se conecta con muchas
      características interesantes de <productname>Emacs</productname>, lo que realmente confirma
      que ambas cosas son las herramientas definitivas para el
      desarrollo de documentos <acronym>SGML</acronym>. Por supuesto, puede pasar que a
      este punto a uno todavía no le agrade tanto <productname>Emacs</productname> porque, a
      pesar de las ventajas vistas, todavía sigue siendo muy raro y
      obtuso. Así que, hagamos algunas mejoras....</para>

    </section>

    <section>
      <title>Gran introducción, pero <productname>Emacs</productname> sigue sin gustarme
      demasiado...</title>
      <para>Bueno, probablemente para muchos usuarios como yo, que venimos de
      editores de texto amigables y coquetos, <productname>Emacs</productname> sea insípido y
      complicado por lo que en esta sección se mostrará cómo hacer que
      funcione como un editor de textos normal. Se podrá ver que con
      un pequeño retoque <productname>Emacs</productname> puede ser tan o más
      amigable que el editor de textos que solíamos usar. </para>

      <section>
	<title>Colores de las Fuentes</title>
	<para>La principal cosa que perdí al migrar a <productname>Emacs</productname> fue el
	  Coloreado Sintáctico<footnote>
	    <para>que es la traducción al español de <quote>Syntax
	Highlighting</quote>. Nota del traductor. </para>
	  </footnote> y me costó mucho trabajo enterarme de cómo
	  activarlo. En <productname>Emacs</productname>, la opción para esto se llama
	<emphasis>Global Font Lock</emphasis>. El porqué de tal
	nombre es un misterio para mí, pero he aquí lo que hay que
	  hacer para activarla:
	</para>
	<para><prompt>M-x global-font-lock</prompt></para>
	<para>Obviamente, no se deberá escribir todo esto. Simplemente
	  <emphasis>global-f</emphasis> y <keycap>Tab</keycap>. </para>
      </section>

      <section>
	<title>¡Quiero ver lo que estoy seleccionando!</title>
	<para>Otra característica estándar molesta de <productname>Emacs</productname> es la
	imposibilidad de ver lo que se está seleccionando. <productname>Emacs</productname> trae
	el modo mark desactivado por defecto, así que lo deberemos
	activar con:</para>
	<para><prompt>M-x transient-mark-mode</prompt></para>
      </section>

      <section>
	<title>¡Dios mío! ¿Cómo hago para desactivar el estúpido ajuste
	de línea?</title>
	<para>En lo personal, ésta fue la cosa más molesta de
	<productname>Emacs</productname>. Es decir, hay muchas situaciones en las que, le guste o
	no al estándar de codificación GNU, hay que ir más allá del
	margen derecho. Bueno, ellos han hecho bastante difícil el
	desactivar esta opción estúpida, pero he aquí lo que hay que
	hacer:</para>
	<para><prompt>M-x hscroll-mode</prompt></para>
	<para>Sin embargo, esto no termina aquí, y lo siguiente no
	será tan trivial. Se deberá cambiar al búfer *scratch* (lo
	  cual se podrá hacer seleccionando el menú 
	    <guimenu>Buffers</guimenu> y luego click en *scratch*). Éste es
	un búfer de evaluación de expresiones Lisp (lo que quiere
	decir que simplemente, el modo principal por defecto de este
	búfer es para evaluaciones Lisp, lo cual se puede ver en la
	línea de estado). Ahora, escríbase la línea
	</para>
	<para><prompt> (setq-default truncate-lines 1)</prompt></para>
	<para>seguida de <keycap>C-j</keycap>. Esto ejecutará la línea
	de código Lisp. </para>
      </section>

      <section>
	<title>Guardando nuestras personalizaciones. </title>
	<para>Lo que se debe hacer es crear un archivo llamado
	  <filename>.emacs</filename> en nuestro directorio
	<filename>home</filename>. Éste será ejecutado cada vez que
	<productname>Emacs</productname> se inicie. He aquí cómo luce mi archivo <filename>.emacs</filename>:</para>
<programlisting>(global-font-lock-mode)
(transient-mark-mode 1)
(hscroll-mode)
(setq-default truncate-lines 1)	</programlisting>
      </section>

    </section>

  </section>




  <section>
    <title>Más allá de Hola Mundo</title>
    <para>Hasta aquí hemos visto las características básicas de la
    edición estructurada usando <productname>Emacs</productname>. Sin embargo, hay mucho, pero
    mucho más que ver. He aquí algunos bonitos trucos y sugerencias
    que van a hacer nuestra vida como autores de documentación mucho
    más fácil. </para>

    <section>
      <title>Dividir nuestros documentos en diferentes
      archivos. </title>
      <para>Una de las principales ventajas del Formateo de Textos
      sobre la Edición de Textos, es la habilidad de trabajar en
      archivos separados y la flexibilidad a la hora de organizar
      estos archivos de manera personal. Más aún, con la técnica de
      Formatear Textos se puede ser tan flexible con nuestra
      documentación, como lo somos a la hora de organizar nuestros
      archivos fuentes cuando programamos. </para>

      <para>Las Entidades deben ser declaradas en la declaración
      DOCTYPE al principio del documento. Una declaración típica es
      como la siguiente: </para>

<programlisting>&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook V4.1//EN" [
&lt;!ENTITY presDeLaCompania SYSTEM "presDeLaCompania.sgml"> ]></programlisting>

      <para>Como se puede deducir del ejemplo anterior, las entidades
	son declaradas dentro de los paréntesis rectos []. Además,
	puede verse que existe un identificador de sistema para la
	entidad, de manera que el analizador sintáctico pueda encontrar el
	archivo cuando procese el documento principal. El nombre de la
	entidad, además de identificarla dentro del documento, puede
	tener cualquier nombre que deseemos. Personalmente, en el
	ejemplo, traté de mantener el mismo nombre entre el de la
	entidad y el identificador del sistema, pero esto no es un
	requisito. </para>
      <para>Para usar nuestra entidad, sólo deberemos usar el signo &amp; y su
	nombre, por ejemplo:</para>

      <programlisting> &amp;presDeLaCompania;</programlisting>

      <important>
	<para>Cuando trabajamos con entidades, no se puede incluir una declaración
	DOCTYPE en la misma. Esto hace que a <productname>Emacs</productname> le sea imposible
	saber cómo validar el documento. He encontrado una
	alternativa para superar esto y es explicada abajo. </para>
      </important>

    </section>

    <section>
      <title>Validar nuestros documentos</title>
      <para>Como se verá al correr de esta sección, <productname>Emacs/PSGML</productname> no
      sólo nos ayudará a editar documentos <acronym>SGML</acronym>, sino que
      también nos ayudará a validar documentos en cualquier momento
      que nos encontremos editándolos. Esta es una característica
      estándar pura de <productname>Emacs</productname> (no de <acronym>PSGML</acronym>), gracias a la cual
      aprenderemos a valorar la edición estructurada en dicho editor
      de textos. </para>

      <section>
	<title>Validar un documento simple</title>
	<para>En cualquier punto del documento, simplemente
	  presionando <keycap>C-c C-v</keycap> se podrá ver la orden
	<emphasis>nsgmls</emphasis> en el mini-búfer. Presionando
	enter, podremos validar nuestro documento actual. Tanto si
	ocurre un error en la validación, como si salió todo bien,
	seremos notificados en una división de la pantalla, por debajo
	del mini-búfer. </para>
	<para>Algo útil con respecto a esto es saber que, si hacemos
	click en uno de los errores y luego enter, nos veremos
	desplazados justo a la línea donde se encontró el error. Es
	más, si el error está en otros archivo que el actual, <productname>Emacs</productname> lo
	abrirá automáticamente y ¡nos hará saltar a donde supuestamente
	se encuentra el error! Ésta es una funcionalidad estándar de
	<productname>Emacs</productname> en integración con algunas otras herramientas de
	  nuestro sistema. Es el mismo caso que
	  <command>gdb</command>,
	  <command>make</command> o un compilador
	<productname>java</productname>. Así de simple. </para>
      </section>

      <section>
	<title>Validar partes (entidades) de un documento</title>
	<para>El principal problema con la división del documento en
	  partes separadas en archivos, o
	<emphasis>entidades</emphasis> 
	  que es como se las denomina en <acronym>SGML</acronym>, es que no podemos tener
	una declaración DOCTYPE en cualquiera de estas partes. Si lo
	hiciéramos así, <productname>Emacs</productname> no tendría forma de saber dónde buscar
	la <acronym>DTD</acronym>. He aquí lo que yo hago para solucionar este problema:
	</para>
	<orderedlist>
	  <listitem id="parte1">
	    <para>Ir al documento principal, (aquel que tiene la
	      declaración DOCTYPE) e ir al menú <guimenu>DTD -> Save
		Parsed DTD</guimenu>. Dar aquí un nombre simple como
	      <filename>docbook.ced</filename> o
	      <filename>main.ced</filename>. Sería bueno almacenar
	      este archivo en el mismo directorio en el que
	      almacenamos nuestro documento principal. 
	    </para>
 	  </listitem>
	  <listitem>
	    <para>Al abrir la parte del documento, obtendremos el
	      error <literal>External entity XXXXXX not
		found</literal>, donde <literal>XXXXXX</literal> es el
	      nombre de la primera etiqueta que se encontró. Ignórese
	      esto y presiónese <keycap>C-x 1</keycap> para maximizar
	      el cuadro en el que trabajaremos. Selecciónese el menú
	      <guimenu>DTD->Load Parsed DTD</guimenu> y sustitúyase
	      <filename>filename.ced</filename> por
	      <filename>main.ced</filename> (o por el nombre que le
	      hallamos dado al archivo en <xref linkend="parte1">). </para>
	  </listitem>
	</orderedlist>
	<para>Y ¡eso es todo!  Ahora podremos trabajar con dicha parte
	del documento en <productname>Emacs</productname> de igual forma que como lo veníamos
	haciendo con nuestro documento principal. </para>
      </section>
    </section>


    <section>
      <title>Manteniendo nuestros documentos bonitos</title>
      <para>En esta sección se hablará sobre el correcto sangrado y
      justificación de nuestros <productname>Docbook</productname>. Para esto usaremos algunos
      modos principales de <productname>Emacs</productname> y el propio modo principal
      <acronym>PSGML</acronym>. </para>

      <section>
	<title>La Tecla Tab</title>
	<para>A diferencia de cualquier otro editor que yo haya visto
	  antes, la tecla <keycap>Tab</keycap> se comporta de un modo
	sorprendentemente inteligente en <productname>Emacs</productname>. Por ejemplo, si nos
	encontramos en un modo principal distinto al modo de texto
	  puro, al presionar la tecla <keycap>Tab</keycap> en
	cualquier parte del documento, esto hará que la línea en la
	cual estamos posicionados sangre correctamente, mientras que
	en cualquier otro editor de textos lo anterior quebrará la
	línea en dos.  </para>
      </section>

      <section>
	<title>Sangrar una región </title>
	<para>Como modo de ejemplo, supóngase que en <xref
	linkend="ejemplo1"> hemos decidido que nuestra Sect2 sea ahora
	una Sect1 y queremos hacerla sangrar apropiadamente. He
	aquí como  hacer tal cosa:</para>
	<orderedlist>
	  <listitem>
	    <para>Selecciónese la región (<keycap>C-space</keycap>
	    activa el bloque de la selección) y reemplácense las
	    etiquetas. Si estamos sangrando para afuera una región
	    deberíamos empezar a buscar y reemplazar empezando por las
	    etiquetas exteriores. Si, por el contrario, estamos
	    sangrando hacia adentro, deberíamos hacer lo contrario. </para>
	  </listitem>
	  <listitem>
	    <para>Una vez que las etiquetas tengan los nombres
	    correctos, <productname>Emacs</productname> debería ser capaz de realizar el sangrado
	    de la región automáticamente. Para ello, simplemente
	      selecciónese la región nuevamente y presiónese
	    <command>M-x indent-region</command> y Voilà!</para>
	  </listitem>
	</orderedlist>
      </section>

      <section>
	<title>Otros detalles sobre el sangrado</title>
	<para>
	  En esta sección se discutirán aspectos que involucran
	  cuestiones de estilo y claridad en el código. Personalmente,
	  en algunos casos prefiero que las líneas de
	  <emphasis>CDATA</emphasis> (los caracteres de datos) estén
	  entre las líneas que ocupan las etiquetas, y no que estas
	  últimas estén al principio y al final de CDATA, en las
	  mismas líneas. Los párrafos son ejemplos perfectos de esto: 
	</para>

<programlisting>&lt;para>
  En esta sección se discutirán aspectos que involucran
  cuestiones de estilo y claridad en el código. Personalmente,
  en algunos casos prefiero que las líneas de
  <emphasis>CDATA</emphasis> (los caracteres de datos) estén
  entre las líneas que ocupan las etiquetas, y no que estas
  últimas estén al principio y al final de CDATA, en las
  mismas líneas. Los párrafos son ejemplos perfectos de esto:
&lt;/para>	</programlisting>

	<para>versus</para>

<programlisting>&lt;para>En esta sección se discutirán aspectos que involucran
cuestiones de estilo y claridad en el código. Personalmente,
en algunos casos prefiero que las líneas de
<emphasis>CDATA</emphasis> (los caracteres de datos) estén
entre las líneas que ocupan las etiquetas, y no que estas
últimas estén al principio y al final de CDATA, en las
mismas líneas. Los párrafos son ejemplos perfectos de
esto. &lt;/para></programlisting>

	<para>Téngase presente que para el sangrado de una región, <productname>Emacs</productname>
	seguirá el sangrado de la primera línea y a partir de este,
	alineará todas las demás. Luego, deberemos tener correctamente
	hecho el sangrado de las líneas superiores para que
	en las líneas inferiores sea correcto. </para>
      </section>

    </section>

    <section>
      <title>Ortografía</title>
      <para>Dado que <productname>Emacs</productname> se integra pacíficamente con
      el sistema operativo y sus herramientas, también lo hace con
      <productname>Ispell</productname> y
      <productname>spell</productname>. Esta integración puede ser
      <emphasis>ad-hoc</emphasis> activando el modo principal Ispell o
      puede ser ejecutado en un modo secundario. Esta última manera de
      funcionar es análoga al subrayado rojo que se presenta en las
      faltas ortográficas de los documentos en Ms Word. He aquí
      algunas pistas:</para>
      <itemizedlist>
	<listitem>
	  <para>Para revisar ortográficamente un documento, presiónese
	  <keycap>M-x ispell</keycap>. </para>
	</listitem>
	<listitem>
	  <para>Para cambiar el diccionario presiónese <keycap>M-x
	  ispell-change-dictionary</keycap>. (Pueden verse los
	  diccionarios disponibles de Ispell en
	  <filename>/usr/lib/ispell</filename>. </para>
	</listitem>
	<listitem>
	  <para>Para activar el modo secundario de Ispell,
	  simplemente presiónese <keycap>M-x flyspell-mode</keycap>. </para>
	</listitem>
	<listitem>
	  <para>Si se tiene activado el modo secundario Ispell y se
	  escucha un beep, esto significa que se ha cometido un error
	  ortográfico en alguna palabra. Para corregirlo, deténgase la
	  edición inmediatamente y presiónese <keycap>M-$</keycap>. De esta
	  forma se verán algunas opciones en la parte superior de la
	  pantalla, igual que en el modo principal de Ispell!</para>
	</listitem>
      </itemizedlist>
 
    </section>


    <section>
      <title>Formatos y Gráficos</title>
      <para>Si bien los documentos <acronym>SGML</acronym> pueden ser limpiamente
      convertidos a otros muchos formatos, hay un par de
      consideraciones que hacer si vamos a convertir documentos <acronym>SGML</acronym>
      que involucren algún otro tipo de dato que no sea texto. Para
      explicar esto, supongamos que estamos manteniendo un documento
      <acronym>SGML</acronym> el cual será distribuido en dos formatos básicos:
      PostScript y <acronym>HTML</acronym>. Si el documento no tiene gráficos no habrá
      problemas serios al realizar las conversiones. Sin embargo, si
      los tiene hay que tener en cuenta dos características de los
      mismos: su tamaño y su formato. En primer lugar tomemos como
      ejemplo una captura de pantalla de 800x600: la misma podrá
      mostrarse sin problemas en un archivo <acronym>HTML</acronym>, pero no entrará en
      una hoja A4 en un archivo <acronym>PS</acronym> o <acronym>PDF</acronym>. El problema con los formatos
      es un poco más complicado. Por ejemplo, debemos tener en cuenta
      que en un archivo <acronym>HTML</acronym> no podremos mostrar un imagen <acronym>EPS</acronym>
      directamente, así como también, en un archivo PostScript no podremos
      mostrar una imagen <acronym>PNG</acronym>. </para>
      <para>Probablemente haya una manera de corregir esta clase de
      limitaciones en los documentos <acronym>SGML</acronym> que involucren algún tipo de
      programa preprocesador, o algo parecido. Sin embargo no estoy
      enterado de la existencia de algo parecido. Cuando encuentre la
      herramienta apropiada, probablemente actualice esta sección del
      documento. Así y todo, he encontrado un procedimiento simple que
      simplifica la solución de este problema de formatos: </para>
      <itemizedlist>
	<listitem>
	  <para>Créese un subdirectorio llamado
	  <filename>graphic</filename> en el cual guardaremos todas
	  nuestras imágenes. En dicho subdirectorio, créense otros
	  subdirectorios uno para cada tipo de formato. Por ejemplo,
	  en mi caso, trabajo con Gimp y publico mis trabajos tanto en
	  PostScript como en <acronym>HTML</acronym> por lo que tengo tres de estos
	  subdirectorios: <filename>XCF</filename>
	    <footnote>
	      <para>XCF - Formato Nativo de Gimp. </para>
	    </footnote>,
	  <filename>EPS</filename> y <filename>PNG</filename>. </para>
	</listitem>
	<listitem>
	  <para>Cuando creemos un gráfico, guardémoslo en los
	  diferentes formatos en cada subdirectorio. Para los formatos
	  <acronym>XCF</acronym> y <acronym>EPS</acronym> guardemos los archivos con extensión, pero
	  guardemos los archivos <acronym>PNG</acronym> sin extensión.</para>
	</listitem>
	<listitem>
	  <para>Si en nuestro documento no especificamos el tipo de
	  archivo, cada rutina de conversión esperará una extensión
	  diferente para las imágenes; excepto por la conversión a
	  <acronym>HTML</acronym> la cual tomará el nombre del archivo literalmente. Es
	  por esto que en el punto anterior pedí que se guardaran los
	  archivos <acronym>PNG</acronym> sin extensión. De todos modos, el explorador de
	  páginas <acronym>HTML</acronym> a usar debería ser capaz de determinar el tipo
	  de archivo. He aquí un ejemplo para insertar una captura de
	  pantalla:</para>
<programlisting>&lt;screenshot>
  &lt;screeninfo><productname>Emacs</productname> 21 Graphical Menus in X&lt;/screeninfo>
    &lt;graphic fileref="graphic/emacs-21-menu-grafico">&lt;/graphic>
&lt;/screenshot></programlisting>
	</listitem>
	<listitem>
	  <para>Antes de ejecutar la herramienta para la conversión de
	  <acronym>SGML</acronym> a otro formato, nos debemos asegurar de tener los
	    archivos de tipo correcto en el directorio
	  <filename>graphic</filename>. Por ejemplo, la conversión a formato
	  PostScript esperará que en dicho directorio halla archivos
	  <acronym>EPS</acronym>. Así, no tendremos que modificar la declaración de cada
	    etiqueta <sgmltag>graphic</sgmltag> para cada conversión. </para>
	</listitem>
	<listitem>
	  <para>Dado que nuestros archivos <acronym>PNG</acronym> no tienen extensión, el
	  parámetro IMG en el archivo <acronym>HTML</acronym> tendrá la misma ruta y
	  nombre de archivo que su ancestro <acronym>SGML</acronym>. </para>
	</listitem>
      </itemizedlist>

    </section>


    <section>
      <title>Referencias Cruzadas, Enlaces y URLs</title>
      <para>Cada elemento <acronym>SGML</acronym> puede tener un ID<footnote>
	  <para>que vendría a ser como un acrónimo de IDentificador. </para>
	</footnote>
	definido por el usuario. Este ID nos permite hacer referencia
	al elemento con diferentes propósitos y obtener una salida más coqueta en
	algunos tipos de archivo que soporten ciertas
	características. Un ejemplo de esto último puede ser el
	siguiente. Si estamos publicando nuestros documentos en
	archivos <acronym>HTML</acronym> u otro tipo de archivos que soporten
	hiperenlaces, puede ser últil publicar enlaces dentro del
	documento que apunten a otras partes del mismo. Estos enlaces
	pueden ser declarados de diferentes maneras en los documentos
	<productname>Docbook</productname> y en esta sección se darán algunas características que
	he encontrado dignas de relatar. </para>

      <section>
	<title>XRef</title>
	<para>He encontrado a <sgmltag>XRef</sgmltag> muy versátil
	dado que trabaja de igual forma en publicaciones para la
	impresión (PostScript) como en publicaciones <acronym>HTML</acronym>. La única
	diferencia es que en este último formato agrega el
	hipervínculo. </para>
	<para>Para usar <sgmltag>XRef</sgmltag> se debe, primero que
	nada, identificar el nodo objetivo del vínculo (o sea, aquella
	cosa a la cual vamos a apuntar). Para esto, simplemente
	deberemos ir a la etiqueta de apertura del elemento que
	  queremos identificar, teclear <keycap>C-c +</keycap> y
	  seleccionar <sgmltag>ID</sgmltag>. Luego deberemos
	introducir el nombre:</para>
<programlisting>&lt;sect1 id="lfpt">
   &lt;title>La Fantasía de los Procesadores de Texto&lt;/title></programlisting>
	<para>A partir de ahora, en cualquier lugar podremos hacer
	referencia a la sección del ejemplo anterior, utilizando su ID
	de la forma:</para>
<programlisting>los cuales fueron listados en &lt;xref linkend="lfpt"></programlisting>
      </section>

      <section>
	<title>URL</title>
	<para>Para declarar una URL el procedimiento es bastante
	  trivial. Simplemente debe usarse el elemento
	<sgmltag>ULink</sgmltag> de modo análogo a como se hace en el
	siguiente ejemplo: </para>
<programlisting>&lt;para>
   &lt;ulink url="http://xml.coverpages.org/general.html#faq">
      http://xml.coverpages.org/general.html#faq
  &lt;/ulink>
&lt;/para></programlisting>

      </section>


    </section>      

    
    
    <section>
      <title>Otros trucos bonitos</title>
      <para>Aquí cubriré otras características bonitas que he
	descubierto gracias al uso de <productname>Emacs</productname> y el módulo <acronym>PSGML</acronym>. Esta
	sección crecerá con el tiempo, por lo que el lector debería
	mantenerse en línea.... </para>
    

      <section>
	<title>Etiquetado no planeado</title>
	<para>No he podido encontrar un mejor título para esta sección
	por lo que los lectores tendrán que soportar éste. Supóngase
	que se está realizando la corrección de un documento ya
	terminado y se decide enfatizar palabras que no lo están. Si
	  se usa <keycap>C-c C-e</keycap> se terminará con una
	etiqueta de apertura seguida de una etiqueta de fin pero con
	nada en el medio. Sin lugar a dudas, esto no es lo que
	  queremos. En este caso se podrá usar <keycap>C-&lt;</keycap>
	lo cual nos dejará elegir una etiqueta, pero sólo insertará la
	de apertura. Cuando se quiera cerrar dicho elemento, se podrá
	  presionar <keycap>C-/</keycap> ¡lo cual insertará
	automáticamente en ese lugar la etiqueta de fin!</para>
      </section>

      <section>
	<title>Parámetros de las Etiquetas</title>
	<para>Cuando escribimos en <productname>Docbook</productname> o en <acronym>HTML</acronym>,
	podemos ver que las etiquetas aceptan gran variedad de
	parámetros diferentes, los cuales pueden ser muy difíciles de
	recordar de memoria, o hasta pueden tener valores por defecto.
	En estos casos, lo que puede hacerse es, ubicando el cursor en
	  cualquier parte de una etiqueta de abertura, presionar
	  <keycap>C-c +</keycap>. Esto hará que se abra una lista de
	parámetros válidos en dicha etiqueta y hasta se podrán ver los
	valores permitidos para cada uno de estos parámetros, si es
	que han sido definidos. Encuentro esta característica
	sorprendente y esencial para cualquier edición que involucre
	etiquetas. Lo que quiero decir, es que ya no necesitaremos
	tener al lado alguna referencia al lenguaje <acronym>HTML</acronym> o <productname>Docbook</productname>
	al editar documentos en tales formatos, ya que la mayoría de
	la información de los parámetros de una etiqueta la podremos
	obtener con la órden anterior y el autocompletado. De todos
	modos, esto no es excusa para no aprender el lenguaje estándar
	de etiquetas con el cual se trabaje, pero sí sirve para no
	tener que acordarnos de memoria de estas características de menor
	importancia. </para>
      </section>  

    </section>
    
  </section>



  <section>
    <title>Sobre este artículo</title>
    <note>
      <para>
	Las direcciones de correos electrónicos que siguen están levemente
	modificadas para evitar SPAM.      </para>
    </note>
  
    <section>
      <title>Sobre el autor</title>
      <para>El nombre del autor de este documento es Alejandro Imass, 
	(<ulink
	  url="http://bios.linuxguru.net/view/ait">ait</ulink>). Se le
	puede encontrar en <ulink url="mailto:ait@  tariffi.net">esta
	  dirección</ulink> de correo electrónico y en su <ulink
	  url="http://www.tariffi.net/~ait">página web</ulink> se podrán encontrar más
	detalles sobre él. Su ubicación actual es Guatire, Miranda,
	Venezuela y es inventor. Escribió este artículo el 12
	de Noviembre de 2002. 
      </para>
    </section>
    <section>
      <title>Sobre la traducción al español</title>
      <para>La traducción al español de este documento fue llevada a
	cabo por Sebastián Gurin (Cancerbero) a quien se lo puede
	encontrar mandándole un correo electrónico a <ulink url="mailto:cancerbero_sgx@
	  users.sourceforge.net">su dirección</ulink>. </para>
      <para>Como todo trabajo humano, la traducción debe tener errores,
	por lo que el traductor ruega recibir
	comentarios, sugerencias, retos, etc, de los lectores
	hispanoparlantes que lean este documento.  </para>

    </section>
  </section>







</article>
