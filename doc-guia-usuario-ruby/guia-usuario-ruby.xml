<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
              "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book lang="es">
<bookinfo>
  <title> Guía del usuario de Ruby </title>
    <author>
    <firstname> matz </firstname>
    </author>
</bookinfo>
<preface>
  <title> Contenidos </title>
  <para>
  Ruby es <quote>un lenguaje de programación orientado a objetos sencillo</quote>. Al principio puede parecer un poco extraño, pero se ha diseñado para que sea fácil de leer y escribir. Esta <emphasis> Guía del usuario de Ruby
  </emphasis> permite ejecutar y utilizar Ruby y proporciona una visión de la naturaleza de Ruby que no se 
  puede obtener del manual de referencia.
  </para>
</preface>
<chapter>
  <title> ¿Qué es Ruby? </title>
<para>
  Ruby es un <quote>lenguaje de guiones (scripts) para una programación orientada a objetos rápida y sencilla</quote>. ¿Qué significa esto?
</para>
<highlights>
<para>
Lenguaje de guiones interpretado:
<itemizedlist mark="bullet">
<listitem><para>
Posibilidad de realizar directamente llamadas al sistema operativo
</para></listitem>
<listitem><para>
Potentes operaciones sobre cadenas de caracteres y expresiones regulares
</para></listitem>
<listitem><para>
Retroalimentación inmediata durante el proceso de desarrollo
</para></listitem>
</itemizedlist>
</para>
<para>
Rápido y sencillo:
<itemizedlist mark="bullet">
<listitem><para>
Son innecesarias las declaraciones de variables
</para></listitem>
<listitem><para>
Las variables no tienen tipo
</para></listitem>
<listitem><para>
La sintaxis es simple y consistente
</para></listitem>
<listitem><para>
La gestión de la memoria es automática
</para></listitem>
</itemizedlist>
</para>
<para>
Programación orientada a objetos:
<itemizedlist mark="bullet">
<listitem><para>
Todo es un objeto
</para></listitem>
<listitem><para>
Clases, herencia, métodos, ...
</para></listitem>
<listitem><para>
Métodos singleton
</para></listitem>
<listitem><para>
Mixins por módulos
</para></listitem>
<listitem><para>
Iteradores y cierres
</para></listitem>
</itemizedlist>
</para>
<para>
También:
<itemizedlist mark="bullet">
<listitem><para>
Enteros de precisión múltiple
</para></listitem>
<listitem><para>
Modelo de procesamiento de excepciones
</para></listitem>
<listitem><para>
Carga dinámica
</para></listitem>
<listitem><para>
Hilos
</para></listitem>
</itemizedlist>
</para>
</highlights>
<para>
Si no estás familiarizado con alguno de los términos anteriores, continúa leyendo y no te preocupes. El mantra de Ruby es <emphasis> Rápido y Sencillo </emphasis>.
</para>
</chapter>
<chapter> <title>Inicio</title>
<para>
Inicialmente hay que comprobar si se tiene instalado Ruby. Desde la línea de petición de comandos de la shell (aquí la representaremos por <quote>%</quote>, por lo tanto no introducir el % de los ejemplos), tecleamos:
<informalexample>
<programlisting>
  % ruby -v
</programlisting>
</informalexample>
(<command>-v</command> le indica al intérprete que imprima la versión de Ruby), a continuación pulsamos la tecla <keysym>Enter</keysym>. Si está instalado Ruby, aparecerá el siguiente mensaje o algo similar:
<informalexample>
<programlisting>
  % ruby -v
  ruby 1.6.3 (2001-11-23) [i586-linux]
</programlisting>
</informalexample>
Si no está instalado, pide a tu administrador que lo instale, o hazlo tú mismo dado que Ruby es software libre sin restricciones de instalación o uso.
</para>
<para>
Comencemos ahora a jugar con Ruby. Se puede introducir directamente en la línea de comandos un programa Ruby utilizando la opción <command>-e</command>:
<informalexample>
<programlisting>
% ruby -e 'print "hola mundo\n"'
hola mundo
</programlisting>
</informalexample>
Un programa Ruby se puede almacenar en un fichero, lo que es mucho más adecuado.
<informalexample>
<programlisting>
% cat > test.rb
print "hola mundo\n"
^D
% cat test.rb
print "hola mundo\n"
%ruby test.rb
hola mundo
</programlisting>
</informalexample>
<keysym>^D</keysym> es <emphasis>control-D</emphasis>. Lo anterior es válido para <productname>UNIX</productname>. Si se está utilizando <productname>DOS</productname>, prueba con:
<informalexample>
<programlisting>
C:\ruby> copy con: test.rb
print "hola mundo\n"
^Z
C:\ruby> type test.rb
print "hola mundo\n"
c:\ruby> ruby test.rb
hola mundo
</programlisting>
</informalexample>
Al escribir código con más fundamento que éste, ¡se puede utilizar cualquier editor!.
</para>
<para>
Algunas cosas sorprendentemente complejas y útiles se pueden hacer con programas miniatura que caben en la línea de comandos. Por ejemplo, el siguiente programa reemplaza la cadena <command>foo</command> por <command>bar</command> en todos los ficheros cabecera y fuentes C del directorio de trabajo, realizando una copia de seguridad del fichero original a la que añade <quote>.bak</quote>
<informalexample>
<programlisting>
% ruby -i .bak -pe 'sub "foo", "bar"' *.[ch]
</programlisting>
</informalexample>
El siguiente programa funciona como el comando <command>cat</command> de <productname>UNIX</productname> (aunque es más lento):
<informalexample>
<programlisting>
% ruby -pe 0 file
</programlisting>
</informalexample>
</para>
</chapter>
<chapter><title>Ejemplos sencillos</title>
<para>
Escribamos una función que calcula factoriales. La definición matemática de factorial es la siguiente:
<blockquote>
<para>(n==0)  n! = 1</para>
<para>(sino)  n! = n * (n-1)!</para>
</blockquote>
</para>
<para>
En Ruby se puede escribir así:
<informalexample>
<programlisting>
def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end
</programlisting>
</informalexample>
Se puede apreciar la aparición repetida de <command>end</command>. Debido a esto a Ruby se le conoce como un lenguaje <quote>tipo Algol</quote>. (Realmente la sintaxis de Ruby reproduce con más exactitud la del lenguaje Eiffel). También se puede apreciar la falta de la sentencia <command>return</command>. Es innecesaria debido a que una función Ruby devuelve lo último que haya evaluado. La utilización de <command>return</command> es factible aunque innecesaria.
</para>

<para>
Probemos la función factorial. Añadiendo una línea de código obtenemos un programa funcional:
<informalexample>
<programlisting>
# Programa para hallar el factorial de un número
# Guarda este programa como fact.rb

def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end

print fact(ARGV[0].to_i), "\n"
</programlisting>
</informalexample>
Aquí, <command>ARGV</command> es un array que contiene los parámetros de la línea de comandos y <command>to_i</command> convierte una cadena de caracteres a un entero.
<informalexample>
<programlisting>
% ruby fact.rb 1
1
% ruby fact.rb 5
120
</programlisting>
</informalexample>
¿Funcionaría con un parámetro igual a 40? Este valor podría provocar un desbordamiento en una calculadora...
<informalexample>
<programlisting>
% ruby fact.rb 40
815915283247897734345611269596115894272000000000
</programlisting>
</informalexample>
Funciona. Además Ruby puede tratar cualquier entero que quepa en la memoria del ordenador. ¡Por lo que se puede calcular el factorial de 400!:
<informalexample>
<programlisting>
% ruby fact.rb 400
640345228466238952623479703195030058507025830260029594586844459428023971691868314
362784786474632646762943505750358568108482981628835174352289619886468029979373416
541508381624264619423523070462443250151144486708906627739149181173319559964407095
496713452904770203224349112107975932807951015453726672516278778900093497637657103
263503315339653498683868313393520243737881577867915063118587026182701698197400629
830253085912983461622723045583395207596115053022360868104332972551948526744322324
386699484224042325998055516106359423769613992319171340638589965379701478272066063
202173794720103213566246138090779423045973606995675958360961587151299138222865785
795493616176544804532220078258184008484364155912294542753848035583745180226759000
613995601455952061272111929181050324910080000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000
</programlisting>
</informalexample>
No podemos verificar su validez a simple vista, pero lo debe ser ;-).
</para>
<sect1><title>El bucle de entrada/evaluación</title>
<para>
Al ejecutar Ruby sin parámetros, éste lee de la entrada estándar comandos y los ejecuta después de dar por finalizada la entrada:
<informalexample>
<programlisting>
% ruby
print "hola mundo\n"
print "adiós mundo\n"
^D
hola mundo
adiós mundo
</programlisting>
</informalexample>
Ruby incluye un programa llamado <command>eval.rb</command> que permite la introducción de código desde el teclado a través de un bucle iterativo que muestra los resultados a medida que se obtienen. Se utilizará ampliamente a lo largo del tutorial.
</para>
<para>
Si se tiene un terminal <acronym>ANSI</acronym> (esto será casi seguro si se está ejecutando alguna versión de <productname>UNIX</productname>; bajo <productname>DOS</productname> se debe instalar <command>ANSI.SYS</command> o <command>ANSI.COM</command>) se debería utilizar este <command>eval.rb</command> mejorado que permite autoindentación, informes sobre incidencias y resaltado por color. Si no, en el directorio <command>sample</command> de la distribución Ruby existe una versión no <acronym>ANSI</acronym> que funciona con cualquier terminal. A continuación se muestra una pequeña sesión con <command>eval.rb</command>:
<informalexample>
<programlisting>
%ruby eval.rb
ruby&gt; print "hola mundo\n"
hola mundo.
  nil
ruby&gt; exit 
</programlisting>
</informalexample>
<command>print</command> produce <emphasis>hola mundo</emphasis>. La siguiente línea, es este caso <emphasis>nil</emphasis> informa sobre lo último que se ha evaluado; Ruby no distingue entre <emphasis>sentencias</emphasis> y <emphasis>expresiones</emphasis>, por lo tanto la evaluación de una pieza de código significa básicamente lo mismo que ejecutarla. Aquí <emphasis>nil</emphasis>, indica que <emphasis>print</emphasis> no devuelve ningún valor significativo. Obsérvese que se puede salir del bucle de interpretación con <emphasis>exit</emphasis>, aunque también funciona <emphasis>^D</emphasis>.
</para>
<para>
A lo largo de toda esta introducción <command>ruby></command> representa la petición de entrada del pequeño pero útil programa <command>eval.rb</command>.
</para>
</sect1>
</chapter>
<chapter>
  <title> Cadenas </title>
  <para> 
    Ruby maneja tanto cadenas como datos numéricos. Las cadenas pueden estar entre comillas dobles("...") o comillas simples ('...').
<informalexample>
<programlisting>
ruby> "abc"
"abc"
ruby> 'abc'
"abc"
</programlisting>
</informalexample>
Las comillas simples y dobles a veces tienen efectos diferentes. Una cadena de comillas dobles permite la presencia embebida de caracteres de escape precedidos por un backslash y la expresión de evaluación #{ }. Una cadena de comillas simples no realiza esta evaluación, lo que se ve es lo que se obtiene. Ejemplos:
<informalexample>
<programlisting>
ruby> print "a\nb\nc","\n"
a
b
c
nil
ruby> print 'a\nb\nc',"\n"
a\nb\nc
nil
ruby> "\n"
"\n"
ruby> '\n'
"\\n"
ruby> "\001"
"\001"
ruby> '\001'
"\\001"
ruby> "abcd #{5*3} efg"
"abcd 15 efg"
ruby> var = " abc "
" abc "
ruby> "1234#{var}5678"
"1234 abc 5678"
</programlisting>
</informalexample>
El manejo de las cadenas en Ruby es más inteligente e intuitivo que en C. Por ejemplo, se pueden concatenar cadenas con + y se puede repetir una cadena varias veces con *:
<informalexample>
<programlisting>
ruby> "foo" + "bar"
"foobar"
ruby> "foo" * 2
"foofoo"
</programlisting>
</informalexample>
La concatenación de cadenas en C es más incómoda debido a la necesidad de una gestión explícita de la memoria:
<informalexample>
<programlisting>
char *s = malloc(strlen(s1)+strlen(s2) +1);
strcpy(s, s1);
strcat(s, s2);
/* ... */
free(s);
</programlisting>
</informalexample>
Ya que al usar Ruby no tenemos que considerar el espacio que va a ocupar una cadena, estamos liberados de la gestión de la memoria.
  </para>
<para>
A continuación se muestran algunas cosas que se pueden hacer con las cadenas.
</para>
<para>
Concatenación:
<informalexample>
<programlisting>
ruby> word = "fo" + "o"
"foo"
</programlisting>
</informalexample>
Repetición:
<informalexample>
<programlisting>
ruby> word = word * 2
"foofoo"
</programlisting>
</informalexample>
Extracción de caracteres (obsérvese que los caracteres en Ruby son enteros):
<informalexample>
<programlisting>
ruby> word[0]
102             # 102 es el código ASCII de 'f'
ruby> word[-1]
111             # 111 es el código ASCII de 'o'
</programlisting>
</informalexample>
</para>
<para>
(Los índices negativos indican desplazamientos desde el final de la cadena, en vez del comienzo).
</para>
<para>
Extracción de  subcadenas:
<informalexample>
<programlisting>
ruby> herb = "parsley"
"parsley"
ruby> herb[0,1]
"p"
ruby> herb[-2,2]
"ey"
ruby> herb[0..3]
"pars"
ruby> herb[-5..-2]
"rsle"
</programlisting>
</informalexample>
Verificación de la igualdad:
<informalexample>
<programlisting>
ruby> "foo" == "foo"
true
ruby> "foo" == "bar"
false
</programlisting>
</informalexample>
Pongamos ahora alguna de estas características en uso. Este acertijo es "Adivina la palabra", aunque tal vez la palabra "acertijo" es demasiado elevada para lo que viene ;-).
<informalexample>
<programlisting>
# Salvar como guess.rb
words = ['foobar', 'baz', 'quux']
secret = words[rand(3)]

print "adivina? "
while guess = STDIN.gets
  guess.chop!
  if guess == secret
    print "¡Ganas!\n"
    break
  else
    print "Lo siento. Pierdes\n"
  end
  print "adivina? "
end
print "La palabra era ", secret, ".\n"
</programlisting>
</informalexample>
Por el momento no te preocupes de los detalles del código. A continuación se muestra una ejecución del programa del acertijo.
<informalexample>
<programlisting>
$ ruby guess.rb
adivina? foobar
Lo siento. Pierdes.
adivina? quux
Lo siento. Pierdes.
adivina? ^D 
La palabra era baz.
</programlisting>
</informalexample>
(Debería haberlo hecho mejor dada la probabilidad de 1/3 de acertar).
</para>
</chapter>
<chapter>
<title>Expresiones regulares</title>
<para>
Realicemos un programa mucho más interesante. Es el momento de comprobar si una cadena satisface una descripción, que llamaremos <emphasis>patrón</emphasis>.
</para>
<para>
En estos patrones existen algunos caracteres y combinaciones de caracteres que tienen un significado especial, y son:
</para>
<table frame="all">
  <title> Caracteres especiales en expresiones regulares </title>
  <tgroup cols="2" align="left" colsep="1" rowsep="1">
  <colspec colname="simbolo" colnum="1" colwidth="1*"/>
  <colspec colname="descrip" colnum="2" colwidth="6*"/>
  <thead>
    <row>
    <entry>Símbolo</entry>
    <entry>Descripción></entry>
    </row>
  </thead>
  <tbody>
    <row>
    <entry>[]</entry>
    <entry>Especificación de rango. (p.e. [a-z] representa  una letra en el rango de la <emphasis>a</emphasis> a la <emphasis>z</emphasis></entry>
    </row>
    <row>
    <entry>\w</entry>
    <entry>Letra o dígito; es lo mismo que [0-9A-Za-z]</entry>
    </row>
    <row>
    <entry>\W</entry>
    <entry>Ni letra, ni dígito</entry>
    </row>
    <row>
    <entry>\s</entry>
    <entry>Espacio, es lo mismo que [ \t\n\r\f] </entry>
    </row>
    <row>
    <entry>\S</entry>
    <entry>No espacio</entry>
    </row>
    <row>
    <entry>\d</entry>
    <entry>Dígito; es lo mismo que [0-9]</entry>
    </row>
    <row><entry>\D</entry><entry>No dígito</entry></row>
    <row><entry>\b</entry><entry>Backspace (0x08) (sólo si aparece en una especificación de rango)</entry></row>
    <row><entry>\b</entry><entry>Límite de palabra (sólo si no aparece en una especificación de rango)</entry></row>
    <row><entry>\B</entry><entry>No límite de palabra</entry></row>
    <row><entry>*</entry><entry>Cero o más repeticiones de lo que precede</entry></row>
    <row><entry>+</entry><entry>Una o más repeticiones de lo que precede</entry></row>
    <row><entry>[m,n]</entry><entry>Al menos <emphasis>m</emphasis> y como máximo <emphasis>n</emphasis> de lo que precede </entry></row>
    <row><entry>?</entry><entry>Al menos una repetición de lo que precede; es lo mismo que [0,1]</entry></row>
    <row><entry>|</entry><entry>Puede coincidir con lo que precede o con lo que sigue</entry></row>
    <row><entry>()</entry><entry>Agrupamiento</entry></row>
  </tbody>
  </tgroup>
</table>
<para>El término común para esto patrones que utilizan este extraño vocabulario es <emphasis>expresión regular</emphasis>. En Ruby, como en Perl, normalmente están rodeadas por barras inclinadas en vez de por comillas dobles. Si nunca antes se ha trabajado con expresiones regulares, es probable que parezcan cualquier cosa excepto <emphasis>regulares</emphasis>, pero sería inteligente dedicar algún tiempo a familiarizarse con ellas. Tienen un poder expresivo en su concisión que puede evitar muchos dolores de cabeza (y muchas líneas de código) si se necesita realizar coincidencia de patrones o cualquier otro tipo de manipulación con cadenas de texto. </para>
<para> Por ejemplo, supongamos que queremos comprobar si una cadena se ajusta a esta descripción: <quote>Comienza con una f minúscula, a la que sigue exactamente una letra mayúscula y opcionalmente cualquier cosa detrás de ésta, siempre y cuando no haya más letras minúsculas.</quote> Si se es un experimentado programador en C probablemente se haya escrito este tipo de código docenas de veces, ¿verdad? Admitádmoslo, es difícil mejorarlo. Pero en Ruby sólamente es necesario solicitar que se verifique la cadena contra la siguiente expresión regular <command>/^f[A-Z][^a-z]*$/</command>.</para>
<para>Y que decir de <quote>¿Contiene la cadena un número hexadecimal entre ángulos?</quote> No hay problema.</para>
<informalexample>
<programlisting>
ruby> def chab(s) # contiene la cadena un hexadecinal entre ángulos
ruby|   (s =~ /<0[Xx][\dA-Fa-f]+>/) != nil 
ruby| end 
nil 
ruby> chab "Este no es" 
false 
ruby> chab "¿Puede ser esta? (0x35)" # entre paréntesis, no ángulos 
false 
ruby> chab "¿O esta? <0x38z7e>"  # letra errónea 
false 
ruby> chab "OK esta si; <0xfc0004>" 
true 
</programlisting>
</informalexample>
<para>Aunque inicialmente las expresiones regulares pueden parecer enigmáticas, se gana rápidamente satisfacción al ser capaz de expresarse con tanta economía.</para>
<para>A continuación se presenta un pequeño programa que nos permitirá experimentar con las expresiones regulares. Almacenémoslo como <command>regx.rb</command>, se ejecuta introduciendo en la línea de comandos <command>ruby regx.rb</command></para>
<informalexample>
<programlisting>
# necesita un terminal ANSI!!!
 
st = "\033[7m"
en = "\033[m"
 
while TRUE
  print "str> "
  STDOUT.flush
  str = gets
  break if not str
  str.chop!
  print "pat> "
  STDOUT.flush
  re = gets
  break if not re
  re.chop!
  str.gsub! re, "#{st}\\&#{en}"
  print str, "\n"
end
print "\n"
</programlisting>
</informalexample>
<para>El programa necesita dos entradas, una con la cadena y otra con la expresión regular. La cadena se comprueba contra la expresión regular, a continuación muestra todas las partes de la cadena que coindicen con el patrón en vídeo inverso. No nos preocupemos de los detalles; analizaremos el código posteriormente.</para>
<informalexample>
<programlisting>
str> foobar
pat> ^fo+
<command>foo</command>bar
~~~
</programlisting>
</informalexample>
<para>Lo resaltado es lo que aparecerá en vídeo inverso como resultado de la ejecución del programa. La cadena '~~~' es en beneficio de aquellos que usen visualizadores en modo texto.</para>
<para>Probemos algunos ejemplos más.
<informalexample>
<programlisting>
str> abc012dbcd555
pat> \d
abc<command>012</command>dbcd<command>555</command>
   ~~~    ~~~
</programlisting>
</informalexample>
Sorprendentemente y como indica la tabla al principio de este capítulo: <command>\d</command> no tiene nada que ver el carácter <emphasis>d</emphasis>, sino que realiza la coincidencia con un dígito.</para>
<para>
¿Qué pasa si hay más de una forma de realizar la coincidencia con el patrón?.
<informalexample>
<programlisting>
str> foozboozer
pat> f.*z
<command>foozbooz</command>er
~~~~~~~~
</programlisting>
</informalexample>
se obtiene <emphasis>foozbooz</emphasis>  en vez de <emphasis>fooz</emphasis> porque las expresiones regulares tratan de obtener la coincidencia más larga posible.
</para>
<para>A continuación se muestra un patrón para aislar la hora de un campo limitada por dos puntos.
<informalexample>
<programlisting>
str> WedFeb  7 08:58:04 JST 2001
pat> [0-9]+:[0-9]+(:[0-9]+)?
WedFeb  7 <command>08:58:04</command> JST 2001
          ~~~~~~~~ 
</programlisting>
</informalexample>
<command>=~</command> es el operador de coincidencia con expresiones regulares; devuelve la posición en la cadena donde se ha producido una coincidencia o <command>nil</command> si no la hay.
<informalexample>
<programlisting>
ruby> "abcdef" =~ /d/
3
ruby> "aaaaaa" =~ /d/
nil
</programlisting>
</informalexample>
</para>
</chapter>
<chapter>
  <title>Arrays</title>
<para>Se pueden crear un <emphasis>array</emphasis> listando elementos entre corchetes ([ ]) y separándolos por comas. Los arrays en Ruby pueden almacenar objetos de diferentes tipos.
<informalexample>
<programlisting>
ruby> ary = [1, 2, "3"]
[1, 2, "3"]
</programlisting>
</informalexample>
Los arrays se pueden concatenar y repetir, igual que las cadenas.
<informalexample>
<programlisting>
ruby> ary + ["foo", "bar"]
[1, 2, "3", "foo", "bar"]
ruby> ary * 2
[1, 2, "3", 1, 2, "3"]
</programlisting>
</informalexample>
Se pueden utilizar índices numéricos para acceder a cualquier parte del array.
<informalexample>
<programlisting>
ruby> ary[0]
1
ruby> ary[0,2]
[1, 2]
ruby> ary[-2]
2
ruby> ary[-2,2]
[2, "3"]
ruby> ary[-2..-1]
[2, "3"]
</programlisting>
</informalexample>
(Los índices negativos indican que se empieza a contar desde el final del array, en vez del principio).
</para>
<para>
Los arrays se pueden convertir a y obtener de cadenas utilizado <command>join</command> y <command>split</command> respectivamente:
<informalexample>
<programlisting>
ruby> str = ary.join(':')
"1:2:3"
ruby> str.split(':')
["1", "2", "3"]
</programlisting>
</informalexample>
</para>
</chapter>
<chapter>
  <title>Hashes</title>
  <para> Un array asociativo contiene elementos que se pueden acceder, no a través de índices numéricos secuenciales, sino a través de <emphasis>claves</emphasis> que pueden tener cualquier tipo de valor. Estos arrays se conocen a veces como <emphasis>hash</emphasis> o <emphasis>diccionario</emphasis>; en el mundo Ruby se prefiere el término <emphasis>hash</emphasis>. Los hash se pueden crear mediante pares de elementos dentro de llaves ({ }). Se usa la clave para encontrar algo en un hash de la misma forma que se utiliza el índice para encontrar algo en un array.
<informalexample>
<programlisting>
ruby> h = {1 => 2, "2" => "4"}
{"2"=>"4", 1=>2}
ruby> h[1]
2
ruby> h["2"]
"4"
ruby> h[5]
nil
ruby> h[5] = 10  # añadimos un valor
10
ruby> h
{5=>10, "2"=>"4", 1=>2}
ruby> h[1]=nil # borramos un valor
nil
ruby> h[1]
nil
ruby> h
{5=>10, "2"=>"4", 1=>nil}
</programlisting>
</informalexample>
</para>
</chapter>
<chapter>
  <title>Retomando los ejemplos sencillos</title>
<para>
Vamos ahora a desmontar el código de nuestros anteriores programas ejemplo. Para que sirva de referencia vamos a numerar las líneas de todos los guiones.</para>
<sect1>
  <title>Factoriales</title>
  <para>El siguiente guión aparece en el capítulo <emphasis>Ejemplos sencillos</emphasis>.
<informalexample>
<programlisting>
01 def fact(n)
02 if n == 0
03  1
04 else
05  n * fact(n-1)
06 end
07 end
08 print fact(ARGV[0].to_i), "\n"
</programlisting>
</informalexample>
  Debido a que es la primera explicación de un código, vamos a ir línea por línea.
<informalexample>
<programlisting>
01 def fact(n)
</programlisting>
</informalexample>
  En la primera línea, <command>def</command> es la sentencia que define una función (o con mayor precisión, un <emphasis>método</emphasis>; trataremos con más detalle los métodos en un capítulo posterior). Aquí se indica que la función <command>fact</command> toma un único argumento, que se llama <command>n</command>.
<informalexample>
<programlisting>
02 if n == 0
</programlisting>
</informalexample>
  Con <command>if</command> comprobamos una condición. Si la condición es cierta, se evalúa la siguiente línea; si no independientemente de lo que siga se evalúa el <command>else</command>
<informalexample>
<programlisting>
03  1
</programlisting>
</informalexample>
  Si la condición es cierta el valor del <command>if</command> es 1.
<informalexample>
<programlisting>
04 else
</programlisting>
</informalexample>
  Si la condición no es cierta, se evalúa el código desde esta línea hasta el <command>end</command>.
<informalexample>
<programlisting>
05  n * fact(n - 1)
</programlisting>
</informalexample>
  Si no se satisface la condición el valor de <command>if</command> es el resultado de multiplicar <command>fact(n-1)</command> por <command>n</command>.
<informalexample>
<programlisting>
06 end
</programlisting>
</informalexample>
  El primer <command>end</command> cierra la sentencia <command>if</command>.
<informalexample>
<programlisting>
07 end
</programlisting>
</informalexample>
  El segundo <command>end</command> cierra la sentencia <command>def</command>.
<informalexample>
<programlisting>
08 print fact(ARGV[0].to_i), "\n"
</programlisting>
</informalexample>
  Llama a la función <command>fact()</command> con el argumento especificado en la línea de comandos, e imprime el resultado.
  </para>
  <para>
  <command>ARGV</command> es un array que contiene los argumentos de la línea de comandos. Los miembros de <command>ARGV</command> son cadenas por lo que hay que convertirlos a números enteros con <command>to_i</command>. Ruby no convierte automáticamente las cadenas a números como hace Perl.
  </para>
  <para>
  Hmmm... ¿Qué pasa si alimentamos este programa con un número negativo? ¿Se ve cuál es el problema? ¿Cómo se podría solucionar?
  </para>
</sect1>
<sect1>
  <title>Cadenas</title>
  <para>A continuación examinaremos el programa acertijo del capítulo sobre las cadenas</para>
<informalexample>
<programlisting>
01 words = ['foobar', 'baz', 'quux']
02 secret = words[rand(3)]
03
04 print "adivina? "
05 while guess = STDIN.gets
06  guess.chop!
07  if guess == secret
08    print "¡Ganas!\n"
09    break
10  else
11    print "Lo siento. Pierdes\n"
12  end
13  print "adivina? "
14 end
15 print "La palabra era ", secret, ".\n"
</programlisting>
</informalexample>
  <para>En este programa se utiliza una nueva estructura de control, <command>while</command>. El código entre el <command>while</command> y su correspondiente <command>end</command> se ejecutará repetidamente mientras la condición especificada se mantenga cierta.</para>
  <para><command>rand(3)</command> de la línea número 2 devuelve un número aleatorio dentro del rango de 0 a 2. Este número se utiliza para extraer uno de los elementos del array <command>words</command>.</para>
  <para>En la línea 5 se lee una línea de la entrada estándar con el método <command>STDIN.gets</command>. Si aparece el fin del fichero (<acronym>EOF</acronym> - End Of File), <command>gets</command> devuelve <command>nil</command>. Por lo tanto el código asociado con el <command>while</command> se repetirá hasta encontrar un <keysym>^D</keysym> (o <keysym>^Z</keysym> bajo <acronym>DOS</acronym>), que representa el fin de fichero</para>
  <para>En la línea 6 <command>guess.chop!</command> elimina el último carácter de <command>guess</command>; en este caso siempre el carácter de línea nueva.</para>
  <para>En la línea 15 se imprime la palabra secreta. Se ha escrito como una sentencia print con tres argumentos (que se imprimen uno detrás del otro), pero hubiera tenido la misma efectividad el hacerlo con un único argumento escribiendo <command>secret</command> como <command>#{secret}</command> para resaltar que la variable se debe evaluar y no imprimir la palabra literal:</para>
<informalexample>
<programlisting>
print "la palabra era #{secret}. \n"
</programlisting>
</informalexample>
</sect1>
<sect1>
  <title>Expresiones regulares</title>
  <para>Por último examinaremos el programa del capítulo sobre expresiones regulares.</para>
<informalexample>
<programlisting>
01 st = "\033[7m"
02 en = "\033[m"
03
04 while TRUE
05  print "str> "
06  STDOUT.flush
07  str = gets
08  break if not str
09  str.chop!
10  print "pat> "
11  STDOUT.flush
12  re = gets
13  break if not re
14  re.chop!
15  str.gsub! re, "#{st}\\&#{en}"
16  print str, "\n"
17 end
18 print "\n"
</programlisting>
</informalexample>
  <para>En la línea 4, se ha fijado la condición del <command>while</command> a <command>true</command> con lo que se obtiene un bucle infinito. Sin embargo se han colocado sentencias <command>break</command> en las líneas octava y decimotercera para salir del bucle. Estos dos <command>breaks</command> ejemplifican también el uso de los modificadores <command>if</command>. Un <quote>modificador <command>if</command></quote> ejecuta la sentencia del lado izquierdo si y sólo si se satisface la condición especificada.</para>
  <para>Hay más cosas que decir sobre <command>chop!</command> (veanse las líneas 9 y 14). En Ruby se añade, por convención, <emphasis>!</emphasis> o <emphasis>?</emphasis> al final de ciertos nombre de métodos. El marca de exclamación (<emphasis>!</emphasis>, pronunciada como un <quote>bang!</quote> sonoro) recalca algo potencialmente peligroso, es decir, algo que puede modificar el valor de lo que toca. <command>chop!</command> afecta directamente a la cadena pero <command>chop</command> sin el signo de exclamación actúa sobre una copia. A continuación se muestra la diferencia.
<informalexample>
<programlisting>
ruby> s1 = "forth"
"forth"
ruby> s1.chop!     # modifica s1
"fort"
ruby> s2 = s1.chop # sitúa en s2 una copia de la modificación
"for"
ruby> s1           # ... sin afectar a  s1
"fort"
</programlisting>
</informalexample>
Posteriormente  no encontraremos con nombres de métodos que finalizan con un signo de interrogación (<emphasis>?</emphasis>, pronunciada a veces como un <quote>huh?</quote> sonoro). Esto indica que el método es un <quote>predicado</quote>, aquel que puede devolver o <command>true</command> o <command>false</command>.
</para>
<para>La línea 15 requiere una especial atención. Primero, se observa que <command>gsub!</command> es otro de los denominados métodos destructivos. Modifica <command>str</command> al reemplazar toda coincidencia del patrón <command>re</command> (<command>sub</command> significa sustituir, la <command>g</command> inicial indica que la sustitución es global, es decir reemplaza todas las coincidencias que hay en la cadena no sólo la primera encontrada). Hasta el momento todo parece correcto pero, ¿Por qué reemplazamos las coincidencias del texto? <command>st</command> y <command>en</command> se definieron en las líneas 1 y 2 como secuencias <acronym>ANSI</acronym> que presentan el color del texto como invertido o normal respectivamente. En la línea 15 se encuentran encerradas entre <command>#{}</command> para asegurar que se interpreten por lo que son (y no se impriman los <emphasis>nombres</emphasis> de las variables). Entre ella se ve <quote>\\&</quote>. Esto es un pequeño truco. Dado que la sentencia de reemplazo se encuentra entre comillas dobles, los dos backslashes se interpretarán como uno solo, que <command>gsub!</command> verá como <quote>\&</quote> que no es otra cosa que el código que representa la primera coincidencia del patrón. Por lo tanto la nueva cadena, al imprimirse, será igual que la antigua, excepto que las partes que coinciden con el patrón aparecen resaltadas en vídeo inverso.</para>
</sect1>
</chapter>
<chapter>
  <title>Estructuras de control</title>
  <para>Este capítulo explora más sentencias de control de Ruby.</para>
  <sect1>
    <title>case</title>
    <para>Se utiliza la sentencia <command>case</command> para comprobar una secuencia de condiciones. Superficialmente se parece al <command>switch</command> de C y Java pero es considerablemente más potente como veremos.
<informalexample>
<programlisting>
ruby> i=8
8
ruby> case i
ruby| when 1, 2..5
ruby|   print "1..5\n"
ruby| when 6..10
ruby|   print "6..10\n"
ruby| end
6..10
nil
</programlisting>
</informalexample>
<command>2..5</command> es una expresión que representa un <emphasis>rango</emphasis> entre 2 y 5 inclusive. La siguiente expresión verifica si el valor <command>i</command> cae dentro del rango:
<informalexample>
<programlisting>
(2..5) === i
</programlisting>
</informalexample>
La sentencia <command>case</command> utiliza internamente el operador === para verificar las distintas condiciones. Dentro de la naturaleza orientada a objetos de Ruby, === lo interpreta el objeto que aparece en la condición <command>when</command>. Por ejemplo, el código que sigue comprueba en el primer <command>when</command> la igualdad de cadenas y en el segundo la coincidencia con una expresión regular.
<informalexample>
<programlisting>
ruby> case 'abcdef'
ruby| when 'aaa', 'bbb'
ruby|   print "aaa o bbb\n"
ruby| when /def/
ruby|   print "incluye /def/\n"
ruby| end
incluye /def/
nil
</programlisting>
</informalexample>
</para>
  </sect1>
  <sect1>
    <title>while</title>
    <para>
    Ruby proporciona medios adecuados para la construcción de bucles, aunque veremos en el siguiente capítulo que si se aprende a utilizar los <emphasis>iteradores</emphasis> a menudo hace innecesario su utilización explícita.
    </para>
    <para>
    Un <command>while</command> es un <command>if</command> repetido. Se ha utilizado en nuestros programas acertijo adivina-palabra y en las expresiones regulares (ver el capítulo anterior); allí tomaba la forma <command>while <varname>condición</varname> ... end</command> que rodeaba el código a repetir mientras la <emphasis>condición</emphasis> fuera cierta. Pero <command>while</command> e <command>if</command> se pueden aplicar fácilmente a sentencias individuales:
<informalexample>
<programlisting>
ruby> i = 0
0
ruby> print "Es cero.\n" if i == 0
Es cero.
nil
ruby> print "Es negativo\n" if i < 0
nil
ruby> print "#{i+=1}\n" while i < 3
1
2
3
nil
</programlisting>
</informalexample>
    Algunas veces se necesita la condición de comprobación negada. Un <command>unless</command> es un <command>if</command> negado y un <command>until</command> es un <command>while</command> negado. Dejamos estas sentencias para que se experimente con ellas.
    </para>
    <para>
    Existen cuatro formas de interrumpir el progreso de un bucle desde su interior. La primera <command>break</command>, como en C, sale completamente del bucle. La segunda <command>next</command> salta al principio de la siguiente iteración del bucle (se corresponde con la sentencia <command>continue</command> del C). La tercera <command>redo</command> reinicia la iteración en curso. A continuación se muestra un extracto de código en C que ilustra el significado de <command>break</command>, <command>next</command>, y <command>redo</command>:
<informalexample>
<programlisting>
while (condicion) {
label_redo:
goto label_next    /*next*/
goto label_break   /*break*/
goto label_redo    /*redo*/
;
;
label_next:
}
label_break:
;
</programlisting>
</informalexample>
    La cuarta forma de salir del interior de un bucle es <command>return</command>. La evaluación de <command>return</command> provoca la salida no sólo del bucle sino también del método que contiene el bucle. Si se le pasa un argumento, lo devolverá como retorno de la llamada al método, si no el retorno será <command>nil</command>.
    </para>
  </sect1>
  <sect1>
    <title>for</title>
    <para>
    Los programadores en C se estarán preguntando cómo se construye un bucle <command>for</command>. En Ruby, el bucle <command>for</command> es mucho más interesante de lo que cabía esperar. El siguiente bucle se ejecuta una vez por cada elemento de la colección.
<informalexample>
<programlisting>
for elem in coleccion
  ...
end
</programlisting>
</informalexample>
    La colección puede ser un rango de valores (esto es lo que la mayoría de la gente espera cuando se habla de bucles for):
<informalexample>
<programlisting>
ruby> for num in (4..6)
ruby|   print num, "\n"
ruby| end
4
5
6
4..6
</programlisting>
</informalexample>
    Puede ser cualquier tipo de colección como por ejemplo un array:
<informalexample>
<programlisting>
ruby> for elm in [100,-9.6,"pickle"]
ruby|   print "#{elm}\t(#{elm.type})\n"
ruby| end
100     (Fixnum)
-9.6    (Float)
pickle   (String)
[100, -9.6, "pickle"]
</programlisting>
</informalexample>
    Saliéndonos un poco del tema, <command>for</command> es realmente otra forma de escribir <command>each</command>, el cual es nuestro primer ejemplo de iterador. La siguientes dos estructuras son equivalentes:
<informalexample>
<programlisting>
# Si utilizas C o Java, puedes preferir esta estructura
for i in coleccion
  ..
end

# si utilizas Smalltalk, puedes preferir esta otra
coleccion.each {|i|
  ...
}
</programlisting>
</informalexample>
    Con frecuencia se puede sustituir los bucles convencionales por iteradores y una vez acostumbrado a utilizarlos es generalmente más sencillo tratar con éstos. Por lo tanto, avancemos y aprendamos más sobre ellos.
    </para>
  </sect1>
</chapter>
<chapter>
  <title>Iteradores</title>
  <para>
  Los iteradores no son un concepto original de Ruby. Son comunes en otros lenguajes orientados a objetos. También se utilizan en Lisp aunque no se les conoce como iteradores. Sin embargo este concepto de iterador es muy poco familiar para muchas personas por lo que se explorará con detalle.
  </para>
  <para>
  Como ya se sabe, el verbo <emphasis>iterar</emphasis> significa hacer la misma cosa muchas veces, por lo tanto un <emphasis>iterador</emphasis> es algo que hace la misma cosa muchas veces.
  </para>
  <para>
  Al escribir código se necesitan bucles en diferentes situaciones. En C, se codifican utilizando <command>for</command> o <command>while</command>. Por ejemplo:
<informalexample>
<programlisting>
char *str;
for (str = "abcdefg"; *str != '\0'; str++) {
  /* aquí procesamos los caracteres */
}
</programlisting>
</informalexample>
  La sintaxis del <command>for(...)</command> de C nos dota de una abstracción que nos ayuda en la creación de un bucle pero, la comprobación de si <command>*str</command> es la cadena nula requiere que el programador conozca los detalles de la estructura interna de una cadena. Esto hace que C se parezca a un lenguaje de bajo nivel. Los lenguajes de alto nivel se caracterizan por un soporte más flexible a la iteración. Consideremos el siguiente guión de la shell <command>sh</command>:
<informalexample>
<programlisting>
#!/bin/sh

for i in *.[ch]; do
  # ... aquí se haría algo con cada uno de los ficheros
done
</programlisting>
</informalexample>
  Se procesarían todos los ficheros fuentes en C y sus cabeceras del directorio actual, el comando de la shell se encargaría de los detalles de coger y sustituir los nombres de los ficheros uno por uno. Pensamos que este es un método de trabajo a nivel superior que C, ¿Verdad?
  </para>
  <para>
  Pero hay más cosas a tener en cuenta: aunque está bien que un lenguaje tenga iteradores para todos los tipos de datos definidos en él, es decepcionante tener que volver a escribir bucles de bajo nivel para los tipos de datos propios. En la POO, los usuarios definen sus propios tipos de datos a partir de otros, por lo tanto, esto puede ser un problema serio.
  </para>
  <para>
  Luego, todos los lenguajes OO incluyen ciertas facilidades de iteración. Algunos lenguajes proporcionan clases especiales con este propósito; Ruby nos permite definir directamente iteradores.
  </para>
  <para>
  El tipo <command>strings</command> de Ruby tiene algunos iteradores útiles:
<informalexample>
<programlisting>
ruby> "abc".each_byte{|c| printf"{%c}", c}; print "\n"
{a}{b}{c}
nil
</programlisting>
</informalexample>
  <command>each_byte</command> es un iterador sobre los caracteres de una cadena. Cada carácter se sustituye en la variable local <command>c</command>. Esto se puede traducir en algo más parecido a C ...
<informalexample>
<programlisting>
ruby> s="abc";i = 0
0
ruby> while i &lt; s.length
ruby|   printf "{%c}",s[i]; i+=1
ruby| end; print "\n"
{a}{b}{c}
nil
</programlisting>
</informalexample>
  ... sin embargo el iterador <command>each_byte</command> es a la vez conceptualmente más simple y tiene más probabilidades de seguir funcionando correctamente incluso cuando, hipotéticamente, la clase <command>string</command> se modifique radicalmente en un futuro. Uno de los beneficios de los iteradores es que tienden a ser robustos frente a tales cambios, además, ésta es una característica del buen código en general. (Si, tengamos paciencia también hablaremos de lo que son las clases)
  </para>
  <para>
  <command>each_line</command> es otro iterador de <command>String</command>.
<informalexample>
<programlisting>
ruby> "a\nb\nc\n".each_line{|l| print l}
a
b
c
"a\nb\nc\n"
</programlisting>
</informalexample>
  Las tareas que más esfuerzo llevan en C (encontrar los delimitadores de línea, generar subcadenas, etc.) se evitan fácilmente utilizando iteradores.
  </para>
  <para>
  La sentencia <command>for</command> que aparece en capítulos previos itera como lo hace el iterador <command>each</command>. El iterador <command>each</command> de <command>String</command> funciona de igual forma que <command>each_line</command>, reescribamos ahora el ejemplo anterior con un <command>for</command>:
<informalexample>
<programlisting>
ruby> for l in "a\nb\nc\n"
ruby|   print l
ruby| end
a
b
c
"a\nb\nc\n"
</programlisting>
</informalexample>
  Se puede utilizar la sentencia de control <command>retry</command> junto con un bucle de iteración y se repetirá la iteración en curso desde el principio.
<informalexample>
<programlisting>
ruby> c = 0
0
ruby> for i in 0..4
ruby|   print i
ruby|   if i == 2 and c == 0
ruby|           c = 1
ruby|           print "\n"
ruby|           retry
ruby|   end
ruby| end; print "\n"
012
01234
nil
</programlisting>
</informalexample>
  A veces aparece <command>yield</command> en la definición de un iterador. <command>yield</command> pasa el control al bloque de código que se pasa al iterador (esto se explorará con más detalle es el capítulo sobre los objetos procedimiento). El siguiente ejemplo define el iterador <command>repeat</command>, que repite el bloque de código el número de veces especificado en el argumento.
<informalexample>
<programlisting>
ruby> def repeat(num)
ruby|   while num > 0
ruby|           yield
ruby|           num -= 1
ruby|   end
ruby| end
nil
ruby> repeat(3){ print "foo\n" }
foo
foo
foo
nil
</programlisting>
</informalexample>
  Con <command>retry</command> se puede definir un iterador que funciona igual que <command>while</command>, aunque es demasiado lento para ser práctico.
<informalexample>
<programlisting>
ruby> def WHILE(cond)
ruby|   return if not cond
ruby|   yield
ruby|   retry
ruby| end
nil
ruby> i=0;WHILE(i<3){ print i; i+=1 }
012nil
</programlisting>
</informalexample>
  ¿Se entiende lo que son los iteradores? Existen algunas restricciones pero se pueden escribir iteradores propios; y de hecho, al definir un nuevo tipo de datos, es conveniente definir iteradores adecuados para él. En este sentido los ejemplos anteriores no son terriblemente útiles. Volveremos a los iteradores cuando se sepa lo que son las clases.
  </para>
</chapter>
<chapter>
  <title>Pensamiento orientado a objetos</title>
  <para>
    La <emphasis>orientación a objetos</emphasis> es una palabra con gancho. Llamar a cualquier cosa <quote>orientada a objetos</quote> puede hacerla parecer más elegante. Ruby reclama ser un lenguaje de guiones orientado a objetos: pero, ¿Qué significa exactamente <quote>orientado a objetos</quote>?
  </para>
  <para>
  Existe una gran variedad de respuestas a esta pregunta, y probablemente todas ellas se pueden reducir a la misma cosa. En vez de recapitular demasiado deprisa, pensemos un momento en el paradigma de la programación tradicional.
  </para>
  <para>
  Tradicionalmente, un problema informático se ataca produciendo algún tipo de <emphasis>representación de datos</emphasis> y <emphasis>procedimientos</emphasis> que operan sobre esos datos. Bajo este modelo, los datos son inertes, pasivos e incapaces. Están a la completa merced de un gran cuerpo procedimental, que es activo, lógico y todopoderoso.
  </para>
  <para>
  El problema con esta aproximación es, que los programas los escriben programadores, que son humanos, que sólo pueden retener cierto número de detalles en sus cabezas en un momento determinado. A medida que crece el proyecto, el núcleo procedimental crece hasta un punto que se hace difícil recordar cómo funciona todo el conjunto. Pequeños lapsos de pensamiento o errores tipográficos llegan a ser errores muy ocultos. Empiezan a surgir interacciones complejas e inintencionadas dentro de este núcleo y el mantenimiento se convierte en algo parecido a transportar un calamar gigante intentado que ninguno de sus tentáculos te alcance la cara. Existen políticas de programación que ayudan a minimizar y localizar errores dentro de este paradigma tradicional pero existe una solución mejor que pasa fundamentalmente por cambiar la forma de trabajar.
  </para>
  <para>
  Lo que hace la programación orientada a objetos es, delegar la mayoría del trabajo mundano y repetitivo <emphasis>a los propios datos</emphasis>; modifica el concepto de los datos que pasan de <emphasis>pasivos</emphasis> a <emphasis>activos</emphasis>. Dicho de otra forma.
  <itemizedlist mark="bullet">
  <listitem>
  <para>
  Dejamos de tratar cada pieza de dato como una caja en la que se puede abrir su tapa y arrojar cosas en ella.
  </para>
  </listitem>
  <listitem>
  <para>
  Empezamos a tratar cada pieza de dato como una máquina funcional cerrada con unos pocos interruptores y diales bien definidos.
  </para>
  </listitem>
  </itemizedlist>
  Lo que se define anteriormente como una <quote>máquina</quote> puede ser, en su interior, algo muy simple o muy complejo. No se puede saber desde el exterior y no se nos permite abrir la máquina (excepto cuando estamos completamente seguros de que algo está mal en su diseño), por lo que se nos obliga a conmutar interruptores y leer los diales para interactuar con los datos. Una vez construida, no queremos tener que pensar en como funciona internamente.
  </para>
  <para>
  Se podría pensar que estamos haciendo más trabajo nosotros mismos, pero esta forma de trabajo tiende a ser un buen método para evitar que vayan mal todo tipo de cosas.
  </para>
  <para>
  Comencemos con un ejemplo que es demasiado simple para tener algún valor práctico pero que al menos muestra parte del concepto. Nuestro coche consta de un odómetro. Su trabajo consiste en  llevar un registro de la distancia recorrida desde la última vez que se pulsó el botón de reinicialización. ¿Cómo podríamos representar esto en un lenguaje de programación? En C, el odómetro sería, simplemente, una variable numérica de tipo <command>float</command>. El programa manipularía esa variable aumentando el valor en pequeños incrementos y ocasionalmente la reinicializaría a cero cuando fuese apropiado. ¿Qué hay de malo en esto? Un error en el programa podría asignar un valor falso a la variable, por cualquier número de razones inesperadas. Cualquiera que haya programado en C sabe que se pueden perder horas o días tratando de encontrar ese error que una vez encontrado parece absurdamente simple. (El momento de encontrar el error es indicado por una sonora palmada en la frente).
  </para>
  <para>
  En un contexto orientado a objetos, el mismo problema se puede atacar desde un ángulo completamente diferente. La primera cosa que se pregunta un programador al diseñar el odómetro no es <quote>¿qué tipos de datos son los más cercanos para representar esta cosa?</quote> sino <quote>¿cómo se supone que actúa esta cosa?</quote>. La diferencia termina siendo profunda. Es necesario dedicar cierto tiempo a decidir para qué es exactamente un odómetro y cómo se espera que el mundo exterior interactúe con el. Se decide entonces construir una pequeña máquina con controles que permitan incrementar, reinicializar y leer su valor y nada más.
  </para>
  <para>
  El odómetro se crea sin un mecanismo para asignarle un valor arbitrario, ¿Por qué? porque es de todos sabido que los odómetros no trabajan de esa forma. Existen sólo unas cuantas cosas que un odómetro puede hacer, y sólo permitimos esas cosas. Así, si alguien desde un programa trata de asignar algún otro valor (por ejemplo, la temperatura límite del sistema de control de climatización del vehículo) al odómetro, aparece de inmediato una indicación de lo que va mal. Al ejecutar el programa se nos dice (o posiblemente, al compilarlo dependiendo de la naturaleza del lenguaje) que <emphasis>No se nos permite asignar valores arbitrarios al objeto Odómetro</emphasis>. El mensaje podría ser menos preciso, pero sí razonablemente próximo al problema. Esto no evita el error, ¿verdad? pero apunta rápidamente en la dirección de la causa. Esta es sólo alguna de múltiples formas en las que la programación OO nos puede evitar muchas pérdidas de tiempo.
  </para>
  <para>
  Existe, normalmente, un nivel de abstracción superior a éste porque resulta que es igual de fácil construir una factoría que hace máquinas como hacer una máquina individual. Es poco probable que construyamos un único odómetro, sino que nos preparamos para construir cualquier cantidad de odómetros a partir de un único patrón. El patrón (o si los prefieres, la factoría de odómetros) es lo que se conoce como <emphasis>clase</emphasis> y el odómetro individual sacado del patrón (o construido en la factoría) se conoce como <emphasis>objeto</emphasis>. La mayoría de los lenguajes OO necesitan una clase para tener un nuevo tipo de objeto pero Ruby no.
  </para>
  <para>
  Conviene resaltar aquí que la utilización de un lenguaje OO no <emphasis>obliga</emphasis> a un diseño OO válido. Es posible, en cualquier lenguaje, escribir código poco claro, descuidado, mal concebido, erróneo e inestable. Lo que permite Ruby (en oposición, especialmente, a C++) es que la práctica de la programación OO sea lo suficientemente natural para que, incluso, trabajando a pequeña escala no se sienta la necesidad de recurrir a un código mal estructurado por evitar esfuerzo. Se tratará la forma en que Ruby logra este admirable propósito a medida que avancemos en esta guía; el próximo tema serán los <quote>interruptores y diales</quote> (métodos del objeto) y a partir de aquí pasaremos a las <quote>factorías</quote> (clases). ¿Sigues con nosotros?
  </para>
</chapter>
<chapter>
  <title>Métodos</title>
  <para>
  ¿Qué es un método? En la programación OO no se piensa en operar sobre los datos directamente desde el exterior de un objeto; si no que los objetos tienen algún conocimiento de cómo se debe operar sobre ellos (cuando se les pide amablemente). Podríamos decir que se pasa un mensaje al objeto y este mensaje obtiene algún tipo de acción o respuesta significativa. Esto debe ocurrir sin que tengamos necesariamente algún tipo de conocimiento o nos importe como realiza el objeto, interiormente, el trabajo. Las tareas que podemos pedir que un objeto realice (o lo que es lo mismo, los mensajes que comprende) son los <emphasis>métodos</emphasis>.
  </para>
  <para>
  En Ruby, se llama a un método con la notación punto (como en C++ o Java). El objeto con el que nos comunicamos se nombra a la izquierda del punto.
<informalexample>
<programlisting>
ruby> "abcdef".length
6
</programlisting>
</informalexample>
  Intuitivamente, <emphasis>a este objeto cadena se le está pidiendo que diga la longitud que tiene</emphasis>. Técnicamente, se está llamando al método <command>length</command> del objeto <command>"abcdef"</command>.
  </para>
  <para>
  Otros objetos pueden hacer una interpretación un poco diferente de <command>length</command>. La decisión sobre cómo responder a un mensaje se hace al vuelo, durante la ejecución del programa, y la acción a tomar puede cambiar dependiendo de la variable a que se haga referencia.
<informalexample>
<programlisting>
ruby> foo = "abc"
"abc"
ruby> foo.length
3
ruby> foo = ["abcde","fghij"]
["abcde", "fghij"]
ruby> foo.length
2
</programlisting>
</informalexample>
  Lo que indicamos con <command>length</command> puede variar dependiendo del objeto con el que nos comunicamos. En el primer ejemplo le pedimos a <command>foo</command> su longitud, como referencia a una cadena simple, sólo hay una respuesta posible. En el segundo ejemplo, <command>foo</command> referencia a un array, podríamos pensar que su longitud es 2, 5 ó 10; pero la respuesta más plausible es 2 (los otros tipos de longitud se podrían obtener si se desea)
<informalexample>
<programlisting>
ruby> foo[0].length
5
ruby> foo[0].length + foo[1].length
10
</programlisting>
</informalexample>
  Lo que hay que tener en cuenta es que, el array <emphasis>conoce lo que significa ser un array</emphasis>. En Ruby, las piezas de datos llevan consigo ese conocimiento por lo que las solicitudes que se les hace se pueden satisfacer en las diferentes formas adecuadas. Esto libera al programador de la carga de memorizar una gran cantidad de nombres de funciones, ya que una cantidad relativamente pequeña de nombre de métodos, que corresponden a conceptos que sabemos como expresar en lenguaje natural, se pueden aplicar a diferentes tipos de datos siendo el resultado el que se espera. Esta característica de los lenguajes OO (que, IMHO<footnote><para>In My Honest Opinion (En mi sincera opinión)</para></footnote>, Java ha hecho un pobre trabajo en explotar), se conoce como <emphasis>polimorfismo</emphasis>
  </para>
  <para>
  Cuando un objeto recibe un mensaje que no conoce, <quote>salta</quote> un error:
<informalexample>
<programlisting>
ruby> foo = 5
5
ruby> foo.length
ERR: (eval):1: undefined method `length' for 5:Fixnum
</programlisting>
</informalexample>
  Por lo tanto hay que conocer qué métodos son aceptable para un objeto, aunque no se necesita saber como son procesados.
  </para>
  <para>
  Si se pasan argumentos a un método, éstos van normalmente entre paréntesis.
<informalexample>
<programlisting>
objeto.metodo(arg1, arg2)
</programlisting>
</informalexample>
  pero se pueden omitir, si su ausencia no provoca ambigüedad
<informalexample>
<programlisting>
objeto.metodo arg1, arg2
</programlisting>
</informalexample>
  En Ruby existe una variable especial <command>self</command> que referencia al objeto que llama a un método. Ocurre con tanta frecuencia que por conveniencia se omite en las llamadas de un método dentro de un objeto a sus propios métodos:
<informalexample>
<programlisting>
self.nombre_de_metodo(args ...)
</programlisting>
</informalexample>
  es igual que:
<informalexample>
<programlisting>
nombre_de_metodo(args ...)
</programlisting>
</informalexample>
  Lo que conocemos tradicionalmente como <emphasis>llamadas a funciones</emphasis> es esta forma abreviada de llamar a un método a través de <command>self</command>. Esto hace que a Ruby se le conozca como un lenguaje orientado a objetos puro. Aún así, los métodos funcionales se comportan de una forma muy parecida a las funciones de otros lenguajes de programación en beneficio de aquellos que no asimilen que las llamadas a funciones son realmente llamadas a métodos en Ruby. Se puede hablar de <emphasis>funciones</emphasis> como si no fuesen realmente métodos de objetos, si queremos.
  </para>
</chapter>
<chapter>
  <title>Clases</title>
  <para>
  El mundo real está lleno de objetos que podemos clasificar. Por ejemplo, un niño muy pequeño es probable que diga <quote>guau guau</quote> cuando vea un perro, independientemente de su raza; naturalmente vemos el mundo en base a estas categorías.
  </para>
  <para>
  En terminología OO, una categoría de objetos, como <quote>perro</quote>, se denomina <emphasis>clase</emphasis> y cualquier objeto determinado que pertenece a una clase se conoce como <emphasis>instancia</emphasis> de esa clase.
  </para>
  <para>
  Generalmente, en Ruby y en cualquier otro lenguaje OO, se define primero las características de una clase, luego se crean las instancias. Para mostrar el proceso, definamos primero una clase muy simple <command>Perro</command>.
<informalexample>
<programlisting>
ruby> class Perro
ruby|   def ladra
ruby|           print "guau guau\n"
ruby|   end
ruby| end
nil
</programlisting>
</informalexample>
  En Ruby, la definición de una clase es la región de código que se encuentra entre las palabras reservadas <command>class</command> y <command>end</command>. Dentro de esta área, <command>def</command> inicia la definición de un <emphasis>método</emphasis>, que como se dijo en el capítulo anterior, corresponde con algún comportamiento específico de los objetos de esa clase.
  </para>
  <para>
  Ahora que tenemos definida la clase <command>Perro</command>, vamos a utilizarla:
<informalexample>
<programlisting>
ruby> rufi = Perro.new
#&lt;Perro:0x401c444c&gt;
</programlisting>
</informalexample>
  Hemos creado una instancia nueva de la clase <command>Perro</command> y le hemos llamado <command>rufi</command>. El método <command>new</command> de cualquier clase, crea una nueva instancia. Dado que <command>rufi</command> es un <command>Perro</command>, según la definición de la clase, tiene las propiedades que se decidió que un <command>Perro</command> debía tener. Dado que la idea de <emphasis>Perrunidad</emphasis> es muy simple, sólo hay una cosa que puede hacer <command>rufi</command>
<informalexample>
<programlisting>
ruby> rufi.ladra
guau guau
nil
</programlisting>
</informalexample>
  La creación de una instancia de una clase se conoce, a veces, como <emphasis>instanciación</emphasis>. Es necesario tener un perro antes de experimentar el placer de su conversación; no se puede pedir simplemente a la clase <command>Perro</command> que ladre para nosotros:
<informalexample>
<programlisting>
ruby> Perro.ladra
ERR: (eval):1: undefined method `ladra' for Perro:Class
</programlisting>
</informalexample>
  Tiene el mismo sentido que intentar <emphasis>comer el concepto de un sándwich</emphasis>
  </para>
  <para>
  Por otro lado, si queremos oír el sonido de un perro sin estar emocionalmente atados, podemos crear (instanciar) un perro efímero, temporal y obtener un pequeño sonido antes de que desaparezca.
<informalexample>
<programlisting>
ruby> (Perro.new).ladra  # o también,  Perro.new.ladra
guau guau
nil
</programlisting>
</informalexample>
  Pero un momento, <quote>¿qué es todo esto de que a continuación el pobre tipo desaparece?</quote>. Pues es verdad, si no nos preocupamos de darle un nombre (como hicimos con <command>rufi</command>) el recolector de basura automático de Ruby decide que se trata de un perro perdido, no deseado y sin piedad se deshace de él. Ciertamente está muy bien, porque podemos crear todos los perros que queramos.
  </para>
</chapter>
<chapter>
  <title>Herencia</title>
  <para>
  La clasificación de los objetos en nuestra vida diaria es evidentemente jerárquica. Sabemos que todos los <emphasis>gatos son mamíferos</emphasis> y que <emphasis>todos los mamíferos son animales</emphasis>. Las clases inferiores <emphasis>heredan</emphasis> características  de las clases superiores a las que pertenecen. Si todos los mamíferos respiran, entonces los gatos respiran.
  </para>
  <para>
  Este concepto se puede expresar en Ruby:
<informalexample>
<programlisting>
ruby> class Mamifero
ruby|   def respira
ruby|           print "inhalar y exhalar\n"
ruby|   end
ruby| end
nil
ruby> class Gato&lt;Mamifero
ruby|   def maulla
ruby|           print "miau \n"
ruby|   end
ruby| end
nil
</programlisting>
</informalexample>
  Aunque no se dice cómo respira un <command>Gato</command>, todo gato heredará ese comportamiento de <command>Mamifero</command> dado que se ha definido <command>Gato</command> como una subclase de <command>Mamifero</command>. En terminología OO, la clase inferior es una <emphasis>subclase</emphasis> de la clase superior que es una <emphasis>superclase</emphasis>. Por lo tanto, desde el punto de vista del programador, los gatos obtienen gratuitamente la capacidad de respirar; a continuación se añade el método <command>maulla</command>, así nuestro gato puede respirar y maullar.
<informalexample>
<programlisting>
ruby> tama = Gato.new
#&lt;Gato:0x401c41b8&gt;
ruby> tama.respira
inhalar y exhalar
nil
ruby> tama.maulla
miau
nil
</programlisting>
</informalexample>
  Existen situaciones donde ciertas propiedades de las superclases no deben heredarse por una determinada subclase. Aunque en general los pájaros vuelan, los pingüinos es una subclase de los pájaros que no vuelan.
<informalexample>
<programlisting>
ruby> class Pajaro
ruby|   def aseo
ruby|           print "me estoy limpiando las plumas."
ruby|   end
ruby|   def vuela
ruby|           print "estoy volando."
ruby|   end
ruby| end
nil
ruby> class Pinguino&lt;Pajaro
ruby|   def vuela
ruby|           fail "Lo siento. yo sólo nado."
ruby|   end
ruby| end
nil
</programlisting>
</informalexample>
  En vez de definir exhaustivamente todas las características de cada nueva clase, lo que se necesita es añadir o redefinir las diferencias entre cada subclase y superclase. Esta utilización de la herencia se conoce como <emphasis>programación diferencial</emphasis>. Y es uno de los beneficios de la programación orientada a objetos.
  </para>
</chapter>
<chapter>
  <title>Redefinición de métodos</title>
  <para>
  En una subclase se puede modificar el comportamiento de las instancias redefiniendo los métodos de la superclase.
<informalexample>
<programlisting>
ruby> class Humano
ruby|   def identidad
ruby|           print "soy una persona.\n"
ruby|   end
ruby|   def tarifa_tren(edad)
ruby|           if edad < 12
ruby|                   print "tarifa reducida.\n"
ruby|           else
ruby|                   print "tarifa normal. \n"
ruby|           end
ruby|	  end
ruby| end
nil
ruby> Humano.new.identidad
soy una persona.
nil
ruby> class Estudiante&lt;Humano
ruby|   def identidad
ruby|           print "soy un estudiante.\n"
ruby|   end
ruby| end
nil
ruby> Estudiante.new.identidad
soy un estudiante.
nil
</programlisting>
</informalexample>
 Supongamos que en vez de reemplazar el método <command>identidad</command> lo que queremos es mejorarlo. Para ello podemos utilizar <command>super</command>
<informalexample>
<programlisting>
ruby> class Estudiante2&lt;Humano
ruby|   def identidad
ruby|           super
ruby|           print "también soy un estudiante.\n"
ruby|   end
ruby| end
nil
ruby> Estudiante2.new.identidad
soy una persona.
también soy un estudiante.
nil
</programlisting>
</informalexample>
  <command>super</command> nos permite pasar argumentos al método original. Se dice que hay dos tipos de personas ...
<informalexample>
<programlisting>
ruby> class Deshonesta&lt;Humano
ruby|   def tarifa_tren(edad)
ruby|           super(11)       #quiero una tarifa barata
ruby|   end
ruby| end
nil
ruby> Deshonesta.new.tarifa_tren(25)
tarifa reducida.
nil
ruby> class Honesta&lt;Humano
ruby|   def tarifa_tren(edad)
ruby|           super(edad)     #pasa el argumento entregado
ruby|   end
ruby| end
nil
ruby> Honesta.new.tarifa_tren(25)
tarifa normal.
nil
</programlisting>
</informalexample>
  </para>
</chapter>
<chapter>
  <title>Control de accesos</title>
  <para>
  Se ha dicho anteriormente que Ruby no tiene funciones, sólo métodos. Sin embargo existe más de una clase de métodos. En esta capítulo vamos a presentar el <emphasis>control de accesos</emphasis>.
  </para>
  <para>
  Vamos a considerar lo que pasa cuando se define un método en el <quote>nivel superior</quote>, no dentro de una clase. Se puede pensar que dicho método es análogo a una <emphasis>función</emphasis> de un lenguaje más tradicional como C.
<informalexample>
<programlisting>
ruby> def square(n)
ruby|   n * n
ruby| end
nil
ruby> square(5)
25
</programlisting>
</informalexample>
  Nuestro nuevo método parece que no pertenece a ninguna clase, pero de hecho Ruby se lo asigna a la clase <command>Object</command>, que es la superclase de cualquier otra clase. Como resultado de esto cualquier objeto es capaz de utilizar este método. Esto es cierto, pero existe un pequeño pero; es un método <emphasis>privado</emphasis> a cada clase. A continuación hablaremos más de lo que esto significa, pero una de sus consecuencias es que sólo se puede llamar de la siguiente forma
<informalexample>
<programlisting>
ruby> class Foo
ruby|   def fourth_power_of (x)
ruby|           square(x) * square(x)
ruby|   end
ruby| end
nil
ruby> Foo.new.fourth_power_of 10
10000
</programlisting>
</informalexample>
  No se nos permite aplicar explícitamente el método a un objeto:
<informalexample>
<programlisting>
"fish".square(5)
ERR: (eval):1: private method `square' called for "fish":String
</programlisting>
</informalexample>
  Esto preserva con inteligencia la naturaleza puramente OO de Ruby (las funciones siguen siendo métodos de objetos, donde el receptor implícito es <command>self</command>), a la vez que proporciona funciones que se pueden escribir de igual forma que en lenguajes tradicionales.
  </para>
  <para>
  Una disciplina mental común en la programación OO, que ya se señaló en un capítulo anterior, tiene que ver con la separación de la <emphasis>especificación</emphasis> y la <emphasis>implementación</emphasis> o <emphasis>qué</emphasis> tareas se supone que un objeto realiza y <emphasis>cómo</emphasis> realmente se consiguen. El trabajo interno de un objeto debe mantenerse, por lo general, oculto a sus usuarios; sólo se tiene que preocupar de lo que entra y lo que sale y confiar en que el objeto sabe lo que está realizando internamente. Así, es generalmente útil que las clases posean métodos que el mundo exterior no ve, pero que se utilizan internamente (y que pueden ser mejorados por el programador cuando desee, sin modificar la forma en que los usuarios ven los objetos de esa clase). En el trivial ejemplo que sigue, piénsese que <command>engine</command> es el motor interno de la clase.
<informalexample>
<programlisting>
ruby> class Test
ruby|   def times_two(a)
ruby|           print a," dos veces es ",engine(a),"\n"
ruby|   end
ruby|   def engine(b)
ruby|           b*2
ruby|   end
ruby|   private:engine # esto oculta engine a los usuarios
ruby| end
Test
ruby> test = Test.new
#&lt;Test:0x401c4230&gt;
ruby> test.engine(6)
ERR: (eval):1: private method `engine' called for #&lt;Test:0x401c4230&gt;
ruby> test.times_two(6)
6 dos veces es 12
nil
</programlisting>
</informalexample>
  Se podría esperar que <command>test.engine(6)</command> devolviese 12, pero por el contrario se nos comunica que <command>engine</command> es inaccesible cuando actuamos como usuario del objeto <command>Test</command>. Sólo otros métodos de <command>Test</command>, como <command>times_two</command> tienen permiso para utilizar <command>engine</command>. Se nos obliga a pasar por el interfaz público, que es el método <command>times_two</command>. El programador que está al cargo de la clase puede modificar <command>engine</command> (en este caso cambiando <command>b*2</command> por <command>b+b</command> suponiendo que así mejora el rendimiento) sin afectar cómo los usuarios interactúan con el objeto <command>Test</command>. Este ejemplo, por supuesto, es demasiado simple para ser útil; los beneficios de control de accesos se manifiestan cuando se comienzan a crear clases más complicadas e interesantes.
  </para>
</chapter>
<chapter>
  <title>Métodos singleton</title>
  <para>
  El comportamiento de una instancia viene determinado por su clase, pero hay veces que sabemos que una determinada <emphasis>instancia</emphasis> debe tener un comportamiento especial. En la mayoría de los lenguajes debemos meternos en la problemática de crear otra clase e instanciarla sólo una vez. En Ruby se puede asignar a cada OBJETO sus propios métodos.
<informalexample>
<programlisting>
ruby> class SingletonTest
ruby|   def size
ruby|           print "25\n"
ruby|   end
ruby| end
nil
ruby> test1 = SingletonTest.new
#&lt;SingletonTest:0x401c4604&gt;
ruby> test2 = SingletonTest.new
#&lt;SingletonTest:0x401c4514&gt;
ruby> def test2.size
ruby|   print "10\n"
ruby| end
nil
ruby> test1.size
25
nil
ruby> test2.size
10
nil
</programlisting>
</informalexample>
  En este ejemplo, <command>test1</command> y <command>test2</command> pertenecen a la misma clase, pero a <command>test2</command> se le ha redefinido el método <command>size</command> y por lo tanto se comportan de forma diferente. Un método que pertenece sólo a un objeto se conoce como <emphasis>método singleton</emphasis>.
  </para>
  <para>
  Los métodos singleton se utilizan frecuentemente en los elementos de un interfaz gráfico de usuario (GUI<footnote><para>Graphical User Interface</para></footnote>) cuando se deben realizar acciones diferentes cuando se pulsan botones diferentes.
  </para>
  <para>
  Los métodos singleton no son únicos de Ruby, aparecen también en CLOS, Dylan, etc. Otros lenguajes como por ejemplo Self y NewtonScript, sólo tienen métodos singleton. A estos se les conoce como lenguajes <emphasis>basados en prototipos</emphasis>
  </para>
</chapter>
<chapter>
  <title>Módulos</title>
  <para>
  Los módulos en Ruby son similares a las clases, excepto en:
  <itemizedlist mark="bullet">
  <listitem><para>Un módulo no puede tener instancias</para></listitem>
  <listitem><para>Un módulo no puede tener subclases</para></listitem>
  <listitem><para>Un módulo se define con <command>module ... end</command></para></listitem>
  </itemizedlist>
  </para>
  <para>
  Ciertamente ... la clase Module de un módulo es la superclase de la clase Class de una clase. ¿Se pilla esto? ¿No? Sigamos.
  </para>
  <para>
  Existen dos usos típicos de los módulos. Uno es agrupar métodos y constantes relacionadas en un repositorio central. El módulo <command>Math</command> de Ruby hace esta función:
<informalexample>
<programlisting>
ruby> Math.sqrt(2)
1.414213562
ruby> Math::PI
3.141592654
</programlisting>
</informalexample>
  El operador <command>::</command> indica al intérprete de Ruby qué módulo debe consultar para obtener el valor de la constante (es concebible, que algún otro módulo a parte de  <command>Math</command> interprete <command>PI</command> de otra forma). Si queremos referenciar a los métodos o constantes de un módulo, directamente, sin utilizar <command>::</command>, podemos <emphasis>incluir</emphasis> ese módulo con <command>include</command>:
<informalexample>
<programlisting>
ruby> include Math
Object
ruby> sqrt(2)
1.414213562
ruby> PI
3.141592654
</programlisting>
</informalexample>
  El otro uso de los módulos se denomina <emphasis>mixin</emphasis>. Algunos lenguajes OO, incluidos el C++, permiten <emphasis>herencia múltiple</emphasis>, es decir, una clase puede heredar de más de una superclase. Un ejemplo de herencia múltiple en el mundo real es un despertador, se podría pensar que un despertador es una clase de <emphasis>reloj</emphasis> y que también pertenece a la clase de objetos que podríamos llamar <emphasis>zumbadores</emphasis>.
  </para>
  <para>
  Ruby, con toda la intención del mundo, no implementa herencia múltiple real, aunque la técnica de los <emphasis>mixins</emphasis> es una buena alternativa. Recuérdese que los módulos no se pueden instanciar ni se pueden crear subclases de ellos; pero si se incluye un módulo en la definición de una clase sus métodos quedan añadidos a ella, es decir se asocian (<emphasis>mixin</emphasis><footnote><para>asociar</para></footnote>) a la clase.
  </para>
  <para>
  Se puede pensar que los mixins son una forma de pedir qué propiedades concretas se desean. Por ejemplo, si una clase tiene un método <command>each</command> funcional, asociarla con el módulo <command>Enumerable</command> de la biblioteca estándar nos proporciona gratuitamente los métodos <command>sort</command> y <command>find</command>.
  </para>
  <para>
  Esta utilización de los módulos proporciona la funcionalidad básica de la herencia múltiple permitiéndonos representar las relaciones de la clase en una simple estructura en árbol que simplifica considerablemente la implementación del lenguaje (Los diseñadores de Java hicieron una elección parecida).
  </para>
</chapter>
<chapter>
  <title>Objetos procedimiento</title>
  <para>
  A menudo es deseable tener la posibilidad de definir respuestas específicas a sucesos inesperados. Resulta que esto se consigue con gran sencillez si podemos pasar un bloque de código a otros métodos, lo que significa que deseamos tratar el código como si fuesen datos.
  </para>
  <para>
  Un <emphasis>objeto procedimiento</emphasis> nuevo se obtiene utilizando <command>proc</command>:
<informalexample>
<programlisting>
ruby> quux = proc {
ruby|   print "QUUXQUUXQUUX!!!\n"
ruby| }
#&lt;Proc:0x401c4884&gt;
</programlisting>
</informalexample>
  Ahora <command>quux</command> referencia a un objeto y como las mayoría de los objetos, tiene un comportamiento que se puede invocar. Concretamente, podemos pedir que se ejecute a través de su método <command>call</command>
<informalexample>
<programlisting>
ruby> quux.call
QUUXQUUXQUUX!!!
nil
</programlisting>
</informalexample>
  Luego, después de todo esto. ¿Podemos utilizar <command>quux</command> cómo un argumento de un método? Ciertamente.
<informalexample>
<programlisting>
ruby> def run ( p )
ruby|   print "Vamos a llamar a un procedimiento ... \n"
ruby|   p.call
ruby|   print "Finalizado. \n"
ruby| end
nil
ruby> run quux
Vamos a llamar a un procedimiento ...
QUUXQUUXQUUX!!!
Finalizado.
nil
</programlisting>
</informalexample>
  El método <command>trap</command> nos permite asignar una respuesta personalizada a cualquier señal del sistema.
<informalexample>
<programlisting>
ruby> inthandler = proc{ print "^C ha sido pulsado.\n" }
#&lt;Proc:0x401c4104&gt;
ruby> trap "SIGINT", inthandler
nil
</programlisting>
</informalexample>
  Normalmente, al pulsar ^C se sale del intérprete. Ahora se imprime un mensaje y el intérprete sigue ejecutándose, así no se pierde el trabajo realizado. (No nos encontramos atrapados en el intérprete para siempre; todavía se puede salir tecleando <command>exit</command> o pulsando ^D.)
  </para>
  <para>
  Una observación final antes de pasar a otros temas: no es necesario dar al objeto procedimiento un nombre antes de asociarlo a una señal. Un objeto procedimiento <emphasis>anónimo</emphasis> equivalente se asemejaría a:
<informalexample>
<programlisting>
ruby> trap "SIGINT", proc{ print "^C ha sido pulsado.\n" }
#&lt;Proc:0x401c4104&gt;
</programlisting>
</informalexample>
  O de una forma más compacta todavía,
<informalexample>
<programlisting>
ruby> trap "SIGINT", 'print "^C ha sido pulsado.\n"'
#&lt;Proc:0x401c3d44&gt;
</programlisting>
</informalexample>
  Este formato abreviado es mas adecuado y legible cuando se escriben pequeños procedimientos anónimos.
  </para>
</chapter>
<chapter>
  <title>Variables</title>
  <para>
  Ruby tiene tres clases de variables, una clase de constante y exactamente dos pseudo-variables. Las variables y las constantes no tienen tipo. Aunque las variables sin tipo tienen sus inconvenientes, presentan más ventajas y se adaptan mejor a la filosofía <emphasis>rápido y sencillo</emphasis> de Ruby
  </para>
  <para>
  En la mayoría de los lenguajes hay que declarar las variables para especificar su tipo, si se pueden modificar (e.g. si son constantes) e indicar su ámbito, ya que no es ningún problema el tipo y como vamos a ver, el resto se obtiene a partir del nombre, en Ruby no se necesita declarar las variables.
  </para>
  <para>
  El primer carácter de un identificador lo cataloga de un plumazo:
  <table frame="all">
  <title> Clases de variables </title>
  <tgroup cols="2" align="left" colsep="1" rowsep="1">
  <tbody>
  <row><entry>$</entry><entry>Variable global</entry></row>
  <row><entry>@</entry><entry>Variable instancia</entry></row>
  <row><entry>[a-z] ó _</entry><entry>Variable local</entry></row>
  <row><entry>[A-Z]</entry><entry>Constante</entry></row>
  </tbody>
  </tgroup>
  </table>
  </para>
  <para>
  Las únicas excepciones a lo expuesto en la tabla son las pseudo-variables de Ruby: <command>self</command>, que referencia al objeto que está en ese momento en ejecución y <command>nil</command> que es el valor nulo que toman las variables no inicializadas. Ambos tienen un identificador como de variable local pero <command>self</command> es una variable global que la mantiene el interprete y <command>nil</command> es una constante. Como estas son las únicas excepciones no provocan mucha confusión.
  </para>
  <para>
  No se debe asignar valores a <command>self</command> y <command>nil</command> principalmente porque un valor de <command>self</command> referencia al objeto de nivel superior:
<informalexample>
<programlisting>
ruby> self
main
ruby> nil
nil
</programlisting>
</informalexample>
  </para>
  <sect1>
    <title> Variables globales </title>
    <para>
    Una variable global tiene un nombre que comienza con <command>$</command>. Se puede utilizar en cualquier parte de un programa. Antes de inicializarse, una variable global tiene el valor especial <command>nil</command>.
<informalexample>
<programlisting>
ruby> $foo
nil
ruby> $foo = 5
5
ruby> $foo
5
</programlisting>
</informalexample>
    La variables globales deben utilizarse con parquedad. Son peligrosas porque se pueden modificar desde cualquier lugar. Una sobreutilización de variables globales puede dificultar la localización de errores; también indica que no se ha pensado detenidamente el diseño del programa. Siempre que se encuentre la necesidad de utilizar una variable global, hay que darle un nombre descriptivo para que no se pueda utilizar inadvertidamente para otra cosa (Llamarle <command>$foo</command> como se ha hecho en el ejemplo es probablemente una mala idea)
    </para>
    <para>
    Una característica notable de las variables globales es que se pueden trazar; se puede definir un procedimiento que se llame cada vez que se modifique el valor de la variable.
<informalexample>
<programlisting>
ruby> trace_var:$x, proc{print "$x es ahora ", $x, "\n"}
nil
ruby> $x = 5
$x es ahora 5
5
</programlisting>
</informalexample>
    Cuando una variable global se la atavía para que funcione con un disparador que se llama cada vez que se modifica, se la conoce como <emphasis>variable activa</emphasis>. Son útiles, por ejemplo, para mantener un GUI actualizado.
    </para>
    <para>
    Existe un grupo especial de variables cuyos nombres constan del símbolo del dolar (<command>$</command>) seguido de un carácter. Por ejemplo, <command>$$</command> contiene el número de identificación del proceso del intérprete de Ruby, y es de sólo lectura. A continuación se muestran las principales variables del sistema y su significado (acudir al <command>manual de referencia</command> de Ruby para más detalles)
    <table frame="all"><title>Variables de sistema</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
    <tbody>
    <row><entry>$!</entry><entry>Último mensaje de error</entry></row>
    <row><entry>$@</entry><entry>Posición del error</entry></row>
    <row><entry>$_</entry><entry>Última cadena leída con <command>gets</command></entry></row>
    <row><entry>$.</entry><entry>Último <command>número</command> de línea leído por el interprete</entry></row>
    <row><entry>$&</entry><entry>Última cadena que ha coincidido con una expresión regular</entry></row>
    <row><entry>$~</entry><entry>Última cadena que ha coincidido con una expresión regular como array de subexpresiones</entry></row>
    <row><entry>$<emphasis>n</emphasis></entry><entry>La <emphasis>n-ésima</emphasis> subexpresión regular de la última coincidencia (igual que <command>$~[n]</command>)</entry></row>
    <row><entry>$=</entry><entry>flag para tratar igual las mayúsculas y minúsculas</entry></row>
    <row><entry>$/</entry><entry>Separador de registros de entrada</entry></row>
    <row><entry>$\</entry><entry>Separador de registros de salida</entry></row>
    <row><entry>$0</entry><entry>El nombre del fichero del guión Ruby</entry></row>
    <row><entry>$*</entry><entry>El comando de la línea de argumentos</entry></row>
    <row><entry>$$</entry><entry>El número de identificación del proceso del intérprete Ruby</entry></row>
    <row><entry>$?</entry><entry>Estado de retorno del último proceso hijo ejecutado</entry></row>
    </tbody>
    </tgroup>
    </table>
    </para>
    <para>
    De las variables anteriores <command>$_</command> y <command>$~</command>, tienen ámbito local. Sus nombres sugieren que deberían tener ámbito global, pero son más útiles de esta forma y existen razones históricas para utilizar estos identificadores.
    </para>
  </sect1>
  <sect1>
    <title>Variables de instancia</title>
    <para>
    Una variable de instancia tiene un nombre que comienza con <command>@</command> y su ámbito está limitado al objeto al que referencia <command>self</command>. Dos objetos diferentes, aún cuando pertenezcan a la misma clase, pueden tener valores diferentes en sus variables de instancia. Desde el exterior del objeto, las variables de instancia, no se pueden alterar e incluso, no se pueden observar (es decir, en Ruby las variables de instancia nunca son públicas) a excepción de los métodos proporcionados explícitamente por el programador. Como con las variables globales, las variables de instancia tienen el valor <command>nil</command> antes de que se inicialicen
    </para>
    <para>
    Las variables de instancia en Ruby no necesitan declararse. Esto da lugar a una estructura flexible de los objetos. De hecho, cada variable de instancia se añade dinámicamente al objeto la primera vez que se la referencia
<informalexample>
<programlisting>
ruby> class InstTest
ruby|   def set_foo(n)
ruby|           @foo = n
ruby|   end
ruby|   def set_bar(n)
ruby|           @bar = n
ruby|   end
ruby| end
nil
ruby> i = InstTest.new
#&lt;InstTest:0x401c3e0c&gt;
ruby> i.set_foo(2)
2
ruby> i
#&lt;InstTest:0x401c3e0c  @foo=2&gt;
ruby> i.set_bar(4)
4
ruby> i
#&lt;InstTest:0x401c3e0c  @bar=4, @foo=2&gt;
</programlisting>
</informalexample>
    Obsérvese que <command>i</command> no informa del valor de <command>@bar</command> hasta que no se haya llamado al método <command>set_bar</command>
    </para>
  </sect1>
  <sect1>
    <title>Variables locales</title>
    <para>
    Una variable local tiene un nombre que empieza con una letra minúscula o con el carácter de subrayado (<command>_</command>). Las variables locales no tienen, a diferencia de las variables globales y las variables de instancia, el valor <command>nil</command> antes de la inicialización:
<informalexample>
<programlisting>
ruby> $foo
nil
ruby> @foo
nil
ruby> foo
ERR: (eval):1: undefined local variable or method `foo' for #&lt;Object:0x401d2c90&gt;
</programlisting>
</informalexample>
    La primera asignación que se realiza sobre una variable local actúa como una declaración. Si se referencia a una variable local no inicializada, el intérprete de Ruby piensa que se trata de una llamada a un método con ese nombre; de ahí el mensaje de error del ejemplo anterior.
    </para>
    <para>
    Generalmente el ámbito de una variable local es uno de los siguientes:
    <itemizedlist mark="bullet">
    <listitem><para><command>proc{ ... }</command></para></listitem>
    <listitem><para><command>loop{ ... }</command></para></listitem>
    <listitem><para><command>def ... end</command></para></listitem>
    <listitem><para><command>class ... end</command></para></listitem>
    <listitem><para><command>module ... end</command></para></listitem>
    <listitem><para>Todo el programa (si no es aplicable ninguno de los puntos anteriores)</para></listitem>
    </itemizedlist>
    </para>
    <para>
    En el siguiente ejemplo <command>define?</command> es un operador que verifica si un identificador está definido. Si lo está, devuelve una descripción del mismo, en caso contrario, devuelve <command>nil</command>. Como se ve el ámbito de <command>bar</command> es local al bucle, cuando se sale del bucle, <command>bar</command> está sin definir.
<informalexample>
<programlisting>
ruby> foo =44; print foo, "\n"; defined? foo
44
"local-variable"
ruby> loop{bar = 45;print bar, "\n"; break}; defined? var
45
nil
</programlisting>
</informalexample>
    Los objetos procedimiento que residen en el mismo ámbito comparten las variables locales que pertenecen a ese ámbito. En el siguiente ejemplo, la variable <command>bar</command> es compartida por <command>main</command> y los objetos procedimiento <command>p1</command> y <command>p2</command>:
<informalexample>
<programlisting>
ruby> bar=0
0
ruby> p1 = proc{|n| bar = n}
#&lt;Proc:0x401c3e34&gt;
ruby> p2 = proc{bar}
#&lt;Proc:0x401c3cf4&gt;
ruby> p1.call(5)
5
ruby> bar
5
ruby> p2.call
5
</programlisting>
</informalexample>
    Obsérvese que no se puede omitir la línea <command>bar=0</command> inicial; esta asignación es la que garantiza que el ámbito de <command>bar</command> incluirá a <command>p1</command> y <command>p2</command>. Si no, <command>p1</command> y <command>p2</command> tendrán al final cada uno su propia variable local <command>bar</command> y la llamada a <command>p2</command> dará lugar a un error de <quote>variable o método no definido</quote>.
    </para>
    <para>
    Una característica muy poderosa de los objetos procedimiento se deriva de su capacidad para recibir argumentos; las variables locales compartidas permanecen válidas incluso cuando se las pasa fuera de su ámbito original.
<informalexample>
<programlisting>
ruby> def box
ruby|   contents = 15
ruby|   get = proc{contents}
ruby|   set = proc{|n| contents = n}
ruby|   return get, set
ruby| end
nil
ruby> reader, writer = box
[#&lt;Proc:0x401c33d0&gt;, #&lt;Proc:0x401c33bc&gt;]
ruby> reader.call
15
ruby> writer.call(2)
2
ruby> reader.call
2
</programlisting>
</informalexample>
    Ruby es especialmente inteligente con respecto al ámbito. En el ejemplo, es evidente que la variable <command>contents</command> está compartida por <command>reader</command> y <command>writer</command>. Ahora bien, es posible definir varios pares reader-writer que utilicen <command>box</command> cada uno de los cuales comparten su propia variable <command>contents</command> sin interferir uno con otro.
<informalexample>
<programlisting>
ruby> reader_1, writer_1 = box
[#&lt;Proc:0x401c2e6c&gt;, #&lt;Proc:0x401c2e58&gt;]
ruby> reader_2, writer_2 = box
[#&lt;Proc:0x401c2cdc&gt;, #&lt;Proc:0x401c2cc8&gt;]
ruby> writer_1.call(99)
99
ruby> reader_1.call
99
ruby> reader_2.call
15
</programlisting>
</informalexample>
    </para>
  </sect1>
</chapter>
<chapter>
  <title>Constantes</title>
  <para>
  Una constante tiene un nombre que comienza con una letra  mayúscula. Se le debe asignar valor sólo una vez. En la implementación actual de Ruby, reasignar un valor a una constante genera un aviso y no un error (la versión no ANSI de eval.rb no informa de este aviso):
<informalexample>
<programlisting>
ruby> fluid = 30
30
ruby> fluid = 31
31
ruby> Solid = 32
32
ruby> Solid = 33
(eval):1: warning: already initialized constant Solid
33
</programlisting>
</informalexample>
  Las constantes se pueden definir en una clase, pero a diferencia de las variables de instancia, son accesibles desde el exterior de la misma.
<informalexample>
<programlisting>
ruby> class ConstClass
ruby|   C1=101
ruby|   C2=102
ruby|   C3=103
ruby|   def show
ruby|           print C1," ",C2, " ",C3,"\n"
ruby|   end
ruby| end
nil
ruby> C1
ERR: (eval):1: uninitialized constant C1
ruby> ConstClass::C1
101
ruby> ConstClass.new.show
101 102 103
nil
</programlisting>
</informalexample>
  Las constantes también se pueden definir en un módulo.
<informalexample>
<programlisting>
ruby> module ConstModule
ruby|   C1=101
ruby|   C2=102
ruby|   C3=103
ruby|   def showConstants
ruby|           print C1," ",C2," ",C3,"\n"
ruby|   end
ruby| end
nil
ruby> C1
ERR: (eval):1: uninitialized constant C1
ruby> include ConstModule
Object
ruby> C1
101
ruby> showConstants
101 102 103
nil
ruby> C1=99 # realmente una idea no muy buena
99
ruby> C1
99
ruby> ConstModule::C1 # La constante del módulo queda sin tocar ...
101
ruby> ConstModule::C1=99
ERR: (eval):1: compile error
(eval):1: parse error
ConstModule::C1=99
              ^
ruby> ConstModule::C1 #... independientemente de lo que hayamos jugado con ella
101
</programlisting>
</informalexample>
  </para>
</chapter>
<chapter>
  <title>Procesamiento de excepciones: <command>rescue</command></title>
  <para>
  Un programa en ejecución puede encontrarse con problemas inesperados. Podría no existir un fichero que desea leer, al salvar algunos datos se podría llenar un disco, un usuario podría introducir algún tipo de datos de entrada poco adecuados.
<informalexample>
<programlisting>
ruby> file = open("algun_fichero")
ERR: (eval):1:in `open': No such file or directory - "algun_fichero"
</programlisting>
</informalexample>
  Un programa robusto manejará estas situaciones prudente y elegantemente. Satisfacer estas expectativas puede ser una tarea exasperante. Los programadores en C se supone que deben verificar toda llamada al sistema que pudiese fallar y decidir inmediatamente que hacer.
<informalexample>
<programlisting>
FILE *file = fopen("algun_fichero","r");
if (file == NULL) {
  fprintf(stderr, "No existe el fichero\n");
  exit(1);
}
bytes_read = fread(buf,1,bytes_desired,file);
if (bytes_read != bytes_desired) {
  /* aquí, más gestión de errores ... */
}
...
</programlisting>
</informalexample>
  Con esta práctica tan aburrida los programadores tienden a ser descuidados y la incumplen siendo el resultado un programa que no gestiona adecuadamente las excepciones. Por otro lado, si se realiza adecuadamente, los programas se vuelven ilegibles debido a que hay mucha gestión de errores que embrolla el código significativo.
  </para>
  <para>
  En Ruby, como en muchos lenguajes modernos, se pueden gestionar las excepciones para bloques de código de una forma compartimentalizada, lo que permite tratar los imprevistos de forma efectiva sin cargar excesivamente ni al programador ni a cualquier otra persona que intente leer el código posteriormente. El bloque de código marcado con <command>begin</command> se ejecutará hasta que haya una excepción, lo que provoca que el control se transfiera a un bloque con el código de gestión de errores, aquel marcado con <command>rescue</command>. Si no hay excepciones, el código de <command>rescue</command> no se usa. El siguiente método devuelve la primera línea de un fichero de texto o <command>nil</command> si hay una excepción.
<informalexample>
<programlisting>
def first_line( filename )
  begin
    file = open(filename)
    info = file.gets
    file.close
    info # Lo último que se evalúa es el valor devuelto
  rescue
    nil # No puedo leer el fichero, luego no devuelvo una cadena
  end
end
</programlisting>
</informalexample>
  A veces nos gustaría evitar con creatividad un problema. A continuación, si el fichero no existe, se prueba a utilizar la entrada estándar:
<informalexample>
<programlisting>
begin
  file = open("algun_fichero")
rescue
  file = STDIN
end
begin
  # ... procesamos la entrada ...
rescue
  # ... aquí tratamos cualquier otra excepción
end
</programlisting>
</informalexample>
  Dentro del código de <command>rescue</command> se puede utilizar <command>retry</command> para intentar de nuevo el código en <command>begin</command>. Esto nos permite reescribir el ejemplo anterior de una forma más compacta:
<informalexample>
<programlisting>
fname = "algun_fichero"
begin
  file = open(fname)
  # ... procesamos la entrada ...
rescue
  fname = "STDIN"
  retry
end
</programlisting>
</informalexample>
  Sin embargo, este ejemplo tiene un punto débil. Si el fichero no existe este reintento entrará en un bucle infinito. Es necesario estar atento a estos escollos cuando se usa <command>retry</command> en el procesamiento de excepciones.
  </para>
  <para>
  Toda biblioteca Ruby genera una excepción si ocurre un error y se pueden lanzar excepciones explícitamente dentro del código. Para lanzar una excepción utilizamos <command>raise</command>. Tiene un argumento, la cadena que describe la excepción. El argumento es opcional pero no se debería omitir. Se puede acceder a él posteriormente a través de la variable global especial <command>$!</command>.
<informalexample>
<programlisting>
ruby> begin
ruby|   raise "error"
ruby| rescue
ruby|   print "Ha ocurrido un error: ", $!, "\n"
ruby| end
Ha ocurrido un error: error
nil
</programlisting>
</informalexample>
  </para>
</chapter>
<chapter>
  <title>Procesamiento de excepciones: <command>ensure</command></title>
  <para>
  Cuando un método termina su ejecución puede que se necesiten ciertas labores de limpieza. Quizás se tenga que cerrar un fichero abierto, se deban liberar los datos de los buffers, etc. Si siempre hubiese un único punto de salida para cada método, se podría poner con seguridad todo el código de limpieza en un lugar concreto y saber que se ejecutará, sin embargo, un método podría retornar en varios lugares o el código de limpieza podría saltarse inesperadamente debido a una excepción.
<informalexample>
<programlisting>
begin
  file = open("/tmp/algun_fichero","w")
  # ... Escribimos en el fichero ...
  file.close
end
</programlisting>
</informalexample>
  En el ejemplo superior, si ocurre una excepción durante la parte del código en que se escribe en el fichero, éste quedará abierto. Si no deseamos recurrir al siguiente tipo de redundancia:
<informalexample>
<programlisting>
begin
  file = open("/tmp/algun_fichero","w")
  # ... Escribimos en el fichero ...
  file.close
rescue
  file.close
  fail # levantamos una excepción
end
</programlisting>
</informalexample>
  Que es desgarbada y se nos escapa de las manos cuando el código se vuelve más complicado debido a que hay que tratar todo <command>return</command> y <command>break</command>.
  </para>
  <para>
  Por esta razón se añadió otra palabra reservada a esquema <command>begin ... rescue ... end</command>, <command>ensure</command>. El bloque de código de <command>ensure</command> se ejecuta independientemente del éxito o fracaso del bloque de código en <command>begin</command>.
<informalexample>
<programlisting>
begin
  file = open("/tmp/algun_fichero","w")
  # ... Escribimos en el fichero ...
rescue
  # ... gestionamos las excepciones ...
ensure
  file.close # ... Y esto se ejecuta siempre.
end
</programlisting>
</informalexample>
  Se puede utilizar <command>ensure</command> sin <command>rescue</command> y viceversa, pero si se utilizan en el mismo bloque <command>begin ... end</command>, <command>rescue</command> debe preceder a <command>ensure</command>.
  </para>
</chapter>
<chapter>
  <title> Accesores</title>
  <para>
  En un capítulo anterior se trató brevemente las variables instancia, pero no se hizo mucho con ellas. Las variables instancia de un objeto son sus atributos, eso que diferencia a un objeto de otro dentro de la misma clase. Es importante poder modificar y leer estos atributos; lo que supone definir métodos denominados <emphasis>accesores de atributos</emphasis>. Veremos en un momento que no siempre hay que definir los métodos accesores explícitamente, pero vayamos paso a paso. Los dos tipos de accesores son los de <emphasis>escritura</emphasis> y los de <emphasis>lectura</emphasis>.
<informalexample>
<programlisting>
ruby> class Fruta
ruby|   def set_kind(k) # escritor
ruby|     @kind = k
ruby|   end
ruby|   def get_kind    # lector
ruby|     @kind
ruby|   end
ruby| end
nilx
ruby> f1 = Fruta.new
#&lt;Fruta:0x401c4410&gt;
ruby> f1.set_kind("melocotón")      #utilizamos el escritor
"melocotón"
ruby> f1.get_kind               #utilizamos el lector
"melocotón"
ruby> f1                        #inspeccionamos el objeto
#&lt;Fruta:0x401c4410  @kind="melocotón"&gt;
</programlisting>
</informalexample>
  Sencillo; podemos almacenar y recuperar información sobre la clase de fruta que queremos tener en cuenta. Pero los nombres de nuestros métodos son un poco largos. Los siguientes son más breves y convencionales:
<informalexample>
<programlisting>
ruby> class Fruta
ruby|   def kind=(k)
ruby|     @kind = k
ruby|   end
ruby|   def kind
ruby|     @kind
ruby|   end
ruby| end
nil
ruby> f2 = Fruta.new
#&lt;Fruta:0x401c30c4&gt;
ruby> f2.kind = "banana"
"banana"
ruby> f2.kind
"banana"
</programlisting>
</informalexample>
  </para>
  <sect1>
    <title> El método <command>inspect</command></title>
    <para>
    En estos momentos es adecuada una pequeña disgresión. Ya se habrá notado que cuando deseamos ver directamente un objeto se nos muestra algo críptico como lo siguiente <command>#&lt;Fruta:0x401c30c4&gt;</command>. Este es un comportamiento por defecto que se puede modificar. Todo los que se necesita es definir un método denominado <command>inspect</command>. Éste puede devolver una cadena que describa el objeto de una forma razonable, incluyendo el estado de alguna o todas las variables instancia.
<informalexample>
<programlisting>
ruby> class Fruta
ruby|   def inspect
ruby|     "una fruta de la variedad " + @kind
ruby|   end
ruby| end
nil
ruby> f2
una fruta de la variedad banana
</programlisting>
</informalexample>
    Un método relacionado es <command>to_s</command> (convertir a cadena) que se utiliza al imprimir un objeto. En general se puede pensar que <command>inspect</command> es una herramienta para cuando se escriben y depuran programas, y <command>to_s</command> una forma de refinar la salida de un programa. <command>eval.rb</command> utiliza <command>inspect</command> cuando muestra resultados. Se puede utilizar el método <command>p</command> para obtener con sencillez resultados para la depuración de programas.
<informalexample>
<programlisting>
# las dos líneas siguientes son equivalentes
p anObject
print anObject.inspect, "\n"
</programlisting>
</informalexample>
    </para>
  </sect1>
  <sect1>
    <title>Facilitando la creación de accesores</title>
    <para>
    Dado que muchas variables instancia necesitan métodos accesores, Ruby proporciona abreviaturas para las formas convencionales.
    <table frame="all"><title>Accesores</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
    <thead>
    <row><entry>Abreviatura</entry><entry>Efecto</entry></row>
    </thead>
    <tbody>
    <row><entry><command>attr_reader :v</command></entry>
         <entry><command>def v; @v; end</command></entry>
    </row>
    <row><entry><command>attr_writer :v</command></entry>
         <entry><command>def v=(value); @v=value; end</command></entry>
    </row>
    <row><entry><command>attr_accesor :v</command></entry>
         <entry><command>attr_reader :v; attr_writer :v</command></entry>
    </row>
    <row><entry><command>attr_accesor :v, :w</command></entry>
         <entry><command>attr_accesor :v; attr_accessor :w</command></entry>
    </row>
    </tbody>
    </tgroup>
    </table>
    </para>
    <para>
    Tomemos ventaja de esto y añadamos información fresca. Primero pediremos la generación de un escritor y un lector y luego incorporaremos la nueva información en <command> inspect</command>.
<informalexample>
<programlisting>
ruby> class Fruta
ruby|   attr_accessor :condition
ruby|   def inspect
ruby|     "una " + @kind + " " + @condition
ruby|   end
ruby| end
nil
ruby> f2.condition = "madura"
"madura"
ruby> f2
una banana madura
</programlisting>
</informalexample>
    </para>
  </sect1>
  <sect1>
    <title>Más diversión con la fruta</title>
    <para>
       Si nadie se come nuestra fruta madura, quizás es momento de que pague su precio.
<informalexample>
<programlisting>
ruby> class Fruta
ruby|   def time_passes
ruby|           @condition = "podrida"
ruby|   end
ruby| end
nil
ruby> f2
una banana madura
ruby> f2.time_passes
"podrida"
ruby> f2
una banana podrida
</programlisting>
</informalexample>
       Pero mientras estábamos jugando con esto se ha introducido un pequeño problema. ¿Qué ocurre si intentamos crear una tercera pieza de fruta en estos momentos? Recuérdese que las variables instancia no existen hasta que no se les asigne valor.
<informalexample>
<programlisting>
ruby> f3 = Fruta.new
ERR: failed to convert nil into String
</programlisting>
</informalexample>
       El que se queja es el método <command>inspect</command> y con motivos. Se le ha indicado que informe sobre el tipo y la condición de una pieza de fruta, pero <command>f3</command> no tiene asignado ninguno de sus atributos. Si se quiere, es posible redefinir este método para que compruebe que las variables instancia están definidas (utilizando el método <command>defined?</command>) e informar de ellos sólo si es así aunque esto puede que no sea de mucha utilidad dado que toda pieza de fruta es de un tipo y está en una determinada condición, parece que se debiera asegurar que los atributos se definen de alguna forma. Este es el tema del siguiente capítulo.
    </para>
  </sect1>
</chapter>
<chapter>
  <title>Inicialización de objetos</title>
  <para>
  La clase Fruta del capítulo anterior tiene dos variables instancia, una para describir la clase de fruta y otra para describir su estado. Después de redefinir el método <command>inspect</command> de la clase, nos dimos cuenta de que no tiene sentido que una pieza de fruta carezca de esas características. Afortunadamente, Ruby tiene un mecanismo para asegurar que las variables instancia se inicialicen siempre.
  </para>
  <sect1><title>El método <command>initialize</command></title>
  <para>
  Siempre que Ruby crea un objeto nuevo, busca un método llamado <command>initialize</command> y lo ejecuta. Luego lo más sencillo que se puede hacer es utilizar este método para dar valores a las variables instancia, así el método <command>inspect</command> no tiene nada por lo que quejarse.
<informalexample>
<programlisting>
ruby> class Fruta
ruby|   def initialize
ruby|     @kind = "manzana"
ruby|     @condition = "madura"
ruby|   end
ruby| end
nil
ruby> f4 = Fruta.new
una manzana madura
</programlisting>
</informalexample>
  </para>
  </sect1>
  <sect1><title>Modificando suposiciones por requisitos</title>
  <para>
  Hay veces en las que no tiene mucho sentido la presencia de valores por defecto. ¿Existe una cosa tal como una fruta por defecto? Es preferible que se deba especificar el tipo en el momento de la creación de cada pieza de fruta. Para hacer esto se debe añadir un argumento formal al método <command>initialize</command>. Por razones en las que no vamos a entrar, los argumentos que se entregan a <command>new</command> se pasan a <command>initialize</command>
<informalexample>
<programlisting>
ruby> class Fruta
ruby|   def initialize(k)
ruby|     @kind = k
ruby|     @condition = "madura"
ruby|   end
ruby| end
nil
ruby> f5 = Fruta.new "pera"
una pera madura
ruby> f6 = Fruta.new
ERR: (eval):1:in `initialize': wrong # of arguments(0 for 1)
</programlisting>
</informalexample>
  </para>
  </sect1>
  <sect1><title>Inicialización flexible</title>
  <para>
  Hemos visto que una vez que se asocia un argumento al método <command>initialize</command> no se puede omitir sin que se genere un error. Si queremos ser más considerados podemos utilizar el argumento si se proporciona, y en caso contrario, recurrir al valor por defecto.
<informalexample>
<programlisting>
ruby> class Fruta
ruby|   def initialize(k="manzana")
ruby|     @kind = k
ruby|     @condition = "madura"
ruby|   end
ruby| end
nil
ruby> f5 = Fruta.new "pera"
una pera madura
ruby> f6 = Fruta.new
una manzana madura
</programlisting>
</informalexample>
  Se pueden utilizar los valores por defecto de un argumento en cualquier método no sólo en <command>initialize</command>. Los argumentos hay que organizarlos de tal forma que aquellos con valores por defecto aparezcan al final de la lista.

  </para>
  <para>
  A veces es útil tener varias formas de inicializar un objeto. Aunque está fuera del ámbito de este tutorial, Ruby permite reflexión sobre los objetos y listas de argumentos de tamaño variable. Ambas técnicas combinadas permiten realizar sobrecarga de métodos.
  </para>
  </sect1>
</chapter>
<chapter>
  <title>Entresijos</title>
  <para>
  Este capítulo trata algunos problemas prácticos.
  </para>
  <sect1><title>Delimitadores de sentencias</title>
  <para>
  Algunos lenguajes requieren algún tipo de puntuación, a menudo el punto y coma (;), para finalizar toda sentencia de un programa. Por el contrario, Ruby recurre al convenio seguido por shells como <command>sh</command> y <command>csh</command>. Varias sentencias en una línea se han de separar con puntos y comas sin que se necesite al final de la línea; LF se trata como un punto y coma. Si una línea termina en \ (backslash) se ignora el LF que le sigue; lo que permite tener una única línea lógica que comprende varias líneas físicas.
  </para>
  </sect1>
  <sect1><title>Comentarios</title>
  <para>
  ¿Por qué escribir comentarios? Aunque el buen código tiende a ser auto-descriptivo, a menudo es útil realizar comentarios en el margen. Es un error creer que otras personas que examinen el código comprendan inmediatamente lo que se pretendía hacer. Aparte, y desde una perspectiva práctica, quién de nosotros no ha tenido que realizar una corrección o mejora en un programa después de un cierto periodo de tiempo y decir: he escrito esto, pero ¿qué demonios se supone que hace?
  </para>
  <para>
  Algunos programadores experimentados señalarán, con bastante razón, que comentarios contradictorios o desactualizados pueden ser peor que ningún comentario en absoluto. Evidentemente, los comentarios no deben ser un sustituto de un código legible; si el código es poco claro, es probable que también sea erróneo. Es probable que se necesite comentar más cuando se está aprendiendo Ruby y menos cuando se llegue a expresar las ideas en código sencillo, elegante y legible.
  </para>
  <para>
  Ruby sigue el convenio, común entre los lenguajes de guiones, de utilizar el símbolo de la almohadilla para indicar el comienzo de un comentario. El interprete ignora cualquier cosa que siga a una almohadilla, que no esté entre comillas, hasta el final de la línea en la que aparece
  </para>
  <para>
  Para facilitar la escritura de grandes bloques de comentarios el interprete también ignora cualquier cosa comprendida entre una línea inicial con <command>=begin</command> y una final con <command>=end</command>.
<informalexample>
<programlisting>
#!/usr/bin/ruby
  
=begin
  ***********************************************************************
  Este es un bloque de comentarios, algo que se escribe en beneficio de
  los lectores (incluido uno mismo). El interprete lo ignora. No hay
  necesidad de utilizar '#' al comienzo de cada línea
  ***********************************************************************
=end
</programlisting>
</informalexample>
  </para>
  </sect1>
  <sect1><title>Organización del código</title>
  <para>
  El intérprete de Ruby procesa el código conforme lo lee. No existe nada semejante a una fase de compilación; si algo no se ha leído todavía, sencillamente está sin definir.
<informalexample>
<programlisting>
# Este código da lugar al error "undefined method":

print successor(3),"\n"

def successor(x)
  x + 1
wend
</programlisting>
</informalexample>
  Como cabría esperar a primera vista esto no fuerza a que se deba organizar el código de un modo estrictamente bottom-up. Cuando el intérprete encuentra la definición de un método puede incluir con seguridad referencias no definidas, siempre y cuando se asegure que se definirán antes de llamar realmente al método:
<informalexample>
<programlisting>
# Conversión de fahrenheit a celsius, dividida en dos pasos

def f_to_c(f)
  scale (f - 32.0) # Referencia adelantada, pero es correcto
end

def scale(x)
  x * 5.0 / 9.0
end

printf "%.1f es una temperatura agradable.\n",f_to_c( 72.3 )
</programlisting>
</informalexample>
  Aunque pueda parecer un poco menos adecuado que lo que se suele usar en Perl o Java, es menos restrictivo que intentar escribir código C sin prototipos (lo que obliga a mantener siempre una ordenación parcial de quién referencia a quién). Poner el código de más alto nivel al final del fichero, funciona siempre. Y esto no es una gran molestia aunque a primera vista lo pudiese parecer. Una forma sensata e indolora de conseguir el comportamiento que se desea es definir una función <command>main</command> al principio del fichero y llamarla al final.
<informalexample>
<programlisting>
#!/usr/bin/ruby

def main
  # Aquí el código de nivel superior
end

  # ... Todo el código de apoyo aquí, organizado como se crea más adecuado ...

main # ... y se inicia la ejecución aquí.
</programlisting>
</informalexample>
  También sirve de ayuda que Ruby proporcione herramientas para dividir programas complicados en bloques legibles, reutilizables, y relacionados lógicamente. Se ha visto la utilización de <command>include</command> para acceder a módulos. Pero también pueden ser útiles <command>load</command> y <command>require</command>. <command>load</command> funciona como si el fichero al que referencia fuese copiado y pegado (algo parecido a la directiva <command>#include</command> del preprocesador C). <command>require</command> es un poco más sofisticada, carga el código como mucho sólo una vez y cuando se necesite. Existen otras diferencias entre <command>load</command> y <command>require</command>; para más información se puede acudir el manual del lenguaje o a la FAQ.
  </para>
  </sect1>
  <sect1><title>Esto es todo</title>
  <para>
  Este tutorial debería se suficiente para arrancar y escribir programas en Ruby. Si surgen más preguntas se puede bucear en el <emphasis>manual de referencia</emphasis> para aprender Ruby con más detalle. También son fuentes importantes de recursos la <emphasis>FAQ</emphasis> y la <emphasis>biblioteca de referencia</emphasis>
  </para>
  <para>
  ¡Suerte y felices codificaciones!
  </para>
  </sect1>
</chapter>
</book>
