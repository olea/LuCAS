<!--
Nota legal:

   Linux Network Administration Guide, por Olaf Kirch et al.

   La traducción al español se publica bajo la licencia GFDL,
siendo texto de portada el siguiente:

Linux Network Administrator's Guide
by Olaf Kirch and Terry Dawson
Copyright  (c) 1993 Olaf Kirch
Copyright  (c) 2000 Terry Dawson
Copyright on O'Reilly printed version (c) 2000 O'Reilly & Associates

y siendo secciones invariantes, la sección de Agradecimientos,
la sección titulada «La traducción al español», el apéndice C; así
como esta nota.

Capítulo traducido por:

Sebastián Gurin, (Cancerbero) <anon@adinet.com.uy>
Jesus Climent, (data) <jesus.climent@hispalinux.es>
Francisco Javier Fernández (cyphra)
Revisión por Francisco Javier Fernández (cyphra) <serrador@arrakis.es>

Glosario:  
"bracket" : corchete (los símbolos [])
"command": orden, instrucción (NUNCA comando)
"host": anfitrión, hospedador (a veces traducido por nodo)
"hub": concentrador
"macro-file": fichero de macros
"mailer": transporte de correo
"mail-hosts": hospedajes de correo
"match": coincide
"smart-anfitrión": anfitrión inteligente 
"relay-anfitrión": anfitrión de retransmisión
"rulesets": conjuntos de reglas (NI juegos de reglas NI reglas de juego)
"token" : símbolo

Marcas: 
buscando la cadena "ATENCION" llegas a errores detectados 
buscando la cadena "REVISIONn"  n IN [1..4] llegas a donde terminó la revisión y puedes leer tareas que hay por hacer.
-->

<chapter id="X-087-2-sendmail"><title>Sendmail</title>
<INDEXTERM id="idx-configuringsendmail" class=startofrange><PRIMARY>configurando</PRIMARY><SECONDARY>sendmail</SECONDARY></INDEXTERM>
<INDEXTERM id="idx-commandsendmailcommand-1" class=startofrange><PRIMARY>sendmail</PRIMARY></INDEXTERM>

<sect1><title>Introducción a sendmail</title>
<para>
Se dice que no se es un <emphasis>verdadero</emphasis> administrador de sistemas 
Unix hasta que se ha editado fichero <filename>sendmail.cf</filename>. Se dice 
asimismo que se está loco si se intenta hacerlo dos veces.
</para>

<para>
<command>sendmail</command> es un programa increíblemente potente. Y también, 
para la mayoría de la gente, increíblemente difícil de aprender y comprender. 
Un programa cuyo manual definitivo de referencia (<command>sendmail</command>, 
por Bryan Costales y Eric Allman, publicado por O'Reilly), ocupa 1,050 páginas, 
lo que es suficiente para espantar a cualquiera. Información sobre referencias 
a <command>sendmail</command> se pueden encontrar en la bibligrafía, al final 
de este libro. 
</para>

<para>
<indexterm><primary>sendmail.cf (fichero)</primary></indexterm>
Afortunadamente, las nuevas versiones de sendmail son diferentes. Ya no se necesitará 
más editar directamente el enigmático fichero <filename>sendmail.cf</filename>; las 
nuevas versiones proveen de una herramienta de configuración, la cual creará el fichero 
<filename>sendmail.cf</filename> por nosotros basándose en ficheros de macros mucho más 
simples. No se necesitará entender la sintaxis complicada del fichero <filename>sendmail.cf
</filename>; los ficheros de macros no lo requieren. En lugar de eso, sólo se necesitará listar 
ítems, como por ejemplo el nombre de las características que se desee incluir en nuestra 
configuración, y especificar algunos de los parámetros que determinan cómo operará esa 
característica. Para esto se usará una utilidad Unix tradicional llamada <command>m4</command>, 
la cual toma nuestros ficheros de macros de configuración y los combina con los datos obtenidos 
de las plantillas que contienen la sintaxis actual de <filename>sendmail.cf</filename>, de 
forma tal que ganará nuestro propio fichero <filename>sendmail.cf</filename>. 
</para>

<para>
En este capítulo se presentará <command>sendmail</command>, se le describirá, se enseñará cómo 
instalarlo, configurarlo y testearlo, usando como ejemplo la Cervecera Virtual. Si la información 
que se presenta aquí, hace que el proceso de configurar <command>sendmail</command> sea menos 
desalentador, esperamos que se gane la suficiente autoestima como para que el usuario intente 
abordar configuraciones más complejas por sí mismo. 
</para>

</sect1>

<sect1><title>Instalando Sendmail</title>
<para>
<indexterm><primary>sendmail</primary><secondary>instalando</secondary></indexterm>
<indexterm><primary>instalando</primary><secondary>sendmail</secondary></indexterm>
El agente de transporte de correo, <command>sendmail</command>, se incluye preempaquetado 
en casi todas las distribuciones de GNU/Linux. La instalación en estos casos es relativamente sencilla. 
Sin embargo, existen algunas razones para instalar <command>sendmail</command> desde el código 
fuente, especialmente si nos importa la seguridad. El programa <command>sendmail</command> es 
muy complejo y se ha ganado la reputación con el paso de los años por contener fallos que permiten 
abrir brechas en la seguridad. Uno de los más conocidos ejemplos es el gusano de Internet RTM, el cuál 
sacó provecho de un problema de desbordamiento del búfer en versiones antiguas de <command>sendmail
</command>. Este ejemplo ya se detalló brevemente en  <xref linkend="X-087-2-firewall">. La mayoría 
de los abusos<footnote><para>N. del T: &ldquo;exploits&rdquo; en el original. </para>
</footnote> que utilicen desbordamientos del búfer, dependen de que todas las copias de <command>sendmail
</command> sean idénticas en las diferentes máquinas, ya que los "exploits" se basan en datos almacenados 
en ubicaciones específicas. Esto, desde luego, es precisamente lo que ocurre con <command>sendmail
</command> instalado en las distribuciones GNU/Linux. Compilar <command>sendmail</command> 
desde el código fuente por usted puede ayudar a reducir este riesgo. Las versiones modernas de <command>
sendmail</command> son menos vulnerables, ya que vienen con exámenes extremadamente cuidadosos en 
cuanto a la seguridad, la cual se ha vuelto una inquietud ampliamente generalizada en la comunidad 
de Internet. 
</para>


<para>
<indexterm><primary>código, obteniendo el</primary><secondary>sendmail</secondary></indexterm>
<indexterm><primary>sendmail</primary><secondary>obteniendo el código</secondary></indexterm>
El código fuente de <command>sendmail</command> está disponible por FTP anónimo en el servidor 
<systemitem role="sitename">ftp.sendmail.org</systemitem>.
</para>

<para>
La compilación es bastante simple, ya que el paquete de los fuentes de <command>sendmail</command> 
soporta directamente a GNU/Linux. Los pasos a seguir para compilar <command>sendmail</command> se resumen en:

<screen><userinput>
# cd /usr/local/src
# tar xvfz sendmail.8.9.3.tar.gz
# cd src
# ./Build
</userinput>
</screen>

Para completar la instalación de los ficheros binarios resultantes, se necesitará los permisos 
de <literal>root</literal>, usando:

<screen><userinput>
# cd obj.Linux.2.0.36.i586
# make install
</userinput>
</screen>

Se han instalado ahora los binarios de <command>sendmail</command> en el directorio <filename>/usr/sbin</filename>. 
Muchos enlaces simbólicos al ejecutable <command>sendmail</command> también se instalarán en el directorio 
<filename>/usr/bin/</filename>. Se comentará sobre estos enlaces, cuando se discutan las tareas comunes al 
utilizar <command>sendmail</command>.
</para>
</sect1>

<sect1><title>Un Vistazo a los Ficheros de Configuración</title>

<para>
<INDEXTERM id="sendmail.config.files" class=startofrange><PRIMARY>sendmail</PRIMARY><SECONDARY>ficheros de configuración</SECONDARY></INDEXTERM>
<INDEXTERM id="config.files.sendmail" class=startofrange><PRIMARY>ficheros de configuración</PRIMARY><SECONDARY>sendmail</SECONDARY></INDEXTERM>
Tradicionalmente, <command>sendmail</command> era configurado a través de un fichero de configuración del sistema 
(llamado usualmente
<filename>/etc/mail/sendmail.cf</filename>, o en otras distribuciones más antiguas,
<filename>/etc/sendmail.cf</filename>, o incluso
<filename>/usr/lib/sendmail.cf</filename>&thinsp;) que no se parece en 
nada a ningún lenguaje que haya visto usted antes. La edición del fichero
<filename>sendmail.cf</filename> para proporcionar un comportamiento a medida
puede ser una experiencia traumática.
</para>

<para>
<?troff .hw understand>
A día de hoy, <command>sendmail</command> crea todas las opciones de 
configuracion a través de macros, con una sintaxis fácil de entender.
El sistema de macros genera configuraciones que cubren muchas de las
instalaciones, pero siempre se tiene la opción de afinar manualmente 
el fichero resultado, <filename>sendmail.cf</filename>, para trabajar
en un entorno más complejo.
</para>

</sect1>

<sect1><title>Los Ficheros sendmail.cf y sendmail.mc</title>

<para>
<INDEXTERM><PRIMARY>m4, procesador de macros</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail.df, fichero</PRIMARY></INDEXTERM>
<INDEXTERM id="sendmail.cf.file" class=startofrange><PRIMARY>sendmail.cf, fichero</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail.mc, fichero</PRIMARY></INDEXTERM>
El programa procesador de macros <command>m4</command> genera el 
fichero <filename>sendmail.df</filename> cuando procesa el fichero de configuración
de macros proporcionado por el administrador del sistema local. A través de lo
que resta de este capítulo, nos referiremos al fichero de configuración como
el fichero <filename>sendmail.mc</filename>.
</para>

<para>
EL proceso de configuración es básicamente una forma de crear un fichero
<filename>sendmail.mc</filename> apropiado que incluya macros que describan
su configuración deseada. Las macros son expresiones que el procesador de macros
<command>m4</command> entiende y expande en la sintaxis compleja de <filename>
sendmail.cf</filename>. Las expresiones macro se componen del nombre de la macro 
(el texto en letras mayúsculas al principio), que se asemejan a una función en un 
lenguaje de programación, y algunos parámetros (el texto entre corchetes) que se 
utilizan en la expansión. Los parámetros pueden ser pasados literalmente a la salida 
de  <filename>sendmail.cf</filename> o pueden ser utilizados para controlar la manera 
en que se realiza el procesamiento de la macro.
</para>

<para>
El fichero <filename>sendmail.mc</filename> para una configuración mínima (UUCP o
SMTP con todos los mensajes no locales retransmitidos a un anfitrión inteligente 
conectado directamente a Internet) puede ser tan corto como 10 o 15 líneas, 
excluyendo comentarios.
</para>

<sect2><title>Dos Ejemplos de los Ficheros  sendmail.mc</title>

<para>
<INDEXTERM><PRIMARY>fichero sendmail.mc </PRIMARY><SECONDARY>dos ejemplos</SECONDARY></INDEXTERM>
Si usted es un administrador de varios hospedajes de correo distintos, quizá no quiera
nombrar su fichero de configuración <filename>sendmail.mc</filename>.
En vez de ésto, es practica usual nombrarlo después del nombre del anfitrión,
&mdash;<filename>vstout.m4</filename> en nuestro caso. El nombre no importa realmente
en tanto que la salida sea llamada <filename>sendmail.cf</filename>. Proporcionar un nombre único
para el fichero de configuración de cada anfitrión le permite conservar todos los ficheros de 
configuración en el mismo directorio y es tan sólo una conveniencia administrativa. 
Echemos un vistazo a dos ejemplos de ficheros de configuración de macros para que sepamos
dónde estamos apuntando.
</para>

<para>
<INDEXTERM><PRIMARY>configurar</PRIMARY><SECONDARY>sendmail</SECONDARY><TERTIARY>para SMTP</TERTIARY></INDEXTERM>
La mayoría de las configuraciones de <command>sendmail</command> de la actualidad usan SMTP únicamente. Es 
muy sencillo configurar <command>sendmail</command> para SMTP. 
<xref linkend="X-087-2-sendmail.mc.smtp"> espera que esté disponible un servidor de nombres DNS 
para resolver anfitriones e intentará aceptar y enviar todo el correo
para los anfitriones usando únicamente SMTP.
</para>

<example id="X-087-2-sendmail.mc.smtp">
<title>Ejemplo de Fichero de Configuración vstout.smtp.m4</title>
<screen>
divert(-1)
#
# Ejemplo de fichero de configuración para vstout - smtp exclusivamente
#
divert(0)
VERSIONID(`@(#)sendmail.mc	8.7 (Linux) 3/5/96')
OSTYPE(`linux')
#
# Incluye soporte para los protocolos de transporte locales y smtp
MAILER(`local')
MAILER(`smtp')
#
FEATURE(rbl)
FEATURE(access_db)
# fin
</screen>
</example>

<para>
Un fichero <filename>sendmail.mc</filename> para 
<systemitem role="sitename">vstout</systemitem> en la Cervecera Virtual se muestra 
en <xref linkend="X-087-2-sendmail.mc.uucpsmtp">.
<systemitem role="sitename">vstout</systemitem> usa SMTP para comunicarse con todos los anfitriones
en la LAN de la cervecera, y verá la semejanza con la configuración genérica  para  SMTP exclusivamente 
que acaba de presentarse. En suma, la configuración de <systemitem role="sitename">vstout</systemitem> 
envía todo el correo para otros destinatarios <systemitem role="sitename">moria</systemitem>, 
su anfitrión de retransmisión a Internet por UUCP.
</para>

<example id="X-087-2-sendmail.mc.uucpsmtp">
<title>Ejemplo de Fichero de Configuración para vstout.uucpsmtp.m4</title>
<screen>
divert(-1)
#
# Ejemplo de fichero de configuración para vstout
#
divert(0)
VERSIONID(`@(#)sendmail.mc	8.7 (Linux) 3/5/96')
OSTYPE(`linux')
dnl
# moria es nuestro anfitrión inteligente (smart anfitrión), usando el transporte "uucp-new".
define(`SMART_ANFITRIÓN', `uucp-new:moria')
dnl
# Soportar los protocolos de transporte de correo local, smtp y uucp.
MAILER(`local')
MAILER(`smtp')
MAILER(`uucp')
LOCAL_NET_CONFIG
# Esta regla asegura que todo correo local sea entregado usando
# transporte smtp, todo lo demás irá por el anfitrión inteligente.
R$* &lt; @ $* .$m. &gt; $*	$#smtp $@ $2.$m. $: $1 &lt; @ $2.$m. &gt; $3
dnl
#
FEATURE(rbl)
FEATURE(access_db)
# fin
</screen>
</example>

<para>
Si se comparan y contrastan las dos configuraciones, quizá sea capaz de
inferir qué hace cada uno de los parámetros de configuración. Los explicaremos todos ellos en detalle.
</para>
</sect2>

<sect2><title>Parámetros sendmail.mc Típicamente Empleados</title>
<para>
<INDEXTERM id="sendmail.mc.parameters" class=startofrange><PRIMARY>fichero sendmail.mc </PRIMARY><SECONDARY>parámetros</SECONDARY></INDEXTERM>
<INDEXTERM id="macro.defs.sendmail" class=startofrange><PRIMARY>definiciones de macro, fichero sendmail.mc </PRIMARY></INDEXTERM>
Unos pocos de los items en el fichero  <filename>sendmail.mc</filename> se requieren
todo el tiempo; otros pueden ignorarse si las configuraciones por omisión le sirven.
La secuencia general de las definiciones en el fichero <filename>sendmail.mc</filename>
son como lo que sigue:

<orderedlist>
<listitem><para>
<systemitem role="keyword">VERSIONID</systemitem>
</para></listitem>

<listitem><para>
<systemitem role="keyword">OSTYPE</systemitem>
</para></listitem>

<listitem><para>
<systemitem role="keyword">DOMAIN</systemitem>
</para></listitem>

<listitem><para>
<systemitem role="keyword">FEATURE</systemitem>
</para></listitem>

<listitem><para>
Local macro definitions
</para></listitem>

<listitem><para>
<systemitem role="keyword">MAILER</systemitem>
</para></listitem>

<listitem><para>
<systemitem role="keyword">LOCAL_*</systemitem> conjuntos de reglas (rulesets)
</para></listitem>
</orderedlist>

Hablaremos acerca de cada uno en las siguientes secciones y nos 
referiremos a nuestros ejemplos en 
<xref linkend="X-087-2-sendmail.mc.smtp"> y
<xref linkend="X-087-2-sendmail.mc.uucpsmtp">, cuando sea apropiado, para explicarlos.
</para>

<sect3><title>Comentarios</title>
<para>
Las líneas en el fichero <filename>sendmail.mc</filename> que comiencen con el carácter literal <literal>#</literal> no son analizadas por
<command>m4</command>, y por omisión serán sacadas directamente a la salida en el fichero <filename>sendmail.cf</filename>. Esto es útil 
si se desea comentar qué está haciendo su configuración en los ficheros de entrada y salida.
</para>

<para>
Para permitir comentarios en su <filename>sendmail.mc</filename> que  <emphasis>no</emphasis> sean colocados en el fichero <filename>sendmail.cf</filename>, 
puede utilizar la orden <command>m4</command> <systemitem role="keyword">divert</systemitem> y las etiquetas<systemitem role="keyword">dnl</systemitem>.
<systemitem role="keyword">divert(-1)</systemitem> hará que toda la salida se detenga. <systemitem role="keyword">divert(0)</systemitem> hará que la salida 
sea restaurada al valor predeterminado. Cualquier salida generada por líneas entre éstos será descartada. En nuestro ejemplo, hemos usado este mecanismo para 
proporcionar un comentario que aparece sólamente en el fichero <filename>sendmail.mc</filename>. Para conseguir el mismo resultado para una línea sencilla, 
puede utilizar la etiqueta <systemitem role="keyword">dnl</systemitem> que significa, literalmente, &ldquo;<footnote><para>starting at the beginning of the 
next line, delete all characters up to and including the next newline.</para></footnote> empezando al principo de la siguiente línea, borrar todos los 
caracteres hacia arriba incluyendo la nueva línea&rdquo; Hemos usado esto en nuestro ejemplo también. 
</para>

<para>
Éstas son características estándar de <command>m4</command> y se puede obtener más información sobre ellas en su página de manual.
</para>
</sect3>

<sect3><title>VERSIONID y OSTYPE</title>
<para>
<INDEXTERM><PRIMARY>VERSIONID definición de macro</PRIMARY></INDEXTERM>
<screen>
VERSIONID(`@(#)sendmail.mc  8.9 (Linux) 01/10/98')
</screen>
<?troff .Nd 10>
La macro <literal>VERSIONID</literal> es opcional, pero es útil para grabar la versión de configuración de sendmail en el fichero <filename>sendmail.cf</filename>. 
Así que a menudo se encontrará con ello, y nosotros lo recomendamos. En cualquier caso, asegúrese de incluir:
</para>

<para>
<screen>
OSTYPE(`linux')
</screen>

<INDEXTERM><PRIMARY>OSTYPE, definición de macro</PRIMARY></INDEXTERM>
Esta es probablemente la definición más importante. La macro <literal>OSTYPE</literal> provoca que se incluya un fichero de definiciones que son buenas opciones predeterminadas 
para su sistema operativo. La mayoría de las definiciones en un fichero macro <literal>OSTYPE</literal> configuran los nombres de ruta de varios ficheros de configuración, 
transporte de correo <footnote><para>N. del T. mailers en el original</para></footnote> y argumentos, y la localización de directorios  que usa  sendmail para almacenar mensajes. 
La distribución estándar de código fuente de sendmail incluye un fichero de este tipo para GNU/Linux, que se incluye en el ejemplo previo. Algunas distrbuciones de GNU/Linux, 
particularmente la distribución Debian, incluye su propio fichero de definiciones que es compatible con la jerarquía de ficheros de GNU/Linux. Cuando su distribución haga ésto, 
probablemente debería usar su definición en vez de la genérica de GNU/Linux por omisión.
</para>

<para>
La definición <systemitem role="keyword">OSTYPE</systemitem> debería ser una de las primeras en aparecer en su fichero <filename>sendmail.mc</filename>, debido a que muchas 
otras definiciones dependen de ella.
</para>
</sect3>

<sect3><title>DOMAIN</title>
<para>
<INDEXTERM><PRIMARY>DOMAIN, definición de macro</PRIMARY></INDEXTERM>
La macro <systemitem role="keyword">DOMAIN</systemitem> es útil cuando se desea configurar un gran número de máquinas en la misma red de una manera estandarizada. Si se está 
configurando un pequeño número de anfitriones, probablemente es mejor no preocparse de ésto. Típicamente se configuran items, como el nombre de los anfitrións de retransmisión <footnote>
<para>N. del T: relay hosts en inglés</para></footnote> o concentradores <footnote><para>N. del T. hubs en inglés</para></footnote> que todos los anfitriones de la red utilizarán.
</para>

<para>
La instalación estándar continene un directorio de plantillas de macros <command>m4</command> utilizadas para dirigir el proceso de configuración. Este directorio se nombra 
normalmente como <filename>/usr/share/sendmail.cf</filename> o algo por el estilo. Aquí se encuentra un subdirectorio llamado <filename>domain</filename> que contiene 
plantillas de configuración específicas para el dominio. Para hacer uso de una macro <systemitem role="keyword">DOMAIN</systemitem>, se debe crear su propio fichero macro 
conteniendo las definiciones estándar que se requieran para el sitio, y escribirlas en el subdirectorio  <filename>domain</filename>. Sólo se deberían incluir normalmente aquí
las definiciones de macro que sean únicas a su dominio, como las definiciones de los anfitriones inteligentes o los anfitriones de retransmisión, pero no limitándose a éstos.
</para>

<para>
La distribución del código fuente de <command>sendmail</command> viene con algunos ficheros de ejemplo de definición de macros que puede usar para crear el suyo propio.
</para>

<para>
Si guardó su fichero de macros de dominio como <filename>/usr/share/sendmail.cf/domain/vbrew.m4</filename>, debería incluir las definiciones en su <filename>sendmail.mc
</filename> usando:

<screen>
DOMAIN(`vbrew')
</screen>
</para>
</sect3>

<sect3><title>FEATURE</title>
<para>
<INDEXTERM><PRIMARY>FEATURE, definición de macro</PRIMARY></INDEXTERM>
La macro <systemitem role="keyword">FEATURE</systemitem> permite incluir características predefinidas de <command>sendmail</command> en su configuración. Estas características de  
<command>sendmail</command> hacen las configuraciones soportadas muy fáciles de usar. Hay un gran número, y a través de este capítulo hablaremos únicamente de unas pocas. Se pueden 
encontrar detalles completos de las características disponibles en el fichero <filename>CF</filename> incluido en el paquete de fuentes.
</para>

<para>
Para usar cualquiera de las características listadas, debería incluir una línea en su fichero <filename>sendmail.mc</filename> que se parezca a esto:

<screen>
FEATURE(<replaceable>nombre</replaceable>)
</screen>

donde <replaceable>nombre</replaceable> se sustituye con el nombre de la característica. Algunas características toman un parámetro opcional. Si desea usar algún otro distinto
al predeterminado, debería utilizar una entrada como ésta: 


<screen>
FEATURE(<replaceable>nombre</replaceable>, <replaceable>parámetro</replaceable>)
</screen>

donde <replaceable>parámetro</replaceable> es el parámetro a suministrar.
</para>
</sect3>

<sect3><title>Definiciones de macros locales</title>
<para>
<INDEXTERM><PRIMARY>definiciones de macros locales</PRIMARY></INDEXTERM>
Los ficheros estándar de configuración de <command>sendmail</command> proporcionan una buena cantidad de maneras y variables con las que se puede personalizar la configuración. 
Éstas se llaman <command>definiciones de macros locales</command>. Muchas de ellas se listan en el fichero <filename>CF</filename> en el paquete de fuentes de <command>sendmail</command>.
</para>

<para>
La definiciones de macros locales son normalmente invocadas mediante el suministro del nombre de la macro con un argumento representando el valor que se quiere asignar a la variable que 
gestiona la macro. Otra vez, exploraremos algunas de las definiciones de macro locales más comunes en los ejemplos que presentaremos más tarde en este capítulo. 
</para>
</sect3>

<sect3><title>Definición de los protocolos de transporte de correo</title>
<para>
<INDEXTERM><PRIMARY>MAILER, definición de la macro</PRIMARY></INDEXTERM>
Si desea que <command>sendmail</command> transporte correo de qualquier otra forma distinta a entrega local, debe indicarle qué transporte tiene que emplear. La macro <literal>MAILER</literal> 
hace esto muy fácil. La versión actual de <command>sendmail</command> soporta una variedad de protocolos de transporte de correo; algunos de éstos son experimentales, otros son probablemente 
usados raramente.
</para>

<para>
En nuestra red necesitamos transporte SMTP para enviar y recibir correo entre los anfitriones en nuestra red local,  y el transporte UUCP para enviar y recibir correo desde nuestro anfitrión inteligente.
Para lograr ésto, simplemente incluimos ambos transportes de correo, el <literal>smtp</literal> y el <literal>uucp</literal>. El transporte de correo <literal>local</literal> se incluye 
por omisión, pero puede ser definido por claridad, si o desea. Si se incluyen ambos <literal>smtp</literal> y <literal>uucp</literal> en su configuración, debe asegurarse siempre de definir 
primero el agente de correo <literal>smtp</literal>.
</para>

<para>
Los transportes disponibles más comúnmente usados al usar la macro 
<systemitem role="keyword">MAILER</systemitem> se describen en la siguiente lista:

<variablelist id="X-087-2-sendmail.mailers">
<varlistentry>
	<term><systemitem role="keyword">local</systemitem></term>
	<listitem><para>
	Este transporte incluye tanto el agente de entrega local usado para enviar correo 
	al buzón de los usuarios en esta máquina como el  programa <systemitem role="keyword">prog</systemitem> transporte 
	de entrega usado para enviar mensajes a programas locales. Este transporte se incluye por omisión. 
	</para></listitem>
</varlistentry>
<varlistentry>
	<term><systemitem role="keyword">smtp</systemitem></term>
	<listitem><para>
	Este transporte implementa el Protocolo Simple de Transporte de Correo (SMTP),	que es el medio más usual  de transporte de correo en Internet.
	Cuando se incluye este transporte, se configuran cuatro transportes de correo: 
        <literal>smtp</literal> (SMTP básico), <literal>esmtp</literal> (SMTP Extendido), <literal>smtp8</literal> 
	(SMTP binario plano de 8 bits), y <literal>relay</literal> (específicamente diseñado para hacer de transporte a modo de pasarela entre anfitriones).
	</para></listitem>
</varlistentry>
<varlistentry>
	<term><systemitem role="keyword">uucp</systemitem></term>
	<listitem><para>
	El transporte <systemitem role="keyword">uucp</systemitem> proporciona 	soporte para dos transportes de correo: 
        <systemitem role="keyword">uucp-old</systemitem>, que es el UUCP tradicional, y
	<systemitem role="keyword">uucp-new</systemitem>, que permite manipular múltiples buzones en una transferencia.
	</para></listitem>
</varlistentry>
<varlistentry>
	<term><systemitem role="keyword">usenet</systemitem></term>
	<listitem><para>
	Este transporte de correo permite enviar mensajes directamente a redes de noticias del estilo Usenet. Cualquier mensaje local dirigido a una dirección de
	<emphasis>news.group.usenet</emphasis> será introducido en la red de noticias para el grupo de noticias <emphasis>news.group</emphasis>.
	</para></listitem>
</varlistentry>
<varlistentry>
	<term><systemitem role="keyword">fax</systemitem></term>
	<listitem><para>
	Si tiene el software Hylafax instalado, este transporte permitirá dirigir correo electrónico a él, para que así pueda construir una pasarela de correo-fax.
	Esta característica era experimental cuando se escribió este documento. Puede obtenerse más información en: <systemitem role="url">http://www.vix.com/hylafax/</systemitem>.
	</para></listitem>
</varlistentry>
</variablelist>
</para>

<para>
Hay otros como <systemitem role="keyword">pop</systemitem>, <systemitem role="keyword">procmail</systemitem>, <systemitem role="keyword">mail11</systemitem>, 
<systemitem role="keyword">phquery</systemitem>, y <systemitem role="keyword">cyrus</systemitem> que son útiles, pero menos comunes. Si le pica la cusiosidad, puede leer sobre 
éstos en el libro de sendmail o en la documentación suministrada en el paquete de fuentes.
</para>
</sect3>

<sect3><title>Configuración de encaminamiento de correo para anfitriones locales</title>
<para>
<INDEXTERM><PRIMARY>LOCAL_NET_CONFIG, definición de la macro</PRIMARY></INDEXTERM>
La configuración de la Cervecera Virtual es probablemente más compleja que lo que muchos sitios requieren. La mayoría de los sitios de hoy usarían transporte SMTP
únicamente y no tendrían que tratar con UUCP para nada. En nuestra configuración hemos configurado un &ldquo;anfitrión inteligente&rdquo; que es usado para tratar todo el 
correo saliente. Debido a que estamos usando un transporte SMTP en nuestra red local debemos indicarle a <command>sendmail</command> que no envíe correo local por el 
anfitrión inteligente. La macro <literal>LOCAL_NET_CONFIG</literal> permite introducir reglas sendmail directamente en el fichero de salida <filename>sendmail.cf</filename> 
para modificar la manera en que el correo local es manipulado. Hablaremos más sobre reglas de reescritura más tarde, pero por el momento se debería aceptar que la regla 
que hemos suministrado en nuestro ejemplo especifica que cualquier correo destinado a anfitriones dentro del dominio <systemitem role="sitename">vbrew.com</systemitem> deberían 
entregarse directamente al anfitrión objetivo usando el transporte de correo SMTP.
</para>

</sect3>
<INDEXTERM startref="sendmail.mc.parameters" class=endofrange> 
<INDEXTERM startref="macro.defs.sendmail" class=endofrange>
</sect2>

<INDEXTERM startref="sendmail.config.files" class=endofrange>
<INDEXTERM startref="config.files.sendmail" class=endofrange>
<INDEXTERM startref="sendmail.cf.file" class=endofrange>
</sect1>

<sect1><title>Generación del Fichero sendmail.cf</title>
<para>
<INDEXTERM><PRIMARY>sendmail.cf, fichero</PRIMARY><SECONDARY>generación</SECONDARY></INDEXTERM>
Cuando haya completado la edición del fichero de configuración  <command>m4</command>, debe procesarlo para producir el fichero <filename>/etc/mail/sendmail.cf</filename> leído por
<command>sendmail</command>. Esto se hace directamente como se ilustra en el siguiente ejemplo:

</para>

<screen>
# <userinput>cd /etc/mail</userinput>
# <userinput>m4 /usr/share/sendmail.cf/m4/cf.m4 vstout.uucpsmtp.mc >sendmail.cf</userinput>
</screen>

<para>
Esta orden invoca el procesador de macros <command>m4</command> suministrándole el nombre de dos ficheros de definición de macros para procesar. <command>m4</command> procesa los 
ficheros en el orden dado. El primer fichero es una plantilla de macro de <command>sendmail</command> estándar suministrada en el paquete de fuentes de  <command>sendmail</command>, 
el segundo, por supuesto, es el fichero que contiene nuestras propias definiciones de macros. La salida de la orden es dirigida al fichero <filename>/etc/mail/sendmail.cf</filename>, 
que es nuestro fichero objetivo.
</para>

<para>
Puede ahora iniciar <command>sendmail</command> con la configuración nueva.
</para>

</sect1>

<sect1><title>Interpretación de las Reglas de Escritura - Reescritura</title>
<para>
<INDEXTERM id="sendmail.rewrite.rules" class=startofrange><PRIMARY>sendmail</PRIMARY><SECONDARY>reglas de reescritura</SECONDARY></INDEXTERM>
<INDEXTERM id="rewrite.rules" class=startofrange><PRIMARY>reglas de reescritura (sendmail)</PRIMARY></INDEXTERM>
Es argumentable que la característica más poderosa de <command>sendmail</command> es la regla de reescritura. Las reglas de reescritura son usadas por <command>sendmail</command> 
para determinar cómo procesar un manseje de correo recibido. <command>sendmail</command> pasa las direcciones desde las  <emphasis>cabeceras</emphasis> de un mensaje de correo
a través de colecciones de reglas de reescritura llamadas  <emphasis>conjuntos de reglas</emphasis>. Las reglas de reescritura transforman una dirección de correo de una forma a otra y 
puede pensar en ellas como algo similar a una orden en su editor que reemplaza todo el texto que encaje en un patrón especificado con otro.
</para>

<para>
Cada regla tiene un lado izquierdo y un lado derecho, separados por al menos un carácter de tabulación. Cuando  <command>sendmail</command> está procesando correo,
busca a través de las reglas de reescritura intentando encontrar una coincidencia con el lado izquierdo. Si una dirección coincide con una de las reglas del lado izquierdo, 
la dirección es reemplazada por la del lado derecho y es procesada de nuevo.
</para>

<sect2><title>Las Órdenes R y S de sendmail.cf</title>
<para>
<INDEXTERM><PRIMARY>sendmail.cf, fichero</PRIMARY><SECONDARY>órdenes R y S</SECONDARY></INDEXTERM>
En el fichero <filename>sendmail.cf</filename>, los conjuntos de reglas son definidos usando órdenes codificadas como <literal>S</literal><replaceable>n</replaceable>, donde
<replaceable>n</replaceable> especifica el conjunto de reglas que se considera el actual.
</para>

<para>
Las reglas por sí mismas aparecen en órdenes codificadas como <command>R</command>. Cuando cada orden  <command>R</command> es leída , se añade al conjunto de reglas actual.
</para>

<para>
Si está tratando sólo con el fichero  <filename>sendmail.mc</filename>, no necesita preocuparse acerca de las órdenes <command>S</command> para nada, ya que 
las macros construirán éstas por usted. Necesitará codificar manualmente las reglas <command>R</command>.
</para>
<?troff .Nd 10>
<para>
Un conjunto de reglas de <command>sendmail</command> entonces tiene la siguiente apariencia:

<screen>
<literal>S</literal><replaceable>n</replaceable>
<literal>R</literal><replaceable>lhs</replaceable> <replaceable>rhs</replaceable>
<literal>R</literal><replaceable>lhs2</replaceable> <replaceable>rhs2</replaceable>
</screen>
</para>
</sect2>

<sect2><title>Algunas Definiciones de Macro Útiles </title>
<para>
<command>sendmail</command> utiliza internamente unas cuantas definiciones de macro estandarizadas. Las más útiles de éstas en la escritura de conjuntos de reglas son: 
</para>

<variablelist>

<varlistentry><term>$j</term>
<listitem><para>
El nombre completamente cualificado de este anfitrión (FQDN).
</para></listitem>
</varlistentry>

<varlistentry><term>$w</term>
<listitem><para>
El componente del anfitrión del FQDN.
</para></listitem>
</varlistentry>

<varlistentry><term>$m</term>
<listitem><para>
El componente del dominio del FQDN.
</para></listitem>
</varlistentry>

</variablelist>

<para>
Podemos incorporar estas definiciones de macros en nuestras propias reglas de reescritura. Nuestra configuración de la Cervecera Virtual utiliza la macro <literal>$m</literal>.
</para>

</sect2>

<sect2><title>El Lado Izquierdo</title>
<para>            
A la izquierda de una regla de reescritura, hay que especificar un patrón que coincida con una dirección que desee transformar. La mayoría de los caracteres se les hace 
coincidir literalmente, pero hay un número de caracteres que tienen significado especial; estos se describen en la lista siguiente. Las reglas de reescritura para el 
lado izquierdo son:
</para>           

<variablelist id="X-087-2-sendmail.rewrite.lhs">

<varlistentry>
<term><literal>$@</literal></term>
<listitem><para>
Coinciden exactamente cero símbolos
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$*</literal></term>
<listitem><para>
Coinciden cero o más símbolos
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$+</literal></term>
<listitem><para>
Coincide uno o más símbolos
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$-</literal></term>
<listitem><para>
Coincide exactamente un símbolo
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$=</literal><replaceable>x</replaceable></term>
<listitem><para>
Coindice cualquier frase en la clase  <replaceable>x</replaceable>
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$~</literal><replaceable>x</replaceable></term>
<listitem><para>
Coincide con cualquier palabra que no esté en la clase <replaceable>x</replaceable>
</para></listitem>
</varlistentry>

</variablelist>

<para>
Un símbolo es una tira de caracteres delimitados por espacios. No hay manera de incluir espacios en un símbolo, o no es necesario como los patrones de expresiones son 
suficientemente flexibles para atajar esta necesidad. Cuando una regla coincide con una dirección, el texto que coincide con cada uno de los patrones en la expresión 
será asignado a variables especiales que se usarán en la parte derecha. La única excepción a esto es con el literal <literal>$@</literal>, que no coincide con ningún 
símbolo y entonces nunca generará texto para ser usado en el lado derecho.
</para>
</sect2>

<sect2><title>El Lado Derecho</title>
<para>
Cuando el lado izquierdo de una regla de reescritura coincide con una direción, el texto original se borra y se reemplaza por lo que haya en el lado derecho de la regla. 
Todos los símbolos en el lado derecho son copiados literalmente , a no ser que comiencen por el signo del dólar. De la misma manera que en el lado izquierdo, unos cuantos 
metasímbolos pueden usarse en el lado derecho. Estos son descritos en la siguiente lista. Las reglas de reescritura para el lado derecho son:
</para>

<variablelist id="X-087-2-sendmail.rewrite.rhs">

<varlistentry>
<term><literal>$</literal><replaceable>n</replaceable></term>
<listitem><para>
Este metasímbolo es reemplazado por la expresión <replaceable>n</replaceable>ésima del lado izquierdo.
</para></listitem>
</varlistentry>

<varlistentry>
<term>
<literal>$[</literal><replaceable>nombre</replaceable><literal>$]</literal>
</term>
<listitem><para>
Este metasímbolo resuelve el nombre del anfitrión a nombre canónico. Es reemplazado por la forma canónica del nombre del anfitrión suministrado.
</para></listitem>
</varlistentry>

<varlistentry>
<term>
<literal>$(</literal><replaceable>map_clave</replaceable><literal> $@</literal><replaceable>argum</replaceable><literal> $:</literal><replaceable>omisión</replaceable><literal> $)</literal>
</term>
<listitem><para>
Esta es la forma más general de búsqueda. La salida es un resultado de mirar la <replaceable>clave</replaceable> en el mapa nombrado <emphasis>map</emphasis> pasándole <replaceable>
argum</replaceable> como argumentos. El <emphasis>mapa</emphasis> puede ser cualquiera de los mapas que <command>sendmail</command> soporta como el <literal>virtusertable</literal> 
que describimos un poco más tarde. Si la búsqueda es infructuosa, <replaceable>por omisión</replaceable> será la salida. Si no se suministra nada por omisión y la búsqueda falla, 
la entrada no se altera y la <replaceable>clave</replaceable> es la salida.
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$&gt;</literal><replaceable>n</replaceable></term>
<listitem><para>
Esto hará que el resto de esta lína sea analizada y entonces dada al conjunto de reglas <replaceable>n</replaceable> para ser evaluada. La salida del conjunto de reglas llamado se escribirá 
como salida a esta regla. Éste es el mecanismo que permite a las reglas invocar otras reglas.
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$#</literal><replaceable>mailer</replaceable></term>
<listitem><para>
Este metasímbolo hace que la evaluación del conjunto de reglas se detenga y especifica el transporte que deberá usarse para transportar este mensaje en el siguiente paso de su entrega.
Este metasímbolo debería ser llamado sólo desde el conjunto de reglas 0 o una de sus subrutinas. Esta es la parte final del análisis de direcciones y debería ser acompañado de 
los dos siguientes metasímbolos.
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$@</literal><replaceable>host</replaceable></term>
<listitem><para>
Este metasímbolo especifica el anfitrión al que este mensaje será reenviado. Si el 
anfitrión destinatario es el anfitrión local, puede omitirse. El <replaceable>host</replaceable> 
puede ser una lista de anfitriones de destino separada por dos puntos (:)
que a los que se intentará entregar el mensaje en secuencia.
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$:</literal><replaceable>user</replaceable></term>
<listitem><para>
Este metasímbolo especifica el usuario destinatario para el mensaje de correo.
</para></listitem>
</varlistentry>

</variablelist>

<para>
Una regla de reescritura que coincide se intenta repetidamente hasta que falla una coincidencia,
entonces el análisis continúa en la sigiente regla. Este comportamiento puede cambiarse
precediendo el lado derecho con uno de dos metasímbolos especiales descritos en la siguiente lista.

Las reglas de reescritura para el control del bucle del lado derecho son:</para>

<variablelist id="X-087-2-sendmail.rewrite.rhs.special">

<varlistentry>
<term><literal>$@</literal></term>
<listitem><para>
Este metasímbolo causa que el conjunto de regles retorne con el resto del
lado derecho como el valor. Ninguna otra regla del conjunto se evalúa.
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>$:</literal></term>
<listitem><para>
Este metasímbolo causa que esta regla finalice inmediatamente, pero el resto
del conjunto de reglas actual es evaluado.
</para></listitem>
</varlistentry>

</variablelist>

</sect2>

<sect2><title>Un Ejemplo de Patrón de Reglas Sencillo</title>
<para>
Para ver mejor cómo funcionan las macros de sustitución de patrones, considere la 
siguiente regla de lado izquierdo:

<screen>
$* &lt; $+ &gt;
</screen>
</para>

<para>
Esta regla coincide con &ldquo;Cero o más símbolos, seguidos por el
carácter &lt, seguidas a su vez por una o más símbolos, seguidos por el carácter &gt;.
&rdquo;
</para>

<para>
Si esta regla fuese aplicada a  <literal>brewer@vbrew.com</literal> o
<literal>Head Brewer &lt; &gt;</literal>, la regla no coincidiría. 
La primera cadena no coincidiría porque no incluye el carácter
&lt;, y la segunda fallaría porque <literal>$+</literal> coincide con
<emphasis>uno o más</emphasis> símbolos
y no hay símbolos entre los caracteres <literal>&lt;&gt;</literal>. En cualquier caso
en que una regla co coincida, el lado derecho de la regla no se usa.
</para>

<para>
Si la regla fuera aplicada a <literal>Head Brewer &lt; brewer@vbrew.com
&gt;</literal>, la regla coincidiría, y en el lado derecho 
<literal>$1</literal> sería sustituido por <literal>Head
Brewer</literal> y <literal>$2</literal> sería sustituido por 
<literal>brewer@vbrew.com</literal>.
</para>

<para>
Si la regla fuese aplicada a <literal>&lt; brewer@vbrew.com
&gt;</literal> la regla coincidiría porque  <literal>$*</literal>
coincide con <emphasis>cero</emphasis> o más símbolos, y en el lado derecho
<literal>$1</literal> podría ser sustituido por la cadena vacía.
</para>
</sect2>

<sect2><title>Semántica del Conjunto de Reglas</title>
<para>
<INDEXTERM id="ruleset.semantics" class=startofrange><PRIMARY>semántica del conjunto de reglas (sendmail)</PRIMARY></INDEXTERM>
<INDEXTERM id="sendmail.ruleset.semantics" class=startofrange><PRIMARY>sendmail</PRIMARY><SECONDARY>semántica del conjunto de reglas</SECONDARY></INDEXTERM>
Cada uno de los conjuntos de reglas de <command>sendmail</command> se les llama para 
realizar una tarea distinta en el procesado del correo. Cuando se están escribiendo
reglas, es importante entender qué se espera que cada uno de los conjuntos de reglas 
haga. Vamos a echar un vistazo a cada uno de los conjuntos de reglas que los guiones de 
configuración <command>m4</command> nos permiten modificar:
</para>

<variablelist>
<varlistentry>
<term>LOCAL_RULE_3</term>
<listitem><para>
<INDEXTERM><PRIMARY>LOCAL_RULE_3, conjunto de reglas de Sendmail</PRIMARY></INDEXTERM>
El conjunto 3 es responsable de convertir una dirección en un formato arbitrario 
en un formato común que<command>sendmail</command> procesará.
El formato de salida esperado es el aspecto familiar 
<replaceable>parte-local</replaceable><literal>@</literal><replaceable>especificación-anfitrión-dominio</replaceable>.
</para>

<para>
El conjunto 3 debería poner la parte del nombre del anfitrión de la dirección convertida entre los caracteres
<literal>&lt;</literal> y <literal>&gt;</literal> para hacer el análisis de las siguientes reglas más fácil. El conjunto de reglas
3 se aplica antes  que <command>sendmail</command> haga cualquier otro procesamiento de 
una dirección de correo, así que si quiere que <command>sendmail</command> haga de pasarela de correo 
desde algún sistema que utilice algún formato de dirección poco usual, se debería añadir una regla 
usando la macro <literal>LOCAL_RULE_3</literal> para convertir direcciones en el formato común.
</para></listitem>
</varlistentry>

<varlistentry>
<term>LOCAL_RULE_0 y LOCAL_NET_CONFIG</term>
<listitem><para>
<INDEXTERM><PRIMARY>LOCAL_RULE_0, conjunto de reglas de sendmail</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>LOCAL_NET_CONFIG, definición de macro</PRIMARY></INDEXTERM>
El conjunto  0 se aplica por <command>sendmail</command> a las direcciones del destinatario tras
el conjunto de reglas 3. La macro <literal>LOCAL_NET_CONFIG</literal> provoca que las reglas sean 
introducidas en la <emphasis>mitad inferior</emphasis> del conjunto 0.
</para>

<para>
El conjunto 0 se espera que realice la entrega del mensaje al destinatario,
así que debe resolver un triplete que especifica el correo, el anfitrión y el usuario.
Las reglas serán colocadas antes de cualquier definición de anfitrión inteligente que quiera
incluir, así que si añade reglas que resuelvan direcciones apropiadamente cualquier 
dirección que coincida con una regla no será tratada por el anfitrión inteligente. Así es 
como tratamos los <command>smtp</command> directos para los usuarios de nuestra red local
en nuestro ejemplo.
</para></listitem>
</varlistentry>

<varlistentry>
<term>LOCAL_RULE_1 y LOCAL_RULE_2</term>
<listitem><para>
<INDEXTERM><PRIMARY>LOCAL_RULE_1, conjunto de reglas sendmail</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>LOCAL_RULE_2, conjunto de reglas sendmail</PRIMARY></INDEXTERM>
El conjunto 1 se aplica a todas las direcciones de remite y el conjunto 2 de aplica a todas las
direcciones de destino. Ambos están normalmente vacíos.
</para></listitem>
</varlistentry>
</variablelist>

<sect3><title>Interpretación de la regla en nuestro ejemplo</title>
<para>
Nuestro ejemplo en  <xref linkend="X-087-2-sendmail.rewrite.example"> usa la macro
<literal>LOCAL_NET_CONFIG</literal> para declarar una regla local que asegure que cualquier
correo  dentro de nuestro dominio se entregue directamente usando el transporte de correo
<command>smtp</command>. Ahora que sabe cómo se construyen las reglas de reescritura,
es capaz de entender cómo funciona esta regla. Echémosle un vistazo.
</para>

<example id="X-087-2-sendmail.rewrite.example">
<title>Regla de reescritura desde vstout.uucpsmtp.m4</title>
<screen>
LOCAL_NET_CONFIG
# Esta regla se asegura de que todo correo local sea entregado usando el
# transporte smtp, todo lo demás irá por el anfitrión inteligente.
R$* &lt; @ $* .$m. &gt; $*  $#smtp $@ $2.$m. $: $1 &lt; @ $2.$m. &gt; $3
</screen>
</example>

<para>
Sabemos que la macro <literal>LOCAL_NET_CONFIG</literal> hará que la regla se introduzca
en algún lugar cerca del final del conjunto de reglas 0, pero antes de 
cualquier definición del anfitrión inteligente. Sabemos también que el conjunto 0
es el último conjunto en ser ejecutado y que debería resolver un triplete 
especificando transporte de correo, usuario y anfitrión.
</para>

<para>
Podemos ignorar las dos líneas de comentariso; no hacen nada útil. La regla
en sí misma es la línea que comienza con  <literal>R</literal>. Sabemos que
la <literal>R</literal> es una instrucción de <command>sendmail</command> y que 
añade esta regla al conjunto de reglas actual, en este caso el conjunto
<literal>0</literal>. Miremos al lado izquierdo y al lado derecho que devuelve.
</para>

<para>
El lado izquierdo es como éste:
<literal>$* &lt; @ $* .$m. &gt; $*</literal>.
</para>

<para>
El conjunto 0 espera los caracteres  &lt; y &gt; porque es alimentado por el conjunto 3. <!--ATENCION:¿alimentado?-->
El conjunto 3 convierte direcciones en una forma común y para hacer el análisis más fácil, 
coloca la parte del anfitrión de la dirección de correo entre  &lt; y &gt;.
</para>

<para>
Esta regla coincide con cualquier dirección que parecezca como:
<literal>'UsuarioDestino &lt; @ cualquieranfitrión.nuestrodominio. &gt; Algún Texto'</literal>. Esto es, coincide
con el correo de cualquier usuario y de cualquier anfitrión dentro de nuestro dominio.
</para>

<para>
Recordará que el texto que coincide con los metasímbolos en el lado izquierdo
de una regla de reescritura se asigna a definiciones de macro para su uso en 
el lado derecho. En nuestro ejemplo, el primer  <literal>$*</literal> coincide con
todo el texto desde el inicio de la dirección hasta el carácter  &lt;.
Todo este texto se asigna al <literal>$1</literal> para su uso en el lado derecho.
Similarmente, el segundo  <literal>$*</literal> en nuestra regla de reescritura
se asigna a  <literal>$2</literal>, y el último se asigna a  <literal>$3</literal>.
</para>

<para>
Ahora tenemos suficiente para entender el lado izquierdo. Esta regla coincide
con el correo de cualquier usuario en cualquier anfitrión dentro de nuestro dominio.
Asigna el nombre de usuario a <literal>$1</literal>, el nombre del anfitrión a 
<literal>$2</literal>, y cualquier texto subsiguiente a <literal>$3</literal>. El
lado derecho se invoca entonces para procesar éstos.
</para>

<para>
Echemos un vistazo a aquello que estamos esperando ver a la salida. El lado derecho de 
nuestra regla de reescritura de ejemplo es semejante a:

<literal>$#smtp $@ $2.$m. $: $1 &lt; @ $2.$m. &gt; $3</literal>.
</para>

<para>
Cuando la regla del lado derecho de nuestro conjunto de reglas se procesa, se interpreta 
cada uno de los metasímbolos y se realizan las sustituciones correspondientes.
</para>

<para>
El metasímbolo <literal>$#</literal> hace que esta regla resuelva  un transporte específico,
<emphasis>smtp</emphasis> en nuestro caso.
</para>

<para>
El  <literal>$@</literal> resuelve el anfitrión objetivo. En nuestro ejemplo,
el anfitrión objetivo se especifica como  <literal>$2.$m.</literal>, el cual 
es el nombre completamente cualificado del anfitrión en nuestro dominio. El
NDCC se construye con el componente del nombre del anfitrión asignado a 
<literal>$2</literal> desde nuestro lado izquierdo con nuestro nombre de 
dominio (<literal>.$m.</literal>) concatenado.
</para>

<para>
El metasímbolo <literal>$:</literal> especifica el usuario objetivo,
el cual se captura otra vez del lado izquierdo y se almacena en
<literal>$1</literal>.
</para>

<para>
Preservamos los contenidos de la sección  &lt;&gt; y  cualquier texto 
acompañante, usando los datos que recogimos desde el lado izquierdo de la 
regla.
</para>

<para>
Debido a que esta regla resuelve a un transporte de correo, el mensaje es reenviado al transporte
para su entrega. En nuestro exemplo, el mensaje sería reenviado al anfitrión de destino usando el
protocolo SMTP.
</para>
</sect3>
</sect2>
<INDEXTERM startref="ruleset.semantics" class=endofrange>
<INDEXTERM startref="sendmail.ruleset.semantics" class=endofrange>
<INDEXTERM startref="sendmail.rewrite.rules" class=endofrange>
<INDEXTERM startref="rewrite.rules" class=endofrange>
</sect1>

<sect1><title>Configuración de las Opciones de Sendmail</title>
<para>
<INDEXTERM id="sendmail.config.options" class=startofrange><PRIMARY>sendmail</PRIMARY><SECONDARY>opciones, configuración</SECONDARY></INDEXTERM>
<command>sendmail</command> tiene un número de opciones que permiten personalizar
la manera en que realiza ciertas tareas. Hay un número mayor de éstas, así que 
sólo hemos listado unas pocas de las más usadas normalmente en la lista siguiente:
</para>

<para>
<INDEXTERM><PRIMARY>procesador de macros m4</PRIMARY><SECONDARY>configurando las opciones de sendmail</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail.cf, fichero</PRIMARY><SECONDARY>configurando las  opciones se sendmail</SECONDARY></INDEXTERM>
Para configurar cualquiera de estas opciones, se pueden definirlas en el fichero de configuración
<command>m4</command>, que es el método preferible, o puede insertarlas directamente en el
fichero  <filename>sendmail.cf</filename>. Por ejemplo, si deseásemos que <command>sendmail</command> se bifurque
en un proceso nuevo para cada mensaje de correo que tenga que entregarse, quizá añadamos la siguiente línea a 
nuestro fichero de configuración <command>m4</command>:

<screen>
define(&lsquo;confSEPARATE_PROC&rsquo;,&lsquo;true&rsquo;)
</screen>
</para>

<para>
La correspondiente entrada creada en  <filename>sendmail.cf</filename> es:

<screen>
O ForkEachJob=true
</screen>
</para>


<para>
<?troff .hw equivalents>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>opciones m4</SECONDARY></INDEXTERM>
La siguiente lista describe opciones usuales de <emphasis>sendmail m4</emphasis>  (y
las equivalentes en  <filename>sendmail.cf</filename>):
</para>

<variablelist id="X-087-2-sendmail.common.options">

<varlistentry>
<term><literal>confMIN_FREE_BLOCKS</literal>
<literal>(MinFreeBlocks)</literal></term> <listitem><para> Hay ocasiones
cuando un problema quizá impida la entrega inmediata de mensajes de correo,
haciendo que los mensajes esperen en la cola de envío. Si su anfitrión de correo
procesa un gran volumen de correo, es posible que la cola de correo crezca
hasta tal tamaño que llene completamente el sistema de ficheros en que la 
cola se encuentra. Para prevenir esto, <command>sendmail</command> 
proporciona esta opción para especificar el número mínimo de bloques de disco
libres que deben existir antes de que un mensaje de correo sea aceptado. Esto permite
asegurarse de  que <command>sendmail</command> nunca provoca que el sistema de ficheros
de la cola de correo se  llene (Predeterminado a: 100).  </para></listitem>
</varlistentry>

<varlistentry>
<term><literal>confME_TOO</literal> <literal>(MeToo)</literal></term>
<listitem><para>
Cuando un objetivo de correo como un alias de correo se expande, es a veces posible para 
el remitente aparecer en la lista de destinatarios. Esta opción determina si los originadores
de un mensaje de correo electrónico recibirán una copia si aparecen en la lista de 
destinatarios expandida. Los valores válidos son  &ldquo;true&rdquo; y
&ldquo;false&rdquo; (Predeterminado a: false).
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>confMAX_DAEMON_CHILDREN</literal> <literal>(MaxDaemonChildren)</literal></term>
<listitem><para>
Cuando  <command>sendmail</command> recibe una conexión SMTP desde un anfitrión remoto, 
inicia una copia nueva de sí mismo para tratar el mensaje entrante. De esta manera, es 
posible para <command>sendmail</command> estar procesando múltiples mensajes entrantes 
simultáneamente. Aunque esto es útil, cada nueva copia de <command>sendmail</command> 
consume memoria en la computadora anfitrióna. Si se recibe un número inusualmente grande 
de conexiones entrantes, por ejemplo, debido a un problema o a un ataque malicioso, es 
posible que los demonios de <command>sendmail</command> consuman toda la memoria del sistema.
Esta opcioón le permite limitar el número máximo de demonios hijos que serán iniciados. Cuando 
este número se alcance, las conexiones nuevas se deniegan hasta que uno de los demonios hijos 
haya terminado. (Predeterminado a: undefined(indefinido)).
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>confSEPARATE_PROC</literal> <literal>(ForkEachJob)</literal></term>
<listitem><para>
Cuando se procesa una cola de correo y se envían mensajes de correo,
<command>sendmail</command> procesa un mensaje de correo cada vez. Cuando esta
opción está activada, <command>sendmail</command> se bifurcará en copias 
nuevas de sí mismo para cada mensaje a ser entregado. Esto es particularmente 
útil cuando hay varios mensajes de correo atascados en la cola porque hay un 
problema con el anfitrión objetivo.
(Predeterminado: false).
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>confSMTP_LOGIN_MSG</literal> <literal>(SmtpGreetingMessage)</literal></term>
<listitem><para>
Cuando se hace una conexión a  <command>sendmail</command>, se envía un mensaje
de bienvenida. Por omisión, este mensaje contiene el nombre del anfitrión, el nombre
del agente de transporte de correo,  el número de versión de sendmail, el número
de versión local, y la fecha actual. El RFC821 especifica que la primera palabra
del saludo debería ser el nombre completamente cualificado del anfitrión, pero
el resto del saludo, puede ser configurado a su gusto. Puede especificar
macros de sendmail aquí y serán expandidas y usadas. La única gente que verá 
este mensaje serán los administradores de sistemas que estén diagnosticando 
problemas de envío de correo, o gente fuertemente curiosa interesada en
descubrir cómo está configurada su máquina. Puede aliviar algo del tedio de
su tarea personalizando el mensaje de bienvenida con algunos chistes; sea amable.
La palabra &ldquo;EMSTP&rdquo; será introducida por <command>sendmail</command> 
entre la primera palabra y la segunda, como señal para los anfitriones remotos de que
soportamos el protocolo ESMTP.
(Predeterminado: <literal>$j Sendmail $v/$Z; $b</literal>).
</para></listitem>
</varlistentry>
</variablelist>
<INDEXTERM startref="sendmail.config.options" class=endofrange>
</sect1>

<sect1><title>Algunas configuraciones útiles para Sendmail</title>
<para>
<INDEXTERM id="sendmail.configs" class=startofrange><PRIMARY>sendmail</PRIMARY><SECONDARY>configurationes importantes</SECONDARY></INDEXTERM>
Hay una miríada de posibles configuraciones de <command>sendmail</command>.
En este espacio se ilustrarán sólo unos cuantos tipos de configuración 
de importancia que serán muy útiles para muchas instalaciones de <command>
sendmail</command>.
</para>

<sect2><title>Confiar en los usuarios para que pongan el campo From:</title>
<para>
En ocasiones es útil sobreescribir el campo <literal>From:</literal>
de un mensaje de correo que va hacia afuera. Supongamos que se tiene
un programa basado en web que genera correo electrónico. Normalmente
el mensaje de correo aparecerá como proviniente del usuario que es el
dueño del proceso del servidor de web. Pero se quiere especificar
alguna otra dirección remitente de tal forma que el correo parezca ser
originado por otro usuario o dirección en esa máquina. <command>
Sendmail</command> permite especificar en qué usuarios del sistema se 
puede confiar para que tengan la habilidad de hacer esto.
</para>

<para>
La opción <literal>use_ct_file</literal> habilita la posibilidad de
especificar y dar un fichero que liste los nombres de los usuarios
de confianza. Por omisión, un pequeño número de usuarios del sistema
son de confianza de <command>sendmail</command>, por ejemplo
<literal>root</literal>. El nombre del fichero por omisión para esta
opción es <filename>/etc/mail/trusted-users</filename> en los sistemas
en los que el directorio de configuración es <filename>/etc/mail</filename> 
y en <filename>/etc/senmdail.ct</filename> en donde es el otro tipo de
configuración. Se puede especificar el nombre y lugar del fichero
sobreescribiendo la definición <literal>confCT_FILE</literal>.
</para>

<para>
Escriba FEATURE(use_ct_file) en el fichero <filename>sendmail.mc</filename> 
para habilitar esta opción.
</para>
</sect2>

<sect2><title>Gestión de Alias de Correo</title>
<para>
<INDEXTERM><PRIMARY>email</PRIMARY><SECONDARY>alias</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>alias</PRIMARY><SECONDARY>email</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>gestionando alias de correo</SECONDARY></INDEXTERM>
Los alias de correo son una poderosa opción que permite que el correo
sea dirigido a otros apartados postales que son nombres alternativos
de usuarios o procesos en un servidor destinatario. Por ejemplo, es
una práctica común tener retroalimentación o comentarios con respecto
a un servidor de Web y que estén dirigidos a &ldquo;webmaster.&rdquo;
Con frecuencia no hay un usuario llamado &ldquo;webmaster.&rdquo; en
el servidor, en vez de ello, hay un alias a otro usuario del
sistema. Otro uso común para los alias de correo es utilizarlos por
los programas de gestión de listas de correo en los cuales un alias
dirige todos los mensajes que ingresan al programa de gestión de la
lista para que sea interpretado.
</para>

<para>
<INDEXTERM><PRIMARY>fichero /etc/aliases</PRIMARY></INDEXTERM>
El fichero <filename>/etc/aliases</filename> es el lugar en donde los
alias se almacenan. El programa <command>sendmail</command> consulta
este fichero cuando está determinando cómo manejar un mensaje que
ingresa. Si encuentra una línea en este fichero que coincide con el
usuario a quien va dirigido el mensaje, lo redirige al lugar que
indica dicha línea.
</para>

<para>
De forma específica, hay tres cosas que los alias permiten:

<itemizedlist>
<listitem><para>
Otorgan un nombre corto o bien conocido para el correo que será dirigido
hacia una o más personas.
</para></listitem>
<listitem><para>
<?troff .hw program>
Pueden invocar a un programa con el mensaje de correo como entrada
hacia dicho programa.
</para></listitem>
<listitem><para>
Pueden mandar el correo a un fichero.
</para></listitem>
</itemizedlist>
</para>

<para>
<?troff .hw compliant>
Todos los sistemas requieren de alias para el
<systemitem role="userid">Postmaster</systemitem> y el
<systemitem role="userid">MAILER-DAEMON</systemitem> para cumplir con
el RFC.
</para>

<para>
Se debe ser especialmente cuidadoso con la seguridad cuando se definan
alias que invoquen o escriban a programas, ya que
<command>sendmail</command> por lo general se ejecuta con los permisos de 
<systemitem role="userid">root</systemitem>.
</para>

<para>
Se pueden encontrar más detalles con respecto a los alias de correo en
la página de manual <filename>aliases(5)</filename>. Una ejemplo del
fichero <filename>aliases</filename> se muestra en <xref
linkend="X-087-2-samp.alias.fig">.
</para>

<example id="X-087-2-samp.alias.fig">
<title>Ejemplo del fichero aliases</title>
<screen>
#
# Los siguientes dos alias deben estar presentes para cumplir con el RFC.
# Es importante resolverlos en 'una persona' que lea su correo con regularidad.
#
postmaster:    root                            # línea indispensable
MAILER-DAEMON: postmaster                      # línea indispensable
#
#
# demuestra los tipos más comunes de alias
#
usenet:        janet                           # alias para una persona
admin:         joe,janet                       # alias para varias personas
newspak-users: :include:/usr/lib/lists/newspak # lee a los destinatarios desde un fichero
changefeed:    |/usr/local/lib/gup             # alias que invoca a un programa
complaints:    /var/log/complaints             # alias que escribe el correo a un fichero
#
</screen>
</example>
<?troff .Nd 10>
<para>
Cada vez que actualice el fichero <filename>/etc/aliases</filename>,
se debe asegurar de ejecutar el programa:

<screen>
# <userinput>/usr/bin/newaliases</userinput>
</screen>

para reconstruir la base de datos que <command>sendmail</command>
utiliza internamente. La orden <command>/usr/bin/newaliases</command>
es un vínculo simbólico al ejecutable de <command>sendmail</command>
y, cuando se invoca de esta forma, se comporta exactamente como si
hubiese sido invocado así:

<screen>
# <userinput>/usr/lib/sendmail -bi</userinput>
</screen>

La orden <command>newaliases</command> es una forma alternativa y más
adecuada para hacer esto.
</para>

</sect2>

<sect2><title>Cómo usar un anfitrión inteligente</title>
<para>
<INDEXTERM><PRIMARY>configuraciones de anfitrión inteligente</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>configuraciones de anfitrión inteligente</SECONDARY></INDEXTERM>
Algunas veces un anfitrión encuentra correo que no puede entregar
directamente a un sitio remoto. Con frecuencia es conveniente tener un
único sitio en una red que tenga el papel de gestionar la transmision
del correo a sitios remotos que son difíciles de alcanzar, en vez de
que cada sitio local intente hacer esto por sí mismo.
</para>

<para>
Hay algunas buenas razones para que se tenga un solo sitio encargado
de la gestión del correo. Se simplifica la gestión al tener sólo un
sitio con una configuración cuidadosa del correo que sepa cómo manejar
todos los tipos de transporte de correo, tales como UUCP, Usenet,
etc. Todos los otros sitios lo único que necesitan es un solo
protocolo de transporte para enviar su correo a este anfitrión
central. Los sitios que cumplen este papel de encaminadores centrales y 
reenviadores se llaman <emphasis>anfitriones inteligentes</emphasis>. 
Si se tiene un anfitrión inteligente que acepte correo de usted, se puede 
enviar correo de cualquier tipo y él se encargará de gestionar el 
encaminamiento y la transmisión de ese correo a todos los sitios remotos 
deseados.
</para>

<para>
Otra buena aplicación para la configuración de anfitriones remotos es
gestionar la transmisión del correo a través de un cortafuegos
privado. Una organización puede elegir instalar una red IP privada y
utilizar sus propias direcciones IP no registradas. La red privada se
puede conectar a Internet mediante un cortafuegos. El enviar el
correo desde y hacia los diversos anfitriones dentro de la red privada
hacia el mundo exterior utilizando SMTP no será posible en una
configuración convencional debido a que los sitios locales no pueden
establecer una conexión directa de red a los sitios que están en
Internet. En cambio, la organización puede optar por que el
cortafuegos tenga la función de anfitrión inteligente. El anfitrión
inteligente que se ejecute en el cortafuegos será capaz de establecer
conexiones directas de red con los sitios que se encuentran tanto en
el interior de la red privada como en el exterior de ella. El
anfitrión inteligente puede aceptar correo de ambos anfitriones, de
los que están en la red privada y de los que están en Internet,
el correo se guarda en un almacenamiento local y luego se gestiona la
retransmisión de ese correo directamente al sitio adecuado.
</para>

<para>
Los anfitriones inteligentes se utilizan en general cuando todos los
otros métodos de entrega han fallado. En el caso de una organización
con una red privada, es perfectamente razonable que los anfitriones
primero intenten entregar el correo directamente, y si eso falla,
entonces los envían al anfitrión inteligente. Esto descarga mucho el
tráfico que va hacia el anfitrión inteligente debido a que los otros
anfitriones pueden enviar correo directamente a otros anfitriones
dentro de la red privada.
</para>

<para>
<INDEXTERM><PRIMARY>macro SMART_HOST</PRIMARY></INDEXTERM>
<command>sendmail</command> provee de un método simple para configurar
un anfitrión inteligente utilizando la opción
<literal>SMART_HOST</literal>; para implementarlo en la configuración
de la Cervecera Virtual, se hace exactamente esto. Las porciones
relevantes de nuestra configuración que definen al anfitrión
inteligente son:

<screen>
define(`SMART_HOST', `uucp-new:moria')
LOCAL_NET_CONFIG
# Esta regla asegura que todo el correo local se entrega utilizando
# el transporte smtp, todo lo demás se va a través del anfitrión inteligente.
R$* &lt; @ $* .$m. &gt; $*	$#smtp $@ $2.$m. $: $1 &lt; @ $2.$m. &gt; $3
</screen>
</para>

<para>
La macro <literal>SMART_HOST</literal> permite que se especifique el
anfitrión que reenviará todo el correo de salida que no se pueda 
entregar directamente y el protocolo de transporte de correo que se
debe utilizar para ello.
</para>

<para>
En nuestra configuración se está usando el transporte
<literal>uucp-new</literal> hacia el sitio UUCP <emphasis
role="bold">moria</emphasis>. Si se quisiera configurar 
<command>sendmail</command> para que utilice un anfitrión inteligente
con SMTP, se debería escribir algo como lo siguiente:

<screen>

define(`SMART_HOST', `mail.isp.net')
</screen>

No se necesita especificar que el transporte es SMTP, ya que está
dicho por omisión.
</para>

<para>
¿Puede adivinar lo que la macro <literal>LOCAL_NET_CONFIG</literal> y la
regla de reescritura podría estar haciendo?
</para>

<para>
La macro <literal>LOCAL_NET_CONFIG</literal> permite agregar reglas 
de reescritura directamente a la configuración de <command>sendmail</command> 
que definirá qué correo se deberá quedar dentro del sistema local. En 
nuestro ejemplo, se ha utilizado una regla en la que cualquier correo 
electrónico cuyo dominio coincida con el dominio de nuestro anfitrión 
(<literal>.$m.</literal>) se reescribe para ser enviado directamente 
usando el transporte <literal>SMTP</literal>.  Esto asegura que cualquier 
mensaje enviado hacia un anfitrión dentro de nuestro dominio local será 
redirigido inmediatamente al transporte  SMTP y enviado directamente a ese 
anfitrión en vez de pasar a través de nuestro anfitrión inteligente, que es 
el tratamiento por omisión.
</para>

</sect2>

<sect2><title>Gestionando correo no deseado o no solicitado (Spam)</title>
<para>
<INDEXTERM id="sendmail.spam" class=startofrange><PRIMARY>spam</PRIMARY></INDEXTERM>
<INDEXTERM id="unsol.mail.managing" class=startofrange><PRIMARY>correo no solicitado, gestión</PRIMARY></INDEXTERM>
<INDEXTERM id="email.unsolicited" class=startofrange><PRIMARY>email</PRIMARY><SECONDARY>no solicitado</SECONDARY></INDEXTERM>
<INDEXTERM id="email.manag.spam" class=startofrange><PRIMARY>email</PRIMARY><SECONDARY>gestión del spam</SECONDARY></INDEXTERM>
Si se ha suscrito a una lista de correo, publicado su dirección de
correo electrónico en un sitio web, o enviado un artículo a UseNet, lo
más probable es que comience a recibir correo electrónico no
solicitado con anuncios. Son los lugares comunes en donde la gente que
ronda por la red busca las direcciones de correo para agregarlas a
listas de correo que luego venden a compañías que buscan anunciar sus
productos. A este tipo de correo masivo se le conoce como spam.
</para>
<?troff .Nd 15>

<para>
El diccionario gratuito de la computación en línea ofrece una
definición con respecto al correo de spam que dice:
<footnote id="X-087-2-FNSD01"><para>
El diccionario gratuito de la computación en línea puede ser
encontrado empaquetado en muchas distribuciones de GNU/Linux, o en línea
en su página web en <systemitem role="url">http://wombat.doc.ic.ac.uk/foldoc/</systemitem>.
</para></footnote></para>

<blockquote>
<para>
2. (En un sentido más estricto que 1, arriba) El envío indiscriminado de grandes
cantidades de correo electrónico no solicitado para promocionar un
producto o un servicio. El spam, en este sentido, es una especie
equivalente electrónico de el correo basura enviado al "inquilino."
</para>

<para>
En los años 90, con el crecimiento del interés comercial en la red,
hay algunas personas sin escrúpulos<footnote><para>N. del T:literalmente 
"scumbags" o sacos de mierda</para></footnote> que ofrecen el uso del spam como
un "servicio" a las compañías que quieren anunciarse en la red. Ello
lo consiguen al enviar mensajes a grandes colecciones de direcciones
de correo, foros de noticias de Usenet o listas de correo. Dichas
prácticas han causado furia y reacción agresiva de muchos usuarios de
la red en contra de dichos individuos.
</para>
</blockquote>


<para>
Por fortuna, <command>sendmail</command> tiene algunos mecanismos que
pueden ayudar a tratar al correo no solicitado.
</para>

<sect3><title>Las Listas Negras en Tiempo Real (RBL)</title>
<para>
<INDEXTERM><PRIMARY>blackhole</PRIMARY></INDEXTERM>
<indexterm><primary>listas negras</primary></indexterm>

Las listas de exclusión <footnote><para>N. del T: 
Del inglés "black hole", agujero negro</para></footnote> 
en tiempo real (RBL, Real-time Blackhole List) es una lista pública 
que ayuda a reducir 
el volumen de anuncios no solicitados con los que se tiene que
tratar. Algunas fuentes de correo electrónico están en listadas en una
base de datos consultable a través de Internet. Ellos han sido
incluidos allí por la gente que recibe anuncios no solicitados de
alguna dirección de correo. Los grandes dominios, en ocasiones están
en dicha lista debido a algún resbalón que les impidió detener el
spam. Mientras que alguna gente se queja de alguna selección en
particular hecha por los mantenedores de la lista, aún sigue siendo
muy popular y los errores se arreglan con rapidez. Todos los detalles
de la operación de cómo opera el servicio están en el sitio web del
Sistema de Protección contra el Abuso del Correo en 
<emphasis>http://maps.vix.com/rbl/</emphasis>.
</para>

<para>
Si se habilita esta opción de <command>sendmail</command>, se buscará
la dirección de origen de cada mensaje que llegue en la base de datos
de la Lista Negra en tiempo real para determinar si se acepta
o no el mensaje. Si se tiene un gran sitio con muchos usuarios, esta
opción podría ahorrarles una gran cantidad de espacio en disco. Esta
opción acepta como parámetro especificar el nombre del servidor que se
va a utilizar. El servidor principal por omisión es
<systemitem role="sitename">rbl.maps.vix.com</systemitem>.
</para>

<para>
Para configurar la opción de "listas negras en tiempo real", se
debe agregar la siguiente declaración de macro en el fichero
<filename>sendmail.mc</filename>:

<screen>
FEATURE(rbl)
</screen>
</para>

<para>
Si se quiere especificar otro servidor de RBL, la declaración que se
debe escribir debe ser como la siguiente:

<screen>
FEATURE(rbl,`rbl.host.net')
</screen>
</para>

</sect3>

<sect3 id="X-087-2-sendmail.accessdb"><title>La base de datos de acceso</title>
<para>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>base de datos de acceso</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>access_db (sendmail), opción</PRIMARY></INDEXTERM>

Un sistema alternativo que tiene gran flexibilidad para el control a
cambio del costo que implica una configuración manual es la opción
<systemitem role="keyword">access_db</systemitem>. La base de datos de
acceso permite configurar qué anfitriones o usuarios serán aceptables
para enviar correo y quiénes pueden utilizarlo como puente.
</para>

<para>
Gestionar a quiénes se les permitirá reenviar el correo es muy
importante ya que el reenvío es una técnica de uso común para mandar
correo basura a los anfitriones que tienen sistemas como el RBL del
que se comentó anteriormente para evitar la basura. En vez de enviar
el correo directamente, los 'spammers' utilizarán el reenvío a través
de un anfitrión que, ingenuamente, lo permita. La conexión entrante de
SMTP no provendrá del anfitrión conocido por enviar basura, sino de
quien lo reenvió. Para garantizar que nuestro anfitrión no sea
utilizado de esta forma, sólo se debe reenviar el correo de los sitios
autorizados. Las versiones de <command>sendmail</command> que son
8.9.0 o posteriores, tienen el reenvío deshabilitado por omisión, así
que para ellos será necesario utilizar la base de datos de acceso para
habilitar a los sitios locales para que puedan reenviar sus mensajes.
</para>

<para>
La idea general es muy sencilla. Cuando se recibe una conexión de
entrada por SMTP, <command>sendmail</command> toma la información del
encabezado de entrada y luego consulta la base de datos de acceso para
ver si aceptará el contenido del mensaje.
</para>

<para>
La base de datos de acceso es una colección de reglas que describen
qué acciones se deben tomar para los mensajes recibidos de los
anfitriones nombrados. El fichero de control de acceso por omisión se
llama <filename>/etc/mail/access</filename>. La tabla tiene un formato
muy simple. Cada línea de la tabla contiene una regla de acceso. El
lado izquierdo de cada regla es un patrón utilizado para comparar con
el remitente de un mensaje de correo de entrada. Puede ser una
dirección de correo completa, un nombre de anfitrión o una dirección
IP. El lado derecho es la acción que se deberá tomar. Hay cinco tipos
de acciones que se pueden seleccionar y son:
</para>

<variablelist>
<varlistentry>
<term>OK</term>
<listitem><para>
Aceptar el mensaje.
</para></listitem>
</varlistentry>

<varlistentry>
<term>RELAY</term>
<listitem><para>
Aceptar los mensajes para este anfitrión o usuario aún si no provienen
de nuestro anfitrión; esto es, aceptar que los mensajes sean
reenviados hacia otros anfitriones desde este anfitrión.
</para></listitem>
</varlistentry>

<varlistentry>
<term>REJECT</term>
<listitem><para>
Rechazar el correo con un mensaje genérico.
</para></listitem>
</varlistentry>

<varlistentry>
<term>DISCARD</term>
<listitem><para>
Descartar el mensaje utilizando la propiedad
<literal>$#discard</literal> del sistema de correo.
</para></listitem>
</varlistentry>

<varlistentry>
<term>### cualquier texto</term>
<listitem><para>
Contestar con un mensaje de error utilizando
<replaceable>###</replaceable> como código de error (el cual deberá
cumplir con el RFC-821) y &ldquo;cualquier texto&rdquo; será el
mensaje.
</para>
</listitem>
</varlistentry>
</variablelist>
<?troff .Nd 15>
<para>
Como ejemplo, el fichero <filename>/etc/mail/access</filename> podría
ser como este:

<screen>
friends@cybermail.com   REJECT
aol.com                 REJECT
207.46.131.30           REJECT
postmaster@aol.com      OK
linux.org.au            RELAY
</screen>
</para>

<para>
Este ejemplo rechazará cualquier correo que se reciba desde
<systemitem role="email">friends@cybermail.com</systemitem>, cualquier
anfitrión en el dominio <emphasis role="bold">aol.com</emphasis> y el
anfitrión <emphasis role="bold">207.46.131.30</emphasis>. La siguiente
regla aceptará correo electrónico desde <systemitem
role="email">postmaster@aol.com</systemitem> a pesar del hecho de
que el dominio en sí mismo tiene una regla de rechazo. Y la última
regla permite el reenvío de correo de cualquier anfitrión en el
dominio <emphasis role="bold">linux.org.au</emphasis>.
</para>

<para>
Para habilitar la opción de la base de datos de acceso, se debe
utilizar la siguiente declaración en su fichero
<filename>sendmail.mc</filename>:

<screen>
FEATURE(access_db)
</screen>
</para>

<para>
La definición por omisión construye la base de datos con
<literal>hash -o /etc/mail/access</literal>, lo que genera una base de
datos con formato hash a partir de un fichero de texto simple. Esto es
perfectamente adecuado en la mayor parte de las instalaciones. Hay
otras opciones que se deben considerar si se intenta tener una gran
base de datos de acceso. Consulte el libro de
<emphasis>sendmail</emphasis> u otra documentación de
<command>sendmail</command> para más detalles.
</para>

</sect3>

<sect3><title>Exclusión usuarios de la recepción de correo</title>
<para>
<INDEXTERM><PRIMARY>email</PRIMARY><SECONDARY>exclusión de usuarios de la recepción</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>blacklist_recipients, característica (sendmail)</PRIMARY></INDEXTERM>
Si tiene usuarios o procesos automatizados que envían correo pero nunca necesitan recibirlo,
es a veces útil no aceptar el correo destinado a ellos. Esto salva espacio de disco malgastado en 
almacenar correo que nunca será leído. la característica <systemitem role="keyword">blacklist_recipients</systemitem>
cuando se usa en combinación con la característica <systemitem role="keyword">access_db</systemitem> le permite
desactivar la recepción de correo para usuarios locales.
</para>

<para>
Para activar la característica, agregue las siguientes líneas al fichero 
<filename>sendmail.mc</filename>, si no están ya allí:

<screen>
FEATURE(access_db)
FEATURE(blacklist_recipients)
</screen>
</para>

<para>
Para desactivar la recepción de correo de un usuario local, simplemente añada sus datos a la base de 
datos de acceso. Normalmente podría usar el estilo de entrada <replaceable>###</replaceable> que devolvería un 
mensaje de error con significado al remitente para que así sepa por qué el correo 
no se ha entregado. Esta característica se aplica igualmente bien a usuarios en dominios de correo 
virtuales, y debe incluir el dominio virtual de correo en la especificación de la base de datos de 
acceso. Algunas entradas de <filename>/etc/mail/access</filename> podrían semejarse a esto:

<screen>
daemon          550 El demonio no acepta ni lee correo.
flacco          550 El correo de este usuario ha sido desactivado administrativamente.
grump@dairy.org 550 Correo desactivado para este destinatario.
</screen>
</para>

</sect3>
<INDEXTERM startref="sendmail.spam" class=endofrange>
<INDEXTERM startref="unsol.mail.managing" class=endofrange>
<INDEXTERM startref="email.unsolicited" class=endofrange>
<INDEXTERM startref="email.manag.spam" class=endofrange>
</sect2>

<sect2><title>Configurando el Hospedaje Virtual de Correo</title>
<para>
<INDEXTERM><PRIMARY>email</PRIMARY><SECONDARY>hospedaje virtual</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>hospedaje virtual de correo electrónico</SECONDARY></INDEXTERM>
El hospedaje virtual de correo proporciona a un anfitrión la capacidad de aceptar y 
entregar correo en nombre de varios dominios diferentes aunque estén en varios hospedajes de correo 
separados. Normalmente son los Proveedores de Aplicación de Internet los que explotan el hospedaje virtual 
en combinación con hospedaje virtual de webs, pero es sencillo de configurar y nunca se
sabrá cuando tendrá la necesidad de hospedar virtualmente una lista de correo para 
su proyecto favorito de GNU/Linux, así que lo describiremos aquí.
</para>

<sect3><title>Aceptar correo para otros dominios</title>
<para>
<INDEXTERM><PRIMARY>hospedaje virtual de correo electrónico</PRIMARY><SECONDARY>aceptar correo para otros dominios</SECONDARY></INDEXTERM>
Cuando <command>sendmail</command> recibe un mensaje de correo electrónico, compara el
anfitrión de destino en las cabeceras del mensaje con el nombre del anfitrión local. Si 
coinciden, <command>sendmail</command> acepta el mensaje para entrega local;
si difieren, <command>sendmail</command> puede decidir aceptar el mensaje e intentar 
reenviarlo al destino final (Vea <xref linkend="X-087-2-sendmail.accessdb"> más tarde en este capítulo
para detalles sobre cómo configurar <command>sendmail</command> para aceptar correo para reenvío&thinsp;).
</para>

<para>
Si deseásemos configurar hospedeaje virtual de correo, la primera cosa que necesitamos hacer
es convencer a  <command>sendmail</command> de que deba aceptar también correo para los 
dominios que estamos hospedando. Afortunadamente, esto es muy sencillo de hacer.
</para>

<para>
La característica de <command>sendmail</command>
<systemitem role="keyword">use_cw_file</systemitem> nos permite especificar el nombre de un
fichero donde almacenamos nombres de dominio para los que <command>sendmail</command> acepta 
correo. Para configurar la característica, añada la declaración de la característica a su 
fichero <filename>sendmail.mc</filename>:

<screen>
FEATURE(use_cw_file)
</screen>
</para>

<para>
El nombre predeterminado del fichero será <filename>/etc/mail/local-host-names</filename> 
para distribuciones que usen el directorio de configuración <filename>/etc/mail/</filename> o 
<filename>/etc/sendmail.cw</filename> para aquellas que no. Alternativamente,
puede especificar el nombre y la localización del fichero anulando la macro 
<literal>confCW_FILE</literal> utilizando una variacion en:

<screen>
define(`confCW_FILE',`/etc/virtualnames')
</screen>
</para>

<para>
Para seguir con el nombre del fichero predeterminado, si deseásemos ofrecer 
hospedaje virtual a los dominios <emphasis role="bold">bovine.net</emphasis>, <emphasis role="bold">dairy.org</emphasis>, y
<emphasis role="bold">artist.org</emphasis>, crearíamos un fichero 
<filename>/etc/mail/local-host-names</filename> semejante a:

<screen>
bovine.net
dairy.org
artist.org
</screen>
</para>

<para>
Cuando esto está hecho, y asumiendo que los registros DNS apropiados existen y apuntan 
éstos nombres de dominio a nuestro anfitrión,  <command>sendmail</command> aceptará los mensajes de correo
para estos dominios como si estuviesen dirigidos a nuestro propio nombre de dominio real.
</para>
</sect3>

<sect3><title>Reenvío de correo hospedado virtualmente a otros destinos</title>
<para>
<INDEXTERM><PRIMARY>hospedaje virtual de correo electrónico</PRIMARY><SECONDARY>reenvío de correo a otros destinos</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>virtusertable, característica</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>virtusertable, característica (sendmail)</PRIMARY></INDEXTERM>
La característica de <command>sendmail</command>
<systemitem role="keyword">virtusertable</systemitem> configura 
el soporte para la tabla de usuarios virtuales, donde configuramos el hospedaje de
correo virtual. Las tablas de usuarios virtuales mapean el correo entrante destinado a 
algunos <emphasis>usuarios@anfitrión</emphasis> a algunos <emphasis>otro_usuario@otro_anfitrión</emphasis>.
Puede pensar en esto como una característica de alias avanzada; una que opera usando no sólo el 
usuario de destino, sino también el dominio de destino.
</para>

<para>
Para configurar la característica <systemitem role="keyword">virtusertable</systemitem>, 
añada la característica a su configuración <filename>sendmail.mc</filename>  como se muestra:

<screen>
FEATURE(virtusertable)
</screen>
</para>

<para>
Por omisión, el fichero conteniendo las reglas para efectuar las traducciones será 
<filename>/etc/mail/virtusertable</filename>. Puede anular éste mediante
el suministro de un argumento a la definición de la macro; consulte una 
referencia detallada de <command>sendmail</command> para aprender acerca de qué opciones
están disponibles.
</para>

<para>
El formato de la tabla de usuarios virtuales es muy sencillo. En el lado izquierdo de cada
línea hay un patrón representando el la dirección de destino original; al lado derecho,
un patrón representando la dirección de correo a la que la se mapeará la dirección virtual hospedada.
</para>

<para>
El siguiente ejemplo muestra tres posibles tipos de entradas:

<screen>
samiam@bovine.net     colin
sunny@bovine.net      darkhorse@mystery.net
@dairy.org            mail@jhm.org
@artist.org           $1@red.firefly.com
</screen>

En este ejemplo, estamos hospedando virtualmente tres dominios:
<emphasis role="bold">bovine.net</emphasis>, <emphasis role="bold">dairy.org</emphasis>, y
<emphasis role="bold">artist.org</emphasis>.
</para>

<para>
La primera entrada reenvía el correo dirigido a un usuario en el dominio virtual
<emphasis role="bold">bovine.net</emphasis> a un usuario local en la máquina. La segunda
entrada reenvía el correo a un usuario en el mismo dominio virtual a un usuario 
en otro dominio. El tercer ejemplo reenvía todo el correo dirigido a cualquier usuario 
dentro del dominio virtual  <emphasis role="bold">dairly.org</emphasis> a una
sola dirección de correo remota. Finalmente, la última entrada reenvía cualquier correo
a un usuario en el dominio virtual  <emphasis role="bold">artist.org</emphasis> al mismo
usuario en otro dominio; por ejemplo,
<systemitem role="email">julie@artists.org</systemitem> sería reenviado a 
<systemitem role="email">julie@red.firefly.com</systemitem>.
</para>
</sect3>
</sect2>
<INDEXTERM startref="sendmail.configs" class=endofrange>
</sect1>

<sect1><title>Probando la Configuración</title>
<para>
<INDEXTERM id="sendmail.testing.config" class=startofrange><PRIMARY>sendmail</PRIMARY><SECONDARY>probando la configuración</SECONDARY></INDEXTERM>
<INDEXTERM id="testing.sendmail.config" class=startofrange><PRIMARY>probando</PRIMARY><SECONDARY>sendmail,  configuración</SECONDARY></INDEXTERM>
La orden <command>m4</command> procesa los ficheros de definición de la macro 
de acuerdo a sus propias reglas de sintaxis  sin entender nada sobre la
corrección de la sintaxis de <command>sendmail</command>; así que no debería haber ningún 
mensaje de error si tiene algo equivocado en el fichero de definición de macros.
Por esta razón, es muy importante que pruebe su configuración. Afortunadamente, 
<command>sendmail</command> proporciona una manera relativamente fácil de hacer esto.
</para>

<para>
<command>sendmail</command> soporta un modo de &ldquo;prueba de direcciones&rdquo; que
nos permite probar nuestra configuración e identificar cualquier error. En este modo 
de operación, invocamos <command>sendmail</command> desde la línea de órdenes,
y él mismo nos pide una especificación del conjunto de reglas y una dirección de destino.
<command>sendmail</command> entonces procesa esa dirección de destino usando 
las reglas especificadas, mostrando la salida de cada regla de reescritura  mientras 
se realiza. Para poner <command>sendmail</command> en este modo, lo invocamos con el 
argumento <literal>&ndash;bt</literal>:
</para>

<screen>
# <userinput>/usr/sbin/sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
&gt;
</screen>

<para>
El fichero de configuración usado por omisión es el fichero <filename>/etc/mail/sendmail.cf</filename>;
puede especificar uno alternativo usando el argumento  <literal>&ndash;C</literal>. Para probar nuestra
configuración, necesitamos seleccionar varias direcciones para procesar que nos dirán que cada uno de los 
requerimientos de manipulación del correo se encuentran. Para ilustrar esto, trabajaremos a través de
nuestra configuración UUCP más complicada mostrada en  <xref linkend="X-087-2-sendmail.mc.uucpsmtp">.
</para>

<para>
Primero, probaremos que <command>sendmail</command> es capaz de entregar correo a los 
usuarios locales del sistema. En estas pruebas, todas las direcciones  serán reescritas 
al transporte de correo <emphasis role="bold">local</emphasis> en esta máquina:
</para>

<screen>
# <userinput>/usr/sbin/sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
&gt; <userinput>3,0 isaac</userinput>
rewrite: ruleset   3   input: isaac
rewrite: ruleset  96   input: isaac
rewrite: ruleset  96 returns: isaac
rewrite: ruleset   3 returns: isaac
rewrite: ruleset   0   input: isaac
rewrite: ruleset 199   input: isaac
rewrite: ruleset 199 returns: isaac
rewrite: ruleset  98   input: isaac
rewrite: ruleset  98 returns: isaac
rewrite: ruleset 198   input: isaac
rewrite: ruleset 198 returns: $# local $: isaac
rewrite: ruleset   0 returns: $# local $: isaac
</screen>

<para>
Esta salida nos muestra cómo <command>sendmail</command> procesa el correo dirigido
a <emphasis role="bold">isaac</emphasis> en este sistema. cada línea nos muestra qué información 
ha sido suministrada a un conjunto de reglas o el resultado obtenido del procesamiento por un 
conjunto de reglas. Le dijimos a  <command>sendmail</command> que deseábamos emplear el conjunto de reglas 3 y
0 para procesar la dirección. El conjunto 0 es lo que se invoca normalmente y nosotros forzamos
el conjunto 3 porque no se comprueba por omisión. La última línea nos muestra que el resultado 
del conjunto 0 en efecto reenvía el correo a  <emphasis role="bold">isaac</emphasis> al transporte de 
correo <emphasis role="bold">local</emphasis>.
</para>
<?troff .Nd 15>
<para>
Lo siguiente que comprobaremos es el correo dirigido a nuestra dirección SMTP: <emphasis role="bold">isaac@vstout.vbrew.com</emphasis>. 
Deberíamos ser capaces de producir el mismo resultado final como en nuestro ejemplo último:
</para>

<screen>
# <userinput>/usr/sbin/sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
&gt; 3,0 isaac@vstout.vbrew.com
rewrite: ruleset   3   input: isaac @ vstout . vbrew . com
rewrite: ruleset  96   input: isaac &lt; @ vstout . vbrew . com &gt;
rewrite: ruleset  96 returns: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset   3 returns: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset   0   input: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset 199   input: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset 199 returns: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset  98   input: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset  98 returns: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset 198   input: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset 198 returns: $# local $: isaac
rewrite: ruleset   0 returns: $# local $: isaac
</screen>

<para>
Otra vez la prueba se pasó. Lo siguiente es probar el correo a nuestra dirección estilo UUCP:
<emphasis role="bold">vstout!isaac</emphasis>.
</para>

<screen>
# <userinput>/usr/sbin/sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
&gt; 3,0 vstout!isaac
rewrite: ruleset   3   input: vstout ! isaac
rewrite: ruleset  96   input: isaac &lt; @ vstout . UUCP &gt;
rewrite: ruleset  96 returns: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset   3 returns: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset   0   input: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset 199   input: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset 199 returns: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset  98   input: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset  98 returns: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset 198   input: isaac &lt; @ vstout . vbrew . com . &gt;
rewrite: ruleset 198 returns: $# local $: isaac
rewrite: ruleset   0 returns: $# local $: isaac
</screen>

<para>
Esta prueba también se pasó. Estas pruebas confirman que cualquier correo recibido
para los usuarios locales en nuestra máquina será entregado apropiadamente sin importar
cómo está formateada la dirección. Si ha definido cualquier alias en su máquina, como 
hospedajes virtuales, debería repetir estas pruebas para cada uno de los nombres
alternativos por los que este anfitrión se conoce para asegurarse  que también 
funcionan correctamente.
</para>

<para>
Después, probaremos que el correo dirigido a otros anfitriones en el dominio 
<emphasis role="bold">vbrew.com</emphasis> se entregan directamente a ese
anfitrión usando el transporte de correo SMTP:
</para>

<screen>
# <userinput>/usr/sbin/sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
&gt; 3,0 isaac@vale.vbrew.com
rewrite: ruleset   3   input: isaac @ vale . vbrew . com
rewrite: ruleset  96   input: isaac &lt; @ vale . vbrew . com &gt;
rewrite: ruleset  96 returns: isaac &lt; @ vale . vbrew . com . &gt;
rewrite: ruleset   3 returns: isaac &lt; @ vale . vbrew . com . &gt;
rewrite: ruleset   0   input: isaac &lt; @ vale . vbrew . com . &gt;
rewrite: ruleset 199   input: isaac &lt; @ vale . vbrew . com . &gt;
rewrite: ruleset 199 returns: isaac &lt; @ vale . vbrew . com . &gt;
rewrite: ruleset  98   input: isaac &lt; @ vale . vbrew . com . &gt;
rewrite: ruleset  98 returns: isaac &lt; @ vale . vbrew . com . &gt;
rewrite: ruleset 198   input: isaac &lt; @ vale . vbrew . com . &gt;
rewrite: ruleset 198 returns: $# smtp $@ vale . vbrew . com . /
    $: isaac &lt; @ vale . vbrew . com . &gt;
rewrite: ruleset   0 returns: $# smtp $@ vale . vbrew . com . /
    $: isaac &lt; @ vale . vbrew . com . &gt;
</screen>

<para>
Podemos ver que esta prueba ha dirigido el mensaje  al transporte SMTP para ser reenviado 
directamente al anfitrión  <emphasis role="bold">vale.vbrew.com</emphasis> y especifica el usuario 
<emphasis role="bold">isaac</emphasis>. Esta prueba confirma que la definición 
<literal>LOCAL_NET_CONFIG</literal> funciona correctamente. Para que esta prueba
sea satisfactoria, el nombre del anfitrión de destino debe ser resuelto correctamente,
así que debe tener una entrada en nuestro fichero 
<filename>/etc/hosts</filename>, o en nuestro DNS local. Podemos ver qué
ocurre si el nombre del anfitrión de destino no es capaz de resolverse especificando
intencionadamente un anfitrión desconocido:
</para>

<screen>
# <userinput>/usr/sbin/sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
&gt; 3,0 isaac@vXXXX.vbrew.com
rewrite: ruleset   3   input: isaac @ vXXXX . vbrew . com
rewrite: ruleset  96   input: isaac &lt; @ vXXXX . vbrew . com &gt;
vXXXX.vbrew.com: Name server timeout
rewrite: ruleset  96 returns: isaac &lt; @ vXXXX . vbrew . com &gt;
rewrite: ruleset   3 returns: isaac &lt; @ vXXXX . vbrew . com &gt;
== Ruleset 3,0 (3) status 75
rewrite: ruleset   0   input: isaac &lt; @ vXXXX . vbrew . com &gt;
rewrite: ruleset 199   input: isaac &lt; @ vXXXX . vbrew . com &gt;
rewrite: ruleset 199 returns: isaac &lt; @ vXXXX . vbrew . com &gt;
rewrite: ruleset  98   input: isaac &lt; @ vXXXX . vbrew . com &gt;
rewrite: ruleset  98 returns: isaac &lt; @ vXXXX . vbrew . com &gt;
rewrite: ruleset 198   input: isaac &lt; @ vXXXX . vbrew . com &gt;
rewrite: ruleset  95   input: &lt; uucp-new : moria &gt; isaac &lt;/
    @ vXXXX . vbrew . com &gt;
rewrite: ruleset  95 returns: $# uucp-new $@ moria $: isaac &lt;/
    @ vXXXX . vbrew . com &gt;
rewrite: ruleset 198 returns: $# uucp-new $@ moria $: isaac &lt;/
    @ vXXXX . vbrew . com &gt;
rewrite: ruleset   0 returns: $# uucp-new $@ moria $: isaac &lt;/
    @ vXXXX . vbrew . com &gt;
</screen>

<para>
Este resultado es muy diferente. Primero el conjunto de reglas 3 
devuelve un mensaje de error indicando que el nombre del anfitrión no se pudo resolver.
segundo, tratamos esta situación delegando en la otra característica clave de 
nuestra configuración: el anfitrión inteligente. El anfitrión inteligente estará
para manipular cualquier correo que no se pueda entregar de otra manera. El nombre del anfitrión
que especificamos en esta prueba era incapaz de ser resuelto y los conjuntos de reglas determinaron
que el correo debería ser reenviado a nuestro anfitrión inteligente <emphasis role="bold">moria</emphasis> 
usando el transporte de correo <emphasis role="bold">uucp-new</emphasis>. Nuestro anfitrión inteligente quizá 
esté mejor conectado y sepa qué hacer con la dirección.
</para>

<para>
Nuesta prueba final asegura que cualquier correo dirigido a un anfitrión que no esté dentro de 
nuestro dominio se entrega a nuestro anfitrión inteligente. Esto debería producir un resultado similar 
a nuestro ejemplo previo:
</para>

<screen>
# <userinput>/usr/sbin/sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
&gt; 3,0 isaac@linux.org.au
rewrite: ruleset   3   input: isaac @ linux . org . au
rewrite: ruleset  96   input: isaac &lt; @ linux . org . au &gt;
rewrite: ruleset  96 returns: isaac &lt; @ linux . org . au . &gt;
rewrite: ruleset   3 returns: isaac &lt; @ linux . org . au . &gt;
rewrite: ruleset   0   input: isaac &lt; @ linux . org . au . &gt;
rewrite: ruleset 199   input: isaac &lt; @ linux . org . au . &gt;
rewrite: ruleset 199 returns: isaac &lt; @ linux . org . au . &gt;
rewrite: ruleset  98   input: isaac &lt; @ linux . org . au . &gt;
rewrite: ruleset  98 returns: isaac &lt; @ linux . org . au . &gt;
rewrite: ruleset 198   input: isaac &lt; @ linux . org . au . &gt;
rewrite: ruleset  95   input: &lt; uucp-new : moria &gt; isaac &lt;/
    @ linux . org . au . &gt;
rewrite: ruleset  95 returns: $# uucp-new $@ moria $: isaac &lt;/
    @ linux . org . au . &gt;
rewrite: ruleset 198 returns: $# uucp-new $@ moria $: isaac &lt;/
    @ linux . org . au . &gt;
rewrite: ruleset   0 returns: $# uucp-new $@ moria $: isaac &lt;/
    @ linux . org . au . &gt;
</screen>

<para>
Los resultados de esta prueba indican que el nombre del anfitrión se resolvió, y que el 
mensaje podría ser encaminado a nuestro anfitrión inteligente. Esto prueba que nuestra 
definición <literal>LOCAL_NET_CONFIG</literal> funciona correctamente y que manejó ambos casos
correctamente. Esta prueba es también exitosa, así que podemos felizmente asumir que nuestra configuración 
es correcta y usarla.
</para>
<INDEXTERM startref="sendmail.testing.config" class=endofrange>
<INDEXTERM startref="testing.sendmail.config" class=endofrange>
</sect1>

<sect1><title>Ejecución de Sendmail</title>
<para>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>ejecución de</SECONDARY></INDEXTERM>
El demonio <command>sendmail</command> puede ejecutarse de dos formas. Una manera es ejecutarlo
desde el demonio <command>inetd</command> y la otra, más usual, es ejecutar <command>sendmail</command> 
como un demonio en solitario. También es común para los programas de transporte invocar <command>sendmail
</command> como una orden de usuario para aceptar el envío del correo generado localmente.
</para>

<para>
Cuando se ejecuta  <command>sendmail</command> de modo solitario, se pone la instrucción
en un fichero <filename>rc</filename>para que se inicie en tiempo de arranque. La sintaxis
usada es normalmente:
<screen>
/usr/sbin/sendmail -bd -q10m
</screen>

El argumento  <literal>-bd</literal> le dice a  <command>sendmail</command> que se ejecute
como un demonio. Se bifurcará y se ejecutará en segundo plano. El argumento
<literal>-q10m</literal> le indica a  <command>sendmail</command>
que verifique su cola cada diez minutos. Puede escoger un tiempo diferente para verificar la cola.
</para>

<para>
Para ejecutar <command>sendmail</command> desde el demonio de red  <command>inetd</command> 
podría usar una entrada como ésta:

<screen>
smtp  stream  tcp nowait  nobody  /usr/sbin/sendmail -bs
</screen>

El argumento  <literal>-bs</literal> aquí le dice a  <command>sendmail</command>
que utilice el protocolo SMTP en  stdin/stdout, que se requiere para utilizarlo con
<command>inetd</command>.
</para>

<para>
La orden <command>runq</command> es usualmente un enlace simbólico al binario de 
<command>sendmail</command> y es una forma más conveniente que:

<screen>
# <userinput>sendmail -q</userinput>
</screen>
</para>

<para>
Cuando <command>sendmail</command> se invoca de esta manera, procesa cualquier correo
esperando en la cola para ser transmitido. Cuando se ejecuta <command>sendmail</command>
desde <command>inetd</command> debe crear un trabajo  en <command>cron</command> que ejecute
la orden  <command>runq</command> periódicamente para asegurarse que el correo se sirve 
periódicamente.
</para>

<para>
Una tabla de <command>cron</command> útil sería similar a :

<screen>
# Ejecutar la entrega de correo cada quince minutos
0,15,30,45     *     *     *     *     /usr/bin/runq
</screen>
</para>

<para>
En muchas instalaciones <command>sendmail</command> procesa la cola
cada 15 minutos como se muestra en nuestra tabla <filename>crontab</filename> de ejemplo,
intentando transmitir cualquier mensaje allí.
</para>

</sect1>

<sect1><title>Peculiaridades y Advertencias</title>
<para>
<INDEXTERM id="sendmail.mgmt.tools" class=startofrange><PRIMARY>sendmail</PRIMARY><SECONDARY>herramientas de administración</SECONDARY></INDEXTERM>
Hay varias cosas que  se pueden hacer para que la gestión de  un sitio 
<command>sendmail</command> sea eficiente. Se proporcionan varias herramientas
en el paquete <command>sendmail</command>; echemos un vistazo a las más importantes de éstas.
</para>

<sect2><title>Gestión de la Cola de Correo</title>
<para>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>gestión de la cola de correo</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>cola de correo, gestión</PRIMARY></INDEXTERM>
El correo es encolado en el directorio <filename>/var/spool/mqueue</filename> 
antes de ser transmitido. Este directorio se llama la cola de correo<footnote><para>mail spool</para></footnote>.
El programa <command>sendmail</command>proporciona un método para mostrar una 
lista formateada de todos los mensajes de correo en la cola y su estado.
</para>

<para>
La orden <command>/usr/bin/mailq</command> es un enlace simbólico al ejecutable de 
<command>sendmail</command> y se comporta idénticamente a:

<screen>
# <userinput>sendmail -bp</userinput>
</screen>

La salida muestra el identificador del mensaje (ID), su tamaño, la hora
en que fue colocado en la cola, quién lo envió y un mensaje indicando su estado actual.
El siguiente ejemplo muestra un mensaje de correo atascado en la cola con un problema:

<screen>
$ <userinput>mailq</userinput>
                Mail Queue (1 request)
--Q-ID-- --Size-- -----Q-Time----- ------------Sender/Recipient------------
RAA00275      124 Wed Dec  9 17:47 root
                 (host map: lookup (tao.linux.org.au): deferred)
                                   terry@tao.linux.org.au
</screen>

Este mensaje está todavía en la cola de correo porque la dirección IP del anfitrión de destino 
no se ha podido resolver.
</para>

<para>
Podemos forzar <command>sendmail</command> para procesar la cola ahora mediante la instrucción 
 <filename>/usr/bin/runq</filename>.
</para>

<para>
La orden  <command>runq</command> no produce ninguna salida.
<command>sendmail</command> comenzará procesando la cola de correo en segundo plano.
</para>
</sect2>

<sect2><title>Forzar a un Anfitrión Remoto a Procesar su Cola de Correo</title>
<para>
<INDEXTERM><PRIMARY>email</PRIMARY><SECONDARY>cola</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>proceso de colas de correo</SECONDARY></INDEXTERM>
Si usa una conexión a Internet temporal mediante marcado telefónico con una 
dirección IP <emphasis>fija</emphasis> y delega en un anfitrión MX para recibir
su correo mientras está desconectado, encontrará útil forzar al anfitrión MX para que
procese su cola de correo tan pronto como se establezca una conexión
</para>

<para>
Un pequeño programa  <command>perl</command> se incluye con la distribución de 
<command>sendmail</command> que hace esto simple para los anfitriones de correo que lo
soportan. El guión <command>etrn</command> tiene como mucho el mismo efecto 
en un anfitrión remoto como la instrucción <command>runq</command> tiene en el nuestro.
Si invocamos la orden como  se indica en este ejemplo:

<screen>
# <userinput>etrn vstout.vbrew.com</userinput>
</screen>

forzaremos al anfitrión <emphasis role="bold">vstout.vbrew.com</emphasis> que procese cualquier correo en espera para
nuestra máquina local.
</para>

<para>
Típicamente añadiría esta instrucción al guión PPP <filename>ip-up</filename> 
de manera que se ejecute tan pronto como la conexión de red sea establecida.
</para>

</sect2>

<sect2><title>Análisis de las Estadísticas de Correo</title>
<para>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>análisis de las estadísticas de correo</SECONDARY></INDEXTERM>
<command>sendmail</command> almacena datos de los volúmenes de tráfico de correo y 
alguna información sobre los anfitriones a los cuáles ha entregado correo. Hay
dos instrucciones disponibles para mostrar esta información,
<command>mailstats</command>, y <command>hoststat</command>.
</para>

<sect3><title>mailstats</title>
<para>
<INDEXTERM><PRIMARY>mailstats, orden</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>mailstats, orden</SECONDARY></INDEXTERM>
La orden <command>mailstats</command> muestra estadísticas del volumen
de correo procesado por <command>sendmail</command>. La hora a la que
la recogida de datos comenzó se imprime primero, seguida de una tabla
con una columna para cada transporte configurado y una mostrando un 
resumen total de todo el correo. Cada línea presenta ocho puntos de información:


<informaltable>
<tgroup cols=2>
<thead>
<row>
	<entry>Campo</entry>
	<entry>Significado</entry>
</row>
</thead>
<tbody>
<row>
	<entry><literal>M</literal></entry>
	<entry>El número del transporte (protocolo de transporte)</entry>
</row>
<row>
	<entry><literal>msgsfr</literal></entry>
	<entry>El número de mensajes desde el transporte</entry>
</row>
<row>
	<entry><literal>bytes_from</literal></entry>
	<entry>Los Kbytes de correo desde el transporte</entry>
</row>
<row>
	<entry><literal>msgsto</literal></entry>
	<entry>El número de mensajes enviados al transporte</entry>
</row>
<row>
	<entry><literal>bytes_to</literal></entry>
	<entry>Los Kbytes de correo enviados al transporte</entry>
</row>
<row>
        <entry><literal>msgsreg</literal></entry>
        <entry>El número de mensajes rechazados</entry>
</row>
<row>
        <entry><literal>msgsdis</literal></entry>
        <entry>El número de mensajes descartados</entry>
</row>
<row>
	<entry><literal>Mailer</literal></entry>
	<entry>El nombre del transporte</entry>
</row>
</tbody>
</tgroup>
</informaltable>

Un ejemplo de la salida de la orden <command>mailstats</command> se muestra
en <xref linkend="X-087-2-sendmail.mailstats">.
</para>

<example id="X-087-2-sendmail.mailstats">
<title>Ejemplo de la Salida de la Instrucción mailstats</title>
<screen>
<prompt>#</prompt> <userinput>/usr/sbin/mailstats</userinput>
Statistics from Sun Dec 20 22:47:02 1998
 M   msgsfr  bytes_from   msgsto    bytes_to  msgsrej msgsdis  Mailer
 0        0          0K       19        515K        0       0  prog
 3       33        545K        0          0K        0       0  local
 5       88        972K      139       1018K        0       0  esmtp
=============================================================
 T      121       1517K      158       1533K        0       0
</screen>
</example>

<para>
Estos datos son recogidos si la opción <emphasis>StatusFile</emphasis> está activada
en el fichero  <filename>sendmail.cf</filename> y el fichero de estado existe.
Típicamente añadiría lo siguiente a su fichero <filename>sendmail.cf</filename>:

<screen>
# status file
O StatusFile=/var/log/sendmail.st
</screen>
</para>

<para>
Para reiniciar la recogida de estadísticas, necesita hacer el fichero de estadísticas
de longitud cero:

<screen>
&gt; /var/log/sendmail.st
</screen>

y reiniciar <command>sendmail</command>.
</para>

</sect3>

<sect3><title>Hoststat</title>
<para>
<INDEXTERM><PRIMARY>hoststat, orden</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>sendmail</PRIMARY><SECONDARY>hoststat, orden</SECONDARY></INDEXTERM>
La instrucción <command>hoststat</command> muestra información sobre el estado de 
los anfitriones a los que <command>sendmail</command> ha intentado enviar correo. La 
instrucción <command>hoststat</command> es equivalente a invocar <command>sendmail</command> 
como:

<screen>
<userinput>sendmail -bh</userinput>
</screen>
</para>

<para>
La salida presenta cada anfitrión en su propia línea, y para cada
uno la hora desde que se intentó la entrega a él, y el mensaje de
estado recibido a esa hora.
</para>

<para>
<xref linkend="X-087-2-sendmail.hoststat"> muestra la clase de salida que podría esperarse
de la instrucción  <command>hoststat</command>. Nótese que la mayor parte de los 
resultados indican una entrega exitosa. El resultado para 
<emphasis role="bold">earthlink.net</emphasis>, por otra parte, indica 
que la entraga no fue exitosa. El mensaje de estado puede algunas veces ayudar
a determinar la causa del fallo. En este caso, la conexión expiró, probablemente 
porque el anfitrión estaba caído o inalcanzable a la hora en que la entrega se intentó.
</para>

<example id="X-087-2-sendmail.hoststat">
<title>Ejemplo de Salida de la Instrucción hoststat</title>
<screen>
<prompt>#</prompt> <userinput>hosts at</userinput>
 -------------- Anfitriónname ---------- How long ago ---------Results---------
 mail.telstra.com.au                    04:05:41 250 Message accepted for
 scooter.eye-net.com.au              81+08:32:42 250 OK id=0zTGai-0008S9-0
 yarrina.connect.com.a               53+10:46:03 250 LAA09163 Message acce
 happy.optus.com.au                  55+03:34:40 250 Mail accepted
 mail.zip.com.au                        04:05:33 250 RAA23904 Message acce
 kwanon.research.canon.com.au        44+04:39:10 250 ok 911542267 qp 21186
 linux.org.au                        83+10:04:11 250 IAA31139 Message acce
 albert.aapra.org.au                    00:00:12 250 VAA21968 Message acce
 field.medicine.adelaide.edu.au      53+10:46:03 250 ok 910742814 qp 721
 copper.fuller.net                   65+12:38:00 250 OAA14470 Message acce
 amsat.org                            5+06:49:21 250 UAA07526 Message acce
 mail.acm.org                        53+10:46:17 250 TAA25012 Message acce
 extmail.bigpond.com                 11+04:06:20 250 ok
 earthlink.net                       45+05:41:09 Deferred: Connection time 
</screen>
</example>

<para>
La instrucción <command>purgestat</command> vacía los datos del anfitrión recogidos y es 
equivalente a invocar sendmail como:

<screen>
# <userinput>sendmail -bH</userinput>
</screen>

</para>

<para>Las estadísticas continuarán creciendo hasta que usted las purge. Quizá quiera
ejecutar periódicamente la instrucción <command>purgestat</command> para hacer
más fácil buscar y encontrar entradas recientes, especialmente si tiene un sitio 
con mucho tráfico. Podría poner la orden en un fichero  <filename>crontab</filename> para que 
se ejecute automáticamente, o tan sólo hacerlo usted mismo ocasionalmente.
</para>

</sect3>
</sect2>
<INDEXTERM startref="sendmail.mgmt.tools" class=endofrange>
</sect1>
<INDEXTERM startref="idx-configuringsendmail" class=endofrange>
<INDEXTERM startref="idx-commandsendmailcommand-1" class=endofrange>
</chapter>

