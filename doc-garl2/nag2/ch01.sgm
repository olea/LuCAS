<!-- $Id: ch01.sgm,v 1.9 2002/11/17 17:43:43 pakojavi2000 Exp $ -->
<!--
Nota legal:

   Linux Network Administration Guide, por Olaf Kirch et al.

   La traducción al español se publica bajo la licencia GFDL,
siendo texto de portada el siguiente:

Linux Network Administrator's Guide
by Olaf Kirch and Terry Dawson
Copyright  (c) 1993 Olaf Kirch
Copyright  (c) 2000 Terry Dawson
Copyright on O'Reilly printed version (c) 2000 O'Reilly & Associates

y siendo secciones invariantes, la sección de Agradecimientos,
la sección titulada «La traducción al español», el apéndice C; así
como esta nota.

Capítulo traducido por:

  Sebastián Gurin, Cancerbero; anon@adinet.com.uy
  Revisión 1 por Francisco Javier Fernández
  Revisión 2 por Francisco Javier Fernández
-->

<chapter id="X-087-2-intro"><title>Introducción al Trabajo en Redes<?lb></title>
<sect1 id="X-087-2-intro.history"><title>Historia</title>

<para>
<indexterm id="chit.netwks.intro"
class="startofrange"><primary>redes</primary><secondary>introducción al trabajo en</secondary></indexterm> El concepto de trabajo en redes es probablemente tan antiguo como lo es el de las telecomunicaciones. Imagínese por un momento, gente viviendo en la Edad de Piedra, en donde los individuos usen tambores para transmitirse mensajes. Supóngase que un hombre de las cavernas A quiere invitar a otro hombre B a una partida de choques de piedra. Lamentablemente viven tan distantes, que a B le sería imposible escuchar el tambor de A cuando éste lo llame. ¿Qué puede hacer A para remediar esto?  Él podría 1) ir caminando al sitio de B, 2) conseguir un tambor más grande, o 3) pedirle a C, quien vive a mitad de camino que reenvíe el mensaje. La tercera elección es denominada <emphasis>Trabajo en Redes</emphasis>.
</para>

<para> 
Por supuesto, la humanidad ha avanzado un poco desde la la Edad de Piedra; ya no se usan aquellos primitivos artefactos ni tenemos los mismos inconvenientes que nuestros antepasados. En la actualidad, contamos con computadoras que hablan con otras sobre una colección de cables, fibra óptica, microondas, etc. tan grande como para llenar el estadio en el partido de fútbol de los sábados<footnote id="X-087-2-FNIT01"><para>Costumbre que todavía se usa algunas ocasiones en Europa (ver arriba). </para></footnote>
A continuación, se hará referencia a los conceptos y métodos que son utilizados para llevar a cabo todo esto. Sin embargo, dejaremos de lado tanto el tema de los cables, como la parte del fútbol.
</para>

<para>
En esta guía se describirán tres tipos de redes. Sin embargo, se discutirá más profundamente TCP/IP puesto que es el protocolo más usado, ya sea en Redes Locales (Local Area Networks, LANs), o en Redes de Área Amplia (Wide Area Networks, WANs), como por ejemplo, Internet. También se echará un vistazo a UUCP e IPX. UUCP fue antiguamente el medio general para transportar las noticias y los mensajes de correo, mediante una conexión telefónica. Es menos usado en estos días, pero sigue siendo útil en muchas situaciones. El protocolo IPX es usado más frecuentemente en los entornos Novell NetWare, y se detallará cómo usarlo<?troff .ne 7> para conectar una máquina GNU/Linux a una red Novell. Cada uno de estos protocolos de red son usados para transportar datos entre computadoras. Se discutirá aquí cómo son usados y se hará una introducción a sus principios fundamentales. 
</para>


<para>
<indexterm><primary>sitios</primary></indexterm>
<indexterm><primary>nodos</primary></indexterm>Se define una red, como una colección de <emphasis>nodos</emphasis> (del inglés hosts), capaces de comunicarse entre sí, a veces confiando en los servicios de un número determinado de máquinas que se encargan de transmitir datos entre quienes que lo demanden. Los nodos son casi siempre computadoras, pero no necesariamente; se puede pensar, sin equivocación, en terminales X o impresoras inteligentes como nodos. Por otro lado, a las pequeñas aglomeraciones de éstos, se las denomina <emphasis>sitios</emphasis>, (sites). 
</para>

<para>
<indexterm><primary>redes</primary><secondary>protocolos</secondary></indexterm>
<indexterm><primary>protocolos</primary></indexterm> 
La comunicación, sería imposible sin algún tipo de lenguaje o código. En la jerga de las redes de computadoras, estos lenguajes se denominan conjuntamente como <emphasis>protocolos</emphasis>. No obstante, no se debería pensar aquí en lenguajes ya escritos y definidos, sino más bien en el código de comportamiento altamente formalizado, que se observa en una población cuando se reúnen jefes de estado, por citar un ejemplo. Así, los protocolos usados en las redes de computadoras no son más que reglas muy estrictas de intercambio de mensajes entre dos o más servidores. 
</para>

</sect1>

<sect1 id="X-087-2-intro.tcpip"><title>Redes TCP/IP</title>

<para>
<indexterm><primary>redes</primary><secondary>TCP/IP</secondary></indexterm>
<INDEXTERM id="chit.networks.tcp-ip"
class=startofrange><PRIMARY>TCP/IP (Transmission Control
Protocol/Internet Protocol)</PRIMARY><SECONDARY>redes</SECONDARY></INDEXTERM>
<indexterm><primary>Local Area Networks (LANs)</primary></indexterm>
<indexterm><primary>redes</primary><secondary>Locales</secondary></indexterm>
<indexterm><primary>redes</primary><secondary>conmutación de paquetes</secondary></indexterm>
<indexterm><primary>redes con conmutación de paquetes</primary></indexterm>
Las aplicaciones modernas para trabajo en redes requieren de un sofisticado método de transporte desde una máquina a otra. Si usted administra una máquina GNU/Linux que posea muchos usuarios, los cuales desean estar conectados simultáneamente a un servidor remoto o a una red, necesitará un modo de acceso para que puedan compartir la conexión a la red, sin que las acciones de cada uno interfieran con las de los demás. La estrategia que un gran número de protocolos de red utilizan hoy día se llama <emphasis>conmutación de paquetes</emphasis>, (packet-switching). Un <emphasis>paquete</emphasis> es nada más que un pequeño trozo de datos que se transfiere de una máquina a otra a través de una red. Esta transferencia ocurre a medida que el datagrama es transmitido a través de cada enlace en la red. Una red de conmutación de paquetes comparte un único enlace con muchos usuarios, enviando los paquetes alternadamente, desde un usuario a otro, a través de ese enlace. 
</para>

<para>
<INDEXTERM><PRIMARY>datagramas</PRIMARY></INDEXTERM> 
La solución que muchos sistemas Unix, (y posteriormente muchas otras plataformas), han adoptado, se conoce como TCP/IP. Cuando se habla de redes TCP/IP, siempre estará presente el término <emphasis>datagrama</emphasis>. Técnicamente, este término tiene un significado especial, pero es a menudo usado de forma intercambiable con <emphasis>paquete</emphasis>. En la siguiente sección, se echará un vistazo a los conceptos fundamentales de los protocolos TCP/IP. 
</para>


<sect2 id="X-087-2-intro.tcpip.intro"><title>Introducción a las Redes TCP/IP</title>

<para>
<indexterm><primary>ARPANET</primary></indexterm>
<indexterm><primary>redes</primary><secondary>ARPANET</secondary></indexterm>
El origen del protocolo TCP/IP, se debe a un proyecto de investigación, financiado por la DARPA, (Defense Advanced Research Projects Agency, o Agencia de Proyectos Avanzados de Investigación en Defensa), en 1969. La ARPANET, fue una red experimental que se convirtió en funcional a mediados de 1975, tras haber sido admitida su funcionalidad. 
</para>
<?troff .Nd 7>
<para>
<indexterm><primary>redes</primary><secondary>Internet</secondary></indexterm>
<indexterm><primary>Internet</primary></indexterm>
<indexterm><primary>redes</primary><secondary>empresariales</secondary></indexterm>
En 1983, el nuevo conjunto de protocolos TCP/IP, fue adoptado como estándar y todas las máquinas de la red tuvieron la necesidad de él. Cuando, finalmente, ARPANET creció y se convirtió en Internet, (integrándose luego ella misma a Internet, en 1990), el uso de TCP/IP se propagó incluso a redes ajenas a ella. Ahora, muchas compañías empresariales construyen redes TCP/IP, e Internet ha crecido hasta tal punto, que se la puede considerar como la corriente principal de consumo tecnológico. Actualmente, es difícil leer un periódico sin ver referencias sobre Internet; casi todo el mundo ya puede usarla. 
</para>

<para>
<indexterm><primary>Marx, Groucho</primary></indexterm>
<indexterm><primary>Groucho Marx University
(GMU)</primary></indexterm> Para apreciar algo palpable sobre lo que hemos discutido anteriormente, supongamos como ejemplo, la Universidad Groucho Marx, (GMU), la cual se encuentra en algún lugar de Federilandia. La mayoría de las divisiones de la universidad tienen su propia red local, mientras que algunas comparten una sola y otras poseen muchas de ellas. Todas se encuentran interconectadas, y están enlazadas a Internet por un simple enlace de alta velocidad. 
</para>

<para>
<indexterm><primary>remoto</primary><secondary>ingreso</secondary></indexterm>
Supóngase que se tiene una máquina GNU/Linux conectada a una LAN de servidores Unix en la división de Matemáticas, y su nombre es <systemitem role="sitename">erdos</systemitem>. Para acceder a un servidor que se encuentra en la división de Física, cuyo nombre es, por ejemplo <systemitem role="sitename">quark</systemitem>, se deberá introducir la siguiente orden:

<screen>
$ <userinput>rlogin quark.physics</userinput>
Welcome to the Physics Department at GMU
(ttyq2) login:
</screen>
</para>

<para>
<indexterm><primary>remoto</primary><secondary>registro</secondary><tertiary>vía TCP/IP</tertiary></indexterm> 
Ante este indicador se podrá introducir un nombre de usuario, por ejemplo 
<systemitem role="userid">sebastian</systemitem>, y una contraseña. Luego, si todo es correcto, nos encontraremos frente a un intérprete de órdenes (shell)<footnote id="X-087-2-FNIT02"><para>
Una shell es un intérprete de órdenes, que actúa como interfaz con el sistema operativo Unix. Se le puede comparar al COMMAND.COM de DOS en un entorno de Microsoft Windows, aunque mucho más potente. 
</para>
</footnote> de <systemitem role="sitename">quark</systemitem>, en la cual, se podrá escribir como si se estuviera sentado frente a la misma consola del sistema. Tras salir del intérprete, se nos presentará nuevamente el antiguo indicador de órdenes de nuestra máquina. Se ha usado aquí, tan sólo una de las muchas aplicaciones instantáneas e interactivas que TCP/IP proporciona: remote login (registro remoto). 
</para>

<para>
<indexterm><primary>remoto</primary><secondary>ingreso</secondary><tertiary>sesiones X-Window</tertiary></indexterm>
<indexterm><primary>X-Window</primary></indexterm>
<indexterm><primary>DISPLAY (variable de entorno)</primary></indexterm> 
<indexterm><primary>variables globales</primary><secondary>DISPLAY</secondary></indexterm> 
Mientras se trabaja en <systemitem role="sitename">quark</systemitem>, puede que se desee ejecutar una aplicación de interfaz gráfica, como por ejemplo un procesador de textos, un programa de diseño gráfico, o hasta un navegador de Internet. El sistema de ventanas X es un entorno gráfico para el usuario, totalmente funcional bajo redes y está disponible para muchos tipos de sistemas informáticos. Para hacerle saber a la aplicación que se desea tener interfaz gráfica en la pantalla de nuestro nodo, se necesitará determinar la variable de entorno
<systemitem role="keyword">DISPLAY</systemitem>:
<screen>
$ <userinput>DISPLAY=erdos.maths:0.0</userinput>
$ <userinput>export DISPLAY</userinput>
</screen>
</para>

<para>
Si ahora se ejecuta la aplicación gráfica, ésta se comunicará con el servidor X de nuestro nodo en lugar de hacerlo con el de 
<systemitem role="sitename">quark</systemitem>, y como consecuencia las ventanas aparecerán en nuestra la pantalla y no en la de nuestro servidor. Por supuesto, esto requiere que se esté ejecutando X11 en 
<systemitem role="sitename">erdos</systemitem>. Lo más importante aquí es que TCP/IP permite el envío y reenvío de paquetes X11 entre <systemitem role="sitename">quark</systemitem>
y <systemitem role="sitename">erdos</systemitem>, haciendo que el usuario tenga la ilusión de que trabaja en una única máquina. Trabajando de este modo, la red será bastante transparente. 
</para>

<para>
<indexterm><primary>NFS (Network File System)</primary><secondary>vía TCP/IP</secondary></indexterm> 
Otra aplicación muy importante en una red TCP/IP es NFS, que significa <emphasis>Network File System</emphasis> (Sistema de Ficheros de Redes). Es otra forma de hacer de la red un sistema transparente, ya que, básicamente, permite al usuario trabajar con los ficheros y directorios de otros nodos como si fueran locales. Por ejemplo, todos los directorios \home de cada usuario pueden alojarse en un servidor central. Desde éste, los demás nodos de la LAN pueden montarlos cuando sea necesario. El resultado es que los usuarios pueden registrarse en el sistema y encontrarse siempre en el mismo directorio \home. De modo similar, es posible compartir grandes cantidades de datos, (como una base de datos, documentación o programas ejecutables), entre muchos nodos, almacenando físicamente una sola copia de dichos datos en un servidor, y permitiendo a los nodos en cuestión acceso a él. Se volverá a hablar de NFS en <xref linkend="X-087-2-nfs">.
</para>

<para>
Por supuesto, estos son sólo ejemplos de lo que se puede hacer en redes TCP/IP. Las posibilidades son casi infinitas, y el lector irá conociéndolas a medida que avance en el libro. 
</para>

<para>
En las siguientes secciones, se estudiará más detenidamente, de qué manera funciona una red TCP/IP. Esta información ayudará a entender cómo y por qué se debe configurar una máquina. Se empezará examinando el hardware, y desde allí con las demás cuestiones. 
</para>

</sect2>

<sect2 id="X-087-2-intro.tcpip.history"><title>Ethernets</title>

<para>
<indexterm><primary>protocolos</primary><secondary>Ethernet</secondary></indexterm>
<indexterm><primary>redes</primary><secondary>Ethernet</secondary></indexterm> 
<indexterm><primary>Redes de Área Local (LANs)</primary><secondary>hardware para</secondary></indexterm> 
El tipo de hardware más utilizado en LANs es lo que comúnmente conocemos como Ethernet. Descrito de una forma simple, consta de un solo cable con los nodos unidos a él a través de conectores, clavijas o transceptores. Los adaptadores Ethernet simples, son relativamente baratos de instalar, lo que unido a un flujo de transferencia neto de 10, 100 o hasta 1,000 Mega bits por segundo, avala gran parte de su popularidad.
</para>

<para>
<indexterm><primary>Ethernet</primary><secondary>gruesos/finos</secondary></indexterm>
<indexterm><primary>Ethernet</primary><secondary>de par trenzado</secondary></indexterm>
<indexterm><primary>thinnet</primary></indexterm>
<indexterm><primary>conectores BNC</primary></indexterm>
<indexterm><primary>núcleo activo</primary></indexterm>
<indexterm><primary>redes</primary><secondary>thinnet</secondary></indexterm>
Las redes Ethernet se pueden clasificar en tres tipos atendiendo al grosor del cable: <emphasis>gruesos</emphasis>,<emphasis>finos</emphasis>, y <emphasis>de par trenzado</emphasis>. Los dos primeros pueden usar cable coaxial, diferiendo en el grosor y el modo de conectar este cable a los nodos. El cable Ethernet fino emplea conectores &ldquo;BNC&rdquo; con forma de T, que se pinchan en el cable y se enganchan a los conectores de la parte trasera del ordenador. El cable Ethernet grueso requiere que se realice un pequeño agujero en el cable, y se conecte un transceptor utilizando un &ldquo;conector vampiro&rdquo; Luego, se podrán conectar uno o más nodos al transceptor. Los cables Ethernet fino y grueso pueden alcanzar una distancia de 200 y 500 metros, respectivamente, y es por ello que se les llama también 10base-2 y 10base-5. La palabra &ldquo;base&rdquo; hace referencia a &ldquo;modulación de banda base&rdquo; y significa, simplemente, que los datos que alimentan al cable, fluyen directamente sin pasar por un módem. El número que se encuentra delante de la palabra alude a la velocidad de transmisión, en Mega bits por segundo, mientras que el número al final indica la máxima longitud que se le puede dar al cable, en cientos de metros. El par trenzado usa un cable hecho de dos hilos de cobre. Por lo común necesitan, además, hardware adicional que se conoce como <emphasis>Núcleo Activo</emphasis>. A este Ethernet se le conoce también como 10base-T, en donde &ldquo;T&rdquo; significa de par trenzado. Los pares trenzados con velocidad de 100 Mega bits por segundo son conocidos como 100base-T.
</para>

<para>
Para agregar un nodo a una instalación Ethernet fina se deberá suspender el servicio de la red por al menos unos minutos, ya que se deberá cortar el cable para insertar un conector. A pesar de que, por otro lado, agregar un nodo a un sistema Ethernet grueso es un poco complicado no hará, por lo general, que el servicio de la red se interrumpa. Un Ethernet de par trenzado es aún más simple. Usa un dispositivo denominado &ldquo;hub,&rdquo; que trabaja como un punto de interconexión. Se pueden insertar y quitar nodos de un núcleo sin interrumpir en absoluto, a ninguno de los demás usuarios. 
</para> 

<para>
 La mayoría de gente prefiere el Ethernet fino porque es barato: las tarjetas de PC pueden encontrarse por unos 30&dollar; americanos (algunas compañías están literalmente, regalándolas), y el cable por pocos centavos el metro. Sin embargo, para instalaciones de gran escala, son más apropiados el Ethernet grueso o el de par trenzado. Por ejemplo, en un principio, el Departamento de Matemáticas de la GMU decidió utilizar el cableado  Ethernet grueso, ya que el gran tráfico que posee toda la red a lo largo de su gran recorrido, no se interrumpe cada vez que se añade un nodo. Actualmente, son muy comunes los cables Ethernet de par trenzado en una gran variedad de instalaciones. Los &ldquo;hubs&rdquo; son ahora más accesibles, y pequeñas unidades están disponibles a 
precios que son atractivos, incluso para pequeñas redes domésticas. El cable de par trenzado puede ser significativamente más barato para grandes instalaciones. Además, el mismo cable de par trenzado es mucho más flexible que los coaxiales usados por otros sistemas Ethernet. Los administradores de la red en la división de matemáticas de GMU, están planeando reemplazar su sistema por uno de par trenzado el año que viene, ya que, además de ahorrar tiempo a la hora de agregar nuevos nodos, y cambiar de lugar los viejos, también podrán ponerse al día con la tecnología actual. 
</para>

<para>
<indexterm><primary>Ethernet</primary><secondary>inconvenientes</secondary></indexterm> 
<indexterm><primary>repetidores</primary></indexterm> 
<indexterm><primary>puentes</primary></indexterm> 
<indexterm><primary>encaminadores</primary></indexterm> 
Uno de los inconvenientes de la tecnología Ethernet es su limitada longitud de cable, que imposibilita cualquier uso fuera de las LANs. Sin embargo, pueden enlazarse varios segmentos de red Ethernet entre sí utilizando repetidores, puentes o encaminadores<footnote><para>Respectivas traducciones de &ldquo;repeaters&rdquo;, &ldquo;bridges&rdquo; y &ldquo;routers&rdquo;. Nota del T. </para></footnote>. Los repetidores simplemente copian las señales entre dos o más segmentos, de forma que todos los segmentos juntos actúan como si fuese una única Ethernet. Debido a requisitos de tiempo, no puede haber mas de cuatro repetidores entre cualquier par de nodos de la red. Los puentes y encaminadores son más sofisticados, analizan los datos de entrada y los reenvían sólo si el nodo receptor no está en la Ethernet local.</para>

<para>
<indexterm><primary>Ethernet</primary><secondary>direcciones</secondary></indexterm>
<indexterm><primary>direcciones</primary><secondary>Ethernet</secondary></indexterm>
Ethernet funciona como un sistema de bus, donde un nodo puede mandar paquetes (o <emphasis>marcos</emphasis>) de hasta 1500 bytes a otro nodo de la misma Ethernet. A cada nodo se le asigna una dirección de seis bytes grabada en el firmware (memoria fija) de su tarjeta Ethernet. Estas direcciones se especifican generalmente como una secuencia de números hexadecimales de dos dígitos separados por dos puntos, como por ejemplo <systemitem role="sitename">aa:bb:cc:dd:ee:ff</systemitem>.
</para>

<para>
<indexterm><primary>Ethernet</primary><secondary>colisiones</secondary></indexterm>
<indexterm><primary>colisiones (Ethernet)</primary></indexterm> 
Una trama enviada por una estación es vista por todas las demás estaciones conectadas, pero sólo el nodo destinatario la toma y la procesa. Si dos estaciones intentan emitir al mismo tiempo, se produce lo que se llama una <emphasis>colisión</emphasis>. Una colisión en un complejo Ethernet, es detectada electrónicamente por las tarjetas de interfaz. Se resuelve por parte de las dos estaciones abortando el envío, y reintentándolo al cabo de un intervalo de tiempo tomado al azar. Seguramente se han escuchado muchas historias que afirmen que las colisiones en un Ethernet son un problema, y que la verdadera tasa de transmisión de datos en un Ethernet, sólo ocupa un 30 por ciento del ancho de banda disponible debido a ellas. La verdad es que las colisiones en un sistema Ethernet son un fenómeno <emphasis>natural</emphasis>. Es más, en un sistema muy activo, no se debería sorprender al ver que las colisiones tienen un índice mayor al 30 por ciento. En la práctica, el administrador de una red Ethernet sólo debería preocuparse cuando la tasa de transmisión se vea limitada a aproximadamente un 60 por ciento del ancho de banda.<footnote id="X-087-2-FNIT03"><para> El FAQ de Ethernet que se encuentra en 
<systemitem role="url">http://www.faqs.org/faqs/LANs/ethernet-faq/</systemitem>
habla sobre este tema. También se puede encontrar abundante información histórica y técnica, muy detallada en el web de Charles Spurgeon's dedicado a Ethernet, 
<systemitem role="url">http://wwwhost.ots.utexas.edu/ethernet/</systemitem>.
</para>
</footnote>
</para>

</sect2>

<sect2 id="X-087-2-intro.tcpip.other-hardware"><title>Otro Tipo de Hardware</title>
<para>
En instalaciones mayores, como la Universidad de Groucho Marx, Ethernet no es el único tipo de red que puede utilizarse. Hay muchos otros tipos de protocolos disponibles y usados en la actualidad, y cada uno de ellos son soportados por GNU/Linux. A continuación se hará una descripción de otros protocolos usados, aunque será algo breve debido a las restricciónes en el tamaño de este documento. La mayoría de estos protocolos poseen documentos HOWTO que los describen en detalle. Es por esto que se debería leerlos si se está interesado en explorar aquellos protocolos que no se describen aquí. 
</para>

<para>
<indexterm><primary>FDDI (Fiber Distributed Data Interface)</primary></indexterm>
<INDEXTERM><PRIMARY>Fiber Distributed Data Interface (FDDI)</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>protocolos</PRIMARY><SECONDARY>paso de testigo (token-passing)</SECONDARY></INDEXTERM>

En la Universidad de Groucho Marx cada LAN de un departamento está enlazada a la &rdquo;espina dorsal&rdquo;<footnote><para>backbone</para></footnote> de la red del campus. Ésta está formada por un cable de fibra óptica funcionando en <emphasis>FDDI </emphasis>(Fiber Distributed Data Interface). FDDI emplea un enfoque totalmente diferente para transmitir datos, que básicamente implica el envío de un número de <emphasis>símbolos</emphasis>, de modo que una estación sólo pueda enviar una trama si captura un símbolo. La principal ventaja de FDDI es la reducción de colisiones. Como consecuencia, el paso de datos puede utilizar en mayor proporción el ancho de banda, lo que permite una velocidad de hasta 100 Mbps. Otro beneficio de FDDI es que, al utilizar fibra óptica, la máxima longitud del cable sea mucho mayor a la que ofrecen las tecnologías basadas en cables, como Ethernet. La máxima longitud de cable usando FDDI oscila en los 200 km, lo que hace que esta tecnología sea ideal para unir las máquinas que se encuentren en distintos edificios de una ciudad. En el caso de nuestra universidad, FDDI une a los diferentes edificios en un campus. 
</para>

<para>
<indexterm><primary>Token Ring</primary><secondary>Redes </secondary></indexterm>
<INDEXTERM><PRIMARY>Redes</PRIMARY><SECONDARY>Token Ring</SECONDARY></INDEXTERM> <INDEXTERM><PRIMARY>Redes IBM Token Ring</PRIMARY></INDEXTERM> 
De modo similar, si se tratase de equipos IBM, sería muy común el ver una red IBM de Token Ring. Esta tecnología es usada, en algunos entornos LAN, como alternativa a Ethernet. La ventaja esencial es que, como FDDI, en términos de utilización de la banda, se reducen las colisiones, aunque a velocidades inferiores (de 4 a 16Mbps). Su coste es menor que el de FDDI, ya que utiliza cables en lugar de fibra óptica. En un sistema GNU/Linux una red basada en Token Ring se configura casi de la misma manera que una red Ethernet, por lo que no se cubrirá, en el libro este procedimiento específicamente. 
</para>

<para>
A pesar de que otras tecnologías para LAN soportadas por GNU/Linux, como por ejemplo ArcNet o DECNet, pueden ser instaladas, no se describirán aquí. Esto es debido, principalmente a que son muy poco usadas en la actualidad. 
</para>

<para>
<indexterm><primary>protocolos</primary><secondary>X.25</secondary></indexterm>
<indexterm><primary>Protocolo X.25</primary></indexterm>
<indexterm><primary>PAD (Packet Assembler Disassembler)</primary></indexterm> 
Muchas redes nacionales, operadas por compañías de Telecomunicaciónes, soportan otros protocolos basados en la conmutación de paquetes. Probablemente, el más popular de estos es un estándar llamado X.25. Muchas Redes de Datos Públicos, como por ejemplo Tymnet en EEUU, Austpac en Australia, y Datex-P en Alemania, ofrecen este servicio. X.25 define una conjunto de protocolos que describen cómo una terminal de datos se comunicará con otros equipos de transmisión, (o sea, un interruptor X.25). X.25 requiere un enlace de datos síncrono  y, por consiguiente, un puerto síncrono especial en el hardware. Se puede usar X.25 en un puerto serie normal, con ayuda de un dispositivo especial llamado PAD, (Packet Assembler Disassembler). El PAD hace que el puerto en serie trabaje de modo síncrono o asíncrono, según sean las condiciones de la tarea. El dispositivo entiende el protocolo X.25 de un modo tal, que las simples terminales pueden efectuar y/o aceptar conexiones vía X.25. 
</para>

<para>X.25 también es usado para transportar otros protocolos de redes, como TCP/IP. Dado que los datagramas IP no pueden ser fácilmente asignados a X.25, (o recíprocamente), son encapsulados en paquetes X.25, y transmitidos por la red. Existe una implementación experimental del protocolo X.25 disponible para GNU/Linux. 
</para>

<para>
<indexterm><primary>protocolos</primary><secondary>Conmutación de Tramas</secondary></indexterm>
<indexterm><primary>protocolos</primary><secondary>Frame Relay</secondary></indexterm>
<indexterm><primary>FRAD (Frame Relay Access Device)</primary></indexterm>
<indexterm><primary>Frame Relay</primary></indexterm>
Un protocolo más reciente ofrecido por compañías de telecomunicaciónes es el denominado <emphasis>Conmutación de Tramas</emphasis>, (Frame Relay). Este protocolo tiene características técnicas similares a las del X.25, aunque su comportamiento es mucho más parecido al IP. Al igual que el protocolo X.25, el de Conmutación de Tramas requiere un tipo de hardware síncrono especial. Debido a la similitud que existe entre estos dos protocolos, muchas tarjetas soportan  ambos. Existe una alternativa, la cual no requiere de hardware interno y que consiste en un componente externo de hardware, denominado Dispositivo de Acceso a Conmutación de Tramas, (FRAD)<footnote><para>En el original: Frame Relay Access Device. Nota del T. </para></footnote>, el cual administra la encapsulación de los paquetes Ethernet en paquetes de Conmutación de Tramas para ser transmitidos a través de la red. El protocolo de Conmutación de Tramas es ideal para transportar al TCP/IP de un sitio a otro. GNU/Linux provee de controladores que soportan algunos tipos de dispositivos internos para el protocolo de Conmutación de Tramas. 
</para>


<para>
<indexterm><primary>protocolos</primary><secondary>ATM (Asynchronous Transfer Mode)</secondary></indexterm>
<indexterm><primary>ATM (Asynchronous Transfer Mode)</primary></indexterm>
<indexterm><primary>Protocolo de transferencia asíncrona</primary></indexterm>
Si se necesita trabajar en una red de alta velocidad, la cual sea capaz de transportar muchos tipos de datos, como por ejemplo sonido o vídeo digitalizado, al mismo tiempo que los datos usuales, ATM (Modo de Transferencia Asíncrona)<footnote><para>En el original: Asynchronous Transfer Mode. Nota del T. </para></footnote> es, con seguridad, lo que se está buscando. ATM es una nueva tecnología de redes, la cual fue específicamente desarrollada para suministrar control sobre la Calidad del Servicio (Quality of Service, Q.S, en inglés). Muchas compañías de telecomunicaciones han destacado la infraestructura de la tecnología ATM, ya que permite integrar diferentes tipos de servicios en una sola plataforma, todo esto aspirando al ahorro en cuanto a la administración y a los costos de mantenimiento. También ATM se usa para transportar al protocolo TCP/IP. En el documento Networking-HOWTO se puede encontrar información sobre el soporte brindado por GNU/Linux para ATM. 

</para>

<para>
<indexterm><primary>protocolos</primary><secondary>AX.25</secondary></indexterm>
<indexterm><primary>protocolos</primary><secondary>NetRom</secondary></indexterm>
<indexterm><primary>protocolos</primary><secondary>Rose</secondary></indexterm>
<indexterm><primary>protocolos de radio-aficionados</primary></indexterm>
<indexterm><primary>radio ham</primary></indexterm>
<indexterm><primary>packet radio</primary></indexterm>
<indexterm><primary>protocolo AX.25</primary></indexterm>
<indexterm><primary>protocolo NetRom</primary></indexterm>
<indexterm><primary>protocolo Rose</primary></indexterm>
<indexterm><primary>TNC (Terminal Node Controller)</primary></indexterm>
<INDEXTERM><PRIMARY>AX25 HOWTO</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>HOWTOs</PRIMARY><SECONDARY>AX25</SECONDARY></INDEXTERM>
A menudo, los radio-aficionados usan sus propios equipos de radio para conectar sus ordenadores en red; comúnmente, a esto se le llama <emphasis>radio paquetes</emphasis> (packet radio). Uno de los protocolos usados por los operadores radio-aficionados es llamado AX.25, que deriva del X.25. También, los operadores radio-aficionados usan al AX.25 para transmitir otros protocolos, como por ejemplo el TCP/IP. AX.25, al igual que X.25, requiere de hardware especial que le permita realizar operaciones síncronas, o un dispositivo externo llamado  &ldquo;Controlador de Nodo Terminal&rdquo;<footnote><para> &ldquo;Terminal Node Controller&rdquo;, en el original. Nota del T. </para></footnote>, el cual convierta los paquetes transmitidos por un enlace en serie asíncrono, en paquetes transmitidos síncronamente. Existen muchas clases diferentes de interfaces de tarjetas disponibles que soporten la operación de radio paquetes. Normalmente, estas tarjetas son aludidas según la &ldquo;base Z8530 SCC&rdquo; y su nombre va tras el controlador de comunicación más popular usado en el diseño. Dos de los protocolos que son transportados comúnmente por el AX.25 son NetRom y Rose, los cuales se denominan protocolos de red en capas (Network layer protocols). Puesto que estos últimos se ejecutan sobre AX.25, tienen los mismos requerimientos de hardware que este último. GNU/Linux soporta ampliamente todas las características de los protocolos AX.25, NetRom y Rose. Una buena fuente de información, sobre la implementación para GNU/Linux de éstos, es el HOWTO AX25-Como. 

</para>

<para>
Otro tipo de acceso a Internet implicaría la utilización de marcación telefónica a una central, sobre una línea serie. Esto involucraría una conexión más lenta, aunque más barata, (usando el teléfono, RDSI, u otros servicios). Esto requiere todavía de la ayuda de otro protocolo para la transmisión de los paquetes, como por ejemplo SLIP o PPP, los que serán descritos más adelante.  
</para>

</sect2>

<sect2 id="X-087-2-intro.tcpip.ip"><title>El Protocolo IP (Internet Protocol)</title>

<para>
<indexterm><primary>protocolos</primary><secondary>Internet (IP)</secondary></indexterm>
<indexterm><primary>IP (Internet Protocol)</primary></indexterm>
Por supuesto, el administrador puede no querer que su red esté limitada solamente a una Ethernet, o a un sólo enlace de datos punto-a-punto. Seguramente la idea original consistirá en poder acceder a un servidor sin importar el hardware del que dispone. Por ejemplo, en instalaciones grandes como la Universidad de Groucho Marx, se encontrará muy a menudo con varias redes distanciadas unas de otras, pero conectadas entre ellas de alguna manera. En la GMU, el departamento de matemáticas tiene dos Ethernets: una red de máquinas rápidas para profesores y graduados, y otra con máquinas más lentas para estudiantes. Ambas redes están enlazadas de la red troncal FDDI del campus.

</para>

<para>
<indexterm><primary>reenviar</primary><secondary>IP</secondary></indexterm>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>reenviar</secondary></indexterm>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>pasarelas (gateways)</secondary></indexterm>
<indexterm><primary>pasarelas</primary><secondary>interconexión con</secondary></indexterm>
Esta conexión se gestiona con un nodo dedicado, denominado <emphasis>pasarela</emphasis>, o gateway, que maneja los paquetes entrantes y salientes copiándolos entre las dos Ethernets y el cable de fibra óptica. Por ejemplo, si se encuentra en el Departamento de Matemáticas, y quiere acceder a <systemitem role="sitename">quark</systemitem> situada en la LAN del Departamento de Físicas, desde su máquina GNU/Linux, el software de red no puede mandar paquetes a <systemitem role="sitename">quark</systemitem> directamente, porque no esta en la misma Ethernet. Por tanto, tiene que confiar en la pasarela para que actúe como retransmisor. La pasarela (llamémosla <systemitem role="sitename">sophus</systemitem>) reenvía entonces estos paquetes a su pasarela homóloga <systemitem role="sitename">niels</systemitem> del Departamento de Física, usando la red troncal, y por fin <systemitem role="sitename">niels</systemitem> los entrega a la máquina destino. El flujo de datos entre <systemitem role="sitename">erdos</systemitem> y <systemitem role="sitename">quark</systemitem> se muestra en <xref linkend="X-087-2-intro.fig.ip-flow">. 

</para>

<figure id="X-087-2-intro.fig.ip-flow">
<title>Los tres pasos del enviado de un datagrama desde erdos a quark</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0101" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0101.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<para>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>encaminamiento</secondary></indexterm>
<INDEXTERM><PRIMARY>datagramas</PRIMARY></INDEXTERM>
Este esquema de envío de datos al nodo remoto se llama <emphasis>encaminamiento</emphasis>, y en este contexto a los paquetes se les denomina <emphasis>datagramas</emphasis>. Para facilitar las cosas, el intercambio de datagramas esta gobernado por un único protocolo que es independiente del hardware utilizado: IP, o <emphasis>Internet Protocol</emphasis> (Protocolo de Internet). En <xref linkend="X-087-2-issues">, trataremos con más detalle al IP y al encaminamiento.
</para>

<para>
<indexterm><primary>interconexión de redes</primary></indexterm>
<indexterm><primary>redes</primary><secondary>interconexión</secondary></indexterm>
<indexterm><primary>internet</primary><secondary>versus interconexión</secondary></indexterm>
El principal beneficio del IP es su cualidad de convertir a redes físicamente diferentes en una red aparentemente homogénea. A esto se le llama interconexión de redes, y a la resultante &ldquo;meta-red&rdquo; se la denomina <emphasis>internet</emphasis>. Obsérvese aquí la sutil diferencia entre <emphasis>una</emphasis> internet y <emphasis>la</emphasis> Internet. El último es el nombre oficial de una internet global en particular.
</para>

<para>
<indexterm><primary>direcciones</primary><secondary>IP</secondary></indexterm>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>direcciones</secondary></indexterm>
<indexterm><primary>notación en cuaternas de puntos</primary></indexterm>
<indexterm><primary>notación decimal por puntos</primary></indexterm>
<INDEXTERM><PRIMARY>IPv4 (Internet Protocol)</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>IP (Internet Protocol)</PRIMARY><SECONDARY>IPv4</SECONDARY></INDEXTERM>
Claro que el IP también necesita un esquema de direccionamiento independiente del hardware. Esto se consigue asignando a cada nodo un número único de 32 bits, denominado <emphasis>dirección IP</emphasis>. Una dirección IP está definida normalmente, por 4 números en decimal, uno por cada división de 8 bits, y separados por puntos. Por ejemplo, <systemitem role="sitename">quark</systemitem> podría tener una dirección IP <systemitem role="sitename">0x954C0C04</systemitem>, que se escribiría como <systemitem role="sitename">149.76.12.4</systemitem>. Este formato de dirección, es comúnmente llamado <emphasis>notación decimal de puntos</emphasis>, aunque también puede hacerse referencia a él como <emphasis>notación en cuaternas de puntos</emphasis><footnote><para>Definiciones que en el inglés serían &ldquo;dotted decimal notation&rdquo; y &ldquo;dotted quad notation&rdquo;, respectivamente. Nota del T.</para></footnote>. Sin embargo la denominación de IP, está cambiando del nombre de IPv4, (por Internet Protocol, Version 4), a un nuevo estándar llamado IPv6 que ofrece mucha más flexibilidad a la hora de direccionar y otras mejoras modernas. Pasará por lo menos un año tras esta edición, antes de que IPv6 empiece a ser usado. 
</para>

<para>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>direcciones</secondary><tertiary>versus hostname</tertiary></indexterm>
<indexterm><primary>Ethernet</primary><secondary>direcciones</secondary><tertiary>versus direcciones IP</tertiary></indexterm>
Se dará cuenta de que ahora tenemos tres tipos distintos de direcciones: primero, tenemos el nombre del nodo, como por ejemplo  <systemitem role="sitename">quark</systemitem>, después tenemos las direcciones IP, y por fin están las direcciones hardware, como la dirección Ethernet de 6 bytes. De alguna forma todas ellas deben relacionarse, de modo que cuando se escriba <command>rlogin quark</command>, se le pueda pasar la dirección IP de <systemitem role="sitename">quark</systemitem> al software de red; y cuando el nivel IP envíe datos a la Ethernet del Departamento de Físicas, de algún modo tenga cómo encontrar a que dirección Ethernet corresponde la dirección IP.
</para>

<para>
Se hará un repaso de todo esto, con más profundidad en el <xref linkend="X-087-2-issues">. De momento, es suficiente con indicar que estos pasos para encontrar las direcciones se llaman: <emphasis>resolución de nombres</emphasis> al trazar un mapa de nombres de nodo con direcciones IP, y <emphasis>resolución de direcciones</emphasis>, al hacer corresponder estas últimas con direcciones hardware.
</para>

</sect2>

<sect2 id="X-087-2-intro.tcpip.slip"><title>IP en Líneas Serie</title>

<para>
<indexterm><primary>protocolos</primary><secondary>CSLIP</secondary></indexterm>
<indexterm><primary>protocolos</primary><secondary>SLIP</secondary></indexterm>
<indexterm><primary>protocolos</primary><secondary>PPP</secondary></indexterm>
<INDEXTERM><PRIMARY>teléfono</PRIMARY><SECONDARY>enviando datos por</SECONDARY></INDEXTERM>
<indexterm><primary>protocolo SLIP (Serial Line IP)</primary></indexterm>
<indexterm><primary>protocolo CSLIP (Compressed Serial Line IP)</primary></indexterm>
<indexterm><primary>PPP (Protocolo de Punto-a-Punto)</primary></indexterm>
Para líneas serie se usa frecuentemente el estándar &ldquo;de facto&rdquo; conocido como SLIP o <emphasis>Serial Line IP</emphasis> (IP sobre línea en serie). Una modificación del SLIP es el CSLIP, o <emphasis>SLIP Comprimido</emphasis>, que realiza compresión de las cabeceras IP para aprovechar el bajo ancho de banda que proporcionan los enlaces serie. Otro protocolo serie es el PPP, o <emphasis>Point-to-Point Protocol</emphasis> (Protocolo Punto a Punto). PPP dispone de muchas más características que SLIP, lo que lo hace mucho más atractivo. Su principal ventaja sobre SLIP es, sin embargo, que no se limita a transportar datagramas IP, sino que se diseñó para que la transmisión de cualquier tipo de protocolo pueda realizarse sobre él.
</para>

</sect2>

<sect2 id="X-087-2-intro.tcpip.tcp"><title>El Protocolo de Control de Transmisión, TCP</title>

<para>
<indexterm><primary>protocolos</primary><secondary>TCP</secondary></indexterm>
<indexterm><primary>TCP (Protocolo de Control de Transmisión)</primary></indexterm>
Pero la historia no se acaba con el envío de datagramas de un nodo a otro. Si se inicia sesión en <systemitem role="sitename">quark</systemitem>, necesita disponer de una conexión fiable entre su proceso <command>rlogin</command> en <systemitem role="sitename">erdos</systemitem> y el proceso del intérprete de órdenes en <systemitem role="sitename">quark</systemitem>. Así, la información enviada en uno u otro sentido debe dividirse por paquetes en el origen, y ser reensamblada en un flujo de caracteres por el receptor. Esto que parece trivial, implica varias tareas complejas.
</para>

<para>
Una cosa importante a saber sobre IP es que, por sí sólo, no es fiable. Suponga que diez personas de su Ethernet comienzan a transferirse la última versión del código fuente del navegador web Netscape, usando el servidor FTP de GMU. La cantidad de tráfico generada por esto podría ser excesiva para la pasarela, por ser demasiado lenta, o tener poca memoria. Si en ese momento Ud. enviara un paquete a <systemitem role="sitename">quark</systemitem>, <systemitem role="sitename">sophus</systemitem> podría tener agotado el espacio del búfer durante un instante y por tanto no seria capaz de reenviarlo. IP resuelve este problema simplemente descartando el paquete el cual se pierde irrevocablemente. Esto traslada, por consiguiente, la responsabilidad de comprobar la integridad y exactitud de los datos a los nodos extremos, y su retransmisión en caso de error.
</para>

<para>
De este proceso se encarga otro protocolo: el <emphasis>Protocolo de Control de Transmisión</emphasis>, (TCP, Transmission
Control Protocol), que construye un servicio fiable por encima de IP. La propiedad esencial de TCP es que usa IP para dar al usuario la impresión de una conexión simple entre los procesos en su equipo y la máquina remota, de modo que no tiene que preocuparse de cómo se transmiten y sobre el recorrido de los datos a través de la ruta por la que viajan. Una conexión TCP funciona básicamente como una tubería de doble sentido, en la que ambos procesos pueden escribir y leer; Se puede usar la analogía de una conversación telefónica para comprender el funcionamiento de este protocolo.
</para>

<para>
<INDEXTERM id="chit.networks.tcp.ports" class=startofrange><PRIMARY>redes</PRIMARY><SECONDARY>puertos</SECONDARY></INDEXTERM>
<INDEXTERM id="chit.networks.ports" class=startofrange><PRIMARY>puertos</PRIMARY></INDEXTERM>
TCP identifica los extremos de una conexión específica por las direcciones IP de los dos nodos implicados, y el número de los <emphasis>puertos</emphasis> de cada nodo. Los puertos se pueden ver como puntos de enganche para conexiones de red. Para seguir utilizando el ejemplo del teléfono un poco más, si pensamos en una analogía entre las ciudades como nodos, se puede comparar las direcciones IP con los prefijos de área (los números representarían ciudades), y los números de puerto con los códigos locales (números que representan teléfonos de personas concretas). Un nodo en particular puede soportar diferentes servicios, cada uno diferenciado por su propio número de puerto. 
</para>

<para>
<indexterm><primary>remoto</primary><secondary>inicio de sesión</secondary></indexterm>
En el ejemplo con <command>rlogin</command>, la aplicación cliente (<command>rlogin</command>) abre un puerto en <systemitem role="sitename">erdos</systemitem> y se conecta al puerto 513 de <systemitem role="sitename">quark</systemitem>, en el cual se sabe que el servidor <command>rlogind</command> está escuchando. Esto establece una conexión TCP. Usando esta conexión, <command>rlogind</command> realiza el procedimiento de autorización para luego, generar un servicio de intérprete de órdenes. La entrada y salida estándar de la shell se redirigen a la conexión TCP, de tal forma que cualquier cosa que se teclee a <command>rlogin</command> en nuestra máquina será pasada al flujo TCP para ser luego transmitida a la entrada estándar del intérprete de órdenes.
</para>
</sect2>

<sect2 id="X-087-2-intro.tcpip.udp"><title>El Protocolo de Datagramas de Usuario</title>

<para>
<indexterm><primary>protocolos</primary><secondary>UDP</secondary></indexterm>
<indexterm><primary>UDP (User Datagram Protocol)</primary></indexterm>
<indexterm><primary>Protocolo de Datagramas de Usuario (User Datagram Protocol, UDP)</primary></indexterm>
Sin embargo, TCP no es el único protocolo de usuario en redes TCP/IP. Aunque adecuado para aplicaciones como <command>rlogin</command>, la sobrecarga que impone es prohibitiva para aplicaciones como NFS, la cual utiliza un protocolo derivado de TCP llamado UDP, o <emphasis>User Datagram Protocol</emphasis> (Protocolo de Datagramas de Usuario). De igual modo que TCP, UDP permite que una aplicación contacte con un servicio en un puerto concreto de la máquina remota, pero no establece una conexión para ello. En cambio, se puede usar para enviar paquetes sueltos al servicio destino - de ahí su nombre.
</para>

<para>
Supóngase que se ha solicitado una pequeña cantidad de información de un servidor de base de datos. Esto tomará, al menos tres datagramas para establecer la conexión TCP, otros tres para enviar y confirmar la cantidad de datos y otros tres para cerrar la conexión. UDP nos facilita el hacer la mayor parte de todo esto, pero solamente usando dos datagramas. Este protocolo está caracterizado por tener un método de conexión y desconexión mucho más rápido, y no requiere que el usuario establezca y cierre una conexión. El mecanismo es simple: UDP coloca los datos en un datagrama y lo envía al servidor. Éste realiza un proyecto del reenvío, poniendo los datos dentro de un datagrama direccionado a nuestra máquina, y luego lo transmite. Mientras que este procedimiento es más rápido y más eficiente que el de TCP para transacciones simples, UDP no fue construido para tratar con posibles pérdidas de datos. Lidiar con estas dificultades dependerá de la aplicación en cuestión. 
</para>

</sect2>

<sect2 id="X-087-2-intro.tcpip.ports"><title>Más sobre Puertos</title>

<para>
<indexterm><primary>redes</primary><secondary>servicios</secondary></indexterm>
<indexterm><primary>servicios</primary></indexterm> 
Los puertos se pueden ver como puntos de anclaje para conexiones de red. Si una aplicación quiere ofrecer un cierto servicio, se engancha ella misma a un puerto y espera a los clientes (a esto también se le llama <emphasis>escuchar</emphasis> en el puerto). Un cliente que quiera usar este servicio se asigna un puerto libre en su nodo local, y se conecta al puerto del servidor en el nodo remoto. El puerto del servidor podrá estar abierto por diferentes máquinas, pero nunca podrán usarlo más de una al mismo tiempo. 
</para>

<para>
Una propiedad importante de los puertos es que, una vez que se ha establecido una conexión entre el cliente y el servidor, otra copia del servidor puede engancharse a su mismo puerto y aguardar a otros clientes. Esto permite, por ejemplo, varios accesos remotos simultáneos al mismo nodo, usando todos ellos el mismo puerto 513. TCP es capaz de distinguir unas conexiones de otras, ya que todas ellas provienen de diferentes puertos o nodos. Por ejemplo, si accede dos veces a <systemitem role="sitename">quark</systemitem> desde <systemitem role="sitename">erdos</systemitem>, el primer cliente <command>rlogin</command> usará el puerto local 1023, y el segundo el 1022. Sin embargo, ambos se conectarán al mismo puerto 513 de <systemitem role="sitename">quark</systemitem>. Las dos conexiones se distinguirán según el puerto que cada una use en <systemitem role="sitename">erdos</systemitem>. 
</para>

<para>
<indexterm><primary>servicios</primary><secondary>más comunes</secondary></indexterm>
<indexterm><primary>servicios</primary><secondary>números de puertos</secondary></indexterm>
<indexterm><primary>IETF (Internet Engineering Task Force)</primary></indexterm>
Este ejemplo muestra el uso de puertos como puntos de encuentro, donde un cliente se contacta con un puerto específico para obtener un servicio específico. Para que un cliente pueda conectarse al número de puerto correcto, se ha tenido que llegar a un acuerdo entre los administradores de los dos sistemas para definir la asignación de estos números. Para servicios ampliamente usados, como <command>rlogin</command>, estos números tienen que administrarse de modo universal. Esto lo realiza el IETF (o Internet Engineering Task Force), que regularmente publica un RFC (Request For Comment) denominado <emphasis>Assigned Numbers</emphasis> (Números Asignados, RFC-1700). Describe, entre otras cosas, los números de puerto asignados a servicios reconocidos. GNU/Linux utiliza un fichero para hacer corresponder los nombres con números, llamado <filename>/etc/services</filename>. </para>

<para> 
Merece la pena indicar que aunque las conexiones TCP y UDP se basan en puertos, estos números no entran en conflicto. Esto significa que el puerto TCP 513, por ejemplo, es diferente del puerto UDP 513. De hecho, estos puertos sirven como puntos de acceso para dos servicios diferentes, como  <command>rlogin</command> (TCP) y <command>rwho</command> (UDP).

<INDEXTERM startref="chit.networks.tcp.ports" class=endofrange>
<INDEXTERM startref="chit.networks.ports" class=endofrange>
</para>

</sect2>

<sect2 id="X-087-2-intro.tcpip.sockets"><title>La Biblioteca de Sockets</title>
<para>
<indexterm><primary>redes</primary><secondary>interfaces de programación</secondary></indexterm> <indexterm><primary>Berkeley Socket Library</primary></indexterm>
<indexterm><primary>sockets</primary></indexterm>
<indexterm><primary>bind(&thinsp;)</primary></indexterm><indexterm><primary>enlazar(&thinsp;)</primary></indexterm>
<indexterm><primary>conectar(&thinsp;)</primary></indexterm>
<indexterm><primary>escuchar(&thinsp;)</primary></indexterm>
<indexterm><primary>aceptar(&thinsp;)</primary></indexterm>
<indexterm><primary>connect(&thinsp;)</primary></indexterm>
<indexterm><primary>listen(&thinsp;)</primary></indexterm>
<indexterm><primary>accept(&thinsp;)</primary></indexterm>
<indexterm><primary>XNS, Xerox Networking System, (Sistema Redes de Trabajo Xerox)</primary></indexterm>
<indexterm><primary>protocolos</primary><secondary>XNS</secondary></indexterm>
En sistemas operativos UNIX, el software que realiza todas las tareas y protocolos descritos anteriormente es generalmente parte del núcleo, y por tanto viene incorporado dentro de GNU/Linux. La interfaz de programación más común en el mundo UNIX es la <emphasis>Biblioteca de Sockets de Berkeley</emphasis><footnote><para>Berkeley Socket Library. Nota del T. </para></footnote>. Su nombre proviene de una analogía popular que ve los puertos como enchufes, y el conectarse a un puerto como enchufarse. Proporciona la llamada <function>bind</function> para especificar un nodo remoto, un protocolo de transporte, y un servicio al que un programa pueda conectarse o escuchar (usando <function>connect</function>, <function>listen</function>, o <function>accept</function>)<footnote><para>En donde las traducciones al español de los términos &ldquo;bind&rdquo;, &ldquo;connect&rdquo;, &ldquo;listen&rdquo; y &ldquo;accept&rdquo; son &ldquo;enlazar&rdquo;, &ldquo;conectar&rdquo;, &ldquo;escuchar&rdquo; y &ldquo;aceptar&rdquo; respectivamente</para></footnote>. La biblioteca de sockets, sin embargo, es algo más general, ya que proporciona no sólo una clase de sockets basados en TCP/IP (los sockets <function>AF_INET</function>), sino también una clase que maneja conexiones locales a la máquina (la clase <function>AF_UNIX</function>). Algunas implementaciones pueden manejar también otras clases, como el protocolo XNS (<emphasis>Xerox Networking System</emphasis>), o el X.25.
</para>

<para>
<indexterm><primary>IPX (Internet Packet eXchange)</primary></indexterm>
<indexterm><primary>protocolos</primary><secondary>Internet Packet eXchange (IPX)</secondary></indexterm>
<indexterm><primary>protocolo X.25</primary></indexterm>
<indexterm><primary>protocolos</primary><secondary>X.25</secondary></indexterm>
<indexterm><primary>ATM, (Asynchronous Transfer Mode)</primary></indexterm>
<indexterm><primary>protocolos</primary><secondary>ATM (Asynchronous Transfer Mode)</secondary></indexterm>
<indexterm><primary>protocolo AX.25</primary></indexterm>
<indexterm><primary>protocolos</primary><secondary>AX.25</secondary></indexterm>
<indexterm><primary>protocolo NetRom</primary></indexterm>
<indexterm><primary>protocolos</primary><secondary>NetRom</secondary></indexterm>
<indexterm><primary>protocolo Rose</primary></indexterm>
<indexterm><primary>protocolos</primary><secondary>Rose</secondary></indexterm>
En GNU/Linux, la biblioteca de sockets forma parte de la biblioteca C estándar, <filename>libc</filename>. Da soporte a los sockets <function>AF_INET</function> y <function>AF_INET6</function>, para sockets de dominio Unix. También soporta <function>AF_IPX</function> para los protocolos de redes Novell; <function>AF_X25</function> para el protocolo X.25; <function>AF_ATMPVC</function> y <function>AF_ATMSVC</function> para el protocolo de redes ATM; y <function>AF_AX25</function>, <function>AF_NETROM</function>, y <function>AF_ROSE</function> para sockets que usen el protocolo de radio-aficionados<footnote><para>Amateur Radio Protocol. Nota del T.</para></footnote>. En este momentos se están desarrollando otras familias de protocolos conocidos, que se agregarán sin esperar mucho tiempo. 
</para>
<INDEXTERM startref="chit.networks.tcp-ip" class=endofrange>
</sect2>
<?troff .Nd 7>
</sect1>

<sect1 id="X-087-2-intro.uucp"><title>Redes UUCP</title>
<para>
<indexterm><primary>redes</primary><secondary>UUCP</secondary></indexterm>
<INDEXTERM><PRIMARY>UUCP</PRIMARY><SECONDARY>redes</SECONDARY></INDEXTERM>
UUCP (Unix-to-Unix Copy), empezó como un paquete de programas para transferir ficheros sobre líneas serie, planificar dichos envíos, e iniciar la ejecución de ciertos programas en sitios remotos. Ha experimentado algunos cambios importantes desde la primera implementación a finales de los setenta, aunque sigue siendo muy estricto en la clase de servicios que ofrece. La principal aplicación de esta tecnología sigue siendo en las Redes de Área Amplia, basándose en enlaces periódicos por red telefónica. 
</para>

<para>
UUCP fue desarrollado por Laboratorios Bell en 1977, con el cometido de comunicar sus sitios Unix en crecimiento. A mediados de 1978, esta red ya contaba con más de 80 sitios, los cuáles tenían acceso a correo electrónico como aplicación, así como a impresión remota. Así y todo, el sistema central en sí, se usaba principalmente para distribuir software y correcciones del mismo. Hoy día, UUCP no está confinada únicamente para el ambiente Unix. Existen portaciones de libre distribución y comerciales disponibles para una gran variedad de plataformas, incluyendo a AmigaOS, DOS y el TOS de Atari.
</para>

<para> 
Una de las desventajas secuenciales de las redes UUCP es su operación por lotes. O sea, no cuentan con una conexión permanente establecida entre nodos, sino que usa conexiones temporales. Una máquina UUCP, quizá sólo sea capaz de conectarse una vez al día a otro nodo UUCP, y si es así, sólo podrá hacerlo por un corto período de tiempo. Mientras dure la conexión, se transferirán todas las noticias, los correos y ficheros que estén en cola, y luego se desconectará. Esta cola será lo que limite la cantidad de aplicaciones que puedan hacer uso de la conexión UUCP. En el caso del correo electrónico, un usuario podrá escribir un mensaje y ponerlo en el buzón, (dejarlo en la cola). El mensaje esperará, y será enviado solamente cuando el servidor UUCP se conecte a otro nodo UUCP. Esto no está mal para servicios como el correo electrónico, pero no se usa, en lo absoluto, para otros servicios, como por ejemplo <command>rlogin</command>.
</para>

<para>
A pesar de estas limitaciones, todavía existen muchas redes UUCP funcionando en todo el mundo, operadas principalmente como pasatiempo de algunas personas que ofrecen acceso privado, a precios razonables. La razón principal por la cual UUCP ha durado tanto tiempo es el relativo bajo costo para acceder a ellas, comparado con tener la computadora conectada directamente a Internet. Para hacer de una computadora un nodo UUCP, todo lo que se necesitará será un módem, una implementación UUCP en funcionamiento, y un nodo UUCP que esté dispuesto para suministrarnos los servicios de correo electrónico y noticias. Mucha gente está dispuesta a levantar servicios UUCP individualmente, ya que este tipo de conexiones no requieren de muchos recursos en sus redes. 
</para>

<para>
Se cubrirá la configuración de UUCP en el capítulo correspondiente, más adelante en el libro. Sin embargo no se discutirá profundamente el uso de esta tecnología, ya que actualmente está siendo reemplazada por TCP/IP. Se puede notar esto, en el hecho de que ahora, el tener acceso barato a Internet se ha convertido en algo común en casi todas las partes del mundo. 
</para>
</sect1>

<sect1><title>Redes con GNU/Linux</title>

<para>
<indexterm><primary>GNU/Linux</primary><secondary>redes</secondary></indexterm> 
<indexterm><primary>redes</primary><secondary>GNU/Linux</secondary></indexterm> 
<indexterm><primary>Net-1 network version</primary></indexterm>
<indexterm><primary>Net-2d network version</primary></indexterm>
<indexterm><primary>Net-2Debugged network version</primary></indexterm>
<indexterm><primary>Net-3 network version</primary></indexterm>
<indexterm><primary>Biro, Ross</primary></indexterm>
<indexterm><primary>Cox, Alan</primary></indexterm>
<indexterm><primary>Kempen, Fred van</primary></indexterm>
Siendo el resultado del esfuerzo concentrado de programadores de todo el mundo, la creación de GNU/Linux no habría sido posible sin la red global. Tanto así, que no sorprende que ya en los primeros pasos del desarrollo, varias personas comenzaran a trabajar para dotarlo de capacidades de red. Casi desde el principio existía ya una implementación de UUCP para Linux. En el otoño de 1992 se comenzó a desarrollar el soporte de TCP/IP, cuando Ross Biro y otros crearon lo que ahora se conoce como Net-1.
</para>

<para>
Después de que Ross dejara el desarrollo activo en Mayo de 1993, Fred van Kempen comenzó a trabajar en una nueva implementación, reescribiendo gran parte del código. Este esfuerzo continuado se conoce como Net-2. En el verano de 1993 salió la primera versión pública de Net-2d (como parte del kernel 0.99.10), y ha sido mantenida y ampliada por varias personas, muy especialmente por Alan Cox<footnote id="X-087-2-FNIT04"><para>Se puede contactar con Alan, en <systemitem role="emailaddr">alan@lxorguk.ukuu.org.uk</systemitem></para></footnote>, dando lugar al Net-2Debugged. Tras una dura corrección y numerosas mejoras en el código, se cambió su nombre a Net-3 después de que Linux 1.0 fuera sacado al público. Net-3 fue desarrollado exclusivamente para Linux 1.2 y Linux 2.0. Los núcleos de versiones 2.2 en adelante, utilizan el soporte para redes Net-4, el cual es la versión del código de red que se incluye actualmente en las versiones oficiales del núcleo.
</para>

<para>
<indexterm><primary>Versión de red Net-4</primary></indexterm> 
La versión del código de red de Linux, Net-4, ofrece una gran variedad de controladores para dispositivos, y muchas características avanzadas. Dentro de los protocolos estándar de Net-4 se incluyen SLIP y PPP, (para el envío de tráfico de redes sobre líneas series), PLIP (para líneas paralelas), IPX (para redes compatibles con Novell, sobre las cuáles se hablará en <xref linkend="X-087-2-ipx">), Appletalk (para redes Apple), y AX.25, NetRom y Rose, (para redes de radio-aficionados). Otros rasgos característicos de Net-4 son la inclusión de cortafuegos IP, contabilidad IP (tema estudiado más en detalle en <xref linkend="X-087-2-firewall"> y <xref linkend="X-087-2-accounting">), y enmascaramiento IP (discutido más adelante, en <xref linkend="X-087-2-ipmasq">)<footnote><para>&ldquo;Cortafuegos IP&rdquo;, &ldquo;Auditoría IP&rdquo;, &ldquo;Enmascaramiento IP&rdquo; y &ldquo;Túneles IP&rdquo;, son las respectivas traducciones de los términos &ldquo;IP Firewalling&rdquo;, &ldquo;IP accounting&rdquo;, &ldquo;IP Masquerade&rdquo;, y &ldquo;IP Tunnelling&rdquo;</para></footnote>. Están soportados los túneles IP, en una unión de diferentes gustos y políticas avanzadas de encaminamiento (routing). También se da soporte a una gran variedad de dispositivos Ethernets, además de algunos FDDI, Token Ring, Frame Relay, y tarjetas RDSI, y ATM.
</para>

<para>
<indexterm><primary>Tridgell, Andrew</primary></indexterm>
Además de lo que ya se ha citado, hay algunas otras características que acentúan de gran manera la flexibilidad de Linux. Dentro de las mismas se destaca una implementación del sistema de ficheros SMB, el cuál interacciona con aplicaciones como <emphasis>lanmanager</emphasis> y Microsoft Windows. Esta implementación se llama Samba, y fue escrita por Andrew Tridgell. También se destaca una implementación de Novell NCP, o Protocolo Interno de NetWare (NetWare Core Protocol).<footnote id="X-087-2-FNIT05"><para>NCP es el protocolo en el cuál se basa el servicio de ficheros e impresión de Novell. 
</para>
</footnote>

</para>

<sect2><title>Diferentes Etapas de Desarrollo</title>
<para>
Dentro del ambiente GNU/Linux, en varias ocasiones, se han presentado varios esfuerzos de desarrollo a la vez. 
</para>

<para>
<indexterm><primary>Net-2e network version</primary></indexterm>
<indexterm><primary>DDI (Device Driver Interface)</primary></indexterm> 
<indexterm><primary>Device Driver Interface (DDI)</primary></indexterm> 
Mientras tanto, al finalizar y lanzar la implementación oficial de Net-2Debugged, Fred siguió desarrollando el Net-2e, que dispone de un diseño más revisado de la capa de red. Fred trabajó para llegar a un estándar, llamado Interfaz de Controlador de Dispositivo, (Device Driver Interface, DDI). Sin embargo, hoy en día el desarrollo de Net-2e ha terminado. 
</para>

<para>
<indexterm><primary>Urlichs, Matthias</primary></indexterm> 
Otra implementación más para redes TCP/IP, es la realizada por Matthias Urlichs, quien escribió un controlador de RDSI para Linux y FreeBSD. Para ello, integró algo del código de red de BSD, en el núcleo Linux. Al igual que el anterior, ya no se trabaja más en este proyecto.  
</para>

<para>
Los cambios son acelerados en las implementaciones de red para el núcleo Linux, y &ldquo;cambio&rdquo; sigue siendo el lema, tanto que el desarrollo continúa. Muchas veces, esto también significa que los cambios deberán llegar a otro software, como por ejemplo, las herramientas de configuración de la red. Aunque éste ya no es un problema esencial, como antes lo era, se puede encontrar con que al actualizar el núcleo, también se deban actualizar las herramientas de configuración de la red. Afortunadamente, gracias a la gran variedad de distribuciones disponibles actualmente, esto es una tarea relativamente fácil de llevar a cabo. 
</para>

<para>
<indexterm><primary>IPv6 (Internet Protocol)</primary></indexterm>
<INDEXTERM><PRIMARY>IP (Internet Protocol)</PRIMARY><SECONDARY>IPv6</SECONDARY></INDEXTERM>
La implementación para redes Net-4 está actualmente en una etapa bastante madura, y es usada en un gran número de sitios alrededor del mundo. Ha costado mucho trabajo el mejorar su rendimiento, y ahora compite con las mejores implementaciones disponibles para su misma plataforma de trabajo. GNU/Linux está extendiéndose rápidamente en el entorno de Proveedores de Servicio de Internet, y muchas veces es elegido por pequeñas organizaciones que necesitan de servidores World Wide Web, de correo y noticias realmente baratos y fiables. Hoy en día, existe el suficiente interés en el desarrollo de Linux, como para decir que se puede mantener el ritmo de los cambios tecnológicos en cuanto a redes. Por ejemplo, las últimas liberaciones del núcleo Linux ofrecen como estándar, la próxima generación del protocolo IP, IPv6. 
</para>

</sect2>

<sect2><title>Dónde Conseguir el Código</title>

<para>
<indexterm><primary>código, obteniendo el</primary><secondary>Redes GNU/Linux</secondary></indexterm>
<indexterm><primary>GNU/Linux</primary><secondary>redes</secondary><tertiary>obteniendo el código para</tertiary></indexterm>
<indexterm><primary>FTP (File Transfer Protocol), ubicación del código de GNU/Linux</primary></indexterm>
<indexterm><primary>versión de red Net-3</primary></indexterm>
Parece extraño el recordar aquellos primeros días del desarrollo del código de red para GNU/Linux. El núcleo estándar requería de un gran conjunto de parches, para dar soporte a redes. En la actualidad, sin embargo, el desarrollo del soporte para redes tiene lugar como parte misma del flujo principal del proceso de desarrollo de GNU/Linux. Los núcleos Linux estables más recientes, se pueden encontrar en <emphasis role=bold>ftp.kernel.org</emphasis> dentro de <filename>/pub/linux/kernel/v2.x/</filename>, donde <emphasis>x</emphasis> es un número par. Análogamente, los núcleos Linux experimentales más recientes se pueden obtener en <emphasis role=bold>ftp.kernel.org</emphasis> dentro de <filename>/pub/linux/kernel/v2.y/</filename>, donde esta vez <emphasis>y</emphasis>, es un número impar. Existen réplicas de las distintas versiones del núcleo Linux repartidas por todo el mundo<footnote><para>Y hasta en distintos idiomas. Nota del T.</para></footnote>. Después de esto,  sería difícil de imaginar a GNU/Linux sin soporte estándar de red. 
</para>

</sect2>

</sect1>

<sect1><title>Mantenimiento del Sistema</title>

<para>
<indexterm><primary>mantenimiento del sistema</primary></indexterm>
<indexterm><primary>sistema, mantenimiento</primary></indexterm>
A lo largo de este libro, se discutirá principalmente cuestiones de instalación y configuración. Sin embargo, la administración de un sistema, es mucho más que eso&mdash;después de activar un servicio, también se deberá mantenerlo en correcto funcionamiento. Para la mayoría de éstos, será suficiente con una pequeñas revisiones, pero para otros servicios, como lo son el correo o las noticias, será necesario ejecutar rutinas de verificación para mantener el sistema en óptimo estado. Se discutirán estas tareas, en los capítulos siguientes. 
</para>

<para>
<indexterm><primary>cron</primary></indexterm>
<INDEXTERM><PRIMARY>errores, buscando</PRIMARY></INDEXTERM>
La tarea mínima de mantenimiento es comprobar regularmente el sistema y los ficheros de registro de cada aplicación buscando condiciones de error y eventos inusuales. Por lo general, es posible hacer esto escribiendo un par de scripts de órdenes y ejecutándolos periódicamente mediante la orden <command>cron</command>. Se podrá encontrar algunos de estos scripts en distribuciones fuente de algunas aplicaciones importantes como <command>inn</command> o C News. Tras obtenerlos, sólo se tendrá que retocarlos para adecuarlos a nuestras necesidades y preferencias.
</para>

<para>
La salida de cualquiera de los trabajos de nuestro <command>cron</command>, se debería enviar a una cuenta de administración. Por defecto, muchas aplicaciones enviarán informes de errores, estadísticas de uso, o resúmenes del fichero de registro a la cuenta de <systemitem role="userid">root</systemitem>. Ésto solo tiene sentido si se entra al sistema como <systemitem role="userid">root</systemitem> frecuentemente. Una idea mucho mejor es redirigir el correo de <systemitem role="userid">root</systemitem> a nuestra cuenta personal, estableciendo un alias de correo como se describe en <xref linkend="X-087-2-exim"> y en <xref linkend="X-087-2-sendmail">.
</para>

<para>
De todos modos, por muy cuidadoso que sea configurando su máquina, la ley de Murphy garantiza que <emphasis>surgirá</emphasis> algún problema en el futuro. Por lo tanto, el mantenimiento de un sistema implica también estar disponible para quejas. Generalmente la gente espera que se pueda contactar con el administrador del sistema al menos por correo electrónico, como <systemitem role="emailaddr">root</systemitem>. Sin embargo, existen otras denominaciones para direcciones de correo usadas comúnmente para contactar a los posibles encargados de la administración de respectivos servicios del sistema. Por ejemplo, las quejas sobre el mal funcionamiento del correo se dirigirán generalmente al <systemitem role="emailaddr">postmaster</systemitem> (encargado del correo). Del mismo modo, los problemas con el sistema de noticias pueden ser comunicados a <systemitem role="emailaddr">newsmaster</systemitem> o al <systemitem role="emailaddr">usenet</systemitem>. El correo al <systemitem role="emailaddr">hostmaster</systemitem> se debería redirigir a la persona encargada de los servicios básicos de red del nodo, y del servicio de nombres DNS si esta funcionando un servidor de nombres. 
</para>

<sect2 id="X-087-2-intro.security"><title>Seguridad del Sistema</title>

<para>
<indexterm><primary>seguridad del sistema</primary></indexterm>
<indexterm><primary>seguridad</primary><secondary>sistema</secondary></indexterm>
Otro aspecto muy importante de la administración de sistemas en un entorno de red es proteger al sistema y a sus usuarios de intrusos. Los sistemas que son administrados descuidadamente ofrecen muchos huecos a los malintencionados: los ataques van desde averiguar las claves hasta acceder a nivel de Ethernet, y el daño causado puede ser desde mensajes de correo falsos hasta pérdida de datos o violación de la privacidad de los usuarios. Mencionaremos algunos problemas concretos cuando discutamos el contexto en el que pueden ocurrir, y algunas defensas comunes contra ellos.
</para>

<para>
En esta sección se comentarán algunos ejemplos y técnicas básicas para poder lidiar con la seguridad del sistema. Por supuesto, los temas relatados aquí no pueden tratar exhaustivamente todos los aspectos de seguridad con los que uno se puede encontrar; sirven meramente para ilustrar los problemas que pueden surgir. Por tanto, la lectura de un buen libro sobre seguridad es absolutamente obligada, especialmente en un sistema en red. 
</para>

<para>
La seguridad del sistema comienza con una buena administración del mismo. Esto incluye comprobar la propiedad y permisos de todos los ficheros y directorios vitales, monitorizar el uso de cuentas privilegiadas, etc. El programa COPS, por ejemplo, sirve para comprobar nuestro sistema de ficheros y ficheros de configuración generales, en busca de permisos inusuales u otras anomalías. También es conveniente usar un sistema de claves que fuerce ciertas reglas en las claves de los usuarios que las hagan difíciles de adivinar. El sistema de claves ocultas (shadow password), por ejemplo, requiere que una clave tenga al menos cinco letras, entre las cuales se encuentren tanto mayúsculas como minúsculas, números y caracteres no-alfabéticos.
</para>

<para>
<indexterm><primary>servicios</primary><secondary>restringiendo el acceso a</secondary></indexterm> <indexterm><primary>TFTP (Trivial File Transfer Protocol)</primary></indexterm> 
Cuando un servicio se hace accesible a la red, asegúrese de darle el &ldquo;menor privilegio&rdquo;. Esto significa, en una palabra que no se deberán permitir acciones que no son imprescindibles, para que se trabaje como se diseñó el servicio originalmente. Por ejemplo, el usuario debería hacer sus programas  setuid <systemitem role="userid">root</systemitem>, o alguna otra cuenta privilegiada, sólo si realmente se necesitara. También, si se quiere usar un servicio sólo para una aplicación muy limitada, el administrador del sistema no debe vacilar en configurar el servicio tan restrictivamente como la aplicación especial lo permita. Por ejemplo, si se quiere permitir a máquinas sin disco arrancar desde un nodo en especial, se debe facilitar el servicio TFTP (<emphasis>Trivial File Transfer Protocol</emphasis>&thinsp; de modo que se puedan obtener los ficheros de configuración básicos del directorio <filename>/boot</filename>. Sin embargo, cuando se usa sin restringir, TFTP permite a cualquier usuario de cualquier lugar del mundo leer cualquier fichero de su sistema. Si esto no es lo que desea,  se debe restringir el servicio TFTP solamente al directorio <filename>/boot</filename><footnote id="X-087-2-FNIT06"><para> Se volverá a retomar este tema en <xref linkend="X-087-2-appl">.
</para>
</footnote>

</para>

<para>
<indexterm><primary>acceso</primary><secondary>restringiendo el</secondary></indexterm>
Pensando en la misma línea, se podría restringir ciertos servicios a usuarios que acceden desde ciertos nodos, digamos desde nuestra red local. En <xref linkend="X-087-2-appl">, presentaremos <command>tcpd</command>, que hace esto para una variedad de aplicaciones de red. Se explorarán otros métodos más sofisticados para restringir el acceso a nodos o servicios particulares en <xref linkend="X-087-2-firewall">. 
</para>

<para>
Otro punto importante a tener en cuenta es evitar software &ldquo;peligroso&rdquo;. Claro que cualquier software que se utilice puede resultar peligroso, dado que el software puede tener fallos que gente astuta pueda explotar para acceder a nuestro sistema. Cosas como ésta ocurren, y no hay protección segura contra ello. Este problema afecta al software libre y a productos comerciales por igual<footnote id="X-087-2-FNIT07"><para> Ha habido sistemas UNIX comerciales, (por los que hay que pagar un montón de dinero), que venían con un script de shell setuid-<systemitem role="userid">root</systemitem> que permitía a los usuarios obtener privilegios de <systemitem role="userid">root</systemitem> utilizando un simple y conocido truco.</para> </footnote>. De cualquier modo programas que requieran privilegio especial son inherentemente más peligrosos que otros, ya que cualquier fallo aprovechable en éstos puede tener consecuencias desastrosas.<footnote id="X-087-2-FNIT08"><para>En 1988, el gusano RTM llevó a gran parte de Internet a un colapso, en parte por explotar un agujero que había en algunos programas, incluyendo a <command>sendmail</command>. Este agujero ya ha sido reparado con creces.</para></footnote> Si instala un programa setuid con propósitos de red, sea muy cuidadoso y no deje de leerse toda la documentación, de manera tal de no crear una brecha en la seguridad del sistema por accidente.
</para>

<para>
<INDEXTERM><PRIMARY>herramientas ssh</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>autentificación</PRIMARY><SECONDARY>cuestiones de</SECONDARY></INDEXTERM>
Otra fuente a considerar deberían ser aquellos programas que permiten registrarse en el sistema, o la ejecución de órdenes con autentificación limitada. Las órdenes <command>rlogin</command>, <command>rsh</command> y <command>rexec</command>, son muy útiles pero ofrecen un muy ligero método de autentificación para aquellos que hagan uso de ellas. Un método de autentificación se basa en la confianza del nombre del nodo llamado, el cual fue obtenido de un servidor de nombres, (se hablará de estos más adelante), que pudo haber sido falseado. Hoy en día, debería ser una práctica común el reemplazar completamente las órdenes  <command>r</command> con la colección de herramientas <command>ssh</command>. Las herramientas <command>ssh</command>  usan un método de autentificación mucho más confiable, además de proporcionar otros servicios como encriptación y compresión. 
</para>

<para>
<indexterm><primary>tripwire</primary></indexterm>
Nunca se debería de olvidar que nuestras precauciones pueden fallar, por muy cuidadosas que estas sean. Por eso se debería asegurar de que la detección de los posibles intrusos es relativamente rápida. Comprobar los ficheros de actividad es un buen comienzo, pero el intruso probablemente sea bastante listo, y borrará cualquier huella que haya dejado. Sin embargo, hay herramientas como <command>tripwire</command>, (escrito por Gene Kim y Gene Spafford), <footnote><para> del que ya hay disponible una traducción en tldp-es</para></footnote>que permite comprobar ficheros vitales del sistema para ver si sus contenidos o permisos han cambiado. <command>tripwire</command> realiza varias e intensas sumas de verificación (checksums) sobre estos ficheros y almacena los resultados en una base de datos. En las siguientes ejecuciones, se reevalúan y comparan dichas sumas de verificación con las almacenadas, detectándose así cualquier posible modificación.

<indexterm class="endofrange" startref="chit.netwks.intro"> 
</para>

</sect2>
</sect1>
</chapter>
