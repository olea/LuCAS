<!-- $Id: ch04.sgm,v 1.7 2002/11/17 17:43:43 pakojavi2000 Exp $ -->
<!--
Nota legal:

   Linux Network Administration Guide, por Olaf Kirch et al.

   La traducción al español se publica bajo la licencia GFDL,
siendo texto de portada el siguiente:

Linux Network Administrator's Guide
by Olaf Kirch and Terry Dawson
Copyright  (c) 1993 Olaf Kirch
Copyright  (c) 2000 Terry Dawson
Copyright on O'Reilly printed version (c) 2000 O'Reilly & Associates

y siendo secciones invariantes, la sección de Agradecimientos,
la sección titulada «La traducción al español», el apéndice C; así
como esta nota.

Capítulo traducido por:

dani, contusion@interlap.com.ar

Revisión 1 por Francisco Javier Fernández
-->
<chapter id="X-087-2-serial"><title>Configuración del Hardware Serie</title>
<indexterm id="idx-hardwareserial-1" class="startofrange"><primary>hardware</primary><secondary>configuración serie</secondary></indexterm>
<indexterm id="idx-deviceserial-1" class="startofrange"><primary>dispositivos</primary><secondary>serie</secondary></indexterm>
<indexterm id="ch04.serdev.setup" class="startofrange"><primary>dispositivos serie</primary><secondary>configuración</secondary></indexterm>

<para>
Internet está creciendo en una proporción increíble. Gran parte de este
crecimiento se atribuye a usuarios que no pueden permitirse conexiones
permanentes a la red, y que usan protocolos como SLIP, PPP, o UUCP
para conectar por teléfono con un proveedor de red y recoger su ración
diaria de correo electrónico y noticias (news).
</para>

<para>
<indexterm><primary>Hankins, Greg</primary></indexterm>
<indexterm><primary>HOWTOs</primary><secondary>Serie</secondary></indexterm>
Este capítulo va dedicado a aquellos que emplean módems para mantener su
vínculo con el resto del mundo. No se cubrirán los aspectos de configuración del módem (el
manual que lo acompaña le proporcionará más información que nosotros), pero sí
nos centraremos en la mayor parte de los aspectos específicos de GNU/Linux relativos al uso
de dispositivos que emplean puertos serie. Incluiremos temas sobre aplicaciones para
comunicación serie, creación de ficheros de dispositivos serie, hardware serie y configuración
de dispositivos con las órdenes <command>setserial</command> y <command>stty</command>.
El Serial HOWTO de David Lawyer cubre otros muchos temas.<footnote id="X-087-2-FNSE1">
<para>
Es posible contactar con David en la dirección de correo electrónico
<systemitem role="emailaddr">bf347@lafn.org</systemitem>.
</para>
</footnote>

</para>

<sect1 id="X-087-2-serial.software"><title>Software de Comunicaciones
<?lb>para Enlaces con Módem</title> <indexterm><primary>programas de terminal
</primary></indexterm> <indexterm><primary>kermit (programa de terminal)</primary></indexterm> <indexterm><primary>minicom (programa de terminal)</primary></indexterm> <indexterm><primary>BBS (Bulletin Board
System, Sistema de Tablón de Anuncios)</primary></indexterm> <indexterm><primary>tablón de anuncios</primary></indexterm> <indexterm id="ch03.modem.comm.sw"
class="startofrange"><primary>modems</primary><secondary>enlaces</secondary><tertiary>software de comunicación para</tertiary></indexterm>

<para>
GNU/Linux tiene disponible cierta cantidad de aplicaciones de comunicaciones.
Muchas de éstas son <emphasis>programas de terminal</emphasis>,
que permiten al usuario conectar por teléfono a otro ordenador como si
estuviera sentado tras un terminal simple. El programa más tradicional
para entornos Unix y similares es <command>kermit</command>. No
obstante, es bastante antiguo y podría ser considerado difícil de usar.
Hay otros programas más cómodos y con más características, como
listines de teléfonos a los que conectar, lenguajes de script para hacer
automática la llamada y acceso (login) al sistema remoto, y un rango de
protocolos de intercambio. Uno de esos programas es <command>minicom</command>,
creado con base en varios de los programas de terminal para DOS.
También tienen representación los usuarios de X11. <command>seyon</command>
es un completo programa de comunicaciones basado en X11.
</para>

<para>
Los programas de terminal no son los únicos disponibles. Otros programas
le permiten conectar con un ordenador y transferir correo electrónico y
noticias (news) de forma compacta, para leer y contestar en otro momento
cualquiera. Esto puede suponer un buen ahorro de tiempo, y es especialmente
útil si tiene usted la mala fortuna de vivir en una zona donde las llamadas
locales se pagan por duración. Todo el tiempo dedicado a leer y contestar
se puede estar desconectado, y, cuando esté listo, puede volver a conectar
y enviar todas las respuestas en un único bloque. La contrapartida es un
uso un poco mayor de disco duro, ya que los mensajes son almacenados
en él antes de ser leídos; sin embargo, con los precios actuales de
discos duros, esta opción puede ser interesante.
</para>

<para>
<indexterm><primary>UUCP</primary></indexterm>
<indexterm><primary>FidoNet</primary></indexterm>
UUCP ejemplifica este estilo de programas de
comunicaciones. Es un conjunto de aplicaciones que copian ficheros de una
computadora a otra y ejecutan programas en computadoras remotas.
Se usa frecuentemente para trasladar correo o noticias dentro de redes
privadas. El paquete de UUCP de Ian Taylor, que también funciona en
GNU/Linux, se describe con detalle en <xref linkend="X-087-2-uucp">.
Otro software no interactivo de comunicaciones se usa en redes como Fidonet.
Existen versiones de aplicaciones de Fidonet como <command>ifmail</command>,
aunque no esperamos que haya todavía mucha gente utilizándolas.
</para>

<para>
<indexterm><primary>protocolo SLIP (Serial Line IP, IP en Línea Serie)
</primary></indexterm> <indexterm><primary>PPP (Point-to-Point
Protocol, Protocolo Punto-a-Punto)</primary></indexterm>
<indexterm><primary>protocolos</primary><secondary>SLIP</secondary></indexterm>
<indexterm><primary>protocolos</primary><secondary>PPP</secondary></indexterm>
PPP y SLIP estan a mitad de camino, puesto que permiten tanto uso interactivo
como no interactivo. Mucha gente usa PPP o SLIP para conectar por teléfono
a la red de su Universidad u otro Proveedor de Servicios de Internet para
ejecutar FTP y leer páginas de la web. PPP y SLIP son, sin embargo, empleadas
también con frecuencia para conexiones permanentes o semi-permanentes de
interconexión entre LAN. De todos modos, este uso es interesante sólo con
RDSI u otro tipo de conexión de alta velocidad.
</para>

<indexterm class="endofrange" startref="ch03.modem.comm.sw">
</sect1>

<sect1 id="X-087-2-serial.ttys"><title>Introducción a los Dispositivos Serie</title>
<indexterm id="idx-tty-1" class="startofrange"><primary>ttys</primary></indexterm>

<para>
El núcleo de Unix proporciona dispositivos para acceder a hardware serie, típicamente
conocidos como dispositivos <emphasis>tty</emphasis>. Se trata de una abreviatura
de dispositivos <emphasis>Teletype</emphasis>, que fue uno de los principales
fabricantes de dispositivos de terminal en los primeros días de Unix. Esta terminología
se usa actualmente para cualquier terminal basado en caracteres. En este capítulo
emplearemos este término para referirnos exclusivamente a los ficheros de
dispositivo de GNU/Linux, no para el teminal físico.
</para>

<para>
GNU/Linux proporciona tres tipos de dispositivos tty: dispositivos serie,
terminales virtuales (accesibles por orden con las pulsaciones Alt-F1 a
Alt-F<emphasis>nn</emphasis> en la consola local), y pseudo-terminales
(similares a una tubería de dos direcciones, empleados por aplicaciones como
X11). Los primeros recibieron el nombre de dispositivos tty porque originalmente
los terminales basados en caracteres se conectaban a la máquina Unix
mediante un cable serie o con un módem y una línea de teléfono. Los otros dos
recibieron la misma denominación debido a que tratan de comportarse de
manera similar, desde el punto de vista del programador.
</para>

<para>
<indexterm><primary>disciplina de línea</primary></indexterm>
<indexterm><primary>ttys</primary><secondary>disciplina de
línea</secondary></indexterm> SLIP y PPP se implementan en la
mayoría de casos en el núcleo. Realmente, el núcleo no trata a un
dispositivo <emphasis>tty</emphasis> como dispositivo de red al
cual se pueda manipular, como los dispositivos Ethernet, empleando
órdenes como <command>ifconfig</command>. Sin embargo, sí que
trata a los dispositivos tty como lugares a los que se pueden asociar
dispositivos de red. Para hacer esto, el núcleo cambia lo que se llama
&ldquo;disciplina de línea&rdquo; del dispositivo tty. Tanto SLIP como
PPP son disciplinas de línea que pueden ser activadas en dispositivos
tty. La idea, en general, es que el manejador serie trata los datos que
recibe de forma distinta según la disciplina de línea para la que está
configurado. En la disciplina de línea por defecto, el manejador se limita
a transmitir cada carácter que recibe por orden. Por contra, al seleccionar
SLIP o PPP como disciplina de línea, el manejador lee bloques de datos,
los encapsula con una cabecera especial que permite al otro extremo
de la conexión identificarlos en una secuencia, y transmite todo el
nuevo bloque. No es realmente importante comprender esto por ahora;
trataremos SLIP y PPP en capítulos posteriores. De todos modos,
esto sucede automáticamente para usted.
</para>

</sect1>

<sect1 id="X-087-2-serial.devices"><title>Acceso a Dispositivos Serie</title>
<para>
Como todo dispositivo en un sistema Unix, los puertos serie son accesibles
a través de ficheros especiales de dispositivo, localizados en el directorio
<filename>/dev</filename>. Hay dos tipos de ficheros de dispositivo
relacionados con manejadores serie, y hay un fichero de dispositivo de cada
tipo para cada puerto. El dispositivo tendrá un comportamiento levemente
distinto, según cuál de sus ficheros de dispositivo empleemos. Cubriremos
estas diferencias porque ayudará a entender algunos aspectos de
configuración y algunos consejos que puede encontrar respecto a
dispositivos serie, pero en la práctica, sólo necesita utilizar uno de ellos. Quizá
en un futuro desaparezca alguno de estos tipos.
</para>

<para>
<indexterm id="idx-filenamedevcuafilename-1" class="startofrange"><primary sortas="dev/cua*">/dev/cua*</primary></indexterm>
<indexterm id="idx-filenamedevttySfilename-1" class="startofrange"><primary sortas="dev/ttyS*">/dev/ttyS*</primary></indexterm>
<indexterm><primary>dispositivos serie</primary><secondary>acceso</secondary></indexterm>
<indexterm><primary>línea serie</primary><secondary>fichero de dispositivo</secondary></indexterm>
<indexterm><primary>dispositivo de llamada saliente</primary></indexterm>
<indexterm><primary>dispositivo de llamada entrante</primary></indexterm>
La más importante de las dos clases de dispositivos serie tiene un
número mayor de 4, y sus ficheros especiales de dispositivo se llaman
<filename>ttyS0</filename>, <filename>ttyS1</filename>, etc.
La otra variedad tiene un número mayor de 5, y fue diseñada para emplearse
en llamadas salientes a través de un puerto; sus ficheros especiales de
dispositivo son <filename>cua0</filename>, <filename>cua1</filename>, etc.
En el mundo Unix, las cuentas comienzan generalmente en cero, mientras
que los profanos tienden a comenzar por uno. Esto genera una
pequeña confusión ya que <literal>COM1:</literal> se representa por
<filename>/dev/ttyS0</filename>, <literal>COM2:</literal> por
<filename>/dev/ttyS1</filename>, etc. Un usuario cualquiera familiarizado con hardware
del estilo del IBM PC sabe que <literal>COM3:</literal> y mayores nunca llegaron
a ser estándar, de todos modos.
</para>

<para>
Los dispositivos <emphasis>cua</emphasis>, o &ldquo;llamada salientes,&rdquo;
fueron creados para solucionar el problema de evitar conflictos en dispositivos
serie para módems que tienen que aceptar tanto conexiones entrantes como
conexiones salientes. Desafortunadamente, han creado sus propios problemas
y probablemente dejarán de ser utilizados. Echemos un vistazo al asunto.
</para>

<para>
GNU/Linux, igual que Unix, permite que un dispositivo, u otro fichero cualquiera,
sea abierto por más de un proceso de forma simultánea. Por desgracia,
esto es raramente útil para dispositivos tty, ya que ambos procesos
interferirán entre sí. Pero, por suerte, se diseñó un mecanismo que permite
a un proceso comprobar si un dispositivo tty está en uso por otro proceso
antes de tratar de abrirlo. Este mecanismo usa lo que denominamos
<emphasis>ficheros de bloqueo</emphasis>. La idea es que cuando un proceso trata
de abrir un dispositivo tty, ha de comprobar la existencia de un fichero en
un lugar especial, llamado de forma parecida al dispositivo tty. Si este fichero
no existe, el proceso lo crea y abre el dispositivo tty. Si el fichero, por contra,
ya existe, el proceso asume que hay otro proceso que ya ha abierto el
dispositivo tty y toma la decisión adecuada. Un último truco para que este
sistema de manejo funcionara adecuadamente es escribir el identificador (pid)
del proceso que ha creado el fichero de bloqueo en el propio fichero de
bloqueo; seguiremos con este punto un poco más abajo.
</para>

<para>
El mecanismo de ficheros de bloqueo funciona perfectamente en los casos en
que tenemos una localización bien definida para estos ficheros de bloqueo,
y todos los programas saben dónde buscarlos. Sin embargo, este no ha sido
siempre el caso de GNU/Linux. No fue hasta que se definió el Estándar de Sistema
de Ficheros de Linux (Linux Filesystem Standard) cuando comenzaron a
trabajar correctamente los ficheros de bloqueo <filename>tty</filename>.
Llegó a haber cuatro, e incluso más lugares elegidos por los programadores para
almacenar los ficheros de bloqueo:
<filename>/usr/spool/locks/</filename>,
<filename>/var/spool/locks/</filename>,
<filename>/var/lock/</filename> y
<filename>/usr/lock/</filename>. La confusión trajo el caos. Los programas
abrían ficheros de bloqueo en lugares distintos para controlar un mismo
dispositivo tty; la situación era similar a no usar ficheros de bloqueo en absoluto.
</para>

<para>
Los dispositivos <filename>cua</filename> fueron creados para solventar este
problema. En lugar de confiar a los ficheros de bloqueo la prevención de
conflictos entre procesos que pretendían usar dispositivos serie, se decidió
que el núcleo podría suministrar un método sencillo de arbitrar quién debía
obtener acceso. Si el dispositivo <filename>ttyS</filename> estaba abierto,
un intento de abrir el <filename>cua</filename> resultaría en un error que
podría ser interpretado por el programa como que el dispositivo ya estaba en uso.
Si el <filename>cua</filename> estaba previamente abierto y se trataba de
abrir el <filename>ttyS</filename>, la petición crearía un bloqueo; es decir,
se pondría en espera hasta que el dispositivo <filename>cua</filename> fuera
cerrado por el otro proceso. Esta solución era adecuada para casos como un
módem único configurado para recibir accesos entrantes y que, en ocasiones,
se quisiera emplear para accesos salientes. Pero no era suficiente para ámbitos
en los que varios programas tratan de realizar llamadas salientes desde el mismo
dispositivo. La única forma de remediar este problema era ¡usar ficheros de
bloqueo! De vuelta al problema inicial.
</para>

<para>
Basta decir que el Estándar de Sistema de Ficheros de Linux llegó al rescate y
ahora es obligatorio almacenar los ficheros de bloqueo en el directorio
<filename>/var/lock</filename>, y que, por acuerdo, el nombre del fichero
de bloqueo correspondiente al dispositivo <filename>ttyS1</filename>, por
ejemplo, es <filename>LCK..ttyS1</filename>. Los ficheros de bloqueo
<filename>cua</filename> también deberían ir en este directorio, pero
el uso de dispositivos <filename>cua</filename> queda desaconsejado
</para>

<para>
Los dispositivos <filename>cua</filename> seguirán existiendo por un
tiempo, para conservar la compatibilidad con software antiguo, pero
con el tiempo serán retirados. Si usted se pregunta cuáles debe usar,
quédese con los dispositivos <filename>ttyS</filename>, y asegúrese de
que su sistema cumpla con el estándar Linux FSSTND (Estándar de Sistema
de Ficheros de Linux), o, como mínimo, que todos los programas que
accedan a dispositivos serie estén de acuerdo en la localización de los
ficheros de bloqueo. Gran parte del software que trata con dispositivos tty
serie proporciona opciones de compilación para especificar la localización de
ficheros de bloqueo. Es probable que aparecerá como una variable llamada
<literal>LOCKDIR</literal> en el <filename>Makefile</filename> o en
algún fichero de configuración de cabecera. Si usted mismo compila el
software, la mejor opción es modificar esto de acuerdo al lugar definido en
el FSSTND. Si usa usted binarios precompilados y no está seguro de dónde
escribirá el programa sus ficheros de bloqueo, quizá esta orden pueda
proporcionarle alguna pista:
<screen>
<command>strings</command> <filename>binaryfile</filename> | <command>grep</command> lock
</screen>
Si el lugar encontrado no es compatible con el resto de su sistema, puede
tratar de crear un enlace simbólico desde el directorio de bloqueo que
pretende usar el binario hacia <filename>/var/lock</filename>. No es
una solución muy elegante, pero funcionará.
</para>

<sect2 id="X-087-2-serial.devicefiles"><title>Los Ficheros Especiales De Dispositivos Serie</title>
<para>
<indexterm><primary>puerto COM</primary></indexterm>
<indexterm><primary>puertos</primary><secondary>COM</secondary></indexterm>
Los números menores son idénticos para ambos tipos de dispositivos serie.
Si tiene usted su módem conectado en un puerto desde COM1: a COM4:,
su número menor será el número de puerto COM más 63. Si emplea usted
hardware serie especial, como controladores de múltiples puertos serie de
gran rendimiento, probablemente necesite crear ficheros especiales de
dispositivo para él; probablemente no emplee el manejador estándar de
dispositivo. El Serial-HOWTO debe poder ayudarle a encontrar los detalles
específicos.
</para>

<para>
Supongamos que su módem está en COM2:. Su número menor será 65,
y su número mayor será 4 para usos normales. Debería existir un dispositivo
llamado <filename>ttyS1</filename> que tiene estos números. Liste los
ttys serie del directorio <filename>/dev</filename>. La quinta y sexta
columna muestran respectivamente el número mayor y el número menor:
</para>

<para>
<screen>
$ <userinput>ls -l /dev/ttyS*</userinput>
0 crw-rw----   1 uucp     dialout    4,  64 Oct 13  1997 /dev/ttyS0
0 crw-rw----   1 uucp     dialout    4,  65 Jan 26 21:55 /dev/ttyS1
0 crw-rw----   1 uucp     dialout    4,  66 Oct 13  1997 /dev/ttyS2
0 crw-rw----   1 uucp     dialout    4,  67 Oct 13  1997 /dev/ttyS3
</screen>
</para>

<para>
Si no hay ningún dispositivo con número mayor 4 y número menor 65,
necesitará crear uno. Pase a modo superusuario y escriba:
</para>

<para>
<screen>
# <userinput>mknod -m 666 /dev/ttyS1 c 4 65</userinput>
# <userinput>chown uucp.dialout /dev/ttyS1</userinput>
</screen>
Según la distribución de GNU/Linux, se emplean estrategias sutilmente distintas
para determinar quién debe ser propietario de los dispositivos serie. A veces
son propiedad de <emphasis>root</emphasis>, y en otros casos
pertenecen a otro usuario, como <userinput>uucp</userinput> en
nuestro ejemplo. Las distribuciones más modernas tienen un grupo especial
para dispositivos que realizan llamadas salientes, y todo usuario que pueda
emplearlos estará añadido a este grupo.
</para>

<para>
<indexterm><primary sortas="dev/modem">/dev/modem</primary></indexterm>
Hay quien sugiere crear <filename>/dev/modem</filename> como un enlace
simbólico al dispositivo de módem para que los usuarios ocasionales no tengan
que recordar el menos intuitivo <filename>ttyS1</filename>. Pero no se puede
utilizar <filename>modem</filename> en un programa y el fichero real de dispositivo
en otro. Sus ficheros de bloqueo tendrían nombres diferentes, y esto haría fallar
al mecanismo de bloqueo.
</para>

<para>
<indexterm class="endofrange" startref="idx-filenamedevcuafilename-1">
<indexterm class="endofrange" startref="idx-filenamedevttySfilename-1">
</para>
</sect2>

</sect1>

<sect1 id="X-087-2-serial.hardware"><title>Hardware Serie</title>
<indexterm><primary>interfaz serie RS-232</primary></indexterm>
<para>
RS-232 es actualmente el estándar más común para comunicaciones serie
en el mundo de los PC. Emplea una serie de circuitos para transmitir bits
de uno en uno, así como para sincronización. Otras líneas adicionales pueden
ser empleadas para señalar la presencia de un portador (empleadas por
módems) y para negociación (handshaking). GNU/Linux acepta una amplia
variedad de tarjetas serie que usan el estándar RS-232.
</para>

<para>
<indexterm><primary>líneas serie</primary><secondary>negociación
por hardware</secondary></indexterm> <indexterm><primary>negociación,
hardware</primary></indexterm>
<indexterm><primary>hardware</primary><secondary>negociación</secondary></indexterm>
<indexterm><primary>RTS/CTS (Ready to Send/Clear to
Send)</primary></indexterm>
La negociación por hardware es opcional, pero muy útil. Permite a cualquiera
de las dos estaciones avisar si está preparada para recibir más datos, o si
la otra estación debería esperar mientras se procesan los datos recibidos. Las
líneas usadas para esto se llaman &ldquo;Clear to Send&rdquo; (CTS) y
&ldquo;Ready to Send&rdquo; (RTS), respectivamente, lo que explica el nombre
coloquial para negociación por hardware: &ldquo;RTS/CTS.&rdquo; El otro
tipo de negociación con el que quizá esté usted familiarizado es la
negociación &ldquo;XON/XOFF&rdquo; XON/XOFF utiliza dos caracteres
concretos, convencionalmente Ctrl-S y Ctrl-Q, para indicar al extremo remoto
que debería parar o comenzar la transmisión de datos, respectivamente.
A la par que este método es simple de implementar y válido para uso con
terminales sin procesamiento, también es cierto que crea una gran confusión
cuando los datos son binarios, ya que probablemente se quisieran transmitir
esos caracteres como parte del flujo de datos que enviamos, en lugar de
que fueran interpretados como caracteres de control del flujo. Por otra parte,
la rapidez con que toman efecto es menor que con negociación por hardware.
La negociación hardware es limpia, rápida y se recomienda sobre XON/XOFF
si existe la posibilidad de elegir.
</para>

<para>
<indexterm><primary>8250 UART</primary></indexterm>
<indexterm><primary>16450 UART</primary></indexterm>
<indexterm><primary>16550 UART</primary></indexterm>
<indexterm><primary>UART</primary></indexterm>
En el IBM PC original, el interfaz RS-232 era manejado por un chip UART
llamado 8250. Los PCs de la época del 486 emplearon una versión más
moderna del UART, llamada 16450. Era ligeramente superior al 8250.
Casi todas las máquinas basadas en procesadores Pentium contienen
otra versión aún más moderna del UART, llamada 16550. Ciertas marcas
(particularmente módems internos equipados con el chipset Rockwell)
utilizan chips completamente distintos que emulan el comportamiento
del 16550 y pueden ser tratados de forma similar. GNU/Linux acepta todos
ellos con su manejador estándar de puerto serie.<footnote id="X-087-2-serial-FIXME">
<para>
¡Nótese que no estamos hablando sobre WinModem&trade; aquí! Los
WinModems tienen una circuitería muy simple y dependen por completo de
la CPU principal de su ordenador, en lugar de hardware específico que haga
todo el trabajo duro. Si ha decidido comprar un módem, le recomendamos
encarecidamente que <emphasis>no</emphasis> compre un módem de
ese tipo; consiga un módem de verdad. Quizá encuentre soporte para
WinModems en GNU/Linux, pero eso sólo los convierte en una solución marginalmente
más atractiva.
</para>
</footnote>

</para>

<para>
El 16550 fue una mejora significativa sobre el 8250 y el 16450, ya que
proporciona un búfer FIFO de 16 bytes. En realidad, el 16550 es una
familia de dispositivos UART, que comprende el 16550, el 16550A y el
16550AFN (posteriormente llamado PC16550DN). Las diferencias radican
en si el FIFO funciona realmente o no; el 16550AFN es el único en el que
es seguro que funciona. También existió un NS16550, pero su FIFO nunca
funcionó.
</para>

<para>
Los UARTs 8250 y 16450 tenían un buffer simple de 1 byte. Esto significa que
un 16450 genera una interrupción por cada carácter transmitido o recibido.
Cada interrupción se procesa <?troff .ne 10> en un corto período de tiempo,
y esta pequeña demora limita a los 16450 a una velocidad de bits máxima
y fiable de 9.600 bps en una máquina de arquitectura ISA típica.
</para>

<para>
En su configuración por defecto, el núcleo comprueba los cuatro puertos
serie estándar, desde COM1: a COM4:. El núcleo también puede detectar
qué tipo de UART se emplea en cada uno de los puertos serie estándar,
y hará uso del búfer FIFO mejorado del 16550, si está disponible.
</para>

</sect1>

<sect1 id="X-087-2-serial-configuration"><title>Uso de las Utilidades de Configuración</title>
<para>
<indexterm id="idx-configuringserialport-1" class="startofrange"><primary>configuración</primary><secondary>puerto serie</secondary></indexterm>
</para>
<para>
Dediquemos algo de tiempo a examinar las dos utilidades más comunes:
<command>setserial</command> y <command>stty</command>.
</para>

<sect2 id="X-087-2-serial-setserial"><title>La orden setserial</title>
<indexterm><primary sortas="setserial">orden setserial</primary></indexterm>
<indexterm><primary sortas="Tso, Theodore">T'so, Theodore</primary></indexterm>
<para>
El núcleo hará su mayor esfuerzo en determinar cómo está configurado
su hardware serie, pero las diversas variantes en la configuración de
dispositivos serie hace difícil obtener una determinación fiable al
100%. Un buen ejemplo de este problema son los módems internos
que discutimos anteriormente. La UART que usan tiene un búfer
FIFO de 16 bytes, pero parece una UART 16450 para el núcleo:
a no ser que específicamente informemos al manejador que el puerto
es realmente un dispositivo 16550, el núcleo no hará uso del búfer
extendido. Otro ejemplo es el de las tarjetas de cuatro puertos sin
procesamiento que permiten compartir una misma IRQ entre un número
de dispositivos serie. Probablemente tengamos que especificarle al
núcleo qué IRQ se supone que usará el puerto, y que las IRQ pueden
estar compartidas.
</para>

<para>
<command>setserial</command> fue creado para configurar el manejador
serie en tiempo de ejecución. La orden <command>setserial</command>
se ejecuta por lo común al arrancar, desde un script llamado
<filename>0setserial</filename> en unas distribuciones, y
<filename>rc.serial</filename> en otras. Este script está al cargo de iniciar
adecuadamente el manejador de puerto serie para dar cabida a cualquier
hardware no estándar o inusual que haya en la máquina.
</para>

<para>
La sintaxis general para la orden <command>setserial</command> es:

<screen>
setserial <replaceable>dispositivo</replaceable> [<replaceable>parámetos</replaceable>]
</screen>
donde el dispositivo es uno de los dispositivos serie, como <emphasis>ttyS0</emphasis>.
</para>

<para>
La orden <command>setserial</command> tiene un gran número de
parámetros. Los más comunes vienen descritos en <xref
linkend="X-087-2-serial-setserial-parameters">. Para más información
sobre el resto de los parámetros, consulte la página de manual de
<command>setserial</command>.
</para>

<table id="X-087-2-serial-setserial-parameters">
<title>Parámetros de Línea de Órdenes de setserial</title>
<tgroup cols=2>
<colspec colnum="2" colwidth="9.0678cm"> 
<thead>
<row>
	<entry>Parámetro</entry>
	<entry>Descripción</entry>
</row>
</thead>
<tbody>
<row>
	<entry><literal>port</literal> <replaceable>número_puerto</replaceable></entry>
	<entry><para>
	Especifica la dirección de E/S del dispositivo serie. Los números de puerto
	deben ser especificados en notación hexadecimal, p.ej. <literal>0x2f8</literal>.
	</para></entry>
</row>
<row>
	<entry><literal>irq</literal> <replaceable>núm</replaceable></entry>
	<entry><para>
	Especifica la línea de petición de interrupción que emplea el dispositivo serie.
	</para></entry>
</row>
<row>
	<entry><literal>uart</literal> <replaceable>tipo_uart</replaceable></entry>
	<entry><para>
	Especifica el tipo de UART del dispositivo serie. Los valores más comunes son
	<literal>16450</literal>, <literal>16550</literal>, etc. Ajustar este valor a
	<literal>none</literal> desactivará el dispositivo serie.
</para></entry>
</row>
<row>
	<entry><literal>fourport</literal></entry>
	<entry><para>
	El uso de este parámetro informará al manejador de puertos serie del núcleo
	de que este puerto forma parte de una tarjeta AST Fourport.
</para></entry>
</row>
<row>
	<entry><literal>spd_hi</literal></entry>
	<entry><para>
	Programar la UART para emplear una velocidad de 57,6 kbps cuando
	un proceso solicita 38,4 kbps.
	</para></entry>
</row>
<row>
	<entry><literal>spd_vhi</literal></entry>
	<entry><para>
	Programar la UART para emplear una velocidad de 115 kbps cuando
	un proceso solicita 38,4 kbps.
	</para></entry>
</row>
<row>
	<entry><literal>spd_normal</literal></entry>
	<entry><para>
	Programar la UART para emplear la velocidad predefinida de 38,4
	kbps cuando se le solicite. Este parámetro sirve para deshacer el
	efecto de un <literal>spd_hi</literal> o <literal>spd_vhi</literal>
	aplicado en el dispositivo serie especificado.
	</para></entry>
</row>
<row>
	<entry><literal>auto_irq</literal></entry>
	<entry><para>
	Este parámetro provocará que el núcleo trate de determinar
	automáticamente la IRQ del dispositivo especificado. Este intento
	puede no ser fiable completamente, así que quizá sea mejor entenderlo
	como una solicitud al núcleo para que adivine la IRQ. Si conoce usted
	la IRQ del dispositivo, debe especificar que se use el parámetro
	<literal>irq</literal> en su lugar.
	</para></entry>
</row>
<row>
	<entry><literal>autoconfig</literal></entry>
	<entry><para>
	Este parámetro debe ser especificado simultáneamente con el
	parámetro <literal>port</literal>. Cuando se suministra este
	parámetro, <command>setserial</command> ordena al núcleo que
	intente determinar automáticamente el tipo de UART localizada en
	la dirección de puerto proporcionada. Si el parámetro
	<literal>auto_irq</literal> también es suministrado, el núcleo
	tratará también de determinar la IRQ automáticamente.
	</para></entry>
</row>
<row>
	<entry><literal>skip_test</literal></entry>
	<entry><para>
	Con este parámetro se solicita que el núcleo no se ocupe de determinar
	el tipo de UART en la auto-configuración. Esto es necesario cuando
	la UART es detectada de forma incorrecta por el núcleo.
	</para></entry>
</row>
</tbody>
</tgroup>
</table>

<para>
Un fichero <filename>rc</filename> típico y sencillo para configurar sus
puertos serie al arrancar puede parecerse a lo mostrado en
<xref linkend="X-087-2-serial-rc.serial.setserial">.
Una mayoría de distribuciones de GNU/Linux incluirán algo más sofisticado
que este ejemplo.
</para>

<example id="X-087-2-serial-rc.serial.setserial">
<title>Ejemplo de órdenes setserial en rc.serial</title>
<screen>
# /etc/rc.serial - script de configuración de líneas serie.
#
# Configurar dispositivos serie.
/sbin/setserial /dev/ttyS0 auto_irq skip_test autoconfig
/sbin/setserial /dev/ttyS1 auto_irq skip_test autoconfig
/sbin/setserial /dev/ttyS2 auto_irq skip_test autoconfig
/sbin/setserial /dev/ttyS3 auto_irq skip_test autoconfig
#
# Mostrar la configuración de dispositivos serie.
/sbin/setserial -bg /dev/ttyS*
</screen>
</example>


<para>
El argumento <literal>-bg /dev/ttyS*</literal> en la última orden
mostrará un pulcro sumario de la configuración hardware de todos
los dispositivos serie activos. Esta salida se parecerá a la mostrada en
<xref linkend="X-087-2-serial.setserial.output">.
</para>

<example id="X-087-2-serial.setserial.output">
<title>Salida de la orden setserial -bg /dev/ttyS*</title>
<screen>
/dev/ttyS0 at 0x03f8 (irq = 4) is a 16550A
/dev/ttyS1 at 0x02f8 (irq = 3) is a 16550A
</screen>
</example>

</sect2>

<sect2 id="x-087-2-serial-stty"><title>La Orden stty</title>
<para>
<indexterm><primary sortas="stty">orden stty</primary></indexterm>
<indexterm><primary>línea serie</primary><secondary>negociación hardware</secondary></indexterm>
<indexterm><primary>negociación, hardware</primary></indexterm>
<indexterm><primary>hardware</primary><secondary>negociación</secondary></indexterm></para>
<para>
El nombre <command>stty</command> probablemente signifique &ldquo;set tty,&rdquo;
pero la orden <command>stty</command> también puede ser empleada para
mostrar la configuración de un terminal. Quizás aún más que <command>setserial</command>,
la orden <command>stty</command> proporciona un desconcertante número
de características configurables. Cubriremos las más importantes en breve.
Puede usted encontrar descrito el resto en la página de manual de
<command>stty</command>.
</para>

<para>
La orden <command>stty</command> se utiliza principalmente para configurar
parámetros del terminal, tales como qué caracteres serán mostrados, o
qué tecla deberá generar una señal de parada. Explicamos anteriormente
que los dispositivos serie son dispositivos tty, y por tanto la orden
<command>stty</command> es igualmente aplicable a ellos.
</para>

<para>
Uno de los usos más importantes de <command>stty</command> para
dispositivos serie es habilitar la negociación por hardware en ellos.
Anteriormente describimos someramente la negociación por hardware.
La configuración por defecto en dispositivos serie es que esta
negociación hardware esté deshabilitada. Esta disposición permite
que los cables serie de &ldquo;tres hilos&rdquo; funcionen;
estos cables no aceptan las señales necesarias para la negociación por
hardware, y si estuviera activada por defecto, serían incapaces de
transmitir ningún carácter para desactivarla.
</para>

<para>
Sorprendentemente, algunos programas de comunicación serie no
habilitan la negociación por hardware, así que si su módem la permite,
deberá configurar el módem para emplearla (diríjase al manual de
su módem para averiguar qué orden usar), y también deberá configurar
el dispositivo serie para utilizar negociación por hardware. La orden
<command>stty</command> tiene una bandera <literal>crtscts</literal>
que habilita la negociación por hardware en un dispositivo; tendrá
que utilizar esto. El lugar más apropiado para ejecutar esta orden
probablemente sea el fichero <filename>rc.serial</filename> (o
equivalente) al arrancar, utilizando sentencias como las mostradas en
<xref linkend="X-087-2-serial-rc.serial.stty">.
</para>

<example id="X-087-2-serial-rc.serial.stty">
<title>Órdenes stty de Ejemplo en rc.serial</title>
<screen>
#
stty crtscts &lt; /dev/ttyS0
stty crtscts &lt; /dev/ttyS1
stty crtscts &lt; /dev/ttyS2
stty crtscts &lt; /dev/ttyS3
#
</screen>
</example>

<para>
La orden <command>stty</command> trabaja en el terminal en uso de
forma predefinida, pero mediante la redirección de entrada (&ldquo;&lt;&rdquo;)
facilitada por el intérprete de órdenes, podemos hacer que
<command>stty</command> maneje cualquier dispositivo tty. Es un
error común olvidar si se ha de emplear &ldquo;&lt;&rdquo; o &ldquo;&gt;&rdquo;;
las versiones más modernas de <command>stty</command> tienen una
sintaxis más clara de especificarlo. Con esta nueva sintaxis, nuestro ejemplo
quedaría como en <xref linkend="X-087-2-serial-rc.serial.stty.new">.
</para>

<example id="X-087-2-serial-rc.serial.stty.new">
<title>Órdenes stty de Ejemplo en rc.serial Empleando Sintaxis Moderna</title>
<screen>
#
stty crtscts -F /dev/ttyS0
stty crtscts -F /dev/ttyS1
stty crtscts -F /dev/ttyS2
stty crtscts -F /dev/ttyS3
#
</screen>
</example>

<para>
Antes mencionamos que la orden <command>stty</command> puede ser
usada para mostrar los parámetros de configuración de un dispositivo
tty. Para mostrar todos los parámetros activos de un dispositivo tty se hace:
</para>

<para>
<screen>
$ <userinput>stty -a -F /dev/ttyS1</userinput>
</screen>
</para>

<para>
La salida de esta orden, mostrada en <xref linkend="X-087-2-serial.stty.output">,
le muestra el estado de todas las banderas para ese dispositivo;
una bandera precedida por un signo menos, como en <option>&ndash;crtscts</option>,
significa que la bandera ha sido desactivada.
</para>

<example id="X-087-2-serial.stty.output">
<title>Salida de una Orden stty -a</title>
<screen>
speed 19200 baud; rows 0; columns 0; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef>;
         eol2 = &lt;undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R;
         werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
-parenb -parodd cs8 hupcl -cstopb cread clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr -icrnl -ixon
        -ixoff -iuclc -ixany -imaxbel
-opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0
         bs0 vt0 ff0
-isig -icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop
         -echoprt echoctl echoke
</screen>
</example>

<para>
Una descripción de las banderas más importantes se da en <xref
linkend="X-087-2-serial.stty.flags">. Cada una de ellas se habilita suministrándola
a <command>stty</command>, y se deshabilita de la misma forma, pero
precedida por un carácter &ndash; delante. Así, para deshabilitar la
negociación hardware, se haría:
<screen>
$ <userinput>stty -crtscts -F /dev/ttyS0</userinput>
</screen>
</para>

<table id="X-087-2-serial.stty.flags">
<title>Banderas de stty Más Relevantes Para Configurar Dispositivos Serie</title>
<tgroup cols=2><colspec colnum="2" colwidth="9.0678cm">
<thead>
<row>
	<entry>Bandera</entry>
	<entry>Descripción</entry>
</row>
</thead>
<tbody>
<row>
	<entry><literal>N</literal></entry>
	<entry><para>
	Ajustar la velocidad de línea a <literal>N</literal> bits por segundo.
	</para></entry
</row>
<row>
	<entry><literal>crtsdts</literal></entry>
	<entry><para>
	Habilitar/Deshabilitar negociación por hardware.
	</para></entry>
</row>
<row>
	<entry><literal>ixon</literal></entry>
	<entry><para>
	Habilitar/Deshabilitar control de flujo mediante XON/XOFF.
	</para></entry>
</row>
<row>
	<entry><literal>clocal</literal></entry>
	<entry><para>
	Habilitar/Deshabilitar señales de control del módem como DTR/DTS y
	DCD. Esto es necesario si se usa cable serie de &ldquo;tres hilos&rdquo;
	ya que no proporciona estas señales.
	</para></entry>
</row>
<row>
	<entry><literal>cs5 cs6 cs7 cs8</literal></entry>
	<entry><para>
	Ajustar el número de bits de datos a 5, 6, 7 u 8, respectivamente.
	</para></entry>
</row>
<row>
	<entry><literal>parodd</literal></entry>
	<entry><para>
	Habilitar paridad impar. Desactivar esta bandera activa la paridad par.
	</para></entry>
</row>
<row>
	<entry><literal>parenb</literal></entry>
	<entry><para>
	Habilitar comprobación de paridad. Si esta bandera se niega, no se
	utiliza paridad.
	</para></entry>
</row>
<row>
	<entry><literal>cstopb</literal></entry>
	<entry><para>
	Ajustar los bits de parada a dos por carácter. Al negar esta
	bandera, se usará sólo un bit de parada por carácter.
	</para></entry>
</row>
<row>
	<entry><literal>echo</literal></entry>
	<entry><para>
	Habilitar/Deshabilitar el eco de caracteres recibidos al que los envía.
	</para></entry>
</row>
</tbody>
</tgroup>
</table>

<para>
El siguiente ejemplo combina algunas de estas banderas y configura
el dispositivo <filename>ttyS0</filename> a 19.200 bps, 8 bits de
datos, sin paridad, con negociación por hardware y eco deshabilitado:

<screen>
$ <userinput>stty 19200 cs8 -parenb crtscts -echo -F /dev/ttyS0</userinput>
</screen>

</para>

<para>
<indexterm class="endofrange" startref="idx-configuringserialport-1">
</para>
</sect2>
</sect1>

<sect1 id="X-087-2-serial.getty"><title>Dispositivos Serie y el Indicador login: (ingreso)</title>
<para>
Llegó a ser muy común que una instalación basada en Unix incluyera
una máquina servidor y muchos terminales &ldquo;tontos&rdquo; (sin
procesamiento) de caracteres o módems para acceso telefónico. Hoy
en día este tipo de configuraciones son menos comunes, lo que
supone una buena noticia para mucha gente interesada en trabajar
así, ya que estos terminales sin procesamiento son muy baratos
actualmente. Las configuraciones con módems de acceso telefónico
no han dejado de ser comunes, pero en estos tiempos probablemente
se utilicen como soporte para ingresos mediante SLIP o PPP (temas
tratados en <xref linkend="X-087-2-slip"> y <xref
linkend="X-087-2-ppp">&thinsp;) más que para un simple ingreso.
En cualquier caso, cada uno de estos métodos puede hacer uso
de un programa sencillo llamado programa <command>getty</command>.
</para>

<para>
El término <command>getty</command> es probablemente una abreviatura
de &ldquo;get tty&rdquo; (conseguir tty). Un programa
<command>getty</command> abre un dispositivo serie, lo configura
apropiadamente, configura opcionalmente un módem, y espera a que
se realice una conexión. Una conexión activa en un dispositivo serie se indica
normalmente mediante la patilla Data Carrier Detect (DCD) en el dispositivo
serie que ha sido activado. Cuando se produce esta detección,
el programa <command>getty</command> llama a un programa que
muestra el punto indicativo <literal>login:</literal>, y es el que maneja
realmente el ingreso al sistema. Cada uno de los terminales virtuales (por
ejemplo, <filename>/dev/tty1</filename>) en GNU/Linux tiene un
<command>getty</command> ejecutándose para él.
</para>

<para>
Hay varias implementaciones distintas de <command>getty</command>,
cada una diseñada para adaptarse a ciertas configuraciones mejor que
a otras. El <command>getty</command> que describiremos aquí
se llama <command>mgetty</command>. Es bastante conocido porque
proporciona todo tipo de características que lo hacen especialmente
indicado para uso con módems, aceptando incluso programas automáticos
para fax y módems de voz. Nos concentraremos en configurar
<command>mgetty</command> para responder a las llamadas
convencionales de datos, y dejaremos el resto para que explore usted
en función de sus necesidades.
</para>

<sect2 id="X-087-2-serial.getty.mgetty"><title>Configuración del Demonio mgetty</title>
<para>
El demonio <command>mgetty</command> está disponible en forma de
código fuente en <systemitem role="url">ftp://alpha.greenie.net/pub/mgetty/source/</systemitem>,
y prácticamente todas las distribuciones de GNU/Linux lo incluyen como paquete.
El demonio <command>mgetty</command> se diferencia de la mayoría
de las implementaciones de programas <command>getty</command> en
que ha sido diseñado específicamente para módems compatibles con
Hayes. Admite aún conexiones directas de terminales, pero se adapta
de forma especialmente buena a aplicaciones de llamadas telefónicas.
En lugar de emplear la señal DCD para detectar una llamada entrante,
espera a la escucha del mensaje <literal>RING</literal> generado
por la mayoría de módems modernos cuando detectan una llamada entrante
y no están configurados para responder automáticamente.
</para>

<para>
El ejecutable principal es <filename>/usr/sbin/mgetty</filename>,
y su fichero de configuración se llama
<filename>/etc/mgetty/mgetty.config</filename>. Hay otros
programas y ficheros de configuración que cubrirán otros rasgos
concretos de <command>mgetty</command>.
</para>

<para>
La configuración, en gran parte de los sistemas, es cuestión únicamente
de editar el fichero <filename>/etc/mgetty/ mgetty.config</filename>
y añadir las entradas apropiadas a <filename>/etc/inittab</filename>
para que <command>mgetty</command> se ejecute automáticamente.
</para>

<para>
<xref linkend="X-087-2-serial.mgetty.conf"> muestra un fichero
muy simple de configuración de <command>mgetty</command>.
Este ejemplo configura dos dispositivos serie. El primero,
<filename>/dev/ttyS0</filename>, se refiere a un módem
compatible con Hayes a 38.400 bps. El segundo,
<filename>/dev/ttyS1</filename>, se corresponde con un terminal
VT100 conectado directamente, a 19.200 bps.
</para>

<para>
<example id="X-087-2-serial.mgetty.conf">
<title>Fichero /etc/mgetty/mgetty.config de ejemplo</title>
<screen>
#
# fichero de configuración de mgetty
#
# este es un fichero de ejemplo de configuración, vea mgetty.info para obtener detalles
#
# las líneas de comentario  comienzan con "#", las líneas vacías son deshechadas
#
# ----- sección global -----
#
# En esta sección van los valores globales por defecto, la configuración por puertos va debajo
#
# acceder al módem (o módems) a 38400 bps
speed 38400
#
# ajustar el nivel global de depuración a "4" (valor por defecto de policy.h)
debug 4
#

# ----- sección específica de puerto -----
#
# Aquí se pondran las cosas que sean válidas sólo para una línea, no las demás
#
#
# Módem Hayes conectado a ttyS0: no usar como fax, menos registro de actividad
#
port ttyS0
  debug 3
  data-only y
#
# conexión directa de un terminal VT100 que no gusta de bajadas en la señal DTR
#
port ttyS1
  direct y
  speed 19200
  toggle-dtr n
#
</screen>
</example>
</para>

<para>
El fichero de configuración acepta opciones globales y específicas de cada puerto.
En nuesto ejemplo, empleamos una opción global para fijar la velocidad a
38.400 bps. Este valor es heredado por el puerto <filename>ttyS0</filename>.
Los puertos a los que aplicamos <command>mgetty</command> emplean
este ajuste de velocidad a no ser que sea reemplazado por un ajuste de
velocidad explícito para el puerto, tal y como hemos hecho en la configuración
de <filename>ttyS1</filename>.
</para>

<para>
La palabra clave <literal>debug</literal> controla la cantidad de texto
del registro de actividad de <command>mgetty</command>. La palabra
clave <literal>data-only</literal> en la configuración de
<filename>ttyS0</filename> hace que <command>mgetty</command>
desprecie las características de fax del módem, para que funcione
únicamente como módem de datos. La palabra <literal>direct</literal>
en la configuración de <filename>ttyS1</filename> avisa a
<command>mgetty</command> para que no lleve a cabo ninguna
inicialización para módem en ese puerto. Finalmente, con
<literal>toggle-dtr</literal> se consigue que
<command>mgetty</command> no trate de colgar la línea
bajando la patilla DTR (Data Terminal Ready) en el interfaz serie;
algunos terminales no reaccionan bien ante esto.
</para>

<para>
También puede usted elegir dejar vacío el fichero
<filename>mgetty.config</filename> y emplear argumentos en la
línea de órdenes para especificar la mayoría de esos mismos
parámetros. La documentación que acompaña a la aplicación
incluye una completa descripción de los parámetros
del fichero de configuración de <command>mgetty</command>
y los argumentos de línea de órdenes. Observe el siguiente ejemplo.
</para>

<para>
Hemos de añadir dos entradas al fichero <filename>/etc/inittab</filename>
para activar esta configuración. El fichero <filename>inittab</filename>
es el fichero de configuración de la orden <command>init</command>
de Unix System V. Esta orden es la encargada de la iniciación
del sistema; proporciona un medio para ejecutar programas
automáticamente al iniciar la máquina y volver a ejecutarlos
cuando terminan. Es muy apropiada para los objetivos de ejecutar
un programa <command>getty</command>.
</para>

<para>
<screen>
T0:23:respawn:/sbin/mgetty ttyS0
T1:23:respawn:/sbin/mgetty ttyS1
</screen>
</para>

<para>
Cada línea del fichero <filename>/etc/inittab</filename> contiene
cuatro campos, separados por dos puntos. El primero es un identificador
que etiqueta de forma única cada entrada del fichero; tradicionalmente
se utilizan dos caracteres, pero las versiones más modernas permiten
cuatro. El segundo campo es la lista de niveles de ejecución en los
que deberá estar activa. Un nivel de ejecución es un mecanismo para
proporcionar distintas configuraciones del equipo y se implementa
mediante el uso de árboles de scripts de inicio, almacenados en
directorios llamados <filename>/etc/rc1.d</filename>,
<filename>/etc/rc2.d</filename>, etc. Esta característica
es implementada típicamente de forma muy simple, por lo
que usted debe modelar sus entradas en el fichero basándose en
otras del mismo, o bien consultar la documentacion de su
sistema para obtener más información. El tercer campo describe
cuándo hay que llevar a cabo la acción. Para los propósitos de
ejecutar un programa <command>getty</command>, este campo
debe ser ajustado a <literal>respawn</literal>, lo que significa que
la orden se re-ejecutará automáticamente cuando muera. Hay
otras opciones también, pero no son útiles para nuestros propósitos
aquí. El cuarto campo es la orden real que ha de ejecutarse; aquí
es donde especificamos la orden <command>mgetty</command>
y cualquier argumento que queramos pasarle. En nuestro ejemplo simple,
ejecutamos y reiniciamos <command>mgetty</command> siempre que
el sistema está operando en los niveles de ejecución dos o tres, y le
suministramos como argumento el nombre del dispositivo que queremos
utilizar. La orden <command>mgetty</command> asume
<filename>/dev/</filename>, así que no hemos de proporcionarlo.
</para>

<para>
Este capítulo ha sido una introducción rápida a <command>mgetty</command>
y cómo ofrecer un punto identificativo de ingreso al sistema en
dispositivos serie. Podrá encontrar información más extensiva en el
Serial-HOWTO.
</para>

<para>
Una vez que haya editado los ficheros de configuración ha de
recargar <command>init</command> para hacer efectivos los cambios.
Simplemente envíe una señal hangup al proceso <command>init</command>;
siempre tiene un identificador de proceso 1, así que puede usar sin
problemas:
</para>

<screen>
# <userinput>kill -HUP 1</userinput>
</screen>

</sect2>

<indexterm class="endofrange" startref="ch04.serdev.setup">
<indexterm class="endofrange" startref="idx-tty-1">
<indexterm class="endofrange" startref="idx-deviceserial-1">
<indexterm class="endofrange" startref="idx-hardwareserial-1">

</sect1>
</chapter>
