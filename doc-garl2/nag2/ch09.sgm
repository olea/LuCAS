<!-- $Id: ch09.sgm,v 1.17 2002/09/28 02:41:18 pakojavi2000 Exp $ -->
<!--
Nota legal:

   Linux Network Administration Guide, por Olaf Kirch et al.

   La traducción al español se publica bajo la licencia GFDL,
siendo texto de portada el siguiente:

Linux Network Administrator's Guide
by Olaf Kirch and Terry Dawson
Copyright  (c) 1993 Olaf Kirch
Copyright  (c) 2000 Terry Dawson
Copyright on O'Reilly printed version (c) 2000 O'Reilly & Associates

y siendo secciones invariantes, la sección de Agradecimientos,
la sección titulada «La traducción al español», el apéndice C; así
como esta nota.

Capítulo traducido por:

  Domingo Sánchez, domingo@toboso.fis.ucm.es
Revisión 1 por Francisco Javier Fernández Serrador@arrakis.es
-->
<chapter id="X-087-2-firewall"><title>Cortafuegos de TCP/IP</title>
<indexterm id="chfw.tcp.ip.firewall" class="startofrange"><primary>TCP/IP (Protocolo de control de tranmisión/Protocolo de internet)</primary><secondary>cortafuegos</secondary></indexterm>
<INDEXTERM id="chfw.firewalls.tcp.ip" class=startofrange><PRIMARY>cortafuegos</PRIMARY><SECONDARY>TCP/IP</SECONDARY></INDEXTERM>
<para>
<indexterm><primary>cortafuegos</primary><secondary>seguridad</secondary></indexterm>
<indexterm><primary>seguridad</primary><secondary>red</secondary></indexterm>
<indexterm><primary>seguridad</primary><secondary>cortafuegos</secondary></indexterm>
La seguridad resulta cada vez más importante tanto para las
compañías como para los individuos. Intenet les ha proporcionado una poderosa 
herramienta para distribuir información entre ellos y para obtener información de 
otros, pero también les ha expuesto a peligros de los que habían estado exentos 
hasta entonces. La criminalidad informática, el robo de información y el daño 
malintencionado constituyen peligros potenciales.
</para>

<para>
Una persona no autorizada y sin escrúpulos que consiga el acceso al sistema 
de una computadora puede que averigüe contraseñas del sistema o
que se aproveche de los errores y del comportamiento particular
de ciertos programas para obtener una cuenta funcional en dicha máquina. Una
vez que sea capaz de entrar en la máquina, puede que tenga acceso a información
que podría resultar dañina, información tan sensible comercialmente
como los planes de negocio, detalles de nuevos proyectos o las bases de datos
con información de los clientes. Un daño a este tipo de datos o su modificación
puede causar severos retrasos a la compañía.
</para>

<para>
La forma más segura de evitar daños de tanto alcance consiste en impedir
que las personas no autorizadas puedan obtener el acceso a la máquina.
Aquí es donde intervienen los cortafuegos
<footnote id="X-087-2-FW-TFN01">
<para> N. del T.: 'firewalls' en el original en inglés
</para>
</footnote>.
</para>

<warning><para>
<indexterm><primary>cortafuegos</primary><secondary>aviso</secondary></indexterm>
La construcción de cortafuegos seguros es todo un arte. Involucra un entendimiento
bueno de la tecnología, y no menos importante, requiere de un entendiemiento
de la filosofía que hay detrás del diseño de un cortafuegos. En este libro no se cubrirá
todo lo que usted necesita; se le recomienda vivamente que realice alguna
investigación adicional antes de confiar en un diseño concreto de cortafuegos,
lo que incluye cualquiera que se presente aquí.
</para></warning>

<para>
Existe bastante material sobre configuración y diseño de cortafuegos
como para llenar un libro entero, y, por supuesto, ya hay algunos buenos
recursos que le podría gustar consultar para incrementar su conocimiento
en la materia. Dos de estos recursos son:
<?troff .Nd 10>
<variablelist>
<varlistentry>
<term><emphasis>'Building Internet Firewalls'</emphasis></term>
<listitem><para>
de D. Chapman y E. Zwicky (O'Reilly). Una guía que explica cómo
diseñar e instalar cortafuegos para Unix, Linux y Windows NT,
y cómo configurar servicios de Internet en coordinación con
los cortafuegos.
</para></listitem>
</varlistentry>

<varlistentry>
<term><emphasis>'Firewalls and Internet Security'</emphasis></term>
<listitem><para>
de W. Cheswick y S. Bellovin (Addison Wesley). Este libro cubre la filosofía
del diseño e implementación de un cortafuegos.
</para></listitem>
</varlistentry>
</variablelist>
</para>

<para>
Este capítulo se centrará en aspectos técnicos específicos de Linux. Más
adelante se presentará un ejemplo de configuración del cortafuegos que
debería servir como punto de partida para su propia configuración, pero,
como con todos los asuntos relacionados con la seguridad, no confíe en nadie.
Vuelva a comprobar otra vez el diseño, asegúrese de que lo entiende y entonces
modifíquelo para ajustarlo a sus requerimientos. Para estar a salvo, esté
seguro.
</para>

<sect1 id="x-082-2-firewall.attacks"><title>Métodos de ataque</title>
<para>
<indexterm><primary>cortafuegos</primary><secondary>métodos de ataque</secondary></indexterm>
<indexterm><primary>seguridad</primary><secondary>métodos de ataque</secondary></indexterm>
Como administrador de una red, es importante que usted entienda la naturaleza
de los posibles ataques a la seguridad informática. Se describirán brevemente
los tipos de ataques más importantes para que usted pueda comprender mejor y de forma
más precisa de qué le protegerá un cortafuegos sobre Linux. Debería realizar
alguna lectura adicional para asegurarse de que está capacitado para proteger
su red de otros tipos de ataques. Aquí están algunos de los más importantes métodos
de ataque y las maneras de protegerse contra ellos:
</para>


<variablelist>
<varlistentry><term>Acceso no autorizado</term>
<listitem><para>
Esto simplemente quiere decir que personas que no deberían utilizar los
servicios de su computadora son capaces de conectarse y utilizarlos.
Por ejemplo, personas de fuera de su compañía podrían intentar conectarse
a la máquina con las cuentas de su compañía o a su servidor de NFS.
</para>
<para>
Existen varias formas de evitar este ataque especificando con cuidado
quién puede tener acceso a estos servicios. Usted puede evitar el acceso
a la red a todo el mundo excepto a los usuarios deseados.
</para></listitem>
</varlistentry>

<varlistentry><term>Aprovechamiento de las debilidades conocidas de un programa</term>
<listitem><para>
Algunos programas y servicios de red no fueron diseñados originalmente
teniendo en cuenta una elevada seguridad y son inherentemente vulnerables
a los ataques. Los servicios remotos del tipo BSD (rlogin, rexec, etc) constituyen
un ejemplo.
</para>
<para>
La mejor manera de protegerse contra este tipo de ataque consiste en
deshabilitar los servicios vulnerables o en encontrar alternativas.
Con 'software' de código abierto resulta muchas veces posible reparar
sus debilidades.
</para></listitem>
</varlistentry>

<varlistentry><term>Denegación de servicio</term>
<listitem><para>
<INDEXTERM><PRIMARY>ataques de denegación de servicio</PRIMARY></INDEXTERM>
Los ataques de denegación de servicio causan que el servicio o programa deje
de funcionar o impide que otros hagan uso de ese servicio o programa.
Estos ataques pueden ser realizados al nivel de red enviando datagramas
cuidadosamente preparados y malintencionados de tal forma que
puedan causar que las conexiones de red fallen. También pueden realizarse
a nivel de aplicación, donde órdenes cuidadosamente construidas se
envían contra un programa para tratar que se vuelva muy ocupado
o que pare su funcionamiento.
</para>
<para>
Impedir que el tráfico de red sospechoso alcance sus máquinas y que lleguen
órdenes y peticiones de programa sospechosos son las mejores formas de
minimizar el riesgo de un ataque de denegación de servicio. Resulta muy
útil conocer los detalles del método de ataque, por lo que debería
aprender usted mismo todo lo posible de cada tipo nuevo de ataque que se haga público.
</para></listitem>
</varlistentry>

<varlistentry><term>Suplantación de identidad
<footnote id="X-087-2-FW-TFN02">
<para> N. del T.: 'spoofing' en el original en inglés
</para>
</footnote>
</term>
<listitem><para>
<INDEXTERM><PRIMARY>spoofing</PRIMARY><SECONDARY>ataques</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>suplantación de identidad</PRIMARY><SECONDARY>ataques</SECONDARY></INDEXTERM>
Este tipo de ataque causa que un 'host' o aplicación simule las
acciones de otro. Típicamente, el atacante se hace pasar por un
'host' inocente siguiendo el rastro de las direcciones IP contenidas
en los paquetes de red. Por ejemplo, un 'exploit'
<footnote id="X-087-2-FW-TFN03">
<para> N. del T.: "método de aprovechamiento de una debilidad o vulnerabilidad"
</para>
</footnote>
bien documentado del servicio de tipo BSD rlogin puede utilizar esta técnica para
simular una conexión de TCP desde otro 'host' prediciendo los números
de secuencia de TCP.
</para>
<para>
Para protegerse contra este tipo de ataque, verifique la autenticidad de
los datagramas y órdenes. Evite el encaminamiento de datagramas con
direcciones de origen no válidas. Introduzca impredicibilidad en los
mecanismos de control de la conexión, como los números de secuencia
de TCP y la asignación dinámica de puertos.
</para></listitem>
</varlistentry>

<varlistentry><term>'Eavesdropping'
<footnote id="X-087-2-FW-TFN04">
<para> N. del T.: "fisgoneo"
</para>
</footnote>
</term>
<listitem><para>
<INDEXTERM><PRIMARY>programas de fisgoneo</PRIMARY></INDEXTERM>
Éste es el método de ataque más simple. Un 'host' se configura para
"escuchar" y capturar los datos no destinados a él. Programas de
fisgoneo cuidadosamente escritos pueden obtener
los nombres de usuario y sus contraseñas a partir de las conexiones
de red con ingresos de usuarios en el sistema. Redes de difusión como las de
tipo Ethernet son especialmente vulnerables a este tipo de ataques.
</para>
<para>
Para protegerse contra este tipo de amenazas, evite el uso de
tecnologías de red con difusiones e imponga el uso de 
encriptación de los datos.
</para></listitem>
</varlistentry>
</variablelist>

<para>
Los cortafueros de IP resultan muy útiles para evitar o reducir los
accesos no autorizados, los ataques de denegación de servicio a nivel 
de red, y los ataques de suplantación de identidad. No resultan muy útiles
para evitar el aprovechamiento de las debilidades de los servicios de
red o programas ni el ['eavesdropping'].
</para>

</sect1>

<sect1 id="X-087-2-firewall.introduction"><title>¿Qué es un cortafuegos?</title>
<para>
<indexterm><primary>cortafuegos</primary></indexterm>
Un cortafuegos es una máquina segura y confiable que se asienta entre
una red privada y una red pública.<footnote id="X-087-2-FW-FN01"><para> El
término <emphasis>cortafuegos</emphasis> (N. del T.: 'firewall' en inglés)
proviene de un aparato utilizado para proteger a las personas del fuego. 
El cortafuegos es un escudo de material resistente al fuego que se coloca 
entre un fuego potencial y las personas que protege.
</para>
</footnote>
La máquina cortafuegos se configura con un conjunto de reglas que
determinan a qué tráfico de red se le permitirá pasar y cuál será
bloqueado o rechazado. En algunas organizaciones grandes, puede
que encuentre un cortafuegos localizado dentro de la red corporativa
para separar áreas sensibles de la organización de otros empleados.
Algunos casos de criminalidad informática acontecen dentro de la misma
organización, no sólo provienen de fuera.
</para>

<para>
Se pueden construir cortafuegos en una variedad de maneras. La
configuración más sofisticada involucra un número de máquinas
separadas y se conoce como <emphasis>red perimetral</emphasis>
<footnote id="X-087-2-FW-TFN05">
<para> N. del T.: 'perimeter network' en el original en inglés
</para>
</footnote>. Dos máquinas, denominadas estranguladoras
<footnote id="X-087-2-FW-TFN06">
<para> N. del T.: 'chokes' en el original en inglés
</para>
</footnote>
actúan como "filtros" para permitir pasar sólo ciertos tipos de 
tráfico de red, y entre estos estranguladores residen servidores
de red como una pasarela de correo o un servidor intermediario
<footnote id="X-087-2-FW-TFN07">
<para> N. del T.: 'proxy' en el original en inglés
</para>
</footnote> de 'World Wide Web'. Esta configuracón puede resultar muy
segura y permite de forma fácil un amplio rango de control sobre quién
puede conectarse tanto desde dentro hacia fuera cómo desde fuera hacia
dentro. Este tipo de configuración debería ser el utilizado por las grandes
organizaciones.
</para>

<para>
Sin embargo, típicamente los cortafuegos son máquinas únicas que
sirven todas estas funciones. Esto es algo menos seguro, porque si
hay alguna debilidad en la propia máquina del cortafuegos que le permita
a alguien conseguir el acceso al mismo cortafuegos, la seguridad de toda la red
habrá sido comprometida. Sin embargo, estos tipos de cortafuegos son
más baratos y fáciles de mantener que la configuración más sofistificada
descrita arriba. La
<xref linkend="X-087-2-firewall.design.graphic"> ilustra los dos tipos
más comunes de configuración de cortafuegos.</para>

<figure id="X-087-2-firewall.design.graphic" float=1>
<title>Las dos clases más importantes de diseño de cortafuegos</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0901" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0901.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<para>
El núcleo de GNU/Linux proporciona un rango de características internas
que le permiten funcionar bastante bien como un cortafuegos de IP.
La implementación de red incluye código para realizar filtros a nivel
de IP en numerosas formas, y proporciona un mecanismo para configurar
con precisión qué tipos de reglas le gustaría imponer. El cortafuegos
en GNU/Linux es suficientemente flexible como para convertirle en algo
muy útil en cualquiera de las configuraciones ilustradas en la
<xref linkend="X-087-2-firewall.design.graphic">. El 'software'
de cortafuegos de Linux proporciona otras dos características
muy útiles que se discutirán en capítulos por separado:
auditoría de IP (<xref
linkend="X-087-2-accounting">) y enmascaramiento de IP (<xref
linkend="X-087-2-ipmasq">).
</para>
</sect1>

<sect1 id="X-087-2-firewall.filtering"><title>¿Qué es el filtrado de IP?</title>
<para>
<indexterm><primary>filtrado</primary><secondary>IP</secondary></indexterm>
<indexterm><primary>IP (protocolo de internet)</primary><secondary>filtrado</secondary></indexterm>
<indexterm><primary>seguridad</primary><secondary>filtrado</secondary></indexterm>
<INDEXTERM><PRIMARY>datagramas</PRIMARY><SECONDARY>filtrado de IP</SECONDARY></INDEXTERM>
El filtrado de IP es simplemente un mecanismo que decide qué tipos de
datagramas de IP serán procesados normalmente y cuáles serán descartados.
Por <emphasis>descartados</emphasis> se entiende que el datagrama
se elimina y se ignora completamente, como si nunca se hubiera recibido.
Usted puede aplicar muchos criterios , y en diferentes ordenamientos,
para determinar qué datagramas desea filtrar; algunos ejemplos de ésto son:

<itemizedlist>
<listitem><para>
Tipo de protocolo: TCP, UDP, ICMP, etc.
</para></listitem>
<listitem><para>
Número de conector
<footnote id="X-087-2-FW-TFN08">
<para> N. del T.: 'socket' en el original en inglés
</para>
</footnote> (para TCP/UDP)
</para></listitem>
<listitem><para>
Tipo de datagrama: SYN/ACK, datos, petición de eco de ICMP, etc.
</para></listitem>
<listitem><para>
Dirección de origen del datagrama: de donde proviene
</para></listitem>
<listitem><para>
Dirección de destino del datagrama: a donde se dirige
</para></listitem>
</itemizedlist>

</para>

<para>
Llegado este punto, resulta muy importante comprender que el filtrado
de IP es una utilidad en la capa de red. Esto significa que este
mecanismo no entiende nada acerca de la aplicación que utiliza las
conexiones de red, sólo sabe acerca de las conexiones mismas. Por
ejemplo, usted puede denegar el acceso a usuarios a su red interna
por el puerto predeterminado de telnet, pero si se apoya únicamente
en el filtrado de IP, no podrá evitar que se utilice el programa de
telnet en un puerto por el que usted permite el paso a través de
su cortafuegos. Puede evitar este tipo de problemas haciendo uso
de servidores intermediarios para cada servicio que
permita que cruce su cortafuegos. Los servidores intermediarios comprenden
la aplicación para la que fueron diseñados y por tanto evitan los
abusos, tales como utilizar el programa de telnet para pasar a
través de un cortafuegos utilizando el puerto de 'World Wide Web'.
Si su cortafuegos soporta un servidor intermediario de 'World Wide Web',
aquella conexión de telnet será siempre respondida por el servidor
intermediario que sólo permitará que pasen peticiones HTTP. Existe
un gran número de programas servidores intermediarios. Algunos son
software libre y muchos otros son productos comerciales. El
documento 'Firewall-HOWTO' 
<footnote id="X-087-2-FW-TFN09"><para>N. del T.:
existe una traducción oficial al castellano con el nombre de 
"Cortafuegos-Como".
</para>
</footnote>
expone un subconjunto popular de aquellos,
pero esto queda fuera del alcance de este libro.
</para>

<para>
El conjunto de reglas de filtrado de IP se construye a partir
de muchas combinaciones de los criterios enumerados previamente. Por
ejemplo, imagínese que usted quiere que los usuarios
del 'World Wide Web' dentro de la red de la Cervecera Virtual no
tengan acceso a ningún servicio de Internet excepto a los servidores web.
Entonces configuraría su cortafuegos permitiendo el reenvío de:

<itemizedlist>
<listitem><para>
datagramas con una dirección de origen dentro de la red de la Cervecera Virtual,
una dirección de destino cualquiera y con un puerto de destino igual a 80 (el
de WWW)
</para></listitem>

<listitem><para>
datagramas con dirección de destino dentro de la red de la Cervecera Virtual
y un puerto de origen igual a 80 (WWW) siendo cualquiera la dirección
de origen
</para></listitem>
</itemizedlist>
</para>

<para>
Nótese que se han utilizado dos reglas aquí. Se tiene que permitir que
nuestros datos salgan fuera, pero también que la correspondiente respuesta
vuelva. En la práctica, como se verá en breve, Linux simplifica esto y nos
permite especificar lo mismo en una sola orden.
</para>
</sect1>

<sect1 id="X-087-2-firewall.howto"><title>Configuración de Linux como cortafuegos</title>
<para>
<INDEXTERM id="kernel.config.ipfirewall" class=startofrange><PRIMARY>núcleos</PRIMARY><SECONDARY>configuración con cortafuegos de IP</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>configuración</PRIMARY><SECONDARY>núcleo</SECONDARY><TERTIARY SORTAS="cortafuegos de IP">con cortafuegos de IP</TERTIARY></INDEXTERM>
Para poder construir un cortafuegos IP con Linux, es necesario disponer
de un núcleo compilado con soporte de cortafuegos de IP y de la utilidad
de configuración adecuada. En todos los núcleos  anteriores a la serie
2.2 se usaba la utilidad
<command>ipfwadm</command>. 
Los núcleos 2.2.x supusieron el lanzamiento de la tercera generación
de cortafuegos de IP para Linux que se denominó 
<emphasis>'IP Chains'</emphasis>. 'IP chains'
utiliza un programa similar a
<command>ipfwadm</command> que se llama <command>ipchains</command>. 
Los núcleos de Linux 2.3.15 y siguientes soportan la cuarta generación
de cortafuegos de IP de Linux que se denomina
<emphasis>netfilter</emphasis>. El código de
<emphasis>netfilter</emphasis>  es el resultado de un gran rediseño del
flujo en el manejo de paquetes en Linux.
<emphasis>Netfilter</emphasis> es una criatura con múltiples
caras, pues proporciona un soporte compatible hacia atrás
tanto con
<command>ipfwadm</command> como con
<command>ipchains</command> además de una nueva orden alternativa que se
llama <command>iptables</command>. En las próximas secciones
se hablará de las diferencias entre los tres.
</para>

<sect2 id="X-087-2-firewall.howto.kernel"><title>Núcleo configurado con cortafuegos de IP</title>
<para>
El núcleo de Linux debe configurarse para que dé soporte a las  funciones de
cortafuegos de IP. Sólo hay que seleccionar las opciones
adecuadas cuando se realiza un
<literal>make menuconfig</literal> del núcleo.
<footnote id="X-087-2-FW-FN02"><para>'firewall packet logging'
(N. del T.: "registro de paquetes del
cortafuegos" en español)
es una característica especial que permite escribir una línea
de información en un dispositivo especial y visible para usted
por cada datagrama que coincida con un regla del cortafuegos. 
</para>
</footnote>
En el
<xref linkend="X-087-2-hardware"> se describe cómo hacerlo.
En los núcleos 2.2, las siguientes opciones deberían ser seleccionadas:

<screen width=80>
Networking options  --->
	[*] Network firewalls
	[*] TCP/IP networking
	[*] IP: firewalling
	[*] IP: firewall packet logging
</screen>
</para>

<para>
En cambio, en los núcleos 2.4.0 y posteriores se deberían seleccionar
estas opciones:

<screen width=80>
  Networking options  --->
     [*] Network packet filtering (replaces ipchains)
         IP: Netfilter Configuration  ---&gt;
              .
             &lt;M&gt; Userspace queueing via NETLINK (EXPERIMENTAL)
             &lt;M&gt; IP tables support (required for filtering/masq/NAT)
             &lt;M&gt;   limit match support
             &lt;M&gt;   MAC address match support
             &lt;M&gt;   netfilter MARK match support
             &lt;M&gt;   Multiple port match support
             &lt;M&gt;   TOS match support
             &lt;M&gt;   Connection state match support
             &lt;M&gt;   Unclean match support (EXPERIMENTAL)
             &lt;M&gt;   Owner match support (EXPERIMENTAL)
             &lt;M&gt;   Packet filtering
             &lt;M&gt;     REJECT target support
             &lt;M&gt;     MIRROR target support (EXPERIMENTAL)
              .
             &lt;M&gt;   Packet mangling
             &lt;M&gt;     TOS target support
             &lt;M&gt;     MARK target support
             &lt;M&gt;   LOG target support
             &lt;M&gt; ipchains (2.2-style) support
             &lt;M&gt; ipfwadm (2.0-style) support
  </screen>
  </para>



</sect2>

<sect2 id="X-087-2-firewall.howto.ipfwadm"><title>La utilidad ipfwadm</title>
<para>
<indexterm><primary>orden ipfwadm</primary></indexterm>
La utilidad<command> ipfwadm</command> (el administrador del cortafuegos de IP)
es la herramienta que se utiliza para construir las reglas del cortafuegos para
todos los núcleos anteriores al 2.2.0. La sintaxis de las órdenes puede
resultar muy confusa porque permite realizar un amplio espectro de cosas;
aquí se proporcionarán algunos ejemplos comunes que ilustrarán las variaciones
más importantes dentro de ese espectro.
</para>

<para>
La utilidad
<command>ipfwadm</command>  se incluye en la mayoría de las distribuciones
modernas de Linux, aunque quizás no por defecto. Puede que haya
un paquete de 'software' específico que tenga que instalar.
Si su distribución no la incluye, puede obtener el paquete con el código fuente de
<systemitem role="sitename">ftp.xos.nl</systemitem> dentro del directorio
<filename>/pub/linux/ipfwadm/</filename>, y compilarla usted mismo. 
</para>

</sect2>

<sect2 id="X-087-2-firewall.howto.ipchains"><title>La utilidad ipchains</title>
<para>
<indexterm><primary>orden ipchains</primary></indexterm>
Al igual que la utilidad
<command>ipfwadm</command>, la utilidad
<command>ipchains</command> puede resultar algo desconcertante al principio.
Proporciona toda la flexibilidad de <command>ipfwadm</command> 
con una sintaxis simplificada, y además proporciona un mecanismo
de &ldquo;encadenamiento&rdquo; 
que le permite gestionar múltiples conjuntos de reglas y enlazarlas
conjuntamente.  Se cubrirá el encadenamiento de reglas en una
sección independiente cerca del final de este capítulo, porque
resulta un concepto avanzado en la mayoría de las situaciones.
</para>

<para>
<indexterm><primary>orden ipfwadm-wrapper</primary></indexterm>
La orden <command>ipchains</command>  aparece en la mayoría de las
distribuciones de Linux basadas en los núcleos 2.2. Si desea compilarla
usted mismo, puede encontrar el paquete con el código fuente en
el sitio de desarrollo
<emphasis>http://www.rustcorp.com/linux/ipchains/</emphasis>.
Con el paquete del código fuente se incluye un guión
<footnote id="X-087-2-FW-TFN10">
<para> N. del T.: 'script' en el original en inglés
</para>
</footnote>
denominado
<command>ipfwadm-wrapper</command> que imita a la orden
<command>ipfwadm</command>, pero que realmente invoca la orden
<command>ipchains</command>. La migración de una configuración
preexistente de cortafuegos
resulta menos costosa gracias a este complemento.
</para>

</sect2>

<sect2 id="X-087-2-firewall.howto.iptables"><title>La utilidad iptables</title>
<para>
<indexterm><primary>orden iptables</primary></indexterm>
La sintaxis de la utilidad <command>iptables</command> es bastante
similar a la de
<command>ipchains</command>.
Los cambios consisten en mejoras y en el resultado del rediseño de 
la herramienta
para que sea extensible a través de bibliotecas dinámicas.
Al igual que en el caso de <command>ipchains</command>, se presentarán los
equivalentes de los ejemplos con
<command>iptables</command> de tal forma que pueda comparar
y contrastar su sintaxis con la de las otras utilidades.
</para>

<para>
La utilidad <command>iptables</command> se incluye en el paquete de
código fuente de
<emphasis>netfilter</emphasis> que está disponible en
<emphasis>http://www.samba.org/netfilter/</emphasis>.
También estará incluído en cualquier distribución basada en la serie
de núcleos 2.4.
</para>

<para>
Se hablará un poco del importante paso hacia delante que
<emphasis>netfilter</emphasis> representa en una sección dedicada más adelante
en este capítulo.
</para>

</sect2>
<INDEXTERM startref="kernel.config.ipfirewall" class=endofrange>
</sect1>

<sect1 id="X-087-2-firewall.filteringmethods"><title>Las tres formas posibles de filtrado</title>
<indexterm><primary>filtrado</primary><secondary>etapas de</secondary></indexterm>
<INDEXTERM><PRIMARY>datagramas</PRIMARY><SECONDARY>etapas de procesamiento</SECONDARY></INDEXTERM>
<para>
Considérese cómo una máquina Unix, o de hecho cualquier máquina capaz
de realizar encaminamiento de IP, procesa los datagramas de IP. Los pasos
básicos,
mostrados en la <xref linkend="X-087-2-firewall.methods.graphic"> son:
</para>

<figure id="X-087-2-firewall.methods.graphic" float=1>
<title>Las etapas del procesamiento de un datagrama de IP</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0902" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0902.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<itemizedlist>
<listitem><para>
Se recibe el datagrama de IP. (1)
</para></listitem>
<listitem><para>
Se examina el datagrama de IP entrante para determinar si está destinado
a un proceso de esta máquina.
</para></listitem>
<listitem><para>
Si el datagrama es para esta máquina, se procesa localmente.(2)
</para></listitem>
<listitem><para>
Si no está destinado a esta máquina, se realiza una búsqueda en la tabla
de encaminamiento de una ruta adecuada y 
el datagragama se reenvía  por la interfaz
adecuada o se elimina si no se puede encontrar una ruta. (3)
</para></listitem>
<listitem><para>
Los datagramas procedentes de procesos locales se envían hacia el 'software' de
encaminamiento para ser reenviados hacia la interfaz apropiada. (4)
</para></listitem>
<listitem><para>
Se examina el datagrama de IP saliente para determinar si existe una ruta
válida que escoger, si no es así, se elimina.
</para></listitem>
<listitem><para>
Se transmite el datagrama de IP. (5)
</para></listitem>
</itemizedlist>

<para>
En nuestro diagrama, el flujo 1&rarr;3&rarr;5
representa nuestra máquina encaminando datos entre un 'host'
sobre nuestra red Ethernet y un 'host' alcanzable
vía nuestro enlace de PPP.
Los flujos 1&rarr;2 y 4&rarr;5 representan
los flujos de entrada y de salida de datos de un programa de red ejecutándose
en nuestro 'host' local.
El flujo 4&rarr;3&rarr;2 representaría un flujo de datos vía una conexión
'loopback'. Naturalmente, los datos fluyen tanto hacia dentro como hacia
fuera de los dispositivos de red. Los símbolos de interrogación del
diagrama representan los puntos donde la capa de IP realiza las decisiones
de encaminamiento.
</para>

<para>
El cortafuegos de IP del núcleo de Linux es capaz de aplicar filtrados
en varias etapas de este proceso. Es decir, se pueden filtrar los
datagramas de IP que entren en su máquina, aquellos que estén siendo
reenviados a través de su máquina y aquellos que estén preparados para
ser transmitidos.
</para>

<para>
En <command>ipfwadm</command> y en <command>ipchains</command>, una
regla de tipo 'Input'
<footnote id="X-087-2-FW-TFN11">
<para> N. del T.: "entrada"
</para>
</footnote>
se aplica al flujo 1 del diagrama, una
regla de tipo 'Forwarding'
<footnote id="X-087-2-FW-TFN12">
<para> N. del T.: "reenvío"
</para>
</footnote>
al flujo 3 y una regla de
tipo 'Output'
<footnote id="X-087-2-FW-TFN13">
<para> N. del T.: "salida"
</para>
</footnote>
al flujo 5.

Cuando se discuta
<emphasis>netfilter</emphasis> más adelante se verá que los puntos
de interceptación han cambiado de tal forma que una regla
de tipo 'Input' se aplica ahora en el flujo 2, y una regla de tipo
'Output' en el flujo 4.
Esto tiene implicaciones importantes sobre cómo se deben estructurar los
conjuntos de reglas, pero los principios generales permanecen válidos
para todos los tipos de cortafuegos de GNU/Linux.
</para>

<para>
Todo esto puede parecer complicado de forma innecesaria en un primer
momento, pero proporciona una flexibilidad que permite construir
configuraciones muy sofisticadas y poderosas.
</para>
</sect1>

<sect1 id="X-087-2-firewall.original"><title>El cortafuegos original de IP (núcleos 2.0)</title>
<para>
<indexterm><primary>Cox, Alan</primary></indexterm>
<indexterm><primary>Vos, Jos</primary></indexterm>
<indexterm><primary>Middelink, Pauline</primary></indexterm>
<INDEXTERM id="original.firewall" class=startofrange><PRIMARY>cortafuegos</PRIMARY><SECONDARY>IP original</SECONDARY></INDEXTERM>
<INDEXTERM id="Linux.2.0.kernels" class=startofrange><PRIMARY>núcleos 2.0</PRIMARY><SECONDARY>cortafuegos de IP</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>orden ipfwadm</PRIMARY></INDEXTERM>
La primera generación del soporte de cortafuegos de IP para GNU/Linux apareció
en la serie de núcleos 1.1. Consistía en una implementación del
cortafuegos ipfw de BSD por Alan Cox. El soporte de cortafuegos que
apareció en la serie de núcleos 2.0 que constituye la segunda generación
fue una mejora de Jos Vos, Pauline Middelink y otros.
</para>

<sect2 id="X-087-2-firewall.usingipfwadm"><title>Uso de ipfwadm</title>
<para>
La orden <command>ipfwadm</command> era la herramienta de configuración
para la segunda generación de cortafuegos de IP de GNU/Linux.
Quizás la forma más simple de describir el uso de la orden
<command>ipfwadm</command> es con un ejemplo.
Para empezar, se codificará el ejemplo que se presentó antes.
</para>

<sect3 id="X-087-2-firewall.simpleexample"><title>Un ejemplo trivial</title>
<para>
Supóngase que se dispone de una red en nuestra organización y que se
utiliza una máquina cortafuegos basada en GNU/Linux para conectar la
red a Internet. Además, supóngase que se desea que los usuarios de
la red sean capaces de acceder a servidores 'web' de Internet,
pero que cualquier otro tipo de tráfico no sea permitido.
</para>

<para>
Se pondrá una regla de tipo 'forwarding' para permitir que los datagramas
con dirección de origen en nuestra red y un conector de destino con
puerto 80 sean reenviados hacia fuera, y los correspondientes datagramas
de respuesta sean reenviados de vuelta vía el cortafuegos.
</para>
<?troff .sp -1p>
<para>
Asúmase que nuestra red tiene una máscara de 24 bits (clase C) y
una dirección de 172.16.1.0. La reglas que se podrían utilizar serían:
<screen>
<prompt>#</prompt> <userinput>ipfwadm -F -f</userinput>
<prompt>#</prompt> <userinput>ipfwadm -F -p deny</userinput>
<prompt>#</prompt> <userinput>ipfwadm -F -a accept -P tcp -S 172.16.1.0/24 -D 0/0 80</userinput>
<prompt>#</prompt> <userinput>ipfwadm -F -a accept -P tcp -S 0/0 80 -D 172.16.1.0/24</userinput>
</screen>
</para>

<para>
El argumento <option>-F</option> de la línea de órdenes significa especifica a
<command>ipfwadm</command> que es una regla de tipo 'forwarding', es decir, de
reenvío.
La primera orden instruye a <command>ipfwadm</command> que se "desprenda"
de todas las reglas de tipo 'forwarding'. Esto asegura que se trabajará
con un estado conocido antes de que se añadan reglas específicas.
</para>

<para>
La segunda regla establece nuestra política predeterminada de reenvío.
Se le dice al núcleo que niegue o que no permita el reenvío de datagramas
de IP. Es muy importante establecer la política por omisión, porque
describe qué le pasará a cualquier datagrama que no esté específicamente
controlado por cualquier otra regla. En la mayoría de las configuraciones de
cortafuegos, usted querrá establecer la política por defecto a 'deny'
<footnote id="X-087-2-FW-TFN14">
<para> N. del T.: "denegación"
</para>
</footnote>,
como se muestra en el ejemplo, para estar seguro de que sólo el tráfico que
usted específicamente permita pasar su cortafuegos sea reenviado.
</para>

<para>
La tercera y la cuarta reglas son las que implementan el requisito.
La tercera orden permite que nuestros datagramas salgan, y la cuarta
permite las respuestas de vuelta.
</para>

<para>
Vamos a revisar cada unos de los argumentos:

<variablelist>
<varlistentry>
<term>-F</term>
<listitem><para>
Esta es una regla de tipo 'forwarding'.
</para></listitem>
</varlistentry>

<varlistentry><term>-a accept</term>
<listitem><para>
Añadir esta regla con la política establecida a "aceptar", lo que quiere
decir que se reenviará cualquier datagrama que se ajuste a esta regla
</para></listitem>
</varlistentry>

<varlistentry><term>-P tcp</term>
<listitem><para>
Esta regla se aplica a los datagramas de TCP (en lugar de UDP o ICMP).
</para></listitem>
</varlistentry>

<varlistentry><term>-S 172.16.1.0/24</term>
<listitem><para>
Los primeros 24 bits de la dirección de origen deben coincidir con
los de la dirección de red 172.16.1.0.
</para></listitem>
</varlistentry>

<varlistentry><term>-D 0/0 80</term>
<listitem><para>
La dirección de destino debe tener cero bits coincidentes con la
dirección 0.0.0.0.
Esto en el fondo es una forma de decir "cualquier dirección". El 80 es
el puerto de destino, en este caso el de WWW. También puede utilizarse
cualquier entrada que aparezca en el fichero
<filename>/etc/services</filename> para describir el puerto, 
de tal forma que <literal>-D 0/0 www</literal> habría funcionado igual de
bien.
</para></listitem>
</varlistentry>
</variablelist>
</para>

<para>
<command>ipfwadm</command> acepta las máscaras de red en una forma
con la que puede no esté familiarizado. La notación <literal>/nn</literal>
es una forma de describir cuántos bits de la dirección suministrada son
significativos, es decir, es el tamaño de la máscara de red.
Los bits se cuentan siempre de izquierda a derecha; algunos ejemplos
habituales se muestran en la <xref linkend="X-087-2-chfw-netmasks">.
</para>

<indexterm><primary>cortafuegos</primary><secondary>especificación de máscaras de red</secondary></indexterm>
<table id="X-087-2-chfw-netmasks" tocentry=1>
<title>Valores habituales de máscaras de red y bits</title>
<tgroup cols=2>
<thead>
<row><entry>Máscara</entry><entry>Bits</entry></row>
</thead>
<tbody>
<row><entry>255.0.0.0</entry><entry>8</entry></row>
<row><entry>255.255.0.0</entry><entry>16</entry></row>
<row><entry>255.255.255.0</entry><entry>24</entry></row>
<row><entry>255.255.255.128</entry><entry>25</entry></row>
<row><entry>255.255.255.192</entry><entry>26</entry></row>
<row><entry>255.255.255.224</entry><entry>27</entry></row>
<row><entry>255.255.255.240</entry><entry>28</entry></row>
<row><entry>255.255.255.248</entry><entry>29</entry></row>
<row><entry>255.255.255.252</entry><entry>30</entry></row>
</tbody>
</tgroup>
</table>

<para>
Se mencionó antes que <command>ipfwadm</command> implementa un pequeño
truco que permite que sea más fácil añadir estos tipos de reglas. Este
truco consiste en el uso de la opción <emphasis>-b</emphasis>, que convierte
a la orden en una regla bidireccional.
</para>

<para>
El modificador de bidireccionalidad nos permite unir nuestras dos reglas
en una sola como sigue:

<screen width=80>
<prompt>#</prompt> <userinput>ipfwadm -F -a accept -P tcp -S 172.16.1.0/24 -D 0/0 80 -b</userinput>
</screen>
</para>
</sect3>

<sect3 id="X-087-2-firewall.simpleexample.refinement"><title>Un refinamiento importante</title>
<para>
Eche una mirada más atenta a nuestro conjunto de reglas. ¿ Puede apreciar
que todavía existe un método de ataque que alguien de fuera podría utilizar
para engañar a nuestro cortafuegos ?
</para>
<para>
Nuestro conjunto de reglas permite que todos los datagramas procedentes
de fuera de nuestra red con un puerto de origen de 80 pasen.
¡ Esto incluiría a aquellos datagramas cuyo bit de SYN valga 1 !
El bit SYN es lo que declara a un datagrama de TCP que sea una petición
de conexión. Si una persona de fuera tuviera un acceso privilegiado a
un 'host', podría realizar una conexión a través de nuestro cortafuegos
con cualquiera de nuestros 'hosts', dado el supuesto de que utilizará 
el puerto 80 en su extremo. Esto no es lo que se deseaba.
</para>
<?troff .Nd 10>
<para>
Afortunadamente, existe una solución a este problema. La orden
<command>ipfwadm</command> proporciona otro modificador que permite
construir reglas que coincidan con datagramas cuyo bit de SYN valga 1.
Cambiemos nuestro ejemplo para incluir una regla de este tipo:

<screen width=80>
<prompt>#</prompt> <userinput>ipfwadm -F -a deny -P tcp -S 0/0 80 -D 172.16.10.0/24 -y</userinput>
<prompt>#</prompt> <userinput>ipfwadm -F -a accept -P tcp -S 172.16.1.0/24 -D 0/0 80 -b</userinput>
</screen>
</para>

<para>
El modificador <option>-y</option> hace que la regla coincida sólo si
el bit SYN del datagrama vale 1. Así nuestra nueva regla dice:
"Deniega cualquier datagrama destinado a nuestra regla procedente de
cualquier sitio con un puerto de origen igual a 80 y bit SYN igual a 1",
o "deniega cualquier petición de conexsión desde 'hosts' utilizando el puerto
80"
</para>

<para>
¿Por qué se ha puesto esta regla especial <emphasis>antes</emphasis> de
la regla principal?  Las reglas de cortafuegos de IP operan de tal forma
que la primera coincidencia es la regla que se utiliza.
Ambas reglas coincidirían con los datagramas que queremos detener, por
tanto debemos asegurarnos que se ha puesto la regla con la instrucción 
<literal>deny</literal> antes que la regla con la
instrucción <literal>accept</literal>.
</para>

</sect3>

<sect3 id="X-087-2-firewall.listing"><title>Listado de nuestras reglas </title>
<para>
<?troff .hw command>
<indexterm><primary>orden ipfwadm</primary><secondary>listado de reglas con</secondary></indexterm>
Después de haber introducido nuestras reglas, se puede pedir a
<command>ipfwadm</command> que las liste con la orden:

<screen width=80>
<prompt>#</prompt> <userinput>ipfwadm -F -l</userinput>
</screen>
Esta orden mostrará todas las reglas de reenvío configuradas. La salida
debería parecerse a algo como esto:

<screen width=80>
<prompt>#</prompt> <userinput>ipfwadm -F -l</userinput>
IP firewall forward rules, default policy: accept
type  prot source               destination          ports
deny  tcp  anywhere             172.16.10.0/24       www -> any
acc   tcp  172.16.1.0/24        anywhere             any -> www
</screen>

La orden <command>ipfwadm</command> intentará traducir el número de
puerto en un nombre de servicio utilizando el fichero 
<filename>/etc/services</filename>, si es que tiene alguna entrada correspondiente.
</para>

<para>
La salida por omisión carece de algunos detalles importantes para nosotros.
En la salida con el listado predeterminado no se puede  ver el efecto del
argumento
<literal>-y</literal>.
La orden
<command>ipfwadm</command>
es capaz de producir un listado más detallado si se especifica además el
argumento
<literal>-e</literal> (salida extendida). 
Aquí no se muestra la salida completa porque es demasiado ancha para la
página, pero sí que incluye una columna para las opciones de nombre
<literal>opt</literal>
que muestra la opción
<option>-y</option>
que controlla los paquetes de tipo SYN:
</para>

<screen width=120>
<prompt>#</prompt> <userinput>ipfwadm -F -l -e</userinput>
P firewall forward rules, default policy: accept
 pkts bytes type  prot opt  tosa tosx ifname  ifaddress   source        ...   
    0     0 deny  tcp  --y- 0xFF 0x00 any     any         anywhere      ...       
    0     0 acc   tcp  b--- 0xFF 0x00 any     any         172.16.1.0/24 ...
</screen>

</sect3>

</sect2>

<sect2 id="X-087-2-firewall.complexexample"><title>Un ejemplo más complejo</title>
<para>
El ejemplo anterior era un ejemplo simple. No todo los servicios de
red son tan simples de configurar como el servicio de WWWW; en la
práctica, la configuración de un cortafuegos típico resultaría ser
mucho más compleja. Vamos a  examinar otro ejemplo común, esta vez FTP.
Se quiere que los usuarios de la red interna puedan entrar en 
servidores de FTP de Internet para leer y escribir ficheros. Pero
no se desea que personas de Internet puedan entrar en nuestros servidores
de FTP.
</para>

<para>
Es sabido que FTP utiliza dos puertos de FTP: el puerto 20 (ftp-data)
y el puerto 21 (ftp), por tanto:

<screen width=80>
<prompt>#</prompt> <userinput>ipfwadm -a deny -P tcp -S 0/0 20 -D 172.16.1.0/24 -y</userinput>
<prompt>#</prompt> <userinput>ipfwadm -a accept -P tcp -S 172.16.1.0/24 -D 0/0 20 -b</userinput>
#
<prompt>#</prompt> <userinput>ipfwadm -a deny -P tcp -S 0/0 21 -D 172.16.1.0/24 -y</userinput>
<prompt>#</prompt> <userinput>ipfwadm -a accept -P tcp -S 172.16.1.0/24 -D 0/0 21 -b</userinput>
</screen>

¿Correcto? Bueno, no necesariamente. Los servidores de FTP pueden
operar en dos modos diferentes: el modo pasivo y el modo activo.
<footnote id="X-087-2-FW-FN03">
<para>
El modo activo de FTP se habilita, de forma poco intuitiva,
con la orden
<command>PORT</command>. 
El modo pasivo de FTP se habilita con la orden
<command>PASV</command>.
</para>
</footnote>  En el modo pasivo, el servidor de FTP permanece escuchando
en espera de una conexión desde el cliente. En el modo activo, es el
servidor  el que realmente realiza la conexión con el cliente. El modo
activo es el habitual por omisión. Las diferencias se ilustran en
la <xref linkend="X-087-2-firewall.ftp.graphic">.
</para>


<figure id="X-087-2-firewall.ftp.graphic" float=1>
<title>Modos de un servidor de FTP</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0903" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0903.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<para>
Muchos servidores de FTP realizan su conexión de datos desde el puerto
20 cuando operan en el modo activo, lo que simplifica las cosas un poco,
pero, degraciadamente, no todos proceden así.
<footnote id="X-087-2-FW-FN04">
<para>
El demonio ProFTPd constituye un buen ejemplo de un servidor de FTP que no
procede así, al menos,en sus versiones antiguas.
</para>
</footnote>
</para>

<para>
Pero, ¿cómo nos afecta todo esto? Fíjese en nuestra regla del puerto
20, el puerto de datos de FTP (FTP-data). La regla, tal como se tiene
en este momento, asume que la conexión será realizada por nuestro cliente
al servidor. Esto funcionará si se utiliza el modo pasivo. 
Pero resulta muy difícil para nosotros el configurar una regla
satisfactoria que permita el modo activo de FTP, porque no se
puede saber de antemano qué puertos serán los utilizados.
Si  abrimos nuestro cortafuegos para permitir conexiones entrantes
en cualquier puerto, estaríamos exponiendo nuestra red a un ataque
sobre todos los servicios que acepten conexiones.
</para>

<para>
El dilema se resuelve de la forma más satisfactoria insistiendo en que
nuestros usuarios operen en el modo pasivo. La mayoría de los servidores
de FTP y muchos clientes de FTP funcionarán de esta forma.
El cliente popular
<command>ncftp</command> también soporta el modo pasivo,
pero requiere un pequeño cambio de configuración para conseguir
que su modo por omisión sea el pasivo.
Muchos navegadores de 'World Wide Web' como el navegador de Netscape
también soportan el modo pasivo de FTP, por lo que no debería ser
muy difícil el encontrar el 'software' adecuado para utilizar.
De forma alternativa, se puede evitar el asunto de forma completa
utilizando un programa intermediario de FTP que acepten una conexión
desde la red interna y establezca conexiones con las redes externas.
</para>

<para>
Cuando construya su cortafuegos, probablemente se encontrará con
varios de estos problemas. Debería siempre pensar cuidadosamente
cómo funciona un servico realmente para estar seguro de que ha puesto
un conjunto de reglas adecuado a ese servicio.
La configuración de un cortafuegos de verdad puede resultar bastante
compleja.
</para>
</sect2>

<sect2 id="X-087-2-firewall.ipfwadmargs"><title>Resumen de los argumentos de ipfwadm</title>
<para>
<INDEXTERM id="ipfwadm.firewall.options" class=startofrange><PRIMARY>orden ipfwadm</PRIMARY><SECONDARY>opciones del cortafuegos</SECONDARY></INDEXTERM>
La orden
<command>ipfwadm</command>
tiene muchos argumentos diferentes que están relacionados con
la configuración del cortafuegos de IP. La sintaxis general es:

<screen width=45>
<command>ipfwadm</command> <replaceable>categoría</replaceable> <replaceable>orden</replaceable> <replaceable>parámetros</replaceable> <replaceable>[opciones]</replaceable>
</screen>
</para>

<para>
Veamos cada cosa.
</para>

<sect3 id="X-087-2-firewall.ipfwadm.categories"><title>Categorías</title>
<para>
Sólo puede introducirse una de estas categorías. La categoría le dice
al cortafuegos qué tipo de regla de cortafuegos se está configurando:
</para>
<?troff .Nd 10>
<variablelist>
<varlistentry><term>-I</term>
<listitem><para>regla de tipo 'Input' </para></listitem>
</varlistentry>

<varlistentry><term>-O</term>
<listitem><para>regla de tipo 'Output' </para></listitem>
</varlistentry>

<varlistentry><term>-F</term>
<listitem><para>regla de tipo 'Forwarding' </para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="X-087-2-firewall.ipfwadm.command"><title>Órdenes</title>
<para>
Al menos una de las siguientes órdenes debe ser introducida y se
aplican sólo aquellas reglas relacionadas con la categoría introducida.
La orden le dice al cortafuegos qué acción debe tomar.
</para>

<variablelist>
<varlistentry><term>-a [política]</term>
<listitem><para>Añade una nueva regla</para></listitem>
</varlistentry>

<varlistentry><term>-i [política]</term>
<listitem><para>Inserta una nueva regla</para></listitem>
</varlistentry>

<varlistentry><term>-d [política]</term>
<listitem><para>Borra una regla existente</para></listitem>
</varlistentry>

<varlistentry><term>-p política</term>
<listitem><para>Establece la política por defecto</para></listitem>
</varlistentry>

<varlistentry><term>-l</term>
<listitem><para>Muestra todas las reglas existentes</para></listitem>
</varlistentry>

<varlistentry><term>-f</term>
<listitem><para>Destruye todas las reglas existentes</para></listitem>
</varlistentry>
</variablelist>

<para>
Las políticas relevantes para el cortafuegos de IP y sus
significados son:

<variablelist>
<varlistentry><term>accept</term>
<listitem><para>
Permite que los datagramas coincidentes sean recibidos, reenviados
o transmitidos
</para></listitem>
</varlistentry>

<varlistentry><term>deny</term>
<listitem><para>
Impide que los  datagramas coincidentes sean recibidos, reenviados o
transmitidos
</para></listitem>
</varlistentry>

<varlistentry><term>reject</term>
<listitem><para>
Impide que los  datagramas coincidentes sean recibidos, reenviados o
transmitidos y envía al 'host' que envió el datagrama un mensaje
de error de ICMP.
</para></listitem>
</varlistentry>
</variablelist>

</para>

</sect3>

<sect3 id="X-087-2-firewall.ipfwadm.parameters"><title>Parámetros</title>
<para>
Al menos uno de los siguientes parámetros debe ser introducido. Utilice
los parámetros para especificar a qué datagramas se aplica esta regla:
</para>

<variablelist>
<varlistentry><term>-P protocolo</term>
<listitem><para>
Puede ser TCP, UDP, ICMP o  todos. Ejemplo:
</para>
<para><literal>-P tcp</literal></para></listitem>
</varlistentry>

<varlistentry><term>-S dirección[/máscara] [puerto]</term>
<listitem><para>
La dirección IP de origen que buscar coincidencias coná con esa regla.
Se asumirá una máscara de
&ldquo;/32&rdquo; bits
si no se proporciona una. Opcionalmente, puede especificar a qué
puertos se aplicará esta regla. También puede especificar el
protocolo utilizando el argumento
<option>-P</option> que se describió más arriba.
Si no se especifica el puerto o un rango de puertos,
se supondrá que &ldquo;todos&rdquo; los puertos buscar coincidencias conán.
Los puertos pueden especificarse por su nombre, utilizando
la entrada del fichero
<filename>/etc/services</filename> que desee.
En el caso del protocolo de ICMP, el campo de puerto se utiliza
para indicar el tipo de datagrama de ICMP. Pueden introducirse
rangos de puertos; para ello utilice la sintaxis genérica:
<replaceable>puerto inferior</replaceable>:<replaceable>puerto superior</replaceable>. Ejemplo:
</para>
<para><literal>-S 172.29.16.1/24 ftp:ftp-data</literal></para></listitem>
</varlistentry>

<varlistentry><term>-D dirección[/máscara] [puerto]</term>
<listitem><para>
Especifica la dirección IP de destino que buscar coincidencias coná con la regla.
La dirección de destino se codifica con las mismas reglas que la
dirección de origen descrita previamente.
Ejemplo:
</para>
<para><literal>-D 172.29.16.1/24 smtp</literal></para></listitem>
</varlistentry>

<varlistentry><term>-V dirección</term>
<listitem><para>
Especifica la dirección del interfaz de red por el que el paquete
se recibe
(<option>-I</option>)
o se envía
(<option>-O</option>). Esto nos permite crear reglas que
sólo se apliquen a ciertas interfaces de red de nuestra máquina.
Ejemplo:
</para>
<para><literal>-V 172.29.16.1</literal></para></listitem>
</varlistentry>

<varlistentry><term>-W nombre</term>
<listitem><para>
Especifica el nombre del interfaz de red. Este argumento
funciona de la misma manera que el argumento
<option>-V</option>, excepto que se proporciona el
nombre del dispositivo en lugar de su dirección.
Ejemplo:
</para>
<para><literal>-W ppp0</literal></para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="X-087-2-firewall.ipfwadm.optargs"><title>Argumentos opcionales</title>
<para>
Estos argumentos resultan muy útiles a veces:
</para>

<variablelist>
<varlistentry><term>-b</term>
<listitem><para>
Utilizado para establecer el modo bidireccional. Este modificador
hace que coincida el tráfico entre el origen y el destino
especificados fluyendo en cualquier sentido.
Esto ahorra el crear dos reglas: una para el sentido hacia delante
de la conexión y otra para el sentido contrario.
</para></listitem>
</varlistentry>

<varlistentry><term>-o</term>
<listitem><para>
Esto habilita el apunte en el registro del núcleo de información
sobre los datagramas coincidentes.
Cualquier datagrama que coincida con esta regla
será registrado en un mensaje del núcleo. Esto resulta
útil para posibilitar la detección de accesos no autorizados.
</para></listitem>
</varlistentry>

<varlistentry><term>-y</term>
<listitem><para>
Utilizado para buscar coincidencias con datagramas de establecimiento de la conexión
de TCP. Esta opción causa que la regla coincida sólo con los datagramas
que intenten establecer conexiones de TCP. Únicamente los
datagramas que tengan su bit SYN con un valor de uno, y su bit ACK con
un valor de 0, buscar coincidencias conán. Esto resulta útil para filtrar
los intentos de conexión de TCP y se ignora en el caso de otros
protocolos.
</para></listitem>
</varlistentry>

<varlistentry><term>-k</term>
<listitem><para>
Utilizado para buscar coincidencias con datagramas de acuse de recibo de TCP.
Esta opción causa que la regla coincida sólo con los datagramas
que sean acuse de recibos de paquetes que intentan establecer
conexiones de TCP. Únicamente los datagramas que tenga
su bit ACK con valor igual a 1. Esto resulta útil para
filtrar los intentos de conexión de TCP y se ignora en el caso
de otros protocolos.
</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="X-087-2-firewall.ipfwadm.icmp-types"><title>Tipos de datagrama de ICMP</title>

<para>
<indexterm><primary>ICMP (protocolo de mensajes de control de Internet)</primary><secondary>tipos de datagrama</secondary></indexterm>
<indexterm><primary>RFC-1700</primary></indexterm>
<INDEXTERM><PRIMARY>tipos de datagrama, protocolo ICMP</PRIMARY></INDEXTERM>
Cada una de las órdenes de configuración del cortafuegos le permite
especificar tipos de datagrama de ICMP. Al contario que los puertos
de TCP y de UDP, no existe un fichero de configuración conveniente
que liste los tipos de datagramas y sus significados.
Los tipos de datagrama de ICMP se definen en el RFC-1700,
el RFC de los números asignados. Los tipos de datagrama de ICMP
aparecen también listados en uno de los ficheros de cabecera
de la biblioteca estándar de C. El fichero
<filename>/usr/include/netinet/ip_icmp.h</filename>,
que pertenece al paquete con la biblioteca estándar de GNU,
y que los programadores de C utilizan cuando escriben 
'software' de red que utilice el protocolo de ICMP,
también define los tipos de datagrama de ICMP.
Para su conveniencia, se incluyen aquí en la
<xref linkend="X-087-2-chfw-icmptypes">
          <footnote id="X-087-2-TFN15"><para>
            N.del T.: se han utilizado  las descripciones
            de la traducción
            al español por P.J. Ponce de León, dentro del proyecto RFC-ES,
            del RFC0792 "Protocolo de mensajes de control de internet"
            </para>
          </footnote>.
La interfaz de la orden <command>iptables</command>
le permite especificar los tipos de ICMP por su nombre,
por lo que también se muestran los nombre nemotécnicos que utiliza.
</para>

<table id="X-087-2-chfw-icmptypes" tocentry=1>
<title>Tipos de datagramas de ICMP
</title>
<tgroup cols=3>
<thead>
<row>
	<entry>Número de tipo</entry>
	<entry>Nnemónico de iptables</entry>
	<entry>Descripción del tipo
        </entry>
</row>
</thead>
<tbody>
<row>
	<entry>0</entry>
	<entry>echo-reply</entry>
	<entry>Respuesta a eco</entry>
</row>
<row>
	<entry>3</entry>
	<entry>destination-unreachable</entry>
	<entry>Destino inaccesible</entry>
</row>
<row>
	<entry>4</entry>
	<entry>source-quench</entry>
	<entry>Disminución del tráfico desde el origen</entry>
</row>
<row>
	<entry>5</entry>
	<entry>redirect</entry>
	<entry>Redirección</entry>
</row>
<row>
	<entry>8</entry>
	<entry>echo-request</entry>
	<entry>Solicitud de eco</entry>
</row>
<row>
	<entry>11</entry>
	<entry>time-exceeded</entry>
	<entry>Tiempo superado</entry>
</row>
<row>
	<entry>12</entry>
	<entry>parameter-problem</entry>
	<entry>Problema de parámetros</entry>
</row>
<row>
	<entry>13</entry>
	<entry>timestamp-request</entry>
	<entry>Solicitud de marca de tiempo</entry>
</row>
<row>
	<entry>14</entry>
	<entry>timestamp-reply</entry>
	<entry>Respuesta de marca de tiempo</entry>
</row>
<row>
	<entry>15</entry>
	<entry>none</entry>
	<entry>Solicitud de información</entry>
</row>
<row>
	<entry>16</entry>
	<entry>none</entry>
	<entry>Respuesta de información</entry>
</row>
<row>
	<entry>17</entry>
	<entry>address-mask-request</entry>
	<entry>Petición de máscara de dirección</entry>
</row>
<row>
	<entry>18</entry>
	<entry>address-mask-reply</entry>
	<entry>Respuesta de máscara de dirección</entry>
</row>
</tbody>
</tgroup>
</table>

</sect3>
<INDEXTERM startref="ipfwadm.firewall.options" class=endofrange>
</sect2>
<INDEXTERM startref="original.firewall" class=endofrange>
<INDEXTERM startref="Linux.2.0.kernels" class=endofrange>
</sect1>

<sect1 id="X-087-2-firewall.fwchains"><title>Cortafuegos 'IP Chains' (núcleos 2.2)</title>
<INDEXTERM id="firewall.ip.chains" class=startofrange><PRIMARY>firewalls</PRIMARY><SECONDARY>IP chains</SECONDARY></INDEXTERM>
<INDEXTERM id="ip.firewall.chains" class=startofrange><PRIMARY>IP (Internet Protocol)</PRIMARY><SECONDARY>cortafuegos 'chains'</SECONDARY></INDEXTERM>
<INDEXTERM id="chains.IP.firewall" class=startofrange><PRIMARY>chains</PRIMARY><SECONDARY>IP firewall</SECONDARY></INDEXTERM>
<INDEXTERM id="Linux.2.2.kernels" class=startofrange><PRIMARY>núcleos 2.2</PRIMARY><SECONDARY>cirtafuegos de IP 'chains'</SECONDARY></INDEXTERM>
<para>
La mayoría de los aspectos de GNU/Linux evolucionan para satisfacer
las cada vez mayores demandas de sus usuarios; el cortafuegos de IP
no es una excepción. La implementación del cortafuegos de IP
tradicional resulta suficiente para la mayoría de las aplicaciones,
pero puede resultar engorroso y poco eficiente para configurar
en entornos complejos. Para resolver este problema, se desarrolló 
un nuevo método de configuración del cortafuegos de IP así como 
nuevas características relacionadas. Este nuevo método fue denominado 
&ldquo;Cortafuegos 'IP Chains'<footnote id="X-087-2-FW-TFN16">
<para> N. del T.: "cadenas de IP"
</para></footnote>&rdquo;
y fue liberado por vez primera para uso general
en el núcleo 2.2.0.
</para>

<para>
<indexterm><primary>Russell, Paul</primary></indexterm>
<indexterm><primary>Neuling, Michael</primary></indexterm>
El soporte del cortafuegos 'IP Chains' fue desarrollado por
Paul Russell y Michael Neuling<footnote id="X-087-2-FN05"><para>
Puede contactar con Paul en
<systemitem role="emailaddr">Paul.Russell@rustcorp.com.au</systemitem>.
</para>
</footnote>.
<indexterm><primary>IPCHAINS-HOWTO</primary></indexterm>
<INDEXTERM><PRIMARY>HOWTOs</PRIMARY><SECONDARY>IPCHAINS</SECONDARY></INDEXTERM>
Paul es el autor del documento sobre 'IP Chains' IPCHAINS-HOWTO.
</para>

<para>
El cortafuegos 'IP Chains' le permite desarrollar clases de
reglas de cortafuegos a las que puede entonces añadir y quitar
'hosts' o redes. Una consecuencia colateral del encadenamiento
de reglas de cortafuegos es que puede mejorar el rendiminento
del cortafuegos en aquellas configuraciones en las que haya
montones de reglas.
</para>

<para>
El cortafuegos 'IP Chains' está soportado por las series de núcleos
2.2 y también se encuentran disponibles como un parche
para la series de núcleos 2.0.*. El HOWTO
describe dónde obtener el parche y proporciona montones de
pistas útiles sobre cómo utilizar de forma efectiva la
utilidad de configuración <command>ipchains</command>.
</para>

<sect2 id="X-087-2-firewall.usingipchains"><title>Uso de ipchains</title>
<para>
<indexterm><primary>orden ipchains</primary></indexterm>
<indexterm><primary>orden ipfwadm-wrapper</primary></indexterm>
Existen dos formas de emplear la utilidad 
<command>ipchains</command>.
La primera forma consiste en utilizar el guión de "shell"
<command>ipfwadm-wrapper</command>,
que es básicamente un sustituto de la orden
<command>ipfwadm</command>
y que llama por debajo al programa <command>ipchains</command>. Si esto es
lo que desea, no siga leyendo y relea las secciones previas que
describen  <command>ipchains</command>,
poniendo <command>ipfwadm-wrapper</command> en su lugar.
Esto funcionará, pero no se garantiza que el guión se mantenga
en un futuro, y en ese caso no dispondrá de las características
avanzadas que el cortafuegos 'IP Chains' vaya a ofrecer.
</para>

<para>
La segunda forma de utilizar <command>ipchains</command> consiste en
aprender su nueva sintaxis y modificar cualquier configuración 
existente que exija utilizar la nueva sintaxis en lugar de la antigua.
Con algunas consideraciones cuidadosas, se dará cuenta de
que puede optimizar su configuración a la vez que realiza la
conversión. La sintaxis de <command>ipchains</command> es más
fácil de aprender que la de <command>ipfwadm</command>, por lo que
resultará una buena opción.
</para>

<para>
La orden <command>ipfwadm</command> manipulaba tres conjuntos
de reglas para el propósito de configurar el cortafuegos.
Con el cortafuegos 'IP Chains', podrá crear un número
arbitrario de conjuntos de reglas, cada una enlazada con otra,
pero siguen estando presentes siempre tres conjuntos
de reglas relacionadas con la función del cortafuegos.
Los conjuntos de reglas estándares son los directos equivalentes
de los utilizados con <command>ipfwadm</command>, exceptuando
el hecho de que ahora tiene nombre: 
<literal>input</literal>, <literal>forward</literal>  y
<literal>output</literal>.
</para>

<para>
Veamos primero la sintaxis general de la orden
<command>ipchains</command>, después se verá como utilizar
<command>ipchains</command> en lugar de <command>ipfwadm</command>
sin preocuparse acerca de sus características avanzadas de encadenamiento.
Se hará reutilizando nuestros ejemplos anteriores
</para>

</sect2>

<sect2 id="X-087-2-firewall.ipchains.syntax"><title>Sintaxis de la orden ipchains</title>
<para>
<INDEXTERM id="ipchains.firewall.options" class=startofrange><PRIMARY>orden ipchains</PRIMARY><SECONDARY>opciones de cortafuegos</SECONDARY></INDEXTERM>
La sintaxis de la orden <command>ipchains</command> es bastante
directa. Se contemplarán los ejemplos más importantes. La sintaxis
general de la mayoría de las órdenes  de <command>ipchains</command> es:

<screen width=80>
<command>ipchains</command> <replaceable>orden</replaceable> <replaceable>especificación_de_regla</replaceable> <replaceable>opciones</replaceable>
</screen>

</para>

<sect3 id="X-087-2-firewall.ipchains.commands"><title>Órdenes</title>
<para>
Existen diversas formas de manipular las reglas y conjuntos
de reglas con la orden <command>ipchains</command>. Las
relevantes para la funcionalidad de cortafuegos de IP son:

<variablelist>
<varlistentry>
<term>-A cadena
</term>
<listitem><para>
Añade una o más reglas al final de la cadena especificada. Si se
proporciona un nombre de 'host' como origen o destino que se resuelve
a más de una dirección IP, entonces se añade una regla por cada una
de las direcciones.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-I cadena numero_de_regla</term>
<listitem><para>
Inserta una o más reglas al principio de la cadena
especificada. De nuevo, si se proporciona un nombre de 'host',
se añade una regla por cada dirección que se resuelva.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-D cadena</term>
<listitem><para>
<?troff .hw specification>
Elimina una o más reglas de la cadena especificada que coincida con la
especificación de regla.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-D cadena número_de_regla</term>
<listitem><para>
Elimina la regla ubicada en la 
posición <replaceable>número_de_regla</replaceable> de la cadena
especificada. Las posiciones de reglas comienzan por uno
en la primera regla de la cadena.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-R cadena número_de_regla</term>
<listitem><para>
Reemplaza  la regla ubicada en la
posición <replaceable>número_de_regla</replaceable> de la cadena
especificada por la especificación de regla proporcionada.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-C cadena</term>
<listitem><para>
Comprueba el datagrama que se describe con la especificación
de la regla contra la cadena especificada. Esta orden devuelve
un mensaje que describe cómo se procesará el datagrama por
la cadena. Esto resulta muy útil para  comprobar
la configuración del cortafuegos, por lo que se verán
más detalles un poco más adelante.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-L [cadena]</term>
<listitem><para>
Muestra las reglas de la cadena especificada, o de todas las 
cadenas si no se especifica ninguna.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-F [cadena]</term>
<listitem><para>
Elimina todas las reglas de la cadena especificada, o de todas
las cadenas si no se especifica ninguna.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-Z [cadena]</term>
<listitem><para>
Establece a cero los contadores de datagramas y bytes de la
cadena especificada, o de todas las cadenas si no se especifica
ninguna.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-N cadena</term>
<listitem><para>
Crea una nueva cadena con el nombre especificado. No puede existir
una cadena con el mismo nombre. Así es como se crean las cadenas
de usuario.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-X [cadena]</term>
<listitem><para>
Elimina la cadena de usuario especificada, o todas
las cadenas de usuario especificadas si no se especifica
ninguna cadena. Para que esta orden tenga éxito, no deben existir
referencias de ninguna otra cadena de reglas a la cadena especificada.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-P política_de_cadena</term>
<listitem><para>
Establece la política por defecto de la cadena especificada a la
política especificada. Las políticas de cortafuegos válidas son
<literal>ACCEPT</literal>,
<literal>DENY</literal>,
<literal>REJECT</literal>,
<literal>REDIR</literal>, o
<literal>RETURN</literal>. <literal>ACCEPT</literal>,
<literal>DENY</literal>, y <literal>REJECT</literal>
tienen los mismo significados que las políticas correspondientes de la
implentación tradicional del cortafuegos de IP.
<literal>REDIR</literal> especifica que se debe
redirigir de forma transparente el datagrama a un puerto del
'host' del cortafuegos. 
La política
<literal>RETURN</literal>
causa que el código del cortafuegos de IP vuelva a la
cadena de cortafuegos que hizo la llamada a la que contiene esta
regla y que continúe empezando por la regla situada tras la regla que hizo
la llamada.
</para></listitem>
</varlistentry>
</variablelist>

</para>
</sect3>

<sect3 id="X-087-2-firewall.ipchains.rulespec"><title>Parámetros de especificación de las reglas</title>
<para>
Ciertos parámetros de
<command>ipchains</command> crean una especificación de reglas
al determinar qué tipos de paquetes coinciden.
Si se omite algunos de esos parámetros de la especificación
de una regla, se asumen sus valores por omisión.
</para>

<variablelist>
<varlistentry>
<term>-p [!]protocolo</term>
<listitem><para>
Especifica el protocolo del datagrama que buscar coincidencias coná con esta regla.
Los protocolos válidos son:
<literal>tcp</literal>, <literal>udp</literal>,
<literal>icmp</literal>, o <literal>todos</literal>.
También puede especificarse un número de protocolo para buscar coincidencias con
con otros protocolos.
Por ejemplo, se puede utilizar el
<literal>4</literal> para buscar coincidencias con
el protocolo de encapsulamiento
<literal>ipip</literal>. Si se proporciona el signo
<literal>!</literal>, entonces la regla es negativa
y el datagrama buscar coincidencias coná con cualquier protocolo que
no sea el especificado.
Si no se especifica este parámetro, se asumirá por omisión el
valor
<literal>all</literal>.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-s [!]dirección[/máscara] [!] [puerto]</term>
<listitem><para>
Especifica la dirección de origen y el puerto del datagrama
que buscar coincidencias coná con este regla. La dirección puede proporcionarse
como un nombre de 'host', un nombre de red o una dirección de IP.
El argumento opcional <literal>máscara</literal> es la
máscara de red que se utilizará y puede ser proporcionada en
la forma tradicional (e.g.,/255.255.255.0)
o en la forma moderna (e.g., /24). El argumento opcional
<literal>puerto</literal>
especifica el puerto de TCP o UDP, o el tipo de datagrama de ICMP
que buscar coincidencias coná. Se puede proporcionar una especificación de
puerto sólamente si se ha proporcionado el párametro
<option>-p</option> con uno de los protocolos
<literal>tcp</literal>, <literal>udp</literal>, o
<literal>icmp</literal>. Se puede
especificar los puertos en la forma de un rango,
especificando los límites inferior y superior con el signo <literal>:</literal>
como delimitador. Por ejemplo,
<literal>20:25</literal> describe todos los puertos que van desde el
20 hasta el 25 incluyendo ambos. De nuevo,
el signo <literal>!</literal> puede utilizarse para negar los valores.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-d [!]dirección[/máscara] [!] [puerto]</term>
<listitem><para>
Especificar la dirección y el puerto de destino del datagrama que
buscar coincidencias coná con esta regla. La codificación de este parámetro es la
misma que la del parámetro
<option>-s</option>.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-j blanco</term>
<listitem><para>
Especifica la acción que se tomará cuando se coincida con esta regla.
Puede pensarse en este parámetro como con el significado de
&ldquo;salta a.&rdquo; 
Los blancos válidos son en principio las políticas
<literal>ACCEPT</literal>, <literal>DENY</literal>, <literal>REJECT</literal>,
<literal>REDIR</literal>, y <literal>RETURN</literal>.
Se describieron sus significados más arriba. Sin embargo,
también puede proporcionarse el nombre de una cadena 
de usuario, y será por donde el proceso continuará.
Si se omite este parámetro, no se tomará ninguna acción sobre
los datagramas coincidentes con la regla exceptuando la actualización de
los contadores de datagrams y de bytes.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-i [!]nombre_de_interfaz</term>
<listitem><para>
Especifica la interfaz por la que se recibió  o va a transmitirse el datagrama.
De nuevo, el signo
<literal>!</literal> invierte el resultado de la coincidencia.
Si el nombre de la interfaz acaba con un signo
<literal>+</literal> entonces cualquier interfaz que comience con
la cadena proporcionada buscar coincidencias coná. Por ejemplo,
<literal>-i ppp+</literal> buscar coincidencias coná con cualquier dispositivo de
red de PPP y
<literal>-i ! eth+</literal> con todas las interfaces excepto
las correspondientes a dispositivos de Ethernet.
</para></listitem>
</varlistentry>

<varlistentry>
<term>[!] -f</term>
<listitem><para>
Especifica que esta regla se aplica a todo excepto al primer fragmento
del un datagrama fragmentado.
</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="X-087-2-firewall.ipchains.options"><title>Opciones</title>
<para>
Las siguientes opciones de
<command>ipchains</command> son más generales por naturaleza propia.
Algunas de ellas controlan características bastante esotéricas
del 'software' de 'IP Chains':

<variablelist>
<varlistentry>
<term>-b</term>
<listitem><para>
Fuerza a que la orden genere dos reglas. Una ajusta el
parámetro proporcionado y la otra regla añadida coincide
con los parámetros en el sentido contrario.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-v</term>
<listitem><para>
Causa que <command>ipchains</command> sea más explícito en
su salida. Proporcionará más información.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-n</term>
<listitem><para>
Causa que 
<command>ipchains</command> muestre las direcciones de IP y los números
de puertos en forma de números sin intentar resoverlos contra sus
correspondientes nombres.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-l</term>
<listitem><para>
Habilita el registro del núcleo de los datagramas coincidentes.
Cualquier datagrama que coincida con la regla será registrado
por el núcleo utilizando su función
<function>printk</function>,
con lo que este registro será gestionado habitualmente por el programa
<command>sysklogd</command> y escrito a un fichero de registro. 
Esto resulta muy útil para hacer visibles datagramas poco usuales.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-o[tamaño_máximo]</term>
<listitem><para>
Causa que el 'software' de 'IP Chains' copie cualquier datagrama
coincidente con la regla al dispositivo
&ldquo;netlink&rdquo; del espacio de usuarios.
El argumento de tamaño_máximo limita el número de bytes que se pasarán
desde cada datagrama al dispositivo netlink.
Esta opción resulta de la mayor utilidad para los desarrolladores
de 'software', pero puede que sea aprovechada por paquetes
de 'software' en el futuro.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-m valor_de_marca</term>
<listitem><para>
Causa que los datagramas coincidentes sean
<emphasis>marcados</emphasis> con un valor. Los valores de las marcas
son números de 32 bits sin signo. En las implementaciones actuales esto
no hace nada, pero en algún momento en el futuro puede que sirvan para
determinar cómo otro 'software', como un código de encaminamiento,
tratará al datagrama. Si un valor de una marca comienza con el signo
<literal>+</literal> o con el signo
<literal>-</literal>, el valor se añade o se substrae del valor actual
de la marca.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-t máscara_and máscara_xor</term>
<listitem><para>
Le permite manipular los bits del
&ldquo;tipo de servicio&rdquo; de la cabecera de IP de cualquier
datagrama que coincida con esta regla. Los bits de tipo de servicio son
utilizados por los encaminadores inteligentes para gestionar la prioridad
de los datagramas antes de reenviarlos. El software de encaminamiento
de GNU/Linux es capaz de realizar este tipo de asignación de prioridades.
La
<replaceable>máscara_and</replaceable> y la
<replaceable>máscara_xor</replaceable>
representar máscaras de bits con las que se realizarán respectivamente
un AND lógico o un OR lógico con los bits del tipo de servicio del 
datagrama. Esto constituye una característica avanzada que se discute con más
detalle en el IPCHAINS-HOWTO.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-x</term>
<listitem><para>
Fuerza que los números de salida de
<command>ipchains</command> aparezcan con sus valores exactos
sin ninguna aproximación.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-y</term>
<listitem><para>
Causa que la regla coincida con cualquier datagrama de TCP
cuyo bit SYN valga 1 y los bits ACK y FIN lleven un valor de 0.
Esto se utiliza para filtrar las peticiones de conexión de TCP.
</para></listitem>
</varlistentry>
</variablelist>

</para>
</sect3>
<INDEXTERM startref="ipchains.firewall.options" class=endofrange>
</sect2>

<sect2 id="X-087-2-firewall.simpleexample.again"><title>Nuestro ejemplo simple revisado</title>
<para>
Vamos de nuevo a suponer que se dispone de una red en nuestra organización
y que se utiliza una máquina cortafuegos basada en GNU/Linux para permitir
a nuestros usuarios el acceso a servidores de WWW en Internet, y para
impedir cualquier otro tipo de tráfico. 
</para>

<para>r
Si nuestra red tiene una máscara de red de 24 bits (clase C) y
tiene como dirección 172.16.1.0, 
podrían utilizarse las siguientes reglas de
<command>ipchains</command>:

<screen width=80>
<prompt>#</prompt> <userinput>ipchains -F forward</userinput>
<prompt>#</prompt> <userinput>ipchains -P forward DENY</userinput>
<prompt>#</prompt> <userinput>ipchains -A forward -s 0/0 80 -d 172.16.1.0/24 -p tcp -y -j DENY</userinput>
<prompt>#</prompt> <userinput>ipchains -A forward -s 172.16.1.0/24 -d 0/0 80 -p tcp -b -j ACCEPT</userinput>
</screen>
</para>

<para>
La primera de las órdenes borra todas las reglas del conjunto de reglas
<literal>forward</literal> y el segundo
establece la política predeterminada del conjunto de reglas
<literal>forward</literal>
a <literal>DENY</literal>. 
Por último, la tercera y cuartas órdenes establecen el filtrado
específico que se desea. La cuarta orden permite que pasen los datagramas
que provengan de o vayan a los servidores web de fuera de nuestra
red, y la tercera red impide las conexiones entrantes de TCP con
un puerto de origen igual a 80.
</para>

<para>
Si ahora se desea añadir reglas que permitan el modo pasivo sólo
como modo de acceso a los servidores de FTP de fuera de nuestra
red, se añadirían estas reglas:

<screen width=80>
<prompt>#</prompt> <userinput>ipchains -A forward -s 0/0 20 -d 172.16.1.0/24 -p tcp -y -j DENY</userinput>
<prompt>#</prompt> <userinput>ipchains -A forward -s 172.16.1.0/24 -d 0/0 20 -p tcp -b -j ACCEPT</userinput>
<prompt>#</prompt> <userinput>ipchains -A forward -s 0/0 21 -d 172.16.1.0/24 -p tcp -y -j DENY</userinput>
<prompt>#</prompt> <userinput>ipchains -A forward -s 172.16.1.0/24 -d 0/0 21 -p tcp -b -j ACCEPT</userinput>
</screen>
</para>
</sect2>

<sect2 id="X-087-2-firewall.listing.again"><title>Listado de nuestras reglas con ipchains</title>
<para>
<indexterm><primary>orden ipchains</primary><secondary>listado de reglas por</secondary></indexterm>
Para mostrar nuestras reglas con
<command>ipchains</command>, se utiliza su argumento 
<option>-L</option>. 
De igual forma que con <command>ipfwadm</command>, existen
argumentos que controlan el grado de detalle de la salida. En su forma
simple, <command>ipchains</command> produce una salida que se parece a ésta:

<screen width=80>
<prompt>#</prompt> <userinput>ipchains -L -n</userinput>
Chain input (policy ACCEPT):
Chain forward (policy DENY):
target     prot opt     source              destination         ports
DENY       tcp  -y----  0.0.0.0/0           172.16.1.0/24       80 ->   *
ACCEPT     tcp  ------  172.16.1.0/24       0.0.0.0/0           * ->   80
ACCEPT     tcp  ------  0.0.0.0/0           172.16.1.0/24       80 ->   *
ACCEPT     tcp  ------  172.16.1.0/24       0.0.0.0/0           * ->   20
ACCEPT     tcp  ------  0.0.0.0/0           172.16.1.0/24       20 ->   *
ACCEPT     tcp  ------  172.16.1.0/24       0.0.0.0/0           * ->   21
ACCEPT     tcp  ------  0.0.0.0/0           172.16.1.0/24       21 ->   *

Chain output (policy ACCEPT):
</screen>
</para>

<para>
Si no se proporciona el nombre de la cadena que se desea mostrar,
<command>ipchains</command> mostrará todas las reglas de todas
las cadenas.
El argumento <literal>-n</literal> de nuestro ejemplo le dice a
<command>ipchains</command>
que no intente convertir ninguna dirección ni puerto en nombres.
La información que presenta debería ser auto-explicativa.
</para>

<para>
Un formato de salida más explícito, que se invoca con la opción
<option>-u</option>, proporciona mucho más detalle. 
Esta salida añade campos para los contadores de bytes y de datagramas,
el tipo de servicio, los identificadores
<emphasis>AND</emphasis> y <emphasis>XOR</emphasis>, 
el nombre de la interfaz, la marca, y el tamaño de la salida.
</para>

<para>
Todas las reglas creadas con 
<command>ipchains</command>
tienen contadores de datagramas y bytes asociadas con ellas.
Así es cómo se implementa la auditoría de IP y se discutirá 
con detalle en
<xref
linkend="X-087-2-accounting">.
Por defecto, estos contadores se presentan de forma aproximada
utilizando los sufijos
<literal>K</literal> y
<literal>M</literal>, que representan las unidades de mil
y de millón, respectivamente.
Si se proporciona el argumento <literal>-x</literal>, 
entonces se muestran los contadores en su forma completa y expandida.
</para>
</sect2>

<sect2 id="X-087-2-firewall.ipchainsyay"><title>Uso avanzado de las cadenas</title>
<para>
Usted ya sabe que la orden
<command>ipchains</command>
sustituye a la orden
<command>ipfwadm</command> con una sintaxis de línea de órdenes
más simple y con algunas mejoras interesantes, pero sin duda alguna,
usted desea saber dónde y por qué se deben utilizar las cadenas de
usuario.
Probablemente, también desee saber cómo utilizar los guiones de soporte
que acompañan a la orden 
<command>ipchains</command> en su paquete de 'software'.
Se investigarán a continuación estas materias y se dará respuesta a esas
cuestiones.
</para>

<sect3><title>Cadenas de usuario</title>
<para>
<INDEXTERM id="firewalls.userdef.chains" class=startofrange><PRIMARY>cortafuegos</PRIMARY><SECONDARY>cadenas definidas por el usuario</SECONDARY></INDEXTERM>
<INDEXTERM id="chains.userdefined" class=startofrange><PRIMARY>cadenas</PRIMARY>
<SECONDARY>definidas por usuario</SECONDARY></INDEXTERM>
Los tres conjuntos de reglas del código del cortafuegos de IP
tradicional proporcionan un mecanismo para construir configuraciones
de cortafuegos que eran bastante simples de entender y de
gestionar en el caso de pequeñas redes con requisitos
simples en cuanto a funcionalidad de cortafuegos. Cuando
los requisitos de configuración no son tan simples, aparecen
numerosos problemas. En primer lugar, las redes muy grandes
requieren con frecuencia un número mucho mayor de reglas
de cortafuegos que el pequeño que hemos visto hasta ahora;
de forma inevitable, aparecen necesidades que requieren que se
añadan reglas de cortafuegos para cubrir escenarios con casos
especiales. Cuando el número de reglas empieza a crecer,
el rendimiento del cortafuegos disminuye más y más según
más y más comprobaciones tienen que realizarse sobre cada
datagrama y la facilidad de gestión se convierte en un
asunto importante. En segundo lugar, no es posible habilitar
y deshabilitar conjuntos de reglas atómicamente; en cambio,
usted se encontrará inevitablemente expuesto a ataques mientras
se encuentre en medio de una reconstrucción de sus conjuntos
de reglas.

</para>

<para>
El diseño del cortafuegos 'IP Chains' ayuda a soliviantar estos problemas
al permitir al administrador de la red crear conjuntos arbitrarios de
reglas de cortafuegos que se pueden enlazar con los tres conjuntos
de reglas predefinidas. Se puede utilizar la opción
<option>-N</option> de <command>ipchains</command> para crear
una nueva cadena con el nombre de ocho caracteres o menos que nos plazca.
(Probablemente sea buena idea restringir el nombre a uno formado
por minúsculas solamente). La opción
<option>-j</option>
configura la acción que se tomará cuando el datagrama coincida 
con la especificación
de la regla.
La opción
<option>-j</option> especifica que si un datagrama coincide con una regla,
entonces deben realizarse más comprobaciones contra una cadena
definida por usuario. Se ilustrará esto con un diagrama.
</para>

<para>
Considérese las siguientes órdenes de
<command>ipchains</command>:

<screen width=80>
ipchains -P input DENY
ipchains -N tcpin
ipchains -A tcpin -s ! 172.16.0.0/16
ipchains -A tcpin -p tcp -d 172.16.0.0/16 ssh -j ACCEPT
ipchains -A tcpin -p tcp -d 172.16.0.0/16 www -j ACCEPT
ipchains -A input -p tcp -j tcpin
ipchains -A input -p all
</screen>
</para>

<para>
Se establece la política por defecto de la cadena de entrada a
<literal>deny</literal>. La segunda orden
crea una cadena de usuario denominada
&ldquo;tcpin.&rdquo; La tercera orden añade una regla
a la cadena
<literal>tcpin</literal>
que coincide con cualquier datagrama cuyo origen esté fuera de nuestra
red; la regla no representa ninguna acción. Esta regla es una regla
de auditoría que se discutirá con más detalle en
<xref linkend="X-087-2-accounting">. Las dos reglas
siguientes coinciden con cualquier datagrama destinado
a nuestra red local tanto al puerto de
<literal>ssh</literal> como al de <literal>www</literal>; los datagramas
que coincidan con estas reglas son aceptados. La
magia de <emphasis>ipchains</emphasis> empieza en la regla siguiente.
Obliga al 'software' del cortafuegos a que compruebe
cualquier datagrama del protocolo de TCP contra la cadena
de usuario <literal>tcpin</literal>.
Por último, se añade una regla a la cadena
<literal>input</literal> que coincide con cualquier datagrama;
esto es otra regla de auditoría.
Todo esto producirá la cadenas de cortafuegos mostradas en
la Figure 9-4.
</para>

<figure id="X-087-2-firewall.ipchains" float=0>
<title>Un conjunto simple de reglas de una cadena de IP</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0904" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0904.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<para>
Nuestras cadenas
<literal>input</literal> y <literal>tcpin</literal> están pobladas
con nuestras reglas. El procesamiento de los datagramas siempre
comienza por una de las cadenas predefinidas... Veamos cómo
entran en juego las cadenas de usuario siguiendo el
camino de procesamiento de los diferentes tipos de datagramas.
</para>

<para>
Primero, veamos qué pasa cuando se recibe un datagrama de UDP para uno de nuestros
'hosts'. La
<xref linkend="X-087-2-firewall.ipchains.udp"> ilustra el flujo
por las reglas.
</para>

<figure id="X-087-2-firewall.ipchains.udp" float=0>
<title> La secuencia de reglas de comprobación de un datagrama de UDP recibido
	</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0905" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0905.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<para>
El datagrama se recibe por la cadena
<literal>input</literal> y cae dentro de las dos reglas porque
coinciden con los protocolos de ICMP y TCP, respectivamente.
Coincide con la tercera regla en la cadena,
pero no se especifica ningún blanco por lo que los contadores
de datagramas y bytes se actualizan pero se toma ninguna otra
acción. El datagrama alcanza el final de la cadena
<literal>input</literal>,
se encuentra con la política predeterminada de la cadena
<literal>input</literal> y no se acepta.
</para>

<para>
Para ver a nuestra cadena de usuario en acción,
considérese qué pasa cuando se recibe un datagrama de TCP
destinado al puerto
<literal>ssh</literal> de uno de nuestros 'hosts'. La secuencia
se muestra en la
<xref linkend="X-087-2-firewall.ipchains.tcp.ssh">.
</para>

<figure id="X-087-2-firewall.ipchains.tcp.ssh" float=0>
<title>Flujo de reglas para un datagrama de TCP recibido para ssh</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0906" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0906.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<para>
Esta vez, la segunda regla de la cadena
<literal>input</literal> coincide y especifica como blanco
la cadena
<literal>tcpin</literal>, nuestra cadena de usuario.
Especificar una cadena de usuario como blanco causa que se
compruebe el datagrama contra las reglas de esa cadena, por lo que
la siguiente regla que se comprobará será la primera regla de la
cadena
<literal>tcpin</literal>. 
La primera regla coincide con cualquier datagrama que tenga una
dirección de origen fuera de nuestra red local y no especifica
ningún blanco, por lo que también es una regla de auditoría
y la comprobación pasa a la siguiente regla. La segunda
regla de nuestra cadena <literal>tcpin</literal> sí que coincide
y especifica un blanco de
<literal>ACCEPT</literal>. 
Se ha llegado a un blanco tal que no se realiza más procesamiento.
El datagrama se acepta.
</para>

<para>
Por último, veamos lo que pasa cuando se
alcanza el final de una cadena de usuario. Para ver esto,
se representará el flujo de un datagrama de TCP destinado
a un puerto distinto de los dos que estamos manejando
específicamente, como se muestra en la
<xref linkend="X-087-2-firewall.ipchains.tcp.other">.
</para>

<figure id="X-087-2-firewall.ipchains.tcp.other" float=0>
<title>Flujo de reglas para un datagra de TCP recibido para telnet</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0907" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0907.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<para>
Las cadenas de usuario no tienen políticas por defecto. Cuando se han
comprobado todas
las reglas de una cadena de usuario , y ninguna coincide,
el código del cortafuegos actúa como si estuviera presente una regla de
<literal>RETURN</literal>, por lo que si no es esto lo que usted
desea, debe asegurarse de proporcionar una regla al final de
la cadena de usuario que tome la acción que desee.
En nuestro ejemplo, la comprobación vuelve a la regla del conjunto
de reglas
<literal>input</literal> situando inmediatamente después de
la que nos movió a la cadena de usuario.
En algún momento, se alcanza el final de la cadena
<literal>input</literal>, que tiene una política predeterminada
y no se acepta el datagrama.
</para>

<para>
Este ejemplo era muy simple, pero sirve de ilustración. Un uso más práctico
de 'IP chains' sería mucho más complejo. Un ejemplo un poco más sofisticado
es el proporcionado con la siguiente lista de órdenes:
</para>

<programlisting id="X-087-2-firewall.ipchains.example" width=80>
#
# Establece la política de reenvío por defecto a REJECT
ipchains -P forward REJECT
#
# crea nuestras cadenas de usuario
ipchains -N sshin
ipchains -N sshout
ipchains -N wwwin
ipchains -N wwwout
#
# Se asegura de que se rechazarán las conexiones provenientes por el camino incorrecto.
ipchains -A wwwin -p tcp -s 172.16.0.0/16 -y -j REJECT
ipchains -A wwwout -p tcp -d 172.16.0.0/16 -y -j REJECT
ipchains -A sshin -p tcp -s 172.16.0.0/16 -y -j REJECT
ipchains -A sshout -p tcp -d 172.16.0.0/16 -y -j REJECT
#
# se asegura que lo que alcance el final de una cadena de usuario se rechaza
ipchains -A sshin -j REJECT
ipchains -A sshout -j REJECT
ipchains -A wwwin -j REJECT
ipchains -A wwwout -j REJECT
#
# dirige los servicios de www y ssh a las cadenas de usuario relevantes
ipchains -A forward -p tcp -d 172.16.0.0/16 ssh -b -j sshin
ipchains -A forward -p tcp -s 172.16.0.0/16 -d 0/0 ssh -b -j sshout
ipchains -A forward -p tcp -d 172.16.0.0/16 www -b -j wwwin
ipchains -A forward -p tcp -s 172.16.0.0/16 -d 0/0 www -b -j wwwout
#
# Inserta nuestras reglas para buscar coincidencias con los 'hosts' en la segunda posición de
# nuestras cadenas de usuario.
ipchains -I wwwin 2 -d 172.16.1.2 -b -j ACCEPT
ipchains -I wwwout 2 -s 172.16.1.0/24 -b -j ACCEPT
ipchains -I sshin 2 -d 172.16.1.4 -b -j ACCEPT <?troff .ne 10>
ipchains -I sshout 2 -s 172.16.1.4 -b -j ACCEPT
ipchains -I sshout 2 -s 172.16.1.6 -b -j ACCEPT
#
</programlisting>

<para>
En este ejemplo, se ha utilizado una selección de cadenas
de usuario tanto para simplificar la gestión de la configuración
de nuestro cortafuegos como para mejorar su eficiencia en
comparación a una solución que involucrara sólo las cadenas
predefinidas.
</para>

<para>
Nuestro ejemplo crea cadenas de usuario para cada uno de los
servicios de
<literal>ssh</literal> y <literal>www</literal> en cada
sentido de la conexión. La cadena denominada
<literal>wwwout</literal> es donde se colocan las reglas
para los 'hosts' que tienen permisos para realizar 
conexiones de World Wide Web salientes, y
<literal>sshin</literal> es donde se definen las reglas
para los 'hosts' a los que se desea permitir las conexiones entrantes
de ssh. Se asume que tenemos los requisitos de permitir
o denegar a 'hosts' individuales de nuestra red la capacidad
de empezar o recibir conexiones de
<literal>ssh</literal> y <literal>www</literal>. 
La simplificación existe porque las cadenas de usuario nos permiten
de forma clara agrupar las reglas para los permisos de entradas y
salidas a los 'hosts' en vez de tenerlas todas revueltas. La mejora
en la eficiencia se debe a que se ha reducido el número medio de
comprobaciones requeridas sobre cualquier datagrama antes de que
se encuentre un blanco. La ganancia de eficiencia aumenta conforme
se añaden más 'hosts' Si no se hubiera utilizado cadenas de usuario,
se tendría que buscar por la lista completa de reglas para determinar
qué acción se toma con cada datagrama que se recibe.
Incluso si se asume que cada una de las reglas de nuestra lista
coincide con una proporción igual del número total de datagramas
procesados, aún así estaríamos buscando en la mitad de la lista
en promedio. Las cadenas de usuario nos permiten evitar la
comprobación de números
grandes de reglas si el datagrama que se comprueba no coincide
con la regla simple en la cadena predeterminada a la que ha saltado.
</para>
<INDEXTERM startref="firewalls.userdef.chains" class=endofrange>
<INDEXTERM startref="chains.userdefined" class=endofrange>
</sect3>

<sect3><title>Los guiones de soporte de ipchains</title>
<para>
<INDEXTERM><PRIMARY>orden ipchains</PRIMARY><SECONDARY>guiones de soporte</SECONDARY></INDEXTERM>
El paquete de 'software' de
<command>ipchains</command> se proporciona con tres guiones de soporte.
El primero de ellos ya se ha discutido brevemente, mientras que los
dos restantes proporcian un método sencillo y conveniente de
guardar y recuperar la configuración de su cortafuegos.
</para>

<para>
<indexterm><primary>orden ipfwadm-wrapper</primary></indexterm>
El guión
<command>ipfwadm-wrapper</command> emula la sintaxis
de la línea de órdenes de la orden
<command>ipfwadm</command>, pero utiliza la orden
<command>ipchains</command> para construir las reglas del cortafuegos.
Esto es una forma conveniente de realizar la migración de la configuración
existente
de su cortafuegos o una alternativa al aprendizaje de la sintaxis
de
<command>ipchains</command>. El guión 
<command>ipfwadm-wrapper</command>
se comporta de forma diferente de la orden
<command>ipfwadm</command> en dos cosas: en primer lugar,
porque la orden
<command>ipchains</command> no soporta la especificación de una
interfaz por su dirección, el guión
<command>ipfwadm-wrapper</command> acepta el argumento
<option>-V</option> pero intenta convertirlo en el equivalente en
<command>ipchains</command> de
<option>-W</option> buscando el nombre del interfaz configurado
por la dirección proporcionada. El guión
<command>ipfwadm-wrapper</command> le dará siempre un aviso
cuando utilice la opción
<option>-V</option> con el propósito de recordarle todo esto.
En segundo lugar, las reglas de auditoría de los fragmentos
no se traducen adecuadamente.
</para>

<para>
<INDEXTERM><PRIMARY>cortafuegos</PRIMARY><SECONDARY>IP chains</SECONDARY><TERTIARY>recuperar/guardar</TERTIARY></INDEXTERM>
<indexterm><primary>orden ipchains-save</primary></indexterm>
<indexterm><primary>orden ipchains-restore</primary></indexterm>
Los guiones <command>ipchains-save</command> e <command>ipchains-restore</command>
convierten la tarea de construir y modificar la configuración del
cortafuegos en una tarea mucho más simple.
La orden
<command>ipchains-save</command> lee la configuración actual y la escribe
de forma simplificada por la salida estándar. La orden
<command>ipchains-restore</command> 
lee datos con el formato de la salida de la orden
<command>ipchains-save</command> y configura el
cortafuegos de IP con esas reglas.
La ventaja de utilizar estos guiones en vez de modificar directamente
el guión de configuración de su cortafuegos y probar la nueva configuración
consiste en la capacidad de construir dinámicamente su configuración una vez y
entonces guardarla. Entonces usted puede recuperar esa configuración,
modificarla, y volverla a guardar si así lo desea.
</para>

<para>
Para utilizar los guiones, se introduciría algo como:

<screen width=80>
<userinput><command>ipchains-save</command> &gt;/var/state/ipchains/firewall.state</userinput>
</screen>

para guardar la configuración actual de su cortafuegos. Usted la recuperaría,
quizás en el momento de arranque del sistema, con:

<screen width=80>
<userinput><command>ipchains-restore</command> &lt;/var/state/ipchains/firewall.state</userinput>
</screen>
</para>

<para>
El guión 
<command>ipchains-restore</command> comprueba si ya existe
cualquiera de las cadenas de usuarios especifica en su entrada.
Si se proporciona el argumento
<literal>-f</literal>,
entonces y de forma automáticaa, el guión borrará las reglas de la cadena
de usuario antes de configurar las de la entrada. El comportamiento
por defecto es que se le pregunte si desea saltarse esta cadena o
inicializarla.
</para>

</sect3>

</sect2>
<INDEXTERM startref="firewall.ip.chains" class=endofrange>
<INDEXTERM startref="ip.firewall.chains" class=endofrange>
<INDEXTERM startref="chains.IP.firewall" class=endofrange>
<INDEXTERM startref="Linux.2.2.kernels" class=endofrange>
</sect1>

<sect1 id="X-087-2-firewall.future"><title>Netfilter e 'IP Tables' (Núcleos 2.4)</title>
<INDEXTERM id="firewalls.netfilter" class=startofrange><PRIMARY>cortafuegos</PRIMARY><SECONDARY>netfilter</SECONDARY></INDEXTERM>
<INDEXTERM id="Linux.2.4.kernels" class=startofrange><PRIMARY>núcleos 2.4</PRIMARY><SECONDARY>netfilter and IP tables</SECONDARY></INDEXTERM>
<INDEXTERM id="netfilter.IP.tables" class=startofrange><PRIMARY>netfilter</PRIMARY><SECONDARY>IP tables and</SECONDARY></INDEXTERM>
<para>
Mientras desarrollaba el cortafuegos 'IP Chains', Paul Russell decidió
que realizar funciones de cortafuegos de IP debería ser algo menos difícil;
pronto asumió como tarea simplificar los aspectos de procesamiento
de datagramas en el código de cortafuegos del núcleo y produjo
un esquema de filtrado que era mucho más claro y mucho más flexible.
Denominó este nuevo esquema
<emphasis>netfilter</emphasis>.
</para>

<note><para>
En el momento de la preparación de este libro, el diseño
de
<emphasis>netfilter</emphasis> no está todavía estable.
Esperamos que perdone cualquier error en la descripción de
<emphasis>netfilter</emphasis> o de cualquiera de las herramientas
de configuración asociadas que sea debido a cambios ocurridos
tras la preparación de este material. Consideramos el trabajo
realizado sobre
<emphasis>netfilter</emphasis> suficientemente importante
como para justificar la inclusión de este material, pese a que
partes de él sean especulativas por sí mismas. Si tiene alguna
duda, los documentos HOWTO correspondientes contendrán
la información más precisa y actualizada sobre los detalles
asociados con la configuración de
<emphasis>netfilter</emphasis>.
</para></note>

<para>
Pero, ¿qué era lo que no estaba bien con las cadenas de IP de ipchains ?
Habían aumentado de forma importante la eficiencia y la gestión de las
reglas del cortafuegos. Pero la forma que tenían de procesar los datagramas
eran todavía complejas, en especial en conjunción con
características relacionadas con las funciones de cortafuegos como
el enmascaramiento de IP (discutido en el
<xref
linkend="X-087-2-ipmasq">) y con otras formas de traducciones
de direcciones. Parte de esta complejidad era debida a que
el enmascaramiento de IP y la traducción de direcciones
de red
<footnote id="X-087-2-FW-TFN17">
<para> N. del T.: 'Network Address Translation' en el original en inglés
</para>
</footnote>
fueron funciones desarrolladas independientemente del código
de cortafuegos e integradas más tarde, en vez de haber sido
diseñadas como partes mismas del código del cortafuegos
desde el principio. Si un desarrollador deseara añadir todavía
más características a la secuencia de procesamiento de datagramas,
entonces se encontraría con dificultades para encontrar el lugar
donde insertar el código y se habría visto obligado a realizar
cambios en el núcleo.
</para>

<para>
Además, había otros problemas. En concreto, la cadena
&ldquo;input&rdquo; describía la entrada a 
la capa de red de IP tomada en conjunto. La cadena
input afectaba tanto a los datagramas que estaban
<emphasis>destinados a</emphasis> este 'host' así como
los datagramas que iban a ser
<emphasis>encaminados</emphasis>. 
Esto resulta contrario a la intuición porque se confundía
la función de la cadena 'input' con la de la cadena 'forward',
que se aplicaba sólo a los datagramas que iban a ser reenviados,
pero que siempre seguía a la cadena 'input'. Se se quería
tratar de forma diferente los datagramas para el propio 'host' de
los que iban a ser reenviados, era necesario construir reglas
complejas que excluían a unos o a otros. El mismo problema
aparecía con la cadena &ldquo;output&rdquo; de salida.
</para>

<para>
Esta complejidad influía de forma inevitable en el trabajo
del administrador de sistemas porque se veía reflejada en
la forma en que se debían diseñar los conjuntos de reglas.
Además, cualquier extensión al proceso de filtrado exigía
la modificación directa del núcleo, porque todas las
políticas de filtrados estaban implementadas allí y no
había forma de proporcionar una interfaz transparente.
<emphasis>netfilter</emphasis> aborda
tanto la complejidad como la rigidez de las soluciones
antiguas implementando un esquema genérico en el núcleo
que simplifica la forma en que se procesan los 
datagramas y proporciona la posibilidad de extender
las políticas de filtrado sin tener que modificar
el núcleo.
</para>

<para>
<INDEXTERM><PRIMARY>datagramas</PRIMARY><SECONDARY>IP chains frente a netfilter</SECONDARY></INDEXTERM>
Veamos dos de los cambios claves realizados.
La <xref
linkend="X-087-2-firewall.routing.ipchains"> 
ilustra cómo se procesan los datagramas en la implementación
de 'IP Chains',
mientras que
<xref
linkend="X-087-2-firewall.routing.netfilter"> 
ilustra cómo se procesan en la implementación de
<emphasis>netfilter</emphasis>.
La diferencias claves consisten en la eliminación
de la función de enmascaramiento del código central
y de un cambio en la localización de las cadenas
de entrada y de salida. En acompañamiento a 
estos cambios, se creó una herramienta de
configuración nueva y extensible que se denominó
<command>iptables</command>.
</para>

<para>
<?troff .hw irrespective>
<?troff .hw config-urations>
En 'IP Chains' la cadena de entrada se aplica a todos los datagramas
recibidos por el 'host', independientemente de si están destinados
al 'host' local o de si serán encaminados a otro 'host'.
En <emphasis>netfilter</emphasis>,
la cadena 'input' de entrada se aplica
<emphasis>sólamente</emphasis> a los datagramas destinados al 'host' local,
y la cadena 'forward' de reenvío se aplica sólo a los datagramas
destinados a
<emphasis>otro</emphasis> 'host'. 
De forma similar, en 'IP chains', la cadena 'output' de salida
se aplica a todos los datagramas que abadonen el 'host' local,
independientemente de si el datagrama se genera en el 'host' local
o ha sido encaminado desde otro 'host'. En
<emphasis>netfilter</emphasis>,
la cadena 'output' de salida se aplica
<emphasis>sólamente</emphasis>
a los datagramas generados en este 'host' y
no se aplica a los datagramas que están siendo 
encaminados provenientes de otro 'host'. Este cambio por
sí solo ofrece una enorme simplificación de muchas
configuraciones de cortafuegos.
</para>

<figure id="X-087-2-firewall.routing.ipchains" float=1>
<title>Procesamiento de datagramas en 'IP Chains'</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0908" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0908.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<para>
En la <xref linkend="X-087-2-firewall.routing.ipchains">, 
los componentes etiquetados como
&ldquo;demasq&rdquo; y &ldquo;masq&rdquo;
son componentes separados del núcleo que son responsables
del procesamiento de los datagramas enmascarados entrantes y
salientes. Estos componentes han sido reimplementados como
módulos de
<emphasis>netfilter</emphasis>.
</para>

<para>
Considérese el caso de una configuración para la que la política
por defecto para cada una de las cadenas 'input', 'forward' y
'output' es
<literal>deny</literal>.
En 'IP Chains', 
se necesitarían seis reglas para permitir cualquier sesión  a través
del 'host' cortafuegos; dos para cada una de las cadenas
'input, 'forward' y 'output' (una cubriría el camino en un sentido
y la otra en el sentido contrario). Puede imaginarse cómo
esto puede llegar a resultar extremadamente complejo y difícil
de gestionar cuando se mezclan sesiones que pueden ser
encaminadas y sesiones que podrían conectarse al 'host'
local sin que deban ser encaminadas. 'IP chains' le permite
crear cadenas que le simplificarían esta tarea un poco,
pero su diseño no resulta evidente y requiere de un cierto
nivel de experiencia.
</para>

<para>
En la implementación de
<emphasis>netfilter</emphasis>
con <command>iptables</command>, 
esta complejidad desaparece completamente.
Para que se pueda encaminar por
un 'host' cortafuegos un servicio que
se desea prohibir que termine en el propio 'host', 
sólo se necesitan
dos reglas: una para un sentido y otra para el contrario
ambas en la cadena 'forward'. Esto es la forma obvia
de diseñar reglas de cortafuegos, y servirá para
simplificar enormemente el diseño de las configuraciones
del cortafuegos.
</para>

<figure id="X-087-2-firewall.routing.netfilter" float=1>
<title>Cadena de procesamientos de datagramas en 'netfilter'</title>
<mediaobject>
  <imageobject><imagedata fileref="lag2_0909" format="eps"></imageobject>
  <imageobject><imagedata fileref="lag2_0909.jpg" format="jpg"></imageobject>
</mediaobject>
</figure>

<para>
<indexterm><primary>PACKET-FILTERING-HOWTO</primary></indexterm>
<INDEXTERM><PRIMARY>HOWTOs</PRIMARY><SECONDARY>PACKET-FILTERING</SECONDARY></INDEXTERM>
El documento PACKET-FILTERING-HOWTO ofrece una lista
detallada de los cambios que se han realizado, por lo que aquí
nos vamos a centrar en los aspectos más prácticos.
</para>

<sect2><title>Compatibilidad hacia atrás con ipfwadm<?lb> e ipchains</title>
<para>
La flexibilidad notoria de <emphasis>netfilter</emphasis> en GNU/Linux
queda ilustrada por su habilidad para emular las interfaces
<command>ipfwadm</command> e
<command>ipchains</command>. 
La emulación hace un poco más sencilla la transición a la nueva generación
del software de cortafuegos.
</para>

<para>
<INDEXTERM><PRIMARY>netfilter</PRIMARY><SECONDARY>módulos del núcleo</SECONDARY></INDEXTERM>
Los dos módulos de 
<emphasis>netfilter</emphasis>
del núcleo denominados
<filename>ipfwadm.o</filename> e <filename>ipchains.o</filename>
proporcionan la compatibilidad hacia atrás para 
<command>ipfwadm</command> e
<command>ipchains</command>. 
Sólo puede cargarse uno de estos módulos a la vez,
y utilizarlo sólo si el módulo
<filename>ip_tables.o</filename>
no está cargado.
Cuando se ha cargado el módulo apropiado, entonces
<emphasis>netfilter</emphasis> 
funciona exactamente de la misma forma que la anterior implementación
del cortafuegos.
</para>

<para>
<emphasis>netfilter</emphasis>
imita la interfaz de
<command>ipchains</command>
con las siguientes órdenes:

<screen>
rmmod ip_tables
modprobe ipchains
ipchains <replaceable>...</replaceable>
</screen>
</para>
</sect2>

<sect2 id="X-087-2-firewall.usingiptables"><title>Uso de iptables</title>
<para>
<INDEXTERM id="iptables.firewall.options" class=startofrange><PRIMARY>orden iptables</PRIMARY><SECONDARY>opcioines del cortafuegos</SECONDARY></INDEXTERM>
La utilidad
<command>iptables</command> se utiliza para configurar
las reglas de filtrado de
<emphasis>netfilter</emphasis>.
Su sintaxis se apoya fuertemente en la de la orden 
<command>ipchains</command>, pero difiere 
en un aspecto muy importante: es
<emphasis>extensible</emphasis>. 
Esto quiere decir que su funcionalidad puede extenderse sin
tener que recompilar. Consigue este truco utilizando bibliotecas
compartidas. Hay extensiones estándares de las que se explorarán
algunas dentro de un momento.
</para>

<para>
Antes de que se pueda utilizar la orden
<command>iptables</command>, se debe cargar el módulo del núcleo de
<emphasis>netfilter</emphasis> que proporciona el soporte para ello.
La forma más fácil de hacerlo es con la orden
<command>modprobe</command>:

<screen>
modprobe ip_tables
</screen>
</para>

<para>
La orden
<command>iptables</command> se utiliza para configurar
tanto el filtrado de IP como la traducción de direcciones
de red.
Para facilitar esto, existen dos tablas de reglas denominadas
<emphasis>filter</emphasis> y
<emphasis>nat</emphasis>. 
Por defecto, se asume la tabla 'filter' salvo que se especifique la opción
<option>-t</option>. 
También se proporciona cinco cadenas predefinidas.
Las cadenas
<literal>INPUT</literal> y <literal>FORWARD</literal>
están disponibles para la tabla
<literal>filter</literal>, 
las cadenas
<literal>PREROUTING</literal> y <literal>POSTROUTING</literal>
están disponbiles para la tabla
<literal>nat</literal> ,
y la cadena
<literal>OUTPUT</literal> está disponible para ambas tablas.

En este capítulo se discutirá solamente la tabla
<emphasis>filter</emphasis>. 
Se contemplará la tabla <emphasis>nat</emphasis> en el <xref linkend="X-087-2-ipmasq">
</para>

<para>
La sintaxis general de la mayoría de las órdenes 
de <command>iptables</command> es:

<screen>
<command>iptables</command> <replaceable>orden</replaceable> <replaceable>especificación_de_regla</replaceable> <replaceable>extensiones</replaceable>
</screen>

Veamos alguna de las opciones con detalle, y después
se revisarán algunos ejemplos.
</para>

<sect3 id="X-087-2-firewall.iptables.commands"><title>Órdenes</title>
<para>
Existen varias formas de manipular las reglas y los conjuntos
de reglas con la orden
<command>iptables</command>. Las relevantes para
la función de cortafuegos de IP son:

<variablelist>
<varlistentry>
<term>-A cadena</term>
<listitem><para>
Añade una o más reglas al final de la cadena especificada.
Si se proporciona un nombre de 'host' tanto como origen como
destino y se resuelve a más de una dirección IP, se añadirá
una regla por cada una de esas direcciones.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-I cadena número_de_regla</term>
<listitem><para>
Inserta una o más reglas al comienzo de la cadena especificada.
De nuevo, si se proporciona un nombre de 'host' en la especificación
de la regla, se añadirá una regla por cada una de las direcciones
que se resuelvan.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-D cadena</term>
<listitem><para>
Borra de la cadena especificada una o más reglas que coincidan con la
especificación de regla de la cadena especificada.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-D cadena número_de_regla</term>
<listitem><para>
Borra la regla que ocupa la posición
<replaceable>número_de_regla</replaceable> en
la cadena especificada.
Las posiciones de reglas comienzan en el 1 para la primera regla de la
cadena.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-R cadena número_de_regla</term>
<listitem><para>
Reemplaza la regla que ocupa la posición
<replaceable>número_de_regla</replaceable>
en la cadena especificada por la regla
proporcionada en la especificación.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-C cadena</term>
<listitem><para>
Comprueba el datagrama descrito por la especificación de la regla contra
la cadena especificada. Esta orden devolverá un mensaje que 
describe cómo el datagrama procesa la cadena. Resulta de la mayor
utilidad para las pruebas de la configuración del cortafuegos
por lo que se contemplará con más detalle más adelante.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-L [cadena]</term>
<listitem><para>
Muestra las reglas de la cadena especificada, o de todas las cadenas
si no se especifica ninguna.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-F [cadena]</term>
<listitem><para>
Borra todas las reglas de la cadena especificada, o de todas las
cadenas si no se especifica ninguna.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-Z [cadena]</term>
<listitem><para>
Pone a cero los contadores de datagramas y bytes en todas
las reglas de la cadena especificada, o de todas las cadenas
si no se especifica ninguna.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-N cadena</term>
<listitem><para>
Crea una nueva cadena con el nombre especificado.
No puede existir antes una cadena del mismo nombre. Así es cómo
se crean las cadenas de usuario.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-X [cadena]</term>
<listitem><para>
Borra la cadena de usuario especificada, o todas
las cadenas de usuario si no se especifica ninguna.
Para que este comando tenga éxito, no deben existir
referencias a la cadena especificada desde cualquier
otra cadena de reglas.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-P cadena política</term>
<listitem><para>
Establece la política por defecto de la cadena especificada a la
política especificada. Las políticas válidas de cortafuegos
son
<literal>ACCEPT</literal>, <literal>DROP</literal>,
<literal>QUEUE</literal>, y <literal>RETURN</literal>.
<literal>ACCEPT</literal> 
permite pasar a los datagramas.
<literal>DROP</literal>
causa que el datagrama sea descartado. <literal>QUEUE</literal>
causa que el datagrama sea pasado al espacio de usuario para
posterior procesamiento.
La política
<literal>RETURN</literal> causa que el código
del cortafuegos de IP vuelva a la cadena que llamó a la que contenía
esta regla, y que continúe con la regla situada tras la regla desde la que
se hizo la llamada.
</para></listitem>
</varlistentry>
</variablelist>

</para>
</sect3>

<sect3 id="X-087-2-firewall.iptables.rulespec"><title>Parámetros de especificación de reglas</title>
<para>
Existe una serie de parámetros de
<command>iptables</command> que constituyen la especificación
de una regla. Donde se requiera la especificación de una regla,
se debe proporcionar algunos de esos  parámetros o se asumirá
sus valores por defecto.
</para>

<variablelist>
<varlistentry>
<term>-p [!]protocolo</term>
<listitem><para>
Especifica el protocolo del datagrama que buscar coincidencias coná con esta regla.
Los nombres válidos de protocolos son
<literal>tcp</literal>, <literal>udp</literal>,
<literal>icmp</literal>, o un número, si se conoce el
número del protocolo de IP.<footnote id="X-087-2-X-087-2-FW-FN06"><para>
Véase el fichero
<filename>/etc/protocols</filename> para buscar los nombres
y números de los protocolos.
</para>
</footnote>
Por ejemplo, podría utilizarse un
<literal>4</literal> para buscar coincidencias con el protocolo de encapsulamiento
<literal>ipip</literal>.
Si se proporciona el signo<literal>!</literal>, 
entonces se niega la regla y el datagrama buscar coincidencias coná
con cualquier protocolo diferente del especificado.
Si no se proporciona este parámetro, se asume por omisión la
coincidencia con todos los protocolos.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-s [!]dirección[/máscara]</term>
<listitem><para>
Especifica la dirección de origen del datagrama que buscar coincidencias coná con
esta regla. Se puede proporcionar la dirección como un nombre
de 'host', como un nombre de red o como una dirección de IP.
El parámetro opcional
<literal>máscara</literal> es la máscara de red que
se utilizará y puede proporcionarse
tanto en la forma tradicional 
(e.g., /255.255.255.0) como en la forma moderna
(e.g., /24).
</para></listitem>
</varlistentry>

<varlistentry>
<term>-d [!]dirección[/máscara]</term>
<listitem><para>
Especifica la dirección de destino del datagrama
que buscar coincidencias coná con esta regla. La codificación de este parámetro
es la misma que la del parámetro
<option>-s</option>.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-j blanco</term>
<listitem><para>
Especifica qué acción se tomará cuando se coincida con esta regla.
Puede pensarse en este parámetro como con el significado de
&ldquo;salta a&rdquo;.
Los blancos válidos son 
<literal>ACCEPT</literal>, <literal>DROP</literal>, <literal>QUEUE</literal>,
y <literal>RETURN</literal>. 
Se describieron sus significados más
arriba. Sin embargo, también puede proporcionarse el nombre de una cadena
de usuario, que sería por donde el proceso continuaría.
También puede proporcionarse el nombre de un blanco complementado
con el de una extensión. Se hablará acerca de las extensiones en breve.
Si se omite este parámetro, no se realizará ninguna acción sobre
los datagramas coincidentes, excepto la actualización de los
contadores de datagramas y bytes de esta regla.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-i [!]nombre_de_interfaz</term>
<listitem><para>
<?troff .hw separated>
Especifica la interfaz por la que se recibió el datagrama. De nuevo,
el signo
&ldquo;<literal>!</literal> invierte el resultado de la coincidencia.
Si el nombre de la interfaz acaba con un signo 
 &ldquo;<literal>+</literal>&rdquo
entonces cualquier interfaz que comience con la cadena
     proporcionada buscar coincidencias coná. Por ejemplo, 
<literal>-i ppp+</literal>
buscar coincidencias coná con cualquier dispositivo de red de PPP y 
<literal>-i ! eth+</literal>
con todas las
interfaces excepto las correspondientes a dispositivos de Ethernet.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-o [!]nombre_de_interfaz</term>
<listitem><para>
Especifica la interfaz por la que se enviará el datagrama.
Este argumento tiene la misma codificación que el argumento
<option>-i</option>.
</para></listitem>
</varlistentry>

<varlistentry>
<term>[!] -f</term>
<listitem><para>
Especifica que esta regla se aplica al segundo y restantes fragmentos
de un datagrama fragmentado, y no al primer fragmento.
</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="X-087-2-firewall.iptables.options"><title>Opciones</title>
<para>
Las siguientes opciones de
<command>iptables</command>
son más generales por naturaleza propia.
Algunas de ellas controlan características bastante
esotéricas del software de 
<emphasis>netfilter</emphasis>.
</para>

<variablelist>
<varlistentry>
<term>-v</term>
<listitem><para>
Hace que 
<command>iptables</command>
sea más explícito en su salida. Proporcionará más información.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-n</term>
<listitem><para>
Hace que
<command>iptables</command>
muestre las direcciones de IP y los números de puertos en forma de números sin intentar resoverlos contra
sus correspondientes nombres.
</para></listitem>
</varlistentry>

<varlistentry>
<term>-x</term>
<listitem><para>
Fuerza que los números de salida de
<command>iptables</command>
parezcan con sus valores exactos sin ninguna aproximación.
</para></listitem>
</varlistentry>

<varlistentry>
<term>- -line-number</term>
<listitem><para>
Causa que se muestren los números de línea en los listados de
los conjuntos de reglas. El número de línea corresponderá
con la posición de la regla dentro de la cadena.
</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="X-087-2-firewall.iptables.extensions"><title>Extensiones</title>
<para>
<INDEXTERM><PRIMARY>orden iptables</PRIMARY><SECONDARY>extensiones</SECONDARY></INDEXTERM>
Se dijo antes que la utilidad
<command>iptables</command> es extensible a través
de módulos de bibliotecas compartidas. Existen
alguna extensiones estándares que proporciona algunas
de las características que
<command>ipchains</command> proporcionaba.
Para utilizar una extensión, se debe especificar su nombre
con el argumento
<option>-m</option> <replaceable>nombre</replaceable> de
<command>iptables</command>.
La lista siguiente muestra las opciones
<option>-m</option> y <option>-p</option>
que establecen el contexto de la extensión, y las opciones proporcionadas
por esa extensión.
</para>

<sect4><title>Extensiones de TCP: utilizadas con <literal>-m tcp -p tcp</literal></title>
<variablelist>
<varlistentry>
<term>- -sport [!] [puerto[:puerto]]</term>
<listitem><para>
Especifica el puerto que debe utilizar el origen del datagrama para
buscar coincidencias con esta regla.
Se pueden especificar los puertos en la forma de un rango, 
especificando los límites inferior y superior con un signo 
<literal>:</literal> como
delimitador. 
Por ejemplo, <literal>20:25</literal> describe todos los puertos
que van desde el 20 hasta el 25 incluyendo ambos. De nuevo, el signo <literal>!</literal> puede utilizarse para negar los valores.
</para></listitem>
</varlistentry>

<varlistentry>
<term>- -dport [!] [puerto[:puerto]]</term>
<listitem><para>
Especifica el puerto que el datagrama de destino utilizará
para buscar coincidencias con este regla. Este argumento se codifica
de forma idéntica a la opción
<option>- -sport</option>.
</para></listitem>
</varlistentry>

<varlistentry>
<term>- -tcp-flags [!] máscara comp</term>
<listitem><para>
<indexterm><primary>RFC-793</primary></indexterm>
Especifica que esta regla debe buscar coincidencias con cuando los indicadores
de TCP del datagrama coincidan con los especificados por
<replaceable>máscara</replaceable> y
<replaceable>comp</replaceable>. <replaceable>máscara</replaceable>
es una lista separada por comas de los indicadores que deben examinarse
en la comprobación.
<replaceable>comp</replaceable> es una lista separada por comas
de indicadores cuyo valores han de ser todos 1 para que la regla
coincida. Los indicadores válidos son:
<emphasis>SYN</emphasis>, <emphasis>ACK</emphasis>,
<emphasis>FIN</emphasis>, <emphasis>RST</emphasis>,
<emphasis>URG</emphasis>, <emphasis>PSH</emphasis>, <emphasis>ALL</emphasis>
o <emphasis>NONE</emphasis>.
Esto constituye una opción avanzada: consúltese
una buena descripción del protocolo de TCP, como el documento
RFC-793, para la explicación del significado y la implicación
de cada uno de estos indicadores.
El signo <literal>!</literal> niega la regla.
</para></listitem>
</varlistentry>

<varlistentry>
<term>[!] - -syn</term>
<listitem><para>
Especifica que la regla buscar coincidencias coná sólo con los datagramas
cuyo bit
<literal>SYN</literal> valga 1 y cuyos bits
<literal>ACK</literal> y
<literal>FIN</literal> valgan ambos 0. 
Los datagramas con estos valores de los indicadores se utilizan
para abrir las conexiones de TCP, por tanto esta opción
puede ser utilizada para gestionar las solicitudes de
conexión. Esta opción es una abreviatura de:

<screen>
<literal>- -tcp-flags SYN,RST,ACK SYN</literal>
</screen>

Cuando se utilice el operador de negación,
la regla buscar coincidencias coná con todos los datagramas
cuyos bits 
<literal>SYN</literal> y <literal>ACK</literal> no
valgan 1 simultáneamente.
</para></listitem>
</varlistentry>

</variablelist>
</sect4>
<sect4>
<title>Extensions de UDP: utilizadas con -m udp -p udp</title>
<variablelist>
<varlistentry>
<term>- -sport [!] [port[:port]]</term>
<listitem><para>
Especifica el puerto que debe utilizar el origen del datagrama para
buscar coincidencias con esta regla.
Se pueden especificar los puertos en la forma de un rango, 
especificando los límites inferior y superior con un signo 
<literal>:</literal> como
delimitador. 
Por ejemplo, <literal>20:25</literal> describe todos los puertos
que van desde el 20 hasta el 25 incluyendo ambos. De nuevo, el signo <literal>!</literal> puede utilizarse para negar los valores.
</para></listitem>
</varlistentry>

<varlistentry>
<term>- -dport [!] [port[:port]]</term>
<listitem><para>
Especifica el puerto que el datagrama de destino utilizará
para buscar coincidencias con esta regla. Este argumento se codifica
de forma idéntica a la opción
<option>- -sport</option>.
</para></listitem>
</varlistentry>
</variablelist>
</sect4>
<sect4>
<title>Extensiones de ICMP: utilizadas con <literal>-m icmp -p icmp</literal></title>
<variablelist>
<varlistentry>
<term>- -icmp-type [!] nombre_de_tipo</term>
<listitem><para>
<?troff .hw protocol-un-reachable>
Especifica el tipo de mensaje de ICMP que buscar coincidencias coná con
esta regla. Puede especificarse el tipo tanto por su número
como por su nombre.
Algunos nombres válidos son:
<literal>echo-request</literal>, <literal>echo-reply</literal>,
<literal>source-quench</literal>, <literal>time-exceeded</literal>,
<literal>destination-unreachable</literal>,
<literal>network-unreachable</literal>, <literal>host-unreachable</literal>,
<literal>protocol-unreachable</literal>, y
<literal>port-unreachable</literal>.
</para></listitem>
</varlistentry>
</variablelist>
</sect4>
<sect4>
<title>Extensiones de MAC: utilizadas con <literal>-m mac</literal></title>
<variablelist>
<varlistentry>
<term>- -mac-source [!] address</term>
<listitem><para>
Especifica la dirección Ethernet del 'host' transmisor que
coincide con esta regla. Esto sólo tiene sentido en una
regla de la cadena de entrada 'input' o de reenvío 'forward'
porque se trasmitirá cualquier datagrama que pase la
cadena de salida 'output'.
</para></listitem>
</varlistentry>
</variablelist>
</sect4>
</sect3>
<INDEXTERM startref="iptables.firewall.options" class=endofrange>
</sect2>

<sect2><title>Nuestro ejemplo simple revisado otra vez</title>
<para>
Para implementar nuestro ejemplo simple con 
<emphasis>netfilter</emphasis>,
simplemente se podría cargar el módulo
<filename>ipchains.o</filename> para que se comporte como
la versión
<command>ipchains</command>.
En cambio, se volverá a realizar una implementación con
<command>iptables</command> para ilustrar lo similar
que es.
</para>

<para>
De nuevo, supóngase que se dispone en nuestra organización
de una red y que se está utilizando una máquina cortafuegos
basada en GNU/Linux para permiir a nuestros usuarios que sean
capaces de acceder a servidores WWW de Internet, y para
impedir el paso de cualquier otro tipo de tráfico.
</para>

<para>
Si nuestra red tiene una máscara de red de 24 bits
(clase C) y tiene como dirección 
172.16.1.0, 
entonces se podría utilizar las siguientes reglas
de <command>iptables</command>:

<screen width=83>
<prompt>#</prompt> <userinput>modprobe ip_tables</userinput>
<prompt>#</prompt> <userinput>iptables -F FORWARD</userinput>
<prompt>#</prompt> <userinput>iptables -P FORWARD DROP</userinput>
<prompt>#</prompt> <userinput>iptables -A FORWARD -m tcp -p tcp -s 0/0 --sport 80 -d 172.16.1.0/24 /
    --syn -j DROP</userinput>
<prompt>#</prompt> <userinput>iptables -A FORWARD -m tcp -p tcp -s 172.16.1.0/24 --sport /
    80 -d 0/0 -j ACCEPT</userinput>
<prompt>#</prompt> <userinput>iptables -A FORWARD -m tcp -p tcp -d 172.16.1.0/24 --dport 80 -s 0/0 -j /
    ACCEPT</userinput>
</screen>
</para>
<?troff .Nd 10>
<para>
En este ejemplo, las órdenes de
<command>iptables</command> se interpretan exactamente
como sus equivalentes de
<command>ipchains</command>. La diferencia más importante es
que debe cargarse el módulo
<filename>ip_tables.o</filename>. 
Nótese que  <command>iptables</command> no soporta la opción
<option>-b</option>,
por lo que debe proporcionarse una regla para cada sentido.
</para>
</sect2>
<INDEXTERM startref="firewalls.netfilter" class=endofrange>
<INDEXTERM startref="Linux.2.4.kernels" class=endofrange>
<INDEXTERM startref="netfilter.IP.tables" class=endofrange>
</sect1>

<sect1 id="X-087-2-firewall.tos.manipulation"><title>Manipulación de los bits de TOS</title>
<para>
<INDEXTERM id="firewalls.TOS.bit.manip" class=startofrange><PRIMARY>cortafuegos</PRIMARY><SECONDARY>manipulación de los bits de TOS </SECONDARY></INDEXTERM>
<INDEXTERM id="ip.TOS.bits" class=startofrange><PRIMARY>IP (Internet Protocol)</PRIMARY><SECONDARY>bits TOS (Type Of Service)</SECONDARY></INDEXTERM>
<INDEXTERM id="TOS.bits.manip" class=startofrange><PRIMARY>TOS (Type Of Service), manipulación de bits</PRIMARY></INDEXTERM>
Los bits del campo de tipo de servicio (TOS
<footnote id="X-087-2-FW-TFN18">
<para> N. del T.: 'Type Of Service' en el original en inglés
</para>
</footnote>) son
un conjunto de cuatro indicadores de un bit de la cabecera de IP.
Si uno de estos indicadores de bit vale 1,
un encaminador puede manipular el datagrama de forma diferente del
caso en el que ningún indicador valiera 1.
Cada uno de los cuatro bits tiene un propósito diferente y
sólo uno de los bits de TOS puede valer 1 al mismo tiempo,
es decir, las combinaciones no están permitidas. Estos indicadores
de bit se denominan de "tipo de servicio" porque permiten que la
aplicación que transmite los datos informe a la red del tipo
de servicio de red que requiere.
</para>

<para>
Las clases de servicios de red disponibles son:</para>

<variablelist>
<varlistentry><term>Demora mínima</term>
<listitem><para>
Se utiliza cuando se le da la máxima importancia al tiempo de
viaje de un datagrama del 'host' de
origen al 'host' de destino (demora).
Por ejemplo, un suministrador de red podría estar utilizando
tanto conexiones de red de fibra como por satélite. Los
datos transportados por las conexiones por satélite tienen
que viajar más lejos y su demora entre los mismos
extremos será por lo general mayor
que la de las conexiones de red terrestres.
Un suministrador de red podría elegir asegurarse que
los datagramas con este tipo de servicio no se transporten
por satélite.
</para></listitem>
</varlistentry>

<varlistentry><term>Rendimiento máximo</term>
<listitem><para>
Se utiliza cuando el volumen de datos transmitidos en cualquier período
de tiempo es importante. Existen numerosos tipos de aplicaciones de
red para las que el tiempo de demora no es muy importante pero
el rendimiento sí que lo es; por ejemplo, las transferencias
de ficheros en bloque. Un suministrador de red podría elegir encaminar
los datagramas con este tipo de servicio vía rutas de demora alta,
pero de gran ancho de banda, como las conexiones por satélite.
</para></listitem>
</varlistentry>

<varlistentry><term>Fiabilidad máxima</term>
<listitem><para>
Se utiliza cuando es importante tener alguna certeza de que
los datos llegarán al destino sin necesidad de una retransmisión.
El protocolo IP puede transportarse sobre un número variado
de medios de transmisión de bajo nivel. Mientras que SLIP y PPP son adecuados
para protocolos de enlace de datos
<footnote id="X-087-2-FW-TFN19">
<para> N. del T.: 'datalink' en el original en inglés
</para>
</footnote>, no son tan fiables
para transportar IP como otras redes, como las redes X.25.
Un suministrador de red podría tener disponible una red alternativa,
que ofreciera alta fiabilidad para transportar IP y que
se utilizaría cuando se eligiera este tipo de servicio.
</para></listitem>
</varlistentry>

<varlistentry><term>Coste mínimo</term>
<listitem><para>
Se utiliza cuando resulta importante minimizar el coste de los
datos transmitidos. El alquiler de ancho de banda de un satélite
para una transmisión transoceánica cuesta generalmente menos
que el alquier de espacio de un cable de fibra óptica sobre
la misma distancia, por lo que los suministradores de red
pueden elegir proporcionar ambos y cobrar de forma
diferente según sea el que se utilice. En este escenario,
el bit de tipo de servicio de &ldquo;coste mínimo&rdquo; 
puede ocasionar que los datagramas sean encaminados vía la
ruta de menor coste por satélite.
</para></listitem>
</varlistentry>
</variablelist>

<sect2><title>Establecimiento de los bits de TOS con ipfwadm o ipchains</title>
<para>
<INDEXTERM><PRIMARY>orden ipfwadm</PRIMARY><SECONDARY>establecimiento de los bits de TOS</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>orden ipchains</PRIMARY><SECONDARY>establecimiento de los bits de TOS</SECONDARY></INDEXTERM>
Las órdenes <command>ipfwadm</command> e <command>ipchains</command> gestionan
los bits de TOS prácticamente de la misma forma. En ambos casos, se especifica
una regla que coincide con los datagramas que contengan un conjunto particular
de bits de TOS, y en ambos se utiliza el argumento
<option>-t</option> para especificar los cambios que se desean realizar.
</para>

<para>
Los cambios se especifican utilizando máscaras de dos bits. Se realiza
un AND lógico con la primera
de estas máscaras de bits y el campo de las opciones de IP, mientras
que se realiza un OR exclusivo con la segunda. Por si puede parecer
complicado, en un momento se darán las recetas que se necesitan 
para habilitar cada uno de los tipos de servicio.
</para>

<para>
Las máscaras de bit se especifican utilizando valores hexadecimales de
ocho bits. Tanto
<command>ipfwadm</command> como <command>ipchains</command> utilizan
la misma sintaxis para el argumento:

<screen width=80>
<literal>-t <replaceable>máscara_and</replaceable> <replaceable>máscara_xor</replaceable></literal>
</screen>

</para>

<para>
Afortunadamente, pueden utilizarse los mismo argumentos de máscara cada vez
que se desee establececer un tipo de servicio particular, lo que ahorra
el tener que averiguarlas cada vez. En
la <xref linkend="X-087-2-firewall.ipchains.tos.recipes"> se presentan
junto con algunas sugerencias de uso.
</para>

<table id="X-087-2-firewall.ipchains.tos.recipes">
<title>Sugerencias de uso de las máscaras de bits de TOS</title>
<tgroup cols=4><colspec colnum="1" colwidth="3.81cm">
<thead>
<row>
	<entry>TOS</entry>
	<entry>ANDmask</entry>
	<entry>XORmask</entry>
	<entry>Uso sugerido</entry>
</row>
</thead>

<tbody>
<row>
	<entry>Demora mínima</entry>
	<entry><literal>0x01</literal></entry>
	<entry><literal>0x10</literal></entry>
	<entry>ftp, telnet, ssh</entry>
</row>

<row>
	<entry>Rendimiento máximo</entry>
	<entry><literal>0x01</literal></entry>
	<entry><literal>0x08</literal></entry>
	<entry>ftp-data, www</entry>
</row>

<row>
	<entry>Fiabilidad máxima</entry>
	<entry><literal>0x01</literal></entry>
	<entry><literal>0x04</literal></entry>
	<entry>snmp, dns</entry>
</row>

<row>
	<entry>Coste mínimo</entry>
	<entry><literal>0x01</literal></entry>
	<entry><literal>0x02</literal></entry>
	<entry>nntp, smtp</entry>
</row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2><title>Establecimiento de los bits de TOS con iptables</title>
<para>
<INDEXTERM><PRIMARY>iptables command</PRIMARY><SECONDARY>establecimieto de los bits de TOS</SECONDARY></INDEXTERM>
La herramienta 
<command>iptables</command> permite especificar reglas
que capturen sólo los datagramas con los bits de TOS coincidentes
con los valores prederminados por la opción
<option>-m tos</option>,
y que establezcan los bits de TOS de los datagramas
de IP que coincidan con una regla con el blanco
<literal>-j
TOS</literal>.
Pueden establecerse los bits de TOS sólamente en las cadenas
<literal>FORWARD</literal> y <literal>OUTPUT</literal>.
La coincidencia y el establecimiento ocurren de forma independiente.
Se puede configurar todo tipo de reglas interesante. Por ejemplo,
puede configurarse una regla que descarte todos los datagramas con
una cierta combinación de bits de TOS, o una regla que
establezca los bits de TOS sólamente de los datagramas que provengan 
de unos ciertos 'hosts'. La mayoría de las veces, se utilizarán
reglas que contengan tanto la coincidencia como el establecimiento
para así realizar traducciones de bits de TOS, como ya se podía
hacer con
<command>ipfwadm</command> o <command>ipchains</command>.
</para>

<para>
En lugar de la configuración complicada de dos máscaras de
<command>ipfwadm</command> e <command>ipchains</command>,
<command>iptables</command> utiliza la estrategia más
simple de especificar de forma plana los bits de TOS que deben
buscar coincidencias con, o los bits de TOS que deben establecerse.
Además, en lugar de tener que recordar y utilizar el valor
hexadecimal, puede especificarse los bits de TOS utilizando los
nombres mnemotécnicos mostrados en la tabla siguiente.
</para>

<para>
La sintaxis general utilizada para buscar coincidencias con los bits de TOS
se parece a:
 
<screen>
<literal>-m tos --tos <replaceable>nombre_mnemotécnico</replaceable> [<replaceable>otros_args</replaceable>] -j <replaceable>objetivo</replaceable></literal>
</screen>
</para>

<para>
La sintaxis general utilizada para establecer los bits de TOS
se parece a:

<screen>
<literal>[<replaceable>otros_args</replaceable>] -j TOS --set <replaceable>nombre_mnemotécnico</replaceable></literal>
</screen>
</para>

<para>
Recuérdese que las dos posibilidades generalmente se utilizarán juntas, pero que
también pueden ser utilizadas de forma independiente si
se quiere una configuración que así lo requiera.
</para>

<informaltable id="X-087-2-firewall.iptables.tos.recipes">
<tgroup cols=2>
<thead>
<row><entry>Mnemónico</entry><entry>Hexadecimal</entry></row>
</thead>
<tbody>
<row><entry>Normal-Service<footnote id="X-087-2-FW-TFN20"><para> N. del T.: "servicio normal" </para>
</footnote></entry><entry>0x00</entry></row>
<row><entry>Minimize-Cost<footnote id="X-087-2-FW-TFN21"><para> N. del T.: "minimizar los costes" </para>
</footnote></entry><entry>0x02</entry></row>
<row><entry>Maximize-Reliability<footnote id="X-087-2-FW-TFN22"><para> N. del T.: "maximizar la fiabilidad" </para>
</footnote></entry><entry>0x04</entry></row>
<row><entry>Maximize-Throughput<footnote id="X-087-2-FW-TFN23"><para> N. del T.: "maximizar el rendimiento" </para>
</footnote></entry><entry>0x08</entry></row>
<row><entry>Minimize-Delay<footnote id="X-087-2-FW-TFN24"><para> N. del T.: "minimizar la demora" </para>
</footnote></entry><entry>0x10</entry></row>
</tbody>
</tgroup>
</informaltable>

</sect2>
<INDEXTERM startref="firewalls.TOS.bit.manip" class=endofrange>
<INDEXTERM startref="ip.TOS.bits" class=endofrange>
<INDEXTERM startref="TOS.bits.manip" class=endofrange>
</sect1>

<sect1 id="X-087-2-firewall.checkingconf"><title>Comprobación de una
configuración del cortafuegos</title>
<para>
<INDEXTERM id="firewall.test.config" class=startofrange><PRIMARY>cortafuegos</PRIMARY><SECONDARY>comprobación de una configuración</SECONDARY></INDEXTERM>
Después de haber diseñado una configuración de cortafuegos adecuada,
es importante comprobar que efectivamente se obtiene lo que
se deseaba. Una forma de hacerlo consiste en utilizar un 'host'
de prueba fuera de nuestra red para que intente atravesar su
cortafuegos: esto puede llegar a resultar farragoso y lento,
y se estaría limitado a la comprobación únicamente de aquellas
direcciones que realmente puedan usarse.
</para>

<para>
Un método más rápido y sencillo está disponible con
la implementación del cortafuegos de GNU/Linux.
Permite generar pruebas y ejecutarlas contra el cortafuegos
como si se estuviera haciendo la prueba con datagramas reales.
Todas las variedades de software del cortafuegos del núcleo
de GNU/Linux,
<command>ipfwadm</command>, <command>ipchains</command>, e
<command>iptables</command>, 
dan soporte a este tipo de comprobaciones.
La implementación involucra el uso de la orden
de <emphasis>comprobación</emphasis> relevante.
</para>

<para>
El procedimiento general de comprobación es como sigue:
</para>

<orderedlist>
<listitem><para>
Diseñe y configure su cortafuegos utilizando 
<command>ipfwadm</command>,
<command>ipchains</command>, o <command>iptables</command>.
</para></listitem>
<listitem><para>
Diseñe una serie de comprobaciones que determinen si su cortafuegos
está realmente funcionando como deseaba. Puede utilizar
cualquier dirección de origen o destino para realizar estas
comprobaciones, por lo que escoja algunas combinaciones
de direcciones que deberían ser aceptadas y otras que
deberían ser rechazadas. Si se va a permitir o prohibir
a un cierto rango de direcciones, es una buena idea comprobar
las direcciones situadas justo en los límites del
rango&mdash;una dirección justo dentro del rango y otra justo
fuera del rango. Esto le ayudará a asegurarse de
que configuró correctamente los rangos, pues a veces
resulta muy fácil especificar de forma incorrecta las
máscaras de su configuración.
Si se filtra por número de protocolo y puerto, sus comprobaciones
también deberían comprobar todas las combinaciones importantes
de estos parámetros.
Por ejemplo, si se desea aceptar TCP sólo en ciertas circunstancias,
compruebe que se rechazan los datagramas de tipo UDP.
</para></listitem>
<listitem><para>
Desarrolle reglas de 
<command>ipfwadm</command>, <command>ipchains</command>, o
<command>iptables</command> para implementar cada comprobación.
Probablemente merezca la pena escribir todas estas reglas
en un guión de tal forma que pueda hacer y rehacer
la comprobación fácilmente a la vez que va corrigiendo los errores
o cambiando el diseño.
Las comprobaciones utilizan casi la misma sintaxis que las
especificaciones de reglas, pero los argumentos tiene significados
ligeramente diferentes. Por ejemplo, el argumento de dirección
de origen de una especificación de una regla especifica
la dirección de origen que deberían tener los datagramas coincidentes
con esta regla. En cambio, el argumento de dirección de origen en
la sintaxis de comprobación específica la dirección de origen
del datagrama de prueba que se generará. En el caso de
<command>ipfwadm</command>, 
debe utilizarse la opción
<option>&ndash;c</option>
para especificar que la orden es una comprobación, mientras que
en el caso de 
<command>ipchains</command> e <command>iptables</command>, 
se debe utilizar la opción
<option>&ndash;C</option>. En todos los casos
<emphasis>siempre</emphasis> se deben especificar
la dirección de origen, la dirección de destino, el protocolo y
la interfaz que se utilizará como prueba.
El resto de argumentos, como los números de puertos y los valores
de los bits de TOS, son opcionales.
</para></listitem>
<listitem><para>
Ejecute cada orden de comprobación y anote el resultado. El resultado
de cata comprobación consistirá en una única palabra que
indicará el blanco final del datagrama después de haber
cruzado la configuración del cortafuegos; es decir,
dónde terminará el proceso.
Para el caso de
<command>ipchains</command> e <command>iptables</command>, 
pueden comprobarse las cadenas de usuario
además de las predefinidas.
</para></listitem>
<listitem><para>
Compare la salida de cada comprobación contra el resultado
deseado. Si encuentra alguna discrepancia, necesitará analizar
su conjunto de reglas para determinar dónde cometió el error.
Si escribió sus órdenes de pruebas en un fichero de guión, entonces
podrá reejecutar la comprobación de forma fácil después de haber
corregido cualquier error de la configuración del cortafuegos.
Se considera buena práctica borrar por completo sus conjuntos
de reglas y reconstruirlas desde cero, en vez de estar realizando
cambios dinámicamente. Esto le ayudará a asegurarse
de que la configuración activa que está comprobando refleja
el conjunto de órdenes de su guión de configuración.
</para></listitem>
</orderedlist>

<para>
Veamos lo que podría ser la transcripción de una comprobación manual de
nuestro ejemplo simple con
<command>ipchains</command>. 
Recuerde que la red local del ejemplo era
172.16.1.0 con una máscara de red de 
255.255.255.0, y que se permitían las conexiones de TCP
hacia servidores web de fuera de la red.
La cadena de reenvío 'forward' no permitía pasar nada más.
Empiece con una transmisión que sabemos debería funcionar,
una conexión desde el 'host' local a un servidor web de fuera:

<screen>
# <userinput>ipchains -C forward -p tcp -s 172.16.1.0 1025 -d 44.136.8.2 80 -i eth0</userinput>
accepted<footnote id="X-087-2-FW-TFN25"><para> N. del T.: "aceptado" </para>
</footnote></screen>
</para>

<para>
Fíjese en los argumentos que se han proporcionado y en la forma en que
se utilizan para describir el datagrama. La salida de la orden
indica que se aceptó el datagrama para su reenvío, que es lo que
se esperaba.
</para>

<para>
Ahora hagamos otra prueba, esta vez con una dirección de origen
que no pertenece a nuestra red, y, que por tanto, debería ser rechazada.
<screen>
# <userinput>ipchains -C forward -p tcp -s 172.16.2.0 1025 -d 44.136.8.2 80 -i eth0</userinput>
denied<footnote id="X-087-2-FW-TFN26"><para> N. del T.: "rechazado" </para>
</footnote></screen>
</para>

<para>
Realice algunas comprobaciones más, con el mismo nivel de detalle que
la primera comprobación pero con diferentes protocolos. También deberían
ser rechazados:

<screen>
# <userinput>ipchains -C forward -p udp -s 172.16.1.0 1025 -d 44.136.8.2 80 -i eth0</userinput>
denied
# <userinput>ipchains -C forward -p icmp -s 172.16.1.0 1025 -d 44.136.8.2 80 -i eth0</userinput>
denied
</screen>
</para>

<para>
Pruebe con otro puerto de destino, de nuevo esperando que sea rechazado:

<screen>
# <userinput>ipchains -C forward -p tcp -s 172.16.1.0 1025 -d 44.136.8.2 23 -i eth0</userinput>
denied
</screen>
</para>

<para>
Tendrá que recorrer un largo camino para estar tranquilo pues
tendrá que diseñar una serie de comprobaciones muy exhaustiva.
Aunque a veces esto resulta tan complicado como el diseño
de la propia configuración del cortafuegos, también
es la mejor forma de saber si su diseño proporciona
la seguridad que esperaba.
</para>
<INDEXTERM startref="firewall.test.config" class=endofrange>
</sect1>

<sect1 id="X-087-2-firewall.example"><title>Un ejemplo de configuración del cortafuegos</title>
<para>
<INDEXTERM id="firewalls.samp.config" class=startofrange><PRIMARY>cortafuegos</PRIMARY><SECONDARY>configuración de ejemplo</SECONDARY></INDEXTERM>
Se han discutido los fundamentos de la configuración del cortafuegos.
Veamos ahora qué aspecto tendría una configuración real del cortafuegos.
</para>

<para>
Se ha diseñado la configuración de este ejemplo con vistas
a que sea fácilmente extensible y personalizable. Se proporcionan
tres versiones.
la primera se implementa con la orden
<command>ipfwadm</command>
(o el guión <command>ipfwadm-wrapper</command>), 
la segunda utiliza
<command>ipchains</command>, y la tercera
<command>iptables</command>.
En el ejemplo no se intenta aprovechar las posibilidades
de las cadenas de usuario, pero le mostrará las similitudes
y diferencias entre las sintaxis de las viejas y las nuevas
herramientas de configuración:
</para>

<programlisting width=80>
#!/bin/bash
##########################################################################
# VERSIÓN PARA IPFWADM 
# Esta configuración está pensada como ejemplo de configuración de
# un cortafuegos sobre un 'host' único que no hospede él mismo ningún
# servicio
##########################################################################

# SECCIÓN CONFIGURABLE POR EL USUARIO

# El nombre y la localización de la utilidad ipfwadm. Utilice
# ipfwadm-wrapper para los núcleos 2.2.*.
IPFWADM=ipfwadm

# Ruta del ejecutable de ipfwadm.    
PATH="/sbin"

# El espacio de direcciones de nuestra red interna y el dispositivo
# de red que la soporta.
OURNET="172.29.16.0/24"
OURBCAST="172.29.16.255"
OURDEV="eth0"

# Las direcciones de fuera y el dispositivo de red que la soporta.
ANYADDR="0/0"
ANYDEV="eth1"

# Los servicios de TCP que deseamos permitir que pasen - un "" vacío
# significa todos los puertos
# nota: separados por espacios
TCPIN="smtp www"
TCPOUT="smtp www ftp ftp-data irc"

# Los servicios de UDP que deseamos permitir que pasen - un "" vacío
# significa todos los puertos
# nota: separados por espacios
UDPIN="domain"
UDPOUT="domain"

# Los servicios de ICMP que deseamos permitir que pasen - un "" vacío
# significa todos los tipos 
# referencia para los números de los tipos: /usr/include/netinet/ip_icmp.h 
# nota: separados por espacios
ICMPIN="0 3 11"
ICMPOUT="8 3 11"

# Registro; descomente la siguiente línea para habilitar el registro
# de los datagramas rechazados por el cortafuegos
# LOGGING=1

# FIN DE LA SECCIÓN CONFIGURABLE POR EL USUARIO
###########################################################################
# Borra las reglas de la cadena de entrada 
$IPFWADM -I -f

# Por defecto, queremos denegar el acceso a los intentos de entrada
$IPFWADM -I -p deny

# SUPLANTACIÓN DE IDENTIDAD
# No se debería aceptar ningún datagrama proveniente de fuera con una 
# direccción de origen coincidente con una de las nuestras, por
# eso las rechazamos.
$IPFWADM -I -a deny -S $OURNET -W $ANYDEV

# 'SMURF'
# No se permiten difusiones dirigidas de ICMP a nuestra red para evitar
# los ataques del estilo denominado 'Smurf'.
$IPFWADM -I -a deny -P icmp -W $ANYDEV -D $OURBCAST

# TCP
# Aceptaremos todos los datagramas de TCP que pertenezcan a una
# conexión ya existente (i.e. cuyo bit de ACK valga 1) 
# en el caso de los puertos de TCP que estamos permitiendo.
# Esto debería capturar más del 95% de todos los paquetes válidos de TCP.
$IPFWADM -I -a accept -P tcp -D $OURNET $TCPIN -k -b

# TCP - CONEXIONES ENTRANTES
# Aceptaremos únicamente las solicitudes de conexión desde
# fuera sólamente en los puertos de TCP permitidos.
$IPFWADM -I -a accept -P tcp -W $ANYDEV -D $OURNET $TCPIN -y

# TCP - CONEXIONES SALIENTES
# Aceptaremos todas las conexiones salientes de TCP hacia los puertos
# de TCP permitidos.
$IPFWADM -I -a accept -P tcp -W $OURDEV -D $ANYADDR $TCPOUT -y

# UDP - ENTRADA
# Aceptaremos la entrada de datagramas UDP por puertos permitidos
$IPFWADM -I -a accept -P udp -W $ANYDEV -D $OURNET $UDPIN

# UDP - SALIDA
# Aceptaremos la salida de datagramas hacia los puertos permitidos.
$IPFWADM -I -a accept -P udp -W $OURDEV -D $ANYADDR $UDPOUT

# ICMP - ENTRADA
# Aceptaremos la entrada de los datagramas de ICMP de los tipos permitidos.
$IPFWADM -I -a accept -P icmp -W $ANYDEV -D $OURNET $ICMPIN

# ICMP - SALIDA
# Aceptaremos la salida de los datagramas de ICMP de los tipos permitidos.
$IPFWADM -I -a accept -P icmp -W $OURDEV -D $ANYADDR $ICMPOUT

# CASO POR DEFECTO y REGISTRO
# Todos los restantes datagramas caen dentro de la regla por defecto
# y son eliminados. Serán registrados si más arrriba se ha configurado
# la variable LOGGING.
#
if [ "$LOGGING" ]
then
	# Registra los paquetes de TCP descartados
	$IPFWADM -I -a reject -P tcp -o

	# Registra los paquetes de UDP descartados
	$IPFWADM -I -a reject -P udp -o

	# Registra los paquetes de ICMP descartados
	$IPFWADM -I -a reject -P icmp -o
fi
#
# fin.
</programlisting>
<?troff .Nd 10>
<para>
Ahora se vuelve a implementar el ejemplo con la orden
<command>ipchains</command>:
</para>

<programlisting width=80>
#!/bin/bash
##########################################################################
# VERSIÓN PARA IPCHAINS
# Este configuración está pensada como ejemplo de configuración de
# un cortafuegos sobre un 'host' único que no hospede él mismo ningún
# servicio
##########################################################################

# SECCIÓN CONFIGURABLE POR EL USUARIO

# El nombre y la localización de la utilidad ipchains.
IPCHAINS=ipchains

# Ruta del ejecutable de ipchains.
PATH="/sbin"

# El espacio de direcciones de nuestra red interna y el dispositivo
# de red que la soporta.
OURNET="172.29.16.0/24"
OURBCAST="172.29.16.255"
OURDEV="eth0"

# Las direcciones de fuera y el dispositivo de red que la soporta.
ANYADDR="0/0"
ANYDEV="eth1"

# Los servicios de TCP que deseamos permitir que pasen - un "" vacío
# significa todos los puertos
# nota: separados por espacios
TCPIN="smtp www"
TCPOUT="smtp www ftp ftp-data irc"

# Los servicios de UDP que deseamos permitir que pasen - un "" vacío
# significa todos los puertos
# nota: separados por espacios
UDPIN="domain"
UDPOUT="domain"

# Los servicios de ICMP que deseamos permitir que pasen - un "" vacío
# significa todos los tipos 
# referencia para los números de los tipos: /usr/include/netinet/ip_icmp.h 
# nota: separados por espacios
ICMPIN="0 3 11"
ICMPOUT="8 3 11"

# Registro; descomente la siguiente línea para habilitar el registro
# de los datagramas rechazados por el cortafuegos
# LOGGING=1

# FIN DE LA SECCIÓN CONFIGURABLE POR EL USUARIO
##########################################################################
# Borra las reglas de la cadena de entrada
$IPCHAINS -F input

# Por defecto, queremos denegar el acceso a los intentos de entrada
$IPCHAINS -P input deny

# SUPLANTACIÓN DE IDENTIDAD
# No se debería aceptar ningún datagrama proveniente de fuera con una 
# direccción de origen coincidente con una de las nuestras, por
# eso las rechazamos.
$IPCHAINS -A input -s $OURNET -i $ANYDEV -j deny

# 'SMURF'
# No se permiten difusiones dirigidas de ICMP a nuestra red para evitar
# los ataques del estilo denominado 'Smurf'.
$IPCHAINS -A input -p icmp -w $ANYDEV -d $OURBCAST -j deny

# Deberíamos aceptar fragmentos, esto se debe explicitar en ipchains.
$IPCHAINS -A input -f -j accept

# TCP
# Aceptaremos todos los datagramas de TCP que pertenezcan a una
# conexión ya existente (i.e. cuyo bit de ACK valga 1) 
# en el caso de los puertos de TCP que estamos permitiendo.
# Esto debería capturar más del 95% de todos los paquetes válidos de TCP.
$IPCHAINS -A input -p tcp -d $OURNET $TCPIN ! -y -b -j accept

# TCP - CONEXIONES ENTRANTES
# Aceptaremos únicamente las solicitudes de conexión desde
# fuera en los puertos de TCP permitidos.
$IPCHAINS -A input -p tcp -i $ANYDEV -d $OURNET $TCPIN -y -j accept

# TCP - CONEXIONES SALIENTES
# Aceptaremos todas las conexiones salientes de TCP hacia los puertos
# de TCP permitidos.
$IPCHAINS -A input -p tcp -i $OURDEV -d $ANYADDR $TCPOUT -y -j accept

# UDP - ENTRADA
# Aceptaremos la entrada de los datagramas de UDP por puertos permitidos
$IPCHAINS -A input -p udp -i $ANYDEV -d $OURNET $UDPIN -j accept

# UDP - SALIDA
# Aceptaremos la salida de datagramas hacia los puertos permitidos.
$IPCHAINS -A input -p udp -i $OURDEV -d $ANYADDR $UDPOUT -j accept

# ICMP - ENTRADA
# Aceptaremos la entrada de los datagramas de ICMP de los tipos permitidos
$IPCHAINS -A input -p icmp -w $ANYDEV -d $OURNET $ICMPIN -j accept

# ICMP - SALIDA
# Aceptaremos la salida de los datagramas de ICMP de los tipos permitidos.
$IPCHAINS -A input -p icmp -i $OURDEV -d $ANYADDR $ICMPOUT -j accept

# CASO POR DEFECTO y REGISTRO
# Todos los restantes datagramas caen dentro de la regla por defecto
# y son eliminados. Serán registrados si más arriba se ha configurado
# la variable LOGGING.
#
if [ "$LOGGING" ]
then
	# Registra los paquetes de TCP descartados
	$IPCHAINS -A input -p tcp -l -j reject

	# Registra los paquetes de UDP descartados
	$IPCHAINS -A input -p udp -l -j reject

	# Registra los paquetes de ICMP descartados
	$IPCHAINS -A input -p icmp -l -j reject
fi
#
# fin.
</programlisting>

<para>
En el ejemplo con
<command>iptables</command>, 
se ha pasado autilizar el conjunto de reglas
<literal>FORWARD</literal> por la diferencia de
significado del conjunto de reglas 
<literal>INPUT</literal> en la implementación de
<emphasis>netfilter</emphasis>. 
Esto tiene implicaciones; significa que ninguna de las reglas
protege el 'host' mismo del cortafuegos.
Para imitar con precisión el ejemplo con
<command>ipchains</command>,
se replicaría cada una de las reglas de la cadena 
<literal>INPUT</literal>. 
En aras de la claridad, en su lugar se ha decidido eliminar
todos los datagramas entrantes provenientes desde el lado
de fuera de la interfaz
</para>

<programlisting width=103>
#!/bin/bash
##########################################################################
# VERSIÓN PARA IPTABLES
# Este configuración está pensada como ejemplo de configuración de
# un cortafuegos sobre un 'host' único que no hospede él mismo ningún
# servicio
##########################################################################

# SECCIÓN CONFIGURABLE POR EL USUARIO

# El nombre y la localización de la utilidad iptables.
IPTABLES=iptables

# Ruta del ejecutable de iptables.
PATH="/sbin"

# El espacio de direcciones de nuestra red interna y el dispositivo
# de red que la soporta.
OURNET="172.29.16.0/24"
OURBCAST="172.29.16.255"
OURDEV="eth0"

# Las direcciones de fuera y el dispositivo de red que la soporta.
ANYADDR="0/0"
ANYDEV="eth1"

# Los servicios de TCP que deseamos permitir que pasen - un "" vacío
# significa todos los puertos
# nota: separados por espacios
TCPIN="smtp,www"
TCPOUT="smtp,www,ftp,ftp-data,irc"

# Los servicios de UDP que deseamos permitir que pasen - un "" vacío
# significa todos los puertos
# nota: separados por espacios
UDPIN="domain"
UDPOUT="domain"

# Los servicios de ICMP que deseamos permitir que pasen - un "" vacío
# significa todos los tipos 
# referencia para los números de los tipos: /usr/include/netinet/ip_icmp.h 
# nota: separados por espacios
ICMPIN="0,3,11"
ICMPOUT="8,3,11"

# Registro; descomente la siguiente línea para habilitar el registro
# de los datagramas rechazados por el cortafuegos
# LOGGING=1

# FIN DE LA SECCIÓN CONFIGURABLE POR EL USUARIO
###########################################################################
# Borra las reglas de la cadena de entrada
$IPTABLES -F FORWARD

# # Por defecto, queremos denegar el acceso a los intentos de entrada
$IPTABLES -P FORWARD deny

# Rechaza todos los datagramas destinados a este host y recibidos
# desde fuera.
$IPTABLES -A INPUT -i $ANYDEV -j DROP

# SUPLANTACIÓN DE IDENTIDAD
# No se debería aceptar ningún datagrama proveniente de fuera con una 
# direccción de origen coincidente con una de las nuestras, por
# eso las rechazamos.
$IPTABLES -A FORWARD -s $OURNET -i $ANYDEV -j DROP

# 'SMURF'
# No se permiten difusiones dirigidas de ICMP a nuestra red para evitar
# los ataques del estilo denominado 'Smurf'.
$IPTABLES -A FORWARD -m multiport -p icmp -i $ANYDEV -d $OURNET -j DENY

# Deberíamos aceptar fragmentos, esto se debe explicitar en iptables.
$IPTABLES -A FORWARD -f -j ACCEPT

# TCP
# Aceptaremos todos los datagramas de TCP que pertenezcan a una
# conexión ya existente (i.e. cuyo bit de ACK valga 1) 
# en el caso de los puertos de TCP que estamos permitiendo.
# Esto debería capturar más del 95% de todos los paquetes válidos de TCP.
$IPTABLES -A FORWARD -m multiport -p tcp -d $OURNET --dports $TCPIN /
    ! --tcp-flags SYN,ACK ACK -j ACCEPT
$IPTABLES -A FORWARD -m multiport -p tcp -s $OURNET --sports $TCPIN /
    ! --tcp-flags SYN,ACK ACK -j ACCEPT

# TCP - CONEXIONES ENTRANTES
# Aceptaremos únicamente las solicitudes de conexión desde
# fuera en los puertos de TCP permitidos.
$IPTABLES -A FORWARD -m multiport -p tcp -i $ANYDEV -d $OURNET $TCPIN /
    --syn -j ACCEPT

## TCP - CONEXIONES SALIENTES
# Aceptaremos todas las conexiones salientes de TCP hacia los puertos
# de TCP permitidos
$IPTABLES -A FORWARD -m multiport -p tcp -i $OURDEV -d $ANYADDR /
    --dports $TCPOUT --syn -j ACCEPT
<?troff .sp -12p>
# UDP - ENTRADA
## Aceptaremos la entrada y vuelta de los datagramas de UDP por puertos
#permitidos.
$IPTABLES -A FORWARD -m multiport -p udp -i $ANYDEV -d $OURNET /
    --dports $UDPIN -j ACCEPT
$IPTABLES -A FORWARD -m multiport -p udp -i $ANYDEV -s $OURNET /
    --sports $UDPIN -j ACCEPT
<?troff .sp -12p>
# UDP - SALIDA
# Se aceptarán la salida de los datagramas de UDP hacia los puertos
permitidos y su vuelta.
$IPTABLES -A FORWARD -m multiport -p udp -i $OURDEV -d $ANYADDR /
    --dports $UDPOUT -j ACCEPT
$IPTABLES -A FORWARD -m multiport -p udp -i $OURDEV -s $ANYADDR /
    --sports $UDPOUT -j ACCEPT
<?troff .sp -12p>
# ICMP - ENTRADA
# Aceptaremos la entrada de los datagramas de ICMP de los tipos permitidos
$IPTABLES -A FORWARD -m multiport -p icmp -i $ANYDEV -d $OURNET /
    --dports $ICMPIN -j ACCEPT
<?troff .sp -12p>
# ICMP - SALIDA
# Aceptaremos la salida de los datagramas de ICMP de los tipos permitidos.
$IPTABLES -A FORWARD -m multiport -p icmp -i $OURDEV -d $ANYADDR /
    --dports $ICMPOUT -j ACCEPT
<?troff .sp -12p>
# CASO POR DEFECTO y REGISTRO
# Todos los restantes datagramas caen dentro de la regla por defecto
# y son eliminados. Serán registrados si más arriba se ha configurado
# la variable LOGGING.
#
if [ "$LOGGING" ]
then
	# Registra los paquetes de TCP descartados
	$IPTABLES -A FORWARD -m tcp -p tcp -j LOG
<?troff .sp -12p>
	# Registra los paquetes de UDP descartados
	$IPTABLES -A FORWARD -m udp -p udp -j LOG
<?troff .sp -12p>
	# Registra los paquetes de ICMP descartados
	$IPTABLES -A FORWARD -m udp -p icmp -j LOG
fi
#
# fin.
</programlisting>

<para>
En muchas situaciones simples, para utilizar el ejemplo todo lo que
necesitará será editar la sección superior del fichero denominado
&ldquo;SECCIÓN CONFIGURABLE POR EL USUARIO&rdquo; 
para especificar qué protocolos y tipos 
de datagramas desea que se les permita su entrada y su salida.
Para el caso de configuraciones más complejas, se necesitará también editar
la sección inferior.
Recuerde que el ejemplo es simple, por tanto examínelo cuidadosamente
para asegurarse de que hace lo que usted desea cuando lo implemente.
</para>
<INDEXTERM startref="firewalls.samp.config" class=endofrange>
</sect1>
<indexterm class="endofrange" startref="chfw.tcp.ip.firewall">
<INDEXTERM startref="chfw.firewalls.tcp.ip" class=endofrange>
</chapter>