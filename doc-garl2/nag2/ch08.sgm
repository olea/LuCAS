<!-- $Id: ch08.sgm,v 1.22 2002/11/29 22:06:43 pakojavi2000 Exp $ -->
<!--
Nota legal:

   Linux Network Administration Guide, por Olaf Kirch et al.

   La traducción al español se publica bajo la licencia GFDL,
siendo texto de portada el siguiente:

Linux Network Administrator's Guide
by Olaf Kirch and Terry Dawson
Copyright  (c) 1993 Olaf Kirch
Copyright  (c) 2000 Terry Dawson
Copyright on O'Reilly printed version (c) 2000 O'Reilly & Associates

y siendo secciones invariantes, la sección de Agradecimientos,
la sección titulada «La traducción al español», el apéndice C; así
como esta nota.

Capítulo traducido por:

  Luis Alberto Melgar, swann@interlap.com.ar
Revisión 1 por Francisco Javier Fernández serrador@arrakis.es
-->
<chapter id="X-087-2-ppp"><title>El Protocolo Punto-a-Punto</title>

<para>
<indexterm><primary>Internet</primary><secondary>conectando a</secondary></indexterm>
<INDEXTERM><PRIMARY>teléfonos</PRIMARY><SECONDARY>mandando datos a traves</SECONDARY></INDEXTERM>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>línea serie</secondary></indexterm>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>llamada</secondary></indexterm>
<indexterm><primary>enlace punto-a-punto</primary></indexterm>
<indexterm id="idx-configuringPPP-1" class="startofrange"><primary>configurando</primary><secondary>PPP</secondary></indexterm>
<indexterm id="idx-PPP-1" class="startofrange"><primary>PPP (Protocolo Punto-a-Punto)</primary></indexterm>
Como SLIP, PPP es un protocolo usado para mandar datagramas a través
de una conexión serie; sin embargo, resuelve varias de las deficiencias
de SLIP. Primero, puede transportar un alto número de protocolos y no
está limitado al protocolo IP. Proporciona detección de
errores en el mismo enlace, mientras que SLIP acepta y reenvía
datagramas corruptos mientras que la corrupción no se produzca en la cabecera.
Igualmente importante, permite a los extremos comunicantes negociar opciones, 
como la dirección IP y el tamaño máximo del datagrama, y provee 
autentificación del cliente. Esta negociación interna, permite una automatización
fiable del establecimiento de la conexión. Mientras la autentificación elimina
la necesidad de cuentas de usuario que requiere SLIP. Para cada una
de estas capacidades, PPP tiene un protocolo específico. En este
capítulo cubrimos brevemente estos elementos básicos que forman PPP.
Esta discusión de PPP está lejos de ser completa; si quiere aprender más sobre
PPP, le instamos a que lea el RFC de su especificación y la alrededor de
docena de RFCs que lo complementan.<footnote id="X-087-2-FNPP01"><para> Los RFCs más relevantes
están indicados en la bibliografia al final del libro.</para></footnote>
Además hay un extenso libro de O'Reilly sobre el tema
 <emphasis>Using & Managing PPP</emphasis>, por Andrew Sun.
</para>

<para>
<indexterm><primary>protocolo </primary><secondary>HDLC (High-Level Data Link Control)</secondary></indexterm>
<indexterm><primary>HDLC (High-Level Data Link Control), protocolo</primary></indexterm>
En la parte más baja de PPP está el protocolo de <emphasis>Control de Conexión de Datos
de Alto-Nivel</emphasis> (HDLC), que define los límites de las tramas PPP individuales,
y proporciona un control de errores de 16 bit.<footnote id="X-087-2-FNPP02"><para> En realidad,
HDLC es un protocolo mucho más general publicado por la Organización Internacional
de Estándares (ISO).</para></footnote> Al contrario de lo que ocurría con
SLIP, una trama PPP es capaz de llevar paquetes de otros protocolos
distintos al IP, como IPX de Novell o  Appletalk. PPP
consigue esto añadiendo a la trama básica HDLC un campo de control
que identifica el tipo de paquete contenido en la misma.
</para>

<para>
<indexterm><primary>LCP (Protocolo de Control de Enlace)</primary></indexterm>
<indexterm><primary>protocolo</primary><secondary>LCP (Protocolo de Control de Enlace)</secondary></indexterm>
El <emphasis>Protocolo de Control de Enlace</emphasis>, es
utilizado en la parte más alta del HDLC para negociar las opciones
concernientes a la conexión de datos, tales como la <emphasis>Unidad
Máxima de Recepción</emphasis> (MRU), que establece el tamaño máximo
del datagrama que cada extremo de comunicación acepta recibir.
</para>

<para>
<indexterm><primary>autentificación</primary><secondary>con PPP</secondary></indexterm>
<indexterm><primary>protocolo</primary><secondary>PAP (Protocolo de Autentificación por contraseña)</secondary></indexterm>
<indexterm><primary>PAP (Protocolo de Autentificación por contraseña)</primary></indexterm>
<indexterm><primary>CHAP (Protocolo de autentificación por reto)</primary></indexterm>
<indexterm><primary>protocolo</primary><secondary>CHAP (Protocolo de autentificación por reto)</secondary></indexterm>
Un paso importante en la configuración del enlace PPP corresponde
a la autentificación del cliente. Aunque no es obligatorio, es casi
un deber para las líneas telefónicas y así mantener fuera a los
intrusos. Normalmente la máquina llamada (el servidor) pide al
cliente que se identifique probando que se sabe alguna clave secreta.
Si el llamante se equivoca con la clave, la conexión termina. Con
PPP, las autorizaciones se producen en los dos sentidos; es decir,
el que llama también puede pedir al servidor que se autentifique.
Estos procedimientos de autentificación son totalmente independientes
entre sí. Hay dos protocolos distintos, según el tipo de autentificación,
los cuales discutiremos más adelante en este capítulo: <emphasis>el Protocolo
de Autentificación por Contraseña</emphasis> (PAP) y <emphasis>el Protocolo
de Autentificación por Reto</emphasis> (CHAP).
</para>

<para>
<indexterm><primary>NCP (Protocolo de control de Red)</primary></indexterm>
<indexterm><primary>protocolo</primary><secondary>NCP (Protocolo de control de Red)</secondary></indexterm>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>Protocolo de Control de Red (PPP)</secondary></indexterm>
<indexterm><primary>protocolo</primary><secondary>IP (Internet Protocol)</secondary></indexterm>
<indexterm><primary>IPCP (Internet Protocol Control Protocol)</primary></indexterm>
<indexterm><primary>protocolo</primary><secondary>IPCP (Internet Protocol Control Protocol)</secondary></indexterm>
Cada protocolo de red que es encaminado a través de la conexión de datos, 
como el IP, el Appletalk, etc; se configura dinámicamente usando el 
correspondiente <emphasis>Protocolo de Control de Red</emphasis> (NCP). Por ejemplo, para enviar
datagramas IP a través del enlace, los dos nodos tienen que negociar en 
primer lugar qué direcciones IP van a utilizar. El protocolo de control
utilizado para esto es el <emphasis>Protocolo de Control del IP</emphasis> (IPCP).
</para>


<para>
<indexterm><primary>Compresión de cabeceras Van Jacobson</primary></indexterm>
<indexterm><primary>TCP/IP (Transmission Control Protocol/Internet Protocol)</primary><secondary>comprimiendo paquetes</secondary></indexterm>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>comprimiendo datos</secondary></indexterm>
<indexterm><primary>Protocolo CSLIP (Compressed Serial Line IP)</primary></indexterm>
Aparte de enviar datagramas IP estándar a través del enlace, el PPP
también permite la compresión Van Jacobson de las cabeceras en los
datagramas IP. Es una técnica para reducir las cabeceras de los paquetes
TCP a un espacio de tan sólo tres bytes. También se utiliza en el
CSLIP, y es conocida coloquialmente como compresión de cabeceras VJ.
La utilización de la compresión puede negociarse también al comienzo
de la conexión gracias al IPCP.
</para>


<sect1><title>PPP en Linux</title>
<indexterm><primary>controladores</primary><secondary>PPP</secondary></indexterm>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>controlador</secondary></indexterm>
<indexterm><primary>PPP (Protocol Punto-a-Punto)</primary><secondary>demonio</secondary></indexterm>
<indexterm><primary>pppd (kernel PPP module)</primary></indexterm>
<indexterm><primary>programa chat</primary></indexterm> 
<para>En GNU/ Linux, la funcionalidad del PPP está dividida en dos partes: un
componente del núcleo que controla los protocolos de bajo nivel (HDLC, IPCP,
IPXCP, etc.) y el demonio <command>pppd</command> en espacio de usuario que
controla varios protocolos de alto nivel, como PAP Y CHAP. La versión actual
de PPP para Linux contiene el demonio PPP pppd y un programa llamado
<command>chat</command> utilizado para llamar al sistema remoto.
</para>


<para>
El controlador de PPP para el núcleo fue escrito por Michael Callahan y
reescrito por Paul Mackerras. El <command>pppd</command> fue escrito a partir
de una implementación <footnote id="X-087-2-FNPP03"><para>
Si usted tiene alguna duda genérica sobre PPP, pregunte a gente de la 
lista de correo de Linux-net en <systemitem role="sitename">vger.rutgers.edu</systemitem>.</para></footnote> 
gratuita de PPP para máquinas Sun y 386BSD que a su vez fue escrita por Drew
Perkins y otros programadores, y mantenida por Paul Mackerras. Fue adaptada
a GNU/Linux por Al Longyear.7 <command>Chat</command> fue escrito por Karl Fox.
<footnote id="X-087-2-FNPP04"><para> Se puede contactar con Karl en
<systemitem role="emailaddr">karl@morningstar.com</systemitem>.
</para>
</footnote>
</para>


<para>
<indexterm><primary>ttys</primary><secondary>line discipline</secondary></indexterm>
<indexterm><primary>line discipline</primary></indexterm>
Al igual que  SLIP,  PPP está implementado a través de una disciplina
especial para la utilización de las líneas. Para utilizar una línea serie
como enlace PPP, en primer lugar tendrá que establecer la conexión con su
módem, como es usual; y posteriormente pasar la línea al modo PPP. En este
modo, todos los datos que nos llegan son pasados al <?troff .Nd 10><?troff .wcon_off>controlador PPP,
que comprueba la validez de las tramas HDLC que llegan (cada trama HDLC trae un
código de control de errores de 16 bit), las descompone y las despacha.
Actualmente, PPP es capaz de transportar indistintamente el protocolo IP,
opcionalmente usando la compresión de cabeceras Van Jacobson, y el protocolo
IPX.
</para>


<para>
<indexterm><primary>PPP-HOWTO</primary></indexterm>
<INDEXTERM><PRIMARY>HOWTOs</PRIMARY><SECONDARY>PPP</SECONDARY></INDEXTERM>
El controlador del núcleo es ayudado por <command>pppd</command>, el demonio
del PPP, que realiza toda la fase de inicialización y autentificación necesaria
antes de que el verdadero tráfico de red pueda ser enviado a través del enlace.
El comportamiento del <command>pppd</command> puede ser ajustado utilizando
varias opciones. Como el PPP es bastante complejo, es imposible explicar todas
ellas en un sólo capítulo. Por eso, este libro no puede cubrir todos los
aspectos de <command>pppd</command>, sino sólamente darle una introducción.
Para más información, consulte <emphasis>Using & Managing PPP</emphasis> y las
páginas de manual y los ficheros <filename>README</filename> de la
distribución con las fuentes de <command>pppd</command>, que deberían ayudarle
a comprender la mayor parte de las cuestiones que este capítulo no trata. El
PPP-HOWTO también debería serle de ayuda.
</para>


<para>
<INDEXTERM><PRIMARY>grupos de noticias</PRIMARY><SECONDARY>comp.protocols.ppp</SECONDARY></INDEXTERM>
Probablemente la mejor ayuda que encontrará para configurar PPP vendrá
de otros usuarios de su misma distribución. Las preguntas sobre la
configuración de PPP son muy comunes, así que pruebe en su grupo lista
de correo local o en el canal de Linux del IRC. Si su problema persiste
incluso después de leer toda la documentación, debería pasarse por el
grupo de noticias <systemitem role="newsgroup">comp.protocols.ppp</systemitem>
para solicitar ayuda, que es el lugar donde encontrará a la mayor parte de la
gente envuelta en el desarrollo del <command>pppd</command>.
</para>
</sect1>


<sect1><title>Ejecutando pppd</title>
<para>
<indexterm><primary>Internet</primary><secondary>conectando a</secondary></indexterm>
<indexterm id="idx-commandpppdcommand-1" class="startofrange"><primary>pppd (kernel PPP module)</primary></indexterm>
<INDEXTERM><PRIMARY>servidores de nombres</PRIMARY><SECONDARY>sólo-caché</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>servidores de nombres de sólo-caché</PRIMARY></INDEXTERM>
Cuando quiere conectarse a Internet a través de un enlace PPP, tiene que
configurar las capacidades básicas de red como el dispositivo de bucle local (loopback) y el
sistema de resolución de direcciones. Las dos han sido explicadas en
<xref linkend="X-087-2-iface">, y <xref linkend="X-087-2-resolv">.
Usted puede configurar simplemente el servidor de nombres de su proveedor de
servicios de Internet en el fichero <filename>/etc/resolv.conf</filename>,
pero esto supondrá que cada consulta DNS será enviada a través de su enlace
serie. Esta situación no es óptima; mientras más cerca se encuentre de su
servidor de nombres, más rápida será la búsqueda. Una solución alternativa
es configurar una estación en su red que dé servicio de servidor de nombres
en modo sólo-cachéo. Esto significa que la primera vez que realice una consulta
DNS de un nodo en particular, su consulta será enviada a través de
su línea serie, pero el resto de las consultas a esta misma máquina, serán
directamente resueltas por su servidor de nombres local de una forma
mucho más rápida. Esta configuración está descrita en el Capítulo 6, en
<xref linkend="X-087-2-resolv.named-cachingonly">.&rdquo;
</para>

<para>
Como ejemplo introductorio de como establecer una conexión PPP con 
<command>pppd</command>, suponga que está de nuevo en <systemitem
role="sitename">vlager</systemitem>. Ya ha llamado al servidor PPP, c3po, y
entrado en la cuenta del usuario <systemitem role="userid">ppp</systemitem>.
<systemitem role="sitename">c3po</systemitem> ya ha lanzado su controlador PPP.
Después de salir del programa de comunicaciones que utilizó para llamar,
ejecute la siguiente orden, sustituyendo el nombre del dispositivo serie que
usted usa por el <literal>ttyS3</literal> mostrado aquí:

<screen>
# <userinput>pppd /dev/ttyS3 38400 crtscts defaultroute</userinput>
</screen>
</para>


<para>
<indexterm><primary>handshake, hardware</primary></indexterm>
<indexterm><primary>hardware</primary><secondary>handshake</secondary></indexterm>
Esto cambiará la línea serie <filename>ttyS3</filename> al modo PPP y
establecerá un enlace IP con <systemitem role="sitename">c3po</systemitem>.
La velocidad de transferencia utilizada en el puerto de serie será de 38400bps.
La opción <systemitem role="keyword">crtscts</systemitem> activa el control de
flujo por hardware en el puerto, que es una obligación para velocidades
superiores a los 9600 bps.
</para>


<para>
Lo primero que hace  <command>pppd</command> tras ejecutarse es negociar
varias características para el enlace con el extremo remoto utilizando  LCP.
Normalmente, el conjunto de opciones que intenta negociar <command>pppd</command>
funcionará, así que no nos meteremos más con este asunto. Digamos que parte de 
esta negociación envuelve la solicitud o asignación de las direcciones IP en 
ambos extremos del enlace. 
</para>


<para>
Hasta ahora, también hemos asumido que
<systemitem role="sitename">c3po</systemitem>
no necesita ninguna autentificación de nosotros, así que la fase de configuración
habrá sido completada con éxito.
</para>


<para>
<indexterm><primary>PPP (Protocolo Punto-a-punto)</primary><secondary>Direcciones IP</secondary></indexterm>
<indexterm><primary>IP (Protocolo de Internet)</primary><secondary>direcciones</secondary><tertiary>negociación  PPP</tertiary></indexterm>
<indexterm><primary>direcciones</primary><secondary>negociación con PPP</secondary></indexterm>
<command>pppd</command> negociará entonces los parámetros IP con su
compañero usando IPCP, el protocolo de control IP. Al no especificar dirección
IP alguna, el <command>pppd</command> intentará usar la dirección que se
obtiene al resolver el nombre del ordenador local. Decididas las direcciones,
cada <command>pppd</command> comunicará su dirección al otro extremo.	
</para>

<para>
Normalmente no habrá ningún problema con esta configuración predeterminada.
Incluso si su máquina esta en una Ethernet, puede utilizar la misma dirección
IP tanto para la Ethernet como para el interfaz PPP. No obstante, 
<command>pppd</command> le permite utilizar una dirección diferente, o incluso
pedir a su compañero que utilice alguna dirección específica. Estas opciones
serán discutidas más adelante en la sección <xref linkend="X-087-2-IPconfig.options">&rdquo;.
</para>

<para>
Tras pasar por la fase de configuración IPCP,  <command>pppd</command>
configurará la red de su ordenador para utilizar el enlace PPP. En primer
lugar, configurará el interfaz de red PPP como un enlace punto-a-punto,
utilizando  <filename>ppp0</filename> para el primer enlace PPP que esté
activo, <filename>ppp1</filename> para el segundo, y así sucesivamente.
A continuación preparará una entrada de la tabla de encaminamiento que apunte
al ordenador del otro extremo del enlace. En el ejemplo anterior, el
<command>pppd</command> hará que el encaminamiento de red predeterminado apunte a
<systemitem role="sitename">c3po</systemitem>, debido a que lo especificamos
con la opción <systemitem role="keyword">defaultroute</systemitem>.<footnote
id="X-087-2-FNPP05"><para> El encaminamineto predeterminado es instalado solamente
si no hay ninguno establecido previamente.</para></footnote> Esto provoca que
todos los datagramas dirigidos a ordenadores que no estén en su red sean
enviados a <systemitem role="sitename">c3po</systemitem>; esto es debido a
que es el único camino por el que se puede llegar a esas máquinas. Hay un
variado número de formas de encaminamiento que acepta el <command>pppd</command>,
y las cubriremos en mayor detalle más adelante.
</para>
</sect1>



<sect1 id="X-087-2-ppp.options"><title>Usando los Ficheros de Opciones</title>

<para>
<indexterm><primary>PPP (Protocolo Punto-a-punto)</primary><secondary>ficheros de opciones</secondary></indexterm>
Antes de que el <command>pppd</command> procese los argumentos de su línea de
órdenes, echa un vistazo a varios ficheros para establecer sus opciones por omisión.
Estos ficheros pueden contener cualquier argumento de línea de órdenes
válido, distribuidos a través de un cierto número de líneas. Los comentarios se
escriben tras el símbolo de almohadillado (#).
</para>

<para>
<indexterm><primary SORTAS="etc/ppp/options">fichero /etc/ppp/options</primary></indexterm> 
El primer fichero de opciones es el <filename>/etc/ppp/options</filename>, que
es leído cada vez que el <command>pppd</command> arranca. Utilizarlo para
establecer algunas opciones globales por omisión es una buena idea, pues le
permite evitar que sus usuarios hagan ciertas cosas que podrían comprometer
la seguridad del sistema. Por ejemplo, para hacer que el
<command>pppd</command> necesite algún tipo de autentificación del otro
sistema, añadiría la opción <option>auth</option> a este fichero. Esta opción
no puede ser evitada por el usuario, de forma que se hace totalmente imposible
el establecer una conexión PPP con cualquier sistema que no esté en nuestras
bases de datos para la autentificación. De todas formas, algunas opciones sí
que pueden ser evitadadas; la cadena <systemitem role="keyword">CONNECT</systemitem> 
es un buen ejemplo.
</para>


<para>
<indexterm><primary SORTAS="ppprc">fichero .ppprc</primary></indexterm>
El otro fichero de opciones, que es leído después del
<filename>/etc/ppp/options</filename>, es el <filename>.ppprc</filename>
situado en el directorio de inicio del usuario. Permite que cada usuario especifique
su propio conjunto de opciones predeterminadas.
</para>


<para>
Un fichero <filename>/etc/ppp/options</filename> de ejemplo puede parecerse a éste:

<screen>
# Opciones globales para el pppd de vlager.vbrew.com

lock 			# usar el bloqueo de dispositivo tipo UUCP
auth 			# obligar a autentificación
usehostname 		# usar el nombre del ordenador local para el CHAP
domain vbrew.com 	# nombre de nuestro dominio
</screen>
</para>


<para>
<indexterm><primary>ficheros de bloqueo y PPP</primary></indexterm>
<indexterm><primary>PPP (Protocolo Punto-a-punto)</primary><secondary>ficheros de bloqueo</secondary></indexterm>
La expresión <systemitem role="keyword">lock</systemitem> hace que 
<command>pppd</command> utilice el método de bloqueo de dispositivos estándar
de UUCP. De esta manera, cada proceso que accede a un dispositivo serie, por
ejemplo el <filename>/dev/ttyS3</filename>, crea un fichero de bloqueo llamado
<filename>LCK..ttyS3</filename> en el directorio de spool del UUCP para señalizar
que ese dispositivo esta siendo usado. Esto es necesario para evitar que otros
programas, como pueden ser  <command>minicom</command> o
 <command>uucico</command>, abran el dispositivo de serie mientras éste se
usa por  PPP.
</para>

<para>
La tres opciones siguientes se refieren a la autentificación y, por contrapartida,
a la seguridad del sistema. Las opciones de autentificación están mejor colocadas
en el fichero global de configuración porque tienen &ldquo;privilegios&rdquo; y
no pueden ser sobreescritas por los ficheros <filename>~/.ppprc</filename>de
los usuarios.
</para>
</sect1>



<sect1><title>Realización de la Llamada con chat</title>

<para>
<indexterm><primary>establecer la conexión</primary></indexterm>
<indexterm><primary>chat (programa)</primary><secondary>PPP</secondary></indexterm>
<indexterm id="idx-PPPchatscript-1" class="startofrange"><primary>PPP
(Protocolo Punto-a-Punto)</primary><secondary>chat (script)</secondary></indexterm>
Uno de los problemas que puede haberle dado el ejemplo anterior es que
tenía que establecer la conexión manualmente antes de poder ejecutar
<command>pppd</command>. Al contrario que  <command>dip</command>,
<command>pppd</command> no tiene su propio lenguaje de scripts para
llamar al sistema remoto y entrar en él, sino que confía en otro programa
externo para que haga esto. El comando que tiene que ser ejecutado puede
dársele <command>pppd</command> con la opción <systemitem role="keyword">connect</systemitem>
en la línea de órdenes. El <command>pppd</command> redirigirá la entrada
y salida estándar de órdenes a la línea serie.
</para>


<para>
El paquete <command>pppd</command> incluye un programa muy simple llamado 
chat que es capaz de automatizar secuencias de registro simples. 
Hablaremos sobre este programa con detalle.
</para>


<para>
<INDEXTERM><PRIMARY>programa expect</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>Libes, Don</PRIMARY></INDEXTERM>
Si su secuencia de registro es compleja, necesitará algo más potente que
<command>chat</command>. Una  alternativa útil que debería considerar es
<command>expect</command>, escrito por Don Libes. Tiene un lenguaje
basado en Tcl, y fue diseñado exactamente para este tipo de aplicación.
Aquellos de vosotros cuyas secuencias de registro requieran, por ejemplo,
autentificación por reto/respuesta con generación de claves
encontraréis <command>expect</command> lo suficientemente potente para 
ocuparse de la tarea. Puesto que hay tantas posibles variaciones de este 
tema, no describiremos como desarrollar un guión de expect apropiado en 
este libro. Es suficiente decir, que usted llama a su guión expect 
especificando su nombre con la opción 
<systemitem role="keyword">connect</systemitem> de <command>pppd</command>. 
También es importante señalar que cuando el guión está ejecutándose, la entrada
y la salida estándar estarán desviadas al módem, y no a
la terminal que invocó al <command>pppd</command>. Si usted necesita
interactuar como usuario, usted deberá hacerlo mediante un terminal
virtual compartido, o mediante otros medios.
</para>


<para>
<indexterm id="idx-commandchatcommand-1" class="startofrange"><primary>chat, programa</primary></indexterm>
<indexterm><primary>chat script</primary></indexterm>
La orden <command>chat</command> le permite especificar un script del estilo
de los de UUCP. Básicamente, un script de chat consiste en una secuencia
alterna de cadenas que esperamos recibir del sistema remoto y las respuestas
que hemos de enviar. Las llamaremos respectivamente, cadenas
<emphasis>esperadas</emphasis> y cadenas <emphasis>enviadas</emphasis>.
Este es un extracto de un típico script de chat:

<screen>
ogin: b1ff ssword: s3|&lt;r1t
</screen>
</para>


<para>
Este script le indica a <command>chat</command> que espere a que el sistema remoto
le envíe el mensaje de petición de usuario y entonces le devuelve el nombre
del usuario <systemitem role="userid">b1ff</systemitem>. Sólo esperamos por
<systemitem role="keyword">ogin:</systemitem> para que no importe si el mensaje
de registro empiece por l mayúscula o minúscula, o si llega con basura. La siguiente
cadena es una cadena esperada que hace que  <command>chat</command> espere al
mensaje de petición de contraseña y le envíe nuestra contraseña como respuesta.
</para>

<para>
Esto es básicamente lo que hacen los scripts de chat. Un script completo para
llamar a un servidor PPP debería, además, incluir las órdenes apropiados para
el módem. Suponga que su módem entiende los comandos Hayes, y que el número de
teléfono del servidor es el 318714. En ese caso, la línea completa de
<command>chat</command> para que pudiésemos establecer una conexión con
<systemitem role="sitename">c3po</systemitem> sería:

<screen>
$ <userinput>chat -v '' ATZ OK ATDT318714 CONNECT '' ogin: ppp word: GaGariN</userinput>
</screen>
</para>


<para>
<?troff .hw compatible>
Por definición, la primera cadena que damos a chat tiene que ser una cadena
esperada, pero como el módem no dirá nada hasta que hablemos con él,
hacemos que  <command>chat</command> la ignore especificando una cadena vacía.
Continuamos enviando <systemitem role="keyword">ATZ</systemitem>, la orden de
inicialización para los módems compatibles Hayes, y esperamos a que nos responda
con (<systemitem role="keyword">OK</systemitem>). La siguiente cadena envía a
<command>chat</command> la orden de marcado junto con el número de teléfono,
y espera a que aparezca el mensaje <systemitem role="keyword">CONNECT</systemitem>
como respuesta. Esto está seguido de otra cadena vacía otra vez, porque ahora no
queremos enviar nada, sino esperar a que aparezca el mensaje de petición de registro.
El resto del script de chat funciona exactamente como antes. Esta descripción
probablemente parezca algo confusa, pero veremos en un momento que hay una forma 
de hacer los scrips chat mucho más fáciles de entender.
</para>

<para>
La opción <option>&ndash;v</option> hace que  <command>chat</command> capture
todas las actividades hacia la facilidad <systemitem role="keyword">local2</systemitem>
del demonio <command>syslog.</command>
<footnote id="X-087-2-FNPP06"><para>Si edita el <filename>syslog.conf</filename> para
redirigir estos mensajes a un fichero, asegúrese de que este fichero no pueda ser
leído por cualquiera, pues  <command>chat</command> también captura todo el script
de entrada por omisión - incluyendo las contraseñas.
</para>
</footnote>
</para>

<para>
<indexterm><primary>seguridad</primary><secondary>PPP</secondary></indexterm>
El escribir el script de chat directamente en la línea de órdenes implica
un cierto riesgo, pues los usuarios pueden ver la línea de órdenes de un
proceso con la orden <command>ps</command>. Puede evitar esto colocando
el script del chat en un fichero, por ejemplo llamado <filename>dial-c3po</filename>.
Entonces, podrá hacer al <command>chat</command> leer el script del fichero en vez de
la línea de comando utilizando la opción <option>&ndash;f</option>, seguida por el
nombre del fichero.<?troff .ne 10><?troff .wcon_off>Esto supondrá el beneficio añadido de
hacer nuestra secuencia de chat expect más fácil de entender.
Al modificar nuestro ejempo, nuestro fichero <filename>dial-c3po</filename> tendrá ahora
un aspecto como éste:

<screen>
''      ATZ
OK      ATDT318714
CONNECT ''
ogin:   ppp
word:   GaGariN
</screen>

Cuando usamos un script de chat de esta manera, la cadena que esperamos
recibir está en la izquierda y la respuesta que devolveremos está en
la derecha. Presentándolas así son mucho más fáciles de leer y entender.
</para>


<para>
Por lo tanto la invocación completa al <command>pppd</command> tendrá ahora
un aspecto como éste:

<screen>
# <userinput>pppd connect "chat -f dial-c3po" /dev/ttyS3 38400 -detach \
        crtscts módem defaultroute</userinput>
</screen>
</para>

<para>
Además de la opción <systemitem role="keyword">connect</systemitem> que
se refiere al script de llamada, hemos añadido dos opciones más a la línea
de órdenes: <systemitem
role="keyword">&ndash;detach</systemitem>, que le indica al <command>pppd</command>
que no se separe de la consola y se convierta en un proceso en segundo plano. La palabra
<systemitem role="keyword">modem</systemitem> activa algunas acciones específicas
para módem sobre el dispositivo serie, como colgar la línea antes y después de
la llamada. Si no utiliza esta opción, <command>pppd</command> no se preocupará
de la línea DCD del puerto, y por lo tanto no podrá detectar si el extremo remoto
cuelga de forma imprevista.
</para>


<para>
Los ejemplos anteriores eran bastante simples; <command>chat</command>
permite el uso de scripts mucho más complejos. Una característica muy útil
es la capacidad de especificar cadenas frente a las cuales parar chat
con un error. Unas cadenas típicas para parar pueden ser mensajes como
<systemitem role="keyword">BUSY</systemitem> o
<systemitem role="keyword">NO CARRIER</systemitem>, que son los que su
módem produce cuando el número al que llama comunica o cuando la línea no tiene tono.
Para hacer que  <command>chat</command> las reconozca inmediatamente en vez de
esperar, puede introducirlas al principio del script utilizando la opción 
<systemitem role="keyword">ABORT</systemitem>:

<screen>
$ <userinput>chat -v ABORT BUSY ABORT 'NO CARRIER' '' ATZ OK ...</userinput>
</screen>
</para>

<para>
Igualmente, puede variar el valor del tiempo de espera para algunas
partes de los scripts de chat insertando opciones
<systemitem role="keyword">TIMEOUT</systemitem>.
</para>


<para>
Algunas veces, también querrá disponer de algún tipo de ejecución condicional
de algunas partes del script de chat. Por ejemplo, cuando reciba el mensaje de
petición de registro (login) desde el extremo remoto, puede que quiera enviar un BREAK, o
un retorno de carro. Puede conseguir esto añadiendo un sub-script a la parte
de la cadena esperada. Consiste en una secuencia de cadenas de envío y esperadas,
de la misma forma que el script en su totalidad, pero separadas por guiones.
El sub-script es ejecutado desde el momento en que la cadena esperada a la que
están ligados no es recibida a tiempo. Para este ejemplo, modificaríamos el
script de chat de la siguiente manera:

<screen>
ogin:-BREAK-ogin: ppp ssword: GaGariN
</screen>
</para>
<?troff .Nd 10>
<para>

Ahora, cuando  <command>chat</command> no recibe el mensaje de login del
sistema remoto, se ejecuta el sub-script enviando un BREAK y esperando de
nuevo por el mensaje de login. Si ahora ya aparece, el script continúa como
usualmente y si no, termina con un error.

<indexterm class="endofrange" startref="idx-PPPchatscript-1">
<indexterm class="endofrange" startref="idx-commandchatcommand-1">

</para>
</sect1>


<sect1 id="X-087-2-IPconfig.options"><title>Opciones de Configuración IP</title>

<para>
<indexterm><primary>IPCP (Internet Protocol Control Protocol)</primary></indexterm>
El IPCP se utiliza para negociar varios parámetros IP a la hora de configurar
la conexión. Normalmente, cada extremo de comunicación puede enviar un Paquete
de Petición de Configuración IPCP, indicando qué valores quiere cambiar de los
que vienen predeterminados, y a qué valor. Tras la recepción, el extremo remoto
inspecciona cada opción sucesivamente, y responde que la acepta, o la rechaza.
</para>

<para>
<command>pppd</command> le da gran control sobre qué opciones intentará
negociar el IPCP. Puede ajustar esto a través de varias opciones en la línea
de órdenes de las que hablamos a continuación.
</para>


<sect2><title>Eligiendo Direcciones IP</title>

<para>
<indexterm><primary>PPP (Point-to-Point Protocol)</primary><secondary>direcciones IP</secondary></indexterm>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>direcciones</secondary><tertiary>negociación con PPP</tertiary></indexterm>
<indexterm><primary>direcciones</primary><secondary>negociación con PPP</secondary></indexterm>
Todos los interfaces IP requieren de direcciones IP asignadas a ellos; Un dispositivo
PPP siempre tiene una dirección IP. El conjunto de protocolos PPP provee un mecanismo
que permite la asignación automática de direcciones IP a interfaces PPP. Es posible
para el programa PPP en un extremo del enlace punto a punto asignar una dirección IP
al extremo opuesto para que la use, o que cada uno use la suya.
</para>

<para>
Algunos servidores PPP que sirven a muchos clientes asignan direcciones
dinámicamente: las direcciones son asignadas a los sistemas sólo cuando
llaman, y son reclamadas de nuevo una vez que se desconecta. Esto permite
que el número de direcciones IP requeridas esté limitado al número de
líneas conectadas. Mientras la limitación es conveniente para quienes
gestionan los servidoresde marcado PPP, es a menudo menos conveniente
para los usuarios que están intentando conectar. Ya discutimos la forma en
la que los nombres de nodo son transformados en direccionnes IP mediante una base
de datos en <xref linkend="X-087-2-resolv">. Para permitir que la gente se
conecte a su nodo, ellos deben saber su dirección IP o el nombre del nodo asociado
a ella. Si usted es usuario de un servicio PPP que le asigna una dirección IP
de forma dinámica, este conocimiento es difícil sin permitir de alguna manera a la
base de datos DNS que se actualice después de que le es asignada la dirección IP.
Este tipo de sistemas existen, pero nosotros no los cubriremos en detalle aquí;
en cambio, miraremos hacia una situación más preferible, la cual implica que
sea capaz de utilizar la misma dirección IP cada vez que se establece su
conexión de red.
<footnote
id="X-087-2-FNPP07"><para>Más información sobre mecanismos de asignación dinámica 
a nodos puede encontrarse aquí: 
<systemitem role="url">http://www.dynip.com/</systemitem> y 
<systemitem role="url">http://www.justlinux.com/dynamic_dns.html</systemitem>.
</para>
</footnote>
</para>

<para>
En el ejemplo anterior, hacíamos que <command>pppd</command> llamase
a <systemitem role="sitename">c3po</systemitem> y estableciera una conexión IP.
No nos preocupábamos de elegir una dirección IP particular en ninguno de los
extremos de la conexión. En vez de ello, tomábamos la dirección de
<systemitem role="sitename">vlager</systemitem> como la dirección IP local, y
dejábamos a <systemitem role="sitename">c3po</systemitem> darse su propia
dirección. El pppd soporta diferentes alternativas a esta aproximación.
</para>


<para>
Para pedir direcciones particulares, normalmente dé a <command>pppd</command>
la siguiente opción:

<screen>
<replaceable>local_addr</replaceable>:<replaceable>remote_addr</replaceable>
</screen>
</para>

<para>
<replaceable>local_addr</replaceable> y 
<replaceable>remote_addr</replaceable> pueden ser especificados tanto en
notación de cuaternas numéricas o como nombres de nodo.<footnote
id="X-087-2-FNPP08"><para> Usar nombres de dominio en esta opción tiene
consecuencias en la autentificación CHAP. Por favor, consulte la sección <xref
linkend="X-087-2-ppp.authentication">&rdquo; más adelante en este mismo capítulo.
</para>
</footnote>
Esta opción hace a <command>pppd</command> intentar usar la primera dirección como
su propia dirección IP, y la segunda como la de su compañero. Si el compañero
rechaza alguna de ellas durante la negociación IPCP, no se establecerá ninguna
conexión IP.<footnote id="X-087-2-FNPP09"><para>
Las opciones <option>ipcp-accept-local</option> y <option>ipcp-accept-remote</option>
indican a <command>pppd</command> aceptar la dirección local y remota ofrecidas
por el PPP remoto, incluso si usted a provisto de alguna en su configuración. Si
estas opciones no son configuradas, su <command>pppd</command> rechazará cualquier
intento de negociación de las direcciones IP usadas.
</para>
</footnote>
</para>


<para>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>Asignación dinámica de direcciones</secondary></indexterm>
Si usted está llamando a un servidor y espera que éste le asigne una
dirección IP, debe asegurarse de que <command>pppd</command> no intenta
negociar una por sí mismo. Para hacer esto, use la opción <option>noipdefault</option>
y deje la opción <replaceable>local_addr</replaceable> en blanco.
La opción <option>noipdefault</option> evitará que  <command>pppd</command>
intente usar la dirección IP asociada al nombre de ordenador como la dirección local.
</para>

<para>
Si sólo quiere establecer la dirección local, y aceptar cualquier dirección
que utilice el compañero, simplemente deseche la parte 
<replaceable>remote_addr</replaceable>. Por ejemplo, para hacer
a <systemitem role="sitename">vlager</systemitem> usar la dirección
IP <systemitem role="sitename">130.83.4.27</systemitem> en vez de la suya
propia, le escribiría <option>130.83.4.27:</option>
en la línea de orden. De forma similar, para establecer la dirección remota
únicamente, dejaría el campo de la <replaceable>dir_local</replaceable> en blanco.
Por omisión, <command>pppd</command> utilizará entonces la dirección
asociada al nombre de su ordenador.
</para>
</sect2>


<sect2><title>Encaminamiento a través de un enlace PPP</title>
<para>
<indexterm><primary>encaminamiento</primary><secondary>sobre PPP</secondary></indexterm>
<indexterm id="idx-PPProuting-1" class="startofrange"><primary>PPP (Point-to-Point Protocol)</primary><secondary>encaminamiento</secondary></indexterm>
Tras configurar el interfaz de red, <command>pppd</command> preparará un
encaminamiento que solamente le sirve para comunicarse con el otro extremo.
Si el ordenador remoto está en una red de área local, seguramente usted
deseará conectar también con los ordenadores que están "detrás" de él; para
eso, se ha de configurar un encaminamiento de red adecuado.
</para>

<para>
Ya hemos visto antes que se puede pedir a <command>pppd</command> que
configure el encaminamiento predeterminado utilizando la opción
<option>defaultroute</option>. Esta opción es muy útil si el servidor PPP al
que llama va a actuar como su pasarela a Internet.
</para>


<para>
<indexterm><primary>ARP (Protocolo de Resolución de Dirección)</primary><secondary>proxy</secondary></indexterm>
<indexterm><primary>proxy ARP</primary></indexterm>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>proxy ARP</secondary></indexterm>
<?troff .hw Winery>
El caso contrario, cuando su sistema actúa como una pasarela para un sólo
ordenador, es también relativamente fácil de llevar a cabo. Por ejemplo,
imagine a algún empleado de la Cervecera Virtual cuyo ordenador de casa se
llama <systemitem role="sitename">oneshot</systemitem>. Cuando esté conectando
a <systemitem role="sitename">vlager</systemitem> a través de PPP, él utiliza
una dirección de la subred de la Cervecera. Podremos dar a <command>pppd</command> del ordenador
<systemitem role="sitename">vlager</systemitem> la opción <option>proxyarp</option>,
que instalará una entrada proxy-ARP para el ordenador <systemitem
role="sitename">oneshot</systemitem>. Esto hará que
<systemitem role="sitename">oneshot</systemitem> sea automáticamente accesible desde todos
los ordenadores de la Cervecera y la Vinatera.
</para>


<para>
<indexterm><primary>Redes de Área Local (LANs)</primary><secondary>conexión</secondary></indexterm>
De cualquier manera, las cosas no son siempre tan fáciles como esto, por ejemplo
cuando intentamos unir dos redes de área local. Esto requiere normalmente el
añadir una ruta de red especifica, porque estas redes tendrán ya sus propios
encaminamientos por defecto. Por otra parte, el tener los dos extremos de
comunicación utilizando la conexión PPP como encaminamiento por defecto
generaría un ciclo sin fin, donde los paquetes con destinos desconocidos
rebotarían entre los dos ordenadores hasta que su tiempo de vida (TTL) expirase.
</para>

<para>
Pongamos un ejemplo: suponga que la Cervecera Virtual abre una sucursal en
alguna otra ciudad. La sucursal utiliza su propia red Ethernet utilizando el
número de red IP <systemitem role="sitename">172.16.3.0</systemitem>, que es
la subred 3 de la red de clase B de la Cervecera. Quieren conectarse a la red
Ethernet principal de la Cervecera a través de PPP para actualizar las bases
de datos de clientes, etc. De nuevo, <systemitem role="sitename">vlager</systemitem>
actuará como pasarela; la otra máquina se llama <systemitem role="sitename">vbourbon</systemitem>
y tiene una dirección IP de <systemitem role="sitename">172.16.3.1</systemitem>.
Esta red está ilustrada en <xref linkend="X-087-2-appendix.brewery.subsidiary"> en
<xref linkend="X-087-2-appendix.brewery">.
</para>


<para>
Cuando <systemitem role="sitename">vbourbon</systemitem> conecta
a <systemitem role="sitename">vlager</systemitem>, hará que el punto de
encaminamiento predeterminado sea <systemitem role="sitename">vlager</systemitem>,
como es habitual. En <systemitem role="sitename">vlager</systemitem>, de todas
formas, tendremos que instalar un encaminamiento de red para la subred 3 que vaya
a través de <systemitem role="sitename">vbourbon</systemitem>.
Podriamos hacer esto manualmente usando la orden <command>route</command> después
de que el enlace PPP sea establecido, pero esta no es una solución muy práctica.
Afortunadamente, podemos configurar la ruta automáticamente utilizando una
característica de <command>pppd</command> de la que no hemos hablado hasta
ahora - la orden <command>ip-up</command>. Es un script de
shell situado en <filename>/etc/ppp</filename> que se ejecuta después de que el
interfaz PPP ha sido configurado. Cuando está presente, se le llama con los
siguientes parámetros:

<screen>
ip-up <replaceable>interface</replaceable> <replaceable>dispositivo</replaceable> <replaceable>velocidad</replaceable> <replaceable>dir_local</replaceable> <replaceable>dir_remota</replaceable>
</screen>
</para>

<para>
La tabla siguiente resume el significado de cada uno de los argumentos (en la primera
columna, se muestra el número usado por el script de shell para referirse a cada
argumento):

<informaltable>
<tgroup cols=3>
<colspec colwidth="0.635cm">
<colspec colwidth="0.635cm">
<colspec colwidth="6.985cm">
<thead>
<row>
	<entry>Argumento</entry>
	<entry>Nombre</entry>
	<entry>Propósito</entry>
</row>
</thead>
<tbody>
<row>
	<entry>$1</entry>
	<entry><replaceable>interfaz</replaceable></entry>
	<entry><para>
	Interfaz de red usado, e.g., <literal>ppp0</literal>	
	</para></entry>
</row>
<row>
	<entry>$2</entry>
	<entry><replaceable>dispositivo</replaceable></entry>
	<entry><para>
	dispositivo es la ruta al dispositivo serie utilizado,(&hairsp;<filename>/dev/tty</filename>
	si se utiliza la salida y entrada estándar)
	</para></entry>
</row>
<row>
	<entry>$3</entry>
	<entry><replaceable>velocidad</replaceable></entry>
	<entry><para>	
	La velocidad del dispositivo en bits por segundo.
	</para></entry>
</row>
<row>
	<entry>$4</entry>
	<entry><replaceable>dir_local</replaceable></entry>
	<entry><para>
	La dirección IP del extremo local del enlace en notación de cuarteto.
	</para></entry>
</row>
<row>
	<entry>$5</entry>
	<entry><replaceable>dir_remota</replaceable></entry>
	<entry><para>
	La dirección IP del extremo remoto de la conexión
	</para></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>

<para> 
En nuestro caso, el guión <command>ip-up</command> puede contener el
siguiente fragmento de código:<footnote id="X-087-2-FNPP10"><para>
Si quisieramos tener rutas creadas para otros sitios cuando se conecten,
tendriamos que añadir entradas apropiadas para permitir a aquellos
<literal>...</literal> que aparecieran en el ejemplo.
</para>
</footnote>

<screen>
#!/bin/sh
case $5 in
172.16.3.1)            # este es vbourbon
        route add -net 172.16.3.0 gw 172.16.3.1;;
...
esac
exit 0
</screen>
</para>

<para>
De una forma análoga,<command>/etc/ppp/ip-down</command> se utiliza para deshacer
todas las acciones de <command>ip-up</command> después de que la conexión PPP
ha sido cortada. Asi en nuestro script <command>/etc/ppp/ip-down</command> tendremos
una orden <command>route</command> que elimine la ruta que creamos con el 
script <command>/etc/ppp/ip-up</command>. 
</para> 

<para>
<indexterm><primary>encaminamiento</primary><secondary>dinámico</secondary></indexterm>
<indexterm><primary>gated, orden</primary></indexterm>
A pesar de todo, la tabla de encaminamiento aún no está completa. Hemos
configurado las entradas de la tabla de encaminamiento para los dos
ordenadores con PPP, pero hasta ahora, todos los demás ordenadores de las
dos redes no saben nada sobre la conexión PPP. Esto no es un gran
problema si todos los ordenadores de la sucursal tienen
su encaminamiento predeterminado encaminado a <systemitem role="sitename">vbourbon</systemitem>,
y todos los ordenadores de la Cervecera encaminan hacia
<systemitem role="sitename">vlager</systemitem> por omisión. Si éste no fuera el
caso, su única posibilidad normalmente será usar un demonio de encaminamiento como
<command>gated</command>. Tras crear el encaminamiento de la red
en <systemitem role="sitename">vlager</systemitem>, el demonio de encaminamiento
pasará el nuevo encaminamiento a todos los ordenadores de las redes dependientes de ésta.
<indexterm class="endofrange" startref="idx-PPProuting-1">
</para>

</sect2>

</sect1>

<sect1><title>Opciones de Control de Enlace</title>

<para>
<indexterm id="idx-LinkControlProtocolPPP-1" class="startofrange"><primary>LCP (Link Control Protocol)</primary><secondary>opciones</secondary></indexterm>
Anteriormente, ya hemos tratado sobre  LCP, el protocolo de control de enlace
(Link Control Protocol), que se utiliza para negociar las características de
la conexión y comprobarla. 
</para> 

<para> 
Las dos opciones más importantes que pueden ser negociadas por el LCP
son la <emphasis>unidad máxima de recepción</emphasis> (MRU) y el
<emphasis>mapa de caracteres de control asíncronos</emphasis>. También hay
varias opciones más de configuración LCP, pero son demasiado específicas como
para comentarlas aquí. Eche un vistazo a la RFC 1548 para ver una descripción de éstas.
</para> 

<para>
<indexterm><primary>línea serie</primary><secondary>protección de caracteres</secondary></indexterm>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>escapando caracteres de control</secondary></indexterm>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>async map</secondary></indexterm>
<INDEXTERM><PRIMARY>Mapa asíncrono de Caracteres de Control</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>mapa asíncrono</PRIMARY></INDEXTERM>
El mapa de caracteres de control asíncronos, también conocido como el
<emphasis>mapa asíncrono</emphasis>, se usa en enlaces asíncronos, como las
líneas telefónicas, para identificar los caracteres de control que deben de ser
reemplazados por una secuencia específica de dos caracteres, para evitar que sean
interpretados por el equipamiento utilizado para establecer el enlace. Por ejemplo, puede
que quiera evitar los caracteres XON y XOFF utilizados con el control de flujo
hardware activado, pues algún módem mal configurado puede parar hasta que reciba
un XOFF. Otro candidato puede ser Ctrl-] (el carácter de escape del
<command>telnet</command>). PPP le permite obviar/rehuir de cualquiera de los caracteres
con códigos ASCII comprendidos entre 0 y 31 especificándolos en el mapa asíncrono.
</para> 

<para> 
El mapa asíncrono (async map) es un mapa de bits de 32 bits de ancho, y cuyo
bit menos significativo corresponde al carácter ASCII NUL, y cuyo bit mas
significativo corresponde al ASCII 31. Estos 32 caracteres ASCII son los
caracteres de control. Si un bit se pone a 1, indica que el carácter
<?troff .ne 10>
correspondiente debe de ser "escapado" antes de ser enviado a través de la
conexión.
</para> 

<para> 
Para decir al otro ordenador que no tiene que rehuir de todos los caracteres
de control sino sólo de algunos, puede establecer un nuevo mapa asíncrono
al <command>pppd</command> utilizando la opción <command>asyncmap</command>.
Por ejemplo, si sólo <literal>^S</literal> y <literal>^Q</literal> (los códigos
ASCII 17 y 19, normalmente utilizados para XON y XOFF) deben de ser "escapados",
utilice la siguiente opción:

<screen>
asyncmap 0x000A0000
</screen>
</para>

<para>
<?troff .hw characters>
Mientras sepa convertir binario a hexadecimal la conversión es simple.
Coloque 32 bits enfrente de usted. El bit más a la derecha corresponde al
ASCII 00(NULL), y el de más a la izquierda al ASCII 32 decimal.
Establezca los bits que corresponden a los caracteres que quiera "escapar" a uno,
y el resto a 0. Para convertir eso al número en hexadecimal que el
<command>pppd</command> espera, simplemente coja cada grupo de 4 bits y conviértalos
en hexadecimal. Debería terminar con ocho figuras en hexadecimal. Póngalos
todos juntos en cadena y antepóngale &ldquo;0x&rdquo; para mostrar que es un número hexadecimal,
y habrá terminado.
</para> 

<para> 
Inicialmente, el mapa asíncrono se establece como <literal>0xffffffff</literal>&mdash;
lo que significa que todos los caracteres de control serán "escapados".
De partida esto es seguro, pero normalmente es más de lo que necesita. Cada carácter
que aparece en el mapa asíncrono produce dos caracteres que son transmitidos a través
del enlace, así al introducir estos caracteres de escape se produce un incremento de la
utilización del enlace y la correspondiente reducción del rendimiento.
</para> 

<para> 
En la mayoria de las circunstancias, un mapa asíncrono de <literal>0x0</literal>
funcionará correctamente. No se producen caracteres de escape.
</para> 

<para>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>Unidad Maxima de Recepción</secondary></indexterm>
<indexterm><primary>Unidad Máxima de Recepción (MRU)</primary></indexterm>
<indexterm><primary>MRU (Unidad Máxima de Recepción)</primary></indexterm> 
La unidad máxima de recepción, o MRU, señaliza al otro extremo el tamaño
máximo de las tramas HDLC que queremos recibir. Aunque esto puede que le
recuerde al valor de la MTU (unidad máxima de transferencia), tienen poco
en común. El MTU es un parámetro del dispositivo de red del núcleo, y
describe el tamaño máximo de la trama que el interfaz es capaz de soportar.
El MRU es más bien un consejo al ordenador remoto para que no genere ninguna
trama más grande que la MRU; no obstante, el interfaz ha de ser capaz de
recibir tramas de hasta 1500 bytes.
</para> 

<para>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>Compresión de datos</secondary></indexterm>
Por lo tanto, elegir un MRU no es tanto una cuestión de que es capaz
de transmitir la conexión, sino de cómo conseguir el mejor rendimiento.
Si va a usar la conexión para aplicaciones interactivas, el poner en el
MRU valores tan bajos como 296 es una buena idea, de forma que un paquete
ocasional mayor (digamos, de una sesión de FTP) no haga a su cursor
&ldquo;saltar.&rdquo;. Para decir al <command>pppd</command> que pida un
MRU de 296, pondría la opción <literal>mru 296</literal>. Las MRUs pequeñas,
de todas maneras, sólo tienen sentido si no tiene la compresión de cabecera
VJ desactivada (esta activada por omisión), de otra manera desaprovechará
una gran cantidad de su ancho de banda sólo transportando la cavecera IP de
cada datagrama.
</para> 

<para> 
El <command>pppd</command> también entiende un par de opciones LCP que configuran
el comportamiento general del proceso de negociación, como es el máximo número de
peticiones de configuración que pueden ser intercambiadas antes de que se corte
la conexión. A menos que sepa exactamente lo que esta haciendo, deberá dejar este
valor fijo.
</para> 

<para>
<INDEXTERM><PRIMARY>LCP (Protocolo de Control de Enlace)</PRIMARY><SECONDARY>Mensajes de eco</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>Echo Request/Echo Response, mesajes</PRIMARY></INDEXTERM>
Finalmente, hay dos opciones que se aplican a los mensajes de eco del LCP.
El PPP define dos mensajes,<emphasis>Petición de Eco</emphasis>  y
<emphasis>Respuesta de Eco</emphasis>. El <command>pppd</command> usa esta
característica para comprobar si la conexión esta aún operativa. Puede
habilitarla utilizando la opción <option>lcp-echo-interval</option> junto con
el tiempo en segundos. Si no se reciben tramas del ordenador remoto en este
intervalo, el <command>pppd</command>  genera una Petición de Eco, y espera a
que el compañero devuelva una Respuesta de Eco. Si el compañero no produce una
respuesta, la conexión es cortada después de que se hayan enviado un cierto
número de peticiones. Este número puede ser establecido utilizando la opción
<option>lcp-echo-failure</option>. predeterminado, esta característica también
esta desactivada.
<indexterm class="endofrange" startref="idx-LinkControlProtocolPPP-1">
</para>
</sect1>


<sect1><title>Consideraciones de Seguridad General</title>
<para>
<indexterm><primary>acceso</primary><secondary>PPP</secondary></indexterm>
<indexterm><primary>pppd (Modulo PPP del núcleo)</primary></indexterm>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>seguridad</secondary></indexterm>
<indexterm id="idx-securityPPP-1" class="startofrange"><primary>seguridad</primary><secondary>usando PPP</secondary></indexterm>
Un demonio de PPP mal configurado puede ser un peligroso agujero en la seguridad.
Es equivalente a dejar a cualquiera enganchar su máquina a su red Ethernet
(y eso es muy malo). En esta sección, discutiremos algunas medidas que deberían
hacer su configuración de PPP segura.
</para>

<note><para>
Configurar el dispositivo de red y la tabla de encaminamiento requiere los
privilegios de root. Normalmente resolverá esto ejecutando
<command>pppd</command> como setuid de <systemitem
role="userid">root</systemitem>. Sin embargo, <command>pppd</command>
permite a los usuarios establecer varias opciones relacionadas con la seguridad.
</para></note>

<para>
<INDEXTERM><PRIMARY SORTAS="etc/ppp/options file">/etc/ppp/options fichero</PRIMARY></INDEXTERM>
Para protegerse contra cualquier ataque que pueda lanzar algún usuario
manipulando estas opciones, se sugiere que establezca un par de valores
predeterminado en el fichero global <filename>/etc/ppp/options</filename>, tal
como los mostrados en el fichero de ejemplo en <xref
linkend="X-087-2-ppp.options">,&rdquo; al principio de este capítulo.
Algunos de ellos, como los de las opciones de autentificación, no pueden ser
después modificados por el usuario, así que proporcionan una razonable protección
contra las manipulaciones. Una opción importante que proteger es la opción <systemitem
role="keyword">connect</systemitem>. Si pretende permitir a usuarios no root
invocar <command>pppd</command> para conectar a Internet, debería siempre añadir
las opciones <literal>connect</literal> y <literal>noauth</literal> al fichero de
opciones globales <filename>/etc/ppp/options</filename>. <?troff .ne 10> Si no
hace esto, los usuarios serán capaces de ejecutar ordenes arbitrarias con privilegios
de <literal>root</literal> especificandolas como argumento del <command>pppd</command>
en la orden de <systemitem role="keyword">connect</systemitem> o en sus ficheros de
opciones personales.
</para>

<para>
Otra buena idea es restringir qué usuarios pueden ejecutar <command>pppd</command>
creando un grupo en <filename>/etc/group</filename> e introducir sólo aquellos usuarios
que usted desea que tengan la habilidad de ejecutar el demonio PPP. Despues debería
cambiar la propiedad de grupo del demonio <command>pppd</command> a ese grupo y quitar 
los privilegios de ejecución globales. Para hacer esto, asumiendo que ha llamado a su
grupo <systemitem role="userid">dialout</systemitem>, podria usar algo como esto:

<screen>
# <userinput>chown root /usr/sbin/pppd</userinput>
# <userinput>chgrp dialout /usr/sbin/pppd</userinput>
# <userinput>chmod 4750 /usr/sbin/pppd</userinput>
</screen>
</para>

<para>
Por supuesto, también tiene que protegerse de los sistemas con los que habla
PPP. Para evitar que otros ordenadores puedan hacerse pasar por quien no
son, debe utilizar siempre algún tipo de autentificación con el otro extremo
de la comunicación. Además, no debería permitir a ordenadores desconocidos
usar cualquier dirección IP que elijan, sino restringirlas a unas pocas. La
siguiente sección tratará sobre estos asuntos.
</para>
</sect1>


<sect1 id="X-087-2-ppp.authentication"><title>Autentificación con PPP</title>

<para>
<indexterm id="idx-PPPauthentication-1" class="startofrange"><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>autentificación</secondary></indexterm>
<indexterm id="idx-authenticationwithPPP-1" class="startofrange"><primary>autentificación</primary><secondary>con PPP</secondary></indexterm>
<indexterm><primary>CHAP (Protocolo de autentificación por Reto)</primary></indexterm>
<indexterm><primary>PAP (Protocolo de autentificación por Contraseña)</primary></indexterm>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>usando CHAP</secondary></indexterm>
<indexterm><primary>PPP (Point-to-Point Protocol)</primary><secondary>usando PAP</secondary></indexterm>
Con el PPP, cada sistema puede obligar al otro ordenador a identificarse usando
uno de los dos protocolos de autentificación disponibles. Estos son el Protocolo
de Autentificación por Contraseña (PAP), y el Protocolo de Autentificación por
Reto (CHAP). Cuando se establece una conexión, cada extremo puede pedir al otro
que se autentifique, independientemente de que sea el llamante o el llamado. Más
adelante, utilizaré relajadamente &ldquo;cliente&rdquo; y &ldquo;servidor&rdquo;
cuando quiera distinguir entre el sistema autentificado y el autentificador. Un
demonio PPP puede pedir a la otra máquina autentificación enviando otra petición
más de configuración de LCP indicando el protocolo de autentificación deseado.
</para>


<sect2><title>PAP frente a CHAP</title>

<para>
PAP, que es utilizado por muchos proveedores de Internet (ISP), funciona
básicamente de la misma forma que el procedimiento normal de registro. El cliente
se autentifica a sí mismo enviando un nombre de usuario y una contraseña
(opcionalmente encriptada) al servidor, la cual es comparada por el servidor
con su base de datos de claves o secrets. <footnote id="X-087-2-FNPP11"><para>
&ldquo;secrets&rdquo; es sólo el nombre que da PPP a las contraseñas. Las
contraseñas de PPP no tienen las mismas limitaciones de tamaño que las
contraseñas de registro de Linux.
</para>
</footnote>
Esta técnica es vulnerable a los intrusos que pueden intentar obtener la
contraseña escuchando en una línea  serie y a otros que hagan sucesivos
intentos de ataque por el método de prueba y error.
</para>

<para>
CHAP no tiene estos defectos. Con  CHAP, el autentificador (i.e. el
servidor) envía una cadena de &ldquo;reto&rdquo; generada aleatoriamente
al cliente, junto a su nombre de ordenador. El cliente utiliza el nombre
del ordenador para buscar la clave apropiada, la combina con el reto, y
encripta la cadena utilizando una función de codificación de un solo
sentido. El resultado es devuelto al servidor junto con el nombre del
ordenador cliente. El servidor realiza ahora la misma computación, y
advierte al cliente si obtiene el mismo resultado.
</para>

<para>
Otra característica de CHAP es que no solicita autentificación al cliente
solamente al comienzo de la sesión, sino que envía retos a intervalos
regulares para asegurarse de que el cliente no ha sido reemplazado por un
intruso, por ejemplo cambiando la línea telefónica, o debido a una
configuración errónea del módem que causa que el demonio PPP no se
perciva que la llamada original de teléfono se ha cortado y algún
otro se ha conectado.
</para>

<para>
<indexterm><primary SORTAS="etc/ppp/chap-secrets file">/etc/ppp/chap-secrets fichero</primary></indexterm> 
<indexterm><primary SORTAS="etc/ppp/pap-secrets file">/etc/ppp/pap-secrets fichero</primary></indexterm> 
El <command>pppd</command> mantiene las claves secretas para el CHAP y el PAP
en dos ficheros separados, llamados <filename>/etc/ppp/pap-secrets</filename>
y <filename>/etc/ppp/chap-secrets</filename> respectivamente. Si introduce un
ordenador remoto en alguno de los dos ficheros, tendrá un buen control de cual
de los protocolos CHAP o PAP se utilizará para autentificarnos con él y
viceversa.
</para>

<para>
Por omisión, <command>pppd</command> no pide autentificación al ordenador
remoto, pero aceptará el autentificarse a sí mismo cuando se lo pida el
ordenador remoto. Como  CHAP es mucho más fuerte que  PAP, el
<command>pppd</command> intenta usar el anterior siempre que es posible. Si
el otro ordenador no lo acepta, o  <command>pppd</command> no encuentra una
clave CHAP para el sistema remoto en su fichero <filename>chap-secrets</filename>,
cambia al PAP. Si tampoco tiene clave PAP para su compañero, renunciará a
autentificarse. Como consecuencia de esto, se cerrará la conexión.
</para>

<para>
Este comportamiento puede ser modificado de varias formas. Por ejemplo, cuando
se añade la palabra <option>auth</option>,  <command>pppd</command> solicitará
al otro ordenador que se autentifique.  <command>pppd</command> aceptará el uso
de CHAP o  PAP para ello, siempre y cuando tenga una clave para su compañero
en su base de datos CHAP o PAP respectivamente. Hay otras opciones para activar o
no un determinado protocolo de autentificación, pero no las describiré aquí. Puede
leer la página de manual del pppd(8) para más detalles.
</para>

<para>
<indexterm><primary SORTAS="etc/ppp/options file">/etc/ppp/options fichero</primary></indexterm> 
Si todos los sistemas con los que conversa PPP están de acuerdo en
autentificarse con usted, debería poner la opción <option>auth</option> en el
fichero global <filename>/etc/ppp/options</filename> y definir contraseñas
para cada sistema en el fichero <filename>chap-secrets</filename>. Si un
sistema no acepta  CHAP, añada una entrada para él al fichero
<filename>pap-secrets</filename>. De esta forma, puede asegurarse de que
ningún sistema sin autentificar se conecta a su ordenador.
</para>

<para>
Las dos secciones siguientes hablan sobre los dos ficheros de claves de PPP,
<filename>pap-secrets</filename> y <filename>chap-secrets</filename>. Están
situados en <filename>/etc/ppp</filename> y contienen tripletes de clientes,
servidores y contraseñas, seguidas opcionalmente por una lista de direcciones
IP. La interpretación de los campos de servidor y cliente es distinta en 
CHAP y  PAP, y también depende de si nos autentificamos nosotros con el otro
ordenador, o si solicitamos al servidor que se autentifique con nosotros.
</para>
</sect2>

<sect2><title>El fichero de claves CHAP</title>

<para>
<indexterm><primary>CHAP (Protocolo de autentificación por Reto)</primary></indexterm>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>usando CHAP</secondary></indexterm>
<indexterm><primary SORTAS="etc/ppp/chap-secrets file">/etc/ppp/chap-secrets fichero</primary></indexterm> 
<INDEXTERM id="ppp.secrets.files" class=startofrange><PRIMARY>PPP (Protocolo Punto-a-Punto)</PRIMARY><SECONDARY>fichero secrets</SECONDARY></INDEXTERM>
Cuando tiene que autentificarse con algún servidor utilizando CHAP, 
<command>pppd</command> busca en el fichero <filename>chap-secrets</filename>
una entrada cuyo campo de cliente sea igual al nombre del ordenador local, y
cuyo campo de servidor sea igual al nombre del ordenador remoto enviado en el
reto del CHAP. Cuando solicita a la otra máquina que se autentifique, los 
roles son simplemente al revés: el pppd entonces buscará una entrada que tenga 
el campo de cliente igual al nombre del ordenador remoto (enviado en la 
respuesta del CHAP del cliente), y el campo de servidor igual al nombre del ordenador local.
</para>

<para>
El siguiente es un fichero de ejemplo de <filename>chap-secrets</filename>
para <systemitem role="sitename">vlager</systemitem>:<footnote id="X-087-2-FNPP12"><para>
Las comillas no son parte de la contraseña, simplemente sirven para proteger el
espacio en blanco del interior de la contraseña.
</para>
</footnote>
</para>

<para>
<screen>
# CHAP secrets for vlager.vbrew.com
#
# client         server           secret                addrs
#---------------------------------------------------------------------
vlager.vbrew.com  c3po.lucas.com   "Use The Source Luke" vlager.vbrew.com
c3po.lucas.com    vlager.vbrew.com "arttoo! arttoo!"     c3po.lucas.com
*                 vlager.vbrew.com "TuXdrinksVicBitter"  pub.vbrew.com
</screen>
</para>

<para>
Cuando se intenta establecer una conexión PPP con
<systemitem role="sitename">c3po</systemitem>, <systemitem role="sitename">c3po</systemitem>
pide a <systemitem role="sitename">vlager</systemitem> que se autentifique
usando el CHAP mediante el envío de un reto de CHAP. El demonio <command>pppd</command>
entonces examina <filename>chap-secrets</filename> buscando una entrada cuyo
campo de cliente sea igual a <systemitem role="sitename">vlager.vbrew.com</systemitem>
y el campo de servidor sea <systemitem role="sitename">c3po.lucas.com</systemitem>,
y encuentra la primera línea mostrada en el ejemplo.<footnote id="X-087-2-FNPP13"><para>
Este nombre de ordenador se toma del reto de CHAP.
</para>
</footnote>
Entonces produce la respuesta de CHAP a partir de la cadena del reto y la
clave (<literal>Use The Source Luke</literal>), y la envía de vuelta a
<systemitem role="sitename">c3po</systemitem>.
</para>

<para>
Al mismo tiempo,  <command>pppd</command> produce un reto del CHAP para
<systemitem role="sitename">c3po</systemitem>, conteniendo una única cadena
de reto y su nombre de ordenador completo
<systemitem role="sitename">vlager.vbrew.com</systemitem>.
<systemitem role="sitename">c3po</systemitem> construye una respuesta de CHAP
de la manera que acabamos de decir, y se la devuelve a
<systemitem role="sitename">vlager</systemitem>.
<command>pppd</command> extrae ahora el nombre del cliente
(<systemitem role="sitename">c3po.vbrew.com</systemitem>) de la respuesta, y
busca en el fichero <filename>chap-secrets</filename> una línea que tenga
<systemitem role="sitename">c3po</systemitem> como cliente y
<systemitem role="sitename">vlager</systemitem> como servidor. La segunda
línea se corresponde con esto, así que el <command>pppd</command> combina el
reto del CHAP y la clave <literal>arttoo! arttoo!</literal>, las encripta, y
compara el resultado con la respuesta de CHAP de
<systemitem role="sitename">c3po</systemitem>.
</para>

<para>
<indexterm><primary>direcciones</primary><secondary>negociacion con PPP</secondary></indexterm>
<indexterm><primary>IP (Internet Protocol)</primary><secondary>direcciones</secondary><tertiary>negociacion en PPP</tertiary></indexterm>
<indexterm><primary>acceso</primary><secondary>restringiendo</secondary></indexterm>
El cuarto campo opcional lista las direcciones IP que son aceptables por los
clientes nombrados en el primer campo. Las direcciones pueden ser dadas en
notación cuaternaria o como nombres de ordenador que son resueltos
posteriormente. Por ejemplo, si <systemitem role="sitename">c3po</systemitem>
solicita usar una dirección IP que no estáa en esta lista durante la negociación
IPCP, la petición será rechazada, e IPCP se desconectará. En el fichero de ejemplo
anterior, <systemitem role="sitename">c3po</systemitem> está limitado a poder usar
sólo su propia dirección. Si el campo de dirección está vacío, se permitirá
cualquier dirección; un valor de &ldquo;<literal>-</literal>&rdquo; evita el uso
de una cierta dirección IP con un cliente.
</para>

<para>
La tercera línea del fichero <filename>chap-secrets</filename> de prueba,
permite a cualquier ordenador establecer un enlace PPP con
<systemitem role="sitename">vlager</systemitem>, pues si aparece la expresión
<literal>*</literal> en los campos de cliente o servidor, será valido cualquier
nombre. El único requisito es que sepa la clave, y utiliza la dirección de
<systemitem role="sitename">pub.vbrew.com</systemitem>. Pueden aparecer
perfectamente entradas con comodines en los nombres en cualquier lugar del
fichero de claves, pues el <command>pppd</command> siempre utilizará la entrada
más específica que pueda ser aplicada a un par cliente/servidor.
</para>

<para>
Hay algunas cosas que decir sobre la manera en que <command>pppd</command>
encuentra los nombres de ordenadores que busca en el fichero de claves. Como
se explicó anteriormente, el nombre del ordenador remoto es siempre
proporcionado por el otro ordenador en el paquete de reto o respuesta del
CHAP. El nombre del ordenador local será obtenido por omisión llamando a la
función <function>gethostname(2)</function>. Si ha configurado el nombre del
sistema como el nombre del ordenador sin calificar, entonces tendrá que dar al
<command>pppd</command> el nombre del dominio a añadir usando la opción
<option>domain</option>:

<screen>
# <userinput>pppd &hellip; domain vbrew.com</userinput>
</screen>
</para>

<para>
Esto añadirá el nombre del dominio de la Cervecera a <systemitem
role="sitename">vlager</systemitem> para todas las actividades relacionadas
con la autentificación. Otras opciones que modifican la idea que tiene el
<command>pppd</command> del nombre del ordenador local son
<option>usehostname</option> y <option>name</option>. Cuando da la dirección
IP local en la línea de comando usando
<command><replaceable>local</replaceable>:<replaceable>remote</replaceable></command>
y <replaceable>local</replaceable> es un nombre en vez de un cuarteto numérico, el
<command>pppd</command> utilizará éste como el nombre local.
</para>
</sect2>


<sect2><title>El fichero de claves PAP</title>

<para>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>usando PAP</secondary></indexterm>
<indexterm><primary SORTAS="etc/ppp/pap-secrets file">fichero /etc/ppp/pap-secrets</primary></indexterm> 
El fichero de claves PAP es muy similar al utilizado por  CHAP. Los dos
primeros campos siempre contienen un nombre de usuario y un nombre de
servidor; el tercero alberga la clave PAP. Cuando el sistema remoto envía
una petición de autentificación,  <command>pppd</command> usa la entrada
en la que el campo de servidor es igual al nombre del ordenador local, y
el campo de usuario igual al nombre de usuario enviado en la petición.
Cuando se autentifica a sí mismo al otro ordenador,  <command>pppd</command>
toma la clave a enviar de la línea con el nombre de usuario igual al nombre
del usuario local, y con el campo de servidor igual al nombre del ordenador
remoto.
</para>

<para>
Un fichero de claves PAP sencillo puede parecerse a éste:

<screen>
# /etc/ppp/pap-secrets
#
# user          server          secret          addrs
vlager-pap      c3po            cresspahl       vlager.vbrew.com
c3po            vlager          DonaldGNUth     c3po.lucas.com
</screen>
</para>

<para>
La primera línea se usa para autentificarnos a nosotros mismos cuando hablemos
con <systemitem role="sitename">c3po</systemitem>. La segunda línea describe
como un usuario llamado <systemitem role="sitename">c3po</systemitem> tiene
que autentificarse con nosotros.
</para>

<para>
El nombre <systemitem role="keyword">vlager-pap</systemitem> de la primera
columna es el nombre de usuario que nosotros mandamos a
<systemitem role="sitename">c3po</systemitem>. POr omisión,<command>pppd</command> 
tomará el nombre del ordenador local como el nombre de
usuario, pero también se puede especificar un nombre diferente usando la opción
<option>user</option>, seguida del nombre deseado.
</para>

<para>
Para escoger una de las entradas del fichero <filename>pap-secrets</filename>
para la autentificación con el compañero,  <command>pppd</command> tiene
que saber el nombre del ordenador remoto. Como no tiene manera de averiguarlo,
tiene que especificarlo en la línea de órdenes usando la palabra 
<option>remotename</option>, seguida por el nombre del ordenador remoto. Por
ejemplo, para usar la entrada comentada anteriormente para la autentificación
con <systemitem role="sitename">c3po</systemitem>, tenemos que añadir la
siguiente opción a la línea de órdenes del <command>pppd</command>:

<screen>
# <userinput>pppd ... remotename c3po user vlager-pap</userinput>
</screen>
</para>
<?troff .Nd 10>

<para>
En el cuarto campo (y todos los siguientes), puede especificar qué direcciones
IP están permitidas para ese ordenador particular, de la misma forma que en el
fichero de claves CHAP. El otro ordenador solo podrá pedir direcciones de
esa lista. En el fichero de ejemplo, la entrada que
<systemitem role="sitename">c3po</systemitem> usará cuando llame a
la linea donde <systemitem role="sitename">c3po</systemitem> es el cliente, le
permitirá usar su IP auténtica y no otra.
</para>
<?troff .wcon_off>
<para>
Dése cuenta de que  PAP es un método de autentificación bastante débil, y se
recomienda utilizar el CHAP siempre que sea posible. Por eso, no explicaremos el
PAP en gran profundidad aquí; si esta interesado en utilizar el PAP, encontrará
algunas características más de éste comentadas en la página del manual del
<filename>pppd(8)</filename>.
<indexterm class="endofrange" startref="idx-authenticationwithPPP-1">
<indexterm class="endofrange" startref="idx-PPPauthentication-1">
<indexterm class="endofrange" startref="idx-securityPPP-1">
<INDEXTERM startref="ppp.secrets.files" class=endofrange>
</para>

</sect2>
</sect1>


<sect1><title>Depurando su configuración de PPP</title>

<para>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>depurando la configuración de</secondary></indexterm>
<indexterm><primary>depurando</primary><secondary>configuracion PPP</secondary></indexterm>
<indexterm><primary>syslog</primary></indexterm>
<indexterm><primary>comprobando</primary><secondary>PPP</secondary></indexterm>
Por omisión, <command>pppd</command> envia cualquier mensaje de
advertencia o error al  <systemitem role="keyword">demonio</systemitem>
<command>syslog</command>. Tiene que añadir una entrada a <filename>syslog.conf</filename>
que redirija estos mensajes a un fichero o incluso a la consola; de lo contrario,
<command>syslog</command>
<?troff .ne 3>
simplemente los descarta. La entrada siguiente envia todos los mensajes a
<filename>/var/log/ppp-log/</filename>:

<screen>
daemon.*                /var/log/ppp-log
</screen>
</para>

<para>
Si su configuración de PPP no funciona bien, debería mirar en este fichero
de log. Si los mensajes no ayudan, también puede activar información de depuración
extra usando la opción <option>debug</option>. Esta salida fuerza al <command>pppd</command>
a enviar a los ficheros de log los contenidos de todos los paquetes de control
enviados o recibidos a <command>syslog</command>. Todos los mensajes van entonces
al <systemitem role="keyword">demonio</systemitem>
</para>

<para>
<indexterm><primary SORTAS="proc/kmsg file">/proc/kmsg fichero</primary></indexterm> 
Finalmente, la manera más drástica de localizar un problema es activar la depuración
a nivel de núcleo invocando al <command>pppd</command> con la opción
<option>kdebug</option>. Es seguida de un argumento numérico que es la suma de los
valores siguientes: 1 para los mensajes de depuración genéricos, 2 para mostrar los
contenidos de las tramas HDLC entrantes, y 4 para hacer que el controlador
muestre las tramas HDLC salientes. Para capturar mensajes de depuración del
núcleo, puede ejecutar el demonio <command>syslogd</command> que lee el
fichero <filename>/proc/kmsg</filename>, o bien el demonio <command>klogd</command>.
Cualquiera de ellos dirige los mensajes de depuración del núcleo al
<command>syslog</command> del núcleo.
</para>

</sect1>

<sect1><title>Configuraciones avanzadas de PPP</title>

<para>
<INDEXTERM id="ppp.advanced.configs" class=startofrange><PRIMARY>PPP (Point-to-Point Protocol)</PRIMARY><SECONDARY>configuraciones avanzadas</SECONDARY></INDEXTERM>
Mientras que configurar PPP para conectar a una red como Internet es 
la más común de sus aplicaciones, hay algunos de vosotros que tenéis
requerimientos más avanzados. En esta sección hablaremos sobre algunas
de las configuraciones más avanzadas que son posibles con PPP bajo GNU/Linux.
</para>

<sect2><title>Servidor PPP</title>

<para>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>configurando un servidor de</secondary></indexterm>
<indexterm><primary SORTAS="etc/passwd file">fichero /etc/passwd</primary></indexterm> 
<indexterm><primary SORTAS="etc/shadow file">fichero /etc/shadow</primary></indexterm> 
Hacer funcionar el <command>pppd</command> como servidor es solo cuestión de
configurar un dispositivo terminal serie para que invoque al
<command>pppd</command> con las opciones apropiadas cuando una llamada entrante
es recibida. Una manera de hacer esto es crear una cuenta especial, digamos
<systemitem role="userid">ppp</systemitem>, y asociarle un script o programa como
shell de entrada que llame al <command>pppd</command> con esas opciones.
De forma alternativa, si quiere soportar autentificacion PAP o CHAP, puede usar
el programa <command>mgetty</command> para soportar su módem y explotar su característica
 &ldquo;/autoPPP/&rdquo;.
</para>

<para>
Para configurar un servidor usando el método de registro (login), añada una línea
similar a la siguiente a su fichero <filename>/etc/passwd</filename>:
<footnote id="X-087-2-FNPP14"><para> La utilidades <command>useradd</command> o
<command>adduser</command>, si las tiene, simplificaran la tarea.
</para>
</footnote>
<?troff .wcon_off>
<screen>
ppp:x:500:200:Public PPP Account:/tmp:/etc/ppp/ppplogin
</screen>
Si su sistema soporta shadow passwords, tambien necesita añadir una entrada
al fichero <filename>/etc/shadow</filename>:
<screen>
ppp:!:10913:0:99999:7:::
</screen>
</para>

<?troff .Nd 5>
<para>
Por supuesto, el UID y GID que utilice dependen de que usuario desea que
sea dueño de la conexión, y de cómo lo haya creado. Además tiene que establecer
la contraseña para la cuenta mencionada usando la orden <command>passwd</command>.
</para>


<para>
El script <command>ppplogin</command> podría tener este aspecto:

<screen>
#!/bin/sh
# ppplogin - script to fire up pppd on login
mesg n
stty -echo
exec pppd -detach silent modem crtscts
</screen>
</para>

<para>
La orden <command>mesg</command> deshabilita la opción  que permite que otros usuarios
puedan escribir en el terminal (tty) usado utilizando, por ejemplo, la orden
<command>write</command>. La orden <command>stty</command> desactiva el eco
de caracteres. Esto es necesario, pues de otra forma todo lo que el otro
ordenador envíe le será devuelto a modo de eco. La opción del
<command>pppd</command> más importante de las incluidas en el script es
<systemitem role="keyword">&ndash;detach</systemitem>, porque evita que el
<command>pppd</command> se separe de la terminal controlada. Si no especificásemos
esta opción, se iría a segundo plano, haciendo que el script del shell terminase.
Esto provocaría que la línea serie colgase y se perdiera la conexión. La opción
<command>silent</command> hace que el <command>pppd</command> espere hasta recibir
un paquete del sistema llamante antes de comenzar a enviar. Esto evita la aparición
de timeouts al transmitir cuando el sistema que nos llama es lento en lanzar su
cliente PPP. La opción <systemitem role="keyword">modem</systemitem> hace al
<command>pppd</command> vigilar la línea DTR para ver si el otro sistema ha colgado.
Siempre deberia activar esta opción cuando use <command>pppd</command> con un
modem. La opción <option>crtscts</option> activa el control de flujo por hardware.
</para>

<para>
Además de estas opciones, se puede forzar alguna clase de autentificación,
por ejemplo especificando <option>auth</option> en la línea de órdenes de
<command>pppd</command>, o en el fichero de opciones globales. La página del
manual también habla sobre opciones más especíificas para activar o desactivar
los protocolos de autentificación individuales.
</para>

<para>
Si desea usar <command>mgetty</command>,
todo lo que tiene que hacer es configurar <command>mgetty</command>
para que soporte el dispositivo serie al que su módem está conectado
(vea <xref linkend="X-087-2-serial.getty.mgetty">&rdquo; para más detalles),
configurar <command>pppd</command> bien para autentificación PAP o CHAP
con las opciones apropiadas en sus ficheros <filename>options</filename>,
y finalmente, añadir una sección similar a la siguiente a su fichero
<filename>/etc/mgetty/login.config</filename>:

<screen>
# Configura mgetty para automaticamente detectar llamandas entrantes e invocar
# al demonio pppd para que se haga cargo de la conexión.
#
/AutoPPP/ -     ppp   /usr/sbin/pppd auth -chap +pap login
</screen>
</para>

<para>
El primer campo es una parte especial mágica usada para detectar que la llamada
entrante es una de tipo PPP. No debe cambiar el aspecto de esta cadena; es
sensitivo a minúusculas y mayúusculas. La tercera columna en el nombre de usuario
que aparece en en el listado de <command>who</command> cuando alquien
a entrado en el sistema. El resto de la línea es el comando a invocar. En
nuestro ejemplo, nos hemos asegurado de que la autentificación por PAP es
requerida, deshabilitado  CHAP, y especificado que el fichero del sistema
<filename>passwd</filename> debe ser usado para autentificar usuarios.
Esto es probablemente parecido a lo que usted querrá. Recuerde, puede especificar
las opciones en el fichero <filename>options</filename> o en la linea de comandos
si lo prefiere.
</para>

<para>
Esto es una pequeña lista de comprobación de los pasos que debe realizar y
la secuencia que debe seguir para tener funcionando en su máquina un
servidor PPP. Asegúrese de que cada paso funciona correctamente antes de pasar
al siguiente:

<orderedlist> 

<listitem><para>
Configure el módem para que funcione en modo de auto-respuesta. En los módems compatibles
Hayes, esto se realiza mediante la orden <literal>ATS0=3</literal>. Si
va a utilizar el demonio <command>mgetty</command>, esto no será necesario.
</para></listitem>

<listitem><para>
Configure el dispositivo serie con una orden tipo <command>getty</command>
para que responda a las llamadas entrantes. Una variante comúnmente usada de
<command>getty</command> es <command>mgetty</command>.
</para></listitem>

<listitem><para>
Considere la autentificación. ¿Como se autentificarán con usted los clientes,
usando PAP, CHAP, o el registro del sistema?
</para></listitem>

<listitem><para>
Configure  <command>pppd</command> como servidor tal como se describe en esta sección.
</para></listitem>

<listitem><para>
Considere el encaminamiento. ¿Necesitará proporcionar una ruta de red a los
clientes? El encaminamiento puede realizarse usando el script <filename>ip-up</filename>.
</para></listitem>

</orderedlist>
</para>
</sect2>
<?troff .wcon_off>

<sect2><title>Llamada bajo demanda</title>

<para>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>configurando llamada bajo demanda para</secondary></indexterm>
<INDEXTERM><PRIMARY>llamada bajo demanda</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>teléefonos</PRIMARY><SECONDARY>llamada bajo demanda</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>móodems</PRIMARY><SECONDARY>llamada bajo demanda</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>llamada</PRIMARY><SECONDARY>demanda</SECONDARY></INDEXTERM>
Cuando hay tráfico IP para ser transportado a través del enlace, 
<emphasis>la llamada en demanda</emphasis> provoca la llamada de su modem
y el establecimiento de una conexión con un host remoto. La llamada en demanda
resulta útil cuando no puede dejar su línea telefónica permanentemente conectada
a su proveedor de Internet. Por ejemplo, puede que tenga que pagar llamadas locales
por tiempo de uso, así le resultará más barato tener la conexión establecida sólo
cuando lo necesite y desconectada cuando no está usando Internet.
</para>

<para>
Las soluciones GNU/Linux tradicionales han usado la orden <command>diald</command>,
que funcionaba bien pero era algo complicado de configurar. Las versiones
2.3.0 y posteriores del demonio PPP tienen incluído el soporte de llamada bajo demanda y
una configuración muy sencilla de realizar. Debe usar un núcleo actual para
poder hacer esto. Cualquiera de los núcleos posteriores al 2.0 funcionará
bien.
</para>


<para>
Para configurar <command>pppd</command> para llamada bajo demanda, todo lo
que tiene que hacer es añadir opciones a su fichero  <filename>/etc/options</filename>
o a la línea de órdenes de <command>pppd</command>. La tabla siguiente resume
las opciones relacionadas a la llamada en demanda:

<?troff .Nd 10>
<informaltable>
<tgroup cols=2>
<colspec colwidth="1.27cm">
<colspec colwidth="6.985cm">
<thead>
<row><entry>Opción</entry><entry>Descripción</entry></row>
</thead>
<tbody>
<row>
	<entry><literal>demand</literal></entry>
<entry><para>
Esta opción especifica que el enlace PPP debe ser establecido en modo de
llamada bajo demanda. El dispositivo de red PPP será creado, pero la orden
<literal>connect</literal> no será usada hasta que un datagrama sea transmitido
por el host local. Esta opción es obligatoria para que funcione la llamada bajo demanda.
</para></entry>
</row>
<row>
	<entry><literal>active-filter</literal> <replaceable>expresión</replaceable></entry>
	<entry><para>
Esta opción le permite especificar qué paquetes de datos van a ser considerados
como tráfico activo. Cualquier tráfico que cumpla la regla especificada
reiniciará el temporizador de la llamada bajo demanda, asegurando que
<command>pppd</command> espera de nuevo antes de terminar el enlace. La
sintaxis del filtro ha sido cogida prestada de la orden <command>tcpdump</command>
El filtro predeterminado especifica todos los datagramas.
</para></entry>
</row>
<row>
	<entry><literal>holdoff</literal> <replaceable>n</replaceable></entry>
	<entry><para>
Esta opción le permite especificar la cantidad míma de tiempo, en segundos,
que esperar antes de reconectar el enlace si termina. Si la conexión falla
mientras <command>pppd</command> cree que está en uso activo, será reestablecido
después de que este temporizador finalice. Este temporizador no se aplica a
las reconexiones producidas por la no transmisión de paquetes.
</para></entry>
</row>
<row>
	<entry><literal>idle</literal> <replaceable>n</replaceable></entry>
	<entry><para>
Si esta opción está configurada, <command>pppd</command> desconectará el enlace 
cuando este temporizador expire. Los tiempos muertos son especificados en segundos.
Cada paquete de datos nuevo activo reseteará el temporizador.
</para></entry>
</row>
</tbody>
</tgroup>
</informaltable>

Una configuración simple de llamada bajo demanda podría ser algo como esto:
<screen>
demand
holdoff 60
idle 180
</screen>

Esta configuración activará la llamada bajo demanda, esperará 60 segundos antes
de reestablecer un conexión fallida, y terminará el enlace si pasan 180
segundos sin ningún dato activo en el enlace.
</para>

</sect2>

<sect2><title>llamada persistente</title>

<para>
<indexterm><primary>PPP (Protocolo Punto-a-Punto)</primary><secondary>configurando llamada persistente para</secondary></indexterm>
<INDEXTERM><PRIMARY>llamada persistente</PRIMARY></INDEXTERM>
<INDEXTERM><PRIMARY>teléfonos</PRIMARY><SECONDARY>llamada persistente</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>modems</PRIMARY><SECONDARY>llamada persistente</SECONDARY></INDEXTERM>
<INDEXTERM><PRIMARY>llamada</PRIMARY><SECONDARY>persistente</SECONDARY></INDEXTERM>
<emphasis>La llamada persistente</emphasis> es lo que la gente que tiene
conexiones permanentes a una red querrá usar. Hay una sutil diferencia
entre llamada en demanda y llamada persistente. Con la llamada persistente,
la conexión es automáticamente establecida tan pronto como el demonio
PPP es lanzado, y el aspecto de persistencia viene a cuento siempre que
la llamada telefónica que soporta el enlace se interrumpa. La llamada
persistente asegura que el enlace está siempre disponible relanzando
automáticamete la conexión si ésta se interrumpe.
</para>

<para>
Usted podría ser afortunado de no tener que pagar por sus llamdas telefónicas;
quizás sean locales y gratuitas, o quizás su empresa es quién las paga.
La opción de llamada persistente es extremadamente útil en esta situación.
Si tiene que pagar por sus llamadas telefónicas, entonces tiene que tener
un poco de cuidado. Si paga por sus llamadas telefónicas en base al tiempo
que la utiliza, la llamada persistente es algo que casi seguro no es
lo que quiere, a menos que esté seguro de que estará usando la conexión
constantemente muy amenudo veinticuatro horas al día.
Si paga las llamadas, pero no en base al tiempo, necesitará tener cuidado de
protegerse de situaciones que puedan causar que el módem llame de forma
interminable. El demonio <command>pppd</command> provee de una opción que
puede ayudar a reducir el efecto de este problema.
</para>

<para>
Para activar la llamada persistente, debe incluir la opción
<systemitem role="keyword">persist</systemitem> en uno de los
ficheros de opciones de <command>pppd</command>. Incluir esta
opción es todo lo que necesita para tener al
<command>pppd</command> invocando automáticamente la orden especificada en la
opción <systemitem role="keyword">connect</systemitem> para 
restablecer la conexión cuando el enlace se interrumpe.
Si está preocupado por el remarcado demasiado rápido del módem (en el
caso de un fallo del servidor o módem del otro extremo de la conexión),
puede usar la opción <systemitem role="keyword">holdoff</systemitem>
para establecer el tiempo mínimo que  <command>pppd</command>
deberá esperar antes de intentar reconectar. Esta opción no resolverá
el problema de un fallo y su consecuente gasto en llamadas de teléfono,
pero al menos le servirá para reducir el impacto de uno de ellos.
</para>


<para>
Una configuración típica de llamada persistente podría parecerse a
ésta:

<screen>
persist
holdoff 600
</screen>

El tiempo de espera es especificado en segundos. En nuestro ejemplo,
el <command>pppd</command> espera durante cinco minutos antes de
rellamar cuando una llamada ha fallado.
</para>

<para>
Es posible combinar la llamada persistente con la llamada en demanda, usando
<systemitem role="keyword">idle</systemitem> para interrumpir el 
enlace si ha estado inactivo por un período especificado de tiempo.
Dudamos de que sean muchos los usuarios que quieran hacer esto, pero
este escenario está descrito brevemente en la página del manual de
<command>pppd</command>, por si tuviera que buscarlo.
</para>


</sect2>

</sect1>

<indexterm class="endofrange" startref="idx-commandpppdcommand-1">
<indexterm class="endofrange" startref="idx-PPP-1">
<indexterm class="endofrange" startref="idx-configuringPPP-1">
<INDEXTERM startref="ppp.advanced.configs" class=endofrange>

</chapter>



