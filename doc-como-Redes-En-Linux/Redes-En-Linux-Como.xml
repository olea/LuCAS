<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>

<articleinfo>

<title>Redes en Linux Como (Previamente Net-3 Como)</title>

<author>
<firstname>Autor actual: Joshua Drake, &lcub;Poet&rcub;, <ulink
url="mailto:poet@linuxports.com"
>poet@linuxports.com</ulink
>

Autores originales:
Terry Dawson (autor principal), <ulink
url="mailto:terry@perf.no.itg.telstra.com.au"
>terry@perf.no.itg.telstra.com.au</ulink
>; Alessandro Rubini, <ulink
url="mailto:rubini@linux.it"
>rubini@linux.it</ulink
> (mantenimiento)

Traducido por: Ricardo Javier Cárdenes Medina, <ulink
url="mailto:a1402@serdis.dis.ulpgc.es"
>a1402@serdis.dis.ulpgc.es</ulink
>
</firstname>
</author>

<pubdate>v1.5, 20 de agosto de 1997, traducción del 3 de septiembre de 1999</pubdate>

<abstract>

<para>
Este <emphasis>Cómo</emphasis> es la base para entender la evolución de las capacidades de
Linux para tratar con redes informáticas. Es el punto de partida para
aprender todo sobre el mantenimiento de redes TCP/IP, la configuración de
los archivos relacionados con la red, y hay un amplio capítulo sobre
configuración de dispositivos físicos. En suma, un documento muy
exhaustivo que merece la pena leer.
</para>

</abstract>

</articleinfo>

<sect1>
<title>Introducción.</title>

<para>
El Sistema Operativo Linux se enorgullece de contar con una implementación
de servicios de red basada en el núcleo, escrita casi por completo
partiendo de cero. Su rendimiento en los núcleos recientes lo convierte en
una alternativa válida incluso a el mejor de sus iguales. Este documento
intenta describir cómo instalar y configurar el software de red de Linux y
sus herramientas asociadas.
</para>

<para>
Esta es la primera entrega desde que LinuxPorts comenzó a hacerse
cargo del documento. Quisiera decir antes que nada que deseamos que
durante los próximos meses encuentre de utilidad este documento, y que
seamos capaces de proporcionar información precisa y puntual en lo que
respecta al tratamiento de redes con Linux.
</para>

<para>
Este documento, al igual que los otros <literal remap="tt">Como</literal>s de los que nos
encargamos, se va a convertir en algo muy diferente. Dentro de poco pasará
a ser el <emphasis remap="it">Redes en Linux Como</emphasis> en lugar de ser sólo el <emphasis remap="it">Net-3(4)
Como</emphasis>. Va a cubrir temas como PPP, VPN (Redes Privadas Virtuales), y
otros...
</para>

</sect1>

<sect1>
<title>Historia del documento</title>

<para>
El <emphasis remap="it">NET-FAQ</emphasis> original fue escrito por Matt Welsh y Terry Dawson para
responder preguntas frecuentes sobre las redes para Linux, un tiempo antes
de que comenzara formalmente el Proyecto de Documentación de Linux. Cubría
las últimas versiones de desarrollo del Linux Networking Kernel. El
<emphasis remap="it">NET-2-HOWTO</emphasis> sobreseyó el <emphasis remap="it">NET-FAQ</emphasis> y fue uno de los documentos HOWTO
originales del LDP. Cubría lo que se llamó versión 2 y posteriormente
versión 3 del Linux Kernel Networking software. Este documento a su vez lo
sobresee y sólo se refiere a la versión 4 del Linux Networking Kernel: más
específicamente a las versiones <literal remap="tt">2.0.x</literal> y <literal remap="tt">2.2.x</literal> del núcleo.
</para>

<para>
Las versiones anteriores de este documento llegaron a ser bastante
grandes a causa de la enorme cantidad de material que caía dentro de
su ámbito. Para ayudar a resolver este problema se han producido unos
cuantos Como que tratan con temas específicos sobre redes. Este
documento proporciona referencias a dichos Como cuando sean relevantes y
cubre aquellas áreas de las que aún no se habla en otros documentos.
</para>

<sect2>
<title>Comentarios y sugerencias</title>

<para>
Estamos interesados en que la gente nos proporcione sugerencias (que nos
informen de cambios, errores, etc.). Por favor, póngase en contacto con
nosotros en: <ulink
url="mailto:poet@linuxports.com"
>poet@linuxports.com</ulink
>.  De nuevo, si encuentra algo erróneo o cualquier
cosa que desearía que fuese añadida, por favor, contacte con nosotros.
</para>

</sect2>

</sect1>

<sect1>
<title>Cómo usar este documento.</title>

<para>
Este documento está organizado de una manera vertical. La primera
sección incluye material informativo y se la puede saltar si no es de su
interés; lo que sigue es una discusión genérica sobre temas referentes a
las redes, y debe asegurarse de entender esto antes de proceder con partes
más específicas. El resto, información «específica de la tecnología»,
está agrupada en tres secciones principales: información relativa a
Ethernet e IP, tecnologías pertinentes a hardware para PC de amplia
difusión y tecnologías usadas sólo rara vez.
</para>

<para>
La metodología que nosotros sugerimos a la hora de leer este documento
es la siguiente:
</para>

<para>
<variablelist>

<varlistentry>
<term>Lea las secciones genéricas</term>
<listitem>
<para>
Estas secciones se aplican a
toda, o casi toda tecnología descrita más adelante, y por tanto es muy
importante que lo comprenda.
</para>
</listitem></varlistentry>
<varlistentry>
<term>Estudie su red</term>
<listitem>
<para>
Debería saber cómo está, o estará diseñada su
red, y exactamente qué tipo de hardware y tecnología estará
implementando.
</para>
</listitem></varlistentry>
<varlistentry>
<term>Lea la sección <xref linkend="IP-y-Ethernet"/> si está
conectado directamente a una LAN o a Internet</term>
<listitem>
<para>
Esta sección describe
la configuración básica para Ethernet ya las varias posibilidades que
ofrece Linux para las redes IP, como servicio de cortafuegos,
encaminamiento avanzado, etc.
</para>
</listitem></varlistentry>
<varlistentry>
<term>Lea la siguiente sección si está interesado en redes locales de
bajo coste o en conexiones punto a punto</term>
<listitem>
<para>
Esta sección describe PLIP,
PPP, SLIP y RDSI, las tecnologías de más amplia difusión en estaciones de
trabajo personales.
</para>
</listitem></varlistentry>
<varlistentry>
<term>Lea las secciones específicas a tecnologías relacionadas con sus
necesidades</term>
<listitem>
<para>
Si sus necesidades difieren de una solución con IP y
hardware común, la sección del final cubre detalles específicos a
protocolos diferentes al IP y a hardware de comunicaciones peculiar.
</para>
</listitem></varlistentry>
<varlistentry>
<term>Configure</term>
<listitem>
<para>
Debería intentar configurar su red y tomar nota
cuidadosamente de cualquier problema que tenga.
</para>
</listitem></varlistentry>
<varlistentry>
<term>Busque más ayuda si la necesita</term>
<listitem>
<para>
Si experimenta problemas que
este documento no le ayude a resolver entonces lea la sección relativa a
dónde encontrar ayuda o dónde informar de los errores.
</para>
</listitem></varlistentry>
<varlistentry>
<term>¡Diviértase!</term>
<listitem>
<para>
Trabajar en red es divertido, disfrútelo.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<sect2>
<title>Convenciones usadas en el documento</title>

<para>
No se han utilizado convenciones especiales, pero debería estar al
corriente de la manera en que aparecen las órdenes. Siguiendo el estilo
clásico en la documentación de Unix, cualquier orden que deba escribir en
su intérprete de órdenes, estará prefijada por el símbolo «prompt». Este
Como muestra el prompt <literal remap="tt">usuario$</literal> para las órdenes que no
necesitan que las ejecute el root. He escogido usar <literal remap="tt">root#</literal> en
lugar de un simple <literal remap="tt">#</literal> para evitar confusiones con los trozos
dispersos de guiones (<emphasis remap="it">shell script</emphasis>), donde la almohadilla
(#) se usa para definir comentarios entre líneas.
</para>

<para>
Cuando se muestran «Opciones de Compilación del Núcleo», se presentan
en el formato usado por <literal remap="tt">menuconfig</literal>. Deberían ser comprensibles
incluso si usted (al igual que yo) no está acostumbrado a usar
<literal remap="tt">menuconfig</literal>. Si tiene dudas al respecto del anidamiento de las
opciones, ejecutar el programa le será de ayuda.
</para>

<para>
Fíjese en que los enlaces a otros documentos COMO son locales para que
pueda acceder a las copias de los documentos del LDP que haya en el
servidor al que usted está accediendo, en caso de que esté leyendo la
versión html de este documento. Si no dispone del paquete completo de
documentos, cada COMO puede ser obtenido en <literal remap="tt"><ulink
url="http://www.linuxdoc.org"
>www.linuxdoc.org</ulink
></literal> (directorio
<literal remap="tt">/pub/Linux/HOWTO</literal>) y en sus incontables servidores réplica
(<emphasis remap="it">mirror sites</emphasis>).
</para>

</sect2>

</sect1>

<sect1>
<title>Información general sobre las redes en Linux.</title>

<sect2>
<title>Breve historia del desarrollo del <emphasis remap="it">Linux Networking Kernel</emphasis>.</title>

<para>
Desarrollar una nueva implementación núcleo de la pila para el protocolo
tcp/ip que rinda tan bien como las implementaciones existentes no es una
tarea fácil. La decisión de no portar una de las implementaciones
existentes se tomó en un tiempo en que había cierta incertidumbre al
respecto de si las implementaciones existentes serían lastradas con
copyrights restrictivos por el precedente sentado por U.S.L.  y en que
había un gran entusiasmo por hacerlo diferente y quizás incluso mejor de
lo que se había hecho.
</para>

<para>
El voluntario original para liderar el desarrollo del núcleo del código
de red fue Ross Biro, <literal remap="tt"><ulink
url="mailto:biro@yggdrasil.com"
>biro@yggdrasil.com</ulink
></literal>. Ross produjo una implementación simple e
incompleta pero aprovechable en su mayor parte de rutinas que fueron
completadas con un controlador de Ethernet para la interfaz de red WD-8003.
Esto era suficiente para tener a mucha gente probando y experimentando
con el software y algunas personas incluso intentaron conectar máquinas
con esta configuración a conexiones reales en Internet. La presión dentro
de la comunidad de Linux conduciendo el desarrollo de la implementación
de la red estaba creciendo y, al final, el coste de una combinación de
cierta presión aplicada sobre Ross y sus propios compromisos personales
le sobrecargaron y se descolgó del puesto de desarrollador jefe. Los
esfuerzos de Ross por iniciar el proyecto y la aceptación de la
responsabilidad de producir realmente algo útil en tan controvertidas
circunstancias fue lo que catalizó todo el trabajo futuro y por lo tanto
supone un componente esencial en el éxito del producto actual.
</para>

<para>
Orest Zborowski, <literal remap="tt"><ulink
url="mailto:obz@Kodak.COM"
>obz@Kodak.COM</ulink
></literal>, produjo la interfaz original de programación
de sockets BSD para el núcleo de Linux. Fue un gran paso adelante ya que
permitió portar a Linux muchas de las aplicaciones de red existentes sin
modificaciones serias.
</para>

<para>
Por aquel momento, Laurence Culhane, <literal remap="tt"><ulink
url="mailto:loz@holmes.demon.co.uk"
>loz@holmes.demon.co.uk</ulink
></literal>
desarrolló los primeros controladores de dispositivo para la implementación del
protocolo SLIP en Linux. Esto permitió a mucha gente que no tenía acceso a
redes Ethernet experimentar con el nuevo software de red. De nuevo, hubo gente
que cogió este controlador y lo puso en servicio para conectarse a Internet.
Esto dio a mucha gente una idea de las posibilidades que podrían hacerse
realidad si Linux tuviera un soporte total de red y creciera el número de
usuarios usando y experimentando de forma activa el software de red que
existía.
</para>

<para>
Una de las personas que también había estado trabajando activamente en la
tarea de construir la implementación de red era Fred vam Kempen,
<literal remap="tt"><ulink
url="mailto:waltje@uwalt.nl.mugnet.org"
>waltje@uwalt.nl.mugnet.org</ulink
></literal>.  Después de un periodo de
incertidumbre tras la renuncia de Ross al cargo de desarrollador jefe,
Fred ofreció su tiempo y esfuerzos y aceptó el papel esencialmente sin
oposición.  Fred tenía planes ambiciosos sobre la dirección que quería
que siguiese el software de red de Linux y orientó el progreso hacia esos
objetivos. Fred desarrolló varias versiones del código de red llamado el
núcleo de código <emphasis remap="it">NET-2</emphasis> (el código <emphasis remap="it">NET</emphasis> era el de Ross) que mucha
gente pudo usar de manera más útil. Fred puso formalmente algunas
innovaciones en la agenda de desarrollo, como la interfaz dinámica de
dispositivo, la implementación del protocolo <emphasis remap="it">Amateur Radio AX.25</emphasis> y
una interfaz de red diseñada más modularmente.  El código <emphasis remap="it">NET-2</emphasis> de
Fred fue usado por un gran número de entusiastas, que crecía
continuamente según se iba corriendo la voz de que el software
funcionaba.  El software de red en esos momentos aún estaba constituido
por un gran número de parches a la versión estándar del núcleo y no
estaba incluido en la versión normal. El <emphasis remap="it">NET-FAQ</emphasis> y el subsecuente
<emphasis remap="it">NET-2-HOWTO</emphasis> describían el por entonces relativamente complejo
procedimiento de ponerlo todo en marcha. Fred se concentraba en
desarrollar innovaciones frente a las implementaciones estándar de red y
eso estaba llevando tiempo.  La comunidad de usuarios estaba
impacientándose por algo que funcionase eficazmente y satisficiera al 80%
de usuarios y, como con Ross, la presión sobre Fred como desarrollador en
jefe creció.
</para>

<para>
Alan Cox, <literal remap="tt"><ulink
url="mailto:iialan@www.uk.linux.org"
>iialan@www.uk.linux.org</ulink
></literal> propuso una solución al problema
diseñada para resolver la situación. Propuso que él podría coger el
código <emphasis remap="it">NET-2</emphasis> de Fred para quitar fallos, haciéndolo eficaz y estable
para que satisficiera al impaciente usuario de base al tiempo que
retiraba esa presión de Fred permitiéndole continuar con su trabajo. Alan
se puso a ello, obteniendo buenos resultados y su primera versión del
código de red de Linux fue llamada it/Net-2D(ebugged)/. El código
funcionaba bien en muchas configuraciones típicas y el usuario de base
estaba feliz. Alan puso claramente sus propias ideas y habilidad para
contribuir al proyecto y como consecuencia comenzaron a aparecer muchas
discusiones relativas a la dirección del código <emphasis remap="it">NET-2</emphasis>.  Esto
desarrolló dos tendencias distintas dentro de la comunidad de red de
Linux, una que tenía la filosofía «hazlo funcionar primero, y luego hazlo
mejor» y la otra «hazlo mejor primero».  Linus terminó arbitrando y
ofreciendo su apoyo a los esfuerzos de desarrollo de Alan e incluyó el
código de Alan en la distribución estándar de las fuentes del núcleo.
Esto puso a Fred en una posición difícil.  Cualquier desarrollo
continuado podría debilitar la gran base de usuarios usando y probando
activamente el código y eso significaría que los progresos serían lentos
y difíciles. Fred continuó trabajando un tiempo y a la larga acabó
dejándolo y Alan se convirtió en el nuevo jefe del esfuerzo de desarrollo
de red para Linux.
</para>

<para>
Donald Becker, <literal remap="tt"><ulink
url="mailto:becker@cesdis.gsfc.nasa.gov"
>becker@cesdis.gsfc.nasa.gov</ulink
></literal> reveló pronto su talento para
los aspectos de bajo nivel de las redes y produjo un amplio abanico de
controladores de red. Casi todos los incluidos en los núcleos actuales
fueron desarrollados por él. Hay más gente que ha hecho contribuciones
significativas, pero el trabajo de Donald es prolífico y eso le garantiza
una mención especial.
</para>

<para>
Alan continuó refinando el código <emphasis remap="it">NET-2-Debugged</emphasis> durante un tiempo
mientras trabajaba en solucionar algunos de los problemas que quedaban
sin mirar en la lista <literal remap="tt">PORHACER</literal>. Por la época en que al código fuente
<literal remap="tt">1.3.*</literal> del núcleo les estaban creciendo los dientes, el código de red
había migrado a la entrega <emphasis remap="it">NET-3</emphasis> que es en la que las versiones
actuales están basadas.  Alan trabajó en muchos aspectos diferentes del
código de red y con la asistencia de mucha otra gente con talento de la
comunidad de red de Linux hizo crecer el código en todas direcciones.
Alan produjo dispositivos de red dinámicos y las primeras
implementaciones de los estándares AX.25 e IPX. Alan ha continuado
jugueteando con el código, estructurándolo y mejorándolo lentamente hasta
el estado en que se encuentra hoy día.
</para>

<para>
Michael Callahan, <literal remap="tt"><ulink
url="mailto:callahan@maths.ox.ac.uk"
>callahan@maths.ox.ac.uk</ulink
></literal> y Al Longyear <literal remap="tt"><ulink
url="mailto:longyear@netcom.com"
>longyear@netcom.com</ulink
></literal>
aportaron la implementación del protocolo PPP, lo cual fue crítico para
incrementar el número de gente que usaba activamente Linux para trabajar
en red.
</para>

<para>
Jonathon Naylor, <literal remap="tt"><ulink
url="mailto:jsn@cs.nott.ac.uk"
>sn@cs.nott.ac.uk</ulink
></literal> ha contribuido mejorando significativamente
el código de AX.25 de Alan, añadiendo los protocolos NetRom y Rose. La
implementación de AX.25/NetRom/Rose es en sí misma bastante
significativa, porque ningún otro sistema operativo puede enorgullecerse
de trabajar de forma nativa con estos protocolos aparte de Linux.
</para>

<para>
Por supuesto, ha habido centenares de otras personas que han hecho
contribuciones significativas al desarrollo del software de red de Linux.
A algunas de estas personas las encontrará más adelante en la sección de
tecnologías específicas; otras personas han contribuido con módulos,
controladores, correcciones de errores, sugerencias, informes de pruebas y
apoyo moral. En cada caso, cada uno puede decir que ha puesto su granito
de arena y que ofreció lo que pudo. El código de red del núcleo de Linux
es un excelente ejemplo de los resultados que se pueden obtener del
anárquico estilo de desarrollo de Linux. Si aún no se ha sorprendido, lo
hará pronto. El desarrollo no se ha detenido.
</para>

</sect2>

<sect2 id="recursos">
<title>Recursos referentes al tratamiento de redes con Linux.
</title>

<para>
Hay varios sitios en los que puede encontrar información acerca de la
implementación de red de Linux.
</para>

<para>
Tiene a su disposición un montón de asesores. Podrá encontrar un listado
en la <emphasis remap="it">LinuxPorts Consultants Database</emphasis>, <literal remap="tt"><ulink
url="http://www.linuxports.com/"
>http://www.linuxports.com</ulink
></literal>
</para>

<para>
Alan Cox, quien en estos momentos se encarga de mantener el código de red del
núcleo de Linux tiene una página WWW con los últimos titulares y eventos
de interés relativos al estado de desarrollo de las funcionalidades presentes y
futuras en cuanto al código de red linux en: <literal remap="tt"><ulink
url="http://www.uk.linux.org/NetNews.html"
>www.uk.linux.org</ulink
></literal>.
</para>

<para>
Otro buen sitio es un libro escrito por Olaf Kirch titulado la <literal remap="tt">Guía para
Administradores de Redes</literal>. Es parte del Proyecto de Documentación de Linux
<literal remap="tt"><ulink
url="http://www.linuxdoc.org/"
>http://www.linuxdoc.org</ulink
></literal> y puede leerlo de forma interactiva en su
versión HTML <literal remap="tt"><ulink
url="http://metalab.unc.edu/LDP/LDP/nag/nag.html"
>http://metalab.unc.edu/LDP/LDP/nag/nag.html</ulink
></literal>, u obtenerlo en varios
formatos mediante FTP (y en castellano) desde el archivo del proyecto LuCAS
<literal remap="tt"><ulink
url="ftp://lucas.hispalinux.es/pub/LuCAS/Manuales-LuCAS/GARL"
>ftp://lucas.hispalinux.es/pub/LuCAS/Manuales-LuCAS/GARL</ulink
></literal>.  El libro
de Olaf es bastante extenso y procura una buena iniciación de alto nivel a la
configuración de redes en Linux.
</para>

<para>
Hay un grupo de noticias en la jerarquía de noticias de Linux dedicado a
las redes y a materias relacionadas: <literal remap="tt"><ulink
url="news:comp.os.linux.networking"
>comp.os.linux.networking</ulink
></literal>
</para>

<para>
Hay una lista de correo a la que se puede suscribir, donde hacer
preguntas relacionadas al trabajo en redes con Linux. Para suscribirse
debe mandar un mensaje:
</para>

<para>

<screen>
A: majordomo@vger.rutgers.edu
Asunto: cualquier cosa
Mensaje:

subscribe linux-net
</screen>

</para>

<para>
En las diferentes redes de IRC suele haber canales <literal remap="tt">#linux</literal> en los
que suele haber gente que responde preguntas sobre linux y redes.
</para>

<para>
Por favor, cuando vaya a informar de cualquier problema, recuerde incluir
todos los detalles que pueda relevantes al respecto.  Debería informar,
específicamente, de las versiones de los programas que esté usando, sobre
todo la versión del núcleo, la versión de herramientas como <literal remap="tt">pppd</literal> o
<literal remap="tt">dip</literal> y la naturaleza exacta del problema que está experimentando.
Esto significa tomar nota de la sintaxis exacta de cualquier mensaje de
error que reciba y de cualquier orden que esté ejecutando.
</para>

</sect2>

<sect2>
<title>Dónde conseguir información sobre redes no específica de
Linux.</title>

<para>
Si está buscando información básica de aprendizaje sobre redes tcp/ip
en general, entonces le recomiendo que eche un vistazo a los siguientes
documentos:
</para>

<para>
<variablelist>

<varlistentry>
<term>TCP/IP Introduction</term>
<listitem>
<para>
este documento está tanto en versión texto
<literal remap="tt"><ulink
url="ftp://athos.rutgers.edu/runet/tcp-ip-intro.doc"
>ftp://athos.rutgers.edu/runet/tcp-ip-intro.doc</ulink
></literal> como en
versión PostScript <literal remap="tt"><ulink
url="ftp://athos.rutgers.edu/runet/tcp-ip-intro.ps"
>ftp://athos.rutgers.edu/runet/tcp-ip-intro.ps</ulink
></literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>TCP/IP Administration </term>
<listitem>
<para>
este documento está tanto en versión
texto <literal remap="tt"><ulink
url="ftp://athos.rutgers.edu/runet/tcp-ip-admin.doc"
>ftp://athos.rutgers.edu/runet/tcp-ip-admin.doc</ulink
></literal> como en
versión PostScript <literal remap="tt"><ulink
url="ftp://athos.rutgers.edu/runet/tcp-ip-admin.ps"
>ftp://athos.rutgers.edu/runet/tcp-ip-admin.ps</ulink
></literal>.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Si busca información algo más detallada sobre redes tcp/ip entonces le
recomiendo:
</para>

<para>
<quote
><emphasis>Internetworking with TCP/IP, Volume 1: principles, protocols and
architecture</emphasis>, de Douglas E. Comer, ISBN 0-13-227836-7, Prentice Hall
publications, Tercera edición, 1995.</quote
>
</para>

<para>
Si quiere aprender a escribir aplicaciones de red en entornos
compatibles Unix entonces también le recomiendo:
</para>

<para>
<quote
><emphasis>Unix Network Programming</emphasis>, by W. Richard Stevens, ISBN 0-13-949876-1,
Prentice Hall publications, 1990.</quote
>
</para>

<para>
También debería probar el grupo de noticias <literal remap="tt"><ulink
url="news:comp.protocols.tcp-ip"
>comp.protocols.tcp-ip</ulink
></literal>.
Otra fuente importante de información técnica específica relativa a la
Internet y al conjunto de protocolos tcp/ip son los RFC. RFC es un
acrónimo de <emphasis remap="it">Request For Comments</emphasis> y es el medio estándar de enviar y
documentar los protocolos estándar de Internet. Hay muchos sitios de
donde tomar los RFC. Muchos de estos sitios son de FTP y otros
proporcionan acceso por World Wide Web con un buscador asociado que le
permite buscar palabras clave en la base de datos de RFC.
</para>

<para>
Un posible lugar donde encontrar lo RFC es la base de datos de Nexor
<literal remap="tt"><ulink
url="http://pubweb.nexor.co.uk/public/rfc/index/rfc.html"
>http://pubweb.nexor.co.uk/public/rfc/index/rfc.html</ulink
></literal>.
</para>

</sect2>

</sect1>

<sect1>
<title>Información genérica sobre la configuración de redes.</title>

<para>
Las siguientes subsecciones las necesitará para saber y comprender
ciertas cosas antes de que intente configurar la red. Son principios
fundamentales que se aplican independientemente de la naturaleza exacta
de la red que desee organizar.
</para>

<sect2>
<title>¿Qué necesito para comenzar?</title>

<para>
Antes de que empiece a construir o configurar la red necesita saber
algunas cosas. Las más importantes son:
</para>

<sect3>
<title>Código fuente del núcleo.</title>

<para>
Antes que nada:
</para>

<para>
La mayoría de las distribuciones vienen por defecto con el soporte de red
activado, por lo cual no habrá que recompilar el núcleo. Si tiene
hardware común, debería irle bien. Por ejemplo, tarjetas de red  3COM,
NE2000, o Intel.  Sin embargo proporcionamos la siguiente información por
si necesita actualizar el núcleo.
</para>

<para>
Como puede ser que el núcleo que está ejecutando no esté preparado para
los tipos de red o tarjetas que desee usar, probablemente necesitará las
fuentes del núcleo para recompilarlo con las opciones apropiadas.
</para>

<para>
Siempre puede obtener la última versión de CDROM.com 
 <literal remap="tt"><ulink
url="ftp://ftp.cdrom.com/pub/linux/sunsite/kernel.org/pub/linux/kernel"
>ftp://ftp.cdrom.com/pub/linux/sunsite/kernel.org/pub/linux/kernel</ulink
></literal>.  Este no es el sitio oficial, pero tiene un GRAN ancho de banda y
permite que MUCHOS usuarios conecten simultáneamente. El sitio oficial es
<literal remap="tt">kernel.org</literal>, pero use el anterior si tiene la posibilidad. Por favor,
recuerde que <literal remap="tt">ftp.kernel.org</literal> está seriamente sobrecargado. Use un
servidor réplica.
</para>

<para>
Normalmente las fuentes del núcleo se instalarán en el directorio
<literal remap="tt">/usr/src/linux</literal>. Para más información sobre cómo aplicar parches
y construir el núcleo debería leer el <literal remap="tt"><ulink
url="Kernel-Como.html"
>Kernel Como</ulink
></literal>. Para más información sobre cómo configurar
módulos del núcleo debería leer el <emphasis remap="it">Modules mini-Howto</emphasis>. Además, el
fichero <literal remap="tt">README</literal> que hay en las fuentes del núcleo y el directorio
<literal remap="tt">Documentation</literal> son muy ilustrativos para el lector intrépido.
</para>

<para>
A menos que se diga específicamente lo contrario, recomiendo que empiece
con la versión estándar del núcleo (la que tenga un número par como
segundo dígito del número de versión). Las versiones de desarrollo del
núcleo (las que tienen el segundo dígito impar) podrían tener algunos
cambios estructurales u otros que podrían causar problemas con otro
software en su sistema. Si no está seguro de que pueda resolver ese tipo
de problemas sumado al potencial de que haya otros errores de software,
no los use.
</para>

<para>
Por otro lado, algunas de las capacidades aquí descritas han sido
introducidas durante el desarrollo de los núcleos <literal remap="tt">2.1</literal>, por lo que
tendrá que tomar una decisión: puede mantenerse en <literal remap="tt">2.0</literal> mientras
espera por el <literal remap="tt">2.2</literal> y por una distribución con cada herramienta
actualizada, o puede coger un <literal remap="tt">2.1</literal> y buscar los diversos programas
necesarios para explotar las nuevas capacidades.  En el momento de
escribir este Como, en Agosto de 1998, el núcleo disponible es el
<literal remap="tt">2.1.115</literal> y se espera que el <literal remap="tt">2.2</literal> aparezca pronto.
</para>

<para>
<literal remap="tt">Nota del Traductor</literal>: En el momento en que acabó la traducción de
este Como, en septiembre de 1999, las versiones disponibles del núcleo
son la <literal remap="tt">2.2.12</literal> (estable) y la <literal remap="tt">2.3.16</literal> (desarrollo). Además, las
principales distribuciones han puesto al día sus herramientas para tratar
las capacidades de la serie <literal remap="tt">2.1</literal> y superiores.
</para>

</sect3>

<sect3>
<title>Herramientas de red actualizadas.</title>

<para>
Las herramientas de red son los programas que usted usa para configurar
los dispositivos de red de linux. Estas herramientas permiten asignar
direcciones a dispositivos y configurar rutas, por ejemplo.
</para>

<para>
La mayoría de distribuciones modernas de Linux están dotadas con las
herramientas de red, por lo que si ha instalado Linux a partir de una
distribución y no ha instalado las herramientas de red, debería hacerlo.
</para>

<para>
Si no ha instalado a partir de una distribución entonces necesitará las
fuentes para compilar las herramientas usted mismo. No es difícil.
</para>

<para>
Las herramientas de red las mantiene ahora Bernd Eckenfelds y están
disponibles en:
</para>

<para>
<literal remap="tt"><ulink
url="ftp://ftp.inka.de/pub/comp/Linux/networking/NetTools/"
>ftp://ftp.inka.de/pub/comp/Linux/networking/NetTools/</ulink
></literal> y están
replicadas en: <literal remap="tt"><ulink
url="ftp://ftp.uk.linux.org/pub/linux/Networking/base/"
>ftp://ftp.uk.linux.org/pub/linux/Networking/base/</ulink
></literal>.
</para>

<para>
También puede encontrar los últimos paquetes de RedHat en <literal remap="tt"><ulink
url="ftp://ftp.cdrom.com/pub/linux/redhat/redhat-6.0/i386/base/"
>ftp://ftp.cdrom.com/pub/linux/redhat/redhat-6.0/i386/base/net-tools-1.51-3.i386.rpm</ulink
></literal>.
</para>

<para>
Para Debian, los paquetes que traen las principales herramientas son los
paquetes <literal remap="tt">hostname</literal>, <literal remap="tt">netbase</literal> y <literal remap="tt">netstd</literal>, que
encontrará en <literal remap="tt"><ulink
url="ftp://ftp.debian.org/debian/dists/stable/main/binary-i386/base/"
>ftp://ftp.debian.org/debian/dists/stable/main/binary-i386/base/</ulink
></literal>.
</para>

<para>
Asegúrese de que elige la versión que más se ajuste al núcleo que
desee usar y siga las instrucciones del paquete para instalarlo.
</para>

<para>
Para instalar y configurar la versión actual, ---en el momento de
traducirse esto--- esto necesitará hacer lo siguiente:
</para>

<para>

<screen>
usuario% cd /usr/src
usuario% tar xvfz net-tools-x.xx.tar.gz
usuario% cd net-tools-x.xx
usuario% make config
usuario% make
root# make install
</screen>

</para>

<para>
O si no, use los paquetes de su distribución. Por ejemplo, con RedHat:
</para>

<para>

<screen>
root# rpm -U net-tools-x.xx-y.i386.rpm
</screen>

</para>

<para>
y con Debian:
</para>

<para>

<screen>
root# dpkg -i hostname_x.xx-y.yy.deb
root# dpkg -i netbase_x.xx-y.yy.deb
root# dpkg -i netstd_x.xx-y.yy.deb
</screen>

</para>

<para>
En los anteriores ejemplos, <literal remap="tt">x.xx</literal> se refiere a la versión de las
herramientas, e <literal remap="tt">y.yy</literal> a la revisión de los correspondientes
paquetes.
</para>

<para>
Si además va a configurar un cortafuegos o a usar la característica de IP
Masquerade, necesitará <literal remap="tt">ipfwadm</literal>.  La última versión la puede
obtener en: <literal remap="tt"><ulink
url="ftp:/ftp.xos.nl/pub/linux/ipfwadm"
>ftp:/ftp.xos.nl/pub/linux/ipfwadm</ulink
></literal>.  De nuevo se encontrará
con más de una versión disponible. Asegúrese de coger la versión que más
se ajuste a su núcleo. Tenga en cuenta que las capacidades de cortafuegos
de Linux cambiaron durante el desarrollo <literal remap="tt">2.1</literal> y <literal remap="tt">ipfwadm</literal> ha
sido sustituida por <literal remap="tt">ipchains</literal> en la versión <literal remap="tt">2.2</literal> del núcleo.
<literal remap="tt">ipfwadm</literal> sólo vale para la versión <literal remap="tt">2.0</literal> del núcleo. Se sabe
de estas distribuciones que se ajustan a versiones <literal remap="tt">2.0</literal> o anteriores
del núcleo:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Redhat 5.2 o anteriores
</para>
</listitem>
<listitem>

<para>
Caldera antes de la versión 2.2
</para>
</listitem>
<listitem>

<para>
Slackware antes de las versiones 4.x
</para>
</listitem>
<listitem>

<para>
Debian antes de las versiones 2.x
</para>
</listitem>

</itemizedlist>

</para>

<para>
Para instalar y configurar la versión actual en el momento de escribir
esto necesita leer el <emphasis remap="it">IPChains Howto</emphasis>, disponible en el Proyecto de
Documentación de Linux <literal remap="tt"><ulink
url="http://www.linuxdoc.org/"
>http://www.linuxdoc.org</ulink
></literal>
</para>

<para>
Tenga en cuenta que si tiene una versión <literal remap="tt">2.2</literal> (o <literal remap="tt">2.1</literal> de las
últimas) del núcleo, <literal remap="tt">ipfwadm</literal> no es la herramienta correcta para
configurar un cortafuegos. Esta versión del <emphasis remap="it">NET-3-HOWTO</emphasis> todavía no
trata con la nueva configuración de cortafuegos. Si necesita información
más detallada sobre <literal remap="tt">ipchains</literal>, por favor, diríjase al documento
mencionado anteriormente.  
</para>

</sect3>

<sect3>
<title>Aplicaciones de red.</title>

<para>
Las aplicaciones de red son programas como <literal remap="tt">telnet</literal> y <literal remap="tt">ftp</literal>
y sus respectivos programas servidores. David Holland estuvo manteniendo
una distribución de las más comunes de la que ahora se ocupa <ulink
url="mailto:netbug@ftp.uk.linux.org"
>:netbug@ftp.uk.linux.org</ulink
>.
Puede obtenerlas en: <literal remap="tt"><ulink
url="ftp://ftp.uk.linux.org/pub/linux/Networking/base"
>ftp://ftp.uk.linux.org/pub/linux/Networking/base</ulink
></literal>.
</para>

</sect3>

<sect3>
<title>Introducción a las direcciones IP.</title>

<para>
Las direcciones del Protocolo Internet (IP) están compuestas por cuatro
bytes. La convención es escribir estas direcciones en la denominada
«notación decimal puntuada» (<emphasis remap="it">dotted decimal notation</emphasis>). De esta forma
cada byte es convertido en un número decimal (0-255), despreciando los
ceros a la izquierda a menos que el número en sí sea cero.  Por
convención, cada interfaz de una máquina o encaminador tiene una
dirección IP. Es válido usar la misma IP para cada interfaz de una sola
máquina en algunas circunstancias, pero normalmente cada interfaz tiene
su propia dirección.
</para>

<para>
Las Redes basadas en <emphasis remap="it">Internet Procotol</emphasis> son secuencias contiguas de
direcciones IP.  Todas las direcciones dentro de una red tienen un número
de dígitos de en común. A la porción de la red que es común a todas las
direcciones llama la «porción de la red». Los dígitos restantes son
llamados «porción de la máquina». Al número de bits que comparten todas
las direcciones de una red se le llama máscara de red (<emphasis remap="it">netmask</emphasis>), y
su papel es determinar qué direcciones pertenecen a la red y cuáles no.
Consideremos el siguiente ejemplo:
</para>

<para>

<screen>
---------------------  ---------------
Dirección Host         192.168.110.23
Máscara de red         255.255.255.0
Porción de red         192.168.110.
Porción de Host        .23
---------------------  ---------------
Dirección de Red       192.168.110.0
Dirección de Difusión  192.168.110.255
---------------------  ---------------
</screen>

</para>

<para>
Cualquier dirección a la que se aplique una operación <emphasis remap="it">and</emphasis> de bits
con su máscara de red, revelará la dirección de la red a la que
pertenece. La dirección de red es por tanto siempre el menor número de
dirección dentro de el rango de la red y siempre tiene la porción de
máquina codificada toda con ceros.
</para>

<para>
La dirección «de difusión» (<emphasis remap="it">broadcast</emphasis>) es una especial a la que
escucha cada máquina en la red además de a la suya propia. Esta dirección
es a la que se envían los datagramas si se supone que todas las máquinas
de la red lo deben recibir. Ciertos tipos de datos, como la información
de encaminamiento y los mensajes de aviso son transmitidos a la dirección
de difusión para que cada estación en la red pueda recibirlo
simultáneamente. Hay dos estándares usados comúnmente al respecto de la
dirección de difusión. El más ampliamente aceptado es el de usar la
dirección más alta posible en la red. En el ejemplo anterior sería
<literal remap="tt">192.168.110.255</literal>. Por alguna razón, otras estaciones han adoptado
la convención de usar las direcciones de red como direcciones de
difusión. En la práctica no importa mucho cual use, pero asegúrese de que
cada máquina en la red está configurada con la misma.
</para>

<para>
Por razones administrativas, durante el desarrollo inicial del protocolo
IP se formaron, de forma arbitraria, algunos grupos de direcciones como
redes, y estas redes se agruparon en las llamadas «clases».  Estas clases
proporcionan un cierto número de redes de tamaño estándar que pueden ser
reservadas. Los rangos reservados son:
</para>

<para>

<screen>
----------------------------------------------------------
| Clase   | Máscara de    | Direcciones de red           |
| de red  | red           |                              |
----------------------------------------------------------
|    A    | 255.0.0.0     | 0.0.0.0    - 127.255.255.255 |
|    B    | 255.255.0.0   | 128.0.0.0  - 191.255.255.255 |
|    C    | 255.255.255.0 | 192.0.0.0  - 223.255.255.255 |
|Multicast| 240.0.0.0     | 224.0.0.0  - 239.255.255.255 |
----------------------------------------------------------
</screen>

</para>

<para>
Las direcciones que deberá usar dependen de lo que vaya a hacer
exactamente. Puede que tenga que realizar varias de las siguientes
actividades para obtener las direcciones que necesite:
</para>

<para>
<variablelist>

<varlistentry>
<term>Instalar una máquina Linux en una red IP existente</term>
<listitem>
<para>
Si
desea instalar una máquina Linux en una red IP existente entonces
debería contactar con los administradores de la red y preguntarles por
la siguiente información:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Dirección IP del Host
</para>
</listitem>
<listitem>

<para>
Dirección IP de la red
</para>
</listitem>
<listitem>

<para>
Dirección IP de broadcast
</para>
</listitem>
<listitem>

<para>
Máscara de red IP
</para>
</listitem>
<listitem>

<para>
Dirección del encaminador (router)
</para>
</listitem>
<listitem>

<para>
Dirección del Servidor de Nombre de Dominio (DNS)
</para>
</listitem>

</itemizedlist>

</para>

<para>
Debería configurar entonces el dispositivo de red Linux con esos
detalles. No puede inventarlos y esperar que la configuración funcione.
</para>
</listitem></varlistentry>
<varlistentry>
<term>Construir una nueva red propia que nunca conectará con
Internet</term>
<listitem>
<para>
Si está construyendo una red privada y no tiene intención
de conectar nunca esa red a Internet entonces puede elegir las
direcciones que quiera. De todas maneras, por razones de seguridad y
consistencia, se han reservado algunas direcciones IP de red
específicamente para este propósito. Están descritas en el RFC1597 y son
las que siguen:
</para>

<para>

<screen>
-----------------------------------------------------------
|      DIRECCIONES RESERVADAS PARA REDES PRIVADAS         |
-----------------------------------------------------------
| Clase   | Máscara de    | Direcciones de red            |
| de red  | red           |                               |
-----------------------------------------------------------
|    A    | 255.0.0.0     | 10.0.0.0    - 10.255.255.255  |
|    B    | 255.255.0.0   | 172.16.0.0  - 172.31.255.255  |
|    C    | 255.255.255.0 | 192.168.0.0 - 192.168.255.255 |
-----------------------------------------------------------
</screen>

</para>

<para>
Primero debería decidir cuán grande quiere que sea su red para entonces
elegir tantas direcciones como necesite.
</para>
</listitem></varlistentry>
</variablelist>
</para>

</sect3>

</sect2>

<sect2>
<title>¿Dónde debería poner las órdenes de configuración?</title>

<para>
Hay unas pocas opciones a elegir para el procedimiento de arranque del
sistema Linux. Después de que carga el núcleo, siempre ejecuta un
programa llamado <literal remap="tt">init</literal>. El programa <literal remap="tt">init</literal> lee entonces el fichero
de configuración llamado <literal remap="tt">/etc/inittab</literal> y comienza el proceso de
arranque. Hay unos pocos <literal remap="tt">init</literal> diferentes, aunque todo el mundo está
ahora convergiendo al modelo <emphasis remap="it">SystemV</emphasis>, desarrollado por Miguel van
Smoorenburg.
</para>

<para>
A pesar de que el programa <literal remap="tt">init</literal> sea el mismo, la configuración del
arranque del sistema está organizada de manera diferente en cada
distribución.
</para>

<para>
Normalmente el fichero <literal remap="tt">/etc/inittab</literal> contiene una entrada que
dice algo como:
</para>

<para>

<screen>
si::sysinit:/etc/init.d/boot
</screen>

</para>

<para>
Esta línea especifica el nombre del fichero de guión de ejecución
(script) que controla la secuencia de carga. Este fichero es algo así
como el <literal remap="tt">AUTOEXEC.BAT</literal> en MS-DOS.
</para>

<para>
El guión de arranque suele llamar a otros, y a menudo la red se configura
dentro de alguno de éstos.
</para>

<para>
La siguiente tabla puede ser usada como guía para su sistema:
</para>

<para>

<screen>
----------------------------------------------------------------------
Distrib. |Interfaz Configuración/Encaminado  |Iniciación del Servidor
----------------------------------------------------------------------
Debian   | /etc/init.d/network               | /etc/rc2.d/*
----------------------------------------------------------------------
Slackware| /etc/rc.d/rc.inet1                | /etc/rc.d/rc.inet2
----------------------------------------------------------------------
RedHat   | /etc/rc.d/init.d/network          | /etc/rc.d/rc3.d/*
----------------------------------------------------------------------
</screen>

</para>

<para>
Fíjese en que Debian y Red Hat usan un directorio entero de guiones que
«levantan» los servicios del sistema (y normalmente la información no se
encuentra en esos archivos; por ejemplo, el sistema de Red Hat almacena
toda la configuración del sistema en ficheros dentro de
<literal remap="tt">/etc/sysconfig</literal>, de donde es leída por los guiones de carga). Si
quiere comprender los detalles del proceso de arranque del sistema, le
sugiero que examine <literal remap="tt">/etc/inittab</literal> y la documentación que acompaña
a <literal remap="tt">init</literal>. Linux Journal va a publicar (o lo ha hecho ya) un
artículo tratando la iniciación del sistema, y este documento mantendrá
una referencia a él tan pronto como esté disponible en la red.
</para>

<para>
La mayoría de distribuciones modernas incluyen algún programa que le
permita configurar la mayoría de interfaces de red. Si tiene una de éstas
entonces debería ver si hace lo que usted quiere antes de acudir a la
configuración manual.
</para>

<para>

<screen>
--------------------------------------------
Distrib.  | Programa de configuración de red
--------------------------------------------
RedHat    | /sbin/netcfg
Slackware | /sbin/netconfig
--------------------------------------------
</screen>

</para>

</sect2>

<sect2>
<title>Creación de las interfaces de red.</title>

<para>
En muchos sistemas operativos Unix los dispositivos de red tienen
correspondencias en el directorio <literal remap="tt">/dev</literal>. Esto <emphasis remap="bf">no</emphasis> pasa en
Linux.  Los dispositivos de red se crean de forma dinámica y por tanto no
requieren de la presencia de ficheros de dispositivo.
</para>

<para>
En la mayoría de los casos los dispositivos de red son creados
automáticamente por el controlador de dispositivos mientras se inicia y
localiza el hardware. Por ejemplo, el controlador Ethernet crea interfaces
<literal remap="tt">eth&lsqb;0..n]</literal> secuencialmente según va encontrado tarjetas Ethernet. La
primera tarjeta que encuentra es <literal remap="tt">eth0</literal>, la segunda <literal remap="tt">eth1</literal>, etc.
</para>

<para>
Sin embargo, en algunos casos, de los que <literal remap="tt">slip</literal> y <literal remap="tt">ppp</literal> son
ejemplos notables, los dispositivos de red son creados por la acción de
algún programa de usuario. Se aplica la misma numeración secuencial de
dispositivos, pero no se crean al arrancar. La razón es que al contrario
que con los dispositivos Ethernet, el número de dispositivos <literal remap="tt">ppp</literal> o
<literal remap="tt">slip</literal> puede variar durante la actividad de la máquina. Estos casos
serán cubiertos con más detalle en secciones posteriores.
</para>

</sect2>

<sect2 id="Ethernet">
<title>Configuración de una interfaz de red.
</title>

<para>
Cuando tenga todos los programas necesarios y su dirección e información
de red, puede configurar la interfaz de red. Cuando hablamos de
configurar una interfaz de red nos referimos al proceso de asignar
direcciones apropiadas a un dispositivo y asignar valores adecuados a
otros parámetros configurables.  El programa usado más comúnmente para
hacer esto es la orden <literal remap="tt">ifconfig</literal> (<emphasis remap="bf">i</emphasis>nter<emphasis remap="bf">f</emphasis>ace
<emphasis remap="bf">config</emphasis>ure).
</para>

<para>
Lo normal será usar una orden similar a la siguiente:
</para>

<para>

<screen>
root# ifconfig eth0 192.168.0.1 netmask 255.255.255.0 up
</screen>

</para>

<para>
En este caso estoy configurando la interfaz Ethernet <literal remap="tt">eth0</literal>, con
dirección IP <literal remap="tt">192.168.0.1</literal> y máscara de red <literal remap="tt">255.255.255.0</literal>. El
`<literal remap="tt">up</literal> del final de la orden le dice al interfaz que debería activarse,
pero normalmente se puede omitir, ya que es el valor por defecto. Para
desactivar una interfaz, simplemente tiene que ejecutar <literal remap="tt">ifconfig eth0
down</literal>.
</para>

<para>
El núcleo asume ciertas cosas cuando configura interfaces. Por ejemplo,
puede especificar la dirección de red y difusión de una interfaz, pero
si usted no lo hace, como en mi ejemplo anterior, entonces el núcleo hará
una suposición razonable de cuáles deberían ser, basándose en la máscara
que se le proporciona; si tampoco indica la máscara, entonces partirá
de la clase de la dirección IP configurada. En mi ejemplo, el núcleo
asumirá que se va a configurar una red clase C en la interfaz y establece
una dirección de red <literal remap="tt">192.168.0.0</literal> y una dirección de difusión
<literal remap="tt">192.168.0.255</literal>.  Hay otras muchas opciones para la orden <literal remap="tt">ifconfig</literal>.
Las mas importantes son:
</para>

<para>
<variablelist>

<varlistentry>
<term>up</term>
<listitem>
<para>
esta opción activa una interfaz (y es la opción por defecto).
</para>
</listitem></varlistentry>
<varlistentry>
<term>down</term>
<listitem>
<para>
esta opción desactiva una interfaz.
</para>
</listitem></varlistentry>
<varlistentry>
<term>&lsqb;-&rsqb;arp</term>
<listitem>
<para>
esta opción activa o desactiva el uso del protocolo
de resolución de dirección (<emphasis remap="bf">a</emphasis>ddress <emphasis remap="bf">r</emphasis>esolution <emphasis remap="bf">p</emphasis>rotocol) sobre
la interfaz
</para>
</listitem></varlistentry>
<varlistentry>
<term>&lsqb;-&rsqb;allmulti</term>
<listitem>
<para>
esta opción activa o desactiva la recepción de
todos los paquetes multicast por hardware. El multicast por hardware
permite que varios grupos de interfaces reciban paquetes remitidos a
destinos especiales. Esto puede ser de importancia si está usando
aplicaciones como videoconferencia, pero normalmente no se usa.
</para>
</listitem></varlistentry>
<varlistentry>
<term>mtu N</term>
<listitem>
<para>
este parámetro le permite especificar la MTU del dispositivo.
</para>
</listitem></varlistentry>
<varlistentry>
<term>netmask &lt;direc&#62;</term>
<listitem>
<para>
este parámetro le permite asignar la máscara de
la red a la que pertenece el dispositivo.
</para>
</listitem></varlistentry>
<varlistentry>
<term>irq &lt;direc&#62;</term>
<listitem>
<para>
este parámetro sólo trabaja con ciertos tipos de
hardware, y permite especificar la IRQ del dispositivo.
</para>
</listitem></varlistentry>
<varlistentry>
<term>&lsqb;-&rsqb;broadcast &lsqb;direc&rsqb;</term>
<listitem>
<para>
este parámetro le permite activar y
asignar la acepción de datagramas destinados a la dirección de difusión,
o desactivarla por completo.
</para>
</listitem></varlistentry>
<varlistentry>
<term>&lsqb;-&rsqb;pointopoint &lsqb;direc&rsqb;</term>
<listitem>
<para>
este parámetro le permite asignar
la dirección de la máquina en el otro extremo de un enlace punto a punto,
como en SLIP o PPP.
</para>
</listitem></varlistentry>
<varlistentry>
<term>hw &lt;tipo&#62; &lt;direc&#62;</term>
<listitem>
<para>
este parámetro le permite asignar la
dirección del hardware de ciertos tipos de dispositivos de red. Esto no
suele ser útil para Ethernet, pero lo es para otras redes como AX.25.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Puede usar la orden <literal remap="tt">ifconfig</literal> sobre cualquier dispositivo de red.
Algunos programas de usuario, como <literal remap="tt">pppd</literal> y <literal remap="tt">dip</literal> configuran
automáticamente los dispositivos de red al crearlos, por lo que es innecesario
el uso de <literal remap="tt">ifconfig</literal> con ellos.
</para>

</sect2>

<sect2 id="Resolucion-de-Nombres">
<title>Configuración del sistema de resolución de nombres (<emphasis remap="it">Name
Resolver</emphasis>) </title>

<para>
El sistema de <emphasis remap="it">resolución de nombres</emphasis> es una parte de la biblioteca estándar
de Linux.  Su función principal es proporcionar un servicio para convertir las
denominaciones «amistosas con el hombre» de las máquinas como <literal remap="tt">ftp.funet.fi</literal>
a direcciones IP «amigables para la máquina» como <literal remap="tt">128.214.248.6</literal>.
</para>

<sect3>
<title>¿Qué hay en un nombre?</title>

<para>
Posiblemente esté familiarizado con la apariencia de los nombres de máquina de
Internet, pero puede que no entienda como se construyen, o como se
«desconstruyen». Los nombres de dominio de Internet son jerárquicos por
naturaleza; esto es, tienen una estructura en árbol. Un <emphasis>dominio</emphasis> es una
familia, o grupo de nombres. Un <emphasis>dominio</emphasis> puede ser fragmentado en
<emphasis>subdominios</emphasis>. Un «dominio de nivel superior» (<emphasis remap="it">toplevel domain</emphasis>) es un
dominio que NO es un subdominio. Los Dominios de Nivel Superior están
especificados en el <emphasis remap="it">RFC-920</emphasis>. Algunos ejemplos de los más comunes son:
</para>

<para>
<variablelist>

<varlistentry>
<term>COM</term>
<listitem>
<para>
Organizaciones Comerciales
</para>
</listitem></varlistentry>
<varlistentry>
<term>EDU</term>
<listitem>
<para>
Organizaciones Educativas
</para>
</listitem></varlistentry>
<varlistentry>
<term>GOV</term>
<listitem>
<para>
Organizaciones Gubernamentales
</para>
</listitem></varlistentry>
<varlistentry>
<term>MIL</term>
<listitem>
<para>
Organizaciones Militares
</para>
</listitem></varlistentry>
<varlistentry>
<term>ORG</term>
<listitem>
<para>
Otras organizaciones
</para>
</listitem></varlistentry>
<varlistentry>
<term>NET</term>
<listitem>
<para>
Organizaciones relacionadas con InterNet
</para>
</listitem></varlistentry>
<varlistentry>
<term>Designador de País</term>
<listitem>
<para>
éstos son códigos de dos letras que representan a un
país en particular.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Por razones históricas, la mayoría de los dominios pertenecientes a uno de los
de nivel superior que no basados en un nombre de país, son de organizaciones
dentro de los Estados Unidos, aunque los Estados Unidos tienen también su
propio código de país <literal remap="tt">.us</literal>. Esto ha dejado de ser cierto para los dominios
<literal remap="tt">.com</literal> y <literal remap="tt">.org</literal>, que son usados de forma común por compañías de fuera de
los Estados Unidos de América.
</para>

<para>
Cada uno de estos dominios de nivel superior tiene subdominios. Los dominios de
nivel superior basados en el nombre de un país suelen estar divididos en
subdominios basados en <literal remap="tt">com</literal>, <literal remap="tt">edu</literal>, <literal remap="tt">gov</literal>, <literal remap="tt">mil</literal> y <literal remap="tt">org</literal>. Por
ejemplo, encontrará cosas como <literal remap="tt">com.au</literal> y <literal remap="tt">gov.au</literal>, las organizaciones
comerciales y gubernamentales en Australia.
</para>

<para>
El siguiente nivel de división suele representar el nombre de la organización.
Los siguientes subdominios varían, a menudo basando el siguiente nivel en la
estructura departamental de la organización a la que pertenecen, pero pueden
estarlo en cualquier criterio considerado razonable y con significado claro
para los administradores de la red de la organización.
</para>

<para>
La parte más a la izquierda de un nombre siempre es el nombre único asignado a
la máquina, y es llamada <emphasis>hostname</emphasis>, la porción del nombre a la derecha del
nombre de la máquina es el <emphasis>domainname</emphasis> (nombre de dominio), y el nombre
completo es llamado <emphasis>Fully Qualified Domain Name</emphasis> (Nombre de Dominio
Completamente Cualificado).
</para>

<para>
Si usamos el ordenador de Terry como ejemplo, el nombre completamente
cualificado es <literal remap="tt">perf.no.itg.telstra.com.au</literal>. Esto significa que el nombre de
la máquina es <literal remap="tt">perf</literal> y el nombre de dominio el <literal remap="tt">no.itg.telstra.com.au</literal>.
El nombre de dominio está basado en un dominio de nivel superior basado en su
país, Australia, y como su dirección de correo pertenece a una organización
comercial tenemos <literal remap="tt">.com</literal> como siguiente nivel de dominio.  El nombre de la
compañía es (era) <literal remap="tt">telstra</literal>, y la estructura interna de su nombre está
basada en una estructura organizacional. En su caso, la máquina pertenece al
Grupo de Tecnología de la Información (Information Technology Group), sección
de Operaciones de Red (Network Operations).
</para>

<para>
Los nombres son, por norma, bastante más cortos; por ejemplo, mi PSI se llama
<literal remap="tt">systemy.it</literal> y mi organización sin ánimo de lucro se llama <literal remap="tt">linux.it</literal>,
sin subdominio <literal remap="tt">com</literal> ni <literal remap="tt">org</literal>, por lo que mi propia máquina se llama
<literal remap="tt">morgana.systemy.it</literal> y <literal remap="tt">rubini@linux.it</literal> es una dirección de correo
electrónico válida. Sepa que el dueño de un dominio tiene derecho tanto para
registrar una máquina como para registrar subdominios; por ejemplo, el GUL
(Grupo de Usuarios de Linux) al que pertenezco usa el dominio
<literal remap="tt">pluto.linux.it</literal>, porque los dueños de <literal remap="tt">linux.it</literal> convinieron en abrir un
subdominio para el GUL. 
</para>

</sect3>

<sect3>
<title>Qué información necesitará</title>

<para>
Necesitará saber a qué dominio pertenecen sus máquinas. El software de
resolución de nombres proporciona el servicio de traducción
haciendo consultas a un <emphasis>Servidor de Nombres de Dominio</emphasis>
(<emphasis remap="it">Domain Name Server</emphasis>), por lo que deberá saber la dirección IP del servidor
de nombres (<emphasis remap="it">nameserver</emphasis>) local que vaya a usar.
</para>

<para>
Hay tres ficheros que es necesario editar. Los comentaré uno a uno.
</para>

</sect3>

<sect3>
<title><literal remap="tt">/etc/resolv.conf</literal></title>

<para>
<literal remap="tt">/etc/resolv.conf</literal> es el fichero de configuración principal del código
de resolución de nombres. Su formato es bastante simple. Es un fichero de texto
con una palabra clave por línea. Hay tres palabras clave de uso frecuente, que
son:
</para>

<para>
<variablelist>

<varlistentry>
<term>domain</term>
<listitem>
<para>
esta palabra clave especifica el nombre de dominio local.
</para>
</listitem></varlistentry>
<varlistentry>
<term>search</term>
<listitem>
<para>
ésta especifica una lista de dominios alternativos para completar
el nombre de una máquina.
</para>
</listitem></varlistentry>
<varlistentry>
<term>nameserver</term>
<listitem>
<para>
ésta, que puede utilizarse varias veces, especifica una
dirección IP de un servidor de nombres de dominio para consultarlo cuando se
resuelvan nombres.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Su <literal remap="tt">/etc/resolv.conf</literal> podría parecerse a éste:
</para>

<para>

<screen>
domain maths.wu.edu.au
search maths.wu.edu.au wu.edu.au
nameserver 192.168.10.1
nameserver 192.168.12.1
</screen>

</para>

<para>
Este ejemplo especifica que el nombre de dominio por defecto para
añadir a los nombres no cualificados (esto es, nombres de máquinas
suministrados sin dominio) es <literal remap="tt">maths.wu.edu.au</literal>, y que si no se encuentra la
máquina en este dominio intentemos también el dominio <literal remap="tt">wu.edu.au</literal>
directamente.  Se proporcionan dos entradas de servidor de nombres, cada uno de
los cuales puede ser llamado por el código de resolución de nombres para
traducir el nombre.
</para>

</sect3>

<sect3>
<title><literal remap="tt">/etc/host.conf</literal></title>

<para>
El fichero <literal remap="tt">/etc/host.conf</literal> es el lugar donde se configuran algunos
elementos que gobiernan el comportamiento del código de resolución de nombres.
El formato de este fichero está descrito en detalle en la página de manual
<literal remap="tt">resolv+</literal>. El ejemplo siguiente funcionará en casi todas las
circunstancias:
</para>

<para>

<screen>
order hosts,bind
multi on
</screen>

</para>

<para>
Esta configuración le dice al resolutor de nombres que examine el fichero
<literal remap="tt">/etc/hosts</literal> antes de intentar consultar a un servidor de nombres, y que
devuelva todas las direcciones válidas de una máquina que encuentre en el
fichero <literal remap="tt">/etc/hosts</literal>, en lugar de sólo el primero.
</para>

</sect3>

<sect3>
<title><literal remap="tt">/etc/hosts</literal></title>

<para>
El fichero <literal remap="tt">/etc/hosts</literal> es donde se pone el nombre y dirección IP de las
máquinas locales. Si usted inserta un nombre en este fichero, entonces su
ordenador no consultará a un servidor de dominio para obtener la dirección IP.
La desventaja de este método es que usted mismo tendrá que poner el fichero al
día si la dirección de alguna máquina cambia. En un sistema bien administrado,
las únicas entradas que suelen aparecer son la interfaz de loopback (prueba en
bucle) y el nombre de la máquina local.
</para>

<para>

<screen>
# /etc/hosts
127.0.0.1      localhost loopback
192.168.0.1    this.host.name
</screen>

</para>

<para>
Se puede especificar más de un nombre de máquina por línea, como se
demuestra en la primera entrada, que es la forma estándar para la interfaz
de prueba (loopback).
</para>

</sect3>

<sect3>
<title>Ejecutar un servidor de nombres</title>

<para>
Si quiere tener un servidor de nombres local, le resultará sencillo.  Por
favor, lea el DNS Como, <literal remap="tt"><ulink
url="http://www.insflug.org/documentos/DNS-Como/"
>http://www.insflug.org/documentos/DNS-Como/</ulink
></literal> y la documentación
incluida en su copia de <literal remap="tt">BIND</literal> (<emphasis remap="it">Berkeley Internet Name Domain</emphasis>).
</para>

</sect3>

</sect2>

<sect2>
<title>Configuración de la interfaz <literal remap="tt">loopback</literal></title>

<para>
La interfaz <emphasis remap="it">loopback</emphasis>' es un tipo especial de interfaz que le
permite hacer conexiones consigo mismo. Hay varias razones por las que
podría querer esto. Por ejemplo, puede que desee probar algún tipo de
programa sin interferir con alguien más en su red. Por convención,
la dirección de red IP <literal remap="tt">127.0.0.1</literal> ha sido asignada específicamente
para el dispositivo de pruebas. Por lo que da igual lo que haga su máquina,
que si abre una conexión de telnet a <literal remap="tt">127.0.0.1</literal>, siempre llegará a la
interfaz interna.
</para>

<para>
Configurar la interfaz <literal remap="tt">loopback</literal> es simple y debería asegurarse de
hacerlo.
</para>

<para>

<screen>
root# ifconfig lo 127.0.0.1
root# route add -host 127.0.0.1 lo
</screen>

</para>

<para>
Hablaremos más de la orden <literal remap="tt">route</literal> en la siguiente sección.
</para>

</sect2>

<sect2>
<title>Encaminamiento (<emphasis remap="it">Routing</emphasis>).</title>

<para>
El encaminamiento es un tema amplio. Sería fácil llenar varios volúmenes
hablando de él. La mayoría de ustedes tendrán requisitos de encaminamiento
relativamente simples, pero algunos no. Cubriré solamente algunos de los
fundamentos básicos. Si está interesado en información más detallada, entonces
sugiero que se remita a las referencias propuestas al principio del documento.
</para>

<para>
Comencemos con una definición. ¿Qué es el encaminamiento IP? Esta es
la que yo suelo aplicar:
</para>

<para>
<quote
>El Encaminamiento IP es el proceso por el que una máquina con múltiples
conexiones de red decide por dónde dirigir un datagrama IP que haya recibido.</quote
>
</para>

<para>
Sería útil ilustrar esto con un ejemplo. Imagine una oficina con el
encaminamiento típico, que podría constar de un enlace PPP con Internet,
varios segmentos Ethernet alimentando las estaciones de trabajo, y un
enlace PPP hacia otra oficina. Cuando el encaminador recibe un datagrama en
cualquiera de sus conexiones de red, el mecanismo que usa para determinar
qué interfaz debería enviar el datagrama, es el encaminamiento. Las
estaciones sencillas también necesitan encaminar. Todas las estaciones en
Internet tienen dos dispositivos de red: uno es la interfaz de pruebas
descrita anteriormente, y la otra es la que usa para comunicarse con el
resto de la red, quizá una Ethernet, quizá una interfaz serie PPP o SLIP.
</para>

<para>
Bien... Por tanto, ¿cómo funciona el encaminado? Cada máquina tiene una
lista de reglas, llamada tabla de encaminamiento. Esta tabla contiene
columnas que suelen contener al menos tres campos: el primero es una
dirección de destino, el segundo es el nombre de la interfaz a la que se
va a encaminar el datagrama, y el tercero es (opcionalmente) la dirección
IP de otra máquina que cogerá el datagrama en su siguiente paso a través
de la red. En Linux puede ver esta tabla usando la siguiente orden:
</para>

<para>

<screen>
root# cat /proc/net/route
</screen>

</para>

<para>
o con cualquiera de estas otras:
</para>

<para>

<screen>
root# /sbin/route -n
root# /bin/netstat -r
</screen>

</para>

<para>
El proceso de encaminado es relativamente simple: se recibe un datagrama
que llega, se examina la dirección de destino (para quién es) y se compara
con cada entrada en la lista. Se selecciona la entrada que más se parezca
y se reenvía el datagrama a la interfaz especificada. Si el campo de
pasarela (gateway) está descrito, el datagrama se reenvía a esa máquina
mediante la interfaz especificada, y si no, se asume que la dirección de
destino está en la red a la que se accede mediante la interfaz
correspondiente.
</para>

<para>
Para manipular esta tabla se usa una orden especial. Esta instrucción toma
sus argumentos en línea de órdenes y los convierte en llamadas al sistema
del núcleo, que le piden que añada, borre o modifique entradas en la tabla
de encaminamiento. Dicha orden se llama <literal remap="tt">route</literal>.
</para>

<para>
Un ejemplo sencillo. Imagine que tiene una red Ethernet. Le han dicho que
pertenece a una red clase C con dirección <literal remap="tt">192.168.1.0</literal>. Le han dado la
dirección IP <literal remap="tt">192.168.1.10</literal> para su uso y también que <literal remap="tt">192.168.1.1</literal>
es un encaminador conectado a Internet.
</para>

<para>
El primer paso es configurar la interfaz como se describió anteriormente. 
Puede usar una orden como:
</para>

<para>

<screen>
root# ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up
</screen>

</para>

<para>
Ahora necesita añadir una entrada en la tabla de rutas para decirle al
núcleo que los datagramas destinados a todas las máquinas con direcciones
que se ajusten a <literal remap="tt">192.168.1.*</literal>, deberán ser enviados al dispositivo
Ethernet. Debería usar una orden similar a:
</para>

<para>

<screen>
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
</screen>

</para>

<para>
Fíjese en el uso del parámetro <literal remap="tt">-net</literal> para especificar al programa
<literal remap="tt">route</literal> que esta entrada es una regla para una red completa. Otra opción es
<literal remap="tt">-host</literal>, que indica una vía específica a una dirección IP en particular.
</para>

<para>
Esta ruta le permitirá establecer conexiones IP con todas las estaciones
de su segmento Ethernet. Pero ¿qué pasa con todas las máquinas con dirección IP
que no están en su segmento Ethernet?
</para>

<para>
Sería bastante engorroso, por no decir imposible, tener que añadir caminos
para cada red de destino posible, por lo que existe un truco que se usa
para simplificar la tarea. A este truco se le llama camino <emphasis remap="it">por defecto</emphasis>. El
camino <emphasis remap="it">por defecto</emphasis> se ajusta a todo destino posible, pero con prioridad
mínima, por lo que si existe cualquier otra entrada que se ajuste a la
dirección requerida, será la que se use en lugar del camino <emphasis remap="it">por defecto</emphasis>.
La idea del camino <emphasis remap="it">por defecto</emphasis> es simplemente permitirle decir: «y todo lo
demás debería ir por aquí». En el ejemplo que me he inventado podría usar una
orden como:
</para>

<para>

<screen>
root# route add default gw 192.168.1.1 eth0
</screen>

</para>

<para>
El parámetro <literal remap="tt">gw</literal> le dice a la orden <literal remap="tt">route</literal> que lo que le sigue es la
dirección IP, o nombre, de una pasarela u otra máquina encaminadora a la que se
deberían enviar todos los datagramas que se ajusten a esta entrada para futuro
encaminamiento.
</para>

<para>
Por lo tanto, la configuración completa debería parecerse a:
</para>

<para>

<screen>
root# ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
root# route add default gw 192.168.1.1 eth0
</screen>

</para>

<para>
Si echa una mirada a los ficheros <literal remap="tt">rc</literal> de red de su máquina, encontrará que
al menos uno de ellos se parece mucho a esto. Es una configuración muy común.
</para>

<para>
Veamos ahora una configuración de encaminamiento un poco más complicada. 
Imaginemos que estamos configurando el encaminador de antes, el que
soportaba el enlace PPP a Internet y los segmentos LAN alimentando las
estaciones de trabajo en la oficina. Imaginemos que el encaminador tiene
tres segmentos Ethernet y un enlace PPP. Nuestra configuración de
encaminamiento debería parecerse a esto:
</para>

<para>

<screen>
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
root# route add -net 192.168.2.0 netmask 255.255.255.0 eth1
root# route add -net 192.168.3.0 netmask 255.255.255.0 eth2
root# route add default ppp0
</screen>

</para>

<para>
Cada una de las estaciones debería usar la forma simple que presentamos
anteriormente. Sólo el encaminador necesita especificar cada uno de los
caminos de red de forma separada, porque para las estaciones el mecanismo de
encaminamiento <literal remap="tt">por defecto</literal> enviará todos los paquetes al encaminador,
dejándole el problema de repartirlos. Puede estar preguntándose por qué
el encaminador por defecto presentado no especifica un <literal remap="tt">gw</literal>. La
razón es simple: los protocolos de enlace serie como PPP y SLIP sólo
tienen dos terminales en su red, uno en cada extremo. Especificar el host
al otro extremo como pasarela no tiene sentido y es redundante, ya que no
hay otra elección, por lo que no se necesita especificar una pasarela para
este tipo de conexión de red.  Otros tipos como Ethernet, arcnet o token
ring necesitan que se especifique la pasarela, ya que se puede acceder a
un gran número de terminales al mismo tiempo.
</para>

<sect3>
<title>Entonces ¿qué hace el programa <literal remap="tt">routed</literal>?</title>

<para>
La configuración de encaminamiento descrita anteriormente se ajusta a
necesidades de red simples, donde los posibles caminos hacia los destinos
son sencillos. Cuando se tienen necesidades de red más complejas, las cosas
se vuelven un poco más complicadas. Afortunadamente la mayoría de ustedes
no tendrá este problema.
</para>

<para>
El gran problema con el «encaminamiento manual» o «encaminamiento
estático» que aquí se ha descrito, es que si una máquina o enlace falla en la
red, entonces la única manera en que podrá dirigir sus datagramas por otra
dirección, si es que existe, es interviniendo manualmente y ejecutando las
órdenes apropiadas. Naturalmente esto es poco elegante, lento, nada práctico y
peligroso. Se han desarrollado varias técnicas para ajustar automáticamente las
tablas de encaminamiento en el caso de fallos en la red donde hubiera caminos
alternativos. Todas estas técnicas se agrupan de manera no muy oficial bajo la
definición «protocolos de encaminamiento dinámico».
</para>

<para>
Puede que haya oído de alguno de los protocolos más comunes. Es probable
que RIP (<emphasis remap="it">Routing Information Protocol</emphasis>) y OSPF (<emphasis remap="it">Open Shortest Path
First Protocol</emphasis>) sean los más comunes. El Routing Information Protocol es muy
común en redes pequeñas, como las redes corporativas pequeñas y medianas o en
las redes de edificios. El OSPF es más moderno y más capaz de gestionar grandes
configuraciones de red, y está mejor preparado para entornos donde haya un gran
número de caminos posibles a través de la red.  Las implementaciones habituales
de estos protocolos son: <literal remap="tt">routed</literal> (RIP) y <literal remap="tt">gated</literal> (RIP, OSPF y otros). El
programa <literal remap="tt">routed</literal> suele venir incluido en las distribuciones de Linux, y si
no, estará incluido en el paquete <emphasis remap="it">NetKit</emphasis>, detallado más adelante.
</para>

<para>
Un ejemplo de dónde y cómo debería usar un protocolo de encaminamiento dinámico
vendría a ser algo como lo siguiente:
</para>

<para>

<screen>
      192.168.1.0 /                         192.168.2.0 /
         255.255.255.0                         255.255.255.0
       -                                     -
       |                                     |
       |   /-----\                 /-----\   |
       |   |     |ppp0   //    ppp0|     |   |
  eth0 |---|  A  |------//---------|  B  |---| eth0
       |   |     |     //          |     |   |
       |   \-----/                 \-----/   |
       |      \ ppp1             ppp1 /      |
       -       \                     /       -
                \                   /
                 \                 /
                  \               /
                   \             /
                    \           /
                     \         /
                      \       /
                       \     /
                    ppp0\   /ppp1
                       /-----\
                       |     |
                       |  C  |
                       |     |
                       \-----/
                          |eth0
                          |
                     |---------|
                     192.168.3.0 /
                        255.255.255.0
</screen>

</para>

<para>
Tenemos tres encaminadores <literal remap="tt">A</literal>, <literal remap="tt">B</literal> y <literal remap="tt">C</literal>. Cada uno da servicio a un
segmento Ethernet con una red IP de clase C (máscara de red
<literal remap="tt">255.255.255.0</literal>). Cada encaminador tiene también un enlace PPP a cada uno de
los otros encaminadores. La red forma un triángulo.
</para>

<para>
Debería estar claro que la tabla de encaminamiento del encaminador <literal remap="tt">A</literal>
podría ser algo como:
</para>

<para>

<screen>
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
root# route add -net 192.168.2.0 netmask 255.255.255.0 ppp0
root# route add -net 192.168.3.0 netmask 255.255.255.0 ppp1
</screen>

</para>

<para>
Esto funcionaría bien hasta que el enlace entre los encaminadores <literal remap="tt">A</literal> y
<literal remap="tt">B</literal> falle. Si falla ese enlace, entonces con la entrada de encaminamiento
mostrada anteriormente, las máquinas del segmento Ethernet de <literal remap="tt">A</literal> no podrán
alcanzar a las del segmento Ethernet en <literal remap="tt">B</literal> porque sus datagramas
serán dirigidos al enlace <literal remap="tt">ppp0</literal> de <literal remap="tt">A</literal> que está mal. Podrían seguir
comunicándose todavía con las máquinas del segmento Ethernet de <literal remap="tt">C</literal>, y las
del segmento Ethernet de <literal remap="tt">C</literal> con las del segmento Ethernet de <literal remap="tt">B</literal>, porque
el enlace entre <literal remap="tt">B</literal> y <literal remap="tt">C</literal> aún está intacto.
</para>

<para>
Pero espere un momento. Si <literal remap="tt">A</literal> puede hablar con <literal remap="tt">C</literal> y <literal remap="tt">C</literal> puede aún
hablar con <literal remap="tt">B</literal>, ¿por qué no puede <literal remap="tt">A</literal> encaminar sus datagramas para
<literal remap="tt">B</literal> a través de <literal remap="tt">C</literal> y dejar que <literal remap="tt">C</literal> se los mande a <literal remap="tt">B</literal>? Este es
exactamente el tipo de problema para el que fueron diseñados los protocolos de
encaminamiento dinámico como RIP. Si cada uno de los encaminadores <literal remap="tt">A</literal>,
<literal remap="tt">B</literal> y <literal remap="tt">C</literal> está ejecutando el demonio de encaminamiento, entonces sus
tablas deberían ser ajustadas automáticamente para reflejar el nuevo estado de
la red si alguno de los enlaces falla. Configurar tal red es sencillo. En cada
encaminador sólo necesita hacer dos cosas. En este caso, para el Encaminador
<literal remap="tt">A</literal>:
</para>

<para>

<screen>
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
root# /usr/sbin/routed
</screen>

</para>

<para>
El demonio de encaminamiento <literal remap="tt">routed</literal> encuentra automáticamente todos
los puertos de red activos cuando comienza y busca mensajes en cada uno de
los dispositivos de red para poder determinar y poner al día la tabla de
encaminamiento en el host.
</para>

<para>
Ésta ha sido una explicación muy concisa del encaminamiento dinámico y de
dónde podría usarlo. Si quiere más información, tendrá que
acudir a las referencias listadas al principio del documento.
</para>

<para>
Los puntos importantes relacionados con el encaminamiento dinámico son:
</para>

<para>

<orderedlist>
<listitem>

<para>
Sólo necesita ejecutar un protocolo de encaminamiento dinámico cuando su
máquina Linux tenga la posibilidad de elegir entre múltiples caminos para
llegar a un destino.

</para>
</listitem>
<listitem>

<para>
El demonio de encaminamiento dinámico modificará automáticamente la tabla
de encaminamiento para ajustarla a los cambios en la red.

</para>
</listitem>
<listitem>

<para>
RIP es adecuado para redes de tamaño pequeño y medio.

</para>
</listitem>

</orderedlist>

</para>

</sect3>

</sect2>

<sect2>
<title>Configuración de los servidores de red y los servicios.</title>

<para>
Los servidores de red y los servicios son aquellos programas que permiten a un
usuario remoto hacer uso de su máquina Linux. Los programas servidores escuchan
en los puertos de red. Los puertos de red son el medio de llegar a un servicio
en particular en una máquina en particular, y es así como un servidor conoce la
diferencia entre una conexión telnet y otra de FTP que le lleguen. El usuario
remoto establece una conexión de red con la máquina, y el programa servidor, el
demonio de red que esté escuchando en ese puerto, aceptará la conexión y se
ejecutará. Hay dos modos de operación para los demonios de red. Ambos se usan
por igual en la práctica. Las dos maneras son:
</para>

<para>
<variablelist>

<varlistentry>
<term>autónomo (standalone)</term>
<listitem>
<para>
el programa demonio de red escucha en el puerto
de red asignado y, cuando llega una conexión, se ocupa él mismo de dar el
servicio de red.
</para>
</listitem></varlistentry>
<varlistentry>
<term>esclavo del servidor <literal remap="tt">inetd</literal></term>
<listitem>
<para>
el servidor inetd es un demonio
de red especial que se especializa en controlar las conexiones entrantes. Tiene
un fichero de configuración que le dice qué programa debe ser ejecutado cuando
se reciba una conexión. Cualquier puerto de servicio puede ser configurado
tanto para el protocolo tcp como para udp. Los puertos son descritos en otro
fichero del que hablaremos dentro de poco.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Hay dos ficheros importantes que necesitamos configurar. Son el fichero
<literal remap="tt">/etc/services</literal> que asigna nombres a los números de puerto y el
fichero <literal remap="tt">/etc/inetd.conf</literal> que es el fichero de configuración del
demonio de red <literal remap="tt">inetd</literal>.
</para>

<sect3>
<title><literal remap="tt">/etc/services</literal></title>

<para>
El fichero <literal remap="tt">/etc/services</literal> es una base de datos sencilla, que asocia un
nombre que nosotros podamos entender, con un puerto de servicio de la máquina.
Su formato es bastante simple. Es un fichero de texto en el que cada línea
representa una entrada a la base de datos. Cada entrada comprende tres campos
separados por cualquier número de espacios en blanco (espacio o tabulador). Los
campos son:
</para>

<para>

<screen>
nombre      puerto/protocolo        sobrenombres     # comentario
</screen>

</para>

<para>
<variablelist>

<varlistentry>
<term>nombre</term>
<listitem>
<para>
una sola palabra que representa el servicio descrito.
</para>
</listitem></varlistentry>
<varlistentry>
<term>puerto/protocolo</term>
<listitem>
<para>
este campo está dividido en dos subcampos.
</para>
</listitem></varlistentry>
<varlistentry>
<term>puerto</term>
<listitem>
<para>
un número que especifica el número de puerto del servicio que
estará disponible. La mayoría de los servicios comunes tienen asignados números
de servicio, y están descritos en el <emphasis remap="it">RFC-1340</emphasis>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>protocolo</term>
<listitem>
<para>
este subcampo debe tener como valor <literal remap="tt">tcp</literal> o
<literal remap="tt">udp</literal>.
</para>

<para>
Es importante que tenga en cuenta que el servicio <literal remap="tt">18/tcp</literal> es muy
diferente del <literal remap="tt">18/udp</literal> y que no hay razón técnica por la cual deban
existir ambos.  Normalmente prevalece el sentido común, y sólo verá una entrada
<literal remap="tt">tcp</literal> y otra <literal remap="tt">udp</literal> para el mismo servicio si es que está
disponible para ambos.
</para>
</listitem></varlistentry>
<varlistentry>
<term>sobrenombres</term>
<listitem>
<para>
(o alias) otros nombres que pueden usarse para referirse
a esta entrada de servicio.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Cualquier texto que aparezca en una línea después de un caracter <literal remap="tt">#</literal> es
ignorado y se trata como un comentario.
</para>

<sect4>
<title>Un ejemplo de fichero <literal remap="tt">/etc/services</literal>.</title>

<para>
Todas las distribuciones modernas de Linux tienen un buen fichero
<literal remap="tt">/etc/services</literal>. Para el caso de que esté montando una máquina desde
cero, aquí tiene una copia del fichero <literal remap="tt">/etc/services</literal> proporcionado por
una antigua la distribución Debian <literal remap="tt"><ulink
url="http://www.debian.org/"
>http://www.debian.org</ulink
></literal>:
</para>

<para>

<screen>
# /etc/services:
# $Id: Redes-En-Linux-Como.xml,v 1.1.1.2 2003/12/10 09:48:56 pfabrega Exp $
#
# Network services, Internet style
#
# Note that it is presently the policy of IANA to assign a single well-known
# port number for both TCP and UDP; hence, most entries here have two entries
# even if the protocol doesn't support UDP operations.
# Updated from RFC 1340, «Assigned Numbers» (July 1992).  Not all ports
# are included, only the more common ones.

tcpmux          1/tcp                           # TCP port service multiplexer
echo            7/tcp
echo            7/udp
discard         9/tcp           sink null
discard         9/udp           sink null
systat          11/tcp          users
daytime         13/tcp
daytime         13/udp
netstat         15/tcp
qotd            17/tcp          quote
msp             18/tcp                          # message send protocol
msp             18/udp                          # message send protocol
chargen         19/tcp          ttytst source
chargen         19/udp          ttytst source
ftp-data        20/tcp
ftp             21/tcp
ssh             22/tcp                          # SSH Remote Login Protocol
ssh             22/udp                          # SSH Remote Login Protocol
telnet          23/tcp
# 24 - private
smtp            25/tcp          mail
# 26 - unassigned
time            37/tcp          timserver
time            37/udp          timserver
rlp             39/udp          resource        # resource location
nameserver      42/tcp          name            # IEN 116
whois           43/tcp          nicname
re-mail-ck      50/tcp                          # Remote Mail Checking Protocol
re-mail-ck      50/udp                          # Remote Mail Checking Protocol
domain          53/tcp          nameserver      # name-domain server
domain          53/udp          nameserver
mtp             57/tcp                          # deprecated
bootps          67/tcp                          # BOOTP server
bootps          67/udp
bootpc          68/tcp                          # BOOTP client
bootpc          68/udp
tftp            69/udp
gopher          70/tcp                          # Internet Gopher
gopher          70/udp
rje             77/tcp          netrjs
finger          79/tcp
www             80/tcp          http            # WorldWideWeb HTTP
www             80/udp                          # HyperText Transfer Protocol
link            87/tcp          ttylink
kerberos        88/tcp          kerberos5 krb5  # Kerberos v5
kerberos        88/udp          kerberos5 krb5  # Kerberos v5
supdup          95/tcp
# 100 - reserved
hostnames       101/tcp         hostname        # usually from sri-nic
iso-tsap        102/tcp         tsap            # part of ISODE.
csnet-ns        105/tcp         cso-ns          # also used by CSO name server
csnet-ns        105/udp         cso-ns
rtelnet         107/tcp                         # Remote Telnet
rtelnet         107/udp
pop-2           109/tcp         postoffice      # POP version 2
pop-2           109/udp
pop-3           110/tcp                         # POP version 3
pop-3           110/udp
sunrpc          111/tcp         portmapper      # RPC 4.0 portmapper TCP
sunrpc          111/udp         portmapper      # RPC 4.0 portmapper UDP
auth            113/tcp         authentication tap ident
sftp            115/tcp
uucp-path       117/tcp
nntp            119/tcp         readnews untp   # USENET News Transfer Protocol
ntp             123/tcp
ntp             123/udp                         # Network Time Protocol
netbios-ns      137/tcp                         # NETBIOS Name Service
netbios-ns      137/udp
netbios-dgm     138/tcp                         # NETBIOS Datagram Service
netbios-dgm     138/udp
netbios-ssn     139/tcp                         # NETBIOS session service
netbios-ssn     139/udp
imap2           143/tcp                         # Interim Mail Access Proto v2
imap2           143/udp
snmp            161/udp                         # Simple Net Mgmt Proto
snmp-trap       162/udp         snmptrap        # Traps for SNMP
cmip-man        163/tcp                         # ISO mgmt over IP (CMOT)
cmip-man        163/udp
cmip-agent      164/tcp
cmip-agent      164/udp
xdmcp           177/tcp                         # X Display Mgr. Control Proto
xdmcp           177/udp
nextstep        178/tcp         NeXTStep NextStep       # NeXTStep window
nextstep        178/udp         NeXTStep NextStep       # server
bgp             179/tcp                         # Border Gateway Proto.
bgp             179/udp
prospero        191/tcp                         # Cliff Neuman's Prospero
prospero        191/udp
irc             194/tcp                         # Internet Relay Chat
irc             194/udp
smux            199/tcp                         # SNMP Unix Multiplexer
smux            199/udp
at-rtmp         201/tcp                         # AppleTalk routing
at-rtmp         201/udp
at-nbp          202/tcp                         # AppleTalk name binding
at-nbp          202/udp
at-echo         204/tcp                         # AppleTalk echo
at-echo         204/udp
at-zis          206/tcp                         # AppleTalk zone information
at-zis          206/udp
z3950           210/tcp         wais            # NISO Z39.50 database
z3950           210/udp         wais
ipx             213/tcp                         # IPX
ipx             213/udp
imap3           220/tcp                         # Interactive Mail Access
imap3           220/udp                         # Protocol v3
ulistserv       372/tcp                         # UNIX Listserv
ulistserv       372/udp
#
# UNIX specific services
#
exec            512/tcp
biff            512/udp         comsat
login           513/tcp
who             513/udp         whod
shell           514/tcp         cmd             # no passwords used
syslog          514/udp
printer         515/tcp         spooler         # line printer spooler
talk            517/udp
ntalk           518/udp
route           520/udp         router routed   # RIP
timed           525/udp         timeserver
tempo           526/tcp         newdate
courier         530/tcp         rpc
conference      531/tcp         chat
netnews         532/tcp         readnews
netwall         533/udp                         # -for emergency broadcasts
uucp            540/tcp         uucpd           # uucp daemon
remotefs        556/tcp         rfs_server rfs  # Brunhoff remote filesystem
klogin          543/tcp                         # Kerberized `rlogin' (v5)
kshell          544/tcp         krcmd           # Kerberized `rsh' (v5)
kerberos-adm    749/tcp                         # Kerberos `kadmin' (v5)
#
webster         765/tcp                         # Network dictionary
webster         765/udp
#
# From «Assigned Numbers»:
#
#&#62; The Registered Ports are not controlled by the IANA and on most systems
#&#62; can be used by ordinary user processes or programs executed by ordinary
#&#62; users.
#
#&#62; Ports are used in the TCP [45,106] to name the ends of logical
#&#62; connections which carry long term conversations.  For the purpose of
#&#62; providing services to unknown callers, a service contact port is
#&#62; defined.  This list specifies the port used by the server process as its
#&#62; contact port.  While the IANA can not control use of these ports it
#&#62; does register or list use of these ports as a convienence to the
#&#62; community.
#
ingreslock      1524/tcp
ingreslock      1524/udp
prospero-np     1525/tcp                # Prospero non-privileged
prospero-np     1525/udp
rfe             5002/tcp                # Radio Free Ethernet
rfe             5002/udp                # Actually use UDP only
bbs             7000/tcp                # BBS service
#
#
# Kerberos (Project Athena/MIT) services
# Note that these are for Kerberos v4 and are unofficial.  Sites running
# v4 should uncomment these and comment out the v5 entries above.
#
kerberos4       750/udp         kdc     # Kerberos (server) udp
kerberos4       750/tcp         kdc     # Kerberos (server) tcp
kerberos_master 751/udp                 # Kerberos authentication
kerberos_master 751/tcp                 # Kerberos authentication
passwd_server   752/udp                 # Kerberos passwd server
krb_prop        754/tcp                 # Kerberos slave propagation
krbupdate       760/tcp         kreg    # Kerberos registration
kpasswd         761/tcp         kpwd    # Kerberos "passwd"
kpop            1109/tcp                # Pop with Kerberos
knetd           2053/tcp                # Kerberos de-multiplexor
zephyr-srv      2102/udp                # Zephyr server
zephyr-clt      2103/udp                # Zephyr serv-hm connection
zephyr-hm       2104/udp                # Zephyr hostmanager
eklogin         2105/tcp                # Kerberos encrypted rlogin
#
# Unofficial but necessary (for NetBSD) services
#
supfilesrv      871/tcp                 # SUP server
supfiledbg      1127/tcp                # SUP debugging
#
# Datagram Delivery Protocol services
#
rtmp            1/ddp                   # Routing Table Maintenance Protocol
nbp             2/ddp                   # Name Binding Protocol
echo            4/ddp                   # AppleTalk Echo Protocol
zip             6/ddp                   # Zone Information Protocol
#
# Debian GNU/Linux services
rmtcfg          1236/tcp                # Gracilis Packeten remote config server
xtel            1313/tcp                # french minitel
cfinger         2003/tcp                # GNU Finger
postgres        4321/tcp                # POSTGRES
mandelspawn     9359/udp        mandelbrot      # network mandelbrot

# Local services
</screen>

</para>

<para>
En el día a día, este fichero se encuentra en proceso de continuo crecimiento
según se van creando nuevos servicios. Si piensa que su copia es incompleta, le
sugiero que haga una copia del <literal remap="tt">/etc/services</literal> de una distribución
reciente.
</para>

</sect4>

</sect3>

<sect3>
<title><literal remap="tt">/etc/inetd.conf</literal></title>

<para>
<literal remap="tt">/etc/inetd.conf</literal> es el fichero de configuración para el demonio
servidor <literal remap="tt">inetd</literal>. Su función es la de almacenar la información relativa a lo
que <literal remap="tt">inetd</literal> debe hacer cuando recibe una petición de conexión a un servicio
en particular. Para cada servicio que desee que acepte conexiones deberá
decirle a <literal remap="tt">inetd</literal> qué demonio servidor de red ejecutar, y cómo ha de
hacerlo.
</para>

<para>
Su formato también es relativamente sencillo. Es un fichero de texto en el
que cada línea describe un servicio que desee proporcionar. Cualquier
texto en una línea que siga a <literal remap="tt">#</literal> es ignorado y se considera un
comentario.  Cada línea contiene siete campos separados por cualquier número de
espacios en blanco (espacio o tabulador). El formato general es el siguiente:
</para>

<para>

<screen>
servicio  tipo_socket  proto  flags  usuario  servidor  argumentos 
</screen>

</para>

<para>
<variablelist>

<varlistentry>
<term>servicio</term>
<listitem>
<para>
es el servicio correspondiente a esta configuración, tomado
del fichero <literal remap="tt">/etc/services</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>tipo_socket</term>
<listitem>
<para>
describe el tipo de socket que esta entrada considerará
relevante. Los valores permitidos son: <literal remap="tt">stream</literal>, <literal remap="tt">dgram</literal>, <literal remap="tt">raw</literal>,
<literal remap="tt">rdm</literal> o <literal remap="tt">seqpacket</literal>.  Es un poco técnico por naturaleza, pero por regla
general casi todos los servicios basados en <literal remap="tt">tcp</literal> usan <literal remap="tt">stream</literal>, y casi
todos los basados en <literal remap="tt">udp</literal> usan <literal remap="tt">dgram</literal>. Sólo algunos demonios servidores
muy particulares usarán otros valores.
</para>
</listitem></varlistentry>
<varlistentry>
<term>proto</term>
<listitem>
<para>
el protocolo considerado válido para este servicio. Debería
corresponder con la entrada apropiada en el fichero <literal remap="tt">/etc/services</literal> y
suele ser <literal remap="tt">tcp</literal> o <literal remap="tt">udp</literal>.  Los servidores basados en Sun RPC (<emphasis remap="it">Remote
Procedure Call</emphasis>) usarán <literal remap="tt">rpc/tcp</literal> o <literal remap="tt">rpc/udp</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>flags</term>
<listitem>
<para>
sólo hay dos valores posibles. Este campo le dice a <emphasis>inetd</emphasis>
si el programa servidor de red libera el socket después de comenzar la
ejecución, y si por tanto <literal remap="tt">inetd</literal> podrá ejecutar otro servidor para la
siguiente petición de conexión, o si <literal remap="tt">inetd</literal> deberá esperar y asumir que el
demonio servidor que esté ejecutándose controlará las nuevas peticiones de
conexión. Esto tiene su dificultad, pero por norma general todos los servidores
<literal remap="tt">tcp</literal> deberían tener esta entrada con el valor <literal remap="tt">nowait</literal> y la mayoría de
servidores <literal remap="tt">udp</literal> deberían tener <literal remap="tt">wait</literal>.  De todas maneras hay algunas
excepciones notables, por lo que debería leer la guía de ejemplo si no está
seguro.
</para>
</listitem></varlistentry>
<varlistentry>
<term>usuario</term>
<listitem>
<para>
este campo indica qué cuenta de usuario de
<literal remap="tt">/etc/passwd</literal> será asignada como dueña del demonio de red cuando se
ejecute. Esto es a menudo útil si quiere protegerse ante riesgos de seguridad.
Puede asignar el usuario <literal remap="tt">nobody</literal> a una entrada, por lo que si la seguridad
del servidor de red es traspasada el posible daño queda minimizado.
Habitualmente, sin embargo, este campo está asignado a <literal remap="tt">root</literal>, porque muchos
servidores requieren privilegios de administrador para funcionar correctamente.
</para>
</listitem></varlistentry>
<varlistentry>
<term>servidor</term>
<listitem>
<para>
este campo es el camino completo hasta el programa servidor
a ejecutar para esta entrada.
</para>
</listitem></varlistentry>
<varlistentry>
<term>argumentos</term>
<listitem>
<para>
este campo comprende el resto de la línea de órdenes y es
opcional. Es en donde se pone cualquier argumento de línea de órdenes que desee
pasar al programa demonio servidor cuando es ejecutado.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<sect4>
<title>Un ejemplo de <literal remap="tt">/etc/inetd.conf</literal></title>

<para>
Al igual que pasa con el <literal remap="tt">/etc/services</literal>, todas las distribuciones
modernas incluirán un buen fichero <literal remap="tt">/etc/inetd.conf</literal> para trabajar con
él.  Aquí incluyo, como ejemplo, el fichero <literal remap="tt">/etc/inetd.conf</literal> de la
distribución Debian <literal remap="tt"><ulink
url="http://www.debian.org/"
>http://www.debian.org</ulink
></literal>.
</para>

<para>

<screen>
# /etc/inetd.conf:  see inetd(8) for further informations.
#
# Internet server configuration database
#
#
# Modified for Debian by Peter Tobias &#60;tobias@et-inf.fho-emden.de&#62;
#
# &#60;service_name&#62; &#60;sock_type&#62; &#60;proto&#62; &#60;flags&#62; &#60;user&#62; &#60;server_path&#62; &#60;args&#62;
#
# Internal services
#
#echo           stream  tcp     nowait  root    internal
#echo           dgram   udp     wait    root    internal
discard         stream  tcp     nowait  root    internal
discard         dgram   udp     wait    root    internal
daytime         stream  tcp     nowait  root    internal
daytime         dgram   udp     wait    root    internal
#chargen        stream  tcp     nowait  root    internal
#chargen        dgram   udp     wait    root    internal
time            stream  tcp     nowait  root    internal
time            dgram   udp     wait    root    internal
#
# These are standard services.
#
telnet  stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.telnetd
ftp     stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.ftpd
#fsp    dgram   udp     wait    root    /usr/sbin/tcpd  /usr/sbin/in.fspd
#
# Shell, login, exec and talk are BSD protocols.
#
shell   stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rshd
login   stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rlogind
#exec   stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rexecd
talk    dgram   udp     wait    root    /usr/sbin/tcpd  /usr/sbin/in.talkd
ntalk   dgram   udp     wait    root    /usr/sbin/tcpd  /usr/sbin/in.ntalkd
#
# Mail, news and uucp services.
#
smtp    stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.smtpd
#nntp   stream  tcp     nowait  news    /usr/sbin/tcpd  /usr/sbin/in.nntpd
#uucp   stream  tcp     nowait  uucp    /usr/sbin/tcpd  /usr/lib/uucp/uucico
#comsat dgram   udp     wait    root    /usr/sbin/tcpd  /usr/sbin/in.comsat
#
# Pop et al
#
#pop-2  stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.pop2d
#pop-3  stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.pop3d
#
# `cfinger' is for the GNU finger server available for Debian.  (NOTE: The
# current implementation of the `finger' daemon allows it to be run as `root'.)
#
#cfinger stream tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.cfingerd
#finger stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.fingerd
#netstat        stream  tcp     nowait  nobody  /usr/sbin/tcpd  /bin/netstat
#systat stream  tcp     nowait  nobody  /usr/sbin/tcpd  /bin/ps -auwwx
#
# Tftp service is provided primarily for booting.  Most sites
# run this only on machines acting as "boot servers."
#
#tftp   dgram   udp     wait    nobody  /usr/sbin/tcpd  /usr/sbin/in.tftpd
#tftp   dgram   udp     wait    nobody  /usr/sbin/tcpd  /usr/sbin/in.tftpd /boot
#bootps dgram   udp     wait    root    /usr/sbin/bootpd        bootpd -i -t 120
#
# Kerberos authenticated services (these probably need to be corrected)
#
#klogin         stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rlogind -k
#eklogin        stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rlogind -k -x
#kshell         stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rshd -k
#
# Services run ONLY on the Kerberos server (these probably need to be corrected)
#
#krbupdate      stream tcp      nowait  root    /usr/sbin/tcpd  /usr/sbin/registerd
#kpasswd        stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/kpasswdd
#
# RPC based services
#
#mountd/1       dgram   rpc/udp wait    root    /usr/sbin/tcpd  /usr/sbin/rpc.mountd
#rstatd/1-3     dgram   rpc/udp wait    root    /usr/sbin/tcpd  /usr/sbin/rpc.rstatd
#rusersd/2-3    dgram   rpc/udp wait    root    /usr/sbin/tcpd  /usr/sbin/rpc.rusersd
#walld/1        dgram   rpc/udp wait    root    /usr/sbin/tcpd  /usr/sbin/rpc.rwalld
#
# End of inetd.conf.
ident           stream  tcp     nowait  nobody  /usr/sbin/identd        identd -i
</screen>

</para>

</sect4>

</sect3>

</sect2>

<sect2>
<title>Otros ficheros de configuración relacionados con la red</title>

<para>
Hay varios ficheros misceláneos relacionados con la configuración de la red en
Linux por los que podría estar interesado. Nunca debería tener que modificar
estos ficheros, pero merece la pena describirlos para que sepa lo que contienen
y para qué son.
</para>

<sect3>
<title><literal remap="tt">/etc/protocols</literal></title>

<para>
El fichero <literal remap="tt">/etc/protocols</literal> es una base de datos que correlaciona
números de identificación de protocolos con sus nombres. Esto lo usan los
programadores para especificar protocolos por su nombre en sus programas y
también por programas como <literal remap="tt">tcpdump</literal> para mostrar nombres en lugar de
números en su salida. En general la sintaxis del fichero es:
</para>

<para>

<screen>
nombredelprotocolo  número  sobrenombres
</screen>

</para>

<para>
El fichero <literal remap="tt">/etc/protocols</literal> proporcionado con la distribución Debian
<literal remap="tt"><ulink
url="http://www.debian.org/"
>http://www.debian.org</ulink
></literal> es
como sigue:
</para>

<para>

<screen>
# /etc/protocols:
# $Id: Redes-En-Linux-Como.xml,v 1.1.1.2 2003/12/10 09:48:56 pfabrega Exp $
#
# Internet (IP) protocols
#
#       from: @(#)protocols     5.1 (Berkeley) 4/17/89
#
# Updated for NetBSD based on RFC 1340, Assigned Numbers (July 1992).

ip      0       IP              # internet protocol, pseudo protocol number
icmp    1       ICMP            # internet control message protocol
igmp    2       IGMP            # Internet Group Management
ggp     3       GGP             # gateway-gateway protocol
ipencap 4       IP-ENCAP        # IP encapsulated in IP (officially «IP»)
st      5       ST              # ST datagram mode
tcp     6       TCP             # transmission control protocol
egp     8       EGP             # exterior gateway protocol
pup     12      PUP             # PARC universal packet protocol
udp     17      UDP             # user datagram protocol
hmp     20      HMP             # host monitoring protocol
xns-idp 22      XNS-IDP         # Xerox NS IDP
rdp     27      RDP             # "reliable datagram" protocol
iso-tp4 29      ISO-TP4         # ISO Transport Protocol class 4
xtp     36      XTP             # Xpress Tranfer Protocol
ddp     37      DDP             # Datagram Delivery Protocol
idpr-cmtp       39      IDPR-CMTP       # IDPR Control Message Transport
rspf    73      RSPF            # Radio Shortest Path First.
vmtp    81      VMTP            # Versatile Message Transport
ospf    89      OSPFIGP         # Open Shortest Path First IGP
ipip    94      IPIP            # Yet Another IP encapsulation
encap   98      ENCAP           # Yet Another IP encapsulation
</screen>

</para>

</sect3>

<sect3>
<title><literal remap="tt">/etc/networks</literal></title>

<para>
El fichero <literal remap="tt">/etc/networks</literal> tiene una función similar a la del fichero
<literal remap="tt">/etc/hosts</literal>. Proporciona una base de datos sencilla de nombres de red y
direcciones de red. Su formato difiere en que sólo puede haber dos campos por
línea y los campos están codificados así:
</para>

<para>

<screen>
nombredelared direccióndered
</screen>

</para>

<para>
Un ejemplo podría ser:
</para>

<para>

<screen>
loopnet    127.0.0.0
localnet   192.168.0.0
amprnet    44.0.0.0
</screen>

</para>

<para>
Cuando use órdenes como <literal remap="tt">route</literal>, si un destino es una red y la red tiene una
entrada en el fichero /etc/networks entonces route mostrará el nombre de la red
en lugar de su dirección.
</para>

</sect3>

</sect2>

<sect2>
<title>Seguridad en la red y control de acceso.</title>

<para>
Déjeme empezar esta sección advirtiendo que la seguridad de su máquina y red
ante ataques maliciosos es un arte complejo. No me considero un experto en este
campo y aunque los mecanismos que voy a describir puedan ayudar, si quiere
tomarse en serio la seguridad entonces le recomiendo que investigue un poco en
el tema. Hay algunas buenas referencias en Internet relacionadas con la
seguridad, incluido el <emphasis remap="it">Security HOWTO</emphasis> (Dispone de una  traducción en
<literal remap="tt"><ulink
url="http://www.insflug.org/documentos/Seguridad-Como/"
>http://www.insflug.org/documentos/Seguridad-Como/</ulink
></literal>.
</para>

<para>
Una regla general importante es: <emphasis remap="bf">No ejecute servicios que no tenga
intención de usar</emphasis>'.  Muchas distribuciones vienen configuradas con todo
tipo de servicios que se inician automáticamente. Para asegurar un nivel mínimo
de seguridad debería examinar el fichero <literal remap="tt">/etc/inetd.conf</literal> y comentar
(<emphasis>poner un <literal remap="tt">#</literal> al inicio de la línea</emphasis>) de toda declaración de
servicio que no vaya a usar. Buenos candidatos son: <literal remap="tt">shell</literal>, <literal remap="tt">exec</literal>,
<literal remap="tt">uucp</literal>, <literal remap="tt">ftp</literal> y servicios de información como <literal remap="tt">finger</literal>, <literal remap="tt">netstat</literal> y
<literal remap="tt">systat</literal>.
</para>

<para>
Hay todo tipo de mecanismos de seguridad y control de acceso, describiré
los más elementales.
</para>

<sect3>
<title><literal remap="tt">/etc/ftpusers</literal></title>

<para>
El fichero <literal remap="tt">/etc/ftpusers</literal> es un mecanismo sencillo que le permite
denegar la entrada a ciertos usuarios mediante FTP. El fichero
<literal remap="tt">/etc/ftpusers</literal> lo lee el programa demonio de FTP (<literal remap="tt">ftpd</literal>) cuando se
recibe una conexión FTP. El fichero es una simple lista de aquellos usuarios
que no tienen permitido el acceso. Puede parecerse a esto:
</para>

<para>

<screen>
# /etc/ftpusers - users not allowed to login via ftp
root
uucp
bin
mail
</screen>

</para>

</sect3>

<sect3>
<title><literal remap="tt">/etc/securetty</literal></title>

<para>
El fichero <literal remap="tt">/etc/securetty</literal> permite especificar qué dispositivos
<literal remap="tt">tty</literal> puede usar <literal remap="tt">root</literal> para identificarse en el sistema. El fichero
<literal remap="tt">/etc/securetty</literal> es leído por el programa de acceso (normalmente
<literal remap="tt">/etc/login</literal>). Su formato es una lista de los nombres de dispositivos
<literal remap="tt">tty</literal> permitidos, en todos los demás <literal remap="tt">root</literal> tiene prohibida la entrada:
</para>

<para>

<screen>
# /etc/securetty - tty's on which root is allowed to login
tty1
tty2
tty3
tty4
</screen>

</para>

</sect3>

<sect3>
<title>El mecanismo de control de acceso <emphasis remap="it">hosts</emphasis> de <literal remap="tt">tcpd</literal></title>

<para>
El programa <literal remap="tt">tcpd</literal> que ha visto listado en el fichero
<literal remap="tt">/etc/inetd.conf</literal> proporciona mecanismos de control de registro y acceso
a los servicios que haya de proteger.
</para>

<para>
Cuando es invocado por el programa <literal remap="tt">inetd</literal> lee dos ficheros que
contienen reglas de acceso y que permiten o deniegan acceso al servidor que
está protegiendo.
</para>

<para>
Mirará en los ficheros de reglas hasta que encuentre la primera
correspondencia. Si no se encuentran correspondencias asume que el acceso
debería estar permitido para todo el mundo. La secuencia de archivos que revisa
es: <literal remap="tt">/etc/hosts.allow</literal>, <literal remap="tt">/etc/hosts.deny</literal>. Describiré cada uno de
estos en seguida. Para una descripción completa de este servicio debería
referirse a las páginas del manual apropiadas (<literal remap="tt">hosts_access</literal> (5) es un buen
punto de partida).
</para>

<sect4>
<title><literal remap="tt">/etc/hosts.allow</literal></title>

<para>
El <literal remap="tt">/etc/hosts.allow</literal> es un fichero de configuración del programa
<literal remap="tt">/usr/sbin/tcpd</literal>. El fichero <literal remap="tt">hosts.allow</literal> contiene reglas que
describen qué máquinas tienen permiso para acceder a un servicio en la suya.
</para>

<para>
El formato del fichero es bastante sencillo:
</para>

<para>

<screen>
# /etc/hosts.allow
#
# &#60;lista de servicios&#62;: &#60;lista de hosts&#62; [: orden]
</screen>

</para>

<para>
<variablelist>

<varlistentry>
<term><literal remap="tt">lista de servicios</literal> </term>
<listitem>
<para>
es una lista delimitada por comas de nombres
de servidores a los que se aplica esta regla.  Ejemplos de nombre de servicio
son: <literal remap="tt">ftpd</literal>, <literal remap="tt">telnetd</literal> y <literal remap="tt">fingerd</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term><literal remap="tt">lista de hosts</literal> </term>
<listitem>
<para>
es una lista de nombres de máquinas, delimitada
por comas. Aquí también puede usar direcciones IP. De forma adicional, puede
especificar nombres de máquinas o direcciones usando caracteres comodín para
corresponder con grupos de máquinas. Por ejemplo: <literal remap="tt">gw.vk2ktj.ampr.org</literal> para
una máquina específica, <literal remap="tt">.uts.edu.au</literal> para cualquier nombre de máquina que
acabe en esa cadena, <literal remap="tt">44.</literal> para cualquier dirección IP que comience con esos
dígitos. Hay algunas palabras especiales para simplificar la configuración,
algunas de las cuales son:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">ALL</literal>, que se corresponde con cualquier host. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">LOCAL</literal> se corresponde con cualquier nombre de host que no contenga un
<literal remap="tt">.</literal> o sea que esté en el mismo dominio que su máquina;

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">PARANOID</literal> se corresponde con cualquier nombre que no se corresponda
con esta dirección (name spoofing). Hay una última palabra que también es útil.
La palabra 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">EXCEPT</literal> permite proporcionar una lista con excepciones. Esto lo
cubriremos en un capítulo posterior.
</para>
</listitem>

</itemizedlist>

</para>
</listitem></varlistentry>
<varlistentry>
<term><literal remap="tt">orden</literal></term>
<listitem>
<para>
es un parámetro opcional. Este parámetro es el camino
completo hasta una orden que debería ser ejecutada cada vez que se cumpla esta
regla. Podría por ejemplo ejecutar una instrucción que intentase identificar
quién está autenticado en el host que conecta, o generar un mensaje de correo u
otro tipo de alerta a un administrador de sistema avisando de que alguien
intenta conectar. Hay cierto número de expansiones que podríamos incluir,
algunos ejemplos comunes son: <literal remap="tt">%h</literal> se expande al nombre de la máquina
que se conecta o a su dirección si no tiene un nombre, <literal remap="tt">%d</literal> es el
demonio que está siendo llamado.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Un ejemplo:
</para>

<para>

<screen>
# /etc/hosts.allow
#
# Permitir correo a todo el mundo
in.smtpd: ALL
# Todo telnet y FTP sólo a hosts dentro de mi dominio y el host que tengo
# en caso
telnetd, ftpd: LOCAL, myhost.athome.org.au
# Permitir finger a cualquiera pero mantener un registro de quién es.
fingerd: ALL: (finger @%h | mail -s "finger desde %h" root)
</screen>

</para>

</sect4>

<sect4>
<title><literal remap="tt">/etc/hosts.deny</literal></title>

<para>
El fichero <literal remap="tt">/etc/hosts.deny</literal> es un fichero de configuración del
programa <literal remap="tt">/usr/sbin/tcpd</literal>. El fichero <literal remap="tt">hosts.deny</literal> contiene
reglas que describen qué máquinas tienen <emphasis>prohibido</emphasis> el acceso a
un servicio en su máquina.
</para>

<para>
Un ejemplo simple podría parecerse a esto:
</para>

<para>

<screen>
# /etc/hosts.deny
#
# Desautorizar a todos los host con nombre sospechoso
ALL: PARANOID
#
# Desautorizar a todos los host.
ALL: ALL
</screen>

</para>

<para>
La entrada <literal remap="tt">PARANOID</literal> es redundante porque la otra entrada abarca todo
en cualquier caso. Ambas entradas serían razonables por defecto dependiendo de
sus requisitos particulares.
</para>

<para>
La configuración más segura es tener <literal remap="tt">ALL: ALL</literal> por defecto en 
<literal remap="tt">/etc/hosts.deny</literal> para después dar permiso específicamente a aquellos
servicios y hosts que se desee en <literal remap="tt">/etc/hosts.allow</literal>.
</para>

</sect4>

</sect3>

<sect3>
<title><literal remap="tt">/etc/hosts.equiv</literal></title>

<para>
El fichero <literal remap="tt">hosts.equiv</literal> se usa para garantizar a ciertos hosts y
usuarios derechos de acceso a cuentas en su máquina sin que tenga que
proporcionar una clave. Esto es útil en un entorno seguro donde controle todas
las máquinas, pero en otro caso es un peligro para la seguridad. Su máquina es
sólo tan segura como la menos segura de aquellas en las que confíe.  Para
maximizar la seguridad, no use este mecanismo, y anime a sus usuarios para que
tampoco usen ficheros <literal remap="tt">.rhost</literal>.
</para>

</sect3>

<sect3>
<title>Configure su demonio de ftp adecuadamente.</title>

<para>
Muchos servidores estarán interesados en ejecutar un demonio de <emphasis>FTP</emphasis>
anónimo para permitir a otras personas que subir y descargar ficheros sin
necesidad de un <emphasis remap="it">userid</emphasis> específico. Si decide ofrecer este servicio
asegúrese de que configura el demonio de <emphasis>ftp</emphasis> apropiadamente para acceso
anónimo. La mayoría de las páginas de <literal remap="tt">ftpd(8)</literal> describen cómo hacerlo.
Debería asegurarse siempre de que sigue estas instrucciones. Una cosa
importante es no usar una copia de su fichero <literal remap="tt">/etc/passwd</literal> habitual en
el directorio <literal remap="tt">/etc</literal> de la cuenta anónima; asegúrese de que elimina
todos los detalles sobre las cuentas excepto aquellos que deba tener, ya que en
otro caso será vulnerable a las técnicas de adquisición de claves por fuerza
bruta.
</para>

</sect3>

<sect3>
<title>Cortafuegos para redes.</title>

<para>
Un excelente medio de seguridad es no permitir que los datagramas lleguen
siquiera a su máquina o servidores. Esto lo cubre en profundidad el
<literal remap="tt"><ulink
url="http://www.insflug.org/documentos/Cortafuegos-Como/"
>http://www.insflug.org/documentos/Cortafuegos-Como/</ulink
></literal> y, más
concisamente, la última sección de este documento.
</para>

</sect3>

<sect3>
<title>Otras sugerencias.</title>

<para>
Hay otras sugerencias, que debería considerar, pero que realmente son
cuestión de cada uno.
</para>

<para>
<variablelist>

<varlistentry>
<term>sendmail</term>
<listitem>
<para>
a pesar de su popularidad, el demonio <emphasis>sendmail</emphasis> aparece
con preocupante regularidad en los anuncios de alerta de seguridad. Usted
decides, pero yo elijo no ejecutarlo.
</para>
</listitem></varlistentry>
<varlistentry>
<term>NFS y otros servicios Sun RPC</term>
<listitem>
<para>
tenga cuidado con estos. Hay todo tipo
de posibles formas de explotar estos servicios. Es difícil de encontrar una
opción a los servicios NFS, y si decide usarlos, asegúrese de que es cuidadoso
con los permisos que da al configurarlo.
</para>
</listitem></varlistentry>
</variablelist>
</para>

</sect3>

</sect2>

</sect1>

<sect1 id="IP-y-Ethernet">
<title>Información relacionada con IP y Ethernet
</title>

<para>
Esta sección cubre la información específica a Ethernet e IP. Estas
subsecciones han sido agrupadas juntas debido a que pienso que son las más
interesante dentro de la que previamente se llamó sección de «Tecnología
Específica». Cualquiera que tenga una LAN se beneficiará de esta parte.
</para>

<sect2>
<title>Ethernet</title>

<para>
Los dispositivos Ethernet son <literal remap="tt">eth0</literal>, <literal remap="tt">eth1</literal>, <literal remap="tt">eth2</literal>, etc.  A la
primera tarjeta detectada por el núcleo se le asigna <literal remap="tt">eth0</literal> y al resto se
les asigna secuencialmente en el orden en que sean detectadas.
</para>

<para>
Por defecto, el núcleo de Linux sólo intenta buscar una tarjeta de red, por lo
que tendrá que pasarle algunos parámetros para forzar la detección de las
demás.
</para>

<para>
Para aprender cómo hacer trabajar una tarjeta Ethernet bajo Linux debería
acudir al Ethernet Howto, <literal remap="tt"><ulink
url="Ethernet-HOWTO.html"
>Ethernet-HOWTO.html</ulink
></literal>.
</para>

<para>
Una vez que tenga el núcleo compilado para reconocer su tarjeta Ethernet,
configurar la tarjeta es sencillo.
</para>

<para>
Normalmente debería hacer algo como:
</para>

<para>

<screen>
root# ifconfig eth0 192.168.0.1 netmask 255.255.255.0 up
root# route add -net 192.168.0.0 netmask 255.255.255.0 eth0
</screen>

</para>

<para>
La mayoría de los controladores Ethernet fueron desarrollados por Donald
Becker, <literal remap="tt"><ulink
url="mailto:becker@CESDIS.gsfc.nasa.gov"
>becker@CESDIS.gsfc.nasa.gov</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>EQL - ecualizador de tráfico para líneas múltiples</title>

<para>
El nombre del dispositivo EQL es <literal remap="tt">eql</literal>. Con las fuentes estándar del núcleo
sólo podrá tener un dispositivo EQL por máquina. EQL proporciona un medio para
utilizar múltiples líneas punto a punto como un solo enlace PPP, slip o PLIP
lógico para llevar tcp/ip. A menudo es más barato usar varias líneas de baja
velocidad que tener una sola línea de alta velocidad.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
Network device support  ---&#62;
  [*] Network device support
  &#60;*&#62; EQL (serial line load balancing) support
 
</screen>

</para>

<para>
Para poder usar este mecanismo la máquina en el otro extremo de la línea debe
admitirlo también. Linux, Livingstone Portmasters y los nuevos servidores
dial-in soportan servicios compatibles.
</para>

<para>
Para configurar EQL necesitará las herramientas eql que están disponibles en
<literal remap="tt"><ulink
url="ftp://metalab.unc.edu/pub/linux/system/Serial/eql-1.2.tar.gz"
>ftp://metalab.unc.edu/pub/linux/system/Serial/eql-1.2.tar.gz</ulink
></literal>.
</para>

<para>
La configuración es bastante directa. Se comienza por la interfaz eql.  La
interfaz es exactamente como la de cualquier otro dispositivo de red. La
dirección IP y mtu se configura usando <literal remap="tt">ifconfig</literal>, con algo como:
</para>

<para>

<screen>
root# ifconfig eql 192.168.10.1 mtu 1006
</screen>

</para>

<para>
Lo siguiente que se necesita es iniciar manualmente cada una de las líneas que
se vayan a usar. Esta puede ser cualquier combinación de dispositivos de red
punto a punto. Cómo iniciar las conexiones depende del tipo de enlace que sea,
por lo que ha de mirar las secciones apropiadas para más información.
</para>

<para>
Finalmente necesitará asociar el enlace serie con el dispositivo EQL, esto se
llama «esclavizar» y se hace con la orden <literal remap="tt">eql_enslave</literal> como se ve en el
ejemplo:
</para>

<para>

<screen>
root# eql_enslave eql sl0 28800
root# eql_enslave eql ppp0 14400
</screen>

</para>

<para>
El parámetro <emphasis>velocidad estimada</emphasis> que se da a <literal remap="tt">eql_enslave</literal> no hace
nada directamente. Lo usa el controlador (<emphasis remap="it">driver</emphasis>) EQL para determinar qué
parte de los datagramas va a recibir cada dispositivo, para así afinar el
balance de las líneas jugando con este valor.
</para>

<para>
Para disociar una línea de un dispositivo EQL use <literal remap="tt">eql_emancipate</literal> de esta
manera:
</para>

<para>

<screen>
#root eql_emancipate eql sl0
</screen>

</para>

<para>
Puede añadir rutas de la misma manera que para cualquier otro enlace punto a
punto, excepto en que las rutas deben referirse al dispositivo <literal remap="tt">eql</literal> en
lugar de a los verdaderos dispositivos en serie. Normalmente usará:
</para>

<para>

<screen>
root# route add default eql
</screen>

</para>

<para>
El controlador EQL fue desarrollado por Simon Janes, <literal remap="tt"><ulink
url="mailto:simon@ncm.com"
>simon@ncm.com</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>IP Accounting (en Linux 2.0)</title>

<para>
Los servicios de auditoría IP del núcleo de Linux le permiten recolectar y
analizar datos de uso de la red. Los datos recogidos comprenden el número de
paquetes y de bytes acumulados desde que se puso a cero la última vez.  Tiene a
su disposición varias reglas para categorizar estas cifras para que se ajusten
a los propósitos que les vaya a dar. Esta opción ha sido eliminada del núcleo a
partir de la versión <literal remap="tt">2.1.102</literal>, porque el viejo sistema de cortafuegos
basado en <literal remap="tt">ipfwadm</literal> fue reemplazado por <literal remap="tt">ipfwchains</literal>.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
Networking options  ---&#62;
  [*] IP: accounting
 
</screen>

</para>

<para>
Después de que haya compilado e instalado el núcleo necesitará hacer uso
de la orden <literal remap="tt">ipfwadm</literal> para configurar la auditoría de IP. Hay muchas maneras
diferentes de obtener la información de auditoría para elegir.  He creado un
ejemplo sencillo de lo que podría ser útil, pero debería leer la página de
manual de <literal remap="tt">ipfwadm</literal> para obtener más información.
</para>

<para>
Escena: Tenemos una red Ethernet que accede a la Internet mediante un
enlace PPP. En la Ethernet tiene una máquina que ofrece cierta variedad
de servicios y está interesado en saber cuánto tráfico se genera por cada
conexión ftp y http, así como el tráfico total tcp y udp.
</para>

<para>
Podrías usar un conjunto de órdenes que se pareciese a lo siguiente, que
se presenta como guión de ejecución de órdenes (<emphasis remap="it">shell script</emphasis>):
</para>

<para>

<screen>
#!/bin/sh
#
# Borrar las reglas de contabilidad
ipfwadm -A -f
#
# Establecer macros
localnet=44.136.8.96/29
any=0/0
# Agregar reglas para los segmentos de la red local
ipfwadm -A in  -a -P tcp -D $localnet ftp-data
ipfwadm -A out -a -P tcp -S $localnet ftp-data
ipfwadm -A in  -a -P tcp -D $localnet www
ipfwadm -A out -a -P tcp -S $localnet www
ipfwadm -A in  -a -P tcp -D $localnet
ipfwadm -A out -a -P tcp -S $localnet
ipfwadm -A in  -a -P udp -D $localnet
ipfwadm -A out -a -P udp -S $localnet
#
# Reglas por defecto
ipfwadm -A in  -a -P tcp -D $any ftp-data
ipfwadm -A out -a -P tcp -S $any ftp-data
ipfwadm -A in  -a -P tcp -D $any www
ipfwadm -A out -a -P tcp -S $any www
ipfwadm -A in  -a -P tcp -D $any
ipfwadm -A out -a -P tcp -S $any
ipfwadm -A in  -a -P udp -D $any
ipfwadm -A out -a -P udp -S $any
#
# Mostrar las reglas
ipfwadm -A -l -n
#
</screen>

</para>

<para>
Los nombres <literal remap="tt">ftp-data</literal> y <literal remap="tt">www</literal> se refieren a líneas en
<literal remap="tt">/etc/services</literal>. La última orden da una lista de cada una de las reglas
de auditoría y muestra los totales obtenidos.
</para>

<para>
Una cosa importante a tener en cuenta cuando analizamos IP accounting es que
<emphasis remap="bf">los totales de todas las reglas que se han cumplido se han incrementado</emphasis>,
por tanto para obtener las diferencias tendrá que hacer los cálculos
apropiados. Por ejemplo, si quiero saber cuantos datos no fueron de ftp, ni www
restaré los totales individuales de la regla que se corresponde con todos los
puertos.
</para>

<para>

<screen>
root# ipfwadm -A -l -n
IP accounting rules
 pkts bytes dir prot source               destination          ports
    0     0 in  tcp  0.0.0.0/0            44.136.8.96/29       * -&#62; 20
    0     0 out tcp  44.136.8.96/29       0.0.0.0/0            20 -&#62; *
   10  1166 in  tcp  0.0.0.0/0            44.136.8.96/29       * -&#62; 80
   10   572 out tcp  44.136.8.96/29       0.0.0.0/0            80 -&#62; *
  252 10943 in  tcp  0.0.0.0/0            44.136.8.96/29       * -&#62; *
  231 18831 out tcp  44.136.8.96/29       0.0.0.0/0             * -&#62; *
    0     0 in  udp  0.0.0.0/0            44.136.8.96/29       * -&#62; *
    0     0 out udp  44.136.8.96/29       0.0.0.0/0            * -&#62; *
    0     0 in  tcp  0.0.0.0/0            0.0.0.0/0            * -&#62; 20
    0     0 out tcp  0.0.0.0/0            0.0.0.0/0            20 -&#62; *
   10  1166 in  tcp  0.0.0.0/0            0.0.0.0/0            * -&#62; 80
   10   572 out tcp  0.0.0.0/0            0.0.0.0/0            80 -&#62; *
  253 10983 in  tcp  0.0.0.0/0            0.0.0.0/0            * -&#62; *
  231 18831 out tcp  0.0.0.0/0            0.0.0.0/0            * -&#62; *
    0     0 in  udp  0.0.0.0/0            0.0.0.0/0            * -&#62; *
    0     0 out udp  0.0.0.0/0            0.0.0.0/0            * -&#62; *
</screen>

</para>

</sect2>

<sect2>
<title>IP Accounting (en Linux 2.2)</title>

<para>
El nuevo código para llevar la contabilidad se accede mediante «IP Firewall
Chains». Consulte la página principal de IP chains <literal remap="tt"><ulink
url="http://www.adelaide.net.au/~rustcorp/ipfwchains/ipfwchains.html"
>http://www.adelaide.net.au/~rustcorp/ipfwchains/ipfwchains.html</ulink
></literal> si
desea más información. Entre otras cosas, necesitará usar <literal remap="tt">ipchains</literal> en
lugar de <literal remap="tt">ipfwadm</literal> para configurar sus filtros. (De
<literal remap="tt">Documentation/Changes</literal> en las últimas fuentes del núcleo)
</para>

</sect2>

<sect2>
<title>IP Aliasing</title>

<para>
Hay algunas aplicaciones para las que es útil ser capaz de asignar varias
direcciones IP a un sólo dispositivo de red. Los Proveedores de Servicios de
Internet usan esto a menudo para ofertar a sus usuarios WWW y FTP «a medida».
Puede acudir al <emphasis remap="it">IP-Alias mini-HOWTO</emphasis> si quiere obtener más información de
la que aquí hay.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
Networking options  ---&#62;
   ....
   [*] Network aliasing
   ....
   &#60;*&#62; IP: aliasing support
</screen>

</para>

<para>
Después de compilar e instalar su núcleo con la implementación de IP_Alias, la
configuración es muy sencilla. Los alias se añaden a dispositivos de red
virtuales asociados al verdadero dispositivo de red.  Se aplica una convención
sencilla para dar nombres a estos dispositivos, que es
<literal remap="tt">&lt;nombredisp&#62;:&lt;núm disp virtual&#62;</literal>, por ejemplo <literal remap="tt">eth0:0</literal>,
<literal remap="tt">ppp0:10</literal>, etc. Tenga en cuenta que dispositivo nombre:número sólo se puede
configurar <emphasis>después</emphasis> de haber activado la interfaz principal.
</para>

<para>
Por ejemplo, asumiremos que tiene una red Ethernet que soporta dos redes IP
diferentes simultáneamente y quiere que tu máquina tenga acceso directo a
ambas. Podríamos hacer algo como:
</para>

<para>

<screen>
root# ifconfig eth0 192.168.1.1 netmask 255.255.255.0 up
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0

root# ifconfig eth0:0 192.168.10.1 netmask 255.255.255.0 up
root# route add -net 192.168.10.0 netmask 255.255.255.0 eth0:0
</screen>

</para>

<para>
Para borrar un alias sencillamente añadimos un `<literal remap="tt">-</literal>' al final de su nombre y
nos referimos a él de forma tan sencilla como:
</para>

<para>

<screen>
root# ifconfig eth0:0- 0
</screen>

</para>

<para>
También serán borradas automáticamente todas las rutas asociadas con ese alias.
</para>

</sect2>

<sect2>
<title>IP Firewall (para Linux 2.0)</title>

<para>
Los temas referentes a Cortafuegos IP y al trabajo con Cortafuegos está
cubierto en mayor profundidad en el <literal remap="tt"><ulink
url="http://www.insflug.org/documentos/Cortafuegos-Como/"
>http://www.insflug.org/documentos/Cortafuegos-Como/</ulink
></literal>. Tener un
Cortafuegos IP le permite asegurar su máquina frente a accesos por la red no
autorizados filtrando o permitiendo que entren datagramas de o hacia las
direcciones IP que sean designadas. Hay tres clases diferentes de reglas,
filtrado de entradas (<emphasis remap="it">incoming filtering</emphasis>), filtrado de salidas
(<emphasis remap="it">outgoing filtering</emphasis>) y filtrado de reenvíos (<emphasis remap="it">forwarding filtering</emphasis>).
Las reglas de entradas son aplicadas a los datagramas recibidos en un
dispositivo de red. Las reglas de salidas se aplican a los datagramas que va a
transmitir un dispositivo de red. Las reglas de reenvíos se aplican a
datagramas que se reciben pero que no son para esta máquina, como por ejemplo
datagramas que entran por una interfaz para ser encaminados por otra.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
Networking options  ---&#62;
  [*] Network firewalls
  ....
  [*] IP: forwarding/gatewaying
  ....
  [*] IP: firewalling
  [ ] IP: firewall packet logging
</screen>

</para>

<para>
La configuración de las reglas del cortafuegos IP se realiza usando la
orden <literal remap="tt">ipfwadm</literal>. Como mencioné antes, yo no soy un experto en seguridad, por
lo aunque le voy a presentar un ejemplo que se puede usar, usted debería
investigar y desarrollar sus propias reglas si la seguridad es algo que le
importe.
</para>

<para>
El uso más común de los cortafuegos IP es probablemente cuando está
usando su máquina Linux como encaminador y pasarela (gateway) cortafuegos para
proteger tu red local de accesos sin autorización desde fuera de la red.
</para>

<para>
La configuración siguiente está basada en una contribución de Arnt
Gulbrandsen, <literal remap="tt"><ulink
url="mailto:agulbra@troll.no"
>agulbra@troll.no</ulink
></literal>.
</para>

<para>
El ejemplo describe la configuración de las reglas de cortafuegos en la
máquina cortafuegos/encaminadora ilustrada en este diagrama.
</para>

<para>

<screen>
-                                   -
 \                                  | 172.16.37.0
  \                                 |   /255.255.255.0
   \                 ---------      |
    |  172.16.174.30 | Linux |      |
NET =================|  f/w  |------|    ..37.19
    |    PPP         | router|      |  --------
   /                 ---------      |--| Mail |
  /                                 |  | /DNS |
 /                                  |  --------
-                                   -
</screen>

</para>

<para>
Las órdenes que siguen, deberían normalmente estar situadas en un fichero
<literal remap="tt">rc</literal> de manera que sean ejecutadas automáticamente cada vez que el
sistema reinicie. Para mayor seguridad deberían ser llamadas después de
que ser configuradas las interfaces de red, pero antes de que las
interfaces hayan sido puestas «en marcha» para prevenir cualquier intento
de acceder mientras la máquina cortafuegos está reiniciando.
</para>

<para>

<screen>
#!/bin/sh

# Limpiar la tabla de reglas de 'Reenvíos'
# Cambiar la política por defecto a 'accept'
#
/sbin/ipfwadm -F -f
/sbin/ipfwadm -F -p accept
#
# .. y lo mismo para 'Entradas'
#
/sbin/ipfwadm -I -f
/sbin/ipfwadm -I -p accept

# Antes que nada, sellamos la interfaz PPP
# Me encantaría usar '-a deny' en lugar de '-a reject -y' pero entonces
# sería imposible originar conexiones desde ese interfaz.
# El -o causa que todos los datagramas rechazados sean registrados. Esto
# toma espacio de disco a cambio de tener el conocimiento de un ataque
# por error de configuración.
#
/sbin/ipfwadm -I -a reject -y -o -P tcp -S 0/0 -D 172.16.174.30

# Eliminar ciertos tipos de paquetes que obviamente han sido generados
# de forma 'artificial': No puede venir nada de direcciones
# multicast/anycast/broadcast
#
/sbin/ipfwadm -F -a deny -o -S 224.0/3 -D 172.16.37.0/24
#
# y nunca deberíamos ver llegar por un cable nada de la red
# 'loopback'
#
/sbin/ipfwadm -F -a deny -o -S 127.0/8 -D 172.16.37.0/24

# aceptamos entradas de las conexiones SMTP y DNS, pero sólo
# hacia el Mail/Name Server
#
/sbin/ipfwadm -F -a accept -P tcp -S 0/0 -D 172.16.37.19 25 53
#
# DNS usa tanto UPD como TCP, por lo tanto los permitimos ambos
# para quien pregunte por nuestro servidor de nombres
#
/sbin/ipfwadm -F -a accept -P udp -S 0/0 -D 172.16.37.19 53
#
# pero no "respuestas" que lleguen a puertos peligrosos como el de NFS
# y extensiones de NFS de Larry McVoy. Si ejecutamos squid, añadir
# su puerto aquí también.
#
/sbin/ipfwadm -F -a deny -o -P udp -S 0/0 53 \
-D 172.16.37.0/24 2049 2050

# valen las respuestas a otros puertos de usuario
#
/sbin/ipfwadm -F -a accept -P udp -S 0/0 53 \
        -D 172.16.37.0/24 53 1024:65535

# Rechazar conexiones de entrada a identd Usaremos 'reject' aquí para que
# se le diga al ordenador que intenta conectar que no continúe, si no lo
# hiciéramos, experimentaríamos retrasos mientras ident da un error de
# 'time out'
#
/sbin/ipfwadm -F -a reject -o -P tcp -S 0/0 -D 172.16.37.0/24 113

# Aceptamos algunas conexiones a servicios comunes desde las redes
# 192.168.64 y 192.168.65, que son amistades en las que confiamos.
#
/sbin/ipfwadm -F -a accept -P tcp -S 192.168.64.0/23 \
       -D 172.16.37.0/24 20:23

# aceptar y dejar pasar cualquier cosa que se origine dentro
#
/sbin/ipfwadm -F -a accept -P tcp -S 172.16.37.0/24 -D 0/0

# denegar la mayoría del resto de conexiones TCP y registrarlas
# (añade 1:1023 si tiene problemas con el FTP)
#
/sbin/ipfwadm -F -a deny -o -y -P tcp -S 0/0 -D 172.16.37.0/24

# ... para UDP también
#
/sbin/ipfwadm -F -a deny -o -P udp -S 0/0 -D 172.16.37.0/24
</screen>

</para>

<para>
Las buenas configuraciones de cortafuegos son un poco complicadillas. Este
ejemplo debería ser un punto de partida razonable. La página de manual de
<literal remap="tt">ipfwadm</literal> ofrece más asistencia en lo que respecta al manejo de la
herramienta. Si intenta configurar un cortafuegos, asegúrese de que hace
suficientes preguntas para tener información de las fuentes que considera
fiables y haga algunas pruebas de funcionamiento con su configuración desde el
exterior de la red.
</para>

</sect2>

<sect2>
<title>IP Firewall (para Linux 2.2)</title>

<para>
Al nuevo código para controlar el cortafuegos se accede mediante <emphasis remap="it">IP Firewall
Chains</emphasis>. Consulte la página principal de IP Chains <literal remap="tt"><ulink
url="http://www.adelaide.net.au/~rustcorp/ipfwchains/ipfwchains.html"
>http://www.adelaide.net.au/~rustcorp/ipfwchains/ipfwchains.html</ulink
> </literal>
si desea más información. Entre otras cosas, necesitará usar <literal remap="tt">ipchains</literal> en
lugar de <literal remap="tt">ipfwadm</literal> para configurar sus filtros.  (De
<literal remap="tt">Documentation/Changes</literal> en las últimas fuentes del núcleo)
</para>

<para>
Estamos avisados de que esto está seguramente desfasado y estamos trabajando
para tener esta sección más al día. Es posible que tengamos una versión nueva
para agosto de 1999.
</para>

</sect2>

<sect2>
<title>Encapsulación IPIP</title>

<para>
¿Qué razón hay para encapsular datagramas IP dentro de datagramas IP?  Le
parecerá una tontería si nunca ha visto antes sus aplicaciones.  Bien, aquí
tenemos un par de ejemplos comunes en los que se usa: Mobile-IP e IP-Multicast.
Posiblemente su uso más extendido o al menos el mejor conocido es Amateur
Radio.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Networking options  ---&#62;
        [*] TCP/IP networking
        [*] IP: forwarding/gatewaying
        ....
        &#60;*&#62; IP: tunneling
</screen>

</para>

<para>
Los dispositivos túneles de IP se denominan <literal remap="tt">tunl0</literal>, <literal remap="tt">tunl1</literal>,
etc.
</para>

<para>
<emphasis remap="it">¿Pero por qué?</emphasis>. Bien, bien. Las reglas convencionales de encaminamiento
de redes IP comprenden direcciones de red y máscaras de red. Esto hace que
conjuntos de direcciones contiguas sean encaminadas mediante una sola regla de
encaminamiento. Esto es muy conveniente, pero significa que sólo puede usar una
dirección IP en particular cuando está conectado a alguna parte de la red a la
que pertenece.  En la mayoría de los casos esto vale, pero si suele desplazarse
entonces no será capaz siempre de conectar desde el mismo sitio. La
encapsulación IP/IP (IP tunneling) le permite saltarse esta restricción
permitiendo que los datagramas que están destinados a su dirección IP sean
encapsulados y dirigidos a otra dirección IP. Si sabe que va a estar durante un
tiempo trabajando en otra red IP entonces podrá poner a punto una máquina de su
red habitual para que acepte los datagramas que van dirigidos a su IP y que los
reenvíe a la dirección que esté usando de manera temporal.
</para>

<sect3>
<title>Una configuración de red con <emphasis remap="it">túneles</emphasis></title>

<para>

<screen>
 192.168.1/24                          192.168.2/24

     -                                     -
     |      ppp0 =            ppp0 =       |
     |  aaa.bbb.ccc.ddd  fff.ggg.hhh.iii   |
     |                                     |
     |   /-----\                 /-----\   |
     |   |     |       //        |     |   |
     |---|  A  |------//---------|  B  |---|
     |   |     |     //          |     |   |
     |   \-----/                 \-----/   |
     |                                     |
     -                                     -
</screen>

</para>

<para>
El diagrama ilustra otra posible razón para usar encapsulación IPIP, las
redes privadas virtuales. Este ejemplo presupone que tiene dos máquinas
cada una con una sola conexión ppp a Internet. Cada máquina tiene una sola
dirección IP. Tras cada una de estas máquinas hay algunas redes privadas
de área local configuradas con direcciones de red IP reservadas.
Supongamos que quiere permitir que cualquier máquina en la red <literal remap="tt">A</literal> se
conecte con cualquier máquina en la red <literal remap="tt">B</literal>, como si estuvieran conectadas a
Internet por una ruta de red. La encapsulación IP se lo permitirá. Tenga
en cuenta que la encapsulación no resuelve el problema de cómo hacer que
las máquinas las redes <literal remap="tt">A</literal> y <literal remap="tt">B</literal> se comuniquen con otras máquinas en
Internet, ya que para seguimos necesitando trucos como el Enmascaramiento IP.
La encapsulación la realiza normalmente una máquina que esté funcionando como
encaminador.
</para>

<para>
El encaminador Linux <literal remap="tt">A</literal> debería configurarse así:
</para>

<para>

<screen>
#!/bin/sh
PATH=/sbin:/usr/sbin
mask=255.255.255.0
remotegw=fff.ggg.hhh.iii
#
# Configuración Ethernet
ifconfig eth0 192.168.1.1 netmask $mask up
route add -net 192.168.1.0 netmask $mask eth0
#
# Configuración ppp0 (iniciar enlace ppp, establecer ruta por defecto)
pppd
route add default ppp0
#
# Configuración del dispositivo túnel
ifconfig tunl0 192.168.1.1 up
route add -net 192.168.2.0 netmask $mask gw $remotegw tunl0
</screen>

</para>

<para>
El encaminador Linux `<literal remap="tt">B</literal>' debería configurarse con:
</para>

<para>

<screen>
#!/bin/sh
PATH=/sbin:/usr/sbin
mask=255.255.255.0
remotegw=aaa.bbb.ccc.ddd
#
# Configuración Ethernet
ifconfig eth0 192.168.2.1 netmask $mask up
route add -net 192.168.2.0 netmask $mask eth0
#
# Configuración ppp0 (iniciar enlace PPP, establecer ruta por defecto)
pppd
route add default ppp0
#
# Configuración del dispositivo túnel
ifconfig tunl0 192.168.2.1 up
route add -net 192.168.1.0 netmask $mask gw $remotegw tunl0
</screen>

</para>

<para>
La orden:
</para>

<para>

<screen>
route add -net 192.168.1.0 netmask $mask gw $remotegw tunl0
</screen>

</para>

<para>
se leería: <emphasis remap="it">Envía cualquier datagrama destinado a</emphasis>
<literal remap="tt">192.168.1.0/24</literal> <emphasis remap="it">dentro de un datagrama IPIP con dirección de
destino</emphasis> <literal remap="tt">aaa.bbb.ccc.ddd</literal>'.
</para>

<para>
Las configuraciones son recíprocas en cada extremo. El dispositivo de túnel usa
el <literal remap="tt">gw</literal> dado en la ruta como <emphasis>destino</emphasis> del datagrama IP en el que
encerrará el datagrama que ha recibido para encaminar.  Esa máquina debe saber
cómo desencapsular datagramas IPIP, esto es, debe también estar configurada con
un dispositivo túnel.
</para>

</sect3>

<sect3>
<title>Configuración de la máquina cuyos paquetes serán encapsulados</title>

<para>
No tiene por qué estar encaminando una red entera. Por ejemplo puede
estar encapsulando una sola dirección IP. En este caso podría configurar
el dispositivo <literal remap="tt">tunl</literal> en la máquina `remota' con su dirección IP y el
extremo <literal remap="tt">A</literal> usará la máquina encaminadora (y <emphasis remap="it">Proxy Arp</emphasis>) en lugar
encaminar la red a través del dispositivo túnel. Dibujemos de nuevo y
modifiquemos apropiadamente nuestra configuración. Ahora tenemos una máquina
<literal remap="tt">B</literal> que quiere actuar y comportarse como si estuviera conectada a Internet y
al mismo tiempo fuera parte de una red remota soportada por la máquina
<literal remap="tt">A</literal>:
</para>

<para>

<screen>
 192.168.1/24

     -
     |      ppp0 =                ppp0 =
     |  aaa.bbb.ccc.ddd      fff.ggg.hhh.iii
     |
     |   /-----\                 /-----\
     |   |     |       //        |     |
     |---|  A  |------//---------|  B  |
     |   |     |     //          |     |
     |   \-----/                 \-----/
     |                      también: 192.168.1.12
     -
</screen>

</para>

<para>
El encaminador Linux <literal remap="tt">A</literal> debería configurarse así:
</para>

<para>

<screen>
#!/bin/sh
PATH=/sbin:/usr/sbin
mask=255.255.255.0
remotegw=fff.ggg.hhh.iii
#
# Configuración Ethernet
ifconfig eth0 192.168.1.1 netmask $mask up
route add -net 192.168.1.0 netmask $mask eth0
#
# Configuración ppp0 (iniciar enlace ppp, establecer ruta por defecto)
pppd
route add default ppp0
#
# Configuración del dispositivo túnel
ifconfig tunl0 192.168.1.1 up
route add -host 192.168.1.12 gw $remotegw tunl0
#
# Proxy ARP para la máquina remota
arp -s 192.168.1.12 xx:xx:xx:xx:xx:xx pub
</screen>

</para>

<para>
El encaminador Linux <literal remap="tt">B</literal> debería configurarse así:
</para>

<para>

<screen>
#!/bin/sh
PATH=/sbin:/usr/sbin
mask=255.255.255.0
remotegw=aaa.bbb.ccc.ddd
#
# Configuración ppp0 (iniciar enlace ppp, establecer ruta por
# defecto)
pppd
route add default ppp0
#
# Configuración del dispositivo túnel
ifconfig tunl0 192.168.1.12 up
route add -net 192.168.1.0 netmask $mask gw $remotegw tunl0
</screen>

</para>

<para>
Esta clase de configuración es más típica de aplicaciones Mobile-IP, donde una
máquina quiere moverse por Internet y mantener una única IP fija. Debería leer
la sección Mobile-IP (IP Móvil) si quiere más información de cómo se hace esto
en la práctica.
</para>

</sect3>

</sect2>

<sect2>
<title>Enmascarado IP (<emphasis remap="it">IP Masquerade</emphasis>)</title>

<para>
Mucha gente dispone de una sola cuenta por conexión telefónica para
conectarse a Internet. Casi todos los que utilizan esa configuración se ve
limitado a una sola dirección IP que le da el Proveedor de Servicios de
Internet. Esto normalmente es bastante para permitir un sólo acceso
completo a la red. El Enmascarado IP es un truco inteligente que permite
que varias máquinas usen una sola dirección IP, haciendo que las otras
máquinas se hagan pasar, y de ahí el término de enmascaramiento, por la
máquina que realmente tiene la conexión. Hay un pequeño defecto y es que
el enmascarado funciona casi siempre en un sólo sentido, y este es que las
máquinas enmascaradas pueden hacer llamadas, pero no pueden aceptar o
recibir llamadas de otras máquinas remotas. Esto significa que algunos
servicios de red como <emphasis>talk</emphasis> no funcionarán y otros como <emphasis>ftp</emphasis>
deberán ser configurados en modo pasivo (PASV) para que funcionen. 
Afortunadamente los servicios de red más comunes como <emphasis>telnet</emphasis>, WWW e
<emphasis>irc</emphasis> funcionan bien.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación de Red</emphasis>:
</para>

<para>

<screen>
    Code maturity level options  ---&#62;
        [*] Prompt for development and/or incomplete code/drivers
    Networking options  ---&#62;
        [*] Network firewalls
        ....
        [*] TCP/IP networking
        [*] IP: forwarding/gatewaying
        ....
        [*] IP: masquerading (EXPERIMENTAL)
</screen>

</para>

<para>
Lo normal es que su máquina Linux esté usando una línea slip o PPP como si
fuera una máquina aislada. Sin embargo, podemos tener además otros
dispositivos de red configurados, quizá una ethernet, configurada con una
de las direcciones de red privadas. Las máquinas que van a ser
enmascaradas podrían estar en esta segunda red. Cada una de ellas debería
tener asignada la dirección IP del puerto Ethernet de la máquina Linux
como la pasarela (<emphasis remap="it">gateway</emphasis>) por defecto.
</para>

<para>
Una configuración típica podría ser algo parecido a:
</para>

<para>

<screen>
-                                   -
 \                                  | 192.168.1.0
  \                                 |   /255.255.255.0
   \                 ---------      |
    |                | Linux | .1.1 |
NET =================| masq  |------|
    |    PPP/slip    | router|      |  --------
   /                 ---------      |--| host |
  /                                 |  |      |
 /                                  |  --------
-                                   -
</screen>

</para>

<para>
<emphasis>Enmascarado con IPFWADM</emphasis>
</para>

<para>
Las órdenes más importantes para esta configuración son:
</para>

<para>

<screen>
# Ruta de red hacia la Ethernet
route add -net 192.168.1.0 netmask 255.255.255.0 eth0
#
# Ruta por defecto al resto de Internet
route add default ppp0
#
# Hace que todas las máquinas de la red 192.168.1/24 sean
# enmascarados
ipfwadm -F -a m -S 192.168.1.0/24 -D 0.0.0.0/0
</screen>

</para>

<para>
<emphasis>Enmascarado con IPCHAINS</emphasis>
</para>

<para>

<screen>
# Ruta de red hacia la Ethernet
route add -net 192.168.1.0 netmask 255.255.255.0 eth0
#
# Ruta por defecto al resto de Internet
route add default ppp0
#
# Hace que todas las máquinas de la red 192.168.1/24 sean
# enmascarados
ipchains -A forward -s 192.168.1.0/24 -j MASQ
</screen>

</para>

<para>
Puede obtener más información sobre Enmascarado IP de Linux en la página de
recursos de IP Masquerade <literal remap="tt"><ulink
url="http://www.hwy401.com/achau/ipmasq/"
>http://www.hwy401.com/achau/ipmasq</ulink
></literal>. También hay un documento
<emphasis>muy</emphasis> detallado que habla sobre enmascaramiento, que es el
<emphasis remap="it">IP-Masquerade-Como</emphasis> (que también enseña a configurar otros sistemas
operativos para trabajar teniendo un Linux como servidor enmascarador).
</para>

</sect2>

<sect2>
<title>Proxy IP transparente</title>

<para>
El proxy transparente de IP es una característica que le permite redirigir
servidores o servicios destinados a otra máquina a esos servicios en esta
máquina. Normalmente esto es útil cuando tiene un Linux como encaminador
que además proporciona un servidor proxy. Debería redirigir todas las
conexiones destinadas a este servicio de forma remota al servidor local
de proxy.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Code maturity level options  ---&#62;
        [*] Prompt for development and/or incomplete code/drivers
    Networking options  ---&#62;
        [*] Network firewalls
        ....
        [*] TCP/IP networking
        ....
        [*] IP: firewalling
        ....
        [*] IP: transparent proxy support (EXPERIMENTAL)
</screen>

</para>

<para>
La configuración de la característica de proxy transparente se realiza
mediante la orden <literal remap="tt">ipfwadm</literal>.
</para>

<para>
Un ejemplo que podría ser útil es el siguiente:
</para>

<para>

<screen>
root# ipfwadm -I -a accept -D 0/0 telnet -r 2323
</screen>

</para>

<para>
Este ejemplo hará que cualquier intento de conexión al puerto <literal remap="tt">telnet</literal> (23)
por parte de otra máquina sea redirigida al puerto 2323 de esta máquina. Si
tiene un servicio activo en ese puerto, podría redirigir las conexiones telnet,
hacer un registro de lo que pasa, o cualquier cosa que se ajuste a sus
necesidades.
</para>

<para>
Un ejemplo más interesante es redirigir todo el tráfico <literal remap="tt">http</literal> a través
de un almacén caché local. Sin embargo, el protocolo usado por los
servidores proxy es diferente al http nativo: mientras que un cliente
conecta a <literal remap="tt">www.servidor.com:80</literal> y pregunta por <literal remap="tt">/camino/página</literal>,
cuando conecta a la caché local busca <literal remap="tt">proxy.dominio.local:8080</literal> y
pregunta por <literal remap="tt">www.servidor.com/camino/página</literal>.
</para>

<para>
Para filtrar una petición <literal remap="tt">http</literal> a través del proxy local, necesitará
adaptar el protocolo insertando un pequeño servidor llamado <literal remap="tt">transproxy</literal> (lo
puede encontrar en la web). Si quiere puede ejecutarlo en el puerto 8081, y
ejecutar esta orden:
</para>

<para>

<screen>
root# ipfwadm -I -a accept -D 0/0 80 -r 8081
</screen>

</para>

<para>
Entonces, el programa <literal remap="tt">transproxy</literal> recibirá todas las conexiones que tengan
que alcanzar servidores externos y las pasará al proxy local arreglando las
diferencias de protocolo.
</para>

</sect2>

<sect2 id="IPv6">
<title>IPv6
</title>

<para>
¡Justo ahora que creía que empezaba a entender las redes IP las reglas
cambian! IPv6 es la notación abreviada de la versión 6 del Internet
Protocol. IPv6 fue desarrollada principalmente para responder a los
temores de la comunidad de Internet al respecto de que pronto habrá
escasez de direcciones IP para asignar. Las direcciones IPv6 son de 16
bytes (128 bits). IPv6 incorpora varios cambios más, en su mayor parte
simplificaciones, que harán que las redes IPv6 sean más manejables que las
IPv4.
</para>

<para>
Linux ya tiene una implementación de IPv6 que funciona, pero no está
completa, a partir de la serie de núcleos <literal remap="tt">2.2.*</literal>.
</para>

<para>
Si quiere experimentar con esta próxima generación de tecnología de
Internet, o le hace falta, debería leerse la <emphasis remap="it">IPv6-FAQ</emphasis> que está disponible
en <literal remap="tt"><ulink
url="http://www.terra.net/ipv6/"
>http://www.terra.net/ipv6</ulink
></literal>.
</para>

</sect2>

<sect2 id="Mobile-IP">
<title>Mobile IP
</title>

<para>
El término <emphasis remap="it">movilidad de IP</emphasis> describe la habilidad de una máquina que es
capaz de mover su conexión de red de un punto de Internet a otro sin cambiar su
dirección IP o perder conectividad. Normalmente cuando una máquina con IP
cambia su punto de conexión también debe cambiar su dirección IP. La Movilidad
de IP soluciona este problema asignando una IP fija a la máquina móvil y usando
encapsulación IP (<emphasis remap="it">tunneling</emphasis>) con encaminado automático para asegurar que
los datagramas destinados a ella se encaminan a la verdadera dirección IP que
esté usando en ese momento.
</para>

<para>
Está en camino un proyecto para proporcionar un juego completo de herramientas
de movilidad de IP para Linux. El estado del proyecto y las herramientas los
puede obtener de la página principal de Linux Mobile IP <literal remap="tt"><ulink
url="http://anchor.cs.binghamton.edu/~mobileip/"
>http://anchor.cs.binghamton.edu/~mobileip</ulink
></literal>.
</para>

</sect2>

<sect2 id="Multicast">
<title>Multicast
</title>

<para>
IP Multicast permite encaminar datagramas IP hacia a un número arbitrario de
máquinas con IP de forma simultánea. Este mecanismo se explota para
proporcionar material de amplia distribución por Internet como transmisiones de
imagen y sonido y otras aplicaciones noveles.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
     Networking options  ---&#62;
         [*] TCP/IP networking
         ....
         [*] IP: multicasting
 
</screen>

</para>

<para>
Esto requiere un conjunto de herramientas y algo de configuración de la red.
Una fuente de información sobre cómo instalar y configurar esto para Linux la
encontramos en <literal remap="tt"><ulink
url="http://www.teksouth.com/linux/multicast/"
>http://www.teksouth.com/linux/multicast</ulink
></literal>.
</para>

</sect2>

<sect2 id="NAT">
<title>NAT - Network Address Translation (Traducción de direcciones de
red)
</title>

<para>
El servicio de Traducción de Direcciones de Redes IP es algo así como el
hermano mayor estandarizado del servicio de Enmascarado IP de Linux.  Está
especificado con cierto detalle en el <emphasis remap="it">RFC-1631</emphasis> en su archivo RFC más
próximo.  NAT proporciona características que no posee el Enmascarado IP que lo
hacen eminentemente más apropiado para su uso en los diseños de encaminamiento
de cortafuegos corporativos y en instalaciones a mayor escala.
</para>

<para>
Michael Hasenstein, <literal remap="tt"><ulink
url="mailto:Michael.Hasenstein@informatik.tu-chemnitz.de"
>Michael.Hasenstein@informatik.tu-chemnitz.de</ulink
></literal>, ha desarrollado una
implementación alfa de NAT para el núcleo <literal remap="tt">2.0.29</literal> de Linux. La
documentación e implementación de Michaels está disponible en: la página Web de
<emphasis remap="it">Linux IP Network Address</emphasis> <literal remap="tt"><ulink
url="http://www.csn.tu-chemnitz.de/HyperNews/get/linux-ip-nat.html"
>http://www.csn.tu-chemnitz.de/HyperNews/get/linux-ip-nat.html</ulink
></literal>
</para>

<para>
Los núcleos más modernos de Linux <literal remap="tt">2.2.x</literal> también incluyen algo de la
funcionalidad NAT en el algoritmo de encaminamiento.
</para>

</sect2>

<sect2 id="Traffic-Shaper">
<title>Traffic Shaper (Manipulación del ancho de banda)
</title>

<para>
El traffic shaper (regulador de caudal) es un controlador que crea nuevas
interfaces de red, las cuales tienen una limitación en el caudal, definida por
el usuario, y que actúan sobre una interfaz de red física para hacer la
comunicación real, pudiendo ser utilizadas por el encaminador para el tráfico
saliente.
</para>

<para>
El regulador fue introducido con Linux-2.1.15 y fue portado a Linux-2.0.36
(apareció en el <literal remap="tt">2.0.36-pre-patch-2</literal> distribuido por Alan Cox, el autor
del dispositivo regulador y mantenedor de Linux-2.0).
</para>

<para>
El regulador de caudal sólo puede ser compilado como módulo y para
configurarlo se usa el programa <emphasis>shapecfg</emphasis> con órdenes como las
siguientes:
</para>

<para>

<screen>
shapecfg attach shaper0 eth1
shapecfg speed shaper0 64000
</screen>

</para>

<para>
El dispositivo regulador sólo puede controlar el ancho de banda del tráfico de
salida, ya que los paquetes son transmitidos a través suyo de acuerdo con las
tablas de rutas; sin embargo, una funcionalidad de <emphasis remap="it">rutas por dirección de
origen</emphasis> podría ayudar a limitar el ancho de banda global de máquinas específicas
que estén usando un encaminador Linux.
</para>

<para>
Linux-2.2 implementa también ese tipo de encaminamiento, y si lo necesita en
Linux-2.0, busque el parche de Mike McLagan, en
<literal remap="tt"><ulink
url="ftp://ftp.invlogic.com"
>ftp://ftp.invlogic.com</ulink
></literal>.
Lea <literal remap="tt">Documentation/networking/shaper.txt</literal> si desea más información al
respecto del <emphasis>shaper</emphasis>.
</para>

<para>
Si quiere probar un intento de regulación de caudal de paquetes entrantes,
use <literal remap="tt">rshaper-1.01</literal> (o más nuevo). Lo encontrará en <literal remap="tt"><ulink
url="ftp://ftp.systemy.it/pub/develop"
>ftp://ftp.systemy.it/pub/develop</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>Encaminamiento con Linux-2.2</title>

<para>
La última versión de Linux, la 2.2, ofrece mucha flexibilidad en lo que a
política de encaminamiento se refiere. Desafortunadamente, deberá esperar
a la siguiente versión de este Como, o acudir a las fuentes del núcleo.
</para>

</sect2>

</sect1>

<sect1>
<title>Uso de hardware común en los PC</title>

<sect2>
<title>RDSI</title>

<para>
La Red Digital de Servicios Integrados (RDSI) es una serie de estándares
que especifican una red digital conmutada de propósito general. Una
llamada RDSI crea un servicio de datos asíncrono punto a punto hacia el
destino. RDSI suele distribuirse con un enlace de gran velocidad que se
divide en varios canales discretos. Hay dos tipos de canales diferentes,
los <emphasis remap="it">Canales B</emphasis> que son los que realmente transportan los datos del
usuario y un sólo canal llamado <emphasis remap="it">canal D</emphasis> que se usa para enviar
información de control a la RDSI para establecer llamadas y otras
funciones. En Australia, por ejemplo, RDSI se distribuye con un enlace
de 2Mbps que se divide en 30 canales discretos B de 64kbps con un canal D
de 64kbps.  Se pueden usar cualquier número de canales en cualquier
momento y en cualquier combinación. Usted podría, por ejemplo, establecer
30 llamadas separadas a 30 destinos diferentes a 64kbps cada uno, o
15 llamadas a 15 destinos diferentes a 128kbps cada uno (dos canales por
llamada), o sencillamente un pequeño número de llamadas y dejar el resto
de los canales sin usar. Se puede usar un canal tanto para llamadas
entrantes como salientes. La intención original de la RDSI fue permitir a
las compañías de telecomunicaciones proporcionar un sólo servicio de datos
que pudiera transmitir tanto teléfono (mediante voz digitalizada) como
servicios de datos a su casa o negocio sin que tuviera que hacer ningún cambio
especial de configuración.
</para>

<para>
Hay unas pocas maneras diferentes de conectar su ordenador a un servicio
RDSI. Una manera es usar un dispositivo llamado <emphasis remap="it">Adaptador Terminal</emphasis> que se
enchufa a la Unidad Terminadora de Red que su compañía local de
telecomunicaciones tuvo que instalar al proporcionarle el servicio RDSI y que
presenta unas cuantas interfaces serie. Uno de estos interfaces se
usa para introducir instrucciones de establecimiento de llamadas y la
configuración y los otros son los que realmente se conectan a los
dispositivos de red que usarán los circuitos de datos cuando se hayan
establecido. Linux trabajará con este tipo de configuración sin
modificación alguna, simplemente tiene que tratar el puerto del Adaptador
Terminal como trataría cualquier otro dispositivo serie.  Otra manera,
que es para la que está diseñado el soporte de RDSI del núcleo permite instalar
una tarjeta RDSI en su máquina Linux y dejar entonces que sea el propio Linux
quien maneje los protocolos y haga las llamadas.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    ISDN subsystem  ---&#62;
        &#60;*&#62; ISDN support
        [ ] Support synchronous PPP
        [ ] Support audio via ISDN
        &#60; &#62; ICN 2B and 4B support
        &#60; &#62; PCBIT-D support
        &#60; &#62; Teles/NICCY1016PC/Creatix support
 
</screen>

</para>

<para>
La implementación del núcleo de Linux de la RDSI soporta varios tipos
diferentes de tarjetas RDSI. Son las que vienen listadas en las opciones de
configuración del núcleo.
</para>

<para>

<itemizedlist>
<listitem>

<para>
ICN 2B and 4B
</para>
</listitem>
<listitem>

<para>
Octal PCBIT-D
</para>
</listitem>
<listitem>

<para>
Tarjetas Teles ISDN y compatibles
</para>
</listitem>

</itemizedlist>

</para>

<para>
Algunas de estas tarjetas requieren que se les carguen ciertos programas
antes de funcionar. Hay una utilidad aparte que hace esto.
</para>

<para>
Hay disponibles más detalles de cómo configurar el soporte RDSI de Linux
en el directorio <literal remap="tt">/usr/src/linux/Documentation/isdn/</literal> y también un
listado <emphasis remap="it">PUF</emphasis> (Pregutas de Uso Frecuente) dedicado a <literal remap="tt">isdn4linux</literal> en
<literal remap="tt"><ulink
url="http://www.lrz-muenchen.de/~ui161ab/www/isdn/"
>http://www.lrz-muenchen.de/~ui161ab/www/isdn</ulink
></literal>.  (Puede pulsar sobre
la bandera inglesa para la versión en inglés).
</para>

<para>
<emphasis remap="bf">Una nota al respecto de PPP</emphasis>. El conjunto de protocolos PPP operará
tanto sobre lineas serie síncronas como asíncronas. El demonio PPP
(<literal remap="tt">pppd</literal>) que se suele distribuir para Linux sólo soporta el modo
asíncrono. Si desea ejecutar los protocolos PPP sobre el servicio RDSI,
necesitará una versión especial modificada. En la documentación
anteriormente mencionada encontrará detalles de cómo encontrarlo.
</para>

<para>
En <literal remap="tt"><ulink
url="http://www.insflug.org/documentos/RDSI-Como/"
>http://www.insflug.org/documentos/RDSI-Como/</ulink
></literal> tiene a su
disposición un documento con detalles específicos de la configuración en
España.
</para>

</sect2>

<sect2>
<title>PLIP en Linux-2.0</title>

<para>
Los nombres de los dispositivos PLIP son `<literal remap="tt">plip0</literal>', `<literal remap="tt">plip1</literal>' y
`<literal remap="tt">plip2</literal>'.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Network device support  ---&#62;
        &#60;*&#62; PLIP (parallel port) support
</screen>

</para>

<para>
<emphasis>plip</emphasis> (Parallel Line IP), se parece a SLIP en que se usa para
proporcionar conexiones <emphasis>punto a punto</emphasis> entre dos máquinas, excepto en
que está diseñado para usar los puertos paralelos de impresora de la
máquina en lugar de los puertos serie (se incluye un diagrama de cableado
en la sección de diagramas de cableado más adelante). Como es posible
transmitir más de un bit a la vez con un puerto paralelo, es posible
obtener mayores velocidades con la interfaz <emphasis>plip</emphasis> que con los
dispositivos serie estándar.  Además, puede aprovecharse incluso el más
sencillo de los puertos paralelos, el puerto de impresora, en lugar de
tener que comprar una UART 16550AFN, comparativamente más cara, para los
puertos serie. PLIP usa mucha CPU si lo comparamos con un enlace serie y
casi seguro que no será una buena opción si puede obtener algunas tarjetas
Ethernet baratas, pero funcionará cuando no esté disponible nada más y
además lo hará bastante bien.  Se puede esperar una tasa de transferencia
de alrededor de 20 kilobytes por segundo cuando el enlace está funcionando
correctamente.
</para>

<para>
Los controladores de dispositivo de PLIP compiten con el controlador de
dispositivo paralelo por el hardware del puerto paralelo. Si desea usar ambos
controladores deberá compilar los dos como módulos para asegurarse de que es
capaz de elegir qué puerto quiere que use PLIP y qué puertos usará como
dispositivos para la impresora. Lea el <emphasis remap="it">Modules mini-Howto</emphasis> para obtener más
información sobre la configuración de los módulos en el núcleo.
</para>

<para>
Por favor tenga en cuenta que algunos portátiles usan circuitería que no
funcionará con PLIP porque no permiten algunas combinaciones de señales en las
que se basa PLIP, que las impresoras no usan.
</para>

<para>
El interfaz <literal remap="tt">plip</literal> de Linux es compatible con el <emphasis>Crynwyr Packet Driver
PLIP</emphasis> y esto significa que puede conectar su máquina Linux a una máquina DOS
que esté ejecutando cualquier clase de programas tcp/ip mediante <literal remap="tt">plip</literal>.
</para>

<para>
En la serie de núcleos 2.0.* los dispositivos PLIP están asignados a
puertos e IRQ como sigue
</para>

<para>

<screen>
    dispositivo  i/o    IRQ
    ----------- -----   ---
    plip0       0x3bc   5
    plip1       0x378   7
    plip2       0x278   2
</screen>

</para>

<para>
Si sus puertos paralelos no se ajustan a alguna de las combinaciones de encima
entonces tendrá que cambiar la IRQ de un puerto usando el parámetro <literal remap="tt">irq</literal> de
la orden <literal remap="tt">ifconfig</literal>. Asegúrese de que activa las IRQ de los puertos de
impresora en la ROM BIOS antes, si es que dispone de esa opción. Como
alternativa, puede especificar las opciones <literal remap="tt">io=</literal> e <literal remap="tt">irq=</literal> como
argumentos a <literal remap="tt">insmod</literal>, si usa módulos. Por ejemplo:
</para>

<para>

<screen>
root# insmod plip.o io=0x288 irq=5
</screen>

</para>

<para>
La operación PLIP se controla con dos retardos, cuyos valores por defecto
suelen ser correctos. Posiblemente necesite incrementarlos si tiene una
máquina un tanto lenta, en cuyo caso los temporizadores a incrementar
están en la <emphasis remap="bf">otra</emphasis> máquina. Hay un programa llamado <literal remap="tt">plipconfig</literal> que
permite cambiar la configuración de los temporizadores sin recompilar el
núcleo. Viene con muchas distribuciones Linux.
</para>

<para>
Para configurar una interfaz <emphasis>plip</emphasis>, necesitará invocar las siguientes
órdenes (o <emphasis remap="bf">añadirlas</emphasis> a su guión de iniciación del sistema):
</para>

<para>

<screen>
root# /sbin/ifconfig plip1 pliplocal pointopoint plipremota
root# /sbin/route add plipremota plip1
</screen>

</para>

<para>
Aquí, el puerto usado es el que está en la dirección E/S <literal remap="tt">0x378</literal>;
<literal remap="tt">pliplocal</literal> y <literal remap="tt">plipremota</literal> son los nombres o direcciones IP usadas para
los extremos del cable PLIP. Personalmente, prefiero tenerlas en mi base de
datos <literal remap="tt">/etc/hosts</literal>:
</para>

<para>

<screen>
# entradas plip
192.168.3.1   pliplocal
192.168.3.2   plipremota
</screen>

</para>

<para>
El parámetro <literal remap="tt">pointopoint</literal> tiene el mismo significado que para SLIP, en el
que especifica la dirección de la máquina en el otro extremo del enlace.
</para>

<para>
En casi todos los aspectos, se puede tratar una interfaz <literal remap="tt">plip</literal> como si
fuese una interfaz <literal remap="tt">SLIP</literal>, excepto que no se puede (ni se necesita)
usar <literal remap="tt">dip</literal> ni <literal remap="tt">slattach</literal>.
</para>

<para>
Para obtener más información al respecto de PLIP, acuda al <emphasis remap="it">PLIP
mini-Howto</emphasis>. 
</para>

</sect2>

<sect2>
<title>PLIP en Linux-2.2</title>

<para>
Durante el desarrollo de las versiones 2.1 del núcleo, se cambió la
implementación del puerto paralelo, hacia una configuración mejor.
</para>

<para>
<emphasis remap="bf">Opciones de compilación del núcleo</emphasis>:
</para>

<para>

<screen>
    General setup  ---&#62;
        [*] Parallel port support
    Network device support  ---&#62;
        &#60;*&#62; PLIP (parallel port) support
</screen>

</para>

<para>
El nuevo código de PLIP se comporta como el anterior (se usan las mismas
órdenes <literal remap="tt">ifconfig</literal> y <literal remap="tt">route</literal> que en la sección anterior, pero la
iniciación del dispositivo es diferente debido a la avanzada implementación del
manejo del puerto paralelo).
</para>

<para>
El «primer» dispositivo PLIP siempre es denominado <literal remap="tt">plip0</literal>, siendo
éste el que primero detecta el sistema, de manera similar a lo que ocurre
con los dispositivos Ethernet. El verdadero puerto paralelo que se va a
usar es uno de los que estén disponibles, tal como se muestra en
<literal remap="tt">/proc/parport</literal>. Por ejemplo, si sólo tiene un puerto paralelo,
sólo tendrá un directorio llamado <literal remap="tt">/proc/parport/0</literal>.
</para>

<para>
Si el núcleo no detecta la IRQ usada por el puerto, <literal remap="tt">insmod plip</literal>
fallará; en este caso simplemente tendrá que escribir el número correcto en
<literal remap="tt">/proc/parport/0/irq</literal> y reinvocar <literal remap="tt">insmod</literal>.
</para>

<para>
Hay disponible información completa al respecto del puerto paralelo en el
archivo <literal remap="tt">Documentation/parport.txt</literal>, parte de las fuentes de su
núcleo.
</para>

</sect2>

<sect2>
<title>PPP</title>

<para>
Los nombres de los dispositivos PPP son <literal remap="tt">ppp0</literal>, <literal remap="tt">ppp1</literal>, etc. Los
dispositivos están numerados de forma secuencial de manera que el primer
dispositivo configurado recibe el <literal remap="tt">0</literal>.
</para>

<para>
<emphasis remap="bf">Opciones de compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Networking options  ---&#62;
        &#60;*&#62; PPP (point-to-point) support
</screen>

</para>

<para>
La configuración del PPP está cubierta en detalle en el PPP-Como, <literal remap="tt"><ulink
url="http://www.insflug.org/documentos/PPP-Como/"
>http://www.insflug.org/documentos/PPP-Como/</ulink
></literal>.
</para>

<sect3>
<title>Mantener una conexión permanente a la red usando <literal remap="tt">pppd</literal>.</title>

<para>
Si es tan afortunado como para tener una conexión semi-permanente a la red y
quiere hacer que su máquina establezca automáticamente la conexión PPP si se
pierde, existe un truco sencillo para hacerlo.
</para>

<para>
Configure el PPP de tal manera que pueda ser iniciado por el usuario
<literal remap="tt">root</literal> ejecutando la orden:
</para>

<para>

<screen>
# pppd
</screen>

</para>

<para>
<emphasis remap="bf">Asegúrese</emphasis> de que tiene configurada la opción <literal remap="tt">-detach</literal> en el fichero
<literal remap="tt">/etc/ppp/options</literal>. Entonces, inserte la siguiente línea en el fichero
<literal remap="tt">/etc/inittab</literal>, bajo las definiciones de <literal remap="tt">getty</literal>.
</para>

<para>

<screen>
pd:23:respawn:/usr/sbin/pppd
</screen>

</para>

<para>
Esto hará que el programa <literal remap="tt">init</literal> ejecute y monitorice el programa <literal remap="tt">pppd</literal>
y que lo reinicie automáticamente si muere.
</para>

</sect3>

</sect2>

<sect2>
<title>Cliente SLIP</title>

<para>
Los nombres de los dispositivos SLIP son <literal remap="tt">sl0</literal>, <literal remap="tt">sl1</literal>, etc.  siendo
asignado el <literal remap="tt">0</literal> al primer dispositivo configurado y el resto incrementando
secuencialmente según van siendo configurados.
</para>

<para>
<emphasis remap="bf">Opciones de compilación del núcleo</emphasis>:
</para>

<para>

<screen>
    Network device support  ---&#62;
        [*] Network device support
        &#60;*&#62; SLIP (serial line) support
        [ ]  CSLIP compressed headers
        [ ]  Keepalive and linefill
        [ ]  Six bit SLIP encapsulation
</screen>

</para>

<para>
El SLIP (<emphasis remap="it">Serial Line Internet Protocol</emphasis>) le permite usar tcp/ip sobre una
línea serie, sea una línea de teléfono con un módem, o una línea dedicada.  Por
supuesto para usar SLIP necesitará tener acceso a un <emphasis>servidor SLIP</emphasis> de
algún tipo. Muchas universidades y empresas de todo el mundo proporcionan
acceso mediante SLIP.
</para>

<para>
Slip usa los puertos serie de su máquina para transportar datagramas IP.
Para hacerlo debe tomar el control del dispositivo serie. Los dispositivos
SLIP se denominan <literal remap="tt">sl0</literal>, <literal remap="tt">sl1</literal>, etc. ¿Cómo se corresponden a sus
dispositivos serie? El código de red usa lo que denominados una llamada
<emphasis>ioctl</emphasis> (i/o control - control de e/s) para convertir los dispositivos
serie en dispositivos SLIP. Se le proporcionan dos programas
que pueden hacer esto, y se llaman <literal remap="tt">dip</literal> y <literal remap="tt">slattach</literal>.
</para>

<sect3>
<title>dip</title>

<para>
<literal remap="tt">dip</literal> (Dialup IP) es un sofisticado programa capaz de programar la
velocidad del dispositivo serie, ordenar a su módem que llame al otro extremo
del enlace, identificarle automáticamente en el servidor remoto, examinar los
mensajes que le envía el servidor y obtener información tal como su dirección
IP y ejecutar las <emphasis>ioctl</emphasis> necesarias para conmutar su puerto serie al
modo SLIP. <literal remap="tt">dip</literal> tiene una gran capacidad para ejecutar guiones
(scripts) y esto lo puede explotar para automatizar el procedimiento de
autenticación.
</para>

<para>
Puede encontrarlo en: <literal remap="tt"><ulink
url="ftp://metalab.unc.edu/pub/Linux/system/Network/serial/dip/dip337o-uri.tgz"
>ftp://metalab.unc.edu/pub/Linux/system/Network/serial/dip/dip337o-uri.tgz</ulink
></literal>.
</para>

<para>
Para instalarlo, intente lo siguiente:
</para>

<para>

<screen>
    usuario% cd /usr/src
    usuario% gzip -dc dip337o-uri.tgz | tar xvf -
    usuario% cd dip-3.3.7o
    root# make install
</screen>

</para>

<para>
El <literal remap="tt">Makefile</literal> asume la existencia de un grupo denominado <literal remap="tt">uucp</literal>,
pero puede que usted quiera cambiarlo a <literal remap="tt">dip</literal> o <literal remap="tt">SLIP</literal>
dependiendo de su configuración.
</para>

</sect3>

<sect3>
<title>slattach</title>

<para>
<literal remap="tt">slattach</literal> es un programa muy sencillo comparado con <literal remap="tt">dip</literal>, muy
fácil de usar, pero no tiene la sofisticación de <literal remap="tt">dip</literal>. No tiene
capacidad para ejecutar guiones, todo lo que hace es configurar su dispositivo
serie como dispositivo SLIP. Asume que tiene toda la información que necesita
y la línea serie se establece antes de que lo invoque. <literal remap="tt">slattach</literal> es
ideal para usarlo donde necesite una conexión permanente al servidor, como un
cable físico o una línea dedicada.
</para>

</sect3>

<sect3>
<title>¿Cuándo usar cada uno?</title>

<para>
Debería usar <literal remap="tt">dip</literal> cuando su enlace a la máquina servidora de SLIP es un
módem, o algún otro enlace temporal. Debería usar <literal remap="tt">slattach</literal> cuando
disponga de una línea dedicada, quizá un cable, entre su máquina y el servidor,
y no se necesita ejecutar ninguna acción especial para hacer que el enlace
funcione. Mire la sección <xref linkend="Conexion-Permanente-con-Slip"/> para más información.
</para>

<para>
configurar SLIP se parece mucho a configurar una interfaz Ethernet (lea la
sección <xref linkend="Ethernet"/> más atrás).  Sin embargo, hay unas pocas
diferencias clave.
</para>

<para>
Antes que nada, los enlaces SLIP son diferentes a las redes Ethernet en
que sólo hay dos máquinas en la red, una en cada extremo del enlace. Al
contrario que con Ethernet que está disponible para su uso nada más que
termine de cablear, con SLIP, dependiendo del tipo de enlace que tenga,
puede que tenga que iniciar la conexión de red de alguna manera especial.
</para>

<para>
Si está usando <literal remap="tt">dip</literal> entonces esto no debería hacerlo en el momento de
arrancar, sino algo más adelante, cuando esté preparado para usar el enlace. Es
posible automatizar este procedimiento.  Si está usando <literal remap="tt">slattach</literal>
entonces probablemente quieras añadir una sección a su fichero
<literal remap="tt">rc.*</literal> correspondiente. Esto lo describiremos pronto.
</para>

<para>
Hay dos tipos principales e servidores SLIP: servidores de direcciones IP
dinámicas y servidores de direcciones IP estáticas. Casi cualquier
servidor SLIP le pedirá al conectar una identificación y una contraseña.
<literal remap="tt">dip</literal> puede proporcionar estos datos automáticamente.
</para>

</sect3>

<sect3>
<title>Servidor SLIP estático con línea por llamada y DIP.</title>

<para>
Un servidor estático de SLIP es aquél en el que se le ha dado una dirección IP
que es exclusivamente suya. Cada vez que conecte al servidor, tendrá que
configurar su puerto SLIP con esa dirección. El servidor estático de SLIP
contestará a la llamada del módem, posiblemente le pregunte su nombre de
usuario y contraseña, y entonces encaminará cualquier datagrama destinado a su
dirección mediante esa conexión. Si tiene un servidor estático, entonces puede
que quiera añadir una entrada con su dirección IP y el nombre de su máquina (ya
que sabe cuales serán) en <literal remap="tt">/etc/hosts</literal>. También debería configurar
algunos otros ficheros como: <literal remap="tt">rc.*</literal>, <literal remap="tt">host.conf</literal>,
<literal remap="tt">resolv.conf</literal>, <literal remap="tt">/etc/HOSTNAME</literal> y <literal remap="tt">rc.local</literal>. Recuerde que
cuando configure <literal remap="tt">rc.*</literal>, no necesita añadir ninguna orden especial para
la conexión SLIP ya que es <literal remap="tt">dip</literal> el que hace todo el trabajo duro al
configurar la interfaz. Necesitará proporcionarle a <literal remap="tt">dip</literal> la información
apropiada de manera que configure la interfaz por usted después de ordenarle al
módem que establezca la llamada y de darle de alta en el servidor SLIP.
</para>

<para>
Si esta es la manera de trabajar de su servidor SLIP entonces puede pasar
a la sección <xref linkend="Uso-de-Dip"/> para aprender a configurar
<literal remap="tt">dip</literal> de forma apropiada.
</para>

</sect3>

<sect3>
<title>Servidor SLIP dinámico con línea por llamada y DIP.</title>

<para>
Un servidor <emphasis>dinámico</emphasis> de SLIP es aquél que le asigna una dirección IP
al azar, a partir de una reserva de direcciones, cada vez que se registra. Eso
significa que no hay garantías de que tenga una dirección en particular cada
vez, y esa dirección puede ser usada por otra persona después de que usted haya
desconectado. El administrador de red que configuró el servidor SLIP habrá
asignado un rango de direcciones para que el servidor SLIP las use, cuando el
servidor recibe una nueva llamada entrante, localiza la primera dirección sin
asignar, guía a quien llama a través del procedimiento de registro y entonces
imprime un mensaje de bienvenida que contiene la dirección IP que se le ha
asignado, para entonces proceder a usar esa dirección IP durante toda la
llamada.
</para>

<para>
La configuración para este tipo de servidor es similar a la configuración
para un servidor estático, excepto en que debe añadir un paso en el que obtiene
la dirección IP que el servidor le ha asignado y configura su dispositivo SLIP
con ella.
</para>

<para>
De nuevo, <literal remap="tt">dip</literal> hace el trabajo duro y las nuevas versiones son
suficientemente sofisticadas no sólo como para registrarle, sino también como
para leer automáticamente la dirección IP impresa en el mensaje de bienvenida y
almacenarla de manera que pueda configurar el dispositivo SLIP con ella.
</para>

<para>
Si esta es la manera de trabajar de su servidor SLIP, entonces puede pasar a la
sección <xref linkend="Uso-de-Dip"/> para aprender a configurar
<literal remap="tt">dip</literal> de forma apropiada.
</para>

</sect3>

<sect3 id="Uso-de-Dip">
<title>Uso de Dip.
</title>

<para>
Como se explicó anteriormente, <literal remap="tt">dip</literal> es un programa potente que puede
simplificar y automatizar el proceso de llamada a el servidor SLIP, registro,
inicio de la conexión y configuración de tus dispositivos SLIP con las órdenes
<literal remap="tt">ifconfig</literal> y <literal remap="tt">route</literal> apropiadas.
</para>

<para>
Esencialmente, para usar <literal remap="tt">dip</literal> escribiremos un «guión dip», que es
básicamente una lista de órdenes que <literal remap="tt">dip</literal> comprende y que le dicen
cómo debe realizar cada una de las acciones que usted quiere que haga.  Eche un
vistazo al fichero <literal remap="tt">sample.dip</literal> que viene con <literal remap="tt">dip</literal> para hacerse
una idea de cómo funciona. <literal remap="tt">dip</literal> es un programa bastante potente, con
muchas opciones. No las va a encontrar todas aquí, y tendrá que mirar la
correspondiente página <literal remap="tt">man</literal>, el <literal remap="tt">README</literal> y los ficheros de ejemplo que
vendrán con su versión de <literal remap="tt">dip</literal>.
</para>

<para>
Fíjese en que el guión <literal remap="tt">sample.dip</literal> asume que está accediendo a un
servidor SLIP estático, por lo que su IP ya se conoce de antemano. Las nuevas
versiones de <literal remap="tt">dip</literal> incluyen, para los servidores SLIP dinámicos, una
orden que puede usarse para leer y configurar automáticamente el dispositivo
SLIP con la dirección IP que el servidor dinámico le asigna. El ejemplo
siguiente es una versión modificada y traducida del <literal remap="tt">sample.dip</literal> que
viene con <literal remap="tt">dip337j-uri.tgz</literal> y probablemente sea un buen punto de
partida. Puede que quiera grabarlo como <literal remap="tt">/etc/guiondip</literal> y editarlo para
que se ajuste a su configuración.
</para>

<para>

<screen>
#
# sample.dip    Programa de soporte de conexión para Dialup IP
#
#               Este fichero (debería mostrar) muestra el uso de DIP
#       Este fichero debería funcionar para los servidores dinámicos
#       de tipo Annex, si usted usa un servidor estático entonces utilice
#       el fichero sample.dip que viene en el paquete dip337-uri.tgz
#
#
# Versión:      @(#)sample.dip  1.40    20/07/93
#
# Autor:        Fred N. van Kempen, &#60;waltje@uWalt.NL.Mugnet.ORG&#62;
#

main:
# Lo siguiente es configurar el nombre y dirección del otro extremo
# La máquina a la que llamo se llama 'xs4all.hacktic.nl'
# (== 193.78.33.42)
get $remote xs4all.hacktic.nl
# Asignar 255.255.255.0 como máscara de red de sl0
netmask 255.255.255.0
# Asignar el puerto serie y velocidad deseados
port cua02
speed 38400

# Reiniciar el módem y la línea terminal
# ¡Esto parece darle problemas a algunas personas!
reset

# ¡Nota! Valores "estándar" predefinidos de "errlevel"
#  0 - OK
#  1 - CONNECT
#  2 - ERROR
#
# Puede cambiarlos buscando "addchat()" en *.c...

# Nos preparamos para llamar.
send ATQ0V1E1X4\r
wait OK 2
if $errlvl != 0 goto problema_con_modem
dial 555-1234567
if $errlvl != 1 goto problema_con_modem

# Estamos conectados. Registrarse en el sistema.
login:
sleep 2
wait ogin: 20
if $errlvl != 0 goto problema_al_registrarse
send MILOGIN\n
wait ord: 20
if $errlvl != 0 goto clave_erronea
send MIPASSWD\n
loggedin:

# Ahora estamos registrados.
wait SOMEPROMPT 30
if $errlvl != 0 goto error_de_prompt

# Ordenamos al servidor que entre en modo SLIP
send SLIP\n
wait SLIP 30
if $errlvl != 0 goto error_de_prompt

# Obtenemos nuestra dirección IP del servidor y la asignamos
#   Aquí asumiremos que tras ordenar al servidor SLIP que entre
#   en modo SLIP, nos imprime nuestra dirección IP.
get $local remote 30
if $errlvl != 0 goto prompt_error

# Configurar los parámetros operativos de SLIP
get $mtu 296
# Aseguramos que se ejecuta "route add -net default xs4all.hacktic.nl"
default

# ¡Decimos hola y arrancamos!
done:
print CONNECTED $local ---&#62; $rmtip
mode CSLIP
goto salir

error_de_prompt:
print Se produjo un TIME-OUT esperando a que arrancara sliplogin
goto error

problema_al_registrarse:
print Hubo un problema esperando por el mensaje Login:...
goto error

clave_erronea:
print Hubo un problema esperando por el mensaje Password:...
goto error

problema_con_modem:
print Hubo un problema con el módem...
error:
print FALLÓ LA CONEXIÓN a $remote
quit

salir:
exit
</screen>

</para>

<para>
El ejemplo anterior asume que estamos llamando a un servidor SLIP
<emphasis>dinámico</emphasis>. Si está llamando a un servidor SLIP <emphasis>estático</emphasis>,
entonces debería funcionarle el fichero <literal remap="tt">sample.dip</literal> que viene con
<literal remap="tt">dip-337-uri.tgz</literal>.
</para>

<para>
Cuando se le da a <literal remap="tt">dip</literal> la orden <literal remap="tt">get $local</literal>, busca en el
texto que viene del otro extremo una cadena que se parezca a una dirección IP,
osea una cadena de números separados por caracteres «.». Esta modificación se
hizo específicamente pensando en los servidores SLIP <emphasis>dinámicos</emphasis>, para
que el proceso de leer la dirección IP pudiera ser automatizado.
</para>

<para>
El ejemplo anterior creará automáticamente una ruta por defecto a través del
enlace SLIP. Si no es lo que deseaba, a lo mejor porque tiene una conexión
Ethernet que debería ser la ruta por defecto, entonces elimine la orden
<literal remap="tt">default</literal> del guión. Después de que haya acabado de ejecutarse el guión,
si ejecuta la orden <literal remap="tt">ifconfig</literal>, verá que hay un dispositivo
<literal remap="tt">sl0</literal>. Este es el dispositivo SLIP. Si fuese necesario, podría modificar
su configuración a mano, después de que la orden <literal remap="tt">dip</literal> haya acabado,
usando las órdenes <literal remap="tt">ifconfig</literal> y <literal remap="tt">route</literal>.
</para>

<para>
Por favor, observe que <literal remap="tt">dip</literal> le permite elegir varios protocolos
diferentes en la orden <literal remap="tt">mode</literal>. El ejemplo más común es <emphasis>cSLIP</emphasis>
que es SLIP con compresión. Por favor, tenga en cuenta que ambos extremos del
enlace deben concordar, por lo que debe asegurarse de que elija lo que elija,
sea la mismo que lo que tenga el servidor.
</para>

<para>
El ejemplo anterior es bastante robusto y debería copar con la mayoría de los
errores. Para obtener más información, haga el favor de dirigirse a las páginas
man de <literal remap="tt">dip</literal>. Naturalmente podría, por ejemplo, codificar un guión para
que haga cosas como llamar de nuevo al servidor si no consigue conectarse tras
un periodo de tiempo determinado, o incluso hacer intentos con varios
servidores si tiene acceso a más de uno.
</para>

</sect3>

<sect3 id="Conexion-Permanente-con-Slip">
<title>Conexión SLIP permanente usando una línea dedicada y slattach
 </title>

<para>
Si lo que tiene es un cable entre dos máquinas, o es tan afortunado como para
tener una línea dedicada, o algún otro tipo de conexión en serie permanente
entre su máquina y otra, entonces no necesita la complejidad de usar
<literal remap="tt">dip</literal> para establecer un enlace serie. <literal remap="tt">slattach</literal> es una utilidad
muy sencilla de usar, que le permite suficiente funcionalidad como para
configurar una conexión.
</para>

<para>
Como la conexión será permanente, querrá añadir algunas órdenes al fichero
<literal remap="tt">rc</literal> pertinente. En esencia, todo lo que necesita hacer para tener una
conexión permanente es asegurarse de que configura el dispositivo serie a la
velocidad correcta y que lo pasa a modo SLIP. <literal remap="tt">slattach</literal> permite hacer
esto con una sola orden. Añade lo siguiente al fichero <literal remap="tt">rc</literal> pertinente:
</para>

<para>

<screen>
#
# Activar una conexión SLIP estática por línea dedicada
#
#  configuramos /dev/cua0 para 19.2kbps y cslip
/sbin/slattach -p cslip -s 19200 /dev/cua0 &#38;
/sbin/ifconfig sl0 IPA.IPA.IPA.IPA pointopoint IPR.IPR.IPR.IPR up
#
# Fin de SLIP estático
</screen>

</para>

<para>
<emphasis remap="bf">Nota del traductor</emphasis>: A fecha de la traducción, la serie estable del
núcleo era la <literal remap="tt">2.2</literal>. En la serie <literal remap="tt">2.2</literal>, los dispositivos
<literal remap="tt">/dev/cuaX</literal> han sido completamente eliminados, unificándolos a los
<literal remap="tt">/dev/ttySX</literal>.
</para>

<para>
Donde:
</para>

<para>
<variablelist>

<varlistentry>
<term>IPA.IPA.IPA.IPA</term>
<listitem>
<para>
representa su dirección IP.
</para>
</listitem></varlistentry>
<varlistentry>
<term>IPR.IPR.IPR.IPR</term>
<listitem>
<para>
representa la dirección IP del extremo remoto.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
<literal remap="tt">slattach</literal> asigna el primer dispositivo SLIP sin asignar al dispositivo
serie especificado. <literal remap="tt">slattach</literal> comienza por <literal remap="tt">sl0</literal>. Por lo tanto
la primera orden <literal remap="tt">slattach</literal> asocia el dispositivo SLIP <literal remap="tt">sl0</literal> al
dispositivo serie especificado y <literal remap="tt">sl1</literal> la siguiente vez, etc.
</para>

<para>
<literal remap="tt">slattach</literal> le permite configurar varios protocolos diferentes con el
argumento <literal remap="tt">-p</literal>. En su caso podrá usar tanto <literal remap="tt">SLIP</literal> como
<literal remap="tt">cSLIP</literal> dependiendo de si quiere o no usar compresión. Nota: ambos
extremos deben estar de acuerdo sobre si usar compresión o no.
</para>

</sect3>

</sect2>

<sect2 id="Servidor-SLIP">
<title>Servidor SLIP.
</title>

<para>
Si tiene una máquina, quizá conectada a una red, a la que le gustaría que otra
máquina pudiese llamar y proporcionar servicios de red, entonces necesita
configurarla como servidor. Si quiere usar SLIP como protocolo de línea serie,
entonces tiene tres opciones para configurar su máquina Linux como servidor
SLIP. Yo preferiría usar la primera presentada, <literal remap="tt">sliplogin</literal>, ya que
parece la más sencilla de configurar y entender, pero presentaré un sumario de
cada una, para que pueda tomar su propia decisión.
</para>

<sect3 id="Servidor-slip-usando-sliplogin">
<title>Servidor slip usando <literal remap="tt">sliplogin</literal>.
</title>

<para>
<literal remap="tt">sliplogin</literal> es un programa, que puede asignar a los usuarios de SLIP en
lugar de un «shell» normal, que convierte una línea terminal en una línea SLIP.
Esto le permite configurar una máquina Linux tanto como <emphasis>servidor de
direcciones estáticas</emphasis>, obteniendo los usuarios la misma dirección cada vez que
llaman, o como <emphasis>servidor de direcciones dinámicas</emphasis>, donde los usuarios
obtienen una dirección que no tiene que ser necesariamente la misma que la
última vez que llamaron.
</para>

<para>
El que llama se registrará igual que en un proceso estándar de <literal remap="tt">login</literal>,
introduciendo su nombre de usuario y contraseña, pero en lugar de presentarle
un intérprete de órdenes normal tras el registro, se ejecuta <literal remap="tt">sliplogin</literal>, el
cual busca en su fichero de configuración (<literal remap="tt">/etc/slip.hosts</literal>) una
entrada con el nombre de usuario que corresponda a la persona que llamó. Si lo
encuentra, entonces configura la línea como «clean» y de 8 bit, y hace una
llamada <emphasis>ioctl</emphasis> para convertir la disciplina de la línea a SLIP. Cuando se
completa este proceso, toma lugar la última parte de la configuración, en la
cual <literal remap="tt">sliplogin</literal> invoca un guión de intérprete de órdenes que configura la
interfaz SLIP con la dirección ip y máscara de red relevantes, y asigna
las rutas apropiadas. Este guión suele llamarse <literal remap="tt">/etc/slip.login</literal>
pero, de forma parecida a <literal remap="tt">getty</literal>, si ciertos usuarios requieren una
iniciación especial, entonces puede crear guiones de configuración llamados
<literal remap="tt">/etc/slip.login.nombreusuario</literal> que serán ejecutados específicamente
para ellos en lugar del que hay por defecto.
</para>

<para>
También hay tres o cuatro ficheros que necesitará configurar para tener
<literal remap="tt">sliplogin</literal> en funcionamiento. Detallaré cómo y dónde obtener los programas
y cómo se configura cada uno. Los ficheros son:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">/etc/passwd</literal>, para las cuentas de los usuarios que llaman.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/etc/slip.hosts</literal>, para almacenar la información única a cada
usuario que llama.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/etc/slip.login</literal>, que lleva la configuración del encaminamiento
que necesite hacerse para el usuario.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/etc/slip.tty</literal>, que será necesario sólo si está configurando el
servidor para asignar direcciones dinámicas y contiene una tabla de direcciones
a asignar.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/etc/slip.logout</literal>, que contiene las órdenes necesarias para dejar
las cosas a punto una vez el usuario cuelgue o cierre la conexión.

</para>
</listitem>

</itemizedlist>

</para>

<sect4>
<title>Dónde obtener <literal remap="tt">sliplogin</literal></title>

<para>
Puede que ya tenga el paquete <literal remap="tt">sliplogin</literal> instalado como parte de su
distribución; si no es así entonces podrá obtenerlo de: <literal remap="tt"><ulink
url="ftp://metalab.unc.edu/pub/linux/system/Network/serial/sliplogin-2.1.1.tar.gz"
>ftp://metalab.unc.edu/pub/linux/system/Network/serial/sliplogin-2.1.1.tar.gz</ulink
></literal>.
El fichero tar contiene tanto las fuentes, como los programas ya compilados y
una página <emphasis>man</emphasis>.
</para>

<para>
para asegurar que sólo son capaces de ejecutar <literal remap="tt">sliplogin</literal> los usuarios
autorizados, debería añadir una entrada al fichero <literal remap="tt">/etc/group</literal> similar
a la siguiente:
</para>

<para>

<screen>
 ..
slip::13:radio,fred
 ..
</screen>

</para>

<para>
Cuando instale el paquete <literal remap="tt">sliplogin</literal>, el <literal remap="tt">Makefile</literal> cambiará el grupo al
que pertenece el programa <literal remap="tt">sliplogin</literal> por <literal remap="tt">slip</literal>, y esto significa que
sólo los usuarios que pertenezcan a ese grupo serán capaces de ejecutarlo. El
ejemplo anterior autorizará ejecutar <literal remap="tt">sliplogin</literal> sólo a los usuarios
<literal remap="tt">radio</literal> y <literal remap="tt">fred</literal>.
</para>

<para>
Para instalar los ejecutables en el directorio <literal remap="tt">/sbin</literal> y la página de
<emphasis>man</emphasis> en la sección 8, haga lo siguiente:
</para>

<para>

<screen>
# cd /usr/src
# gzip -dc .../sliplogin-2.1.1.tar.gz | tar xvf -
# cd sliplogin-2.1.1
# &#60;..edite el Makefile si no usa shadow password..&#62;
# make install
</screen>

</para>

<para>
Si quiere recompilar los ejecutables tras la instalación, añada un <literal remap="tt">make
clean</literal> antes de <literal remap="tt">make install</literal>. Si quiere instalar los ejecutables en
cualquier otro lado, necesitará editar la regla <literal remap="tt">install</literal> en el
<literal remap="tt">Makefile</literal>.
</para>

<para>
Por favor, lea los ficheros <literal remap="tt">README</literal> que vienen con el paquete si quiere
obtener más información.
</para>

</sect4>

<sect4>
<title>Configuración de <literal remap="tt">/etc/passwd</literal> para máquinas que usan Slip.</title>

<para>
Lo normal es que cree algunos <emphasis remap="it">login</emphasis> especiales en el fichero
<literal remap="tt">/etc/passwd</literal> para la gente que llama con Slip. Una convención
comúnmente aceptada es usar el nombre de la máquina que llaman prefijándole una
letra «S» mayúscula. Por tanto, por ejemplo, si la máquina que llama se
denomina <literal remap="tt">radio</literal>, entonces podrías crear una entrada en <literal remap="tt">/etc/passwd</literal>
que se pareciese a:
</para>

<para>

<screen>
Sradio:FvKurok73:1427:1:radio SLIP login:/tmp:/sbin/sliplogin
</screen>

</para>

<para>
Realmente no importa cómo se llame la cuenta, siempre y cuando tenga algún
significado para usted.
</para>

<para>
Nota: el que llama no necesita ningún directorio personal, ya que no se le
presentará ningún intérprete de órdenes, por tanto <literal remap="tt">/tmp</literal> es una buena
elección. Observe también que se usa <literal remap="tt">sliplogin</literal> en lugar de un intérprete
de órdenes normal.
</para>

</sect4>

<sect4>
<title>Configuración de <literal remap="tt">/etc/slip.hosts</literal></title>

<para>
El fichero <literal remap="tt">/etc/slip.hosts</literal> es el fichero en el que <emphasis>sliplogin</emphasis>
busca las entradas que se correspondan al nombre de login que de las que
obtiene los detalles de configuración para esa persona. Es aquí donde
se especifica la dirección ip y la máscara de red que se le asignará al que
llama y que serán configuradas para su uso.  Las entradas para dos máquinas,
una con configuración estática para <literal remap="tt">radio</literal> y otra, con configuración
dinámica, para la máquina <literal remap="tt">albert</literal>, deberían parecerse a lo siguiente:
</para>

<para>

<screen>
#
Sradio   44.136.8.99   44.136.8.100  255.255.255.0  normal      -1
Salbert  44.136.8.99   DYNAMIC       255.255.255.0  compressed  60
#
</screen>

</para>

<para>
Las entradas del fichero <literal remap="tt">/etc/slip.hosts</literal> son
</para>

<para>

<orderedlist>
<listitem>

<para>
el nombre de login del que llama.
</para>
</listitem>
<listitem>

<para>
la dirección ip de la máquina servidor, osea esta máquina.

</para>
</listitem>
<listitem>

<para>
la dirección IP que se asignará al que llama. Si este campo se rellena
con <literal remap="tt">DYNAMIC</literal> entonces se asignará una dirección ip basada en la información
contenida en el fichero <literal remap="tt">/etc/slip.tty</literal> del que se habló antes.
<emphasis remap="bf">Nota:</emphasis> deberá usar al menos la versión <literal remap="tt">1.3</literal> de sliplogin para que esto
funcione.

</para>
</listitem>
<listitem>

<para>
la máscara de red asignada a la máquina que llama en notación decimal
punteada, por ejemplo <literal remap="tt">255.255.255.0</literal> para una máscara de red para una clase
C.

</para>
</listitem>
<listitem>

<para>
las opciones del modo slip, que le permiten activar o desactivar la
compresión y otras características de slip. Los valores permitidos aquí
son <literal remap="tt">normal</literal> y <literal remap="tt">compressed</literal>.

</para>
</listitem>
<listitem>

<para>
un parámetro de <emphasis remap="it">timeout</emphasis> que especifica cuánto tiempo puede estar
ociosa la línea (sin recibir datagramas) antes de que se desconecte la línea.
Un valor negativo desactivará esta característica.

</para>
</listitem>
<listitem>

<para>
argumentos opcionales.
</para>
</listitem>

</orderedlist>

</para>

<para>
Nota: Para los campos 2 y 3 puede usar tanto el nombre de la máquina como su
dirección IP en notación decimal. Si usted usa nombres entonces tendrán que ser
resueltos, esto es, su máquina deberá ser capaz de localizar la dirección ip de
esos nombres o en caso contrario el guión fallará cuando sea ejecutado. Puede
probarlo intentando hacer telnet hacia esos nombres, y si obtiene el mensaje
<literal remap="tt">Trying nnn.nnn.nnn...</literal> entonces es que su máquina ha sido capaz de
encontrar una dirección ip para ese nombre. Si obtiene el mensaje <literal remap="tt">Unknown
host</literal>, entonces no lo consiguió. En este caso, use una dirección ip en notación
decimal o ponga a punto la configuración de su resolutor de nombres. (Ver
sección <xref linkend="Resolucion-de-Nombres"/>).
</para>

<para>
Los modos slip más comunes son:
</para>

<para>
<variablelist>

<varlistentry>
<term>normal</term>
<listitem>
<para>
para habilitar el SLIP normal sin compresión.
</para>
</listitem></varlistentry>
<varlistentry>
<term>compressed</term>
<listitem>
<para>
para habilitar la compresión de cabeceras de
van Jacobsen (cSLIP)
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Por supuesto, son mutuamente exclusivos. Puede usar uno o el otro, pero no
ambos. Para obtener más información sobre las otras opciones disponibles, ve a
las páginas de <literal remap="tt">man</literal>.
</para>

</sect4>

<sect4>
<title>Configuración del fichero <literal remap="tt">/etc/slip.login</literal>.</title>

<para>
Después de que sliplogin haya examinado el <literal remap="tt">/etc/slip.hosts</literal> y
encontrado una entrada que concuerde, intentará ejecutar el fichero
<literal remap="tt">/etc/slip.login</literal> para configurar la interfaz SLIP con su dirección ip y
su máscara.
</para>

<para>
El fichero de ejemplo <literal remap="tt">/etc/slip.login</literal> proporcionado con el paquete
<literal remap="tt">sliplogin</literal> se parece a esto:
</para>

<para>

<screen>
#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90
#
# fichero de login genérico para una línea SLIP. sliplogin
# lo invoca con los parámetros:
#     $1       $2       $3    $4, $5, $6 ...
# unidadSLIP veloctty   pid   los argumentos de la entrada en slip.host
#
/sbin/ifconfig $1 $5 pointopoint $6 mtu 1500 -trailers up
/sbin/route add $6
arp -s $6 &#60;hw_addr&#62; pub
exit 0
#
</screen>

</para>

<para>
Podrá comprobar que este guión se limita a usar las órdenes <literal remap="tt">ifconfig</literal> y
<literal remap="tt">route</literal> para configurar el dispositivo SLIP con su dirección ip,
dirección ip remota y máscara de red y crea una ruta hasta la dirección remota
a través del dispositivo SLIP. Exactamente lo mismo que haría si estuviera
usando la orden <literal remap="tt">slattach</literal>.
</para>

<para>
Advierta también el uso de <emphasis remap="it">Proxy ARP</emphasis> para asegurar que otras
máquinas en la misma Ethernet que la máquina servidora sabrán cómo llegar
a la máquina que llama. El campo <literal remap="tt">&lt;hw_addr&gt;</literal> (dirección hardware)
debería ser la dirección hardware de la tarjeta Ethernet de la máquina. Si su
máquina servidora no está en una red Ethernet, entonces puede eliminar
completamente esa línea.
</para>

</sect4>

<sect4>
<title>Configuración del fichero <literal remap="tt">/etc/slip.logout</literal>.</title>

<para>
Cuando la llamada se corta, querrá asegurarse de que se restaura el estado
normal del dispositivo serie para que otras personas sean capaces más adelante
de registrarse correctamente. Esto se lleva a cabo mediante el uso del fichero
<literal remap="tt">/etc/slip.logout</literal>. Es de formato bastante sencillo y se le llama con
los mismos argumentos que al fichero <literal remap="tt">/etc/slip.login</literal>.
</para>

<para>

<screen>
#!/bin/sh -
#
#               slip.logout
#
/sbin/ifconfig $1 down
arp -d $6
exit 0
#
</screen>

</para>

<para>
Todo lo que hace es desactivar (down) la interfaz, lo que borrará la ruta que
se creó anteriormente. También usa la orden <literal remap="tt">arp</literal> para borrar cualquier
proxy que se estableciese. De nuevo, no necesita la orden <literal remap="tt">arp</literal> en el
guión si su máquina servidora no tiene un puerto ethernet.
</para>

</sect4>

<sect4>
<title>Configuración del fichero <literal remap="tt">/etc/slip.tty.</literal></title>

<para>
Si está usando asignación dinámica de direcciones ip (tiene configurada
cualquier máquina con la palabra clave <literal remap="tt">DYNAMIC</literal> en el fichero
<literal remap="tt">/etc/slip.hosts</literal>, entonces deberá configurar el fichero
<literal remap="tt">etc/slip.tty</literal> para que tenga una lista de las direcciones que se
asignarán a qué puerto. Sólo necesita este fichero si desea que su servidor
asigne de manera dinámica las direcciones a los usuarios.
</para>

<para>
El fichero es una tabla que lista los dispositivos <literal remap="tt">tty</literal> que darán
soporte a las conexiones SLIP y las direcciones ip que deberían asignarse
a los usuarios que llaman a ese puerto.
</para>

<para>
Su formato es como sigue:
</para>

<para>

<screen>
# slip.tty    tty -&#62; correspondencias IP para SLIP dinámico
# formato: /dev/tty?? xxx.xxx.xxx.xxx
#
/dev/ttyS0      192.168.0.100
/dev/ttyS1      192.168.0.101
#
</screen>

</para>

<para>
Lo que dice esta tabla es que a la gente que llame al puerto
<literal remap="tt">/dev/ttyS0</literal> y que tengan la palabra <literal remap="tt">DYNAMIC</literal> en su campo de
dirección remota en el fichero <literal remap="tt">/etc/slip.hosts</literal> les será asignada una
dirección de <literal remap="tt">192.168.0.100</literal>.
</para>

<para>
De esta manera sólo necesita asignar una dirección por puerto para todos los
usuarios que no requieran una dirección dedicada para ellos. Esto le ayuda a
mantener bajo mínimos los números de dirección para evitar su escasez.
</para>

</sect4>

</sect3>

<sect3 id="Servidor-Slip-usando-dip">
<title>Servidor Slip usando <literal remap="tt">dip</literal>.
</title>

<para>
Déjeme empezar diciendo que parte de la información que sigue viene de las
páginas de manual de <literal remap="tt">dip</literal>, donde se documenta brevemente la manera de
usar Linux como servidor SLIP. por favor, preste atención, puesto que lo
siguiente está basado en el paquete <literal remap="tt">dip337o-uri.tgz</literal> y probablemente no
ses aplicable a otrs versiones de <literal remap="tt">dip</literal>.
</para>

<para>
<literal remap="tt">dip</literal> tiene un modo de operación de entrada, en el cual asigna
automáticamente una entrada para el usuario que lo invoque y configura la línea
serie como enlace SLIP de acuerdo con la información que encuentre en el
fichero <literal remap="tt">/etc/dipshosts</literal>. Este modo de operación de entrada se activa
invocando a <literal remap="tt">dip</literal> como <literal remap="tt">diplogin</literal>. Es así por tanto la manera de
usar <literal remap="tt">dip</literal> como servidor SLIP, creando cuentas especiales donde se usa
<literal remap="tt">diplogin</literal> como <emphasis remap="it">login shell</emphasis>.
</para>

<para>
Lo primero que necesita hacer es un enlace simbólico como sigue:
</para>

<para>

<screen>
# ln -sf /usr/sbin/dip /usr/sbin/diplogin
</screen>

</para>

<para>
Después necesitará añadir entradas tanto al fichero <literal remap="tt">/etc/passwd</literal> como
al <literal remap="tt">/etc/diphosts</literal>. Las entradas que necesita hacer tienen el formato
que sigue:
</para>

<para>
Para configurar Linux como servidor SLIP con <literal remap="tt">dip</literal>, se necesita crear
algunas cuentas SLIP especiales para los usuarios, en las que se usa
<literal remap="tt">dip</literal> (en modo entrada) como <emphasis remap="it">login shell</emphasis>. Se sugiere la convención
de comenzar los nombres de las cuentas SLIP con una <literal remap="tt">S</literal> mayúscula, como por
ejemplo <literal remap="tt">Sfredm</literal>.
</para>

<para>
Una entrada en <literal remap="tt">/etc/passwd</literal> para un usuario SLIP se parece a:
</para>

<para>

<screen>
Sfredm:ij/SMxiTlGVCo:1004:10:Fred:/tmp:/usr/sbin/diplogin
^^         ^^        ^^  ^^   ^^   ^^   ^^
|          |         |   |    |    |    \__ diplogin como login shell
|          |         |   |    |    \_______ Directorio `home'
|          |         |   |    \____________ Nombre completo del usuario
|          |         |   \_________________ ID de grupo del usuario
|          |         \_____________________ ID del usuario
|          \_______________________________ Contraseña cifrada
\__________________________________________ Nombre de Login del Usuario SLIP
</screen>

</para>

<para>
Después de que el usuario se registre, el programa <literal remap="tt">login</literal>, si encuentra
y autentica al usuario, ejecutará la orden <literal remap="tt">diplogin</literal>.  <literal remap="tt">dip</literal>,
cuando es invocado como <literal remap="tt">diplogin</literal>, sabe que debe asumir automáticamente
que va a ser usado como intérprete de órdenes de <emphasis remap="it">login</emphasis>. Cuando comienza
como <literal remap="tt">diplogin</literal>, la primera cosa que hace es usar la función
<literal remap="tt">getuid()</literal> para tomar el userid de quien fuera que lo invocó. Entonces
busca en el fichero <literal remap="tt">/etc/diphosts</literal> la primera entrada que se
corresponda bien con el userid, bien con el dispositivo <literal remap="tt">tty</literal> por el que
entró la llamada y se configura apropiadamente. Por razones de sentido común,
para que se pueda dar a un usuario una entrada en el fichero <literal remap="tt">diphosts</literal>,
o bien para que se le dé la configuración por defecto, es posible montar el
servidor de tal manera que se pueda tener una mezcla de usuarios a los que se
asigne la dirección de forma estática o dinámica.
</para>

<para>
<literal remap="tt">dip</literal> añadirá automáticamente una entrada <emphasis remap="it">Proxy-ARP</emphasis> si se le invoca
en modo entrada, por lo que no tendrá que preocuparse de hacerlo manualmente.
</para>

<sect4>
<title>Configuración del fichero /etc/diphosts</title>

<para>
<literal remap="tt">/etc/diphosts</literal> lo usa <literal remap="tt">dip</literal> para buscar configuraciones ya
establecidas para máquinas remotas. Estas máquinas remotas pueden ser usuarios
que llaman a la máquina Linux, o pueden ser máquinas a las que usted llamas
desde su máquina.
</para>

<para>
El formato general para <literal remap="tt">/etc/diphosts</literal> es como sigue:
</para>

<para>

<screen>
 ..
Suwalt::145.71.34.1:145.71.34.2:255.255.255.0:SLIP uwalt:CSLIP,1006
ttyS1::145.71.34.3:145.71.34.2:255.255.255.0:Dynamic ttyS1:CSLIP,296
 ..
</screen>

</para>

<para>
Los campos son:
</para>

<para>

<orderedlist>
<listitem>

<para>
<literal remap="tt">nombre de login</literal>: el que devuelve <literal remap="tt">getpwuid(getuid())</literal> o el
nombre de la tty.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">sin uso</literal>: para compatibilidad con <literal remap="tt">passwd</literal>

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">Dirección Remota</literal>: dirección IP de la máquina que llama, puede
ser tanto la numérica como el nombre.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">Dirección Local</literal>: dirección IP de esta máquina, en número o por
nombre.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">Máscara de red</literal>: en notación decimal puntuada.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">Campo de comentario</literal>: ponga aquí lo que quiera.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">protocolo</literal>: Slip, cSLIP, etc.
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">MTU</literal>: número decimal.

</para>
</listitem>

</orderedlist>

</para>

<para>
Un ejemplo de entrada en <literal remap="tt">/etc/net/diphosts</literal> para un usuario SLIP
remoto podría ser:
</para>

<para>

<screen>
Sfredm::145.71.34.1:145.71.34.2:255.255.255.0:SLIP uwalt:SLIP,296
</screen>

</para>

<para>
lo que especifica un enlace SLIP con dirección remota <literal remap="tt">145.71.34.1</literal> y MTU de
<literal remap="tt">296</literal>, o:
</para>

<para>

<screen>
Sfredm::145.71.34.1:145.71.34.2:255.255.255.0:SLIP uwalt:CSLIP,1006
</screen>

</para>

<para>
que especifica un enlace capaz de usar cSLIP con dirección remota
<literal remap="tt">145.71.34.1</literal> y MTU de <literal remap="tt">1006</literal>.
</para>

<para>
Por tanto, todos los usuarios que desee que tengan asignado un acceso de
llamada con IP estática deberían tener una entrada en <literal remap="tt">/etc/diphosts</literal>.
Si quiere que los usuarios que llaman a un puerto en particular y, que los
detalles sean asignados dinámicamente, deberá tener entonces una entrada para
el dispositivo <literal remap="tt">tty</literal> y no una basada en el usuario. Debería configurar
al menos una entrada para cada dispositivo <literal remap="tt">tty</literal> que usen los usuarios
para asegurar que hay disponible para ellos una configuración adecuada
independientemente al módem al que llamen.
</para>

<para>
Cuando un usuario se registra recibirá las preguntas normales sobre su
cuenta y contraseña en las que debería introducir su userid o contraseña
de SLIP-login. Si se verifican, entonces el usuario no verá mensajes
especiales y sólo tendrá que cambiar el modo SLIP en su extremo. El
usuario debería ser capaz de conectar y quedar configurado con los
parámetros relevantes del fichero <literal remap="tt">diphosts</literal>.
</para>

</sect4>

</sect3>

<sect3 id="Servidor-SLIP-usando-el-paquete-dSLIP">
<title>Servidor SLIP usando el paquete <literal remap="tt">dSLIP</literal>.
</title>

<para>
Matt Dillon, <literal remap="tt"><ulink
url="mailto:dillon@apollo.west.oic.com"
>dillon@apollo.west.oic.com</ulink
></literal> ha escrito un paquete que no sólo hace
llamadas SLIP entrantes sino también llamadas salientes.  El paquete de Matt es
una combinación de pequeños programas y guiones que coordinan las conexiones
por usted. Necesitará tener instalado <literal remap="tt">tcsh</literal> ya que al menos uno de los
guiones lo necesita. Matt proporciona una copia ejecutable de la utilidad
<literal remap="tt">expect</literal> ya que la necesita otro de los guiones. Además necesitará tener
algo de experiencia con <literal remap="tt">expect</literal> para hacer que este paquete funcione a
su gusto, pero no deje que eso le desanime.
</para>

<para>
Matt ha escrito unas instrucciones de instalación muy buenas en el fichero
<literal remap="tt">README</literal>, por lo que no pienso repetirlas.
</para>

<para>
Puede obtener el paquete dSLIP de su sitio de origen:
</para>

<para>
<literal remap="tt"><ulink
url="ftp://apollo.west.oic.com/pub/linux/dillon_src/dSLIP203.tgz"
>ftp://apollo.west.oic.com/pub/linux/dillon_src/dSLIP203.tgz</ulink
></literal>
</para>

<para>
o desde:
</para>

<para>
<literal remap="tt"><ulink
url="ftp://metalab.unc.edu/pub/Linux/system/Network/serial/dSLIP203.tgz"
>ftp://metalab.unc.edu/pub/Linux/system/Network/serial/dSLIP203.tgz</ulink
></literal>
</para>

<para>
Léase el fichero <literal remap="tt">README</literal> y cree las entradas en <literal remap="tt">/etc/passwd</literal> y
<literal remap="tt">/etc/group</literal> antes de hacer <literal remap="tt">make install</literal>.
</para>

</sect3>

</sect2>

</sect1>

<sect1>
<title>Otras tecnologías de red</title>

<para>
Las siguientes subsecciones son específicas a ciertas tecnologías de red.  La
información que contienen no son válidas necesariamente para cualquier otro
tipo de tecnología. Los conceptos están ordenados alfabéticamente.
</para>

<sect2>
<title>ARCNet</title>

<para>
Los nombres de dispositivo ARCNet son <literal remap="tt">arc0e</literal>, <literal remap="tt">arc1e</literal>, <literal remap="tt">arc2e</literal>
etc. o <literal remap="tt">arc0s</literal>, <literal remap="tt">arc1s</literal>, <literal remap="tt">arc2s</literal> etc. A la primera tarjeta detectada
por el núcleo se le asigna <literal remap="tt">arc0e</literal> o <literal remap="tt">arc0s</literal> y el resto es asignado
secuencialmente en el orden en que se detecte. La letra del final identifica si
ha seleccionado el formato de paquete de encapsulación Ethernet o el formato de
paquete especificado en el <emphasis remap="it">RFC 1051</emphasis>.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Network device support  ---&#62;
        [*] Network device support
        &#60;*&#62; ARCnet support
        [ ]   Enable arc0e (ARCnet "Ether-Encap" packet format)
        [ ]   Enable arc0s (ARCnet RFC1051 packet format)
</screen>

</para>

<para>
Una vez que haya compilado el núcleo apropiadamente para admitir su tarjeta
Ethernet, la configuración de la tarjeta es sencilla.
</para>

<para>
Normalmente se usa algo como:
</para>

<para>

<screen>
# ifconfig arc0e 192.168.0.1 netmask 255.255.255.0 up
# route add -net 192.168.0.0 netmask 255.255.255.0 arc0e
</screen>

</para>

<para>
Lea, por favor, los ficheros
<literal remap="tt">/usr/src/linux/Documentation/networking/arcnet.txt</literal> y
<literal remap="tt">/usr/src/linux/Documentation/networking/arcnet-hardware.txt</literal> si desea
obtener más información.
</para>

<para>
La implementación de ARCNet fue desarrollada por Avery Pennarun,
<literal remap="tt"><ulink
url="mailto:lapenwarr@foxnet.net"
>lapenwarr@foxnet.net</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>Appletalk (<literal remap="tt">AF_APPLETALK</literal>)</title>

<para>
La implementación de Appletalk no utiliza nombres especiales para sus
dispositivos ya que usa otros ya existentes.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Networking options  ---&#62;
        &#60;*&#62; Appletalk DDP
</screen>

</para>

<para>
Trabajar con Appletalk permite a una máquina Linux interconectar con redes
Apple. Una utilidad importante que se saca de esto es poder compartir recursos
tales como impresoras y discos entre una máquina Linux y ordenadores Apple. Se
necesita un programa adicional, que se llama <emphasis>netatalk</emphasis>. Wesley Craig
<literal remap="tt"><ulink
url="mailto:netatalk@umich.edu"
>netatalk@umich.edu</ulink
></literal>
representa a un equipo llamado el <emphasis remap="it">Research Systems Unix Group</emphasis>, de la
Universidad de Michigan y han creado el paquete <emphasis>netatalk</emphasis>, que proporciona
programas que implementan la pila del protocolo Appletalk y algunas utilidades.
El paquete <emphasis>netatalk</emphasis> viene en su distribución de Linux, y si no, lo puede
encontrar en su servidor de origen, en la Universidad de Michigan <literal remap="tt"><ulink
url="ftp://terminator.rs.itd.umich.edu/unix/netatalk/"
>ftp://terminator.rs.itd.umich.edu/unix/netatalk/</ulink
></literal>.
</para>

<para>
Para compilar e instalar el paquete haga algo como esto:
</para>

<para>

<screen>
user% tar xvfz .../netatalk-1.4b2.tar.Z
user% make
root# make install
</screen>

</para>

<para>
Puede que quiera editar el <literal remap="tt">Makefile</literal> antes de ejecutar <literal remap="tt">make</literal>.
Principalmente para cambiar la variable <literal remap="tt">DESTDIR</literal>, que define el lugar donde
serán instalados los ficheros. El directorio por defecto
<literal remap="tt">/usr/local/atalk</literal> suele ser una buena elección.
</para>

<sect3>
<title>Configuración del software Appletalk.</title>

<para>
La primera cosa que tiene que hacer para que todo funcione es asegurarse de que
están presentes las entradas apropiadas en el fichero <literal remap="tt">/etc/services</literal>.
La entradas que necesita son:
</para>

<para>

<screen>
rtmp  1/ddp   # Routing Table Maintenance Protocol
nbp   2/ddp   # Name Binding Protocol
echo  4/ddp   # AppleTalk Echo Protocol
zip   6/ddp   # Zone Information Protocol
</screen>

</para>

<para>
El siguiente paso es crear los ficheros de configuración de Appletalk en el
directorio <literal remap="tt">/usr/local/atalk/etc</literal> (o donde haya instalado el paquete).
</para>

<para>
El primer fichero a crear es el <literal remap="tt">/usr/local/atalk/etc/atalkd.conf</literal>.  En
principio, este fichero sólo necesita una línea que da el nombre del
dispositivo a través del cual se accede a la red donde están tus máquinas
Apple.
</para>

<para>

<screen>
eth0
</screen>

</para>

<para>
El demonio Appletalk añadirá más detalles después de ejecutarse.
</para>

</sect3>

<sect3>
<title>Exportación de un sistema de ficheros Linux vía Appletalk.</title>

<para>
Existe la posibilidad de exportar sistemas de ficheros desde una máquina Linux
a la red para que las máquinas Apple en la red puedan compartirlos.
</para>

<para>
Para hacerlo tiene que configurar el fichero
<literal remap="tt">/usr/local/atalk/etc/AppleVolumes.system</literal>. Hay otro fichero de
configuración llamado <literal remap="tt">/usr/local/atalk/etc/AppleVolumes.default</literal>, que
tiene exactamente el mismo formato y describe qué sistemas de archivos
recibirán los usuarios que conecten con privilegios de invitado.
</para>

<para>
Puede encontrar todos los detalles de configuración de estos ficheros y qué
significa cada opción en la página de manual del <literal remap="tt">afpd</literal>.
</para>

<para>
Un ejemplo sencillo podría parecerse a esto:
</para>

<para>

<screen>
/tmp Scratch
/home/ftp/pub "Espacio Público"
</screen>

</para>

<para>
Que exportaría su sistema de ficheros <literal remap="tt">/tmp</literal> como el Volumen AppleShare
<literal remap="tt">Scratch</literal> y el directorio público de FTP como el Volumen AppleShare
<literal remap="tt">Espacio Público</literal>. Los nombres de volumen no son obligatorios, el demonio
elegirá un nombre por defecto, pero no le va a morder si lo especifica.
</para>

</sect3>

<sect3>
<title>Compartir la impresora Linux a través de Appletalk.</title>

<para>
Puede compartir una impresora linux con máquinas Apple de manera bastante
sencilla. Necesita ejecutar el programa <literal remap="tt">papd</literal> que es el <emphasis remap="it">Printer
Access Protocol Daemon</emphasis> de Appletalk. Cuando ejecute este programa, aceptará
peticiones de las máquinas Apple y meterá la tarea de impresión en la cola del
demonio de la impresora local para ser impreso.  
Debe editar el fichero <literal remap="tt">/usr/local/atalk/etc/papd.conf</literal> para configurar
el demonio. La sintaxis de este fichero es la misma que la del fichero
<literal remap="tt">/etc/printcap</literal>. El nombre que le dé a la definición se registrado con
el protocolo de nombres de Appletalk, NBP.
</para>

<para>
Un ejemplo de configuración podría ser como éste:
</para>

<para>

<screen>
TricWriter:\
   :pr=lp:op=cg:
</screen>

</para>

<para>
Que pondría a disposición de la red Appletalk la impresora <literal remap="tt">TricWriter</literal> y
todos los trabajos aceptados serían impresos en la impresora linux <literal remap="tt">lp</literal>
(definida en el fichero <literal remap="tt">/etc/printcap</literal>) usando <literal remap="tt">lpd</literal>. La entrada
<literal remap="tt">op=cg</literal> dice que el usuario de Linux <literal remap="tt">cg</literal> es el operador de la
impresora.
</para>

</sect3>

<sect3>
<title>Ejecución de AppleTalk.</title>

<para>
Muy bien, ahora debería estar preparado para probar esta configuración básica.
Hay un fichero <literal remap="tt">rc.atalk</literal> proporcionado con el paquete <literal remap="tt">netatalk</literal>
que debería funcionar bien, por lo que todo lo que tiene que hacer es:
</para>

<para>

<screen>
root# /usr/local/atalk/etc/rc.atalk
</screen>

</para>

<para>
y todo debería comenzar y ejecutarse bien. No debería ver mensajes de error y
el software enviará mensajes a la consola indicando cada etapa según comienza.
</para>

</sect3>

<sect3>
<title>Comprobación de AppleTalk.</title>

<para>
Para comprobar que el software está funcionando adecuadamente, vaya a una de
las máquinas Apple, abra el menú Apple, seleccione el <emphasis remap="it">Chooser</emphasis>, pulse sobre
<emphasis remap="it">AppleShare</emphasis>, y debería aparecer la máquina Linux.
</para>

</sect3>

<sect3>
<title>Problemas con AppleTalk.</title>

<para>

<itemizedlist>
<listitem>

<para>
Puede que necesite ejecutar el software Appletalk antes de configurar la
red IP. Si tiene problemas ejecutando los programas Appletalk, o si después de
ejecutarlo tiene problemas con la red IP, entonces intente ejecutar los
programas Appletalk antes de ejecutar el fichero <literal remap="tt">rc</literal> correspondiente.


</para>
</listitem>
<listitem>

<para>
El <literal remap="tt">afpd</literal> (<emphasis remap="it">Apple Filing Protocol Daemon</emphasis>) desordena mucho el
disco duro. Bajo el punto de montaje crea un par de directorios llamados
<literal remap="tt">.AppleDesktop</literal> y <literal remap="tt">Network Trash Folder</literal>. Además, por cada
directorio al que acceda creará un <literal remap="tt">.AppleDouble</literal> bajo él de manera que
pueda almacenar <emphasis remap="it">resource forks</emphasis>, etc. Por tanto, piénselo dos veces antes
de exportar <literal remap="tt">/</literal>, o se pasará un rato borrando después.

</para>
</listitem>
<listitem>

<para>
El programa <literal remap="tt">afpd</literal> espera que las claves que vengan de los Mac
estén sin cifrar. Esto podría ser un problema de seguridad; por tanto, sea
cuidadoso cuando ejecute este demonio en una máquina conectada a Internet, o
sufrirá las consecuencias si algún indeseable decide hacerle alguna maldad.

</para>
</listitem>
<listitem>

<para>
Las herramientas de diagnóstico existentes como <literal remap="tt">netstat</literal> e
<literal remap="tt">ifconfig</literal> no soportan Appletalk. La información «en bruto» está
disponible en el directorio <literal remap="tt">/proc/net</literal> si tuviese necesidad de ella.

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

<sect3>
<title>Si necesitase más información...</title>

<para>
  
</para>

<para>
Eche un vistazo a la página del <emphasis>Linux Netatalk-Howto</emphasis> de Anders Brownworth
si quiere una descripción más detallada de cómo configurar Appletalk para Linux
en <literal remap="tt"><ulink
url="http://thehamptons.com/anders/netatalk/"
>http://thehamptons.com/anders/netatalk</ulink
></literal>.
</para>

</sect3>

</sect2>

<sect2>
<title>ATM</title>

<para>
Werner Almesberger, <literal remap="tt"><ulink
url="mailto:werner.almesberger@lrc.di.epfl.ch"
>werner.almesberger@lrc.di.epfl.ch</ulink
></literal> está dirigiendo un proyecto para
proporcionar una implementación del <emphasis remap="it">Asynchronous Transfer Mode</emphasis> en Linux.
Puede obtener información actualizada sobre el estado del proyecto en:
<literal remap="tt"><ulink
url="http://lrcwww.epfl.ch/linux-atm/"
>http://lrcwww.epfl.ch/linux-atm</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>AX25 (<literal remap="tt">AF_AX25</literal>)</title>

<para>
Los nombres de los dispositivos AX.25 son <literal remap="tt">sl0</literal>, <literal remap="tt">sl1</literal>, etc. en los
núcleos <literal remap="tt">2.0.*</literal> y <literal remap="tt">ax0</literal>, <literal remap="tt">ax1</literal>, etc. a partir de los núcleos
<literal remap="tt">2.1.*</literal>.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Networking options  ---&#62;
        [*] Amateur Radio AX.25 Level 2
</screen>

</para>

<para>
Los protocolos AX25, Netrom y Rose están cubiertos por el <literal remap="tt"><ulink
url="AX25-HOWTO.html"
>AX25 Howto</ulink
></literal>.  Estos protocolos son usados por
los Operadores de Amateur Radio de todo el mundo para experimentar con packet
radio.
</para>

<para>
La mayoría del trabajo de implementación de estos protocolos lo ha hecho
Jonathon Naylor, <literal remap="tt"><ulink
url="mailto:jsn@cs.nott.ac.uk"
>sn@cs.nott.ac.uk</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>DECNet</title>

<para>
Actualmente se está trabajando en la implementación de DECNet. Debería aparecer
en algún núcleo <literal remap="tt">2.1.*</literal> tardío.
</para>

</sect2>

<sect2>
<title>FDDI</title>

<para>
Los nombres de dispositivo FDDI son <literal remap="tt">fddi0</literal>, <literal remap="tt">fddi1</literal>, <literal remap="tt">fddi2</literal>, etc. A
la primera tarjeta detectada por el núcleo se le asigna <literal remap="tt">fddi0</literal> y al resto
se le asigna secuencialmente en el orden en que son detectadas.
</para>

<para>
Lawrence V. Stefani, <literal remap="tt"><ulink
url="mailto:larry_stefani@us.newbridge.com"
>larry_stefani@us.newbridge.com</ulink
></literal>, ha desarrollado un controlador
para las tarjetas FDDI EISA y PCI de <emphasis remap="it">Digital Equipment Corporation</emphasis>.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Network device support  ---&#62;
        [*] FDDI driver support
        [*] Digital DEFEA and DEFPA adapter support
</screen>

</para>

<para>
Cuando tenga el núcleo compilado para trabajar con el controlador FDDI e
instalado, la configuración de la interfaz FDDI es casi idéntica al de una
interfaz Ethernet. Simplemente ha de especificar la interfaz FDDI apropiada en
las órdenes <literal remap="tt">ifconfig</literal> y <literal remap="tt">route</literal>.
</para>

</sect2>

<sect2>
<title>Retransmisión de Tramas (<literal remap="tt">Frame Relay</literal>)</title>

<para>
Los nombres de dispositivo Frame Relay son <literal remap="tt">dlci00</literal>, <literal remap="tt">dlci01</literal>, etc para
los dispositivos de encapsulación DLCI y <literal remap="tt">sdla0</literal>, <literal remap="tt">sdla1</literal>, etc para los
FRAD.
</para>

<para>
El Frame Relay (Retransmisión de tramas) es una tecnología de red diseñada para
ajustarse al tráfico de comunicación de datos que es de naturaleza «explosiva»
o intermitente. La conexión a una red Frame Relay se realiza usando un
<emphasis remap="it">Frame Relay Access Device</emphasis> (FRAD). El Linux Frame Relay implementa IP sobre
Frame Relay según se describe en el <emphasis remap="it">RFC-1490</emphasis>.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Network device support  ---&#62;
        &#60;*&#62; Frame relay DLCI support (EXPERIMENTAL)
        (24)   Max open DLCI
        (8)   Max DLCI per device
        &#60;*&#62;   SDLA (Sangoma S502/S508) support
</screen>

</para>

<para>
Mike McLagan, <literal remap="tt"><ulink
url="mailto:mike.mclagan@linux.org"
>mike.mclagan@linux.org</ulink
></literal>, desarrolló el soporte de Frame Relay y las
herramientas de configuración.
</para>

<para>
Actualmente los únicos FRAD soportados son los <literal remap="tt">S502A</literal>, <literal remap="tt">S502E</literal> y
<literal remap="tt">S508</literal> de <emphasis remap="it">Sangoma Technologies</emphasis> <literal remap="tt"><ulink
url="http://www.sangoma.com/"
>http://www.sangoma.com</ulink
></literal> Para
configurar los dispositivos FRAD y DLCI después de haber recompilado el núcleo
necesitará las herramientas de configuración Frame Relay. Están disponibles en
<literal remap="tt"><ulink
url="ftp://ftp.invlogic.com/pub/linux/fr/frad-0.15.tgz"
>ftp://ftp.invlogic.com/pub/linux/fr/frad-0.15.tgz</ulink
></literal>. Compilar e
instalar las herramientas es algo muy sencillo, pero la carencia de un fichero
<literal remap="tt">Makefile</literal> para todo lo convierte en un proceso básicamente manual:
</para>

<para>

<screen>
user% tar xvfz .../frad-0.15.tgz
user% cd frad-0.15
user% for i in common dlci frad; make -C $i clean; make -C $i; done
root# mkdir /etc/frad
root# install -m 644 -o root -g root bin/*.sfm /etc/frad
root# install -m 700 -o root -g root frad/fradcfg /sbin
root# install -m 700 -o root -g root dlci/dlcicfg /sbin
</screen>

</para>

<para>
Tenga en cuenta que estas órdenes usan sintaxis de <literal remap="tt">sh</literal>. Si utiliza un
intérprete de órdenes tipo <literal remap="tt">csh</literal> (como <literal remap="tt">tcsh</literal>), el bucle <literal remap="tt">for</literal> será
diferente.
</para>

<para>
Después de instalar las herramientas necesitará crear un fichero
<literal remap="tt">/etc/frad/router.conf</literal>. Puede usar esta plantilla, que es una versión
modificada de uno de los ficheros de ejemplo:
</para>

<para>

<screen>
# /etc/frad/router.conf
# Esta es una plantilla de configuración para retransmisión de tramas.
# Se incluyen todas las etiquetas. Los valores por defecto están basados
# en el código proporcionado con los controladores DOS para la tarjeta
# Sangoma S502A.
#
# Un '#' en cualquier parte de una línea constituye un comentario
# Los espacios en blanco son ignorados (puede indentar con tabuladores
# también)
# Las entradas [] y claves desconocidas son ignoradas
#

[Devices]
Count=1                 # Número de dispositivos a configurar
Dev_1=sdla0             # el nombre del dispositivo
#Dev_2=sdla1            # el nombre del dispositivo
  
# Lo especificado aquí es aplicado a todos los dispositivos y puede ser
# cambiado para cada tarjeta en particular.
#
Access=CPE
Clock=Internal
KBaud=64
Flags=TX
#
# MTU=1500              # Máxima longitud del IFrame, por defecto 4096
# T391=10               # valor T391    5 - 30, por defecto 10
# T392=15               # valor T392    5 - 30, por defecto 15
# N391=6                # valor N391    1 - 255, por defecto 6
# N392=3                # valor N392    1 - 10, por defecto 3
# N393=4                # valor N393    1 - 10, por defecto 4

# Lo especificado aquí da los valores por defecto para todas las tarjetas
# CIRfwd=16             # CIR forward   1 - 64
# Bc_fwd=16             # Bc forward    1 - 512
# Be_fwd=0              # Be forward    0 - 511
# CIRbak=16             # CIR backward  1 - 64
# Bc_bak=16             # Bc backward   1 - 512
# Be_bak=0              # Be backward   0 - 511

#
#
# Configuración específica para el dispositivo
#
#

#
# El primer dispositivo es un Sangoma S502E
#
[sdla0]
Type=Sangoma            # Tipo del dispositivo a configurar, actualmente
                        # sólo se reconoce SANGOMA
#
# Estas claves son específicas al tipo "Sangoma"
#
# El tipo de tarjeta Sangoma - S502A, S502E, S508
Board=S502E
#
# El nombre del firmware de prueba para la tarjeta Sangoma
# Testware=/usr/src/frad-0.10/bin/sdla_tst.502
#
# El nombre del firmware FR 
# Firmware=/usr/src/frad-0.10/bin/frm_rel.502
#
Port=360                # Puerto de esta tarjeta
Mem=C8                  # Dirección de la memoria, A0-EE, depende
IRQ=5                   # Número de la IRQ, no especificar para la S502A
DLCIs=1                 # Número de DLCI asociados al dispositivo
DLCI_1=16               # Número del DLCI nº 1, 16 - 991
# DLCI_2=17
# DLCI_3=18
# DLCI_4=19
# DLCI_5=20
#
# Lo especificado aquí se aplica a este dispositivo nada más y
# prevalece sobre los valores por defecto
#
# Access=CPE            # CPE o NODE, por defecto CPE
# Flags=TXIgnore,RXIgnore,BufferFrames,DropAborted,Stats,MCI,AutoDLCI
# Clock=Internal        # External o Internal, por defecto Internal
# Baud=128              # Tasa en baudios del CSU/DSU asociado
# MTU=2048              # Longitud máxima del IFrame, por defecto 4096
# T391=10               # valor T391    5 - 30, por defecto 10
# T392=15               # valor T392    5 - 30, por defecto 15
# N391=6                # valor N391    1 - 255, por defecto 6
# N392=3                # valor N392    1 - 10, por defecto 3
# N393=4                # valor N393    1 - 10, por defecto 4

#
# El segundo dispositivo es otra tarjeta
#
# [sdla1]
# Type=FancyCard        # Type of the device to configure.
# Board=                # Type of Sangoma board
# Key=Value             # values specific to this type of device

#
# DLCI Default configuration parameters
# These may be overridden in the DLCI specific configurations
#
CIRfwd=64               # CIR forward   1 - 64
# Bc_fwd=16             # Bc forward    1 - 512
# Be_fwd=0              # Be forward    0 - 511
# CIRbak=16             # CIR backward  1 - 64
# Bc_bak=16             # Bc backward   1 - 512
# Be_bak=0              # Be backward   0 - 511

#
# DLCI Configuration
# These are all optional. The naming convention is
# [DLCI_D&#60;devicenum&#62;_&#60;DLCI_Num&#62;]
#

[DLCI_D1_16]
# IP=
# Net=
# Mask=
# Flags defined by Sangoma: TXIgnore,RXIgnore,BufferFrames
# DLCIFlags=TXIgnore,RXIgnore,BufferFrames
# CIRfwd=64
# Bc_fwd=512
# Be_fwd=0
# CIRbak=64
# Bc_bak=512
# Be_bak=0

[DLCI_D2_16]
# IP=
# Net=
# Mask=
# Flags defined by Sangoma: TXIgnore,RXIgnore,BufferFrames
# DLCIFlags=TXIgnore,RXIgnore,BufferFrames
# CIRfwd=16
# Bc_fwd=16
# Be_fwd=0
# CIRbak=16
# Bc_bak=16
# Be_bak=0
</screen>

</para>

<para>
Cuando haya terminado el fichero <literal remap="tt">/etc/frad/router.conf</literal>, el único paso
que queda es configurar el dispositivo en sí. Esto es sólo un poco más complejo
que la configuración de un dispositivo de red normal. Debe recordar activar el
dispositivo FRAD antes que los dispositivos de encapsulación DLCI. Es mejor que
ponga estas órdenes en un guión, ya que son muchos:
</para>

<para>

<screen>
#!/bin/sh
# Configurar los parámetros del frad y los DLCI
/sbin/fradcfg /etc/frad/router.conf || exit 1
/sbin/dlcicfg file /etc/frad/router.conf
#
# Activar el dispositivo FRAD
ifconfig sdla0 up
#
# Configurar los dispositivos de encapsulación DLCI
ifconfig dlci00 192.168.10.1 pointopoint 192.168.10.2 up
route add -net 192.168.10.0 netmask 255.255.255.0 dlci00
#
ifconfig dlci01 192.168.11.1 pointopoint 192.168.11.2 up
route add -net 192.168.11.0 netmask 255.255.255.0 dlci00
#
route add default dev dlci00
#
</screen>

</para>

</sect2>

<sect2>
<title>IPX (<literal remap="tt">AF_IPX</literal>)</title>

<para>
El protocolo IPX se usa comúnmente en entornos de redes de área local Novell
Netware(tm). Linux incluye una implementación de este protocolo y puede ser
configurado para actuar como punto final en una red, o como encaminador de IPX.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Networking options  ---&#62;
        [*] The IPX protocol
        [ ] Full internal IPX network
</screen>

</para>

<para>
Los protocolos IPX y el NCPFS están cubiertos en gran profundidad en el
<literal remap="tt"><ulink
url="IPX-HOWTO.html"
>IPX Howto</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>NetRom (<literal remap="tt">AF_NETROM</literal>)</title>

<para>
Los nombres de los dispositivos NetRom son <literal remap="tt">nr0</literal>, <literal remap="tt">nr1</literal>, etc.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Networking options  ---&#62;
        [*] Amateur Radio AX.25 Level 2
        [*] Amateur Radio NET/ROM
</screen>

</para>

<para>
Los protocolos AX25, Netrom y Rose están cubiertos en el <literal remap="tt"><ulink
url="AX25-HOWTO.html"
>AX25 Howto</ulink
></literal>. Estos protocolos los usan
Operadores de Amateur Radio de todo el mundo en la experimentación de
<emphasis remap="it">packet radio</emphasis>.
</para>

<para>
La mayoría del trabajo de la implementación de estos protocolos lo ha
Jonathon Naylor, <literal remap="tt"><ulink
url="mailto:jsn@cs.nott.ac.uk"
>jsn@cs.nott.ac.uk</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>Protocolo Rose (<literal remap="tt">AF_ROSE</literal>)</title>

<para>
Los nombres de los dispositivos Rose son <literal remap="tt">rs0</literal>, <literal remap="tt">rs1</literal>, etc, en los
núcleos <literal remap="tt">2.1.*</literal>. Rose está disponible a partir de los núcleos <literal remap="tt">2.1.*</literal>.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Networking options  ---&#62;
        [*] Amateur Radio AX.25 Level 2
        &#60;*&#62; Amateur Radio X.25 PLP (Rose)
</screen>

</para>

<para>
Los protocolos AX25, Netrom y Rose están cubiertos por el <literal remap="tt"><ulink
url="AX25-HOWTO.html"
>AX25 Howto</ulink
></literal>. Estos protocolos los usan
Operadores de Amateur Radio de todo el mundo en la experimentación de
<emphasis remap="it">packet radio</emphasis>.
</para>

<para>
La mayoría del trabajo de la implementación de estos protocolos lo ha
hecho Jonathon Naylor, <literal remap="tt"><ulink
url="mailto:jsn@cs.nott.ac.uk"
>jsn@cs.nott.ac.uk</ulink
></literal>. 
</para>

</sect2>

<sect2>
<title>Soporte SAMBA - NetBEUI, NetBios.</title>

<para>
SAMBA es una implementación del protocolo <emphasis remap="it">Session Management Block</emphasis>.  Samba
permite que los sistemas de Microsoft (y otros) monten y usen sus discos e
impresoras.
</para>

<para>
SAMBA y su configuración vienen cubiertos en detalle en el <literal remap="tt"><ulink
url="http://www.insflug.org/documentos/Samba-Como/"
>http://www.insflug.org/documentos/Samba-Como/</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>Soporte de STRIP (<emphasis remap="it">Starmode Radio IP</emphasis>)</title>

<para>
Los nombres de los dispositivos STRIP son <literal remap="tt">st0</literal>, <literal remap="tt">st1</literal>, etc.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Network device support  ---&#62;
        [*] Network device support
        ....
        [*] Radio network interfaces
        &#60; &#62; STRIP (Metricom starmode radio IP)
</screen>

</para>

<para>
STRIP es un protocolo diseñado específicamente para un rango de radio-módems
Metricon para un proyecto de investigación conducido por la Universidad de
Stanford llamado MosquitoNet Project <literal remap="tt"><ulink
url="http://mosquitonet.Stanford.EDU/mosquitonet.html"
>http://mosquitonet.Stanford.EDU/mosquitonet.html</ulink
></literal>. Es muy
interesante leerse esto, incluso si no está interesado directamente en el
proyecto.
</para>

<para>
Las radios Metricon se conectan a un puerto serie, emplean tecnología de
espectro amplio y suelen ser capaces de alcanzar los 100kbps. Hay información
disponible acerca de las radios Metricon en el servidor Web de Metricon
<literal remap="tt"><ulink
url="http://www.metricom.com/"
>http://www.metricom.com</ulink
></literal>.
</para>

<para>
En estos momentos las herramientas y utilidades estándar de red no implementan
el controlador STRIP, por lo que deberá obtener algunas herramientas preparadas
desde el servidor WWW de MosquitoNet. Los detalles sobre los programas que
necesitará están disponibles en la página de MosquitoNet sobre STRIP
<literal remap="tt"><ulink
url="http://mosquitonet.Stanford.EDU/strip.html"
>http://mosquitonet.Stanford.EDU/strip.html</ulink
></literal>.
</para>

<para>
En resumen de la configuración, use un programa <literal remap="tt">slattach</literal> modificado para
establecer STRIP como la disciplina de línea de un dispositivo serie tty y
entonces configurar el dispositivo <literal remap="tt">st[0-9]</literal> resultante igual que haría con
uno Ethernet con una excepción importante: por razones técnicas, STRIP no
soporta el protocolo ARP, por lo que deberá configurar manualmente las entradas
ARP de cada una de las máquinas en la subred.  Esto no debería ser demasiado
oneroso.
</para>

</sect2>

<sect2>
<title>Anillo con testigo (<emphasis remap="it">Token Ring</emphasis>)</title>

<para>
Los nombres de los dispositivos de anillo con testigo son <literal remap="tt">tr0</literal>, <literal remap="tt">tr1</literal>,
etc. El anillo con testigo es un protocolo de red LAN estándar de IBM que evita
colisiones proporcionando un mecanismo que permite que sólo una de las
estaciones en la red tenga en un momento determinado derecho a transmitir. Una
estación mantiene un «testigo» (<emphasis remap="it">token</emphasis>) durante un tiempo determinado y ésa
es la única con permiso para transmitir.  Cuando ha transmitido los datos le
pasa el testigo a la siguiente estación.  El testigo traza un bucle entre todas
las estaciones activas, de ahí el nombre de «Anillo con Testigo».
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
    Network device support  ---&#62;
        [*] Network device support
        ....
        [*] Token Ring driver support
        &#60; &#62; IBM Tropic chipset based adaptor support
</screen>

</para>

<para>
La configuración de un anillo con testigo es idéntica a la de una Ethernet con
la excepción del nombre de los dispositivos a configurar.
</para>

</sect2>

<sect2>
<title>X.25</title>

<para>
El X.25 es un protocolo de circuitos basados en conmutación de paquetes
definido por el <literal remap="tt">C.C.I.T.T.</literal> (una organización de estándares reconocida por
compañías de Telecomunicaciones en la mayor parte del mundo). En estos momentos
está en funcionamiento una implementación de X.25 y LAPB y los núcleos
<literal remap="tt">2.1.*</literal> más recientes incluyen el trabajo que está en progreso.
</para>

<para>
Jonathon Naylor <literal remap="tt"><ulink
url="mailto:jsn@cs.nott.ac.uk"
>jsn@cs.nott.ac.uk</ulink
></literal> está liderando el desarrollo y se ha establecido
una lista de correo para discutir materias relativas al X.25 en Linux. Para
suscribirse, envíe un mensaje a: <literal remap="tt"><ulink
url="mailto:majordomo@vger.rutgers.edu"
>majordomo@vger.rutgers.edu</ulink
></literal>
con el texto <literal remap="tt">subscribe linux-x25</literal> en el cuerpo del mensaje.
</para>

<para>
Se pueden obtener las primeras versiones de las herramientas de configuración
desde el sitio de FTP de Jonathon en <literal remap="tt"><ulink
url="ftp://ftp.cs.nott.ac.uk/jsn/"
>ftp://ftp.cs.nott.ac.uk/jsn</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>Tarjeta WaveLan</title>

<para>
Los nombres de los dispositivos Wavelan son <literal remap="tt">eth0</literal>, <literal remap="tt">eth1</literal>, etc.
</para>

<para>
<emphasis remap="bf">Opciones de Compilación del Núcleo</emphasis>:
</para>

<para>

<screen>
Network device support  ---&#62;
    [*] Network device support
    ....
    [*] Radio network interfaces
    ....
    &#60;*&#62; WaveLAN support
</screen>

</para>

<para>
La tarjeta WaveLAN es una tarjeta de red LAN inalámbrica de amplio espectro. La
tarjeta se parece bastante en la práctica a una tarjeta Ethernet y se configura
de la misma manera.
</para>

<para>
Puede obtener información acerca de la tarjeta Wavelan de Wavelan.com
<literal remap="tt"><ulink
url="http://www.wavelan.com/"
>http://www.wavelan.com</ulink
></literal>.
</para>

</sect2>

</sect1>

<sect1>
<title>Cables y Cableado</title>

<para>
Aquellos de ustedes que se manejen con un soldador puede que quieran construir
sus propios cables para interconectar dos máquinas Linux.  Los siguientes
diagramas de cableado deberían serles de ayuda.
</para>

<sect2>
<title>Cable serie Módem NULO (NULL Modem)</title>

<para>
No todos los cables Módem NULO son iguales. Muchos cables módem nulo hacen poco
más que un pequeño truco para que el ordenador crea que están presentes todas
las señales apropiadas, cruzando los cables de transmisión y recepción. Esto
vale, pero significa que deberá usar programas de control de flujo software
(XON/XOFF), que es menos eficiente que el control de flujo hardware. El
siguiente cable proporciona la mejor señalización posible entre las máquinas y
permite usar control de flujo por hardware (RTS/CTS).
</para>

<para>

<screen>
Nombre Patilla Patilla                           Patilla
 Datos Tx       2  -----------------------------  3
 Datos Rx       3  -----------------------------  2
 RTS            4  -----------------------------  5
 CTS            5  -----------------------------  4
 Tierra         7  -----------------------------  7
 DTR            20 -\---------------------------  8
 DSR            6  -/
 RLSD/DCD       8  ---------------------------/-  20
                                              \-  6
</screen>

</para>

</sect2>

<sect2>
<title>Cable de puerto paralelo (cable PLIP)</title>

<para>
Si pretende usar el protocolo PLIP entre dos máquinas, entonces este cable 
funcionará independientemente del tipo de puertos paralelos que tenga
instalados.
</para>

<para>

<screen>
Nombre Patilla  Patilla        Patilla
 STROBE         1*
 D0-&#62;ERROR      2  ----------- 15
 D1-&#62;SLCT       3  ----------- 13
 D2-&#62;PAPOUT     4  ----------- 12
 D3-&#62;ACK        5  ----------- 10
 D4-&#62;BUSY       6  ----------- 11
 D5             7*
 D6             8*
 D7             9*
 ACK-&#62;D3        10 ----------- 5
 BUSY-&#62;D4       11 ----------- 6
 PAPOUT-&#62;D2     12 ----------- 4
 SLCT-&#62;D1       13 ----------- 3
 FEED           14*
 ERROR-&#62;D0      15 ----------- 2
 INIT           16*
 SLCTIN         17*
 GROUND         25 ----------- 25
</screen>

</para>

<para>
Notas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
No conecte las patillas marcadas con un asterisco, <literal remap="tt">*</literal>.
</para>
</listitem>
<listitem>

<para>
Las tomas de tierra extra son 18,19,20,21,22,23 y 24.

</para>
</listitem>
<listitem>

<para>
Si el cable que está usando tiene apantallamiento metálico, debería estar
conectado a la carcasa DB-25 en <emphasis remap="bf">sólo uno</emphasis> de los extremos.

</para>
</listitem>

</itemizedlist>

</para>

<para>
<emphasis remap="bf">Cuidado: Un cable PLIP mal hecho puede destruir la tarjeta</emphasis>
controladora. Sea muy cuidadoso y examine dos veces cada conexión para
asegurarse de que no va a hacer más trabajo ni a llevarse más infartos de lo
necesario.
</para>

<para>
Aunque puede que sea capaz de tener cables PLIP para grandes distancias,
debería evitarlo. Las especificaciones del cable permiten una longitud de
alrededor de 1 metro. Por favor, tenga mucho cuidado cuando tienda cables PLIP
largos, ya que las fuentes de campos electromagnéticos fuertes, como los rayos,
cables de corriente y emisoras de radio pueden interferir en los controladores,
y a veces dañarlos. Si realmente quiere conectar dos ordenadores a larga
distancia, debería intentar obtener un par de tarjetas Ethernet para thin-net
(red de cable fino) y tender cable coaxial.
</para>

</sect2>

<sect2>
<title>Cableado Ethernet 10base2 (coaxial fino)</title>

<para>
10base2 es un estándar de cableado Ethernet que especifica el uso de cables
coaxiales de 52 ohmios con un diámetro de alrededor de 5 milímetros. Hay un par
de reglas importantes a recordar cuando conectemos máquinas con cableado
10base2. La primera es que debe usar terminadores en <emphasis>ambos extremos</emphasis> del
cable. Un terminador es una resistencia de 52 ohmios que ayuda a asegurar que
la señal es absorbida y no reflejada cuando alcanza el final del cable. Sin un
terminador a cada extremo del cable, podría pasar que la Ethernet sea
ineficiente o que no funcione.  Normalmente debería usar conectores en «T» para
interconectar las máquinas por lo que terminará con algo que se parezca a:
</para>

<para>

<screen>

 |==========T=============T=============T==========T==========|
            |             |             |          |
            |             |             |          |
          -----         -----         -----      -----
          |   |         |   |         |   |      |   |
          -----         -----         -----      -----

</screen>

</para>

<para>
Donde el <literal remap="tt">|</literal> a cada extremo representa un terminador, el <literal remap="tt">======</literal>
representa cables coaxiales con conectores BNC a cada extremo y las <literal remap="tt">T</literal>
representan conectores «en T». Debería hacer que la longitud del cable entre la
<literal remap="tt">T</literal> y el PC lo más corto posible ya que, idealmente, la «T» debería estar
directamente enchufada a la tarjeta Ethernet.
</para>

</sect2>

<sect2>
<title>Cable Ethernet de Par Trenzado</title>

<para>
Si tiene sólo dos tarjetas Ethernet de par trenzado y desea conectarlas,
entonces no necesita un concentrador. Puede cablear las dos tarjetas
directamente una a otra. Hay un diagrama que muestra cómo hacerlo incluido en
el <literal remap="tt"><ulink
url="Ethernet-HOWTO.html"
>Ethernet Howto</ulink
></literal>
</para>

</sect2>

</sect1>

<sect1>
<title>Glosario de Términos usados en este documento</title>

<para>
La siguiente lista contiene algunos de los términos más importantes usados
en este documento.
</para>

<para>
<variablelist>

<varlistentry>
<term>ARP</term>
<listitem>
<para>
Es un acrónimo para del <emphasis>Protocolo de Resolución de
Direcciones</emphasis> (Address Resolution Protocol) y es la manera en que
asocia una máquina de red una dirección IP con una dirección hardware.
</para>
</listitem></varlistentry>
<varlistentry>
<term>ATM</term>
<listitem>
<para>
Es un acrónimo de <emphasis>Modo Asíncrono de Transferencia</emphasis>
(Asynchronous Transfer Mode). Una red ATM empaqueta los datos en bloques
de tamaño estándar que puede transportar eficientemente de un punto a
otro. ATM es una tecnología de red basada en circuitos de paquetes
conmutados.
</para>
</listitem></varlistentry>
<varlistentry>
<term>cliente</term>
<listitem>
<para>
Suele ser la parte de un programa que se encuentra en el
lado del usuario. Hay ciertas excepciones, por ejemplo, en el sistema de
ventanas X11 es el servidor el que está con el usuario, y el cliente puede
estar ejecutándose en una máquina remota. El cliente es el programa o
terminal de un sistema que está recibiendo el servicio proporcionado por
el servidor. En el caso de sistema <emphasis>de igual a igual</emphasis> (peer to peer),
como <literal remap="tt">slip</literal> o <literal remap="tt">ppp</literal>, se dice que el cliente es el extremo que inicia
la conexión y el extremo remoto, que ha sido llamado, es el servidor.
</para>
</listitem></varlistentry>
<varlistentry>
<term>datagrama</term>
<listitem>
<para>
Un datagrama es un paquete discreto de datos y
cabeceras que contiene direcciones, que es la unidad básica de transmisión
a través de una red IP. Puede que lo haya oído llamar «paquete».
</para>
</listitem></varlistentry>
<varlistentry>
<term>Dirección hardware</term>
<listitem>
<para>
Es un número que identifica de forma unívoca
una máquina en una red física en la capa de acceso al medio. Algunos
ejemplos son las <emphasis>Direcciones Ethernet</emphasis> y las <emphasis>Direcciones
AX.25</emphasis>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>Dirección IP</term>
<listitem>
<para>
Es un número que identifica unívocamente una máquina
TCP/IP en la red. La dirección es de 4 bytes de longitud y normalmente se la
representa en <emphasis remap="it">notación decimal puntuada</emphasis>, donde cada byte es representado
en decimal con puntos «<literal remap="tt">.</literal>» entre ellos.
</para>
</listitem></varlistentry>
<varlistentry>
<term>DLCI</term>
<listitem>
<para>
DLCI viene de <emphasis remap="it">Data Link Connection Identifier</emphasis> y se usa para
identificar una conexión virtual punto a punto en particular a través de una
red de Retransmisión de Tramas. Los DLCI los suele asignar el proveedor de red
de Retransmisión de Tramas.
</para>
</listitem></varlistentry>
<varlistentry>
<term>ISP</term>
<listitem>
<para>
Véase PSI.
</para>
</listitem></varlistentry>
<varlistentry>
<term>MSS</term>
<listitem>
<para>
El Tamaño Máximo de Segmento (<emphasis>Maximum Segment Size</emphasis>)
es la mayor cantidad de datos que pueden ser transmitidos a la vez. Si
quiere prevenir la fragmentación, el MSS debería ser igual al MTU de la
cabecera IP.
</para>
</listitem></varlistentry>
<varlistentry>
<term>MTU</term>
<listitem>
<para>
La Máxima Unidad de Transmisión (<emphasis>Maximum Transmission
Unit</emphasis>) es un parámetro que determina el mayor datagrama que puede ser
transmitido por una interfaz IP sin necesidad de dividirlo en unidades más
pequeñas. La MTU debería ser más grande que el mayor datagrama que desee
transmitir sin fragmentar. Fíjese que esto sólo previene la fragmentación
de manera local, algunos otros enlaces por el camino pueden tener una MTU
más pequeña y el datagrama será fragmentado allí. Los valores normales son
1500 bytes para una interfaz Ethernet, o 576 bytes para una interfaz SLIP.
</para>
</listitem></varlistentry>
<varlistentry>
<term>PSI</term>
<listitem>
<para>
Es un acrónimo de Proveedor de Servicios de Internet (ISP -
Internet Service Provider). Son organizaciones y compañías que
proporcionan conectividad con Internet.
</para>
</listitem></varlistentry>
<varlistentry>
<term>RDSI</term>
<listitem>
<para>
Es un acrónimo de <emphasis>Red Digital de Servicios
Integrados</emphasis> (ISDN en inglés). La RDSI proporciona medios
estandarizados por los cuales las compañías de Telecomunicaciones pueden
llevar información tanto de voz como de datos según las premisas de los
abonados. Técnicamente la RDSI es una red de circuitos de paquetes
conmutados.
</para>
</listitem></varlistentry>
<varlistentry>
<term>Retransmisión de tramas</term>
<listitem>
<para>
La retransmisión de tramas (o Frame
Relay) es una tecnología de red idealmente preparada para transportar
tráfico que es de naturaleza esporádica o a ráfagas. Los costes de red se
reducen compartiendo varios abonados a la retransmisión de tramas la
misma capacidad de red y dejándoles a ellos el deseo de usar la red en
momentos ligeramente diferentes.
</para>
</listitem></varlistentry>
<varlistentry>
<term>ruta</term>
<listitem>
<para>
La <emphasis>ruta</emphasis> es el camino que siguen los datagramas a
través de la red para alcanzar su destino.
</para>
</listitem></varlistentry>
<varlistentry>
<term>servidor</term>
<listitem>
<para>
Normalmente es la parte del programa o terminal de un
sistema remoto con respecto al usuario. El servidor proporciona algún
servicio a uno o varios clientes. Los ejemplos de servidores incluyen
<emphasis>ftp</emphasis>, <emphasis>Network File System</emphasis> o <emphasis>Domain Name Server</emphasis>. En el caso
de sistemas de <emphasis>igual a igual</emphasis> (peer to peer) tales como <literal remap="tt">slip</literal> o
<literal remap="tt">ppp</literal>. Se dice que es el servidor el extremo del enlace que recibe la
llamada y el otro extremo es el cliente.
</para>
</listitem></varlistentry>
<varlistentry>
<term>ventana</term>
<listitem>
<para>
La <emphasis>ventana</emphasis> es la mayor cantidad de datos que el
extremo receptor puede aceptar en un momento dado.
</para>
</listitem></varlistentry>
</variablelist>
</para>

</sect1>

<sect1>
<title>¿Linux para un PSI?</title>

<para>
Si está interesado en usar Linux para propósitos de PSI entonces le recomiendo
que eche un vistazo a la página principal de Linux ISP <literal remap="tt"><ulink
url="http://www.anime.net/linuxisp/"
>http://www.anime.net/linuxisp</ulink
></literal>
si quiere obtener una buena lista de enlaces a la información que pudiera
necesitar.
</para>

</sect1>

<sect1>
<title>Reconocimientos</title>

<para>
Me gustaría dar las gracias a las siguientes personas por su contribución
a este documento (no están por orden): Terry Dawson, Axel Boldt, Arnt
Gulbrandsen, Gary Allpike, Cees de Groot, Alan Cox, Jonathon Naylor,
Claes Ensson, Ron Nessim, John Minack, Jean-Pierre Cocatrix, Erez Strauss.
</para>

<para>
El traductor quisiera también reconocer el trabajo de Fernando Tricas,
por su inestimable ayuda en el proceso de revisión del documento.
</para>

<para>
El mayor de los reconocimientos a la gran labor de Francisco Montilla
<literal remap="tt"><ulink
url="mailto:pacopepe@insflug.org"
>pacopepe@insflug.org</ulink
></literal> y el grupo Insflug <literal remap="tt"> <ulink
url="http://www.insflug.org"
>http://www.insflug.org</ulink
></literal> para conseguir
aportar documentación de calidad al movimiento LiNUX. ¡Animo!
</para>

</sect1>

<sect1>
<title>Copyright.</title>

<para>
<emphasis>Copyright Information</emphasis>
</para>

<para>
The NET-3-HOWTO, information on how to install and configure networking
support for Linux. Copyright (c) 1997 Terry Dawson, 1998 Alessandro
Rubini,
1999 &lcub;POET&rcub; - LinuxPorts
</para>

<para>
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version. This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
Public License for more details. You should have received a copy of the
GNU General Public License along with this program; if not, write to the:
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</para>

</sect1>

<sect1 id="Insflug">
<title>Anexo: El INSFLUG </title>

<para>
El <emphasis remap="it">INSFLUG</emphasis> forma parte del grupo internacional <emphasis remap="it">Linux Documentation
Project</emphasis>, encargándose de las traducciones al castellano de los Howtos,
así como de la producción de documentos originales en aquellos casos en los
que no existe análogo en inglés, centrándose, preferentemente, en documentos
breves, como los <emphasis>COMOs</emphasis> y <emphasis>PUFs</emphasis> (<emphasis remap="bf">P</emphasis>reguntas de <emphasis remap="bf">U</emphasis>so
<emphasis remap="bf">F</emphasis>recuente, las <emphasis remap="it">FAQs</emphasis>. <literal remap="tt">:)</literal> ), etc.
</para>

<para>
Diríjase a la sede del Insflug para más información al respecto.
</para>

<para>
En ella encontrará siempre las <emphasis remap="bf">últimas</emphasis> versiones de las traducciones
«oficiales»:  <literal remap="tt"><ulink
url="http://www.insflug.org"
>www.insflug.org</ulink
></literal>. Asegúrese de comprobar cuál es la última
versión disponible en el Insflug antes de bajar un documento de un
servidor réplica. 
</para>

<para>
Además, cuenta con un sistema interactivo de gestión de fe de erratas y
sugerencias en línea, motor de búsqueda específico, y más servicios en los
que estamos trabajando incesantemente.
</para>

<para>
Ponga su granito de arena; si detecta una errata o incorrección en este
documento, por favor, diríjase a <literal remap="tt"><ulink
url="http://www.insflug.org/documentos/Redes-En-Linux-Como/"
>http://www.insflug.org/documentos/Redes-En-Linux-Como/</ulink
></literal> y aporte su
sugerencia o errata en línea.
</para>

<para>
En <literal remap="tt"><ulink
url="http://www.insflug.org/insflug/creditos.php3"
>http://www.insflug.org/insflug/creditos.php3</ulink
></literal> cuenta con una
detallada relación de las personas que hacen posible tanto esto como las
traducciones.
</para>

<para>
¡Diríjase a <literal remap="tt"><ulink
url="http://www.insflug.org/colaboracion/index.php3"
>http://www.insflug.org/colaboracion/index.php3</ulink
></literal> si desea
unirse a nosotros!.
</para>

<para>
«Cartel» Insflug, <literal remap="tt"><ulink
url="mailto:cartel@insflug.org"
>cartel@insflug.org</ulink
></literal>. 
</para>

</sect1>

</article>
