This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: gserver,  Next: import,  Prev: export,  Up: Ordenes y Opciones

gserver
-------

Sinopsis: gserver

Éste es el servidor GSSAPI (Servicios Generales de Seguridad API). Este
mandato no se ejecuta normalmente por usuarios.  En vez de esto, se
arranca en el lado del servidor cuando un usuario conecta desde un
cliente con el método de acceso `:gserver:':

     cvs -d :gserver:floss.red-bean.com:/usr/local/nuevorepos checkout miproyecto

GSSAPI provee, entre otras cosas, la Versión 5 de Kerberos; para la
versión 4, usar `:kserver:'.

Ajustando y usando una librería GSSAPI en sus máquinas está fuera del
alcance de este libro.  (Ver sin embargo el nodo `Acreditación GSSAPI'
en el manual Cederqvist para obtener ayudas más útiles).

Opciones: ninguna.

history [OPCIONES] [SUBCADENA_FICHERO(S)]

   * Nombres alternativos - hi, his

   * Requiere - Repositorio, CVSROOT/history

   * Cambia - Nada

Muestra un historial de la actividad en el repositorio.
Específicamente, esta opción muestra los registros de obtenciones,
entregas, etiquetados, actualizaciones y lanzamientros.  Por omisión,
la opción muestra las obtenciones (pero vea la opción -x).  Este
mandato no funciona si no hay fichero `CVSROOT/history' en el
repositorio.

El mandato history difiere de otros mandatos CVS en muchos sentidos.
Primero, deben proporcionarse opciones normalmente para hacer algo útil
(y muchas de estas opciones significan diferentes cosas para el
historial que para otros mandatos).  Segundo, en vez de hablar de
nombres completos de fichero como argumentos, toma una o más subcadenas
para coincidir con nombres de fichero (todas las grabaciones que
coincidan con al menos una de estas subcadenas se recuperan).  Tercero,
la salida del historial tiene aspecto de basura hasta que aprenda a
leerla, así que explicaré el formato de salida en una sección especial
después de las opciones.  (Ver también *Note log::.)

Opciones:

   * -a - Muestra el historial para todos los usuarios (de otro modo, es
     por omisión uno mismo).

   * -b CADENA - Muestra los datos conteniendo la CADENA en el nombre
     del módulo, nombre del fichero o ruta al repositorio.

   * -c - Muestra entregas.

   * -D FECHA - Muestra los datos desde FECHA (los formatos de fecha de
     CVS están disponibles).

   * -e - Todo - Muestra todos los tipos de registros.

   * -f FICHERO - Muestra los eventos más recientes concernientes a
     FICHERO.  Puede especificar esta opción muchas veces.  Esto es
     diferente del significado usual de -f en los mandatos CVS: "Forzar
     a la revisión de cabecera como última solución."

   * -l - Muestra el registro representando el último (como en "más
     reciente") evento de cada proyecto.  Esto es diferente del
     significado usual de -l en mandatos CVS: "Ejecutar localmente, no
     recursivamente".

   * -m MÓDULO - Esto produce un informe sobre el MÓDULO (nombre de
     proyecto). Puede especificar esta opción muchas veces.

   * -n MÓDULO - Muestra los eventos más recientes sobre MÓDULO.  Por
     ejemplo, obtener el módulo concierne al módulo únicamente, pero
     modificar o actualizar un fichero dentro del módulo, trata del
     fichero, no del módulo.  Puede especificar esta opción muchas
     veces.  Ésto es diferente del significado usual de -n en los
     mandatos CVS: "No ejecutar un programa CVSROOT/modules."

   * -o - Muestra los registros de obtenciones (por omisión).

   * -p REPOS - Muestra los datos de un directorio particular en el
     repositorio. Puede especificar esta opción muchas veces.  El
     significado de esta opción difiere del significado usual de -p en
     los mandatos CVS: "Encaminar los datos a la salida estándar en vez
     de hacia un fichero".

     Esta opción parece estar por lo menos parcialmente rota desde el
     verano de 1999.

   * -r REV - Muestra los registros refirientes a versiones desde que
     la revisión o etiqueta llamada REV aparece en ficheros RCS
     individuales.  En cada fichero RCS se busca la revisión o etiqueta.

   * -T - Muestra todos los eventos de etiquetado.

   * -t ETIQUETA - Muestra los registros desde que la ETIQUETA fue
     últimamente añadida al fichero de historial.  Esto difiere del
     flag -r en donde se lee sólo el fichero `CVSROOT/history', no los
     ficheros RCS y es, por tanto, mucho más rápido.

   * -u USUARIO - Muestra los eventos asociados con USUARIO.  Puede
     especificar esta opción muchas veces.

   * -w - Muestra los registros que están asociados con el directorio de
     trabajo del cual está invocando history.

   * -X FICHERO_HISTORIAL - Usa FICHERO_HISTORIAL en vez de
     `CVSROOT/history'.  Esta opción es principalmente para depurado y
     no se apoya oficialmente; aun con todo, puede encontrarla útil
     (tal vez para generar informes legibles-por-humanos de ficheros
     viejos de historial que ha conservado por ahí).

   * -x TIPOS - Muestra eventos especificados en TIPOS.  Cada tipo está
     representado por una simple letra, del juego `TOEFWUCGMAR';
     cualquier número de letras puede ser combinado.  Aquí está lo que
     significan:

        * T - Etiqueta

        * O - Obtención

        * E - Exportación

        * F - Lanzamiento

        * W - Actualización (fichero obsoleto más nuevo quitado de la
          copia de trabjo)

        * U - Actualización (fichero que fue entregado sobre un fichero
          de usuario)

        * C - Actualización (mezclado, con conflictos)

        * G - Actualización (mezclado, sin conflictos)

        * M - Entrega (el fichero fue modificado)

        * A - Entrega (el fichero fue añadido)

        * R - Entrega (el fichero fue borrado)

     Por omisión, si no se proporcionan opciones -x, es para mostrar
     obtenciones (como `-x O').

   * -z ZONA - Muestra tiempos en la salida para el huso ZONE.  ZONE es
     un nombre de huso abreviado, como UTC, GMT, BST, CDT, CCT y así.
     Una lista completa de husos está disponible en TimezoneTable en el
     fichero `lib/getdate.c' en la distribución de fuentes de CVS.


Salida de historial

La salida del mandato history es una serie de líneas; cada línea
representa un "evento de historial" y comienza con una sola letra de
código indicando qué tipo de evento es.  Por ejemplo:

     floss$ cvs history -D yesterday -x TMO
     M 08/21 20:19 +0000 jcualquiera 2.2           baar       miproyecto == <remote>
     M 08/22 04:18 +0000 jcualquiera 1.2           README     miproyecto == <remote>
     O 08/22 05:15 +0000 jcualquiera myproj =myproj= ~/src/*
     M 08/22 05:33 +0000 jcualquiera 2.18          README.txt miproyecto == ~/src/myproj
     O 08/22 14:25 CDT jcualquiera miproyecto =miproyecto= ~/src/*
     O 08/22 14:26 CDT jcualquiera [99.08.23.19.26.03] miproyecto =miproyecto= ~/src/*
     O 08/22 14:28 CDT jcualquiera [Saludos_Exoticos-rama] miproyecto =miproyecto= ~/src/*

Las letras de código son las mismas que para la opción -x recientemente
descrita.  Siguiendo el código de letra en la fecha de un evento
(expresada en tiempo UTC/GMT, a no ser que se use la opción -z),
seguida del usuario responsable del evento.

Después del usuario podría haber un número de revisión, etiqueta, o
fecha, pero sólo si es apropiada para el evento (la fecha o etiqueta
estarán en corchetes y formateados como se muestra en el ejemplo
precedente).  Si usted entrega un fichero, muestra el nuevo número de
revisión; si obtiene con -D o -r, la fecha o etiqueta adhesiva se
muestra dentro de corchetes.  Para una obtención sencilla, nada extra
se muestra.

Luego viene el nombre del fichero en cuestión, o nombre del módulo en
el evento que es sobre un módulo.  En el anterior, las siguientes dos
cosas son el nombre de la copia de trabajo del módulo obtenido (entre
dos signos de igual), seguida por su localización en el directorio
personal del usuario (home).  (El nombre de la copia de trabajo
obtenida puede diferir del nombre del módulo si flag -d es usado con
checkout).


File: cvsbook.info,  Node: import,  Next: init,  Prev: gserver,  Up: Ordenes y Opciones

import
------

Sinopsis: import [OPCIONES] REPOSITORIO ETIQUETA_VENDEDOR ETIQUETA_LANZAMIENTO(S)

   * Nombres alternativos - im, imp

   * Requiere - Repositiorio, directorio actual (el directorio de
     fuentes)

   * Changes - Repositorio

Importa nuevas fuentes en el repositorio, bien creando un nuevo
proyecto o creando una nueva revisión de vendedor en una rama de
vendedor de un proyecto existente. (Ver *Note CVS avanzado:: para
obtener una explicación básica de las ramas de vendedor en la
importación, que le ayudará a entender lo siguiente).

Es normal usar import para añadir muchos ficheros o directorios de vez
o para crear un nuevo proyecto.  Para anñadir simples ficheros, debe
usar add.

Opciones:

   * -b RAMA - Importa a la rama de vendedor RAMA.  (RAMA es un número
     de rama actual, no una etiqueta).  Esto se usa raramente pero
     puede ser útil si coge las fuentes del mismo proyecto de
     diferentes vendedores.  Un mandato de importación normal asume que
     los fuentes deben ser importados en la rama de vendedor por
     omisión, que es "1.1.1".  Debido a que es por omisión, normalmente
     no tiene que preocuparse en especificarlo con -b:

          floss$ cvs import -m "importando del vendedor 1" su_proyecto ELLOS1 ELLOS1-0

     Para importar a una rama de vendedor distinta de la que es por
     omisión, debe especificar un número de rama diferente
     explícitamente:

          floss$ cvs import -b 1.1.3 -m "del vendedor 2" su_proyecto ELLOS2 ELLOS2-0

     La rama 1.1.3 puede absorver futuras importaciones y ser mezclada
     como cualquier otra rama de vendedor.  Sin embargo, debe
     asegurarse que en cualquier futura importación que especifique
     `-b 1.1.3' también debe usar la misma etiqueta de vendedor
     (`ELLOS2'). CVS no comprueba que el nombre de vendedor coincida
     con la etiqueta de vendedor.  Sin embargo, si no coinciden,
     ocurrirán cosas extrañas e impredecibles.

     Las ramas de vendedor están numeradas con impares, lo contrario de
     ramas regulares.

   * -d - Toma la fecha de modificación como la fecha de importación en
     vez de usar la fecha actual.  Esto no funciona con CVS
     cliente/servidor.

   * -I NOMBRE - Da nombres de fichero que deben no ser tenidos en
     cuenta en la importación.  Puede usar esta opción muchas veces en
     una importación.  Los patrones con comodines están admitidos:
     `*.foo' significa no tener en cuenta todo lo que termine en
     `.foo'. (Ver *Note cvsignore:: en *Note Ficheros de Administracion
     del Repositorio:: para obtener detalles acerca de los comodines).

     Los siguientes ficheros y nombres de directorios son obviados por
     omisión:

          	.
          	..
          	.#*
          	#*
          	,*
          	_$*
          	*~
          	*$
          	*.a
          	*.bak
          	*.BAK
          	*.elc
          	*.exe
          	*.ln
          	*.o
          	*.obj
          	*.olb
          	*.old
          	*.orig
          	*.rej
          	*.so
          	*.Z
          	.del-*
          	.make.state
          	.nse_depinfo
          	core
          	CVS
          	CVS.adm
          	cvslog.*
          	RCS
          	RCSLOG
          	SCCS
          	tags
          	TAGS

     Puede suprimir que no se tengan en cuenta estos patrones de nombre
     de fichero, así como cualquiera especificado en `.cvsignore',
     `CVSROOT/cvsignore', y la variable de entorno `$CVSIGNORE', usando
     `-I !'. Esto es,

          floss$ cvs import -I ! -m "importando el universo" proyecto VENDEDOR VENDEDOR_0

     importa todos los ficheros en el árbol de directorio actual,
     incluso los que serían normalmente desechados.

     Usar `-I !' borra cualquier lista de ficheros a no tener en cuenta
     que haya sido creada hasta este punto, así que cualquier opción -I
     que venga después debería ser anulada, pero cualquiera que venga
     después todavía contará.  Así,

          floss$ cvs import -I ! -I LÉAME.txt -m "algunos msj" su_proyecto ELLOS ELLOS_0

     no es lo mismo que

          floss$ cvs import -I LÉAME.txt -I ! -m "algunos msj" su_proyecto ELLOS ELLOS_0

     El primero obvia (no importa) LÉAME.txt, mientras que el último lo
     importa.

   * -k MODO - Configura la clave de modo de sustitución RCS por
     omisión para los ficheros importados.  (Ver *Note Claves de
     Sustitucion (Claves RCS):: más adelante en este capítulo para
     obtener una lista de modo válidos).

   * -m MENSAJE - Registra MENSAJE como mensaje de registro de
     importación.

   * -W SPEC - Especifica filtros basados en nombres de fichero que
     deben ser usados efectivamente para la importación.  Puede usar
     esta opción muchas veces.  (Vea *Note cvswrappers:: en *Note
     Ficheros de Administracion del Repositorio:: para obtener detalles
     acerca de las especificaciones de cobertura).



File: cvsbook.info,  Node: init,  Next: kserver,  Prev: import,  Up: Ordenes y Opciones

init
----

Sinopsis: init NUEVO_REPOSITORIO

   * Nombres alternativos - Ninguno

   * Requiere - Localización para el nuevo repositorio

   * Crea - Repositorio

Crea un nuevo repositorio (que es, el raíz de un repositorio en el cual
se almacenan muchos proyectos diferentes).  Casi siempre deseará usar
la opción global -d con esto, como en

     floss$ cvs -d /usr/local/otro_nombre_de_repositorio init

porque, incluso si tiene la variable de entorno CVSROOT ajustada, está
apuntando probablemente a un repositorio existente, que puede ser
inservible e incluso peligroso en el contexto de este mandato. (Véase
*Note Administracion del Repositorio:: para averiguar los pasos
adicionales que se deberían tomar después de inicializar un nuevo
repositorio).

Opciones: Ninguna.


File: cvsbook.info,  Node: kserver,  Next: log,  Prev: init,  Up: Ordenes y Opciones

kserver
-------

Sinopsis: kserver

Este es un servidor Kerberos.  (Si tiene la versión 4 de las librerías
de Kerberos o anteriores - Versión 5 usa GSSAPI, ver *Note gserver::.)
Este mandato normalmente no se ejecuta directamente por usuarios pero
se ejecuta en el lado del servidor cuando un usuario conecta desde un
cliente con el método de acceso `:kserver:':

     cvs -d :kserver:floss.red-bean.com:/usr/local/nuevorepos checkout miproyecto

Configurar y usar Kerberos en su máquina está fuera del alcance de este
libro.  (Sin embargo, vea `Acreditación Kerberos' en el manual
Cederqvist para obtener ayuda más útil.)

Opciones: Ninguna.


File: cvsbook.info,  Node: log,  Next: login,  Prev: kserver,  Up: Ordenes y Opciones

log
---

Sinopsis: log [OPCIONES] [FICHEROS]

   * Nombres alternativos - lo, rlog

   * Requiere - Copia de trabajo, repositorio

   * Cambia - Nada

Muestra mensajes de registro para un proyecto, o para ficheros dentro
de un proyecto.  La salida de resitro no está precisamente en el mismo
estilo que la salida de otros mandatos CVS, porque el registro se basa
en un programa RCS más viejo (rlog).  Su formato de salida da una
cabecera, conteniendo varias piezas de información sobre el fichero
no-específica-de-una-revisión, seguida de los mensajes de registro
(arreglados por revisión).  Cada revisión no muestra meramente el
número de revisión y los mensajes de registro, sino también el autor y
la fecha de el cambio y el número de líneas añadidas o borradas.
Siempre imprimidas en UTC (GMT), no en fecha local.

Debido a que la salida de log es por fichero, una simple entrega que
involucra múltiples ficheros puede no parecer conceptualmente como un
cambio atómico.  Sin embargo, si lee todos los mensajes de registro y
fechas cuidadosamente, podrá reconstruir qué ocurrió.  (Para obtener
más información sobre una herramienta que puede reformatear salida de
log de muchos ficheros de una forma más legible, vea *Note cvs2cl --
Genera ChangeLogs al estilo GNU:: en *Note Herramientas de terceros::
para obtener más detalles).  (Ver también *Note history file::).

Opciones:

Mientras lee las siguientes opciones de filtrado, puede no quedar
completamente claro cómo se comportan cuando se combinan.  Un
descripción precisa del comportamiento del registro es la que toma la
intersección de las revisiones seleccionadas por -d, -s y -w, cuando
intersectan con la unión de las seleccionadas por -b y -r.

   * -b - Imprime información de registro acerca de la rama por omisión
     solamente (usualmente la rama más alta del tronco).  Esto se hace
     usualmente para evitar la impresión de los mensajes de registro de
     ramas laterales de desarrollo.

   * -dFECHAS - Imprime información de registro para sólo las revisiones
     que coincidan con la fecha o rango de fechas dado por FECHAS, una
     lista separada por comas.  Las fechas se pueden dar en cualquiera
     de los formatos usuales (ver *Note Formatos de Fecha::
     anteriormente en esta sección) y puede ser combinado en rangos
     como a continuación:

        * FECHA1<FECHA2 - Selecciona las revisiones creadas entre
          FECHA1 y FECHA2.  Si FECHA1 es más vieja que FECHA2, use en
          cambio `>'; de otro modo no se obtendrán mensajes de registro.

        * <FECHA FECHA> - Todas las fechas desde FECHA o más tempranas.

        * >FECHA FECHA< - Todas las revisiones de FECHA o más adelante.

        * FECHA -  Simplemente selecciona la revisión simple más
          reciente desde FECHA o más temprana.


     Puede usar `<=' y `>=' en vez de `<' y `>' para indicar un rango
     exclusivo (de otro modo, los rangos son inclusivos).  Los rangos
     múltiples pueden ser separados por comas, por ejemplo

          floss$ cvs log -d"1999-06-01<1999-07-01;1999-08-01<1999-09-01"

     selecciona los mensajes de registro de revisiones entregadas en
     junio o agosto de 1999 (pasando julio).  No puede haber espacio
     entre -d y sus argumentos.

   * -h - Imprime sólo la información de cabecera de cada fichero, que
     incluye el nombre del fichero, el directorio de trabajo, la
     revisión de cabecera, la rama por omisi\'n, la lista de acceso,
     los bloqueos, los nombres simbólicos (etiquetas) y la clave de
     modo de sustituci\'n por omisión.  No se imprimen mensajes de
     registro.

   * -l - Local.  Se ejecuta sólo para los ficheros en el directorio de
     trabajo actual.

   * -N - Omite la lista de nombres simbólicos (etiquetas) de la
     cabecera.  Esto puede ser útil cuando su proyecto tiene muchas
     etiquetas que no está interesado en ver en los mensajes de
     registro.

   * -R - Imprime el nombre del fichero RCS en el repositorio.

     Esto es diferente del significado usual de -R: "recursivo". No hay
     modo de contrarrestar un -l para este mandato, así que no ponga
     log -l en su `.cvsrc'.

   * -rREVS - Muestra información de registro para las revisiones
     especificadas en REVS, una lista separada por comas.  REVS puede
     contener tanto números de revisión y etiquetas. Los rangos pueden
     ser especificados así:

        * REV1:REV2 - Revisiones desde REV1 a REV2 (deben estar en la
          misma rama).

        * :REV - Revisiones desde el comienzo de la rama de REV hasta, e
          incluyendo REV.

        * REV: - Revisiones desde REV hasta el final de la rama de REV.

        * RAMA - Todas las revisiones de esta rama, desde la raíz hasta
          la punta.

        * RAMA1:RAMA2 - Un rango de ramas - todas las revisiones de
          todas las ramas de este rango.

        * RAMA. - La última revisión (punta) de una RAMA.


     Finalmente, un solo -r, sin argumento, significa seleccionar la
     última revisión en la rama por omisión (normalmente el tronco).
     No puede haber espacio entre -r y sus argumentos.

     Si el argumento a -r es una lista, está separada por comas, no por
     punto y coma, como -d.

   * -sESTADOS - Selecciona las revisiones cuyos atributos de estado
     coincida con uno de los estados dados por ESTADOS, una lista
     separada por comas.  No puede haber espacios entre -s y sus
     argumentos.

     Si los argumentos a -s son una lista, están separado por comas, no
     por puntos y comas como -d.

   * -t - Como -h, pero también incluye la descripción del fichero (su
     mensaje de creación).

   * -wUSUARIOS - Selecciona las revisiones entregadas por usuarios
     cuyos nombres de usuario aparezcan en la lista de usuarios
     separada por comas.  Un -w suelto sin USUARIOS significa tomar el
     nombre de usuario de la persona que ejecute cvs log.

     Recuerde que cuando los sobrenombres de usuario se efectúan (ver
     sección *Note El servidor de autentificacion de contrasen~as:: en
     *Note Administracion del Repositorio::), CVS registra el nombre de
     usuario CVS, no el nombre de usuario de sistema, en cada entrega.
     Puede no haber espacio entre -w y sus argumentos.

     Si el argumento a -w es una lista, está separada por comas, no
     separada por puntos y comas como -d.



File: cvsbook.info,  Node: login,  Next: logout,  Prev: log,  Up: Ordenes y Opciones

login
-----

Sinopsis: login

   * Nombres alternativos - logon, lgn

   * Requiere - Repositorio

   * Cambia - fichero ~/.cvspass

Establece contacto con un servidor CVS y confirma la información de
acreditación para un repositorio en particular.  Este mandato no afecta
ni a la copia de trabajo ni al repositorio; simplemente confirma una
clave (para usar con el método de acceso :pserver:) con un repositorio
y almacena la clave para uso posterior en el fichero .cvspass en su
directorio de trabajo.  Mandatos futuros que accedan al mismo
repositorio con el mismo nombre de usuario no requerirán que vuelva a
ejecutar login, porque el CVS del lado del cliente consultará el
fichero .cvspass para obtener la clave.

Si usa este mandato, debe especificar un repositorio usando el método
de acceso pserver, como en esto

     floss$ cvs -d :pserver:jcualquiera@floss.red-bean.com:/usr/local/nuevorepos

o configurando la variable de entorno CVSROOT.

Si cambia la clave en el lado del servidor, debe volver a ejecutar
login.

Opciones: Ninguna.


File: cvsbook.info,  Node: logout,  Next: pserver,  Prev: login,  Up: Ordenes y Opciones

logout
------

Sinopsis: logout

   * Nombres alternativos - None

   * Requiere - fichero ~/.cvspass

   * Cambia - fichero ~/.cvspass

Lo contrario que login - borra la clave para este repositorio de
.cvspass.

Opciones: Ninguna.


File: cvsbook.info,  Node: pserver,  Next: rdiff,  Prev: logout,  Up: Ordenes y Opciones

pserver
-------

Sinopsis: pserver

   * Nombres alternativos - Ninguno

   * Requiere - Repositorio

   * Cambia - Nada

Es el servidor de acreditación por clave.  Este mandato normalmente no
se ejecuta directamente por usuarios, pero se ejecuta desde
`/etc/inetd.conf' en el servidor cuando un usuario se conecta desde un
cliente con el método de acceso `:pserver:'. (Ver también los mandatos
*Note login:: y *Note logout::, y el fichero `.cvspass' en la sección
*Note Ficheros de Control de Ejecucion:: en este capítulo.  Ver *Note
Administracion del Repositorio:: para obtener más detalles acerca de
configurar un servidor CVS de acreditación por clave).

Opciones: Ninguna.


File: cvsbook.info,  Node: rdiff,  Next: release,  Prev: pserver,  Up: Ordenes y Opciones

rdiff
-----

Sinopsis: rdiff [OPTIONS] PROJECTS

   * Nombres alternativos - patch, pa

   * Requiere - Repositorio

   * Cambia - Nada

Es como el mandato diff, excepto que opera directamente en el
repositorio y, por tanto, no requiere copia de trabajo. Este mandato
sirve para obtener las diferencias entre un lanzamiento y otro de su
proyecto en un formato adecuado como entrada al programa patch (tal vez
para que pueda distribuir ficheros parche a usuarios que quieran una
actualización).

La operación del programa patch está fuera del alcance de este libro.
Sin embargo, note que si el fichero de parche contiene diferencias para
ficheros en subdirectorios, puede necesitar usar la opción -p de patch
para permitir que aplique las diferencias correctamente.  (Ver la
documentación de patch para obtener más información acerca de esto).
(Ver también *Note diff::).

Opciones:

   * -c - Imprime salida en el formato de contexto diff (por omisión).

   * -D FECHA o -D FECHA1 -D FECHA2 - Con una fecha, esto muestra las
     diferencias entre los ficheros desde FECHA hasta las revisiones de
     cabecera.  Con dos fechas, muestra las diferencias entre las
     fechas.

   * -f - Fuerza el uso de una revisión de cabecera si no se ecuentran
     revisiones coincidentes para la opción -D o -r (de otro modo,
     rdiff no tendría en cuenta el fichero).

   * -l - Local.  No desciende a los subdirectorios.

   * -R - Recursivo.  Desciende a los subdirectorios (por omisión).
     Sólo tiene que especificar esta opción para contrarrestar un -l en
     su .cvsrc.

   * -r REV -r REV1 -r REV2 - Con una revisión, esto muestra las
     diferencias entre la revisión REV de los ficheros y la revisión de
     cabecera.  Con dos, muestra las diferencias entre las revisiones.

   * -s - Muestra un sumario de diferencias.  Esto muestra qué ficheros
     han sido añadidos, modificados o borrados, sin mostrar los cambios
     en sus contenidos.  La salida tiene este aspecto:

          floss$ cvs -Q rdiff -s -D 1999-08-20 mi_proyecto
          File mi_proyecto/Cosa.txt is new; current revision 1.4
          File mi_proyecto/LÉAME.txt changed from revision 2.1 to 2.20
          File mi_proyecto/baar is new; current revision 2.3

   * -t - Muestra la diferencia entre las dos revisiones superiores de
     cada fichero. Esto es un atajo útil para determinar los cambios
     más recientes en un proyecto.  Esta opción es incompatible con -D
     y -r.

   * -u - Imprime salida en formato unidiff.  Las versiones más viejas
     del parche no pueden manejar formato unidiff; por tanto, no use -u
     si está intentando generar un fichero de parche distribuible - use
     -c en su lugar.

   * -V (En desuso) - CVS ahora da un error si intenta usar esta opción.
     La he incluido aquí sólo en caso de que vea algún script viejo
     intentando usarla.



File: cvsbook.info,  Node: release,  Next: remove,  Prev: rdiff,  Up: Ordenes y Opciones

release
-------

Sinopsis: release [OPCIONES] DIRECTORIO

   * Nombres alternativos - re, rel

   * Requiere - Copia de trabajo

   * Cambia - Copia de trabajo, CVSROOT/history

Cancela una obtención (indica que la copia de trabajo y no está en
uso). A diferencia de la mayoría de los mandatos CVS que operan en una
copia de trabajo, esta no se invoca dentro de la copia de trabajo, sino
directamente encima de ella (en su directorio padre).  Debe configurar
su variable de entorno CVSROOT o bien usar la opción global -d, ya que
CVS no podrá encontrar el repositorio desde la copia de trabajo.

Usar release nunca es necesario.  Debido a que CVS no hace bloqueo
normalmente, puede simplemente borrar su copia de trabajo.

Sin embargo, si no ha entregado cambios en su copia de trabajo y quiere
que la cesación del trabajo sea notificada en el fichero
CVSROOT/history (ver mandato history), debe usar release.  CVS primero
comprueba cualquier cambio no entregado; si hay alguno, avisa y
pregunta si continuar. Una vez que la copia de trabajo esté lanzada,
este hecho se graba en el fichero del repositorio CVSROOT/history.

Opciones:

   * -d - Borra la copia de trabajo si el lanzamiento tiene éxito. Sin
     -d, la copia de trabajo permanece en el disco después del
     lanzamiento.


Si creó cualquier directorio nuevo dentro de su copia de trabajo pero
no los añadió al repositorio, serán borrados junto con el resto de la
copia de trabajo, si especificó la opción -d.


File: cvsbook.info,  Node: remove,  Next: rtag,  Prev: release,  Up: Ordenes y Opciones

remove
------

Synopsis: remove [OPCIONES] [FICHEROS]

   * Nombres alternativos - rm, delete

   * Requiere - Copia de trabajo

   * Cambia - Copia de trabajo

Borra un fichero de un proyecto.  Normalmente, el fichero en sí mismo
ya está borrado del disco cuando invoca este mandato (pero vea -f).
Aunque este mandato opera recursivamente por omisión, es común nombrar
explícitamente el los ficheros que se van a borrar.  Note lo que
implica la anterior afirmación: Usualmente, ejecuta cvs remove en los
ficheros que no ya existen en su copia de trabajo.

Aunque se conecta con el repositorio para obtener confirmación, el
fichero no se borra efectivamente hasta que una entrega posterior se
realiza.  Incluso entonces, el fichero RCS no se borra realmente de
repositorio; si es borrado del tronco, se mueve al subdirectorio
Attic/, donde todavía está disponible para su existencia en las ramas.
Si se borra de una rama, su localización no se cambia, pero una nueva
revisión con el estado dead (muerta) se añade a la rama (Ver también
*Note add::).

Opciones:

   * -f - Fuerza.  Borra el fichero de desco antes de borrarlo del CVS.
     Este significado difiere del usual significado de -f en los
     mandatos CVS: "Forzar a la revisión de cabecera".

   * -l - Local.  Ejecuta sólo en el directorio de trabajo.

   * -R - Recursivo.  Desciende dentro de los subdirectorios (por
     omisión).  Esta opción existe sólo para contrarrestar un -l en
     .cvsrc.



File: cvsbook.info,  Node: rtag,  Next: server,  Prev: remove,  Up: Ordenes y Opciones

rtag
----

Sinopsis: rtag [OPCIONES] TAG PROJECTO(S)

   * Nombres alternativos - rt, rfreeze

   * Requiere - Repositorio

   * Cambia - Repositorio

Etiqueta un módulo directamente en el repositorio (no requiere copia de
trabajo). Probablemente necesita tener su variable de entorno CVSROOT
configurada o usar la opción global -d para que esto funcione.  (Ver
también *Note tag::).

Opciones:

   * -a - Borra la etiqueta de cualquier fichero borrado, porque los
     ficheros borrados permanecen en el repositorio para propósitos de
     historial, pero ya no son considerados parte del proyecto vivo.
     Aunque es ilegal etiquetar ficheros con un nombre de etiqueta que
     ya está en uso, no debería interferir si el nombre sólo es usado
     en ficheros borrados (los cuales, desde el actual punto de vista
     del proyecto, ya no existen).

   * -b - Crea una nueva rama, con nombre de rama ETIQUETA.

   * -D FECHA - Etiqueta la última revisión no posterior a FECHA.

   * -d - Borra la etiqueta.  No se hace ningún registro de este cambio
     - la etiqueta simplemente desaparece.  CVS no mantiene un
     historial de cambios para las etiquetas.

   * -F - Fuerza la reasignación del nombre de la etiqueta, si ocurre
     que ya existe para alguna otra revisión del fichero.

   * -f - Fuerza a la revisión de cabecera si una etiqueta dada o fecha
     no es encontrada. (Ver -r y -D).

   * -l - Local.  Ejecuta en el directorio actual solamente.

   * -n - No ejecuta un programa de etiquetación de CVSROOT/modules
     (Vea la sección *Note Ficheros de Administracion del Repositorio::
     más adelante en este capítulo para obtener detalles acerca de
     estos programas).

   * -R - Recursivo.  Desciende dentro de subdirectorios (por omisión).
     La opción -R existe sólo para contrarrestar un -l en un .cvsrc.

   * -r REV - Etiqueta la revisión REV (que puede ser en sí un nombre
     de etiqueta).



File: cvsbook.info,  Node: server,  Next: status,  Prev: rtag,  Up: Ordenes y Opciones

server
------

Sinopsis: server

Comienza un servidor CVS.  Este mandato no se invoca nunca por usuarios
(a no ser que esté intentando depurar el protocolo cliente/servidor),
así que permítame limitarme a mencionarla.

Opcions: Ninguna.


File: cvsbook.info,  Node: status,  Next: tag,  Prev: server,  Up: Ordenes y Opciones

status
------

Synopsis: status [OPCIONES] [FICHEROS]

   * Nombres alternativos - st, stat

   * Requiere - Copia de trabajo

   * Cambia - Nada

Muestra el estado de los ficheros en la copia de trabajo

Opciones:

   * -l - Local.  Se ejecuta en el directorio actual solamente.

   * -R - Recursivo.  Desciende dentro de los subdirectorios (por
     omisión). La opción -R existe sólo para contrarrestar un -l en
     .cvsrc.

   * -v - Muestra información de etiquetas para el fichero.



File: cvsbook.info,  Node: tag,  Next: unedit,  Prev: status,  Up: Ordenes y Opciones

tag
---

Sinopsis: tag [OPCIONES] TAG [FICHEROS]

   * Nombres alternativos - ta, freeze

   * Requiere - Copia de trabajo, repositorio

   * Cambia - Repositorio

Asigna un nombre a una revisión particular o colección de revisiones
para un proyecto.  Muchas veces se llama "tomar una instantánea" del
proyecto.  Este mandato también se usa para crear ramas en CVS.  (Ver
la opción -b - ver también *Note rtag::).

Opciones:

   * -b - Crea una rama llamada TAG.

   * -c - Comprueba que la copia de trabajo no tenga cambios sin
     entregar.  Si es así, el mandato sale con un aviso, y no se hace
     el etiquetado.

   * -D FECHA - Etiqueta la última revisión no posterior a FECHA.

   * -d - Borra la etiqueta.  No se graba este cambio; la etiqueta
     simplemente desaparece.  CVS no mantiene un historial de cambios
     de las etiquetas.

   * -F - Fuerza la reasignación del nombre de la etiqueta, si ocurre
     que existe ya para otras revisiones del fichero.

   * -f - Fuerza a la revisión de cabecera si una etiqueta dada o fecha
     no es encontrada.  (Ver -r y -D).

   * -l - Local.  Ejecuta sólo en el directorio actual.

   * -R - Recursivo.  Desciende en los subdirectorios (por omisión).
     La opción -R existe sólo para contrarrestar un -l en un .cvsrc.

   * -r REV - Etiqueta la revisión REV (que puede ser en sí un nombre
     de etiqueta).



File: cvsbook.info,  Node: unedit,  Next: update,  Prev: tag,  Up: Ordenes y Opciones

unedit
------

Sinopsis: unedit [OPCIONES] [FICHEROS]

   * Nombres alternativos - Ninguno

   * Requiere - Copia de trabajo, repositorio

   * Cambia - listas de edición/observación en el repositorio

Avisa a los observadores de que ha terminado de editar un fichero. (Ver
también *Note watch::, *Note watchers::, *Note edit:: y *Note
editors::).

Opciones:

   * -l - Local.  Avisa sobre la edición para los ficheros del
     directorio de trabajo solamente.

   * -R - Recursivo (contrario de -l).  Recursivo es por omisión; la
     única razón de pasar -R es contrarrestar un -l en su fichero
     .cvsrc.



File: cvsbook.info,  Node: update,  Next: watch,  Prev: unedit,  Up: Ordenes y Opciones

update
------

Sinopsis: update [OPCIONES] [FICHEROS]

   * Nombres alternativos - up, upd

   * Requiere - Copia de trabajo, repositorio

   * Cambia - Copia de trabajo

Mezcla los cambios del repositorio en su copia de trabajo.  Como efecto
colateral, indica qué ficheros en su copia de trabajo están modificados
(pero si la opción global -Q se pasa, estas indicaciones no se
imprimen).  (Véase también *Note checkout::).

Opciones:

   * -A - Borra cualquier etiqueta adhesiva, o cualquier clave RCS de
     modo de expansión adhesiva.  Esto puede resultar en que los
     contenidos de los ficheros cambian, si las revisiones de la cabeza
     del tronco son diferentes del las anteriores revisiones adhesivas
     .  (Imagine -A como si fuera una obtención fresca del tronco de un
     proyecto).

   * -C - Borra cualquier fichero localmente alterado y los remplaza
     con las últimas versiones del repositorio.  Esto no es
     necesariamente lo mismo que revertir los ficheros, dado que el
     repositorio podría tener cambios desde la última actualización u
     obtención.  Cualquier modificación se salva en `.#fechero.rev'.

     Nota: Esta opción fue implementada en enero de 2000; si su CVS fue
     adquirido antes que entonces, tendrá que actualizarlo.

   * -D FECHA - Actualiza a la revisión más reciente no posterior a
     FECHA.  Esta opción es adhesiva e implica -P.  Si la copia de
     trabajo tiene fecha adhesiva, las entregas no son posibles.

   * -d - Recupera directorios ausentes - esto es, directorios que
     existen en el repositorio pero no todavía en la copia de trabajo.
     Tales directorios puden haber sido creados en el repositorio
     después de que la copia de trabajo fuera obtenida.  Sin esta
     opción, update sólo opera en los directorios presentes en la copia
     de trabajo; los ficheros se traen desde el repositorio, pero los
     nuevos directorios no. (Ver también -P).

   * -f - Fuerza a la revisión de cabecera si no se encuentran
     revisiones coincidentes con las opciones -D o -r.

   * -I NOMBRE - Como la opción -I de import.

   * -j REV[:FECHA] o -j REV1[:FECHA] -j REV2[:FECHA] - Une, o mezcla,
     dos líneas de desarrollo.  No teniendo en cuenta el argumento
     opcional de FECHA por el momento (lo retomaremos luego), así es
     cómo -j funciona: Si sólo se da una, toma todos los cambios desde
     el ancestro común a REV y los mezcla en la copia de trabajo.  El
     "acestro común" es la última revisión que es acestral a ambas
     revisiones en el directorio de trabajo y a REV.  Si se dan dos
     opciones -j, mezcla los cambios de REV1 a REV2 en la copia de
     trabajo.

     Las etiquetas especiales HEAD y BASE pueden ser usadas como
     argumentos de -j; significan la más reciente revisión del
     repositorio y la revisión en la que se basa la copia actual,
     respectivamente.

     Y para los argumentos opcionales de FECHA, si REV es una rama, se
     toma normalmente el significado de la última revisión no posterior
     a FECHA.  La fecha debe estar separada de la revisión por una
     coma, sin espacios, por ejemplo:

          floss$ cvs update -j UnaRama:1999-07-01 -j UnaRama:1999-08-01

     En este ejemplo, diferentes fechas en la misma rama se usan, así
     el efecto es tomar los cambios en esta rama desde julio a agosto y
     mezclarlos en la copia de trabajo.  Sin embargo, note que no se
     requiere que la rama sea la misma en ambas opciones -j.

   * -k MODO - Realiza una sustitución RCS de acuerdo al MODO.  (Vea la
     sección *Note Claves de Sustitucion (Claves RCS):: más adelante en
     este capítulo).  El modo permanece adhesivo en la copia de
     trabajo, así que afectará a futuras actualizaciones (pero vea -A).

   * -l - Local.  Actualiza sólo el directorio actual.

   * -P - Poda los directorios vacíos.  Cualquier directorio controlado
     por CVS que no contenga ficheros al final de la actualización se
     borra de la copia de trabajo.  (Ver también -d).

   * -p - Envía los contenidos del fichero a la salida estándar en vez
     de a los ficheros.  Usando normalmente para revertir a una
     revisión anterior sin producir etiquetas adhesivas en la copia de
     trabajo.  Por ejemplo:

          floss$ cvs update -p -r 1.3 LÉAME.txt > LÉAME.txt

     Ahora LÉAME.txt en la copia de trabajo tiene los contenidos de su
     pasada revisión 1.3, simplemente como si lo tuviera editado a mano
     en este estado.

   * -R - Recursivo.  Desciende a los subdirectorios para actualizar
     (por omisión).  La única razón por la que lo especificaría sería
     para contrarrestar un -l en .cvsrc.

   * -r REV - Actualiza (o rejuvenece) a la revisión REV.  Cuando
     actualiza una copia de trabajo entera, REV es habitualmente una
     etiqueta (regular o rama).  Sin embargo, cuando actualice un
     fichero individual, es tan probable que sea un número de revisión
     como una etiqueta.

     Esta opción es adhesiva.  Si los ficheros se cambian a una etiqueta
     que no sea de una rama o revisiones adhesivas, no pueden ser
     omitidas hasta que lo adhesivo se quite.  (Véase -A).  Si REV es
     una etiqueta de rama, sin embargo, las entrgas son posibles.
     Simplemente se entregarán nuevas revisiones en esta rama.

   * -WSPEC - Especifica filtros de cobertura para usarse durante la
     actualización.  Puede usar esta opción muchas veces.  (Vea *Note
     cvswrappers:: en *Note Ficheros de Administracion del Repositorio::
     en este capítulo para obtener más detalles sobre las
     especificaciones de cobertura).  No hay espacio entre -W y su
     argumento.



File: cvsbook.info,  Node: watch,  Next: watchers,  Prev: update,  Up: Ordenes y Opciones

watch
-----

Sinopsis: watch on|off|add|remove [OPCIONES] [FICHEROS]

   * Nombres alternativos - Ninguno

   * Requiere - Copia de trabajo, repositorio

   * Cambia - Lista de observaciones en el repositorio

Configura en observación en uno o más ficheros.  A diferencia de la
mayoría de los mandatos de CVS, la observación requiere un submandato
adicional para hacer algo útil.  (Véase también *Note watchers::, *Note
edit::, *Note editors::, *Note unedit:: y *Note users::).

Submandatos:

   * on - Declara que los ficheros están siendo observados.  Esto
     significa que se crean en modo de sólo-lectura en la obtención, y
     los usuarios deben hacer cvs edit para crearlos como
     lectura-escritura (notificar a cualquier observador que el fichero
     ahora está siendo editado).  Conectar una observación no le añade
     a la lista de observadores para ningún fichero. (Vea `watch add' y
     `watch remove' para eso).

   * off - Contrario de watch on.  Declara que los ficheros ya no están
     siendo observados.

   * add - Le añade a la lista de observadores para este fichero.
     Usted será notificado cuando alguien entregue o ejecute cvs edit o
     cvs unedit (pero vea la opción -a).

   * remove - Contrario de watch add.  Le borra de la lista de
     observadores para este fichero.


Opciones (para usar cualquier submandato de observación).  Las tres
funciones tienen los mismos significados que para editar:

   * -a ACCIONES

   * -l

   * -R



File: cvsbook.info,  Node: watchers,  Prev: watch,  Up: Ordenes y Opciones

watchers
--------

Sinopsis: watchers [OPCIONES] [FICHEROS]

   * Nombres alternativos - Ninguno

   * Requiere - Copia de trabajo, repositorio

   * Cambia - Nada

Muestra quién está observando qué ficheros.

Opciones - estas opciones significan la misma cosa aquí que para *Note
edit:::

   * -l

   * -R



File: cvsbook.info,  Node: Claves de Sustitucion (Claves RCS),  Next: Ficheros de Administracion del Repositorio,  Prev: Ordenes y Opciones,  Up: Referencia de CVS

Claves de Sustitucion (Claves RCS)
==================================

CVS puede realizar algunas sustituciones en ficheros, permitiéndole que
mantenga automáticamente alguna información actualizada en sus ficheros.
Todas las sustituciones se realizan a través de unos patrones de
palabras claves determinadas, rodeadas por los símbolos de dolar. Por
ejemplo:

     $Revision: 1.6 $

en un fichero se expande a algo como

     $Revision: 1.6 $

y CVS seguirá manteniendo la cadena de revisión actualizada a medida
que se añaden nuevas revisiones.

* Menu:

* Controlling Keyword Expansion::          How to use keywords in your files.
* List Of Keywords::                       All the keywords.


File: cvsbook.info,  Node: Controlling Keyword Expansion,  Next: List Of Keywords,  Up: Claves de Sustitucion (Claves RCS)

Controlling Keyword Expansion
-----------------------------

By default, CVS performs keyword expansion unless you tell it to stop.
You can permanently suppress keyword expansion for a file with the -k
option when you add the file to the project, or you can turn it off
later by invoking admin with -k.  The -k option offers several different
modes of keyword control; usually you want mode o or b, for example:

     floss$ cvs add -ko chapter-9.sgml

This command added `chapter-9.sgml' to the project with keyword
expansion turned off.  It sets the file's default keyword expansion mode
to `o', which means no substitution. (Actually, the "o" stands for
"old", meaning to substitute the string with its old value, which is the
same as substituting it for itself, resulting in no change.  I'm sure
this logic made sense to somebody at the time.)

Each file's default keyword mode is stored in the repository.  However,
each working copy can also have its own local keyword substitution mode
- accomplished with the -k options to checkout or update.  You can also
have a mode in effect for the duration of just one command, with the -k
option to diff.

Here are all the possible modes, presented with the -k option prepended
(as one would type at a command line).  Any of these options can be used
as either the default or local keyword substitution mode for a file:

   * -kkv - Expands to keyword and value.  This is the default keyword
     expansion mode, so you don't need to set it for new files.  You
     might use it to change a file from another keyword mode, however.

   * -kkvl - Like -kkv, but includes the locker's name if the revision
     is currently locked.  (See the -l option to admin for more on
     this.)

   * -kk - Won't expand values in keyword strings, just uses the keyword
     name.  For example, with this option,

          $Revision: 1.6 $

     and

          $Revision: 1.6 $

     would both "expand" (okay, contract) to:

          $Revision: 1.6 $

   * -ko - Reuses the keyword string found in the file (hence "o" for
     "old"), as it was in the working file just before the commit.

   * -kb - Like -ko, but also suppresses interplatform line-end
     conversions.  The "b" stands for "binary"; it is the mode you
     should use for binary files.

   * -kv - Substitutes the keyword with its value, for example

          $Revision: 1.6 $

     might become:

          1.5

     Of course, after that's happened once, future substitutions will
     not take place, so this option should be used with care.


