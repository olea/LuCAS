@c ---------------------------------------------------------
@node CVS avanzado
@unnumbered CVS avanzado


Ahora que hemos cubierto los conceptos básicos sobre el uso de CVS y la 
administración del repositorio, miraremos cómo CVS puede ser incorporado
dentro del proceso de desarrollo. El ciclo de funcionamiento de CVS --
obtener (@emph{checkout}), actualizar (@emph{update} entregar 
(@emph{commit}), actualizar, entregar, y así sucesivamente -- fué mostrado 
en los ejemplos @ref{Una introduccion a CVS}. Este capítulo amplía este ciclo 
y muestra como CVS puede ser usado para ayudar a los desarrolladores a 
comunicarse, dar resúmenes del la actividad y la historia del proyecto, 
fusionar diferentes ramas de desarrollo y ejecutar tareas frecuentes 
automáticamente. Algunas de las técnicas explicadas introducen nuevas 
órdenes, pero muchas simplemente indican otra forma mejorada de usar 
órdenes que ya se han visto.

@menu
* Alarmas (CVS como telefono)::
* Mensajes log y correos electrónicos a la entrega::
* Cambiar un mensaje log después de una entrega::
* Deshacerse de una copia de trabajo::
* Historial -- Un resumen de la actividad del repositorio::
* Anotaciones -- Sumario detallado de la actividad del proyecto::
* Anotaciones y ramificaciones::
* Usando expansión de palabras::
* Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)::
* Vigilando fuentes de terceras partes (Derivaciones comerciales)::
* Exportar para distribución pública::
* El humilde gurú::
@end menu

@c --------------------------------------------------------
@node Alarmas (CVS como telefono)
@section Alarma (CVS como telefono)

Un beneficio importante de usar CVS en un proyecto es que puede funcionar
tanto como un dispositivo de comunicación como para almacenar información
sobreel proyecto. Esta sección se centra en cómo se puede usar CVS para
que los participantes estén informados de lo que pasa en el projector. 
Como en otros aspectos de CVS, estas características fomentan la 
cooperación. Peros los participantes tienen que querer expresamente 
que se les informe; si la gente elige no usar estas carácteristicas de 
comunicación no hay nada que CVS puede hacer.

@menu
* Cómo funcionan las alarmas::
* Habilitar alarmas en el repositorio::
* Usando alarmas durante el desarrollo::
* Cómo acabar una sesión de edición::
* Controlar qué acciones son vigiladas::
* Encontrar quién vigila qué::
* Recomendar a la gente usar alarmas::
* Cómo aparecen las alarmas en el repositorio::
@end menu
 
@c -------------------------------------------------------------------
@node Cómo funcionan las alarmas
@subsection Cómo funcionan las alarmas

En su comportamiento por defecto CVS trata cada copia de trabajo como una
caja independiente. Nadie sabe lo que usted está haciendo hasta que 
entrega sus cambios. Así mismo usted no sabe lo que los demás están 
haciendo en las suyas; excepto a través de los métodos normales de 
comunicación, por ejemplo pegando una voz en la oficina: -¡Oye, voy 
a trabajar en el fichero.c ahora. Decidme si alguién está trabajando 
en él para no tener conflictos!

Este método informal funciona en proyectos donde la gente sabe más o 
menos quién es responsable de qué. Sin embargo, es más dificil cuando 
hay un gran número de desarrolladores activos en todas las partes del 
código base y quieren evitarse los  conflictos. En estos casos, 
frecuentemente se pasa al área de responsabilidad de otro compañero y
no se puede estar gritando en la oficina ya que el lugar de trabajo 
es geográficamente disperso.

Una característica de CVS llamada @code{alarma} proporciona un modo de 
avisarse entre ellos quién está trabajando en que fichero en un 
momento dado. Si alguien establece una alarma en un fichero puede ser
advertido cuando otro desarrollador empieze a trabajar es ese fichero. 
La advertencia se envía normalmente por medio de correo electrónico  
pero es posible usar otros métodos.

Para usar alarmas, hay que modificar uno ó dos ficheros del área de 
admistración del repositorio, y los desarrolladores tienen que hacer un 
paso extra en el ciclo ususal de obtención/actualización/entrega. Los 
cambios en el repositorio son bastante simples: Necesita editar el 
fichero @file{CVSROOT/notify} para que CVS sepa que advertencias debe 
realizar. También hay que añadir algunas líneas al fichero
 @file{CVSROOT/users}, que aporta direcciones externas de correo 
electrónico.

En la copia de trabajo los desarrolladores tienen que decir al CVS qué 
ficheros debe vigilar para que CVS informe cuando alguién va a editar 
alguno de esos ficheros. Además uno tiene que decirle a CVS cuando empieza
o termina de editar un fichero para que CVS a su vez lo indique a otros 
desarrolladores que podrían estar vigilando. Las siguientes órdenes son 
usadas para estos pasos extra.

@itemize 
@item cvs watch
@item cvs edit
@item cvs unedit
@end itemize

El patrón de la orden @code{watch} se diferencia de otras órdenes comunes 
en que utiliza subórdenes, como por ejemplo @w{@code{cvs watch add...}}, 
@w{@code{cvs watch remove...}}, y así.

En el siguiente ejemplo vamos a ver cómo se establecen las alarmas en el 
repositorio y cómo se usan desde el área del desarrollador. Los dos 
usuarios de ejemplo, jrandom y qsmith, tienen su propia copia de trabajo 
que puede estar en diferentes máquinas. Seguimos asumiendo que la 
variable de entorno $CVSROOT está asignada y por ello no tenemos que 
pasar la opción -d <REPOS> a ningún comando CVS.

@c ----------------------------------------------------------
@node Habilitar alarmas en el repositorio
@subsection Habilitar alarmas en el repositorio

Primero se debe activar la notificación mediante correo electrónico 
editando el fichero CVSROOT/notify. Uno de los dos desarrolladores debe 
hacer esto o el administrador del repositorio si los desarrolladores no 
tienen permiso para cambiar los ficheros administrativos del repositorio.
En cualquier caso la primera cosa es obtener el área administrativa y 
editar el fichero notify:

@example
floss$ cvs -q co CVSROOT 
U CVSROOT/checkoutlist 
U CVSROOT/commitinfo 
U CVSROOT/config 
U CVSROOT/cvswrappers 
U CVSROOT/editinfo 
U CVSROOT/loginfo 
U CVSROOT/modules 
U CVSROOT/notify 
U CVSROOT/rcsinfo 
U CVSROOT/taginfo 
U CVSROOT/verifymsg 
floss$ cd CVSROOT
floss$ emacs notify 
... 
@end example

Cuando se edita el fichero notify por primera vez nos encontramos con 
algo como esto:

@example
# Versión en castellano
# El fichero 'notify' especifica donde van se envían las notificaciones 
# procedentes de alarmas establecidas mediante "cvs watch add" ó "cvs 
# edit". La primera entrada de una línea es una expresión regular que se
# compara con el directorio donde el cambio se está haciendo relativo a
# $CVSROOT. Si coincide el resto de la línea es un programa filtro que 
# debería contener una ocurrencia %s que indica el usuario a notificar, e 
# informcación de su entrada de datos estándar.  
# 
# "ALL" o "DEFAULT" puede ser usada en lugar de la expresión regular.
# 
# Por ejemplo:
# ALL mail %s -s "notificación de CVS"
@end example

En realidad todo lo que hay que hacer es descomentar la última línea 
quitando el carácter @code{#}. Aunque @code{notify} proporciana la misma 
flexibilidad que otros ficheros administrativos a través de las 
expresiones regulares normalmente no se va usar. La única razón de 
tener múltiples lineas, cada una con un expresión regular para cada 
parte del repositorio es si se van usar otros métodos de notificación 
distintos para cada proyecto. Normalmente la mayoría de los proyectos usan
correo electrónico ya que es un buen método de notificación.  

Para especificar la notificación mediante correo electrónico, la línea

@example
ALL mail %s -s "notificación de CVS"
@end example

debería funcionar en cualquier Unix estándar. Éste comando hace que las
notificaciones o avisos sean enviadas mediante correo electrónico 
con la línea de @code{subject} @code{notificación de CVS} (La expresión se 
compara contra cualquier directorio). Cuando se haya descomentado la 
línea hay que entregar el fichero notify para que el repositoria sea 
consciente del cambio:

@example
floss$ cvs ci -m "establecido notificación por alarma" 
cvs commit: Examining . 
Checking in notify; 
/usr/local/newrepos/CVSROOT/notify,v  <--  notify 
new revision: 1.2; previous revision: 1.1 
done 
cvs commit: Rebuilding administrative file database 
floss$  
@end example

Editar este fichero es todo lo que hay que hacer para establecer alarmas 
en el repositorio. Sin embargo si hay desarrolladores trabajando en 
máquinas remotas es necesario editar el fichero @file{CVSROOT/users}
también. La función de este fichero es indicar a CVS a qué direcciones 
de correo enviar las notificaciones para los usuarios remotos.
El formato de cada línea del fichero users sería:

@example
CVS_USERNAME:EMAIL_ADDRESS 
@end example

Por ejemplo,

@example
qsmith:quentinsmith@@farawayplace.com 
@end example

El nombre de usuario al principio de la línea corresponde a un usuario 
de CVS del fichero @file{CVSROOT/password} (si está presente y el 
método de acceso por servidor está siendo usado), o el usuario  
del servidor ejecutando CVS. Siguiendo los dos puntos viene la 
dirección de correo de ese usuario a la que el CVS enviará las 
notificaciones.

Desgraciadamente en el momento de la escritura de este documeto el 
fichero users no existe en la distribución estándar de CVS. Debido a que
es un fichero administrativo no sólo se debe crearlo, añadirlo 
@code{cvs add ...} y entregarlo @code{commit ...} de la forma usual sino que
hay que añadirlo al fichero @file{CVSROOT/checkoutlist} para que una
copia sea mantenida en el repositorio.

Lo siguiente es una sesión de ejemplo:

@example
floss$ emacs checkoutlist 
  ... (añade la línea para el fichero users) ... 
floss$ emacs users 
  ... (añade la línea para el usuario qsmith) ... 
floss$ cvs add users 
floss$ cvs ci -m "añade users a checkoutlist, qsmith a users" 
cvs commit: Examining . 
Checking in checkoutlist; 
/usr/local/newrepos/CVSROOT/checkoutlist,v  <--  checkoutlist 
new revision: 1.2; previous revision: 1.1 
done 
Checking in users; 
/usr/local/newrepos/CVSROOT/users,v  <--  users 
new revision: 1.2; previous revision: 1.1 
done 
cvs commit: Rebuilding administrative file database 
floss$  
@end example

Es posible usar direcciones de correo de formato expandido en 
@file{CVSROOT/usres}, pero hay que tener cuidado en poner todos los 
espacios en blanco entre comillas. Veamos el siguiente ejemplo

@example
qsmith:"Quentin Q. Smith <quentinsmith@@farawayplace.com>"
@end example

o

@example
qsmith:'Quentin Q. Smith <quentinsmith@@farawayplace.com>' 
@end example

Sin embargo, esto no funcionará:

@example
qsmith:"Quentin Q. Smith" <quentinsmith@@farawayplace.com> 
@end example

Si hay dudas debería probar ejecutando la orden del fichero notify 
directamente reemplazando @code{%s} en  

@example
mail %s -s "CVS notification" 
@end example

por lo que sigue después de los dos puntos en el fichero users. 
Si funciona desde el prompt debería hacerlo también en el fichero de 
usuarios.

Cuando está terminado el fichero checkout debería aparecer como:

@example
# El fichero 'checkoutlist' se usa para soportar ficheros adicionales de 
# control de versión administrativos de $CVSROOT/CVSROOT, como plantillas.
#
# La primera entrada de una línea es un nombre de fichero que será obtenido 
# del correspondiente RCS fichero del directorio $CVSROOT/CVSROOT.
# El resto de la línea será el mensaje de error que aparecerá si el fichero
# no se puede obtener. 
# 
# Formato del fichero: 
# 
#       [<espacio en blaco>]<nombre del fichero><espcio en blanco>
<mensaje de error><find de línea> 
# 
# líneas de comentario enmpiezan con '#' 

users   No ha sido posible obtener @code{users} file in CVSROOT. 
@end example

Ya hemos visto como se prepara el repositorio para las alarmas. Pasemos
ahora a lo que los desarrolladores tienen que hacer en sus copias de trabajo.

@c --------------------------------------------------------------
@node Usando alarmas durante el desarrollo
@subsection Usando alarmas durante el desarrollo

Primero, un programador obtiene una copia de trabajo y se añade a la 
lista de vigilantes para alguno de los ficheros del projecto:

@example
floss$ whoami 
jrandom 
floss$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
floss$ cd myproj 
floss$ cvs watch add hello.c 
floss$ 
@end example
 
La última orden, @code{cvs watch add hello.c}, indica a CVS que nofifique a 
jramdom si alguien empieza a trabajar en hello.c. O sea que añade jrandom a
la lista de alarma de hello.c. Para que CVS pueda notificar tan pronto 
como sea posible que un fichero se va a editar el usuario tiene que 
indicárselo a CVS mediante la orden @code{cvs edit} y el nombre del fichero.
CVS no tiene otro modo de saber cuando alguien empieza a trabajar en un 
fichero. Una ver que se ha obtenido una copia, CVS no es normalmente 
invocado hasta la siguiente actualización o entrega, la cual sucede después 
de que el fichero se haya editado:

@example
paste$ whoami 
qsmith 
paste$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
paste$ cd myproj 
paste$ cvs edit hello.c 
paste$ emacs hello.c 
... 
@end example

Cuando qsmith ejecuta @code{cvs edit hello.c}, CVS mira en la lista de alarma de 
hello.c, ve que jrandom está en ella, y envia un correo a jrandom diciendole 
que qsmith ha empezado a editar el fichero. El fichero incluso parece haber 
llegado del mismo qsmith:


@example
From: qsmith 
Subject: CVS notification 
To: jrandom 
Date: Sat, 17 Jul 1999 22:14:43 -0500 

myproj hello.c 
--  
Triggered edit watch on /usr/local/newrepos/myproj 
By qsmith 

Además cada vez que qsmith (o cualquiera) entrega una nueva revisión de 
hello.c, jrandon recivirá otro correo electrónico:


myproj hello.c 
-- 
Triggered commit watch on /usr/local/newrepos/myproj 
By qsmith 
@end example

Después de recibir estos correos, jrandom podría querer actualizar su 
copia de hello.c para ver qué cambios qsmith ha hecho o quizás quisiera 
enviar un correo a qsmith para saber porqué está trabajando en ese fichero.
Nada fuerza a qsmith a recordar hacer un @code{cvs edit}. Si lo hizo fué 
porque quizá querría hacerselo saber a jrandom. De cualquier forma, incluso si 
se olvida hacer un @code{cvs edit} al hacer una entrega se disparará la 
notificación. La razón de @code{cvs edit} es que los advierte a los vigilantes 
antes de que empizes a trabajar en el fichero y éstos se pueden poner en 
contacto contigo para resolver el conflicto, antes de que hayas desperdiciado 
el tiempo.

CVS asume que cualquiera que hace un @code{cvs edit} quiere ser añadido a la 
lista de alarma de ese fichero, al menos temporalmente, en caso de que algún
otro también lo edite. Cuando qsmith ejecuta @code{cvs edit}, se convierte
en un vigilante de hello.c. Él y jrandom recivirían un notificación si una 
tercera persona ejecutase @code{cvs edit} en ese fichero (ó lo entregara).

Sin embargo, CVS también asume que la persona que está editando el fichero 
quiere estar en la lista mientras está trabajando en él. Esos usuarios serán 
borrados de la lista cuando hayan hecho su edición del fichero. Si quieren 
ser vigilantes permanenetes deberán ejecutar @code{cvs watch add}.
CVS asume por defecto que alguién ha terminado la edición cuando él ó ella 
hace una entrega del fichero.

Cualquiera que está en la lista de vigilancia de un fichero por haber 
ejecutado @w{@code{cvs edit}} en ese fichero es conocido como @dfn{temporary 
watcher} y es eliminado de la lista cuando entrege un cambio en el fichero. 
Si quiere editarlo de nuevo tendría que volver a ejecutar @w{@code{cvs 
edit}}.

La suposición de que la primera entrega acaba la sesión de edición es 
sólamente una buena predicción, ya que CVS no sabe cuantas entregas la 
persona necesitará para hacer sus cambios. La predicción es buena para 
@dfn{one-off} cambios -- cambios donde hay que arreglar un pequeño error 
en un fichero y entregarlo. Para ediciones más prolongadas que requieren 
varias entregas sería bueno que el usuarios se añadiera permanentemente a 
la lista de vigilantes.

@example
paste$ cvs watch add hello.c 
paste$ cvs edit hello.c 
paste$ emacs hello.c 
... 
paste$ cvs commit -m "escrito hola en sánscrito" 
@end example

Incluso después de una entraga, qsmith quedará como vigilante de hello.c
ya que ejecutó @code{watch add} sobre él. (A propósito, qsmith no recibirá 
notificaciones sobre sus propios cambios; sólo los demás. CVS es lo 
suficientemente listo para no advertirte sobre tus propias acciones.)


@c --------------------------------------------------------------
@node Cómo acabar una sesión de edición
@subsection Cómo acabar una sesión de edición 

Si no quieres hacer una entrega sino acabar tu sesión de edición 
explicitamente, se puede hacer ejecutando @code{cvs unedit}:

@example
paste$ cvs unedit hello.c 
@end example

Dese cuenta de que además de notificar a los demás vigilantes que ha 
terminado esta orden ofrece la posibilidad de deshacer todos los cambios 
que haya hecho en el fichero.


@example
paste$ cvs unedit hello.c 
hello.c has been modified; revert changes? y 
paste$  
@end example

Si usted contesta @code{y}, CVS deshará todos los cambios y notificará 
a todos los vigilantes que no seguirá editando el fichero. Si responde 
@code{n}, CVS mantiene sus cambios  y seguirá registrado como uno de 
los editores del fichero. Por lo tanto no habrá nofificación; de hecho es
como si no hubiera ejecutado @w{@code{cvs unedit}}. Esta posibilidad es 
un poco tremenda, pero fácil de entender: si declara al mundo que ha 
terminado su sesión de edición cualquier cambio que no haya entregado 
antes es porque no tenía intención de guardarlos. Al menos así es como lo
ve CVS. No es necesario decir que tenga cuidado.

@c ---------------------------------------------------------------
@node Controlar qué acciones son vigiladas
@subsection Controlar qué acciones son vigiladas

Por defecto los vigilantes son noficados ante tres acciones: ediciones, 
entregas, y terminación de sesión. Sin embargo si usted sólo quiere ser
notificado, por ejemplo en las entregas, puede restringir sus 
notificaciones con el indicador -a  de la orden watch (a  por action).



@example
floss$ cvs watch add -a commit hello.c
@end example

Es posible pasar el indicador -a dos veces si quiere ser advertido de 
entregas y notificaciones.

@example
floss$ cvs watch add -a edit -a commit hello.c 
@end example

Añadir alarmas con el indicador -a no causará la eliminación de ninguna 
de sus existentes alarmas. Si estaba vigilando para las tres acciones 
sobre hello.c, el ejecutar

@example
floss$ cvs watch add -a commit hello.c 
@end example

no tiene efecto -- usted seguirá teniendo las tres acciones.
Para quitar las alarmas hay que hacer lo siguiente

@example
floss$ cvs watch remove hello.c 
@end example

Esta orden, por defecto quita las tres clases de acciones. Especificando
la acción mediante -a se quitan sólo las alarmas que se especifiquen en 
la línea de órdenes:

@example
floss$ cvs watch remove -a commit hello.c 
@end example

Esto indica que usted desea dejear de recibir notificaciones sobre
entregas pero seguirá recibiendo notificaciones sobre ediciones y 
terminación de edición (asumiendo que tenía vigilancia para estas 
dos acciones).

Hay dos opciones que se pueden pasar al indicador -a: 
all ó none (todas ó niguna).
@emph{all} significa que las acciones que se vigilarán son las tres antes 
mencionadas y @emph{none} ninguna de ellas. 
Ya que el comportamiento por defecto de CVS sin el indicador -a es 
vigilar todas las acciones y si no se vigila ninguna es como
estar fuera de la lista de vigilancia es dificil imaginar una 
situación en la que que se usen estas dos opciones. Sin embargo, 
"cvs edit" también usa lleva el indicador -a, y en esta caso puede
ser útil especificar @emph{all} ó @emph{none}. 
Por ejemplo, alguien que va a trabajar brevemente en un fichero quizá 
no quiera ser notificado sobre lo que están haciendo otros en ese 
fichero. La orden

@example
paste$ whoami 
qsmith 
paste$ cvs edit -a none README.txt 
@end example

hace que vigilantes de README.txt sean notificados de que qsmith va 
a trabajar en él, pero qsmith no será un vigilante temporal de 
README.txt durante su sesión de edición ya que pidió explicitamente
no vigilar ninguna acción.

Observe que esto sólo afecta a lo que usted está vigilando con la
orden @code{cvs watch}. Usted puede dejar de vigilar cualquier fichero 
pero esto no afectará a las alarmas de los demás.

@c ------------------------------------------------------------------
@node Encontrar quién vigila qué
@subsection Encontrar quién vigila qué

Alguna vez puede interesarle saber quien está vigilando o editando un 
fichero sin antes de ejecutar @code{cvs edit} o ver quién está editando qué 
sin añadirse a ninguna lista de vigilancia. O podría haber olvidado 
su propio estatus. Después de haber establecido algunas alarmas y haber 
entregado algunos ficheros es fácil saber que está uno vigilando y
editando.

CVS proporciona dos comandos para mostrar quién está vigilando y editando 
qué ficheros -- @code{cvs watchers} y @code{cvs editors}:

@example
floss$ whoami 
jrandom 
floss$ cvs watch add hello.c 
floss$ cvs watchers hello.c 
hello.c jrandom  edit unedit  commit 
floss$ cvs watch remove -a unedit hello.c 
floss$ cvs watchers hello.c 
hello.c jrandom  edit commit 
floss$ cvs watch add README.txt 
floss$ cvs watchers 
README.txt      jrandom edit    unedit  commit 
hello.c jrandom edit    commit 
floss$  
@end example

Observe que la última orden @code{cvs watchers} no especifica ningún 
fichero y así muestra los vigilantes para todos los ficheros que 
estén siendo vigilados.

Todas las órdenes @code{watch} y @code{edit} tienen en común con otras órdenes 
CVS esta característica. Si usted especifica nombres de ficheros estas 
órdenes actuan sobre ellos. Si se especifican nombres de directorio 
actuan sobre cada fichero de ese directorio y sus subdirectorios. Si no 
especifica nada, actuan sobre el directorio actual y sus subdirectorios. 
Siguiendo con la sesión del ejemplo anterior:

@example
floss$ cvs watch add a-subdir/whatever.c  
floss$ cvs watchers 
README.txt      jrandom edit    unedit  commit 
hello.c jrandom edit    commit 
a-subdir/whatever.c     jrandom edit    unedit  commit 
floss$ cvs watch add 
floss$ cvs watchers 
README.txt      jrandom edit    unedit  commit 
foo.gif jrandom edit    unedit  commit 
hello.c jrandom edit    commit  unedit 
a-subdir/whatever.c     jrandom edit    unedit  commit 
a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit 
b-subdir/random.c       jrandom edit    unedit  commit 
floss$  
@end example

El penúltimo comando hizó a jrandom un vigilante de todos los ficheros 
del proyecto y el último mostró cada lista de cada fichero del proyecto.
La salida de @w{@code{cvs watchers}} puede que no perfectamente 
alineado por columnas debido a que se mezclan tabuladores con 
información de longitud variable, pero el formateo de las líneas es 
consistente.

@example
[FILENAME] [espacio en blanco] WATCHER [espacio en blanco] 
ACTIONS-BEING-WATCHED... 
@end example

Observe qué pasa cuando qsmith empieza a editar uno de los ficheros:

@example
paste$ cvs edit hello.c 
paste$ cvs watchers 
README.txt      jrandom edit    unedit  commit 
foo.gif jrandom edit    unedit  commit 
hello.c jrandom edit    commit  unedit 
       qsmith  tedit   tunedit tcommit 
a-subdir/whatever.c     jrandom edit    unedit  commit 
a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit 
b-subdir/random.c       jrandom edit    unedit  commit 
@end example

El fichero hello.c tiene un nuevo vigilante: qsmith (observe que el 
nombre del fichero no se repite sino que se deja un espacio en blanco 
al principio de la línea; esto es importante si usted alguna vez 
escribiera un programa que compila la salida de la orden).
Ya que está editando el fichero hello.c, qsmith tendrá una 
@dfn{temporary watch alarma temporal} sobre el fichero, la cual 
se terminará cuando haga una entrega sobre éste. 
El prefijo ð@code{t} delante de cada acción indica que son 
alarmas termporales.
Si qsmith se añade a la lista de vigilantes regulares de hello.c 

@example
paste$ cvs watch add hello.c 
README.txt      jrandom edit    unedit  commit 
foo.gif jrandom edit    unedit  commit 
hello.c jrandom edit    commit  unedit
       qsmith  tedit   tunedit tcommit edit    unedit  commit 
a-subdir/whatever.c     jrandom edit    unedit  commit 
a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit 
b-subdir/random.c       jrandom edit    unedit  commit 
@end example

se encontrará a la vez como un vigilante temporal y un vigilante 
permanente. Se puede decir que el estatus de vigilante permanente 
sobrepasa al temporal. Entonces la línea sería como:

@example
        qsmith  edit    unedit  commit 
@end example

Sin embargo, CVS no puede reemplazar las alarmas temporales porque 
sabe que orden ocurren las acciones. ¿Se quitará qsmith de la lista
permanente de vigilancia antes de acabar su sesión de edición?, o 
¿acabará sus ediciones siendo todavía un vigilante?. En el primer caso 
las acciones @code{edit / unedit / commit} desaparecen mientras que 
@code{tedit / tunedit / tcommit} permanecen; en el segundo caso ocurre 
lo contrario. De cualquier forma esto no será de gran importancia.
Casi siempre lo que usted hará es ejecutar

@example
floss$ cvs watchers 
@end example

o 

@example
floss$ cvs editors 
@end example

desde el nivel más alto para ver quién está haciendo qué. No necesita 
conocer los detalles de quien está vigilando que acciones: lo 
importante son las personas y los ficheros.
@c ----------------------------------------------------
@node Recomendar a la gente usar alarmas
@subsection Recomendar a la gente usar alarmas

Habrá observado que el funcionamiento de las alarmas depende, en 
última instancia de la colaboración de todos los desarrolladores. 
Si alguien empieza a editar un fichero sin ejecutar @code{cvs edit}, 
nadie lo sabrá hasta que los cambios se entreguen. Como @code{cvs edit}
se usa a un nivel superior y no está dentro de la rutina normal de 
desarrollo las personas pueden olvidarse fácilmente de hacerlo.

Aunque CVS no puede forzar a alguien a usar @code{cvs edit}, tiene un 
mecanismo que es permite a recordar a los usuarios a hacerlo; 
la orden @code{watch on}:

@example
floss$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
floss$ cd myproj 
floss$ cvs watch on hello.c 
floss$ 
@end example

Ejecutando @code{cvs watch} sobre hello.c, jrandom hace que futuras 
obtenciones de copias de myproj hagan que hello.c sea de sólo lectura en la 
copia de trabajo. Cuando qsmith intenta trabajar sobre él comprobará 
que es de sólo lectura y se le recordará que debe ejecutar primero 
@code{cvs edit}:

@example
paste$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
paste$ cd myproj 
paste$ ls -l 
total 6 
drwxr-xr-x   2 qsmith    users        1024 Jul 19 01:06 CVS/ 
-rw-r--r--   1 qsmith    users          38 Jul 12 11:28 README.txt 
drwxr-xr-x   4 qsmith    users        1024 Jul 19 01:06 a-subdir/ 
drwxr-xr-x   3 qsmith    users        1024 Jul 19 01:06 b-subdir/ 
-rw-r--r--   1 qsmith    users         673 Jun 20 22:47 foo.gif 
-r--r--r--   1 qsmith    users         188 Jul 18 01:20 hello.c 
paste$ 
@end example

Cuando lo ha hecho, el fichero será de lectura-escritura. Entonces lo 
podrá editar y cuando haga entregas, pasa a modo de sólo lectura:


@example
paste$ cvs edit hello.c 
paste$ ls -l hello.c 
-rw-r--r--   1 qsmith    users         188 Jul 18 01:20 hello.c 
paste$ emacs hello.c 
  ...  
paste$ cvs commit -m "decir hello en arameo" hello.c 
Checking in hello.c;  
/usr/local/newrepos/myproj/hello.c,v  <--  hello.c 
new revision: 1.12; previous revision: 1.11 
done 
paste$ ls -l hello.c 
-r--r--r--   1 qsmith    users         210 Jul 19 01:12 hello.c 
paste$  
@end example

Al hacer esta edición y entrega se enviarán notificaciones a todos los 
vigilantes de hello.c. Observe que jranadom no es necesariamente uno de 
ellos. Al ejecutar @code{cvs watch} sobre hello.c jrandom no se añadió asimismo 
a la lista de vigilancia para ese fichero; simplemente especificó qe 
se deberían obtener copias  en modo de sólo lectura. Las personas que quieren
vigilar un fichero deben añadirse a la lista de vigilancia. CVS no puede
hacer nada sobre esto.

Establecer alarmas en un simple fichero sería la excepción. Generalmente 
es más común establecer las alarmas sobre un proyecto:


@example
floss$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
floss$ cd myproj 
floss$ cvs watch on 
floss$  
@end example

Esta acción equivale a anunciar una potitica de decisión para todo el 
proyecto: @emph{"Por favor, use cvs edit para advertir a los vigilantes en 
que está trabajando y vigile cuantos ficheros le interesen o sean de su 
responsabilidad."} Cada fichero del proyecto será actualizado en modo
de sólo lectura, y así a la gente se le recordará que se espera que 
usen @code{cvs edit} antes de trabajar en algo.

Curiosamente, aunque obtenciones de copias de ficheros vigilados se hacen 
en modo de sólo lectura, las actualizaciones no lo son. Si qsmith ha 
obtenido una copia de trabajo antes de que jrandom hiciera @code{cvs watch} 
sus ficheros serían le lectura-escritura quedando así incluso después de
hacer actualizaciones. Sin embargo, cualquier fichero que entregue 
después de que jrandom estableciera las alarmas será de sólo lectura. 
Si jrandom quita las alarmas:

@example
floss$ cvs watch off 
@end example

los ficheros de sólo lectura de qsmith no se convierte mágicamente en 
ficheros de lectura-escritura. Por otro lado, después de hacer una entrega 
volverán a modo lectura-escritura de nuevo (como si las alarmas todavía 
estuviaran puestas).

Observe que qsmith podría, si fuese malicioso, hacer los ficheros de 
su copia de trabajo escribibles usando la orden estándar de Unix 
@code{chmod} saltándose @w{@code{cvs edit}} por completo.

@example
paste$ chmod u+w hello.c 
@end example

o si quisiera hacerlo todo en una pasada.

@example
paste$ chmod -R u+w . 
@end example

No hay nada que CVS pueda hacer sobre esto. Las copias de trabajo son 
por su propia naturaleza privadas. Las alarmas pueden permitir su 
escrutinio al público tanto como lo permita el desarrollador. 
Sólamente cuando un desarrollador hace algo que afecte al 
repositorio (como una entrega) su privacidad se pierde incondicinalmente.

La relación entre @code{watch add}, @code{watch remove}, @code{watch on} 
y @code{watch off} 
podría parecer confusa. Para aclarar esto resumamos  el esquema general:
@code{add} y @code{remove} sirven para añadir o quitar usuarios de la 
lista de vigilancia de un fichero; no tiene nada que ver con que 
los ficheros sean de sólo lectura al obtener la copia de trabajo o 
después de la entrega. @code{on} y @code{off} sirven para los permisos 
de los ficheros. No tienen nada que ver con la lista de vigilancia; 
más bien son herramientas par ayudar a los desarrolladores a recordar 
la política de alarmas haciendo que los ficheros de la copia de trabajo 
sean de sólo lectura.

Todo esto parece un poco inconsistente. De algún modo el usar alarmas 
parece ir en contra de la esencia de CVS. Se desvía del universo 
ideal de múltiples desarrrolladores editando libremente en sus copias 
de trabajo, ocultos unos de otros hasta que hacen una entrega. Con las 
alarmas CVS da a los desarrolladores atajos para informarse mutuamente 
lo que pasa en sus copias de trabajo. Sin embargo no tiene forma de 
imponer las políticas de observación ni un concepto de que constituye 
una sesión de edición. Aun así las alarmas pueden ser útiles en ciertas 
ocasiones.
  

@c -------------------------------------------------------
@node Cómo aparecen las alarmas en el repositorio 
@subsection Cómo aparecen las alarmas en el repositorio

Para acabar con las cajas negras y los misterios sin solución vamos 
a hacer una rápida mirada a cómo las alarmas son implementadas en 
el repositorio. Será rápido ya que no es agradable.

Cuando usted establece una alarma

@example
floss$ pwd 
/home/jrandom/myproj 
floss$ cvs watch add hello.c 
floss$ cvs watchers 
hello.c jrandom edit    unedit  commit 
floss$ 
@end example

CVS la guarda en un fichero especial, @file{CVS/fileattr}, del 
subdirectorio apropiado del repositorio.

@example
floss$ cd /usr/local/newrepos 
floss$ ls 
CVSROOT/   myproj/ 
floss$ cd myproj 
floss$ ls 
CVS/          a-subdir/     foo.gif,v 
README.txt,v  b-subdir/     hello.c,v 
floss$ cd CVS 
floss$ ls 
fileattr 
floss$ cat fileattr 
Fhello.c        _watchers=jrandom>edit+unedit+commit 
floss$  
@end example


El hecho de que fileattr sea almacenado en un subdirectorio llamado CVS 
del repositorio no significa que el repositorio se haya convertido en 
una copia de trabajo. Simplemente el nombre @code{CVS} estaba ya 
reservado en la copia de trabajo para guardar información con lo 
que no habrá ningún proyecto que necesite un subdirectorio con ese nombre 
en el repositorio.

No describiré el formato de @file{fileattr} formalmente; se puede ver 
bastante bien estudiando los cambios que ocurren en él entre orden y orden.

@example
floss$ cvs watch add hello.c 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watchers=jrandom>edit+unedit+commit 
floss$ cvs watch add README.txt 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watchers=jrandom>edit+unedit+commit 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
floss$ cvs watch on hello.c 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watchers=jrandom>edit+unedit+commit;_watched= 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
floss$ cvs watch remove hello.c 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watched= 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
floss$ cvs watch off hello.c 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
floss$  
@end example

Registros de edición son almacenados en fileatrr también. 
Esto es lo que pasa cuando qsmith se añade asimismo como un editor.

@example
paste$ cvs edit hello.c 

floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watched=;_editors=qsmith>Tue Jul 20 04:53:23 1999 GMT+floss\
+/home/qsmith/myproj;_watchers=qsmith>tedit+tunedit+tcommit 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
@end example

Finalmente, observe que CVS quita le fichero fileattr y subdirectorio  
CVS cuando no hay más vigilantes o editores para cualquier fichero en ese
directorio:


@example
paste$ cvs unedit 

floss$ cvs watch off 
floss$ cvs watch remove 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
cat: /usr/local/newrepos/myproj/CVS/fileattr: No such file or directory 
floss$  
@end example

Debe quedar claro depués de esta breve exposición que los detalles del 
tratamiento del formato de fileattr se dejan a CVS. La principal razón 
para tener una comprensión básica del formato, además de la satisfacción 
inherente de saber que es lo que ocurre detrás de las cortinas, es 
si usted va a escribir una extensión a las alarmas de CVS, o está 
depurando algún error en ellas. Es suficiente con que no se alarme si ve 
CVS/ subdirectorios apareciendo y desapareciendo de su repositorio. 
Son los únicos lugares seguros que CVS tiene para almacenar 
meta-información como las listas de vigilancia.

@c --------------------------------------------------------
@node Mensajes log y correos electrónicos a la entrega 
@section Mensajes log y correos electrónicos a la entrega

Los correos electrónicos a la entrega son enviados cuando se hace una 
entrega y muestran el mensaje log y los ficheros involucrados en ésta.
Normalmente van para todos los partipantes en el proyecto y algunas veces 
para otras partes interesadas. Los detalles para establecer correos 
a la entrega son cubiertos en @ref{Administracion del Repositorio}, por 
lo que no los repetiremos aquí. He observado, sin embargo, algunos 
efectos inesperados en los proyectos. Efectos que usted debería tener 
en cuenta si estable correos electrónicos a la entrega.

Prepárese para que la mayoría de los mensajes sean ignorados. Que se 
lean o no dependerá, al menos en parte, en la frecuencia con que se hagan 
entregas en su proyecto. ¿Entregan los desarrolladores un cambio grande al 
final de día, o hacen pequeños cambios durante la jornada? En el último 
caso los desarrolladores recibirán más mensajes y es problabe que presten 
menos atención a ellos.

Esto no significa que los mensajes no son útiles, sino que no debe contar 
con que cada persona va a leer cada mensaje. Es un modo conveniente de 
para las personas de mantener información de quién está haciendo qué
(sin la intrusión de las alarmas). Cuando los correos van a una lista 
de correos pública subscribible son un mecanismo maravilloso para dar 
a usuarios interesados (y futuros desarrolladores) una oportunidad para 
ver lo que ocurre en el código a nivel básico.

Podría tener un desarrollador designado para vigilar todos los mensajes 
log y tener un visión general de la actividad en todo el proyecto
(por supuesto, un buen jefe de proyectos estará probablemente haciendo esto).
Si hay una clara división de responsabilidades, es decir, ciertos 
desarrolladores están a cargo de algún subdirectorio del proyecto, usted 
podría usar algún lenguaje interpretado sobre CVSROOT/loginfo para que 
cada responsable reciba notificaciones especiales de cambios hechos en 
su área. Esto aseguraría que los desarrolladores leen al menos los 
correos involucrados en sus subdirectorios.

Un interesante efecto que surge cuando los correos no son ignorados.
La gente empieza a usarlos como un método de comunicación en tiempo real.
Ésta es la clase de mensaje log que podría resultar:

@example
Acabada la forma de retroalimentación; arreglados los colores de las 
fuentes y el fondo. Bien, ¿alguien quiere almorzar en 'Los claveles'?
@end example
  
No hay nada malo en esto y hace los mensajes log más entretenidos cuando 
se repasan más tarde. Sin embargo hay que ser consciente de que los mensajes 
log se guardan para siempre en el historial del proyecto. Por ejemplo, 
quejarse de las especificaciones de un cliente es un pasatiempo entre 
los programadores; no es dificil imaginar a alguien entregando un mensaje 
log como éste, sabiendo que otros programadores lo verán en su correo:

@example
Cambiar los cuatro digitos del año por dos en la salida. Lo que el 
cliente pide, el cliente recibe, no importa lo estúpido y malo que sea.
@end example

Esto hace los correos más divertidos pero, ¿qué ocurriría si el cliente 
revisara los mensajes log? (Apostaría a que debido a esto más de un 
sitio ha configurado su CVSROOT/loginfo para que invoque scripts que 
matengan libre de palabras ofensivas los mensajes log.)

El efecto global de los correos a la entraga sería que la gente 
no escribe mensajes log demasiandos cortos o complicados, lo cual está 
bien. Sin embargo hay que recordar que su audiencia no son sólo la gente 
que recibe los correos sino cualquiera que pudiera leer estos mensajes log.

@c -------------------------------------------------------------------
@node Cambiar un mensaje log después de una entrega
@section Cambiar un mensaje log después de una entrega

Por si alguien escribe un mensaje log deplorable, CVS permite que éste se 
puede reescribier después de que se haya entregado. Se hace con el indicador 
-m de la orden admit (esta orden se verá en más detalle más adelante) y 
permite cambiar un mensaje log (por revisión, por fichero) cada vez. 
Así es como funciona:

@example
floss$ cvs admin -m 1.7:"Cambiar cuatro dígitos del año por dos en la 
salida." date.c
RCS file: /usr/local/newrepos/someproj/date.c,v 
done 
floss$  
@end example

El mensaje ofensivo original que fue entregado en la revisión 1.7 ha sido
reemplazado por uno más inocente (aunque también más soso).
No olvide los dos puntos separando el número de revisión del nuevo 
mensaje log.

Si el mensaje original fue entregado en múltiples fichros, tendrá que 
ejecurar @code{cvs admit} para cada uno de ellos, porque el número de revisión 
será distinto en cada fichero. Así, esta es una de las pocas órdenes 
en las que CVS requiere que se pase como argumento el nombre de un fichero:

@example
floss$ cvs admin -m 1.2:"mensaje log muy aburrido" hello.c REAME.txt foo.gif 
cvs admin: while processing more than one file: 
cvs [admin aborted]: attempt to specify a numeric revision 
floss$  
@end example

Obtendría el mismo error si no le pasa ningún nombre de fichero. Parace 
confuso pero la razón es que CVS asumiría como argumentos implícitos todos 
los ficheros de directorio actual.

@example
floss$ cvs admin -m 1.2:"mensaje log muy aburrido" 
cvs admin: while processing more than one file: 
cvs [admin aborted]: attempt to specify a numeric revision 
floss$  
@end example

Desgraciadamente esto lo encontramos a menudo en los mensajes de error. 
Usted debe ver las cosas desde el punto de vista de CVS para 
que los mensajes tengan sentido.

Invocar @w{@code{admin -m}} cambia el historial del proyecto por lo que 
debe usarlo con cuidado. No habrá forma de saber que un mensaje log fue 
cambiado alguna vez. Parecerá como si esa revisión fue entregada con el 
nuevo mensaje. No quedará huella del mensaje antiguo en ningún sitio 
(a no ser que salve el correo que se entregó la primera vez).

Aunque por su nombre pueda parecer que sólo administradores designados 
de CVS pueden usarlo cualquiera puede ejecutar @w{@code{cvs admin}}
si tiene acceso de escritura en el proyecto.
Sin embargo, es mejor usarlo con cuidado; la habilidad de cambiar el 
historial de un proyecto es poca comparado con el daño potencial que 
se puede hacer. Vea @ref{Referencia de CVS} para saber más sobre @code{admin} 
y también como restringir su uso.

@c -------------------------------------------------------------
@node Deshacerse de una copia de trabajo
@section Deshacerse de una copia de trabajo

En un uso típico de CVS, el modo de deshacerse del directorio que contiene 
una copia de trabajo es quitarlo como se haría con cualquier árbol de 
directorios:

@example
paste$ rm -rf myproj 
@end example

Sin embargo al hacerlo de esta manera otros desarrolladores no sabrán que 
ha dejado de trabajar en él. CVS proporciona una orden para dejar una 
copia de trabajor explícitamente. Piense de un lanzamiento como lo 
contrario de una entrega; usted le dice al repositorio que ya ha hecho su 
trabajo con la copia de trabajo. Como la entrega, el lanzamiento es 
invocado desde el directorio padre del arbol.


@example
paste$ pwd 
/home/qsmith/myproj 
paste$ cd .. 
paste$ ls 
myproj 
paste$ cvs release myproj 
You have [0] altered files in this repository. 
Are you sure you want to release directory 'myproj': y 
paste$  
@end example

(Usted tiene [0] ficheros alterados en este repositorio,
Está seguro de que quiere lanzarlos (y borrar) el directorio 'myproj': si

Por ahora la versión 1.10.6 no permite que la orden @code{release} deduzca 
la localización del repositorio examinando la copia de trabajo ya que 
@code{release} es invocado fuera de la copia de trabajo no dentro de ella.
Usted debe pasar la opición global  @w{@code{-d <REPOS>}} o asegurarse que 
la variable de entorno CVSROOT está correcta. (Esto se podría arreglar en 
futuras versiones.)

Cederqvist afirma que si se usa @code{release} en vez de borrar el 
directorio de trabajo, la gente que vigila los ficheros liberados será 
notificada como si hubieran ejecutado @code{unedit}. Lo he probado  
experimentalmente y parece que no es verdad.

@c ----------------------------------------------------
@node Historial -- Un resumen de la actividad del repositorio
@section Historial -- Un resumen de la actividad del repositorio

En @ref{Administracion del Repositorio} comenté brebemente la orden @code{history}.
Ésta orden muestra un resumen de todos las obtenciones @emph{checkouts}, 
entregas @emph{commits}, actualizaciones @emph{updates}, etiquetas 
@emph{rtags}, y entregas finales @emph{releases} hechos en el repositorio 
(al menos, desde que @code{logging} fue activado mediante la creación del 
fichero CVSROOT/history en el repositorio). Puede controlar el formato y
contenidos del resumen con varias optciones.

El primer paso es asegurarse que @code{logging} esta activo en su repositorio.
El administrador del repositorio debe asegurarse de que existe un fichero 
history

@example
floss$ cd /usr/local/newrepos/CVSROOT 
floss$ ls -l history 
ls: history: No such file or directory 
floss$  
@end example

y si no exite crearlo de la siguiente forma:

@example
floss$ touch history 
floss$ ls -l history 
-rw-r--r--   1 jrandom   cvs           0 Jul 22 14:57 history 
floss$  
@end example

Este para el historial, @code{history} debe ser escribible por cualquiera que 
use el repositorio ya que de otra forma se obtendrá un error cada vez que 
ejecute alguna orden de CVS que modifique ese fichero. La foram más simple 
es hacer el fichero escribible por todo el mundo:

@example
floss$ chmod a+rw history 
floss$ ls -l history 
-rw-rw-rw-   1 jrandom   cvs           0 Jul 22 14:57 history 
floss$  
@end example

Si el repositorio fue creado con la orden @w{@code{cvs init}}, el fichero 
@code{history} ya existirá. Tal vez que tuviese que arreglar los permisos 
de escritura.

Se asume en el resto de los ejemplos que @code{history logging} se ha activado 
durante un tiempo y por lo tanto ha habido tiempo para alguna información 
se haya acumulado en el historial (fichero @code{history}).

La salida de @code{cvs history} es en cierta forma dificil (probablemente se 
creó pensando en que se tratataría mediante otros programas y no mediante 
personas, aunque con un poco de estudio se puede leer). Ejecutémoslo y 
veamos lo que obtenemos.

@example
paste$ pwd 
/home/qsmith/myproj 
paste$ cvs history -e -a 
O 07/25 15:14 +0000 qsmith  myproj =mp=     ~/* 
M 07/25 15:16 +0000 qsmith  1.14 hello.c    myproj == ~/mp 
U 07/25 15:21 +0000 qsmith  1.14 README.txt myproj == ~/mp 
G 07/25 15:21 +0000 qsmith  1.15 hello.c    myproj == ~/mp 
A 07/25 15:22 +0000 qsmith  1.1  goodbye.c  myproj == ~/mp 
M 07/25 15:23 +0000 qsmith  1.16 hello.c    myproj == ~/mp 
M 07/25 15:26 +0000 qsmith  1.17 hello.c    myproj == ~/mp 
U 07/25 15:29 +0000 qsmith  1.2  goodbye.c  myproj == ~/mp 
G 07/25 15:29 +0000 qsmith  1.18 hello.c    myproj == ~/mp 
M 07/25 15:30 +0000 qsmith  1.19 hello.c    myproj == ~/mp 
O 07/23 03:45 +0000 jrandom myproj =myproj= ~/src/* 
F 07/23 03:48 +0000 jrandom        =myproj= ~/src/* 
F 07/23 04:06 +0000 jrandom        =myproj= ~/src/* 
M 07/25 15:12 +0000 jrandom 1.13 README.txt myproj == ~/src/myproj 
U 07/25 15:17 +0000 jrandom 1.14 hello.c    myproj == ~/src/myproj 
M 07/25 15:18 +0000 jrandom 1.14 README.txt myproj == ~/src/myproj 
M 07/25 15:18 +0000 jrandom 1.15 hello.c    myproj == ~/src/myproj 
U 07/25 15:23 +0000 jrandom 1.1  goodbye.c  myproj == ~/src/myproj 
U 07/25 15:23 +0000 jrandom 1.16 hello.c    myproj == ~/src/myproj 
U 07/25 15:26 +0000 jrandom 1.1  goodbye.c  myproj == ~/src/myproj 
G 07/25 15:26 +0000 jrandom 1.17 hello.c    myproj == ~/src/myproj 
M 07/25 15:27 +0000 jrandom 1.18 hello.c    myproj == ~/src/myproj 
C 07/25 15:30 +0000 jrandom 1.19 hello.c    myproj == ~/src/myproj 
M 07/25 15:31 +0000 jrandom 1.20 hello.c    myproj == ~/src/myproj 
M 07/25 16:29 +0000 jrandom 1.3  whatever.c myproj/a-subdir == ~/src/myproj 
paste$  
@end example

¿No está claro?

Antes de examinar la salida, observe que la orden incluye dos opciones:
-e y -a. Cuando usted ejecuta @code{histoy}, casi siempre le pasará opciones 
para indicar que datos y en que formato los verá. En esto difiere de la 
mayoria de las órdenes de CVS, que normalmente hacen cosas útiles sin 
necesidad de opciones. En este ejemplo, los dos indicadores significan 
respectivamente "todas las cosas" (del inglés @emph{everything}), que muestra 
todas las claves de eventos que han ocurrido, y "todo" (del inglés 
@emph{all}), por todos los usuarios.

Otro modo en que @code{history} se diferencia de otros comandos es que, aunque 
normalmente se invoca dentro de una copia de trabajo, no sólo está 
restringida su salida a esa copia del projecto sino que también muestra 
todo el historial de eventos de todos los proyectos del repositorio. La 
copia de trabajo sólo indica a CVS desde que repositorio conseguir los datos 
del historial. (En el ejemplo anterior, los únicos datos de historial de 
ese repositorio son los del proyecto @code{myproj}, por lo tanto eso es lo 
que vemos.)

El formato general de salida es:
 
@example
CÓDIGO FECHA_Y_HORA USUARIO [REVISION] [FICHERO] DIRECTORIO_DEL_REPOSITORIO
NOMBRE_DEL_DIRECTORIO_DE_TRABAJO
@end example

@c todo: weird table ref here
Aunque la salida de esta orden fue diseñado para ser compacto y usado como 
entrado por otros programas, CVS le da bastante control sobre su contenido.
Las opciones mostradas en la Tabla 6.2 controlan sobre que tipos de eventos
se informa.


@example
Tabla 6.1  Significado del código de las letras.

Letra	        Significado
======          =========================================================
O		Obtener
T		Tag
F		Entrega final
W		Actualizar (no de un fichero de usuario, eliminación en las 
                entradas del fichero)
U		Actualizar (fichero sobrescribe un fichero de usuario 
                no modificado)
G		Actualizar (fichero fusionado exitosamente con un fichero 
                modificado de usuario)
C		Actualizar (fichero fusionado, pero existen conflictos con 
                fichero de usuario)
M		Entregar (de un fichero modificado)
A		Entregar (un fichero añadido)  
R		Entregar (el borrado de un fichero)
E		Exportar
@end example

@example
Tabla 6.2  Opciones de filtrado sobre tipo de evento.
 
Opción	        Significado
==========      =========================================================
-m MODULO	Muestra eventos del historial que afecten a MODULO
-c		Muestra las entregas.
-o		Muestra las obtenciones. 
-T		Muestra los tag.
-x CODE(S)	Muestra los eventos de tipo CODE (uno o más de OTFWUGCMARE).
-e		Muestra todos los eventos. Una ver seleccionados los tipos 
                de eventos se puede filtrar más con las opciones de la
                Tabla 6.3.
@end example

@example
Tabla 6.3  Opciones a filtrar por el usuario.

Opción	        Significado
==========      =========================================================
-a		Muestra las acciones hechas por todos los usuarios  
-w              Muestra sólo las acciones hechas dentro de la copia de 
                trabajo. 
-l		Muestra sólo la última vez que este usuario realizó la
                acción
-u USUARIO      Muestra los registros para USUARIO 
@end example

@c ------------------------------------------------------------------
@node Anotaciones -- Sumario detallado de la actividad del proyecto
@section Anotaciones -- Sumario detallado de la de la actividad del proyecto

@heading La orden @code{annotaded}

Mientras que la orden @code{history} da una visión general sobre la 
actividad del proyecto, @dfn{annotate} es un modo de acercarse con más 
detalle a esa visión. Con @code{annotate} usted puede ver quién fue la 
última perosna que tocó cada línea de un fichro, y en que revisión se hizó.


@example
floss$ cvs annotate
Annotations for README.txt 
*************** 
1.14         (jrandom  25-Jul-99): blah 
1.13         (jrandom  25-Jul-99): test 3 for history 
1.12         (qsmith   19-Jul-99): test 2 
1.11         (qsmith   19-Jul-99): test 
1.10         (jrandom  12-Jul-99): blah 
1.1          (jrandom  20-Jun-99): Just a test project. 
1.4          (jrandom  21-Jun-99): yeah. 
1.5          (jrandom  21-Jun-99): nope. 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.15         (jrandom  25-Jul-99):   /* another test for history */ 
1.13         (qsmith   19-Jul-99):   /* random change number two */ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.21         (jrandom  25-Jul-99):   printf ("Hellooo, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.11         (qsmith   18-Jul-99):   /* added this comment */ 
1.16         (qsmith   25-Jul-99):   /* will merge these changes */ 
1.18         (jrandom  25-Jul-99):   /* will merge these changes too */ 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
Annotations for a-subdir/whatever.c 
*************** 
1.3          (jrandom  25-Jul-99): /* A completely non-empty C file. */
Annotations for a-subdir/subsubdir/fish.c 
*************** 
1.2          (jrandom  25-Jul-99): /* An almost completely empty C file. */ 
Annotations for b-subdir/random.c 
*************** 
1.1          (jrandom  20-Jun-99): /* A completely empty C file. */ 
floss$  
@end example

La salida de @code{annotate} es bastante intuitiva. A la izquiera está el
número de revisión, desarrollador, y la fecha en que esa línea fué 
añadida o modificada. A la derecha está la línea en questión en su 
actual versión. Como cada línea es comentado se puede ver el contenido 
entero del fichero a la derecha de la información anotada.

Si especifica un número de revisión, las anotaciones son dadas para esa
revisión lo cual quiere decir que se muestran la más reciente 
modificacione para cada línea a esa o una anterior revisión. Este es 
probablemente el modo más comunmente usado. Se examina una revision 
particular de un fichero para determinar que desarrolladores estaban 
activos en cada parte de un fichero.

En el ejemplo anterior se puede ver que la más reciente revisión de hello.c
es la 1.21, en la que jrandom hizo algo en la línea:

@example
printf ("Hellooo, world!\n"); 
@end example

Un modo de ver lo que ella hizo es usar @code{diff} de esa revisión con la 
anterior:

@example
floss$ cvs diff -r 1.20 -r 1.21 hello.c 
Index: hello.c 
=================================================================== 
RCS file: /usr/local/newrepos/myproj/hello.c,v 
retrieving revision 1.20 
retrieving revision 1.21 
diff -r1.20 -r1.21 
9c9 
<   printf ("Hello, world!\n"); 
-- 
>   printf ("Hellooo, world!\n"); 
floss$  
@end example

Otro modo de verlo manteniendo la amplia visión de la actividad de cada
uno es comparando las actuales anotaciones con las anotaciones de 
una revisión anterior:

@example
floss$ cvs annotate -r 1.20 hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.15         (jrandom  25-Jul-99):   /* another test for history */ 
1.13         (qsmith   19-Jul-99):   /* random change number two */ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.11         (qsmith   18-Jul-99):   /* added this comment */ 
1.16         (qsmith   25-Jul-99):   /* will merge these changes */ 
1.18         (jrandom  25-Jul-99):   /* will merge these changes too */ 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

Aunque el @code{diff} muestra los cambios sobre el texto de forma más concisa, 
la anotación puede ser preferible ya que coloca estos cambios en su
contexto histórico al mostrar desde cuando ha estado presente esa línea
(en este caso desde la revisión 1.1). Ese conocimiento puede ayudarle 
a decidir si mirar en los mensajes log para averiguar los motivos del 
cambio:


@example
floss$ cvs log -r 1.21 hello.c 
RCS file: /usr/local/newrepos/myproj/hello.c,v 
Working file: hello.c 
head: 1.21 
branch: 
locks: strict 
access list: 
symbolic names: 
       random-tag: 1.20 
       start: 1.1.1.1 
       jrandom: 1.1.1 
keyword substitution: kv 
total revisions: 22;    selected revisions: 1 
description: 
---------------------------- 
revision 1.21 
date: 1999/07/25 20:17:42;  author: jrandom;  state: Exp;  lines: +1 -1 
say hello with renewed enthusiasm 
============================================================================
floss$  
@end example

Además de la opción -r, se puede filtrar las anotaciones con la opción 
-D DATE:


@example
floss$ cvs annotate -D "5 weeks ago" hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$ cvs annotate -D "3 weeks ago" hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

@c -----------------------------------------------------------
@node Anotaciones y ramificaciones
@section Anotaciones y ramificaciones

Por defecto, las anotaciones muestran siempren la actividad de la rama 
principal de desarrollo. Incluso aunque se llame desde una copia de trabajo 
derivada se muestra las anotaciones de la rama principal a menos que se 
especifique lo contrario. (Dependiendo de su punto de vista esta tendencia 
de favorecer el tronco principal se puedría considerar un error o una 
característica.) Puede anotar una ramificación o derivación pasando el 
nombre de ésta como argumento de -r. He aquí un ejemplo de una copia de 
trabajo cuyo fichero hello.c está en una derivación llamada 
@code{Brancho_Gratuito}, con al menos un cambio entregado en esa rama:

@example
floss$ cvs status hello.c 
=================================================================== 
File: hello.c           Status: Up-to-date 

  Working revision:    1.10.2.2        Sun Jul 25 21:29:05 1999 
  Repository revision: 1.10.2.2        /usr/local/newrepos/myproj/hello.c,v
  Sticky Tag:          Brancho_Gratuito (branch: 1.10.2) 
  Sticky Date:         (none) 
  Sticky Options:      (none) 

floss$ cvs annotate hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$ cvs annotate -r Brancho_Gratuito hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.10.2.2     (jrandom  25-Jul-99):   printf ("hmmmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.10.2.1     (jrandom  25-Jul-99):   printf ("added this line"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

También puede pasar el número de la ramificación:

@example
floss$ cvs annotate -r 1.10.2 hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.10.2.2     (jrandom  25-Jul-99):   printf ("hmmmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.10.2.1     (jrandom  25-Jul-99):   printf ("added this line"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

o el número de revisión completo de la ramificación:

@example
floss$ cvs annotate -r 1.10.2.1 hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.10.2.1     (jrandom  25-Jul-99):   printf ("added this line"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

Si hace esto, recuerde que los números son sólo válidos parar ese 
fichero particualr. En general es mejor usar el nombre de esa 
ramificación si ello es posible.

@c ---------------------------------------------------------
@node Usando expansión de palabras
@section Usando expansión de palabras

Podría recordar una breve mención de @code{keyword expansion} en 
@ref{Una introduccion a CVS}. Estas palabras especiales de RCS están 
rodeadas por el signo del dolar, que CVS busca en el texto del fichero 
y las sustituye por información de revisión. Por ejemplo si un fichero 
contiene 

@example
$Author: jfs $ 
@end example

entonces cuando se actualize ese fichero a cualquier revisión, CVS 
lo sustituirá por el nombre de usuario de la persona que realizó la 
entrega de esa revisión:

@example
$Author: jfs $ 
@end example

CVS es también consciente de las palabras que han sido sustituidas por lo 
que estas se pueden actualizar cuando sea apropiado.

Aunque estas palabras no ofrecen información que no puediera ser obtenida 
mediante otros medios, dan a las personas una forma cómoda de ver los 
hechos de revisión incluidos en el texto mismo, en vez de tener que 
invocar alguna orden rara de CVS.

He aquí otros ejemplos de sustitución de palabras:

@example
$Date: 2002/12/05 19:10:27 $       ==>  date of last commit, expands to ==> 
$Date: 2002/12/05 19:10:27 $ 

$Id: chapter-6.texi,v 1.4 2002/12/05 19:10:27 jfs Exp $         ==>  filename, revision, date, and author; expands to ==> 
$Id: chapter-6.texi,v 1.4 2002/12/05 19:10:27 jfs Exp $ 

$Revision: 1.4 $   ==>  exactly what you think it is, expands to ==> 
$Revision: 1.4 $ 

$Source: /home/cvs/lucas/doc-cvsbook-es/chapter-6.texi,v $     ==> path to corresponding repository file, expands to ==> 
$Source: /home/cvs/lucas/doc-cvsbook-es/chapter-6.texi,v $ 

$Log: chapter-6.texi,v $
Revision 1.4  2002/12/05 19:10:27  jfs
Ahora el documento compila incluyendo los acentos en castellano, he seguido
los consejos de
http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
Sin embargo sería conveniente revisar por qué los nombres de nodo que se
referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?

Revision 1.3  2002/12/03 13:04:59  carlosgarcia
Traduccion de main, introduction e index

Revision 1.2  2002/11/27 16:26:56  carlosgarcia
Realizados arreglos para compilación

Revision 1.1  2000/09/16 12:07:53  jjamor
Traduccion del capitulo 6 insertada en la B.de trabajo
        ==>  accumulating log messages for the file, expands to ==> 
$Log: chapter-6.texi,v $
Revision 1.4  2002/12/05 19:10:27  jfs
Ahora el documento compila incluyendo los acentos en castellano, he seguido
los consejos de
http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
Sin embargo sería conveniente revisar por qué los nombres de nodo que se
referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?

Revision 1.3  2002/12/03 13:04:59  carlosgarcia
Traduccion de main, introduction e index

Revision 1.2  2002/11/27 16:26:56  carlosgarcia
Realizados arreglos para compilación

Revision 1.1  2000/09/16 12:07:53  jjamor
Traduccion del capitulo 6 insertada en la B.de trabajo
 
Revision 1.2  1999/07/26 06:47:52  jrandom 
...and this is the second log message. 

Revision 1.1  1999/07/26 06:39:46  jrandom 
This is the first log message... 
@end example

La palabra $Log: chapter-6.texi,v $
La palabra Revision 1.4  2002/12/05 19:10:27  jfs
La palabra Ahora el documento compila incluyendo los acentos en castellano, he seguido
La palabra los consejos de
La palabra http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
La palabra Sin embargo sería conveniente revisar por qué los nombres de nodo que se
La palabra referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
La palabra
La palabra Revision 1.3  2002/12/03 13:04:59  carlosgarcia
La palabra Traduccion de main, introduction e index
La palabra
La palabra Revision 1.2  2002/11/27 16:26:56  carlosgarcia
La palabra Realizados arreglos para compilación
La palabra
La palabra Revision 1.1  2000/09/16 12:07:53  jjamor
La palabra Traduccion del capitulo 6 insertada en la B.de trabajo
La palabra es la única que se exande varias lineas. A diferencia 
de las otras no reemplaza la antigua sustitución con una nueva, sino que 
inserta la última sustitución más una línea en blanco justo después de 
la palabra especial (las previas sustituciones quedan más abajo). 
Además cualquier texto entre el principio de línea y el $Log es usada 
como un prefijo para las sustituciones (esto se hace para asegurar que 
los mensajes log quedan comentados en el código del programa). 
Por ejemplo, si usted pone esto dentro de un fichero 


@example
// $Log: chapter-6.texi,v $
// Revision 1.4  2002/12/05 19:10:27  jfs
// Ahora el documento compila incluyendo los acentos en castellano, he seguido
// los consejos de
// http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
// Sin embargo sería conveniente revisar por qué los nombres de nodo que se
// referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
//
// Revision 1.3  2002/12/03 13:04:59  carlosgarcia
// Traduccion de main, introduction e index
//
// Revision 1.2  2002/11/27 16:26:56  carlosgarcia
// Realizados arreglos para compilación
//
// Revision 1.1  2000/09/16 12:07:53  jjamor
// Traduccion del capitulo 6 insertada en la B.de trabajo
// 
@end example

se sustituirá por esto en la primera entrega:

@example
// $Log: chapter-6.texi,v $
// Revision 1.4  2002/12/05 19:10:27  jfs
// Ahora el documento compila incluyendo los acentos en castellano, he seguido
// los consejos de
// http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
// Sin embargo sería conveniente revisar por qué los nombres de nodo que se
// referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
//
// Revision 1.3  2002/12/03 13:04:59  carlosgarcia
// Traduccion de main, introduction e index
//
// Revision 1.2  2002/11/27 16:26:56  carlosgarcia
// Realizados arreglos para compilación
//
// Revision 1.1  2000/09/16 12:07:53  jjamor
// Traduccion del capitulo 6 insertada en la B.de trabajo
// 
// Revision 1.14  1999/07/26 07:03:20  jrandom 
// this is the first log message... 
// 
@end example

a esto en la segunda:

@example
// $Log: chapter-6.texi,v $
// Revision 1.4  2002/12/05 19:10:27  jfs
// Ahora el documento compila incluyendo los acentos en castellano, he seguido
// los consejos de
// http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
// Sin embargo sería conveniente revisar por qué los nombres de nodo que se
// referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
//
// Revision 1.3  2002/12/03 13:04:59  carlosgarcia
// Traduccion de main, introduction e index
//
// Revision 1.2  2002/11/27 16:26:56  carlosgarcia
// Realizados arreglos para compilación
//
// Revision 1.1  2000/09/16 12:07:53  jjamor
// Traduccion del capitulo 6 insertada en la B.de trabajo
// 
// Revision 1.15  1999/07/26 07:04:40  jrandom 
// ...and this is the second log message... 
// 
// Revision 1.14  1999/07/26 07:03:20  jrandom 
// this is the first log message... 
// 
@end example

y así sucesivamente:

@example
// $Log: chapter-6.texi,v $
// Revision 1.4  2002/12/05 19:10:27  jfs
// Ahora el documento compila incluyendo los acentos en castellano, he seguido
// los consejos de
// http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
// Sin embargo sería conveniente revisar por qué los nombres de nodo que se
// referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
//
// Revision 1.3  2002/12/03 13:04:59  carlosgarcia
// Traduccion de main, introduction e index
//
// Revision 1.2  2002/11/27 16:26:56  carlosgarcia
// Realizados arreglos para compilación
//
// Revision 1.1  2000/09/16 12:07:53  jjamor
// Traduccion del capitulo 6 insertada en la B.de trabajo
// 
// Revision 1.16  1999/07/26 07:05:34  jrandom 
// ...and this is the third!
// 
// Revision 1.15  1999/07/26 07:04:40  jrandom 
// ...and this is the second log message... 
// 
// Revision 1.14  1999/07/26 07:03:20  jrandom 
// this is the first log message... 
// 
@end example

Podría no querer mantener el historial completo en el fichero todo el 
tiempo; si es así siempre puede quitar las antiguas secciones cuando 
sea muy grande. Es más conveniente que tener que ejecutar @code{cvs log}, 
y podría ser útil en proyectos donde la gente debe leer constantemente 
los mensajes logs.

Una técnica más común puede ser incluir $Revision: 1.4 $ en un fichero y 
usarlo como número de versión para el programa. Esto puede funcionar si 
el proyecto consiste de un fichero o se llevan a cabo muchas entregas 
finales (releases) y al menos se garantize que uno de los ficheros se 
ha modificado entre cada entrega. Incluso se pueden usar estas palabras 
de expansión como un valor en el código de un programa:

@example
VERSION = "$Revision: 1.4 $"; 
@end example

CVS sustituye esa palabra como cualquier otra; no tiene en cuenta la 
semántica del lenguaje de programación ni asume que las dobles comillas 
protegen la cadena de algún modo.

Una lista completa de palabras de sustitución (hay algunas más poco usuales)
se encuentra en @ref{Referencia de CVS}

@c -------------------------------------------------------------------
@node Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)
@section Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)

Las derivaciones o ramificaciones son una de las más importantes y más 
fácilmente mal usadas características del CVS. Aislar los cambios 
arriesgados o perturbadores en una línea de desarrollo separada hasta 
que se haya estabilizado puede ser inmensamente beneficioso. Sin embargo, 
si no se usa apropiadamente puede llevar un proyecto a la confusión 
y al caos, cuando la gente no pierde la cuento sobre qué cambios se 
han fusionado y cuando se realizaron.

@menu
* Algunos principios para trabajar con derivaciones::
* Fusionar repetidamente con la rama principal::
* La Aproximación de la Cola de Milano -- Fusionar dentro y fuera de la rama principal::
* La Aproximación del Pez Volador -- Una forma más simple de hacerlo::
* Derivaciones y expansión de palabras -- Enemigos naturales::
@end menu

@c -------------------------------------------------------------------
@node Algunos principios para trabajar con derivaciones
@subsection Algunos principios para trabajar con derivaciones

Para trabajar exitosamente con derivaciones, su grupo de desarrollo 
debería seguir estos principios:

@itemize

@item
Minimizar el número de derivaciones activas cada vez. Cuantas más 
derivaciones se esten desarrrollando al mismo tiempo habrá más 
posibilidad de que existan conflictos cuando se fusionen con la rama 
principal. En términos prácticos, la forma de conseguir esto es 
fusionar tan frecuentemente como pueda (cada vez que una derivación 
está en un punto estable) y volver al desarrollo de la rama principal 
cuando esto sea viable. Minimizando la cantidad de desarrollo en 
paralelo es posible estar al tanto de lo que pasa en cada rama y 
la posibilidad de conflictos se reduce.

Esto no significa minimizar el número absoluto de derivaciones de un 
proyecto sino el número de ellos en las que se trabajo en un momentod 
dado.

@item
Minimizar la complejidad -- es decir la profundidad -- del esquema 
de sus derivaciones. Hay circunstancias en que es apropiado tener 
derivaciones de derivaciones pero son muy raras (usted podría no 
encontrar una situación como ésta durante toda su vida como programador).
El que CVS permita técnicamente que se puedan tener distintos niveles 
de derivaciones anidadas, y que se pueda fusionar unas con otras, no 
quiere decir que usted quiera hacerlo. En la mayoría de las situaciones 
lo mejor es tener las derivaciones sobre la rama principal y fusionar 
de la derivación al tronco y vuelta a empezar.

@item 
Use consistentemente etiquetas para marcar todas los eventos de fusión y 
ramificación. Idealmente el significado de cada etiqueta y su relación 
con otras ramificaciones y etiquetas debería quedar claro por su nombre. 
(Esto quedará más claro cuando veamos los ejemllos.)

@end itemize
Con estos principios en la cabeza veamos un típico escenario de 
desarrollo con una ramificación. Tendremos jrandom en la rama principal 
y qsmith en la derivación. Pero tenga en cuento que podría haber múltiples 
desarrolladores en ambos sitios. El desarrollo normal en cada línea 
puede involucrar cualquier número de personas; sin embargo el etiquetado 
y fusión es mejor hacerlos por una persano en cada lado como verá.

@c -----------------------------------------------------------------
@node Fusionar repetidamente con la rama principal
@subsection Fusionar repetidamente con la rama principal

Supongamos que qsmith necesita hacer desarrollo en una derivación para 
no desestabilizar la rama principal que comparte con jrandom. El primer 
paso es crear una rama nueva. Observe como primero qsmith crea una 
etiqueta normal (no-rama) en ese punto de la rama principal y después 
crea la derivación:

@example
paste$ pwd 
/home/qsmith/myproj 
paste$ cvs tag Root-of-Exotic_Greetings 
cvs tag: Tagging . 
T README.txt 
T foo.gif 
T hello.c 
cvs tag: Tagging a-subdir 
T a-subdir/whatever.c 
cvs tag: Tagging a-subdir/subsubdir 
T a-subdir/subsubdir/fish.c 
cvs tag: Tagging b-subdir 
T b-subdir/random.c 
paste$ cvs tag -b Exotic_Greetings-branch 
cvs tag: Tagging . 
T README.txt 
T foo.gif 
T hello.c 
cvs tag: Tagging a-subdir 
T a-subdir/whatever.c 
cvs tag: Tagging a-subdir/subsubdir 
T a-subdir/subsubdir/fish.c 
cvs tag: Tagging b-subdir 
T b-subdir/random.c 
paste$  
@end example

Etiquetar primero la rama principal podría servir para obtener algún 
día la rama principal en el momento de que la derivación fue creada.
Si tuviese que hacer eso debería haber un modo de referirse a esa 
instantánea de la rama principal sin referirse a la derivación. No 
puede usar la etiqueta de la derivación ya que lo que obtendría es 
esa derivación no las revisiones que forman la raiz del tronco. El 
único modo de hacer esto sería hacer una etiqueta de las revisiones 
de las que sale la derivación. (Alguna gente que esta regla tan 
fielmente que consideré listarla como "principio número 4 de 
ramificación: Crear siempre una etiqueta no-derivación en la posición 
de la derivación." Sin embargo en algunos sitios no se usa y parece 
que lo hacen bien por lo que es una cuestión de gusto.)
De ahora en adelante me referiré a esta etiqueta no-derivación como 
@dfn{etiqueta del punto de derivación}.

Observe que me he adherido a una convención de nombres: La etiqueta 
del punto de derivación empieza con @code{Root-of-} (Raiz-de-), y 
después el nombre, que usará subrayado en vez de guión para separar las 
palabras. Cuando la derivación es creada su etiqueta acabará con el 
sufijo @code{-branch} (rama) que le indicará con sólo mirar el nombre 
que es una derivación. (La etiqueta del punto de derivación 
@code{Root-of-Exotic_Greetings} no incluye el sufijo @code{-branch} porque no 
es una derivación.) No tiene que usar esta convención en particular pero 
desde luego es aconsejable usar alguna.

Por supuesto, he sido extra pedante. En pequeños proyectos donde cada uno
sabe quién está haciendo qué y se pueden arreglar fácilmente las 
confusiones estas convenciones no tienen que ser usadas. El que use la 
etiqueta del punto de derivación o una estricta convención de nombres 
para sus etiquetas dependerá de la complejidad del proyecto y su esquema
de derivaciones. (No olvide que siempre puede volver atrás más tarde 
para actualizar viejas etiquetas y usar una nueva convención; obtenga 
la versión de la vieja etiqueta, añada la nueva etiqueta y borre después 
la antigua.)

Ahora qsmith puede empezar a trabajar con la derivación:


@example
paste$ cvs update -r Exotic_Greetings-branch 
cvs update: Updating . 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
paste$  
@end example

Hace algunos cambios a un par de ficheros y los entrega en la derivación:

@example
paste$ emacs README.txt a-subdir/whatever.c b-subdir/random.c 
... 
paste$ cvs ci -m "print greeting backwards, etc" 
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in README.txt; 
/usr/local/newrepos/myproj/README.txt,v  <--  README.txt 
new revision: 1.14.2.1; previous revision: 1.14 
done 
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.3.2.1; previous revision: 1.3 
done 
Checking in b-subdir/random.c; 
/usr/local/newrepos/myproj/b-subdir/random.c,v  <--  random.c 
new revision: 1.1.1.1.2.1; previous revision: 1.1.1.1 
done 
paste$  
@end example

Mientras tanto jrandom sigue trabajando en el tronco. Ella modifica 
dos o tres ficheros que qsmith tocó. Para ponerlo más dificil haremos
sus cambios creen conflictos con el trabajo de qsmith:

@example
floss$ emacs README.txt whatever.c 
 ... 
floss$ cvs ci -m "some very stable changes indeed" 
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in README.txt; 
/usr/local/newrepos/myproj/README.txt,v  <--  README.txt 
new revision: 1.15; previous revision: 1.14 
done 
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.4; previous revision: 1.3 
done 
floss$  
@end example

El conflicto no es aparente todavía ya que ninguno de los desarrolladores
ha intentado hacer la fusión de la derivación con el tronco. Ahora
jrandom hace la fusión:

@example
floss$ cvs update -j Exotic_Greetings-branch 
cvs update: Updating . 
RCS file: /usr/local/newrepos/myproj/README.txt,v 
retrieving revision 1.14 
retrieving revision 1.14.2.1 
Merging differences between 1.14 and 1.14.2.1 into README.txt 
rcsmerge: warning: conflicts during merge 
cvs update: Updating a-subdir 
RCS file: /usr/local/newrepos/myproj/a-subdir/whatever.c,v 
retrieving revision 1.3 
retrieving revision 1.3.2.1 
Merging differences between 1.3 and 1.3.2.1 into whatever.c 
rcsmerge: warning: conflicts during merge 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
RCS file: /usr/local/newrepos/myproj/b-subdir/random.c,v 
retrieving revision 1.1.1.1 
retrieving revision 1.1.1.1.2.1 
Merging differences between 1.1.1.1 and 1.1.1.1.2.1 into random.c 
floss$ cvs update 
cvs update: Updating . 
C README.txt 
cvs update: Updating a-subdir 
C a-subdir/whatever.c 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
M b-subdir/random.c 
floss$  
@end example

Dos de los ficheros tienen conflictos. No importa, con su saber hacer 
jarandom resuelve los conflictos, entrega y etiqueta el tronco 
indicando una fusión con éxito.

@example
floss$ emacs README.txt a-subdir/whatever.c 
 ... 
floss$ cvs ci -m "merged from Exotic_Greetings-branch (conflicts resolved)"
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in README.txt; 
/usr/local/newrepos/myproj/README.txt,v  <--  README.txt 
new revision: 1.16; previous revision: 1.15 
done 
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.5; previous revision: 1.4 
done 
Checking in b-subdir/random.c; 
/usr/local/newrepos/myproj/b-subdir/random.c,v  <--  random.c 
new revision: 1.2; previous revision: 1.1 
done 
floss$ cvs tag merged-Exotic_Greetings 
cvs tag: Tagging . 
T README.txt 
T foo.gif 
T hello.c 
cvs tag: Tagging a-subdir 
T a-subdir/whatever.c 
cvs tag: Tagging a-subdir/subsubdir 
T a-subdir/subsubdir/fish.c 
cvs tag: Tagging b-subdir 
T b-subdir/random.c 
floss$  
@end example

Mientras, qsmith no necesita esperar que termine la fusión para 
continuar el desarrollo si hace una etiqueta del conjunto de cambios 
que jrandom fusionó (más tarde, jrandom necesitará saber el nombre 
de esta etiqueta; en general las derivaciones dependen de una frecuente 
y completa comunicación entre los desarrolladores):

@example
paste$ cvs tag Exotic_Greetings-1 
cvs tag: Tagging . 
T README.txt 
T foo.gif 
T hello.c 
cvs tag: Tagging a-subdir 
T a-subdir/whatever.c 
cvs tag: Tagging a-subdir/subsubdir 
T a-subdir/subsubdir/fish.c 
cvs tag: Tagging b-subdir 
T b-subdir/random.c 
paste$ emacs a-subdir/whatever.c 
 ... 
paste$ cvs ci -m "print a randomly capitalized greeting" 
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.3.2.2; previous revision: 1.3.2.1 
done 
paste$  
@end example

Y por supuesto cuando qsmith haya hecho sus cambios tendrá que etiquetar:

@example
paste$ cvs -q tag Exotic_Greetings-2 
T README.txt 
T foo.gif 
T hello.c 
T a-subdir/whatever.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
paste$  
@end example

Mientras todo esto sucede jrandom hace un cambio en un fichero 
distinto, uno que qsmith no ha tocado en sus ediciones:

@example
floss$ emacs README.txt 
 ... 
floss$ cvs ci -m "Mention new Exotic Greeting features" README.txt 
Checking in README.txt; 
/usr/local/newrepos/myproj/README.txt,v  <--  README.txt 
new revision: 1.17; previous revision: 1.16 
done 
floss$  
@end example

En este momento qsmith ha entregado un nuevo cambio en su derivación 
y jrandom ha entregado otro cambio no conflictivo en un fichero 
distinto del tronco. Observe que sucede cuando jrandom trata de fusionar
desde la derivación de nuevo:

@example
floss$ cvs -q update -j Exotic_Greetings-branch 
RCS file: /usr/local/newrepos/myproj/README.txt,v 
retrieving revision 1.14 
retrieving revision 1.14.2.1 
Merging differences between 1.14 and 1.14.2.1 into README.txt 
rcsmerge: warning: conflicts during merge 
RCS file: /usr/local/newrepos/myproj/a-subdir/whatever.c,v 
retrieving revision 1.3 
retrieving revision 1.3.2.2 
Merging differences between 1.3 and 1.3.2.2 into whatever.c 
rcsmerge: warning: conflicts during merge 
RCS file: /usr/local/newrepos/myproj/b-subdir/random.c,v 
retrieving revision 1.1 
retrieving revision 1.1.1.1.2.1 
Merging differences between 1.1 and 1.1.1.1.2.1 into random.c 
floss$ cvs -q update 
C README.txt 
C a-subdir/whatever.c 
floss$  
@end example

¡Hay conflictos! ¿Esperaba esto?

El problema radica en el significado de fusionar. En @ref{Una introduccion 
a CVS} expliqué que cuando usted ejecuta

@example
floss$ cvs update -j BRANCH 
@end example

en una copia de trabajo, CVS fusiona en la copia de trabajo las 
diferencias entre la raiz BRANCH y su estado actual. El problema con 
este comportamiento es que, en esta situación, la mayoría de esos 
cambios ya habían sido incorporados al tronco la primera vez que jrandom
hizo una fusión. Cuando CVS intentó fusionarlos de nuevo (sobre ellos 
mismos que es como estaban) se produce naturalmente un conflicto.

Lo que jrandom realmente quería hacer era fusionar en su copia de trabajo
los cambios entre la más reciente fusión del tronco con su estado actual. 
Usted puede hacer esto usando dos -j indicadores para actualizar, como 
debería recordar en @ref{Una introduccion a CVS}, siempre que sepa que 
revisión corresponde con cada indicador. Afortunadamente qsmith hizó una 
etiqueta exactamente en el último punto de fusión (¡hurra por planificar 
con antelación!), por lo que esto no será problema. Primero veamos como 
jrandom puede devolver su copia de trabajo un estado limpio, desde el 
que puede rehacer la fusión:

@example
floss$ rm README.txt a-subdir/whatever.c 
floss$ cvs -q update 
cvs update: warning: README.txt was lost 
U README.txt 
cvs update: warning: a-subdir/whatever.c was lost 
U a-subdir/whatever.c 
floss$  
@end example

Ahora ella puede hacer la fusión, usando la etiqueta colocada 
convenientemente por qsmith.

@example
floss$ cvs -q update -j Exotic_Greetings-1 -j Exotic_Greetings-branch 
RCS file: /usr/local/newrepos/myproj/a-subdir/whatever.c,v 
retrieving revision 1.3.2.1 
retrieving revision 1.3.2.2 
Merging differences between 1.3.2.1 and 1.3.2.2 into whatever.c 
floss$ cvs -q update 
M a-subdir/whatever.c 
floss$  
@end example

Mucho mejor. Los cambios de qsmith han sido incorporados a whatever.c;
jrandom puede hacer una entrega y etiquetado:


@example
floss$ cvs -q ci -m "merged again from Exotic_Greetings (1)"
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.6; previous revision: 1.5 
done 
floss$ cvs -q tag merged-Exotic_Greetings-1 
T README.txt 
T foo.gif 
T hello.c 
T a-subdir/whatever.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
floss$  
@end example

Incluso si qsmith hubiese olvidado etiquetar en el punto de fusión, 
las esperanzas no estaría perdidas. Si jrandom supiese aproximadamente 
cuando hizo qsmith su primera entrega ella podría tratar de filtrar 
por la fecha:

@example
floss$ cvs update -j Exotic_Greetings-branch:3pm -j Exotic_Greetings_branch 
@end example

Aunque útil como último recurso, filtrar por fecha no es tan bueno 
porque selecciona los cambios basandose en los recuerdos de la gnete 
en vez de en designaciones que dependan del desarrollador. Si el primer 
conjunto de cambios fusionados de qsmith hubiera ocurrido en varias 
entregas en vez de sólo una jrandom pudiera equivocadamente elegir una 
fecha u hora que tomara algunos de los cambios, pero no todos.

No es necesario que cada punto etiquetado en los cambios de qsmith sea 
enviado al repositorio un una simple entrega. Ocurrió así casualmente 
en el ejemplo. En la vida real, qsmith pudo haber hecho varias entregas 
entre cada etiquetado. Él puede trabajar de forma aislada en su derivación 
tanto como quiera. La razón de las etiquetas es registar sucesivos 
puntos en la derivación donde considere que los cambios deban ser 
fusionados con la rama principal. Siempre que jrandom fusione 
usando dos indicadores -j y sea cuidadoso al usar las etiquetas de 
ramificación de qsmith en el orden apropiado y una sóla vez por cada un 
la rama principal padecer el problema de la doble fusión.

Podrían ocurrir conflictos, pero éstos serían de la inevitable clase que 
requiere resolución humana; situaciones en las que tanto el tronco como 
la derivación realizan cambios en la misma área de código.

@c ----------------------------------------------------------------
@node La Aproximación de la Cola de Milano -- Fusionar dentro y fuera de la rama principal
@subsection La Aproximación de la Cola de Milano -- Fusionar dentro y fuera de la rama principal 

Fusionar repetidamente de derivación a tronco es bueno para la gente del 
tronco ya que ven todos sus cambios y los de la derivación. Sin embargo 
el desarrollador de la derivación no obtiene nunca los cambios producidos
en el tronco.

Para permitir esto el desarrollador de la derivación debe realizar un 
paso extra cuando tenga ganas de hacer una fusión de los cambios más 
recientes del tronco y resolver los inevitables conflictos que surgan:

@example
paste$ cvs update -j CABEZA
@end example

La etiqueta especial reservada @code{CABEZA} señala el estado actual del 
tronco. La orden anterior fusiona en el tronco los cambios entre la raiz 
de la actual derivación (@code{Exotic_Greetings-branch}) y la revisión 
más alta de cada fichero del tronco. Por supuesto qsmith tiene que 
etiquetar de nuevo después de hacer esto para que los desarrolladores del 
tronco eviten accidentalmente fusionar sus propios cambios cuando 
intenten conseguir los de qsmith.

De la misma manera el desarrollador de la derivación puede usar las 
etiquetas de fusión del tronco como límites, permitinedo a la derivación 
fusionar exactamente aquellos cambios entre la última fusión y el estado
actual del tronco (de la misma manera que el tronco fusiona). Por 
ejemplo, supongamos que jrandom ha hecho algunos cambios a hello.c 
después de fusionar la derivación:
 
@example
floss$ emacs hello.c 
 ... 
floss$ cvs ci -m "clarify algorithm" hello.c 
Checking in hello.c; 
/usr/local/newrepos/myproj/hello.c,v  <--  hello.c 
new revision: 1.22; previous revision: 1.21 
done 
floss$  
@end example

Después puede qsmith fusionar esos cambios en el tronco, entregar, y,
por supuesto, etiquetar.

@example
paste$ cvs -q update -j merged-Exotic_Greetings-1 -j HEAD 
RCS file: /usr/local/newrepos/myproj/hello.c,v 
retrieving revision 1.21 
retrieving revision 1.22 
Merging differences between 1.21 and 1.22 into hello.c 
paste$ cvs -q update 
M hello.c 
paste$ cvs -q ci -m "merged trunk, from merged-Exotic_Greetings-1 to HEAD" 
Checking in hello.c; 
/usr/local/newrepos/myproj/hello.c,v  <--  hello.c 
new revision: 1.21.2.1; previous revision: 1.21 
done 
paste$ cvs -q tag merged-merged-Exotic_Greetings-1 
T README.txt 
T foo.gif 
T hello.c 
T a-subdir/whatever.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
paste$  
@end example

Observe que a jrandom no etiquetó después de entregar los cambios a 
hello.c pero si qsmith. El principio utilizado aquí es que aunque usted 
no necesita etiquetar después de hacer cualquier pequeno cambio si 
debería hacerlo después de fusionar o entregar su línea de desarrollo
a un estado que permita la fusión. De este modo otras personas, quizá en 
otras derivaciones tienen un punto de referencia en el cual basarse para 
sus propias fusiones.

@c -------------------------------------------------------------------
@node La Aproximación del Pez Volador -- Una forma más simple de hacerlo
@subsection La Aproximación del Pez Volador -- Una forma más simple de hacerlo

Hay una variante más simple, aunque un poco más limitada, que la anterior.
En ella, los desarrolladores de la derivación se congelan o paran mientras 
el tronco se fusiona, y después los desarrolladores del tronco crean una 
nueva derivación, que reemplaza la anterior. Los desarrolladores de la 
antigua derivación cambian a esa nueva derivación y siguen trabajando. 
Este ciclo sigue hasta uqe no hay más necesidad de desarrollo en la 
derivación. Funciona así (supondremos que jrandom@@floss está en el tronco 
y qsmith@@paste esté en la derivación como hasta ahora):
 

@example
floss$ cvs tag -b BRANCH-1 
paste$ cvs checkout -r BRANCH-1 myproj 
@end example

Tronco y derivación empiezan a funcionar y pasado un tiempo los 
desarrolladores deciden que tienen que fusionar la derivación en 
el tronco:

@example
paste$ cvs ci -m "committing all uncommitted changes" 
floss$ cvs update -j BRANCH-1 
@end example

Todos los cambios de la rama se fusionan y los desarrolladores paran 
su trabajo mientras que los desarrolladores del tronco resuelven 
cualquier conflicto, entregan, etiquetan y crean una nueva derivación:

@example
floss$ cvs ci -m "merged from BRANCH-1" 
floss$ cvs tag merged-from-BRANCH-1 
floss$ cvs tag -b BRANCH-2 
@end example

Ahora los desarrolladores de la derivación cambian sus copias de trabajo 
a la nueva derivación sabiendo que no perderán ningún cambio no 
entregado ya que estaban actualizados cuando la fusión ocurrió ya la 
nueva derivación viene de un tronco que incorpora los cambios de la 
nueva derivación:

@example
paste$ cvs update -r BRANCH-2 
@end example

Y el ciclo continúa del mismo modo indefinidamente; sustituya 
BRANCH-2 por BRANCH-1 y BRANCH-3 por BRANCH-2.

Llamo a esta técnica @dfn{Pez Volador} porque la derivación está 
constantemente emergiendo del tronco, viajando una corta distancia y 
uniéndose a él después. Las ventajas de esta aproximación son que 
es simple (el tronco siempre fusiona todos los cambios para una 
derivación dada) y los desarrolladores no tinene que resolver 
conflictos (cada vez trabajan con una nueva y limpia derivación). Las 
desventajas son que la gente de la derivación debe esperar sin poder
hacer nada hasta que se haya fusionado el tronco (que puede durar 
un tiempo arbitrario dependiendo de cómo haya que resolver los conflictos). 
Otra pequeña desventaja es habrá muchas derivaciones sin usar en vez de 
etiquetas no_derivación. Si no le importa tener millones de pequeñas y 
obsoletas derivaciones y puede anticipar claramente fusiones libres de 
problemas el Pez Volador pueda ser el modo más fácil en términos mentales.

@c --------------------------------------------------------------------
@node Derivaciones y expansión de palabras -- Enemigos naturales
@subsection Derivaciones y expansión de palabras -- Enemigos naturales

Si sus ficheros contienen palabras de expansión en RCS que se 
sustituyen de forma distinta en la derivación y en el tronco casi 
seguro que tendrá conflictos en las fusiones. Incluso si nada cambia
las palabras de expansión se sobrepondrán y sus sustituciones no se podrán 
hacer. Por ejemplo; if README.txt contiene esto en el tronco

@example
$Revision: 1.4 $ 
@end example

y esto en la derivación

@example
$Revision: 1.4 $ 
@end example

entonces cuando sea realizada la fusión obtendrá el siguiente conflicto:

@example
floss$ cvs update -j Exotic_Greetings-branch
RCS file: /usr/local/newrepos/myproj/README.txt,v
retrieving revision 1.14
retrieving revision 1.14.2.1
Merging differences between 1.14 and 1.14.2.1 into README.txt
rcsmerge: warning: conflicts during merge
floss$ cat README.txt
 ... 
<<<<<<< README.txt 
key $Revision: 1.4 $ 
======= 
key $Revision: 1.4 $ 
>>>>>>> 1.14.2.1 
 ... 
floss$  
@end example

Para evitar esto, usted puede temporalmente desabilitar la expansión de 
palabras pasando la opción -kk (No sé que significa; ¿"kill keywords" 
(mata palabras) quizá?) cuando haga la fusión:

@example
floss$ cvs update -kk -j Exotic_Greetings-branch 
RCS file: /usr/local/newrepos/myproj/README.txt,v 
retrieving revision 1.14 
retrieving revision 1.14.2.1 
Merging differences between 1.14 and 1.14.2.1 into README.txt 
floss$ cat README.txt 
 ... 
$Revision: 1.4 $ 
 ... 
floss$  
@end example

Tiene que tener cuidado con una cosa; si usa -kk, invalida cualquier 
otro modo de expansión de palabras que pueda haber establecido para ese 
fichero. Específicamente esto es un problema para los ficheros binarios 
que normalmente usan -kb (que suprime todas las palabras de expansión 
y conversiones de fin de línea). Por lo tanto si tiene ficheros binarios
en una derivación no use -kk. Trate los conflictos manualmente.

@c ------------------------------------------------------------------
@node Vigilando fuentes de terceras partes (Derivaciones comerciales)
@section Vigilando fuentes de terceras partes (Derivaciones comerciales)

De vez en cuando un sitio pudiera hacer un cambio local al código de 
un programa obtenido del exterior. Si la fuente exterior no incorpora 
los cambios locales (y habría muchas razones legítimas para no hacerlo),
el sitio tiene que mantener sus cambios en cada actualización del 
software.

CVS puede ayudar en esta tarea a través de una característica conocida 
como @dfn{derivaciones comerciales}. De hecho, derivaciones comerciales 
está detrás de los ahora misteriosos dos finales argumentos de la orden 
@code{cvs import}; la etiqueta comercial y la de entrega final que vimos 
en @ref{Una introduccion a CVS}.

He aquí como funciona. La importación inicial is como cualquier otra 
importación de un proyecto en CVS (excepto que tendrá que elegir la 
etiqueta comercial con un poco de cuidado):

@example
floss$ pwd 
/home/jrandom/theirproj-1.0 
floss$ cvs import -m "Import of TheirProj 1.0" theirproj Them THEIRPROJ_1_0
N theirproj/INSTALL 
N theirproj/README 
N theirproj/src/main.c 
N theirproj/src/parse.c 
N theirproj/src/digest.c 
N theirproj/doc/random.c 
N theirproj/doc/manual.txt 

No conflicts created by this import 

floss$  
@end example

Después debe obtener una copia de trabajo, hacer sus modificaciones 
locales y entregar:

@example
floss$ cvs -q co theirproj 
U theirproj/INSTALL 
U theirproj/README 
U theirproj/doc/manual.txt 
U theirproj/doc/random.c 
U theirproj/src/digest.c 
U theirproj/src/main.c 
U theirproj/src/parse.c 
floss$ cd theirproj 
floss$ emacs src/main.c src/digest.c 
 ... 
floss$ cvs -q update 
M src/digest.c 
M src/main.c 
floss$ cvs -q ci -m "changed digestion algorithm; added comment to main" 
Checking in src/digest.c; 
/usr/local/newrepos/theirproj/src/digest.c,v  <--  digest.c 
new revision: 1.2; previous revision: 1.1 
done 
Checking in src/main.c; 
/usr/local/newrepos/theirproj/src/main.c,v  <--  main.c 
new revision: 1.2; previous revision: 1.1 
done 
floss$  
@end example

Un año más tarde la siguiente versión del programa llega de Ellos, S.A.,
y ustede debe incorporar sus cambios locales a ella. Los cambios de 
ellos y los suyos se sobreponen ligeramente. Ellos han añadido un nuevo 
fichero, modificado un par de ficheros que usted no tocó y otros dos 
que usted si modificó.

Primero tiene que hacer otra importación para obtener las nuevas fuentes.
Casi todo estaba como en la importación inicial; usted está importando el 
mismo proyecto del repositorio y de la misma derivación comercial. La 
única diferencia es en la etiqueta de entrega final:

@example
floss$ pwd 
/home/jrandom/theirproj-2.0 
floss$ cvs -q import -m "Import of TheirProj 2.0" theirproj Them THEIRPROJ_2_0
U theirproj/INSTALL 
N theirproj/TODO 
U theirproj/README 
cvs import: Importing /usr/local/newrepos/theirproj/src 
C theirproj/src/main.c 
U theirproj/src/parse.c 
C theirproj/src/digest.c 
cvs import: Importing /usr/local/newrepos/theirproj/doc 
U theirproj/doc/random.c 
U theirproj/doc/manual.txt 

2 conflicts created by this import. 
Use the following command to help the merge: 

       cvs checkout -jThem:yesterday -jThem theirproj 

floss$  
@end example

Dios mío; No hemos visto que CVS sea tan útil. Nos está diciendo que
orden ejecutar para fusionar los cambios. Y casi está bien. En realidad 
el comando funciona (asumiendo que sustituye @code{yesterday} (ayer) por un 
intervalo de tiempo que incluya la primera primera importación pero no 
la segunda). Yo prefiero hacerlo mediante etiquetas de entrega final:

@example
floss$ cvs checkout -j THEIRPROJ_1_0 -j THEIRPROJ_2_0 theirproj 
cvs checkout: Updating theirproj 
U theirproj/INSTALL 
U theirproj/README 
U theirproj/TODO 
cvs checkout: Updating theirproj/doc 
U theirproj/doc/manual.txt 
U theirproj/doc/random.c 
cvs checkout: Updating theirproj/src 
U theirproj/src/digest.c 
RCS file: /usr/local/newrepos/theirproj/src/digest.c,v 
retrieving revision 1.1.1.1 
retrieving revision 1.1.1.2 
Merging differences between 1.1.1.1 and 1.1.1.2 into digest.c 
rcsmerge: warning: conflicts during merge 
U theirproj/src/main.c 
RCS file: /usr/local/newrepos/theirproj/src/main.c,v 
retrieving revision 1.1.1.1 
retrieving revision 1.1.1.2 
Merging differences between 1.1.1.1 and 1.1.1.2 into main.c 
U theirproj/src/parse.c 
floss$  
@end example

Observe como la importación nos indica que hay dos conflictos pero 
la fusión parece ver sólo uno. Esto es porque la idea de conflicto 
en CVS es un poco diferente que en las otras ocasiones. Básicamente 
la importación informa de conflictos cuando usted y el distribuidor 
modifican un fichero entre la última importación y esta. Sin embargo, 
cuando se fusiona o actualiza la definición de conflicto es la usual,
cambios que se sobreponen. Cambios que no se sobreponen son fusionados 
de la forma normal y el fichero se marca como modificado.

Un @code{diff} verifica que sólo uno de los ficheros tiene conflictos:


@example
floss$ cvs -q update 
C src/digest.c 
M src/main.c 
floss$ cvs diff -c 
Index: src/digest.c 
===================================================================
RCS file: /usr/local/newrepos/theirproj/src/digest.c,v 
retrieving revision 1.2 
diff -c -r1.2 digest.c 
*** src/digest.c        1999/07/26 08:02:18     1.2 
-- src/digest.c        1999/07/26 08:16:15 
*************** 
*** 3,7 **** 
-- 3,11 ---- 
 void 
 digest () 
 @{ 
+ <<<<<<< digest.c 
   printf ("gurgle, slorp\n"); 
+ ======= 
+   printf ("mild gurgle\n"); 
+ >>>>>>> 1.1.1.2 
 @} 
Index: src/main.c 
=================================================================== 
RCS file: /usr/local/newrepos/theirproj/src/main.c,v 
retrieving revision 1.2 
diff -c -r1.2 main.c 
*** src/main.c  1999/07/26 08:02:18     1.2 
-- src/main.c  1999/07/26 08:16:15 
*************** 
*** 7,9 **** 
-- 7,11 ---- 
 @{ 
   printf ("Goodbye, world!\n"); 
 @} 
+  
+ /* I, the vendor, added this comment for no good reason. */ 
floss$  
@end example

A partir de aquí deberá resolver los conflictos como cualquier otra 
fusión:

@example
floss$ emacs  src/digest.c  src/main.c 
 ... 
floss$ cvs -q update 
M src/digest.c 
M src/main.c 
floss$ cvs diff src/digest.c 
cvs diff src/digest.c  
Index: src/digest.c 
=================================================================== 
RCS file: /usr/local/newrepos/theirproj/src/digest.c,v 
retrieving revision 1.2 
diff -r1.2 digest.c 
6c6 
<   printf ("gurgle, slorp\n"); 
-- 
>   printf ("mild gurgle, slorp\n"); 
floss$  
@end example

Entones entregue los cambios

@example
floss$ cvs -q ci -m "Resolved conflicts with import of 2.0" 
Checking in src/digest.c; 
/usr/local/newrepos/theirproj/src/digest.c,v  <--  digest.c 
new revision: 1.3; previous revision: 1.2 
done 
Checking in src/main.c; 
/usr/local/newrepos/theirproj/src/main.c,v  <--  main.c 
new revision: 1.3; previous revision: 1.2 
done 
floss$  
@end example

y espere la próxima versión del distribuidor. (Por supuesto tendrá que 
comprobar que sus antiguas modificaciones todavía funcionan).

@c ---------------------------------------------------------------
@node Exportar para distribución pública
@section Exportar para distribución pública
@c @indexkff export command

CVS es un buen mecanismo de distribución para desarrolladores, pero la 
mayoría de usuarios obtendrán el software a través de un paquete 
descargable. Este paquete normalmente no es una copia de trabajo de CVS;
es un árbol de código que puede ser fácilmente configurado y compilado 
en el sistema del usuario.

Sin embargo, CVS ofrece un mecanismo que ayuda a crear ese paquete,
la orden @w{@code{cvs export}} (Exportar). @dfn{Exportar} un proyecto es 
como obtener una copia de trabajo del proyecto, excepto que se obtiene 
el directorio completo del proyecto @emph{sin} los subdirectorios 
administrativos. O sea, que no obtiene una copia de trabajo sino el código 
fuente completo que no sabe nado sobre dónde vino o que versiones de CVS 
tienen sus ficheros. Así la copia exportada es como lo que el público ve 
cuando descarga y desempaqueta un distribución. Asumiendo que el proyecto 
está organizado para que sea directamente compilable desde la copia de 
trabajo (y así es como debería estar), entonces todavía será compilable 
en la copia exportada.

La orden @code{export} funciona igual que @code{checkout}, excepto que 
requiere una etiqueta o fecha. Por ejemplo, aquí hemos etiquetado el 
proyecto con un nombre para el lanzamiento final y hemos exportado 
basándonos en eso:


@example
floss$ pwd
/home/jrandom/myproj
floss$ cvs -q tag R_1_0
T README.txt
T hello.c
T a-subdir/whatever.c
T a-subdir/subsubdir/fish.c
T b-subdir/random.c
floss$ cd ..
floss$ cvs -d /usr/local/newrepos -q export -r R_1_0 -d myproj-1.0 myproj
U myproj-1.0/README.txt
U myproj-1.0/hello.c
U myproj-1.0/a-subdir/whatever.c
U myproj-1.0/a-subdir/subsubdir/fish.c
U myproj-1.0/b-subdir/random.c
floss$ cd myproj-1.0
floss$ ls
README.txt  a-subdir  b-subdir  hello.c
@end example

Observe que como la @code{export} no es llamada desde una copia de trabajo 
ha sido necesario usar la opción global @code{-d} para decirle a CVS qué 
repositorio usar. En este ejemolo en particular, además, exportamos a un 
directorio explícitamente nombrado (@code{myproj-1.0}) en vez del 
directorio por defecto con el nombre del proyecto (@code{myproy}, porque 
ya había una copia con ese nombre presente. Esta situación no es 
infrecuente.

Después de crear la copia mediante export, como en el ejemplo anterior, 
lo que sigue es suficiente para completar la entrega final si el 
proyecto es sencillo:

@example
floss$ tar cf myproj-1.0.tar myproj-1.0
floss$ gzip --best myproj-1.0.tar
floss$ ls
myproj/   myproj-1.0/   myproj-1.0.tar.gz
floss$ rm -rf myproj-1.0
floss$ mv myproj-1.0.tar.gz /home/ftp/pub/myproj/
@end example

Ejecutar todas estas órdenes a mano es raro. Lo normal es que 
@w{@code{cvs export}} sea llamada desde una rutina que maneje todos 
los aspectos de la entrega final y el proceso de empaquetado. Debido 
a que hay varias entregas de prueba antes del lanzamiento final es 
deseable que los procedimientos para crear un paquete se automatizen.

@c --------------------------------------------------------------------
@node El humilde gurú
@section El humilde gurú

Si usted ha leido y comprendido e incluso mejor, ha experimentado con
todo lo de este capítulo, puede asegurar que no le quedan muchas más 
cosas en CVS por aprender; al menos hasta que alguien añada una 
nueva e importante característica a CVS. Todo lo que necesita saber para 
usar CVS en un gran proyecto ha sido presentado.

Antes de que esto se le suba a la cabeza permítame insistir en la sugerencia, 
hecha ya en el capítulo 4, de que se suscriba a la lista de 
correo @email{info-cvs@@gnu.org}. A pesar de una proporción de ruido 
común a la mayoría de listas de correo en Internet, lo bueno que le 
llega merece la pena esperarlo. He estado suscrito durante el tiempo que 
estuve escribiendo este capítulo y estaría sorprendido de la cantidad de 
importantes de detalles que aprendí sobre el comportamiento de CVS 
leyendo los correos de otras personas. Si va a usar CVS seriamente y 
especialmente si usted es un administrador de CVS en un grupo de 
desarrolladores se puede beneficiar del conocimiento compartido 
entre todos los demás usuarios serios que hay por ahí.






