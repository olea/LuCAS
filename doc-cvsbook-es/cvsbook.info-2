This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: Ver lo que Ud. (y otros) han hecho - comandos Update y Diff,  Next: CVS y argumentos implícitos,  Prev: Hacer un cambio,  Up: Un día con CVS

Ver lo que Ud. (y otros) han hecho - comandos Update y Diff
-----------------------------------------------------------

Hasta ahora nos hemos referido a la "actualización" como una forma de
traer a su copia de trabajo los cambios que se han realizado en el
repositorio, es decir, como una manera de obtener los cambios hechos
por otras personas. Sin embargo, la actualización es un proceso algo
más complejo que esto, puesto que compara el estado global de su copia
de trabajo con el estado del proyecto que se encuentra en el
repositorio.  Incluso si nada ha cambiado en el repositorio desde que
se obtuvo la copia, puede que algo en la copia de trabajo sí lo haya
hecho, y "update" también le mostrará esto:

     floss$ cvs update
     cvs update: Updating .
     M hello.c
     cvs update: Updating a-subdir
     cvs update: Updating a-subdir/subsubdir
     cvs update: Updating b-subdir

La "M" al lado de hello.c significa que el fichero ha sido modificado
desde que se obtuvo la copia, y que las modificaciones no se han enviado
aún al repositorio.

A veces, todo lo que necesita es simplemente saber qué ficheros ha
editado. Sin embargo, si desea echar un vistazo más de cerca a los
cambios, puede solicitar un informe detallado en formato diff. El
comando diff compara los ficheros que puedan haberse modificado en la
copia de trabajo con sus homónimos en el repositorio, mostrando a
continuación cualquier posible diferencia:

     floss$ cvs diff
     cvs diff: Diffing .
     Index: hello.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.1.1.1
     diff -r1.1.1.1 hello.c
     6a7
     >   printf ("¡Adiós, mundo!\n");
     cvs diff: Diffing a-subdir
     cvs diff: Diffing a-subdir/subsubdir
     cvs diff: Diffing b-subdir

Aunque un poco liosa, esta información es útil, si bien todavía hay un
montón de ruido ahí. Para empezar, puede ignorar la mayor parte de las
líneas del comienzo, dado que sólo hacen referencia al nombre del
fichero del repositorio e indican el número de la última revisión
enviada al mismo.  Son datos útiles en otras circunstancias (las
veremos en detalle más adelante), pero no las necesita cuando sólo
quiere hacerse una idea de los cambios que se han hecho en la copia de
trabajo.

Una molestia más seria a la hora de leer el diff es que CVS anuncia su
entrada en escena a medida que va entrando en cada directorio durante la
actualización. Esto puede ser útil durante largas actualizaciones en
grandes proyectos, puesto que le da una idea del tiempo que va a
necesitar el comando, pero ahora mismo lo único que hace es molestarle
mientras intenta interpretar lo que está leyendo. Así pues, digámosle a
CVS que no diga nada sobre su trabajo, con la opción global -Q (de "Que
te calles", obviamente):

     floss$ cvs -Q diff
     Index: hello.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.1.1.1
     diff -r1.1.1.1 hello.c
     6a7
     >   printf ("¡Adiós, mundo!\n");

Mejor - al menos, parte del ruido ha desaparecido. Sin embargo, el diff
es aún difícil de leer. Le está diciendo que en la línea 6 se añadió una
línea nueva (que se convirtió en la línea 7) cuyo contenido es:

     printf ("¡Adiós, mundo!\n");

El signo ">" que precede a la línea en el diff le dice que esta línea
está presente en la nueva versión del fichero, pero no en la antigua.

Sin embargo, el formato podría ser aún más legible. Muchas personas
encuentran el formato "de contexto" de diff más fácil de leer, porque
muestra menos líneas de contexto delimitando los cambios. Los diffs de
contexto pueden generarse pasando a diff la opción -c:

     floss$ cvs -Q diff -c
     Index: hello.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.1.1.1
     diff -c -r1.1.1.1 hello.c
     *** hello.c     1999/04/18 18:18:22     1.1.1.1
     --- hello.c     1999/04/19 02:17:07
     ***************
     *** 4,7 ****
     ---4,8 --
       main ()
       {
         printf ("¡Hola, mundo!\n");
     +   printf ("¡Adiós, mundo!\n");
       }

¡Esto sí está claro! Incluso si no está acostumbrado a leer diffs de
contexto, un vistazo a esta información mostrará de forma bastante
obvia lo que ha sucedido: se añadió una nueva línea (el + en la primera
columna significa que se ha añadido una línea) entre la línea que
imprime "¡Hola, mundo!" y la llave final.

No es necesario que seamos capaces de interpretar perfectamente los
diffs de contexto (esto es trabajo para el programa "patch"), pero le
será útil tomarse un tiempo para adquirir al menos una cierta
familiaridad con el formato. Las primeras dos líneas (después del rollo
del comienzo) son

     *** hello.c     1999/04/18 18:18:22     1.1.1.1
     --- hello.c     1999/04/19 02:17:07

y le dicen qué se está comparando con qué. En este caso, la revisión
1.1.1.1 de hello.c se está comparando con una versión modificada del
mismo fichero (motivo por el cual no aparece número alguno de revisión
en la segunda línea, porque los cambios de la copia de trabajo no se
han enviado todavía al repositorio). Las líneas de asteriscos y guiones
identifican secciones situadas más adelante en el fichero de
diferencias.  Más adelante, una línea de asteriscos seguida de una
franja de valores precede a una sección del fichero original. Después,
una línea de guiones, con una franja de números de línea nuevos y
potencialmente distintos, precede a una sección del fichero modificado.
Estas secciones están organizadas por pares: por un lado la parte del
fichero antiguo, y por otro lado la parte del fichero nuevo.

Nuestro fichero de diferencias tiene uno de estos pares:

     ***************
     *** 4,7 ****
     --- 4,8 --
       main ()
       {
         printf ("¡Hola, mundo!\n");
     +   printf ("¡Adiós, mundo!\n");
       }

La primera sección del par está vacía, lo que significa que no se ha
eliminado nada del fichero original. La segunda sección indica que, en
el lugar correspondiente del nuevo fichero, se ha añadido una nueva
línea, que aparece marcada con un signo "+". (Cuando el diff cita partes
de ficheros, se reserva las primeras dos columnas a la izquierda para
códigos especiales, como el "+", así que el trozo entero aparenta estar
justificado a la izquierda con dos espacios. Esta justificación extra
desaparece, por supuesto, cuando se aplica el fichero de diferencias.)

La franja de números de líneas muestra el alcance del par de
diferencias, incluyendo líneas de contexto. En el fichero original, el
par estaba en las líneas 4 a la 7; en el nuevo fichero, son las líneas
4 a la 8 debido a la nueva línea que se ha añadido. Fíjese en que el
fichero de diferencias no necesita enseñar ninguna cosa del fichero
original puesto que no se ha eliminado nada; sólo nos ha mostrado la
franja afectada y ha continuación ha saltado a la segunda sección del
par de diferencias.

Aquí hay otro diff de contexto, procedente esta vez de un proyecto real
mío:

     floss$ cvs -Q diff -c
     Index: cvs2cl.pl
     ===================================================================
     RCS file: /usr/local/cvs/kfogel/code/cvs2cl/cvs2cl.pl,v
     retrieving revision 1.76
     diff -c -r1.76 cvs2cl.pl
     *** cvs2cl.pl   1999/04/13 22:29:44     1.76
     --- cvs2cl.pl   1999/04/19 05:41:37
     ***************
     *** 212,218 ****
               # can contain uppercase and lowercase letters, digits, '-',
               # and '_'. However, it's not our place to enforce that, so
               # we'll allow anything CVS hands us to be a tag:
     !         /^\s([^:]+): ([0-9.]+)$/;
               push (@{$symbolic_names{$2}}, $1);
             }
           }
     -- 212,218 --
               # can contain uppercase and lowercase letters, digits, '-',
               # and '_'. However, it's not our place to enforce that, so
               # we'll allow anything CVS hands us to be a tag:
     !         /^\s([^:]+): ([\d.]+)$/;
               push (@{$symbolic_names{$2}}, $1);
             }
           }

El signo de exclamación indica que la línea marcada difiere del fichero
antiguo al nuevo. Dado que no hay ningún signo "+" o "-", sabemos que el
número total de líneas del fichero sigue siendo el mismo.

Éstas son otras diferencias de contexto del mismo proyecto, esta vez un
poco más complejas:

     floss$ cvs -Q diff -c
     Index: cvs2cl.pl
     ===================================================================
     RCS file: /usr/local/cvs/kfogel/code/cvs2cl/cvs2cl.pl,v
     retrieving revision 1.76
     diff -c -r1.76 cvs2cl.pl
     *** cvs2cl.pl   1999/04/13 22:29:44     1.76
     --- cvs2cl.pl   1999/04/19 05:58:51
     ***************
     *** 207,217 ****
     }
             else    # we're looking at a tag name, so parse & store it
             {
     -         # According to the Cederqvist manual, in node "Tags", "Tag
     -         # names must start with an uppercase or lowercase letter and
     -         # can contain uppercase and lowercase letters, digits, '-',
     -         # and '_'. However, it's not our place to enforce that, so
     -         # we'll allow anything CVS hands us to be a tag:
               /^\s([^:]+): ([0-9.]+)$/;
               push (@{$symbolic_names{$2}}, $1);
             }
     - 207,212 --
     ***************
     *** 223,228 ****
     --- 218,225 --
           if (/^revision (\d\.[0-9.]+)$/) {
             $revision = "$1";
           }
     +
     +     # Esta línea ha sido añadida, lo admito, sólo para este ejemplo de diff.
     
           # If have file name but not time and author, and see date or
           # author, then grab them:

Este fichero diff tiene dos pares de diferencias. En el primero se han
eliminado cinco líneas (estas líneas se muestran sólo en la primera
sección del par, y la cuenta de líneas de la segunda sección indica que
tiene menos líneas).  Una línea continua de asteriscos hace las veces de
delimitador entre pares, y en el segundo par vemos que se han añadido
dos líneas: una línea en blanco y un comentario inútil. Observe cómo
los números de línea compensan el efecto del par anterior. En el
fichero original, la franja del segundo par iba desde 223 hasta 228; en
el nuevo fichero, dado que la eliminación tuvo lugar en el primer par,
la franja de líneas abarca desde la 218 hasta la 225.

Enhorabuena, en este momento tiene posiblemente toda la experiencia que
necesita para poder interpretar ficheros de diferencias.


File: cvsbook.info,  Node: CVS y argumentos implícitos,  Next: Enviar cambios al repositorio,  Prev: Ver lo que Ud. (y otros) han hecho - comandos Update y Diff,  Up: Un día con CVS

CVS y argumentos implícitos
---------------------------

En cada uno de los comandos de CVS explicados hasta el momento, quizás
se haya dado cuenta de que no hemos indicado fichero alguno en la línea
de comando. Por ejemplo, hemos utilizado

     floss$ cvs diff

en lugar de

     floss$ cvs diff hello.c

y

     floss$ cvs update

en lugar de

     floss$ cvs update hello.c

El principio que dicta esto es que si usted no indica ningún nombre de
fichero, CVS actuará sobre todos los ficheros sobre los que el comando
resultaría apropiado. Esto incluye también ficheros en subdirectorios
situados por debajo del directorio actual; CVS automáticamente desciende
desde el directorio actual hasta cada subdirectorio en el árbol. Por
ejemplo, si modificó b-subdir/random.c y a-subdir/subsubdir/fish.c,
invocar una actualización podría devolver unos resultados como éstos:

     floss$ cvs update
     cvs update: Updating .
     M hello.c
     cvs update: Updating a-subdir
     cvs update: Updating a-subdir/subsubdir
     M a-subdir/subsubdir/fish.c
     cvs update: Updating b-subdir
     M b-subdir/random.c
     floss$

o mejor aún:

     floss$ cvs -q update
     M hello.c
     M a-subdir/subsubdir/fish.c
     M b-subdir/random.c
     floss$

Nota: La opción -q es una versión "ligera" de -Q. Si se hubiera usado
-Q, el comando no habría mostrado nada en absoluto, porque las notas de
modificación son consideradas mensajes de información no esenciales.
La versión en minúsculas, -q, es menos estricta: suprime los mensajes
que posiblemente no queramos, a la vez que permite que otros mensajes,
posiblemente más útiles, sí lleguen hasta nosotros.

También puede nombrar ficheros específicos que desee actualizar:

     floss$ cvs update hello.c b-subdir/random.c
     M hello.c
     M b-subdir/random.c
     floss$

y CVS sólo examinará estos ficheros, ignorando cualquier otro.

Lo cierto es que es más habitual no limitar la actualización a
determinados ficheros, puesto que en la mayoría de los casos querrá
actualizar el árbol de directorios al completo de una sola vez. En todo
caso, recuerde que las actualizaciones que hacemos aquí a modo de
ejemplo sólo muestran que algunos ficheros se han modificado de forma
local, porque aún no se ha cambiado nada en el repositorio. Cuando
otras personas están trabajando en el mismo proyecto que usted, siempre
existe la posibilidad de que la actualización incorpore algunos cambios
nuevos del repositorio en sus ficheros locales, en cuyo caso sí puede
resultarle útil indicar los ficheros en concreto que desea actualizar.

El mismo principio puede aplicarse a otros comandos de CVS. Por ejemplo,
con diff, puede ver los cambios habidos en un fichero cada vez:

     floss$ cvs diff -c b-subdir/random.c
     Index: b-subdir/random.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
     retrieving revision 1.1.1.1
     diff -c -r1.1.1.1 random.c
     *** b-subdir/random.c   1999/04/18 18:18:22     1.1.1.1
     --- b-subdir/random.c   1999/04/19 06:09:48
     ***************
     *** 1 ****
     ! /* Un fichero en C completamente vacío. */
     --- 1,8 --
     ! /* Imprimir un número aleatorio. */
     !
     ! #include <stdio.h>
     !
     ! void main ()
     ! {
     !   printf ("un número aleatorio\n");
     ! }

o ver todos los cambios de una sola vez (agárrese al asiento, esto va a
ser un diff bastante grande):

     floss$ cvs -Q diff -c
     Index: hello.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.1.1.1
     diff -c -r1.1.1.1 hello.c
     *** hello.c     1999/04/18 18:18:22     1.1.1.1
     --- hello.c     1999/04/19 02:17:07
     ***************
     *** 4,7 ****
     --- 4,8 --
       main ()
       {
         printf ("¡Hola, mundo!\n");
     +   printf ("¡Adiós, mundo!\n");
       }
     Index: a-subdir/subsubdir/fish.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v
     retrieving revision 1.1.1.1
     diff -c -r1.1.1.1 fish.c
     *** a-subdir/subsubdir/fish.c   1999/04/18 18:18:22     1.1.1.1
     --- a-subdir/subsubdir/fish.c   1999/04/19 06:08:50
     ***************
     *** 1 ****
     ! /* Un fichero en C completamente vacío. */
     --- 1,8 --
     ! #include <stdio.h>
     !
     ! void main ()
     ! {
     !   while (1) {
     !     printf ("fish\n");
     !   }
     ! }
     Index: b-subdir/random.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
     retrieving revision 1.1.1.1
     diff -c -r1.1.1.1 random.c
     *** b-subdir/random.c   1999/04/18 18:18:22     1.1.1.1
     --- b-subdir/random.c   1999/04/19 06:09:48
     ***************
     *** 1 ****
     ! /* Un fichero en C completamente vacío. */
     --- 1,8 --
     ! /* Imprimir un número aleatorio. */
     !
     ! #include <stdio.h>
     !
     ! void main ()
     ! {
     !   printf ("un número aleatorio\n");
     ! }

En cualquier caso, como puede ver en estos diffs, queda claro que el
proyecto está listo para debutar. Enviemos los cambios al repositorio.


File: cvsbook.info,  Node: Enviar cambios al repositorio,  Next: Números de revisión,  Prev: CVS y argumentos implícitos,  Up: Un día con CVS

Enviar cambios al repositorio
-----------------------------

El comando "commit" envía las modificaciones al repositorio. Si no
indica ningún fichero, el comando enviará todos los cambios al
repositorio; sin embargo, si así lo prefiere, puede indicarle el nombre
de uno o más ficheros concretos a enviar, en cuyo caso el resto de los
ficheros serán ignorados.

Aquí enviamos un fichero nombrándolo expresamente, y otros dos por
alusiones:

     floss$ cvs commit -m "ahora también dice adiós" hello.c
     Checking in hello.c;
     /usr/local/cvs/miproyecto/hello.c,v  <--  hello.c
     new revision: 1.2; previous revision: 1.1
     done
     floss$ cvs commit -m "añadido código C"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in a-subdir/subsubdir/fish.c;
     /usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v  <--  fish.c
     new revision: 1.2; previous revision: 1.1
     done
     Checking in b-subdir/random.c;
     /usr/local/cvs/miproyecto/b-subdir/random.c,v  <--  random.c
     new revision: 1.2; previous revision: 1.1
     done
     floss$

Deténgase un momento a leer la salida detenidamente. La mayor parte de
lo que dice se explica por sí solo. Una cosa de la que tal vez se dé
cuenta es que los números de revisión se han incrementado (como era de
esperar), pero las revisiones originales se listan como 1.1 en lugar de
1.1.1.1 como vimos anteriormente para el caso del fichero Entries.

Hay una explicación para esta discrepancia, pero no es muy importante,
y tiene que ver con un significado especial que CVS da a la revisión
1.1.1.1: en la mayor parte de los casos, podemos decir simplemente que
los ficheros reciben un número de revisión 1.1 al hacer una importación,
pero, -por motivos que sólo CVS conoce- el número aparece como 1.1.1.1
en el fichero Entries hasta que el fichero es enviado al repositorio
por primera vez.


File: cvsbook.info,  Node: Números de revisión,  Next: Detección y resolución de conflictos,  Prev: Enviar cambios al repositorio,  Up: Un día con CVS

Números de revisión
-------------------

Cada fichero en un proyecto tiene su propio número de revisión. Cuando
un fichero es enviado al repositorio, la última parte del número de
revisión se incrementa en una unidad. Por tanto, los diferentes
ficheros que forman parte de un proyecto pueden tener siempre números
de revisión (a veces muy) diferentes. Esto sólo significa que algunos
ficheros han sido modificados (e incorporados en el repositorio) con
más frecuencia que otros.

En este momento quizás se pregunte qué sentido tiene la parte situada a
la izquierda del punto decimal, cuando la única parte que cambia es la
situada a la derecha. Pues bien, a pesar de que CVS nunca incrementa
automáticamente el número situado a la izquierda, este número puede ser
incrementado a petición del usuario. Esto es algo que se usa en muy
contadas ocasiones, y no lo cubriremos en esta guía.

Volviendo al tema, en el proyecto de ejemplo que hemos estado usando,
acabábamos de enviar al repositorio los cambios que habíamos realizado
en tres ficheros. Cada uno de estos ficheros es ahora la revisión 1.2,
pero el resto de ficheros del proyecto son aún la revisión 1.1. Cuando
usted solicita al repositorio una copia de un proyecto, siempre obtiene
la última revisión de cada fichero allí presente. Esto es lo que el
usuario mperez vería si ahora mismo solicitase una copia de miproyecto
y observase los números de revisión del directorio raíz:

     paste$ cvs -q -d :pserver:mperez@cvs.foobar.com:/usr/local/cvs co miproyecto
     U miproyecto/README.txt
     U miproyecto/hello.c
     U miproyecto/a-subdir/loquesea.c
     U miproyecto/a-subdir/subsubdir/fish.c
     U miproyecto/b-subdir/random.c
     paste$ cd miproyecto/CVS
     paste$ cat Entries
     /README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//
     /hello.c/1.2/Mon Apr 19 06:35:15 1999//
     D/a-subdir////
     D/b-subdir////
     paste$

El fichero hello.c (entre otros) se encuentra ahora en su revisión 1.2,
mientras que el fichero README.txt está aún en la revisión inicial
(1.1.1.1, también conocida como 1.1).

Si mperez añade ahora la línea

     printf ("entre hola y adiós\n");

a hello.c y lo envía, el número de revisión del fichero se incrementará
una vez más:

     paste$ cvs ci -m "añadida una nueva línea entremedias"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in hello.c;
     /usr/local/cvs/miproyecto/hello.c,v  <--  hello.c
     new revision: 1.3; previous revision: 1.2
     done
     paste$

Ahora hello.c está en la revisión 1.3, fish.c y random.c están aún en
la revisión 1.2, y los demás ficheros en la revisión 1.1.

Observe que el comando fue dado como cvs ci en lugar de cvs commit.  La
mayor parte de los comandos CVS tienen una forma abreviada, para hacer
más fácil el escribirlos. Para checkout, update y commit, las versiones
abreviadas son co, up y ci, respectivamente. Puede obtener una lista de
todas las formas abreviadas ejecutando el comando `cvs --help-synonyms'.

Normalmente puede ignorar el número de revisión de un fichero. En la
mayoría de los casos, estos números son simplemente anotaciones
internas que CVS gestiona automáticamente. Sin embargo, ser capaz de
encontrar y comparar números de revisión es algo muy útil cuando tiene
que obtener (o establecer diferencias respeto a) una copia antigua del
fichero.

Examinar el fichero Entries no es la única forma de descubrir un número
de revisión. Puede usar también el comando status:

     paste$ cvs status hello.c
     ===================================================================
     File: hello.c           Status: Up-to-date
     
        Working revision:    1.3     Tue Apr 20 02:34:42 1999
        Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:          (none)
        Sticky Date:         (none)
        Sticky Options:      (none)

el cual, cuando se invoca sin nombrar ningún fichero, muestra el estado
de todos los ficheros que conforman el proyecto:

     paste$ cvs status
     cvs status: Examining.
     ===================================================================
     File: README.txt        Status: Up-to-date
     
        Working revision:    1.1.1.1 Sun Apr 18 18:18:22 1999
        Repository revision: 1.1.1.1 /usr/local/cvs/miproyecto/README.txt,v
        Sticky Tag:          (none)
        Sticky Date:         (none)
        Sticky Options:      (none)
     
     ===================================================================
     File: hello.c           Status: Up-to-date
     
        Working revision:    1.3     Tue Apr 20 02:34:42 1999
        Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:          (none)
        Sticky Date:         (none)
        Sticky Options:      (none)
     
     cvs status: Examining a-subdir
     ===================================================================
     File: loquesea.c        Status: Up-to-date
     
        Working revision:    1.1.1.1 Sun Apr 18 18:18:22 1999
        Repository revision: 1.1.1.1 /usr/local/cvs/miproyecto/a-subdir/loquesea.c,v
        Sticky Tag:          (none)
        Sticky Date:         (none)
        Sticky Options:      (none)
     
     cvs status: Examining a-subdir/subsubdir
     ===================================================================
     File: fish.c            Status: Up-to-date
     
        Working revision:    1.2     Mon Apr 19 06:35:27 1999
        Repository revision: 1.2     /usr/local/cvs/miproyecto/
                                     a-subdir/subsubdir/fish.c,v
        Sticky Tag:          (none)
        Sticky Date:         (none)
        Sticky Options:      (none)
     
     cvs status: Examining b-subdir
     ===================================================================
     File: random.c          Status: Up-to-date
     
        Working revision:    1.2     Mon Apr 19 06:35:27 1999
        Repository revision: 1.2     /usr/local/cvs/miproyecto/b-subdir/random.c,v
        Sticky Tag:          (none)
        Sticky Date:         (none)
        Sticky Options:      (none)
     
     paste$

Limítese a ignorar las partes de la salida que no entienda; de hecho,
éste es por regla general un buen consejo al utilizar CVS. A menudo, el
pequeño trozo de información que está buscando vendrá acompañado de
otra mucha información que no le interesa, y que quizás ni siquiera
comprenda. Esta situación es normal; simplemente tome lo que necesite y
olvídese de todo lo demás.

En el ejemplo anterior, las partes que nos interesan son las primeras
tres líneas (sin contar la línea en blanco) de la información de estado
de cada fichero. La primera línea es la más importante, puesto que le
dice el nombre del fichero y su estado en la copia de trabajo. Todos
los ficheros están en este momento sincronizados con el repositorio,
así que todos dicen `Up-to-date'. Sin embargo, si random.c hubiera sido
modificado y el cambio no se hubiese enviado al repositorio, podríamos
encontrarnos algo como esto:

     ===================================================================
     File: random.c          Status: Locally Modified
     
        Working revision:    1.2     Mon Apr 19 06:35:27 1999
        Repository revision: 1.2     /usr/local/cvs/miproyecto/b-subdir/random.c,v
        Sticky Tag:          (none)
        Sticky Date:         (none)
        Sticky Options:      (none)

Los números de revisión de la copia de trabajo y de la copia presente
en el repositorio le informan de si el fichero está o no sincronizado
con la copia que hay en el repositorio. Volviendo a nuestra copia de
trabajo original (la copia de jluis, que no ha visto todavía el cambio
habido en hello.c), vemos lo siguiente:

     floss$ cvs status hello.c
     ===================================================================
     File: hello.c           Status: Needs Patch
     
        Working revision:    1.2     Mon Apr 19 02:17:07 1999
        Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:          (none)
        Sticky Date:         (none)
        Sticky Options:      (none)
     
     floss$

Esto nos dice que alguien ha efectuado cambios en hello.c, elevando a
1.3 el número de revisión de la copia que hay en el repositorio, y que
esta copia de trabajo está aún en la revisión 1.2. La línea "Status:
Needs Patch" significa que la siguiente actualización traerá los
cambios del repositorio y los aplicará a la copia de trabajo del
fichero.

Supongamos por un momento que ignoramos completamente el cambio que
mperez ha hecho a hello.c, así que no utilizamos status ni update, sino
que simplemente procedemos a editar nuestro fichero local, realizando un
cambio ligeramente distinto en el mismo punto del fichero. Esto nos
lleva a nuestro primer conflicto.


File: cvsbook.info,  Node: Detección y resolución de conflictos,  Next: Averiguar quién hizo qué (leyendo informes de cambios),  Prev: Números de revisión,  Up: Un día con CVS

Detección y resolución de conflictos
------------------------------------

Detectar un conflicto es bastante sencillo. Al invocar una
actualización, CVS le dice, bien a las claras, que existe un conflicto.
Pero primero, creemos el conflicto en sí: editemos el fichero hello.c
para insertar la línea

     printf ("este cambio generará un conflicto\n");

exactamente donde mperez introdujo esto:

     printf ("entre hola y adiós\n");

En este momento, el estado de nuestra copia de hello.c es

     floss$ cvs status hello.c
     ===================================================================
     File: hello.c           Status: Needs Merge
     
        Working revision:    1.2     Mon Apr 19 02:17:07 1999
        Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:          (none)
        Sticky Date:         (none)
        Sticky Options:      (none)
     
     floss$

lo que significa que ha habido cambios tanto en la copia del repositorio
como en nuestra copia de trabajo, y que estos cambios necesitan ser
fusionados (CVS no es aún consciente de que los cambios entrarán en
conflicto, porque aún no hemos intentado hacer una actualización).
Cuando hagamos una actualización, veremos esto:

     floss$ cvs update hello.c
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.2
     retrieving revision 1.3
     Merging differences between 1.2 and 1.3 into hello.c
     rcsmerge: warning: conflicts during merge
     cvs update: conflicts found in hello.c
     C hello.c
     floss$

La última línea es la clave. La "C" situada a la izquierda del nombre
del fichero indica que los cambios han sido fusionados [en nuestra
copia de trabajo], pero que entran en conflicto. El contenido de
hello.c muestra ahora ambos cambios:

     #include <stdio.h>
     
     void
     main ()
     {
       printf ("¡Hola, mundo!\n");
     <<<<<<< hello.c
       printf ("este cambio generará un conflicto\n");
     =======
       printf ("entre hola y adiós\n");
     >>>>>>> 1.3
       printf ("¡Adiós, mundo!\n");
     }

Los conflictos siempre se muestran delimitados por marcadores de
conflicto, en el siguiente formato:

     <<<<<<< (nombre de fichero)
       (cambios en la copia de trabajo, todavía no enviados al repositorio)
       blah blah blah
     =======
       (cambios procedentes del repositorio)
       blah blah blah
       etc.
     >>>>>>> (último número de revisión en el repositorio)

El fichero Entries también muestra que el fichero se encuentra en este
momento en un estado intermedio:

     floss$ cat CVS/Entries
     /README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//
     D/a-subdir////
     D/b-subdir////
     /hello.c/1.3/Result of merge+Tue Apr 20 03:59:09 1999//
     floss$

La manera de resolver el conflicto es editar el fichero de forma que
tenga el texto que resulte apropiado, eliminando de paso los marcadores
de conflicto, y después enviarlo al repositorio. Esto no significa
necesariamente elegir entre uno o otro cambio; podría decidir que
ninguno de los dos cambios es satisfactorio y reescribir la sección
donde aparece el conflicto, o incluso el fichero al completo. En este
caso, vamos a favorecer el primero de los cambios, pero con una
puntuación y uso de las mayúsculas ligeramente distintos de los
empleados por mperez:

     floss$ emacs hello.c
       (editamos el fichero...)
     floss$ cat hello.c
     #include <stdio.h>
     
     void
     main ()
     {
       printf ("¡Hola, mundo!\n");
       printf ("ENTRE HOLA Y ADIÓS.\n");
       printf ("¡Adiós, mundo!\n");
     }
     floss$ cvs ci -m "alterada la línea del medio"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in hello.c;
     /usr/local/cvs/miproyecto/hello.c,v  <-  hello.c
     new revision: 1.4; previous revision: 1.3
     done
     floss$


File: cvsbook.info,  Node: Averiguar quién hizo qué (leyendo informes de cambios),  Next: Examinar y deshacer cambios,  Prev: Detección y resolución de conflictos,  Up: Un día con CVS

Averiguar quién hizo qué (leyendo informes de cambios)
------------------------------------------------------

A estas alturas, el proyecto ha pasado ya por varios cambios. Si está
intentado hacerse una idea de lo sucedido hasta el momento, no querrá
necesariamente examinar con detalle cada fichero de diferencias.
Examinar los informes de cambios sería lo ideal, y puede hacerlo con el
comando log:

     floss$ cvs log
     (páginas y páginas de salida omitidas)

La salida del comando tiende a ser bastante detallada. Veamos los
informes de cambios para un único fichero:

     floss$ cvs log hello.c
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     Working file: hello.c
     head: 1.4
     branch:
     locks: strict
     access list:
     symbolic names:
             start: 1.1.1.1
             jluis: 1.1.1
     keyword substitution: kv
     total revisions: 5;     selected revisions: 5
     description:
     --------------
     revision 1.4
     date: 1999/04/20 04:14:37;  author: jluis;  state: Exp;  lines: +1 -1
     alterada la línea del medio
     --------------
     revision 1.3
     date: 1999/04/20 02:30:05;  author: mperez;  state: Exp;  lines: +1 -0
     añadida una nueva línea entremedias
     --------------
     revision 1.2
     date: 1999/04/19 06:35:15;  author: jluis;  state: Exp;  lines: +1 -0
     ahora también dice adiós
     --------------
     revision 1.1
     date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;
     branches:  1.1.1;
     Revisión inicial
     --------------
     revision 1.1.1.1
     date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;  lines: +0 -0
     Importación inicial en CVS
     =========================================================================
     floss$

Como es habitual, hay mucha información al comienzo que puede
simplemente ignorar. La parte que nos interesa viene después de cada
línea de guiones, en un formato que se explica por sí solo.

Cuando se envían muchos ficheros a la vez al repositorio, todos tienen
un mismo informe de cambios, algo que puede ser útil para seguir los
cambios.  Por ejemplo, ¿recuerda cuando enviamos fish.c y random.c a la
vez? Se hizo de esta forma:

     floss$ cvs commit -m "añadido código C"
     Checking in a-subdir/subsubdir/fish.c;
     /usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v  <-  fish.c
     new revision: 1.2; previous revision: 1.1
     done
     Checking in b-subdir/random.c;
     /usr/local/cvs/miproyecto/b-subdir/random.c,v  <-  random.c
     new revision: 1.2; previous revision: 1.1
     done
     floss$

El resultado de esta operación fue el envío de ambos ficheros con un
mismo informe de cambios: "añadido código C". Se da el caso de que ambos
ficheros empezaban en la revisión 1.1 y pasaron a la 1.2, pero esto es
sólo una coincidencia; si random.c estuviera en la revisión 1.29,
habría pasado a la 1.30 tras concluir este envío, y la revisión 1.30
tendría el mismo informe de cambios que la revisión 1.2 de fish.c.

Al utilizar cvs log con estos ficheros, verá el informe que ambos
comparten:

     floss$ cvs log a-subdir/subsubdir/fish.c b-subdir/random.c
     
     RCS file: /usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v
     Working file: a-subdir/subsubdir/fish.c
     head: 1.2
     branch:
     locks: strict
     access list:
     symbolic names:
             start: 1.1.1.1
             jluis: 1.1.1
     keyword substitution: kv
     total revisions: 3;     selected revisions: 3
     description:
     --------------
     revision 1.2
     date: 1999/04/19 06:35:27;  author: jluis;  state: Exp;  lines: +8 -1
     añadido código C
     --------------
     revision 1.1
     date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;
     branches:  1.1.1;
     Revisión inicial
     --------------
     revision 1.1.1.1
     date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;  lines: +0 -0
     Importación inicial en CVS
     =========================================================================
     RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
     Working file: b-subdir/random.c
     head: 1.2
     branch:
     locks: strict
     access list:
     symbolic names:
             start: 1.1.1.1
             jluis: 1.1.1
     keyword substitution: kv
     total revisions: 3;     selected revisions: 3
     description:
     --------------
     revision 1.2
     date: 1999/04/19 06:35:27;  author: jluis;  state: Exp;  lines: +8 -1
     añadido código C
     --------------
     revision 1.1
     date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;
     branches:  1.1.1;
     Revisión inicial
     --------------
     revision 1.1.1.1
     date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;  lines: +0 -0
     Importación inicial en CVS
     =========================================================================
     floss$

Por esta información sabrá que las dos revisiones fueron parte del mismo
envío (el hecho de que las fechas de las dos revisiones sean las mismas,
o muy próximas entre sí, es una prueba más).

Examinar los informes de cambios es una buena forma de hacerse
rápidamente una idea de lo que ha estado sucediendo en un proyecto o de
saber lo que pasó con un fichero específico en un momento determinado.
Existen también muchas herramientas libres diseñadas para convertir la
salida bruta de cvs log a formatos más concisos y legibles (por
ejemplo, al estilo ChangeLog de GNU); no cubriremos estas herramientas
en esta guía, pero serán presentadas en *Note Herramientas de
terceros::.


File: cvsbook.info,  Node: Examinar y deshacer cambios,  Next: El método lento de deshacer cosas,  Prev: Averiguar quién hizo qué (leyendo informes de cambios),  Up: Un día con CVS

Examinar y deshacer cambios
---------------------------

Supongamos que, mientras estamos leyendo los informes de cambios, mperez
se percata de que jluis hizo el cambio más reciente a hello.c:

     revision 1.4
     date: 1999/04/20 04:14:37;  author: jluis;  state: Exp;  lines: +1 -1
     alterada la línea del medio

y se pregunta qué hizo jluis exactamente. En términos formales, la
pregunta que se hace mperez es, "¿Cuál es la diferencia entre mi
revisión (1.3) de hello.c, y la revisión de jluis que vino a
continuación (1.4)?"  La forma de averiguarlo es utilizar el comando
diff, pero esta vez comparando las dos últimas revisiones utilizando la
opción de comando -r para especificar ambos números:

     paste$ cvs diff -c -r 1.3 -r 1.4 hello.c
     Index: hello.c
     ===========================================================
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.3
     retrieving revision 1.4
     diff -c -r1.3 -r1.4
     *** hello.c     1999/04/20 02:30:05     1.3
     --- hello.c     1999/04/20 04:14:37     1.4
     ***************
     *** 4,9 ****
       main ()
       {
         printf ("¡Hola, mundo!\n");
     !   printf ("entre hola y adiós\n");
         printf ("¡Adiós, mundo!\n");
       }
     --- 4,9 --
       main ()
       {
         printf ("¡Hola, mundo!\n");
     !   printf ("ENTRE HOLA Y ADIÓS.\n");
         printf ("¡Adiós, mundo!\n");
       }
     paste$

El cambio es bastante obvio, visto de esta forma. Dado que los números
de revisión se dan en orden cronológico (por lo general, una buena
idea), el comando los muestra de forma ordenada. Si sólo se da un
número de revisión, CVS utiliza como segundo número la revisión actual
del fichero presente en la copia de trabajo.

Cuando mperez ve estos cambios, decide al momento que le gusta más su
forma de hacer las cosas, así que decide "deshacerlo", esto es, ir una
revisión atrás.

Sin embargo, esto no significa que desee perder su revisión 1.4. Si bien
en un sentido estrictamente técnico es probablemente posible conseguir
este efecto en CVS, raramente existe razón alguna para hacerlo. Es mucho
más deseable guardar la revisión 1.4 en el historial y hacer una nueva
revisión 1.5 idéntica a la 1.3: de esta forma, la operación de deshacer
se convierte en parte del historial del fichero.

La única pregunta es, ¿cómo puede usted obtener el contenido de la
revisión 1.3 y ponerlo en la 1.5?

En este caso en particular, dado que el cambio es muy sencillo, mperez
puede seguramente limitarse a editar el fichero a mano para hacerlo
idéntico a la revisión 1.3, y entonces enviarlo al repositorio. Sin
embargo, si los cambios son más complejos (como suele ocurrir en un
proyecto real), intentar recrear a mano la revisión antigua será
irremediablemente algo donde se producirán errores. Por tanto, vamos a
hacer que mperez utilice CVS para obtener y reenviar el contenido de la
antigua revisión.

Hay dos formas igualmente buenas de conseguir esto: la lenta y dolorosa,
y la rápida y vistosa. Vamos a examinar primero la lenta y dolorosa.


File: cvsbook.info,  Node: El método lento de deshacer cosas,  Next: El método rápido de deshacer cosas,  Prev: Examinar y deshacer cambios,  Up: Un día con CVS

El método lento de deshacer cosas
---------------------------------

Este método utiliza la combinación de opciones -p y -r al hacer la
actualización. La opción -p envía el contenido de la revisión indicada a
la salida estándar.

De por sí, no es que esto sea algo terriblemente útil, dado que el
contenido del fichero desaparecerá rápidamente por la  ventana, dejando
intacta la copia de trabajo. Sin embargo, redirigiendo la salida
estándar al fichero, el fichero terminará recibiendo el contenido de la
antigua revisión. Sería lo mismo que haber editado el fichero a mano
para llevarlo a ese estado.

Primero, sin embargo, mperez necesita ponerse al día respecto al
repositorio:

     paste$ cvs update
     cvs update: Updating .
     U hello.c
     cvs update: Updating a-subdir
     cvs update: Updating a-subdir/subsubdir
     cvs update: Updating b-subdir
     paste$ cat hello.c
     #include <stdio.h>
     
     void
     main ()
     {
       printf ("¡Hola, mundo!\n");
       printf ("ENTRE HOLA Y ADIÓS.\n");
       printf ("¡Adiós, mundo!\n");
     }
     paste$

Lo siguiente que hace es emplear la opción -p al invocar la
actualización, para asegurarse de que la revisión 1.3 es justo la que
quiere:

     paste$ cvs update -p -r 1.3 hello.c
     ===================================================================
     Checking out hello.c
     RCS:  /usr/local/cvs/miproyecto/hello.c,v
     VERS: 1.3
     ***************
     #include <stdio.h>
     
     void
     main ()
     {
       printf ("¡Hola, mundo!\n");
       printf ("entre hola y adiós\n");
       printf ("¡Adiós, mundo!\n");
     }

Ooops, hay algunas líneas inútiles al comienzo. En realidad estas líneas
no se envían a la salida estándar sino al flujo de error estándar, así
que son inofensivas. Aún así, estas líneas hacen más difícil
interpretar la información, y pueden ser suprimidas con -Q:

     paste$ cvs -Q update -p -r 1.3 hello.c
     #include <stdio.h>
     
     void
     main ()
     {
       printf ("¡Hola, mundo!\n");
       printf ("entre hola y adiós\n");
       printf ("¡Adiós, mundo!\n");
     }
     paste$

Ahí estamos - esto es exactamente lo que mperez quería obtener. El
siguiente paso es poner ese contenido en el fichero de la copia de
trabajo, usando una redirección Unix (que es lo que hace el signo ">"):

     paste$ cvs -Q update -p -r 1.3 hello.c > hello.c
     paste$ cvs update
     cvs update: Updating .
     M hello.c
     cvs update: Updating a-subdir
     cvs update: Updating a-subdir/subsubdir
     cvs update: Updating b-subdir
     paste$

Al hacer ahora la actualización, el fichero aparece como modificado, lo
cual tiene sentido dado que su contenido ha cambiado. Específicamente,
tiene el mismo contenido que la antigua revisión 1.3 (no es que CVS se
dé cuenta de que es idéntica a la revisión antigua, tan sólo se da
cuenta de que se ha modificado). Si mperez quiere estar aún más seguro,
puede hacer un diff para comprobarlo:

     paste$ cvs -Q diff -c
     Index: hello.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.4
     diff -c -r1.4 hello.c
     *** hello.c     1999/04/20 04:14:37     1.4
     --- hello.c     1999/04/20 06:02:25
     ***************
     *** 4,9 ****
       main ()
       {
         printf ("¡Hola, mundo!\n");
     !   printf ("ENTRE HOLA Y ADIÓS.\n");
         printf ("¡Adiós, mundo!\n");
       }
     --- 4,9 --
       main ()
       {
         printf ("¡Hola, mundo!\n");
     !   printf ("entre hola y adiós\n");
         printf ("Adiós, mundo!\n");
       }
     paste$

Sí, esto es exactamente lo que él quería: una verdadera vuelta atrás.
De hecho, es lo contrario del diff que obtuvo previamente. Satisfecho,
lo envía:

     paste$ cvs ci -m "devuelto al código 1.3"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in hello.c;
     /usr/local/cvs/miproyecto/hello.c,v  <-  hello.c
     new revision: 1.5; previous revision: 1.4
     done
     paste$


File: cvsbook.info,  Node: El método rápido de deshacer cosas,  Prev: El método lento de deshacer cosas,  Up: Un día con CVS

El método rápido de deshacer cosas
----------------------------------

La forma rápida y vistosa de deshacer es usar la opción -j (de "juntar")
al comando de actualización. Esta opción es similar a -r en el sentido
de que utiliza un número de revisión, y de que puede usar hasta dos -j
a la vez. CVS calcula la diferencia entre las dos revisiones nombradas y
aplica esta diferencia como un parche al fichero en cuestión (con lo
cual, será de vital importancia el orden en el que indique estas
revisiones al comando).

Así pues, asumiendo que la copia de mperez está al día, puede hacer
simplemente lo siguiente:

     paste$ cvs update -j 1.4 -j 1.3 hello.c
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.4
     retrieving revision 1.3
     Merging differences between 1.4 and 1.3 into hello.c
     paste$ cvs update
     cvs update: Updating .
     M hello.c
     cvs update: Updating a-subdir
     cvs update: Updating a-subdir/subsubdir
     cvs update: Updating b-subdir
     paste$ cvs ci -m "devuelto al código 1.3" hello.c
     Checking in hello.c;
     /usr/local/cvs/miproyecto/hello.c,v  <--  hello.c
     new revision: 1.5; previous revision: 1.4
     done
     paste$

Cuando sólo es necesario deshacer los cambios habidos en un único
fichero, no hay realmente mucha diferencia entre el método lento y el
rápido. Más adelante, veremos como el método rápido es mucho mejor para
deshacer múltiples ficheros al mismo tiempo. De momento, utilice
simplemente el método que le resulte más cómodo.

Deshacer no es un sustituto para la comunicación
================================================

Con toda probabilidad, lo que mperez hizo en nuestro ejemplo fue
bastante desconsiderado por su parte. Al trabajar en un proyecto real
con otras personas, si se considera que alguien ha hecho un cambio poco
deseable, lo primero que debería hacerse es discutir el tema con esa
persona. Quizás haya una buena razón detrás del cambio, o puede que esa
persona no lo haya meditado lo suficiente antes de incorporarlo al
repositorio. Sea como fuere, no hay motivo alguno para precipitarse a
deshacerlo. CVS guarda un registro completo de todo lo que va
sucediendo, así que siempre puede deshacer los cambios hasta una
revisión previa después de consultar con la persona que hizo esos
cambios.

Si es Ud. el responsable máximo de un proyecto y tiene una fecha límite
para entregarlo, o si considera que tiene todo el derecho -y la
necesidad- de deshacer inmediatamente el cambio sin más dilación,
entonces adelante, pero lo siguiente que debería hacer es contactar con
el autor de los cambios que ha deshecho, explicándole sus motivos y qué
hay que hacer para volver a enviar el cambio.


File: cvsbook.info,  Node: Otros comandos útiles de CVS,  Next: Ramas,  Prev: Un día con CVS,  Up: Una introduccion a CVS

Otros comandos útiles de CVS
============================

Llegados a este punto, ya debería sentirse relativamente cómodo con el
uso básico de CVS. Dejaré por tanto mi tono narrativo y docente para
presentar algunos comandos más que resultan útiles, esta vez de forma
más breve:

* Menu:

* Añadir ficheros::
* Añadir directorios::
* CVS y ficheros binarios::
* Eliminar ficheros::
* Eliminar directorios::
* Renombrar ficheros y directorios::
* Evitar la fatiga de las opciones::
* Obtener instantáneas (fechas y marcas)::
* Formatos de fecha permitidos::
* Marcar un momento en el tiempo (marcas)::


File: cvsbook.info,  Node: Añadir ficheros,  Next: Añadir directorios,  Up: Otros comandos útiles de CVS

Añadir ficheros
---------------

Añadir un fichero es un proceso de dos pasos: primero debe ejecutar el
comando add ("añadir") sobre él, y después enviarlo. El fichero no
aparecerá en el repositorio hasta que se haya realizado el envío:

     floss$ cvs add nuevofichero.c
     cvs add: scheduling file 'nuevofichero.c' for addition
     cvs add: use 'cvs commit' to add this file permanently
     floss$ cvs ci -m "añadido nuevofichero.c" nuevofichero.c
     RCS file: /usr/local/cvs/miproyecto/nuevofichero.c,v
     done
     Checking in nuevofichero.c;
     /usr/local/cvs/miproyecto/nuevofichero.c,v  <-  nuevofichero.c
     initial revision: 1.1
     done
     floss$

