@c ---------------------------------------------------------
@node CVS avanzado
@unnumbered CVS avanzado


Ahora que hemos cubierto los conceptos b@'asicos sobre el uso de CVS y la 
administraci@'on del repositorio, miraremos c@'omo CVS puede ser incorporado
dentro del proceso de desarrollo. El ciclo de funcionamiento de CVS --
obtener (@emph{checkout}), actualizar (@emph{update} entregar 
(@emph{commit}), actualizar, entregar, y as@'{@dotless{i}} sucesivamente -- fu@'e mostrado 
en los ejemplos @ref{Una introduccion a CVS}. Este cap@'{@dotless{i}}tulo ampl@'{@dotless{i}}a este ciclo 
y muestra como CVS puede ser usado para ayudar a los desarrolladores a 
comunicarse, dar res@'umenes del la actividad y la historia del proyecto, 
fusionar diferentes ramas de desarrollo y ejecutar tareas frecuentes 
autom@'aticamente. Algunas de las t@'ecnicas explicadas introducen nuevas 
@'ordenes, pero muchas simplemente indican otra forma mejorada de usar 
@'ordenes que ya se han visto.

@menu
* Alarmas (CVS como telefono)::
* Mensajes log y correos electr@'onicos a la entrega::
* Cambiar un mensaje log despu@'es de una entrega::
* Deshacerse de una copia de trabajo::
* Historial -- Un resumen de la actividad del repositorio::
* Anotaciones -- Sumario detallado de la actividad del proyecto::
* Anotaciones y ramificaciones::
* Usando expansi@'on de palabras::
* Salir del limbo (C@'omo trabajar con derivaciones y sobrevivir)::
* Vigilando fuentes de terceras partes (Derivaciones comerciales)::
* Exportar para distribuci@'on p@'ublica::
* El humilde gur@'u::
@end menu

@c --------------------------------------------------------
@node Alarmas (CVS como telefono)
@section Alarma (CVS como telefono)

Un beneficio importante de usar CVS en un proyecto es que puede funcionar
tanto como un dispositivo de comunicaci@'on como para almacenar informaci@'on
sobreel proyecto. Esta secci@'on se centra en c@'omo se puede usar CVS para
que los participantes est@'en informados de lo que pasa en el projector. 
Como en otros aspectos de CVS, estas caracter@'{@dotless{i}}sticas fomentan la 
cooperaci@'on. Peros los participantes tienen que querer expresamente 
que se les informe; si la gente elige no usar estas car@'acteristicas de 
comunicaci@'on no hay nada que CVS puede hacer.

@menu
* C@'omo funcionan las alarmas::
* Habilitar alarmas en el repositorio::
* Usando alarmas durante el desarrollo::
* C@'omo acabar una sesi@'on de edici@'on::
* Controlar qu@'e acciones son vigiladas::
* Encontrar qui@'en vigila qu@'e::
* Recomendar a la gente usar alarmas::
* C@'omo aparecen las alarmas en el repositorio::
@end menu
 
@c -------------------------------------------------------------------
@node C@'omo funcionan las alarmas
@subsection C@'omo funcionan las alarmas

En su comportamiento por defecto CVS trata cada copia de trabajo como una
caja independiente. Nadie sabe lo que usted est@'a haciendo hasta que 
entrega sus cambios. As@'{@dotless{i}} mismo usted no sabe lo que los dem@'as est@'an 
haciendo en las suyas; excepto a trav@'es de los m@'etodos normales de 
comunicaci@'on, por ejemplo pegando una voz en la oficina: -¡Oye, voy 
a trabajar en el fichero.c ahora. Decidme si algui@'en est@'a trabajando 
en @'el para no tener conflictos!

Este m@'etodo informal funciona en proyectos donde la gente sabe m@'as o 
menos qui@'en es responsable de qu@'e. Sin embargo, es m@'as dificil cuando 
hay un gran n@'umero de desarrolladores activos en todas las partes del 
c@'odigo base y quieren evitarse los  conflictos. En estos casos, 
frecuentemente se pasa al @'area de responsabilidad de otro compa@~nero y
no se puede estar gritando en la oficina ya que el lugar de trabajo 
es geogr@'aficamente disperso.

Una caracter@'{@dotless{i}}stica de CVS llamada @code{alarma} proporciona un modo de 
avisarse entre ellos qui@'en est@'a trabajando en que fichero en un 
momento dado. Si alguien establece una alarma en un fichero puede ser
advertido cuando otro desarrollador empieze a trabajar es ese fichero. 
La advertencia se env@'{@dotless{i}}a normalmente por medio de correo electr@'onico  
pero es posible usar otros m@'etodos.

Para usar alarmas, hay que modificar uno @'o dos ficheros del @'area de 
admistraci@'on del repositorio, y los desarrolladores tienen que hacer un 
paso extra en el ciclo ususal de obtenci@'on/actualizaci@'on/entrega. Los 
cambios en el repositorio son bastante simples: Necesita editar el 
fichero @file{CVSROOT/notify} para que CVS sepa que advertencias debe 
realizar. Tambi@'en hay que a@~nadir algunas l@'{@dotless{i}}neas al fichero
 @file{CVSROOT/users}, que aporta direcciones externas de correo 
electr@'onico.

En la copia de trabajo los desarrolladores tienen que decir al CVS qu@'e 
ficheros debe vigilar para que CVS informe cuando algui@'en va a editar 
alguno de esos ficheros. Adem@'as uno tiene que decirle a CVS cuando empieza
o termina de editar un fichero para que CVS a su vez lo indique a otros 
desarrolladores que podr@'{@dotless{i}}an estar vigilando. Las siguientes @'ordenes son 
usadas para estos pasos extra.

@itemize 
@item cvs watch
@item cvs edit
@item cvs unedit
@end itemize

El patr@'on de la orden @code{watch} se diferencia de otras @'ordenes comunes 
en que utiliza sub@'ordenes, como por ejemplo @w{@code{cvs watch add...}}, 
@w{@code{cvs watch remove...}}, y as@'{@dotless{i}}.

En el siguiente ejemplo vamos a ver c@'omo se establecen las alarmas en el 
repositorio y c@'omo se usan desde el @'area del desarrollador. Los dos 
usuarios de ejemplo, jrandom y qsmith, tienen su propia copia de trabajo 
que puede estar en diferentes m@'aquinas. Seguimos asumiendo que la 
variable de entorno $CVSROOT est@'a asignada y por ello no tenemos que 
pasar la opci@'on -d <REPOS> a ning@'un comando CVS.

@c ----------------------------------------------------------
@node Habilitar alarmas en el repositorio
@subsection Habilitar alarmas en el repositorio

Primero se debe activar la notificaci@'on mediante correo electr@'onico 
editando el fichero CVSROOT/notify. Uno de los dos desarrolladores debe 
hacer esto o el administrador del repositorio si los desarrolladores no 
tienen permiso para cambiar los ficheros administrativos del repositorio.
En cualquier caso la primera cosa es obtener el @'area administrativa y 
editar el fichero notify:

@example
floss$ cvs -q co CVSROOT 
U CVSROOT/checkoutlist 
U CVSROOT/commitinfo 
U CVSROOT/config 
U CVSROOT/cvswrappers 
U CVSROOT/editinfo 
U CVSROOT/loginfo 
U CVSROOT/modules 
U CVSROOT/notify 
U CVSROOT/rcsinfo 
U CVSROOT/taginfo 
U CVSROOT/verifymsg 
floss$ cd CVSROOT
floss$ emacs notify 
... 
@end example

Cuando se edita el fichero notify por primera vez nos encontramos con 
algo como esto:

@example
# Versi@'on en castellano
# El fichero 'notify' especifica donde van se env@'{@dotless{i}}an las notificaciones 
# procedentes de alarmas establecidas mediante "cvs watch add" @'o "cvs 
# edit". La primera entrada de una l@'{@dotless{i}}nea es una expresi@'on regular que se
# compara con el directorio donde el cambio se est@'a haciendo relativo a
# $CVSROOT. Si coincide el resto de la l@'{@dotless{i}}nea es un programa filtro que 
# deber@'{@dotless{i}}a contener una ocurrencia %s que indica el usuario a notificar, e 
# informcaci@'on de su entrada de datos est@'andar.  
# 
# "ALL" o "DEFAULT" puede ser usada en lugar de la expresi@'on regular.
# 
# Por ejemplo:
# ALL mail %s -s "notificaci@'on de CVS"
@end example

En realidad todo lo que hay que hacer es descomentar la @'ultima l@'{@dotless{i}}nea 
quitando el car@'acter @code{#}. Aunque @code{notify} proporciana la misma 
flexibilidad que otros ficheros administrativos a trav@'es de las 
expresiones regulares normalmente no se va usar. La @'unica raz@'on de 
tener m@'ultiples lineas, cada una con un expresi@'on regular para cada 
parte del repositorio es si se van usar otros m@'etodos de notificaci@'on 
distintos para cada proyecto. Normalmente la mayor@'{@dotless{i}}a de los proyectos usan
correo electr@'onico ya que es un buen m@'etodo de notificaci@'on.  

Para especificar la notificaci@'on mediante correo electr@'onico, la l@'{@dotless{i}}nea

@example
ALL mail %s -s "notificaci@'on de CVS"
@end example

deber@'{@dotless{i}}a funcionar en cualquier Unix est@'andar. @'Este comando hace que las
notificaciones o avisos sean enviadas mediante correo electr@'onico 
con la l@'{@dotless{i}}nea de @code{subject} @code{notificaci@'on de CVS} (La expresi@'on se 
compara contra cualquier directorio). Cuando se haya descomentado la 
l@'{@dotless{i}}nea hay que entregar el fichero notify para que el repositoria sea 
consciente del cambio:

@example
floss$ cvs ci -m "establecido notificaci@'on por alarma" 
cvs commit: Examining . 
Checking in notify; 
/usr/local/newrepos/CVSROOT/notify,v  <--  notify 
new revision: 1.2; previous revision: 1.1 
done 
cvs commit: Rebuilding administrative file database 
floss$  
@end example

Editar este fichero es todo lo que hay que hacer para establecer alarmas 
en el repositorio. Sin embargo si hay desarrolladores trabajando en 
m@'aquinas remotas es necesario editar el fichero @file{CVSROOT/users}
tambi@'en. La funci@'on de este fichero es indicar a CVS a qu@'e direcciones 
de correo enviar las notificaciones para los usuarios remotos.
El formato de cada l@'{@dotless{i}}nea del fichero users ser@'{@dotless{i}}a:

@example
CVS_USERNAME:EMAIL_ADDRESS 
@end example

Por ejemplo,

@example
qsmith:quentinsmith@@farawayplace.com 
@end example

El nombre de usuario al principio de la l@'{@dotless{i}}nea corresponde a un usuario 
de CVS del fichero @file{CVSROOT/password} (si est@'a presente y el 
m@'etodo de acceso por servidor est@'a siendo usado), o el usuario  
del servidor ejecutando CVS. Siguiendo los dos puntos viene la 
direcci@'on de correo de ese usuario a la que el CVS enviar@'a las 
notificaciones.

Desgraciadamente en el momento de la escritura de este documeto el 
fichero users no existe en la distribuci@'on est@'andar de CVS. Debido a que
es un fichero administrativo no s@'olo se debe crearlo, a@~nadirlo 
@code{cvs add ...} y entregarlo @code{commit ...} de la forma usual sino que
hay que a@~nadirlo al fichero @file{CVSROOT/checkoutlist} para que una
copia sea mantenida en el repositorio.

Lo siguiente es una sesi@'on de ejemplo:

@example
floss$ emacs checkoutlist 
  ... (a@~nade la l@'{@dotless{i}}nea para el fichero users) ... 
floss$ emacs users 
  ... (a@~nade la l@'{@dotless{i}}nea para el usuario qsmith) ... 
floss$ cvs add users 
floss$ cvs ci -m "a@~nade users a checkoutlist, qsmith a users" 
cvs commit: Examining . 
Checking in checkoutlist; 
/usr/local/newrepos/CVSROOT/checkoutlist,v  <--  checkoutlist 
new revision: 1.2; previous revision: 1.1 
done 
Checking in users; 
/usr/local/newrepos/CVSROOT/users,v  <--  users 
new revision: 1.2; previous revision: 1.1 
done 
cvs commit: Rebuilding administrative file database 
floss$  
@end example

Es posible usar direcciones de correo de formato expandido en 
@file{CVSROOT/usres}, pero hay que tener cuidado en poner todos los 
espacios en blanco entre comillas. Veamos el siguiente ejemplo

@example
qsmith:"Quentin Q. Smith <quentinsmith@@farawayplace.com>"
@end example

o

@example
qsmith:'Quentin Q. Smith <quentinsmith@@farawayplace.com>' 
@end example

Sin embargo, esto no funcionar@'a:

@example
qsmith:"Quentin Q. Smith" <quentinsmith@@farawayplace.com> 
@end example

Si hay dudas deber@'{@dotless{i}}a probar ejecutando la orden del fichero notify 
directamente reemplazando @code{%s} en  

@example
mail %s -s "CVS notification" 
@end example

por lo que sigue despu@'es de los dos puntos en el fichero users. 
Si funciona desde el prompt deber@'{@dotless{i}}a hacerlo tambi@'en en el fichero de 
usuarios.

Cuando est@'a terminado el fichero checkout deber@'{@dotless{i}}a aparecer como:

@example
# El fichero 'checkoutlist' se usa para soportar ficheros adicionales de 
# control de versi@'on administrativos de $CVSROOT/CVSROOT, como plantillas.
#
# La primera entrada de una l@'{@dotless{i}}nea es un nombre de fichero que ser@'a obtenido 
# del correspondiente RCS fichero del directorio $CVSROOT/CVSROOT.
# El resto de la l@'{@dotless{i}}nea ser@'a el mensaje de error que aparecer@'a si el fichero
# no se puede obtener. 
# 
# Formato del fichero: 
# 
#       [<espacio en blaco>]<nombre del fichero><espcio en blanco>
<mensaje de error><find de l@'{@dotless{i}}nea> 
# 
# l@'{@dotless{i}}neas de comentario enmpiezan con '#' 

users   No ha sido posible obtener @code{users} file in CVSROOT. 
@end example

Ya hemos visto como se prepara el repositorio para las alarmas. Pasemos
ahora a lo que los desarrolladores tienen que hacer en sus copias de trabajo.

@c --------------------------------------------------------------
@node Usando alarmas durante el desarrollo
@subsection Usando alarmas durante el desarrollo

Primero, un programador obtiene una copia de trabajo y se a@~nade a la 
lista de vigilantes para alguno de los ficheros del projecto:

@example
floss$ whoami 
jrandom 
floss$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
floss$ cd myproj 
floss$ cvs watch add hello.c 
floss$ 
@end example
 
La @'ultima orden, @code{cvs watch add hello.c}, indica a CVS que nofifique a 
jramdom si alguien empieza a trabajar en hello.c. O sea que a@~nade jrandom a
la lista de alarma de hello.c. Para que CVS pueda notificar tan pronto 
como sea posible que un fichero se va a editar el usuario tiene que 
indic@'arselo a CVS mediante la orden @code{cvs edit} y el nombre del fichero.
CVS no tiene otro modo de saber cuando alguien empieza a trabajar en un 
fichero. Una ver que se ha obtenido una copia, CVS no es normalmente 
invocado hasta la siguiente actualizaci@'on o entrega, la cual sucede despu@'es 
de que el fichero se haya editado:

@example
paste$ whoami 
qsmith 
paste$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
paste$ cd myproj 
paste$ cvs edit hello.c 
paste$ emacs hello.c 
... 
@end example

Cuando qsmith ejecuta @code{cvs edit hello.c}, CVS mira en la lista de alarma de 
hello.c, ve que jrandom est@'a en ella, y envia un correo a jrandom diciendole 
que qsmith ha empezado a editar el fichero. El fichero incluso parece haber 
llegado del mismo qsmith:


@example
From: qsmith 
Subject: CVS notification 
To: jrandom 
Date: Sat, 17 Jul 1999 22:14:43 -0500 

myproj hello.c 
--  
Triggered edit watch on /usr/local/newrepos/myproj 
By qsmith 

Adem@'as cada vez que qsmith (o cualquiera) entrega una nueva revisi@'on de 
hello.c, jrandon recivir@'a otro correo electr@'onico:


myproj hello.c 
-- 
Triggered commit watch on /usr/local/newrepos/myproj 
By qsmith 
@end example

Despu@'es de recibir estos correos, jrandom podr@'{@dotless{i}}a querer actualizar su 
copia de hello.c para ver qu@'e cambios qsmith ha hecho o quiz@'as quisiera 
enviar un correo a qsmith para saber porqu@'e est@'a trabajando en ese fichero.
Nada fuerza a qsmith a recordar hacer un @code{cvs edit}. Si lo hizo fu@'e 
porque quiz@'a querr@'{@dotless{i}}a hacerselo saber a jrandom. De cualquier forma, incluso si 
se olvida hacer un @code{cvs edit} al hacer una entrega se disparar@'a la 
notificaci@'on. La raz@'on de @code{cvs edit} es que los advierte a los vigilantes 
antes de que empizes a trabajar en el fichero y @'estos se pueden poner en 
contacto contigo para resolver el conflicto, antes de que hayas desperdiciado 
el tiempo.

CVS asume que cualquiera que hace un @code{cvs edit} quiere ser a@~nadido a la 
lista de alarma de ese fichero, al menos temporalmente, en caso de que alg@'un
otro tambi@'en lo edite. Cuando qsmith ejecuta @code{cvs edit}, se convierte
en un vigilante de hello.c. @'El y jrandom recivir@'{@dotless{i}}an un notificaci@'on si una 
tercera persona ejecutase @code{cvs edit} en ese fichero (@'o lo entregara).

Sin embargo, CVS tambi@'en asume que la persona que est@'a editando el fichero 
quiere estar en la lista mientras est@'a trabajando en @'el. Esos usuarios ser@'an 
borrados de la lista cuando hayan hecho su edici@'on del fichero. Si quieren 
ser vigilantes permanenetes deber@'an ejecutar @code{cvs watch add}.
CVS asume por defecto que algui@'en ha terminado la edici@'on cuando @'el @'o ella 
hace una entrega del fichero.

Cualquiera que est@'a en la lista de vigilancia de un fichero por haber 
ejecutado @w{@code{cvs edit}} en ese fichero es conocido como @dfn{temporary 
watcher} y es eliminado de la lista cuando entrege un cambio en el fichero. 
Si quiere editarlo de nuevo tendr@'{@dotless{i}}a que volver a ejecutar @w{@code{cvs 
edit}}.

La suposici@'on de que la primera entrega acaba la sesi@'on de edici@'on es 
s@'olamente una buena predicci@'on, ya que CVS no sabe cuantas entregas la 
persona necesitar@'a para hacer sus cambios. La predicci@'on es buena para 
@dfn{one-off} cambios -- cambios donde hay que arreglar un peque@~no error 
en un fichero y entregarlo. Para ediciones m@'as prolongadas que requieren 
varias entregas ser@'{@dotless{i}}a bueno que el usuarios se a@~nadiera permanentemente a 
la lista de vigilantes.

@example
paste$ cvs watch add hello.c 
paste$ cvs edit hello.c 
paste$ emacs hello.c 
... 
paste$ cvs commit -m "escrito hola en s@'anscrito" 
@end example

Incluso despu@'es de una entraga, qsmith quedar@'a como vigilante de hello.c
ya que ejecut@'o @code{watch add} sobre @'el. (A prop@'osito, qsmith no recibir@'a 
notificaciones sobre sus propios cambios; s@'olo los dem@'as. CVS es lo 
suficientemente listo para no advertirte sobre tus propias acciones.)


@c --------------------------------------------------------------
@node C@'omo acabar una sesi@'on de edici@'on
@subsection C@'omo acabar una sesi@'on de edici@'on 

Si no quieres hacer una entrega sino acabar tu sesi@'on de edici@'on 
explicitamente, se puede hacer ejecutando @code{cvs unedit}:

@example
paste$ cvs unedit hello.c 
@end example

Dese cuenta de que adem@'as de notificar a los dem@'as vigilantes que ha 
terminado esta orden ofrece la posibilidad de deshacer todos los cambios 
que haya hecho en el fichero.


@example
paste$ cvs unedit hello.c 
hello.c has been modified; revert changes? y 
paste$  
@end example

Si usted contesta @code{y}, CVS deshar@'a todos los cambios y notificar@'a 
a todos los vigilantes que no seguir@'a editando el fichero. Si responde 
@code{n}, CVS mantiene sus cambios  y seguir@'a registrado como uno de 
los editores del fichero. Por lo tanto no habr@'a nofificaci@'on; de hecho es
como si no hubiera ejecutado @w{@code{cvs unedit}}. Esta posibilidad es 
un poco tremenda, pero f@'acil de entender: si declara al mundo que ha 
terminado su sesi@'on de edici@'on cualquier cambio que no haya entregado 
antes es porque no ten@'{@dotless{i}}a intenci@'on de guardarlos. Al menos as@'{@dotless{i}} es como lo
ve CVS. No es necesario decir que tenga cuidado.

@c ---------------------------------------------------------------
@node Controlar qu@'e acciones son vigiladas
@subsection Controlar qu@'e acciones son vigiladas

Por defecto los vigilantes son noficados ante tres acciones: ediciones, 
entregas, y terminaci@'on de sesi@'on. Sin embargo si usted s@'olo quiere ser
notificado, por ejemplo en las entregas, puede restringir sus 
notificaciones con el indicador -a  de la orden watch (a  por action).



@example
floss$ cvs watch add -a commit hello.c
@end example

Es posible pasar el indicador -a dos veces si quiere ser advertido de 
entregas y notificaciones.

@example
floss$ cvs watch add -a edit -a commit hello.c 
@end example

A@~nadir alarmas con el indicador -a no causar@'a la eliminaci@'on de ninguna 
de sus existentes alarmas. Si estaba vigilando para las tres acciones 
sobre hello.c, el ejecutar

@example
floss$ cvs watch add -a commit hello.c 
@end example

no tiene efecto -- usted seguir@'a teniendo las tres acciones.
Para quitar las alarmas hay que hacer lo siguiente

@example
floss$ cvs watch remove hello.c 
@end example

Esta orden, por defecto quita las tres clases de acciones. Especificando
la acci@'on mediante -a se quitan s@'olo las alarmas que se especifiquen en 
la l@'{@dotless{i}}nea de @'ordenes:

@example
floss$ cvs watch remove -a commit hello.c 
@end example

Esto indica que usted desea dejear de recibir notificaciones sobre
entregas pero seguir@'a recibiendo notificaciones sobre ediciones y 
terminaci@'on de edici@'on (asumiendo que ten@'{@dotless{i}}a vigilancia para estas 
dos acciones).

Hay dos opciones que se pueden pasar al indicador -a: 
all @'o none (todas @'o niguna).
@emph{all} significa que las acciones que se vigilar@'an son las tres antes 
mencionadas y @emph{none} ninguna de ellas. 
Ya que el comportamiento por defecto de CVS sin el indicador -a es 
vigilar todas las acciones y si no se vigila ninguna es como
estar fuera de la lista de vigilancia es dificil imaginar una 
situaci@'on en la que que se usen estas dos opciones. Sin embargo, 
"cvs edit" tambi@'en usa lleva el indicador -a, y en esta caso puede
ser @'util especificar @emph{all} @'o @emph{none}. 
Por ejemplo, alguien que va a trabajar brevemente en un fichero quiz@'a 
no quiera ser notificado sobre lo que est@'an haciendo otros en ese 
fichero. La orden

@example
paste$ whoami 
qsmith 
paste$ cvs edit -a none README.txt 
@end example

hace que vigilantes de README.txt sean notificados de que qsmith va 
a trabajar en @'el, pero qsmith no ser@'a un vigilante temporal de 
README.txt durante su sesi@'on de edici@'on ya que pidi@'o explicitamente
no vigilar ninguna acci@'on.

Observe que esto s@'olo afecta a lo que usted est@'a vigilando con la
orden @code{cvs watch}. Usted puede dejar de vigilar cualquier fichero 
pero esto no afectar@'a a las alarmas de los dem@'as.

@c ------------------------------------------------------------------
@node Encontrar qui@'en vigila qu@'e
@subsection Encontrar qui@'en vigila qu@'e

Alguna vez puede interesarle saber quien est@'a vigilando o editando un 
fichero sin antes de ejecutar @code{cvs edit} o ver qui@'en est@'a editando qu@'e 
sin a@~nadirse a ninguna lista de vigilancia. O podr@'{@dotless{i}}a haber olvidado 
su propio estatus. Despu@'es de haber establecido algunas alarmas y haber 
entregado algunos ficheros es f@'acil saber que est@'a uno vigilando y
editando.

CVS proporciona dos comandos para mostrar qui@'en est@'a vigilando y editando 
qu@'e ficheros -- @code{cvs watchers} y @code{cvs editors}:

@example
floss$ whoami 
jrandom 
floss$ cvs watch add hello.c 
floss$ cvs watchers hello.c 
hello.c jrandom  edit unedit  commit 
floss$ cvs watch remove -a unedit hello.c 
floss$ cvs watchers hello.c 
hello.c jrandom  edit commit 
floss$ cvs watch add README.txt 
floss$ cvs watchers 
README.txt      jrandom edit    unedit  commit 
hello.c jrandom edit    commit 
floss$  
@end example

Observe que la @'ultima orden @code{cvs watchers} no especifica ning@'un 
fichero y as@'{@dotless{i}} muestra los vigilantes para todos los ficheros que 
est@'en siendo vigilados.

Todas las @'ordenes @code{watch} y @code{edit} tienen en com@'un con otras @'ordenes 
CVS esta caracter@'{@dotless{i}}stica. Si usted especifica nombres de ficheros estas 
@'ordenes actuan sobre ellos. Si se especifican nombres de directorio 
actuan sobre cada fichero de ese directorio y sus subdirectorios. Si no 
especifica nada, actuan sobre el directorio actual y sus subdirectorios. 
Siguiendo con la sesi@'on del ejemplo anterior:

@example
floss$ cvs watch add a-subdir/whatever.c  
floss$ cvs watchers 
README.txt      jrandom edit    unedit  commit 
hello.c jrandom edit    commit 
a-subdir/whatever.c     jrandom edit    unedit  commit 
floss$ cvs watch add 
floss$ cvs watchers 
README.txt      jrandom edit    unedit  commit 
foo.gif jrandom edit    unedit  commit 
hello.c jrandom edit    commit  unedit 
a-subdir/whatever.c     jrandom edit    unedit  commit 
a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit 
b-subdir/random.c       jrandom edit    unedit  commit 
floss$  
@end example

El pen@'ultimo comando hiz@'o a jrandom un vigilante de todos los ficheros 
del proyecto y el @'ultimo mostr@'o cada lista de cada fichero del proyecto.
La salida de @w{@code{cvs watchers}} puede que no perfectamente 
alineado por columnas debido a que se mezclan tabuladores con 
informaci@'on de longitud variable, pero el formateo de las l@'{@dotless{i}}neas es 
consistente.

@example
[FILENAME] [espacio en blanco] WATCHER [espacio en blanco] 
ACTIONS-BEING-WATCHED... 
@end example

Observe qu@'e pasa cuando qsmith empieza a editar uno de los ficheros:

@example
paste$ cvs edit hello.c 
paste$ cvs watchers 
README.txt      jrandom edit    unedit  commit 
foo.gif jrandom edit    unedit  commit 
hello.c jrandom edit    commit  unedit 
       qsmith  tedit   tunedit tcommit 
a-subdir/whatever.c     jrandom edit    unedit  commit 
a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit 
b-subdir/random.c       jrandom edit    unedit  commit 
@end example

El fichero hello.c tiene un nuevo vigilante: qsmith (observe que el 
nombre del fichero no se repite sino que se deja un espacio en blanco 
al principio de la l@'{@dotless{i}}nea; esto es importante si usted alguna vez 
escribiera un programa que compila la salida de la orden).
Ya que est@'a editando el fichero hello.c, qsmith tendr@'a una 
@dfn{temporary watch alarma temporal} sobre el fichero, la cual 
se terminar@'a cuando haga una entrega sobre @'este. 
El prefijo ð@code{t} delante de cada acci@'on indica que son 
alarmas termporales.
Si qsmith se a@~nade a la lista de vigilantes regulares de hello.c 

@example
paste$ cvs watch add hello.c 
README.txt      jrandom edit    unedit  commit 
foo.gif jrandom edit    unedit  commit 
hello.c jrandom edit    commit  unedit
       qsmith  tedit   tunedit tcommit edit    unedit  commit 
a-subdir/whatever.c     jrandom edit    unedit  commit 
a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit 
b-subdir/random.c       jrandom edit    unedit  commit 
@end example

se encontrar@'a a la vez como un vigilante temporal y un vigilante 
permanente. Se puede decir que el estatus de vigilante permanente 
sobrepasa al temporal. Entonces la l@'{@dotless{i}}nea ser@'{@dotless{i}}a como:

@example
        qsmith  edit    unedit  commit 
@end example

Sin embargo, CVS no puede reemplazar las alarmas temporales porque 
sabe que orden ocurren las acciones. ¿Se quitar@'a qsmith de la lista
permanente de vigilancia antes de acabar su sesi@'on de edici@'on?, o 
¿acabar@'a sus ediciones siendo todav@'{@dotless{i}}a un vigilante?. En el primer caso 
las acciones @code{edit / unedit / commit} desaparecen mientras que 
@code{tedit / tunedit / tcommit} permanecen; en el segundo caso ocurre 
lo contrario. De cualquier forma esto no ser@'a de gran importancia.
Casi siempre lo que usted har@'a es ejecutar

@example
floss$ cvs watchers 
@end example

o 

@example
floss$ cvs editors 
@end example

desde el nivel m@'as alto para ver qui@'en est@'a haciendo qu@'e. No necesita 
conocer los detalles de quien est@'a vigilando que acciones: lo 
importante son las personas y los ficheros.
@c ----------------------------------------------------
@node Recomendar a la gente usar alarmas
@subsection Recomendar a la gente usar alarmas

Habr@'a observado que el funcionamiento de las alarmas depende, en 
@'ultima instancia de la colaboraci@'on de todos los desarrolladores. 
Si alguien empieza a editar un fichero sin ejecutar @code{cvs edit}, 
nadie lo sabr@'a hasta que los cambios se entreguen. Como @code{cvs edit}
se usa a un nivel superior y no est@'a dentro de la rutina normal de 
desarrollo las personas pueden olvidarse f@'acilmente de hacerlo.

Aunque CVS no puede forzar a alguien a usar @code{cvs edit}, tiene un 
mecanismo que es permite a recordar a los usuarios a hacerlo; 
la orden @code{watch on}:

@example
floss$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
floss$ cd myproj 
floss$ cvs watch on hello.c 
floss$ 
@end example

Ejecutando @code{cvs watch} sobre hello.c, jrandom hace que futuras 
obtenciones de copias de myproj hagan que hello.c sea de s@'olo lectura en la 
copia de trabajo. Cuando qsmith intenta trabajar sobre @'el comprobar@'a 
que es de s@'olo lectura y se le recordar@'a que debe ejecutar primero 
@code{cvs edit}:

@example
paste$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
paste$ cd myproj 
paste$ ls -l 
total 6 
drwxr-xr-x   2 qsmith    users        1024 Jul 19 01:06 CVS/ 
-rw-r--r--   1 qsmith    users          38 Jul 12 11:28 README.txt 
drwxr-xr-x   4 qsmith    users        1024 Jul 19 01:06 a-subdir/ 
drwxr-xr-x   3 qsmith    users        1024 Jul 19 01:06 b-subdir/ 
-rw-r--r--   1 qsmith    users         673 Jun 20 22:47 foo.gif 
-r--r--r--   1 qsmith    users         188 Jul 18 01:20 hello.c 
paste$ 
@end example

Cuando lo ha hecho, el fichero ser@'a de lectura-escritura. Entonces lo 
podr@'a editar y cuando haga entregas, pasa a modo de s@'olo lectura:


@example
paste$ cvs edit hello.c 
paste$ ls -l hello.c 
-rw-r--r--   1 qsmith    users         188 Jul 18 01:20 hello.c 
paste$ emacs hello.c 
  ...  
paste$ cvs commit -m "decir hello en arameo" hello.c 
Checking in hello.c;  
/usr/local/newrepos/myproj/hello.c,v  <--  hello.c 
new revision: 1.12; previous revision: 1.11 
done 
paste$ ls -l hello.c 
-r--r--r--   1 qsmith    users         210 Jul 19 01:12 hello.c 
paste$  
@end example

Al hacer esta edici@'on y entrega se enviar@'an notificaciones a todos los 
vigilantes de hello.c. Observe que jranadom no es necesariamente uno de 
ellos. Al ejecutar @code{cvs watch} sobre hello.c jrandom no se a@~nadi@'o asimismo 
a la lista de vigilancia para ese fichero; simplemente especific@'o qe 
se deber@'{@dotless{i}}an obtener copias  en modo de s@'olo lectura. Las personas que quieren
vigilar un fichero deben a@~nadirse a la lista de vigilancia. CVS no puede
hacer nada sobre esto.

Establecer alarmas en un simple fichero ser@'{@dotless{i}}a la excepci@'on. Generalmente 
es m@'as com@'un establecer las alarmas sobre un proyecto:


@example
floss$ cvs -q co myproj 
U myproj/README.txt 
U myproj/foo.gif 
U myproj/hello.c 
U myproj/a-subdir/whatever.c 
U myproj/a-subdir/subsubdir/fish.c 
U myproj/b-subdir/random.c 
floss$ cd myproj 
floss$ cvs watch on 
floss$  
@end example

Esta acci@'on equivale a anunciar una potitica de decisi@'on para todo el 
proyecto: @emph{"Por favor, use cvs edit para advertir a los vigilantes en 
que est@'a trabajando y vigile cuantos ficheros le interesen o sean de su 
responsabilidad."} Cada fichero del proyecto ser@'a actualizado en modo
de s@'olo lectura, y as@'{@dotless{i}} a la gente se le recordar@'a que se espera que 
usen @code{cvs edit} antes de trabajar en algo.

Curiosamente, aunque obtenciones de copias de ficheros vigilados se hacen 
en modo de s@'olo lectura, las actualizaciones no lo son. Si qsmith ha 
obtenido una copia de trabajo antes de que jrandom hiciera @code{cvs watch} 
sus ficheros ser@'{@dotless{i}}an le lectura-escritura quedando as@'{@dotless{i}} incluso despu@'es de
hacer actualizaciones. Sin embargo, cualquier fichero que entregue 
despu@'es de que jrandom estableciera las alarmas ser@'a de s@'olo lectura. 
Si jrandom quita las alarmas:

@example
floss$ cvs watch off 
@end example

los ficheros de s@'olo lectura de qsmith no se convierte m@'agicamente en 
ficheros de lectura-escritura. Por otro lado, despu@'es de hacer una entrega 
volver@'an a modo lectura-escritura de nuevo (como si las alarmas todav@'{@dotless{i}}a 
estuviaran puestas).

Observe que qsmith podr@'{@dotless{i}}a, si fuese malicioso, hacer los ficheros de 
su copia de trabajo escribibles usando la orden est@'andar de Unix 
@code{chmod} salt@'andose @w{@code{cvs edit}} por completo.

@example
paste$ chmod u+w hello.c 
@end example

o si quisiera hacerlo todo en una pasada.

@example
paste$ chmod -R u+w . 
@end example

No hay nada que CVS pueda hacer sobre esto. Las copias de trabajo son 
por su propia naturaleza privadas. Las alarmas pueden permitir su 
escrutinio al p@'ublico tanto como lo permita el desarrollador. 
S@'olamente cuando un desarrollador hace algo que afecte al 
repositorio (como una entrega) su privacidad se pierde incondicinalmente.

La relaci@'on entre @code{watch add}, @code{watch remove}, @code{watch on} 
y @code{watch off} 
podr@'{@dotless{i}}a parecer confusa. Para aclarar esto resumamos  el esquema general:
@code{add} y @code{remove} sirven para a@~nadir o quitar usuarios de la 
lista de vigilancia de un fichero; no tiene nada que ver con que 
los ficheros sean de s@'olo lectura al obtener la copia de trabajo o 
despu@'es de la entrega. @code{on} y @code{off} sirven para los permisos 
de los ficheros. No tienen nada que ver con la lista de vigilancia; 
m@'as bien son herramientas par ayudar a los desarrolladores a recordar 
la pol@'{@dotless{i}}tica de alarmas haciendo que los ficheros de la copia de trabajo 
sean de s@'olo lectura.

Todo esto parece un poco inconsistente. De alg@'un modo el usar alarmas 
parece ir en contra de la esencia de CVS. Se desv@'{@dotless{i}}a del universo 
ideal de m@'ultiples desarrrolladores editando libremente en sus copias 
de trabajo, ocultos unos de otros hasta que hacen una entrega. Con las 
alarmas CVS da a los desarrolladores atajos para informarse mutuamente 
lo que pasa en sus copias de trabajo. Sin embargo no tiene forma de 
imponer las pol@'{@dotless{i}}ticas de observaci@'on ni un concepto de que constituye 
una sesi@'on de edici@'on. Aun as@'{@dotless{i}} las alarmas pueden ser @'utiles en ciertas 
ocasiones.
  

@c -------------------------------------------------------
@node C@'omo aparecen las alarmas en el repositorio 
@subsection C@'omo aparecen las alarmas en el repositorio

Para acabar con las cajas negras y los misterios sin soluci@'on vamos 
a hacer una r@'apida mirada a c@'omo las alarmas son implementadas en 
el repositorio. Ser@'a r@'apido ya que no es agradable.

Cuando usted establece una alarma

@example
floss$ pwd 
/home/jrandom/myproj 
floss$ cvs watch add hello.c 
floss$ cvs watchers 
hello.c jrandom edit    unedit  commit 
floss$ 
@end example

CVS la guarda en un fichero especial, @file{CVS/fileattr}, del 
subdirectorio apropiado del repositorio.

@example
floss$ cd /usr/local/newrepos 
floss$ ls 
CVSROOT/   myproj/ 
floss$ cd myproj 
floss$ ls 
CVS/          a-subdir/     foo.gif,v 
README.txt,v  b-subdir/     hello.c,v 
floss$ cd CVS 
floss$ ls 
fileattr 
floss$ cat fileattr 
Fhello.c        _watchers=jrandom>edit+unedit+commit 
floss$  
@end example


El hecho de que fileattr sea almacenado en un subdirectorio llamado CVS 
del repositorio no significa que el repositorio se haya convertido en 
una copia de trabajo. Simplemente el nombre @code{CVS} estaba ya 
reservado en la copia de trabajo para guardar informaci@'on con lo 
que no habr@'a ning@'un proyecto que necesite un subdirectorio con ese nombre 
en el repositorio.

No describir@'e el formato de @file{fileattr} formalmente; se puede ver 
bastante bien estudiando los cambios que ocurren en @'el entre orden y orden.

@example
floss$ cvs watch add hello.c 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watchers=jrandom>edit+unedit+commit 
floss$ cvs watch add README.txt 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watchers=jrandom>edit+unedit+commit 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
floss$ cvs watch on hello.c 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watchers=jrandom>edit+unedit+commit;_watched= 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
floss$ cvs watch remove hello.c 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watched= 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
floss$ cvs watch off hello.c 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
floss$  
@end example

Registros de edici@'on son almacenados en fileatrr tambi@'en. 
Esto es lo que pasa cuando qsmith se a@~nade asimismo como un editor.

@example
paste$ cvs edit hello.c 

floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
Fhello.c        _watched=;_editors=qsmith>Tue Jul 20 04:53:23 1999 GMT+floss\
+/home/qsmith/myproj;_watchers=qsmith>tedit+tunedit+tcommit 
FREADME.txt     _watchers=jrandom>edit+unedit+commit 
@end example

Finalmente, observe que CVS quita le fichero fileattr y subdirectorio  
CVS cuando no hay m@'as vigilantes o editores para cualquier fichero en ese
directorio:


@example
paste$ cvs unedit 

floss$ cvs watch off 
floss$ cvs watch remove 
floss$ cat /usr/local/newrepos/myproj/CVS/fileattr 
cat: /usr/local/newrepos/myproj/CVS/fileattr: No such file or directory 
floss$  
@end example

Debe quedar claro depu@'es de esta breve exposici@'on que los detalles del 
tratamiento del formato de fileattr se dejan a CVS. La principal raz@'on 
para tener una comprensi@'on b@'asica del formato, adem@'as de la satisfacci@'on 
inherente de saber que es lo que ocurre detr@'as de las cortinas, es 
si usted va a escribir una extensi@'on a las alarmas de CVS, o est@'a 
depurando alg@'un error en ellas. Es suficiente con que no se alarme si ve 
CVS/ subdirectorios apareciendo y desapareciendo de su repositorio. 
Son los @'unicos lugares seguros que CVS tiene para almacenar 
meta-informaci@'on como las listas de vigilancia.

@c --------------------------------------------------------
@node Mensajes log y correos electr@'onicos a la entrega 
@section Mensajes log y correos electr@'onicos a la entrega

Los correos electr@'onicos a la entrega son enviados cuando se hace una 
entrega y muestran el mensaje log y los ficheros involucrados en @'esta.
Normalmente van para todos los partipantes en el proyecto y algunas veces 
para otras partes interesadas. Los detalles para establecer correos 
a la entrega son cubiertos en @ref{Administracion del Repositorio}, por 
lo que no los repetiremos aqu@'{@dotless{i}}. He observado, sin embargo, algunos 
efectos inesperados en los proyectos. Efectos que usted deber@'{@dotless{i}}a tener 
en cuenta si estable correos electr@'onicos a la entrega.

Prep@'arese para que la mayor@'{@dotless{i}}a de los mensajes sean ignorados. Que se 
lean o no depender@'a, al menos en parte, en la frecuencia con que se hagan 
entregas en su proyecto. ¿Entregan los desarrolladores un cambio grande al 
final de d@'{@dotless{i}}a, o hacen peque@~nos cambios durante la jornada? En el @'ultimo 
caso los desarrolladores recibir@'an m@'as mensajes y es problabe que presten 
menos atenci@'on a ellos.

Esto no significa que los mensajes no son @'utiles, sino que no debe contar 
con que cada persona va a leer cada mensaje. Es un modo conveniente de 
para las personas de mantener informaci@'on de qui@'en est@'a haciendo qu@'e
(sin la intrusi@'on de las alarmas). Cuando los correos van a una lista 
de correos p@'ublica subscribible son un mecanismo maravilloso para dar 
a usuarios interesados (y futuros desarrolladores) una oportunidad para 
ver lo que ocurre en el c@'odigo a nivel b@'asico.

Podr@'{@dotless{i}}a tener un desarrollador designado para vigilar todos los mensajes 
log y tener un visi@'on general de la actividad en todo el proyecto
(por supuesto, un buen jefe de proyectos estar@'a probablemente haciendo esto).
Si hay una clara divisi@'on de responsabilidades, es decir, ciertos 
desarrolladores est@'an a cargo de alg@'un subdirectorio del proyecto, usted 
podr@'{@dotless{i}}a usar alg@'un lenguaje interpretado sobre CVSROOT/loginfo para que 
cada responsable reciba notificaciones especiales de cambios hechos en 
su @'area. Esto asegurar@'{@dotless{i}}a que los desarrolladores leen al menos los 
correos involucrados en sus subdirectorios.

Un interesante efecto que surge cuando los correos no son ignorados.
La gente empieza a usarlos como un m@'etodo de comunicaci@'on en tiempo real.
@'Esta es la clase de mensaje log que podr@'{@dotless{i}}a resultar:

@example
Acabada la forma de retroalimentaci@'on; arreglados los colores de las 
fuentes y el fondo. Bien, ¿alguien quiere almorzar en 'Los claveles'?
@end example
  
No hay nada malo en esto y hace los mensajes log m@'as entretenidos cuando 
se repasan m@'as tarde. Sin embargo hay que ser consciente de que los mensajes 
log se guardan para siempre en el historial del proyecto. Por ejemplo, 
quejarse de las especificaciones de un cliente es un pasatiempo entre 
los programadores; no es dificil imaginar a alguien entregando un mensaje 
log como @'este, sabiendo que otros programadores lo ver@'an en su correo:

@example
Cambiar los cuatro digitos del a@~no por dos en la salida. Lo que el 
cliente pide, el cliente recibe, no importa lo est@'upido y malo que sea.
@end example

Esto hace los correos m@'as divertidos pero, ¿qu@'e ocurrir@'{@dotless{i}}a si el cliente 
revisara los mensajes log? (Apostar@'{@dotless{i}}a a que debido a esto m@'as de un 
sitio ha configurado su CVSROOT/loginfo para que invoque scripts que 
matengan libre de palabras ofensivas los mensajes log.)

El efecto global de los correos a la entraga ser@'{@dotless{i}}a que la gente 
no escribe mensajes log demasiandos cortos o complicados, lo cual est@'a 
bien. Sin embargo hay que recordar que su audiencia no son s@'olo la gente 
que recibe los correos sino cualquiera que pudiera leer estos mensajes log.

@c -------------------------------------------------------------------
@node Cambiar un mensaje log despu@'es de una entrega
@section Cambiar un mensaje log despu@'es de una entrega

Por si alguien escribe un mensaje log deplorable, CVS permite que @'este se 
puede reescribier despu@'es de que se haya entregado. Se hace con el indicador 
-m de la orden admit (esta orden se ver@'a en m@'as detalle m@'as adelante) y 
permite cambiar un mensaje log (por revisi@'on, por fichero) cada vez. 
As@'{@dotless{i}} es como funciona:

@example
floss$ cvs admin -m 1.7:"Cambiar cuatro d@'{@dotless{i}}gitos del a@~no por dos en la 
salida." date.c
RCS file: /usr/local/newrepos/someproj/date.c,v 
done 
floss$  
@end example

El mensaje ofensivo original que fue entregado en la revisi@'on 1.7 ha sido
reemplazado por uno m@'as inocente (aunque tambi@'en m@'as soso).
No olvide los dos puntos separando el n@'umero de revisi@'on del nuevo 
mensaje log.

Si el mensaje original fue entregado en m@'ultiples fichros, tendr@'a que 
ejecurar @code{cvs admit} para cada uno de ellos, porque el n@'umero de revisi@'on 
ser@'a distinto en cada fichero. As@'{@dotless{i}}, esta es una de las pocas @'ordenes 
en las que CVS requiere que se pase como argumento el nombre de un fichero:

@example
floss$ cvs admin -m 1.2:"mensaje log muy aburrido" hello.c REAME.txt foo.gif 
cvs admin: while processing more than one file: 
cvs [admin aborted]: attempt to specify a numeric revision 
floss$  
@end example

Obtendr@'{@dotless{i}}a el mismo error si no le pasa ning@'un nombre de fichero. Parace 
confuso pero la raz@'on es que CVS asumir@'{@dotless{i}}a como argumentos impl@'{@dotless{i}}citos todos 
los ficheros de directorio actual.

@example
floss$ cvs admin -m 1.2:"mensaje log muy aburrido" 
cvs admin: while processing more than one file: 
cvs [admin aborted]: attempt to specify a numeric revision 
floss$  
@end example

Desgraciadamente esto lo encontramos a menudo en los mensajes de error. 
Usted debe ver las cosas desde el punto de vista de CVS para 
que los mensajes tengan sentido.

Invocar @w{@code{admin -m}} cambia el historial del proyecto por lo que 
debe usarlo con cuidado. No habr@'a forma de saber que un mensaje log fue 
cambiado alguna vez. Parecer@'a como si esa revisi@'on fue entregada con el 
nuevo mensaje. No quedar@'a huella del mensaje antiguo en ning@'un sitio 
(a no ser que salve el correo que se entreg@'o la primera vez).

Aunque por su nombre pueda parecer que s@'olo administradores designados 
de CVS pueden usarlo cualquiera puede ejecutar @w{@code{cvs admin}}
si tiene acceso de escritura en el proyecto.
Sin embargo, es mejor usarlo con cuidado; la habilidad de cambiar el 
historial de un proyecto es poca comparado con el da@~no potencial que 
se puede hacer. Vea @ref{Referencia de CVS} para saber m@'as sobre @code{admin} 
y tambi@'en como restringir su uso.

@c -------------------------------------------------------------
@node Deshacerse de una copia de trabajo
@section Deshacerse de una copia de trabajo

En un uso t@'{@dotless{i}}pico de CVS, el modo de deshacerse del directorio que contiene 
una copia de trabajo es quitarlo como se har@'{@dotless{i}}a con cualquier @'arbol de 
directorios:

@example
paste$ rm -rf myproj 
@end example

Sin embargo al hacerlo de esta manera otros desarrolladores no sabr@'an que 
ha dejado de trabajar en @'el. CVS proporciona una orden para dejar una 
copia de trabajor expl@'{@dotless{i}}citamente. Piense de un lanzamiento como lo 
contrario de una entrega; usted le dice al repositorio que ya ha hecho su 
trabajo con la copia de trabajo. Como la entrega, el lanzamiento es 
invocado desde el directorio padre del arbol.


@example
paste$ pwd 
/home/qsmith/myproj 
paste$ cd .. 
paste$ ls 
myproj 
paste$ cvs release myproj 
You have [0] altered files in this repository. 
Are you sure you want to release directory 'myproj': y 
paste$  
@end example

(Usted tiene [0] ficheros alterados en este repositorio,
Est@'a seguro de que quiere lanzarlos (y borrar) el directorio 'myproj': si

Por ahora la versi@'on 1.10.6 no permite que la orden @code{release} deduzca 
la localizaci@'on del repositorio examinando la copia de trabajo ya que 
@code{release} es invocado fuera de la copia de trabajo no dentro de ella.
Usted debe pasar la opici@'on global  @w{@code{-d <REPOS>}} o asegurarse que 
la variable de entorno CVSROOT est@'a correcta. (Esto se podr@'{@dotless{i}}a arreglar en 
futuras versiones.)

Cederqvist afirma que si se usa @code{release} en vez de borrar el 
directorio de trabajo, la gente que vigila los ficheros liberados ser@'a 
notificada como si hubieran ejecutado @code{unedit}. Lo he probado  
experimentalmente y parece que no es verdad.

@c ----------------------------------------------------
@node Historial -- Un resumen de la actividad del repositorio
@section Historial -- Un resumen de la actividad del repositorio

En @ref{Administracion del Repositorio} coment@'e brebemente la orden @code{history}.
@'Esta orden muestra un resumen de todos las obtenciones @emph{checkouts}, 
entregas @emph{commits}, actualizaciones @emph{updates}, etiquetas 
@emph{rtags}, y entregas finales @emph{releases} hechos en el repositorio 
(al menos, desde que @code{logging} fue activado mediante la creaci@'on del 
fichero CVSROOT/history en el repositorio). Puede controlar el formato y
contenidos del resumen con varias optciones.

El primer paso es asegurarse que @code{logging} esta activo en su repositorio.
El administrador del repositorio debe asegurarse de que existe un fichero 
history

@example
floss$ cd /usr/local/newrepos/CVSROOT 
floss$ ls -l history 
ls: history: No such file or directory 
floss$  
@end example

y si no exite crearlo de la siguiente forma:

@example
floss$ touch history 
floss$ ls -l history 
-rw-r--r--   1 jrandom   cvs           0 Jul 22 14:57 history 
floss$  
@end example

Este para el historial, @code{history} debe ser escribible por cualquiera que 
use el repositorio ya que de otra forma se obtendr@'a un error cada vez que 
ejecute alguna orden de CVS que modifique ese fichero. La foram m@'as simple 
es hacer el fichero escribible por todo el mundo:

@example
floss$ chmod a+rw history 
floss$ ls -l history 
-rw-rw-rw-   1 jrandom   cvs           0 Jul 22 14:57 history 
floss$  
@end example

Si el repositorio fue creado con la orden @w{@code{cvs init}}, el fichero 
@code{history} ya existir@'a. Tal vez que tuviese que arreglar los permisos 
de escritura.

Se asume en el resto de los ejemplos que @code{history logging} se ha activado 
durante un tiempo y por lo tanto ha habido tiempo para alguna informaci@'on 
se haya acumulado en el historial (fichero @code{history}).

La salida de @code{cvs history} es en cierta forma dificil (probablemente se 
cre@'o pensando en que se tratatar@'{@dotless{i}}a mediante otros programas y no mediante 
personas, aunque con un poco de estudio se puede leer). Ejecut@'emoslo y 
veamos lo que obtenemos.

@example
paste$ pwd 
/home/qsmith/myproj 
paste$ cvs history -e -a 
O 07/25 15:14 +0000 qsmith  myproj =mp=     ~/* 
M 07/25 15:16 +0000 qsmith  1.14 hello.c    myproj == ~/mp 
U 07/25 15:21 +0000 qsmith  1.14 README.txt myproj == ~/mp 
G 07/25 15:21 +0000 qsmith  1.15 hello.c    myproj == ~/mp 
A 07/25 15:22 +0000 qsmith  1.1  goodbye.c  myproj == ~/mp 
M 07/25 15:23 +0000 qsmith  1.16 hello.c    myproj == ~/mp 
M 07/25 15:26 +0000 qsmith  1.17 hello.c    myproj == ~/mp 
U 07/25 15:29 +0000 qsmith  1.2  goodbye.c  myproj == ~/mp 
G 07/25 15:29 +0000 qsmith  1.18 hello.c    myproj == ~/mp 
M 07/25 15:30 +0000 qsmith  1.19 hello.c    myproj == ~/mp 
O 07/23 03:45 +0000 jrandom myproj =myproj= ~/src/* 
F 07/23 03:48 +0000 jrandom        =myproj= ~/src/* 
F 07/23 04:06 +0000 jrandom        =myproj= ~/src/* 
M 07/25 15:12 +0000 jrandom 1.13 README.txt myproj == ~/src/myproj 
U 07/25 15:17 +0000 jrandom 1.14 hello.c    myproj == ~/src/myproj 
M 07/25 15:18 +0000 jrandom 1.14 README.txt myproj == ~/src/myproj 
M 07/25 15:18 +0000 jrandom 1.15 hello.c    myproj == ~/src/myproj 
U 07/25 15:23 +0000 jrandom 1.1  goodbye.c  myproj == ~/src/myproj 
U 07/25 15:23 +0000 jrandom 1.16 hello.c    myproj == ~/src/myproj 
U 07/25 15:26 +0000 jrandom 1.1  goodbye.c  myproj == ~/src/myproj 
G 07/25 15:26 +0000 jrandom 1.17 hello.c    myproj == ~/src/myproj 
M 07/25 15:27 +0000 jrandom 1.18 hello.c    myproj == ~/src/myproj 
C 07/25 15:30 +0000 jrandom 1.19 hello.c    myproj == ~/src/myproj 
M 07/25 15:31 +0000 jrandom 1.20 hello.c    myproj == ~/src/myproj 
M 07/25 16:29 +0000 jrandom 1.3  whatever.c myproj/a-subdir == ~/src/myproj 
paste$  
@end example

¿No est@'a claro?

Antes de examinar la salida, observe que la orden incluye dos opciones:
-e y -a. Cuando usted ejecuta @code{histoy}, casi siempre le pasar@'a opciones 
para indicar que datos y en que formato los ver@'a. En esto difiere de la 
mayoria de las @'ordenes de CVS, que normalmente hacen cosas @'utiles sin 
necesidad de opciones. En este ejemplo, los dos indicadores significan 
respectivamente "todas las cosas" (del ingl@'es @emph{everything}), que muestra 
todas las claves de eventos que han ocurrido, y "todo" (del ingl@'es 
@emph{all}), por todos los usuarios.

Otro modo en que @code{history} se diferencia de otros comandos es que, aunque 
normalmente se invoca dentro de una copia de trabajo, no s@'olo est@'a 
restringida su salida a esa copia del projecto sino que tambi@'en muestra 
todo el historial de eventos de todos los proyectos del repositorio. La 
copia de trabajo s@'olo indica a CVS desde que repositorio conseguir los datos 
del historial. (En el ejemplo anterior, los @'unicos datos de historial de 
ese repositorio son los del proyecto @code{myproj}, por lo tanto eso es lo 
que vemos.)

El formato general de salida es:
 
@example
C@'ODIGO FECHA_Y_HORA USUARIO [REVISION] [FICHERO] DIRECTORIO_DEL_REPOSITORIO
NOMBRE_DEL_DIRECTORIO_DE_TRABAJO
@end example

@c todo: weird table ref here
Aunque la salida de esta orden fue dise@~nado para ser compacto y usado como 
entrado por otros programas, CVS le da bastante control sobre su contenido.
Las opciones mostradas en la Tabla 6.2 controlan sobre que tipos de eventos
se informa.


@example
Tabla 6.1  Significado del c@'odigo de las letras.

Letra	        Significado
======          =========================================================
O		Obtener
T		Tag
F		Entrega final
W		Actualizar (no de un fichero de usuario, eliminaci@'on en las 
                entradas del fichero)
U		Actualizar (fichero sobrescribe un fichero de usuario 
                no modificado)
G		Actualizar (fichero fusionado exitosamente con un fichero 
                modificado de usuario)
C		Actualizar (fichero fusionado, pero existen conflictos con 
                fichero de usuario)
M		Entregar (de un fichero modificado)
A		Entregar (un fichero a@~nadido)  
R		Entregar (el borrado de un fichero)
E		Exportar
@end example

@example
Tabla 6.2  Opciones de filtrado sobre tipo de evento.
 
Opci@'on	        Significado
==========      =========================================================
-m MODULO	Muestra eventos del historial que afecten a MODULO
-c		Muestra las entregas.
-o		Muestra las obtenciones. 
-T		Muestra los tag.
-x CODE(S)	Muestra los eventos de tipo CODE (uno o m@'as de OTFWUGCMARE).
-e		Muestra todos los eventos. Una ver seleccionados los tipos 
                de eventos se puede filtrar m@'as con las opciones de la
                Tabla 6.3.
@end example

@example
Tabla 6.3  Opciones a filtrar por el usuario.

Opci@'on	        Significado
==========      =========================================================
-a		Muestra las acciones hechas por todos los usuarios  
-w              Muestra s@'olo las acciones hechas dentro de la copia de 
                trabajo. 
-l		Muestra s@'olo la @'ultima vez que este usuario realiz@'o la
                acci@'on
-u USUARIO      Muestra los registros para USUARIO 
@end example

@c ------------------------------------------------------------------
@node Anotaciones -- Sumario detallado de la actividad del proyecto
@section Anotaciones -- Sumario detallado de la de la actividad del proyecto

@heading La orden @code{annotaded}

Mientras que la orden @code{history} da una visi@'on general sobre la 
actividad del proyecto, @dfn{annotate} es un modo de acercarse con m@'as 
detalle a esa visi@'on. Con @code{annotate} usted puede ver qui@'en fue la 
@'ultima perosna que toc@'o cada l@'{@dotless{i}}nea de un fichro, y en que revisi@'on se hiz@'o.


@example
floss$ cvs annotate
Annotations for README.txt 
*************** 
1.14         (jrandom  25-Jul-99): blah 
1.13         (jrandom  25-Jul-99): test 3 for history 
1.12         (qsmith   19-Jul-99): test 2 
1.11         (qsmith   19-Jul-99): test 
1.10         (jrandom  12-Jul-99): blah 
1.1          (jrandom  20-Jun-99): Just a test project. 
1.4          (jrandom  21-Jun-99): yeah. 
1.5          (jrandom  21-Jun-99): nope. 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.15         (jrandom  25-Jul-99):   /* another test for history */ 
1.13         (qsmith   19-Jul-99):   /* random change number two */ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.21         (jrandom  25-Jul-99):   printf ("Hellooo, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.11         (qsmith   18-Jul-99):   /* added this comment */ 
1.16         (qsmith   25-Jul-99):   /* will merge these changes */ 
1.18         (jrandom  25-Jul-99):   /* will merge these changes too */ 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
Annotations for a-subdir/whatever.c 
*************** 
1.3          (jrandom  25-Jul-99): /* A completely non-empty C file. */
Annotations for a-subdir/subsubdir/fish.c 
*************** 
1.2          (jrandom  25-Jul-99): /* An almost completely empty C file. */ 
Annotations for b-subdir/random.c 
*************** 
1.1          (jrandom  20-Jun-99): /* A completely empty C file. */ 
floss$  
@end example

La salida de @code{annotate} es bastante intuitiva. A la izquiera est@'a el
n@'umero de revisi@'on, desarrollador, y la fecha en que esa l@'{@dotless{i}}nea fu@'e 
a@~nadida o modificada. A la derecha est@'a la l@'{@dotless{i}}nea en questi@'on en su 
actual versi@'on. Como cada l@'{@dotless{i}}nea es comentado se puede ver el contenido 
entero del fichero a la derecha de la informaci@'on anotada.

Si especifica un n@'umero de revisi@'on, las anotaciones son dadas para esa
revisi@'on lo cual quiere decir que se muestran la m@'as reciente 
modificacione para cada l@'{@dotless{i}}nea a esa o una anterior revisi@'on. Este es 
probablemente el modo m@'as comunmente usado. Se examina una revision 
particular de un fichero para determinar que desarrolladores estaban 
activos en cada parte de un fichero.

En el ejemplo anterior se puede ver que la m@'as reciente revisi@'on de hello.c
es la 1.21, en la que jrandom hizo algo en la l@'{@dotless{i}}nea:

@example
printf ("Hellooo, world!\n"); 
@end example

Un modo de ver lo que ella hizo es usar @code{diff} de esa revisi@'on con la 
anterior:

@example
floss$ cvs diff -r 1.20 -r 1.21 hello.c 
Index: hello.c 
=================================================================== 
RCS file: /usr/local/newrepos/myproj/hello.c,v 
retrieving revision 1.20 
retrieving revision 1.21 
diff -r1.20 -r1.21 
9c9 
<   printf ("Hello, world!\n"); 
-- 
>   printf ("Hellooo, world!\n"); 
floss$  
@end example

Otro modo de verlo manteniendo la amplia visi@'on de la actividad de cada
uno es comparando las actuales anotaciones con las anotaciones de 
una revisi@'on anterior:

@example
floss$ cvs annotate -r 1.20 hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.15         (jrandom  25-Jul-99):   /* another test for history */ 
1.13         (qsmith   19-Jul-99):   /* random change number two */ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.11         (qsmith   18-Jul-99):   /* added this comment */ 
1.16         (qsmith   25-Jul-99):   /* will merge these changes */ 
1.18         (jrandom  25-Jul-99):   /* will merge these changes too */ 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

Aunque el @code{diff} muestra los cambios sobre el texto de forma m@'as concisa, 
la anotaci@'on puede ser preferible ya que coloca estos cambios en su
contexto hist@'orico al mostrar desde cuando ha estado presente esa l@'{@dotless{i}}nea
(en este caso desde la revisi@'on 1.1). Ese conocimiento puede ayudarle 
a decidir si mirar en los mensajes log para averiguar los motivos del 
cambio:


@example
floss$ cvs log -r 1.21 hello.c 
RCS file: /usr/local/newrepos/myproj/hello.c,v 
Working file: hello.c 
head: 1.21 
branch: 
locks: strict 
access list: 
symbolic names: 
       random-tag: 1.20 
       start: 1.1.1.1 
       jrandom: 1.1.1 
keyword substitution: kv 
total revisions: 22;    selected revisions: 1 
description: 
---------------------------- 
revision 1.21 
date: 1999/07/25 20:17:42;  author: jrandom;  state: Exp;  lines: +1 -1 
say hello with renewed enthusiasm 
============================================================================
floss$  
@end example

Adem@'as de la opci@'on -r, se puede filtrar las anotaciones con la opci@'on 
-D DATE:


@example
floss$ cvs annotate -D "5 weeks ago" hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$ cvs annotate -D "3 weeks ago" hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

@c -----------------------------------------------------------
@node Anotaciones y ramificaciones
@section Anotaciones y ramificaciones

Por defecto, las anotaciones muestran siempren la actividad de la rama 
principal de desarrollo. Incluso aunque se llame desde una copia de trabajo 
derivada se muestra las anotaciones de la rama principal a menos que se 
especifique lo contrario. (Dependiendo de su punto de vista esta tendencia 
de favorecer el tronco principal se puedr@'{@dotless{i}}a considerar un error o una 
caracter@'{@dotless{i}}stica.) Puede anotar una ramificaci@'on o derivaci@'on pasando el 
nombre de @'esta como argumento de -r. He aqu@'{@dotless{i}} un ejemplo de una copia de 
trabajo cuyo fichero hello.c est@'a en una derivaci@'on llamada 
@code{Brancho_Gratuito}, con al menos un cambio entregado en esa rama:

@example
floss$ cvs status hello.c 
=================================================================== 
File: hello.c           Status: Up-to-date 

  Working revision:    1.10.2.2        Sun Jul 25 21:29:05 1999 
  Repository revision: 1.10.2.2        /usr/local/newrepos/myproj/hello.c,v
  Sticky Tag:          Brancho_Gratuito (branch: 1.10.2) 
  Sticky Date:         (none) 
  Sticky Options:      (none) 

floss$ cvs annotate hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$ cvs annotate -r Brancho_Gratuito hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.10.2.2     (jrandom  25-Jul-99):   printf ("hmmmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.10.2.1     (jrandom  25-Jul-99):   printf ("added this line"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

Tambi@'en puede pasar el n@'umero de la ramificaci@'on:

@example
floss$ cvs annotate -r 1.10.2 hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.10.2.2     (jrandom  25-Jul-99):   printf ("hmmmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.10.2.1     (jrandom  25-Jul-99):   printf ("added this line"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

o el n@'umero de revisi@'on completo de la ramificaci@'on:

@example
floss$ cvs annotate -r 1.10.2.1 hello.c 
Annotations for hello.c 
*************** 
1.1          (jrandom  20-Jun-99): #include <stdio.h> 
1.1          (jrandom  20-Jun-99):  
1.1          (jrandom  20-Jun-99): void 
1.1          (jrandom  20-Jun-99): main () 
1.1          (jrandom  20-Jun-99): @{ 
1.10         (jrandom  12-Jul-99):   /* test */ 
1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n"); 
1.3          (jrandom  21-Jun-99):   printf ("hmmm\n"); 
1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n"); 
1.10.2.1     (jrandom  25-Jul-99):   printf ("added this line"); 
1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n"); 
1.1          (jrandom  20-Jun-99): @} 
floss$  
@end example

Si hace esto, recuerde que los n@'umeros son s@'olo v@'alidos parar ese 
fichero particualr. En general es mejor usar el nombre de esa 
ramificaci@'on si ello es posible.

@c ---------------------------------------------------------
@node Usando expansi@'on de palabras
@section Usando expansi@'on de palabras

Podr@'{@dotless{i}}a recordar una breve menci@'on de @code{keyword expansion} en 
@ref{Una introduccion a CVS}. Estas palabras especiales de RCS est@'an 
rodeadas por el signo del dolar, que CVS busca en el texto del fichero 
y las sustituye por informaci@'on de revisi@'on. Por ejemplo si un fichero 
contiene 

@example
$Author: jfs $ 
@end example

entonces cuando se actualize ese fichero a cualquier revisi@'on, CVS 
lo sustituir@'a por el nombre de usuario de la persona que realiz@'o la 
entrega de esa revisi@'on:

@example
$Author: jfs $ 
@end example

CVS es tambi@'en consciente de las palabras que han sido sustituidas por lo 
que estas se pueden actualizar cuando sea apropiado.

Aunque estas palabras no ofrecen informaci@'on que no puediera ser obtenida 
mediante otros medios, dan a las personas una forma c@'omoda de ver los 
hechos de revisi@'on incluidos en el texto mismo, en vez de tener que 
invocar alguna orden rara de CVS.

He aqu@'{@dotless{i}} otros ejemplos de sustituci@'on de palabras:

@example
$Date: 2002/12/05 19:10:27 $       ==>  date of last commit, expands to ==> 
$Date: 2002/12/05 19:10:27 $ 

$Id: chapter-6.texi,v 1.4 2002/12/05 19:10:27 jfs Exp $         ==>  filename, revision, date, and author; expands to ==> 
$Id: chapter-6.texi,v 1.4 2002/12/05 19:10:27 jfs Exp $ 

$Revision: 1.4 $   ==>  exactly what you think it is, expands to ==> 
$Revision: 1.4 $ 

$Source: /home/cvs/lucas/doc-cvsbook-es/chapter-6.texi,v $     ==> path to corresponding repository file, expands to ==> 
$Source: /home/cvs/lucas/doc-cvsbook-es/chapter-6.texi,v $ 

$Log: chapter-6.texi,v $
Revision 1.4  2002/12/05 19:10:27  jfs
Ahora el documento compila incluyendo los acentos en castellano, he seguido
los consejos de
http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
Sin embargo ser@'{@dotless{i}}a conveniente revisar por qu@'e los nombres de nodo que se
referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?

Revision 1.3  2002/12/03 13:04:59  carlosgarcia
Traduccion de main, introduction e index

Revision 1.2  2002/11/27 16:26:56  carlosgarcia
Realizados arreglos para compilaci@'on

Revision 1.1  2000/09/16 12:07:53  jjamor
Traduccion del capitulo 6 insertada en la B.de trabajo
        ==>  accumulating log messages for the file, expands to ==> 
$Log: chapter-6.texi,v $
Revision 1.4  2002/12/05 19:10:27  jfs
Ahora el documento compila incluyendo los acentos en castellano, he seguido
los consejos de
http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
Sin embargo ser@'{@dotless{i}}a conveniente revisar por qu@'e los nombres de nodo que se
referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?

Revision 1.3  2002/12/03 13:04:59  carlosgarcia
Traduccion de main, introduction e index

Revision 1.2  2002/11/27 16:26:56  carlosgarcia
Realizados arreglos para compilaci@'on

Revision 1.1  2000/09/16 12:07:53  jjamor
Traduccion del capitulo 6 insertada en la B.de trabajo
 
Revision 1.2  1999/07/26 06:47:52  jrandom 
...and this is the second log message. 

Revision 1.1  1999/07/26 06:39:46  jrandom 
This is the first log message... 
@end example

La palabra $Log: chapter-6.texi,v $
La palabra Revision 1.4  2002/12/05 19:10:27  jfs
La palabra Ahora el documento compila incluyendo los acentos en castellano, he seguido
La palabra los consejos de
La palabra http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
La palabra Sin embargo ser@'{@dotless{i}}a conveniente revisar por qu@'e los nombres de nodo que se
La palabra referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
La palabra
La palabra Revision 1.3  2002/12/03 13:04:59  carlosgarcia
La palabra Traduccion de main, introduction e index
La palabra
La palabra Revision 1.2  2002/11/27 16:26:56  carlosgarcia
La palabra Realizados arreglos para compilaci@'on
La palabra
La palabra Revision 1.1  2000/09/16 12:07:53  jjamor
La palabra Traduccion del capitulo 6 insertada en la B.de trabajo
La palabra es la @'unica que se exande varias lineas. A diferencia 
de las otras no reemplaza la antigua sustituci@'on con una nueva, sino que 
inserta la @'ultima sustituci@'on m@'as una l@'{@dotless{i}}nea en blanco justo despu@'es de 
la palabra especial (las previas sustituciones quedan m@'as abajo). 
Adem@'as cualquier texto entre el principio de l@'{@dotless{i}}nea y el $Log es usada 
como un prefijo para las sustituciones (esto se hace para asegurar que 
los mensajes log quedan comentados en el c@'odigo del programa). 
Por ejemplo, si usted pone esto dentro de un fichero 


@example
// $Log: chapter-6.texi,v $
// Revision 1.4  2002/12/05 19:10:27  jfs
// Ahora el documento compila incluyendo los acentos en castellano, he seguido
// los consejos de
// http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
// Sin embargo ser@'{@dotless{i}}a conveniente revisar por qu@'e los nombres de nodo que se
// referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
//
// Revision 1.3  2002/12/03 13:04:59  carlosgarcia
// Traduccion de main, introduction e index
//
// Revision 1.2  2002/11/27 16:26:56  carlosgarcia
// Realizados arreglos para compilaci@'on
//
// Revision 1.1  2000/09/16 12:07:53  jjamor
// Traduccion del capitulo 6 insertada en la B.de trabajo
// 
@end example

se sustituir@'a por esto en la primera entrega:

@example
// $Log: chapter-6.texi,v $
// Revision 1.4  2002/12/05 19:10:27  jfs
// Ahora el documento compila incluyendo los acentos en castellano, he seguido
// los consejos de
// http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
// Sin embargo ser@'{@dotless{i}}a conveniente revisar por qu@'e los nombres de nodo que se
// referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
//
// Revision 1.3  2002/12/03 13:04:59  carlosgarcia
// Traduccion de main, introduction e index
//
// Revision 1.2  2002/11/27 16:26:56  carlosgarcia
// Realizados arreglos para compilaci@'on
//
// Revision 1.1  2000/09/16 12:07:53  jjamor
// Traduccion del capitulo 6 insertada en la B.de trabajo
// 
// Revision 1.14  1999/07/26 07:03:20  jrandom 
// this is the first log message... 
// 
@end example

a esto en la segunda:

@example
// $Log: chapter-6.texi,v $
// Revision 1.4  2002/12/05 19:10:27  jfs
// Ahora el documento compila incluyendo los acentos en castellano, he seguido
// los consejos de
// http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
// Sin embargo ser@'{@dotless{i}}a conveniente revisar por qu@'e los nombres de nodo que se
// referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
//
// Revision 1.3  2002/12/03 13:04:59  carlosgarcia
// Traduccion de main, introduction e index
//
// Revision 1.2  2002/11/27 16:26:56  carlosgarcia
// Realizados arreglos para compilaci@'on
//
// Revision 1.1  2000/09/16 12:07:53  jjamor
// Traduccion del capitulo 6 insertada en la B.de trabajo
// 
// Revision 1.15  1999/07/26 07:04:40  jrandom 
// ...and this is the second log message... 
// 
// Revision 1.14  1999/07/26 07:03:20  jrandom 
// this is the first log message... 
// 
@end example

y as@'{@dotless{i}} sucesivamente:

@example
// $Log: chapter-6.texi,v $
// Revision 1.4  2002/12/05 19:10:27  jfs
// Ahora el documento compila incluyendo los acentos en castellano, he seguido
// los consejos de
// http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
// Sin embargo ser@'{@dotless{i}}a conveniente revisar por qu@'e los nombres de nodo que se
// referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
//
// Revision 1.3  2002/12/03 13:04:59  carlosgarcia
// Traduccion de main, introduction e index
//
// Revision 1.2  2002/11/27 16:26:56  carlosgarcia
// Realizados arreglos para compilaci@'on
//
// Revision 1.1  2000/09/16 12:07:53  jjamor
// Traduccion del capitulo 6 insertada en la B.de trabajo
// 
// Revision 1.16  1999/07/26 07:05:34  jrandom 
// ...and this is the third!
// 
// Revision 1.15  1999/07/26 07:04:40  jrandom 
// ...and this is the second log message... 
// 
// Revision 1.14  1999/07/26 07:03:20  jrandom 
// this is the first log message... 
// 
@end example

Podr@'{@dotless{i}}a no querer mantener el historial completo en el fichero todo el 
tiempo; si es as@'{@dotless{i}} siempre puede quitar las antiguas secciones cuando 
sea muy grande. Es m@'as conveniente que tener que ejecutar @code{cvs log}, 
y podr@'{@dotless{i}}a ser @'util en proyectos donde la gente debe leer constantemente 
los mensajes logs.

Una t@'ecnica m@'as com@'un puede ser incluir $Revision: 1.4 $ en un fichero y 
usarlo como n@'umero de versi@'on para el programa. Esto puede funcionar si 
el proyecto consiste de un fichero o se llevan a cabo muchas entregas 
finales (releases) y al menos se garantize que uno de los ficheros se 
ha modificado entre cada entrega. Incluso se pueden usar estas palabras 
de expansi@'on como un valor en el c@'odigo de un programa:

@example
VERSION = "$Revision: 1.4 $"; 
@end example

CVS sustituye esa palabra como cualquier otra; no tiene en cuenta la 
sem@'antica del lenguaje de programaci@'on ni asume que las dobles comillas 
protegen la cadena de alg@'un modo.

Una lista completa de palabras de sustituci@'on (hay algunas m@'as poco usuales)
se encuentra en @ref{Referencia de CVS}

@c -------------------------------------------------------------------
@node Salir del limbo (C@'omo trabajar con derivaciones y sobrevivir)
@section Salir del limbo (C@'omo trabajar con derivaciones y sobrevivir)

Las derivaciones o ramificaciones son una de las m@'as importantes y m@'as 
f@'acilmente mal usadas caracter@'{@dotless{i}}sticas del CVS. Aislar los cambios 
arriesgados o perturbadores en una l@'{@dotless{i}}nea de desarrollo separada hasta 
que se haya estabilizado puede ser inmensamente beneficioso. Sin embargo, 
si no se usa apropiadamente puede llevar un proyecto a la confusi@'on 
y al caos, cuando la gente no pierde la cuento sobre qu@'e cambios se 
han fusionado y cuando se realizaron.

@menu
* Algunos principios para trabajar con derivaciones::
* Fusionar repetidamente con la rama principal::
* La Aproximaci@'on de la Cola de Milano -- Fusionar dentro y fuera de la rama principal::
* La Aproximaci@'on del Pez Volador -- Una forma m@'as simple de hacerlo::
* Derivaciones y expansi@'on de palabras -- Enemigos naturales::
@end menu

@c -------------------------------------------------------------------
@node Algunos principios para trabajar con derivaciones
@subsection Algunos principios para trabajar con derivaciones

Para trabajar exitosamente con derivaciones, su grupo de desarrollo 
deber@'{@dotless{i}}a seguir estos principios:

@itemize

@item
Minimizar el n@'umero de derivaciones activas cada vez. Cuantas m@'as 
derivaciones se esten desarrrollando al mismo tiempo habr@'a m@'as 
posibilidad de que existan conflictos cuando se fusionen con la rama 
principal. En t@'erminos pr@'acticos, la forma de conseguir esto es 
fusionar tan frecuentemente como pueda (cada vez que una derivaci@'on 
est@'a en un punto estable) y volver al desarrollo de la rama principal 
cuando esto sea viable. Minimizando la cantidad de desarrollo en 
paralelo es posible estar al tanto de lo que pasa en cada rama y 
la posibilidad de conflictos se reduce.

Esto no significa minimizar el n@'umero absoluto de derivaciones de un 
proyecto sino el n@'umero de ellos en las que se trabajo en un momentod 
dado.

@item
Minimizar la complejidad -- es decir la profundidad -- del esquema 
de sus derivaciones. Hay circunstancias en que es apropiado tener 
derivaciones de derivaciones pero son muy raras (usted podr@'{@dotless{i}}a no 
encontrar una situaci@'on como @'esta durante toda su vida como programador).
El que CVS permita t@'ecnicamente que se puedan tener distintos niveles 
de derivaciones anidadas, y que se pueda fusionar unas con otras, no 
quiere decir que usted quiera hacerlo. En la mayor@'{@dotless{i}}a de las situaciones 
lo mejor es tener las derivaciones sobre la rama principal y fusionar 
de la derivaci@'on al tronco y vuelta a empezar.

@item 
Use consistentemente etiquetas para marcar todas los eventos de fusi@'on y 
ramificaci@'on. Idealmente el significado de cada etiqueta y su relaci@'on 
con otras ramificaciones y etiquetas deber@'{@dotless{i}}a quedar claro por su nombre. 
(Esto quedar@'a m@'as claro cuando veamos los ejemllos.)

@end itemize
Con estos principios en la cabeza veamos un t@'{@dotless{i}}pico escenario de 
desarrollo con una ramificaci@'on. Tendremos jrandom en la rama principal 
y qsmith en la derivaci@'on. Pero tenga en cuento que podr@'{@dotless{i}}a haber m@'ultiples 
desarrolladores en ambos sitios. El desarrollo normal en cada l@'{@dotless{i}}nea 
puede involucrar cualquier n@'umero de personas; sin embargo el etiquetado 
y fusi@'on es mejor hacerlos por una persano en cada lado como ver@'a.

@c -----------------------------------------------------------------
@node Fusionar repetidamente con la rama principal
@subsection Fusionar repetidamente con la rama principal

Supongamos que qsmith necesita hacer desarrollo en una derivaci@'on para 
no desestabilizar la rama principal que comparte con jrandom. El primer 
paso es crear una rama nueva. Observe como primero qsmith crea una 
etiqueta normal (no-rama) en ese punto de la rama principal y despu@'es 
crea la derivaci@'on:

@example
paste$ pwd 
/home/qsmith/myproj 
paste$ cvs tag Root-of-Exotic_Greetings 
cvs tag: Tagging . 
T README.txt 
T foo.gif 
T hello.c 
cvs tag: Tagging a-subdir 
T a-subdir/whatever.c 
cvs tag: Tagging a-subdir/subsubdir 
T a-subdir/subsubdir/fish.c 
cvs tag: Tagging b-subdir 
T b-subdir/random.c 
paste$ cvs tag -b Exotic_Greetings-branch 
cvs tag: Tagging . 
T README.txt 
T foo.gif 
T hello.c 
cvs tag: Tagging a-subdir 
T a-subdir/whatever.c 
cvs tag: Tagging a-subdir/subsubdir 
T a-subdir/subsubdir/fish.c 
cvs tag: Tagging b-subdir 
T b-subdir/random.c 
paste$  
@end example

Etiquetar primero la rama principal podr@'{@dotless{i}}a servir para obtener alg@'un 
d@'{@dotless{i}}a la rama principal en el momento de que la derivaci@'on fue creada.
Si tuviese que hacer eso deber@'{@dotless{i}}a haber un modo de referirse a esa 
instant@'anea de la rama principal sin referirse a la derivaci@'on. No 
puede usar la etiqueta de la derivaci@'on ya que lo que obtendr@'{@dotless{i}}a es 
esa derivaci@'on no las revisiones que forman la raiz del tronco. El 
@'unico modo de hacer esto ser@'{@dotless{i}}a hacer una etiqueta de las revisiones 
de las que sale la derivaci@'on. (Alguna gente que esta regla tan 
fielmente que consider@'e listarla como "principio n@'umero 4 de 
ramificaci@'on: Crear siempre una etiqueta no-derivaci@'on en la posici@'on 
de la derivaci@'on." Sin embargo en algunos sitios no se usa y parece 
que lo hacen bien por lo que es una cuesti@'on de gusto.)
De ahora en adelante me referir@'e a esta etiqueta no-derivaci@'on como 
@dfn{etiqueta del punto de derivaci@'on}.

Observe que me he adherido a una convenci@'on de nombres: La etiqueta 
del punto de derivaci@'on empieza con @code{Root-of-} (Raiz-de-), y 
despu@'es el nombre, que usar@'a subrayado en vez de gui@'on para separar las 
palabras. Cuando la derivaci@'on es creada su etiqueta acabar@'a con el 
sufijo @code{-branch} (rama) que le indicar@'a con s@'olo mirar el nombre 
que es una derivaci@'on. (La etiqueta del punto de derivaci@'on 
@code{Root-of-Exotic_Greetings} no incluye el sufijo @code{-branch} porque no 
es una derivaci@'on.) No tiene que usar esta convenci@'on en particular pero 
desde luego es aconsejable usar alguna.

Por supuesto, he sido extra pedante. En peque@~nos proyectos donde cada uno
sabe qui@'en est@'a haciendo qu@'e y se pueden arreglar f@'acilmente las 
confusiones estas convenciones no tienen que ser usadas. El que use la 
etiqueta del punto de derivaci@'on o una estricta convenci@'on de nombres 
para sus etiquetas depender@'a de la complejidad del proyecto y su esquema
de derivaciones. (No olvide que siempre puede volver atr@'as m@'as tarde 
para actualizar viejas etiquetas y usar una nueva convenci@'on; obtenga 
la versi@'on de la vieja etiqueta, a@~nada la nueva etiqueta y borre despu@'es 
la antigua.)

Ahora qsmith puede empezar a trabajar con la derivaci@'on:


@example
paste$ cvs update -r Exotic_Greetings-branch 
cvs update: Updating . 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
paste$  
@end example

Hace algunos cambios a un par de ficheros y los entrega en la derivaci@'on:

@example
paste$ emacs README.txt a-subdir/whatever.c b-subdir/random.c 
... 
paste$ cvs ci -m "print greeting backwards, etc" 
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in README.txt; 
/usr/local/newrepos/myproj/README.txt,v  <--  README.txt 
new revision: 1.14.2.1; previous revision: 1.14 
done 
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.3.2.1; previous revision: 1.3 
done 
Checking in b-subdir/random.c; 
/usr/local/newrepos/myproj/b-subdir/random.c,v  <--  random.c 
new revision: 1.1.1.1.2.1; previous revision: 1.1.1.1 
done 
paste$  
@end example

Mientras tanto jrandom sigue trabajando en el tronco. Ella modifica 
dos o tres ficheros que qsmith toc@'o. Para ponerlo m@'as dificil haremos
sus cambios creen conflictos con el trabajo de qsmith:

@example
floss$ emacs README.txt whatever.c 
 ... 
floss$ cvs ci -m "some very stable changes indeed" 
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in README.txt; 
/usr/local/newrepos/myproj/README.txt,v  <--  README.txt 
new revision: 1.15; previous revision: 1.14 
done 
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.4; previous revision: 1.3 
done 
floss$  
@end example

El conflicto no es aparente todav@'{@dotless{i}}a ya que ninguno de los desarrolladores
ha intentado hacer la fusi@'on de la derivaci@'on con el tronco. Ahora
jrandom hace la fusi@'on:

@example
floss$ cvs update -j Exotic_Greetings-branch 
cvs update: Updating . 
RCS file: /usr/local/newrepos/myproj/README.txt,v 
retrieving revision 1.14 
retrieving revision 1.14.2.1 
Merging differences between 1.14 and 1.14.2.1 into README.txt 
rcsmerge: warning: conflicts during merge 
cvs update: Updating a-subdir 
RCS file: /usr/local/newrepos/myproj/a-subdir/whatever.c,v 
retrieving revision 1.3 
retrieving revision 1.3.2.1 
Merging differences between 1.3 and 1.3.2.1 into whatever.c 
rcsmerge: warning: conflicts during merge 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
RCS file: /usr/local/newrepos/myproj/b-subdir/random.c,v 
retrieving revision 1.1.1.1 
retrieving revision 1.1.1.1.2.1 
Merging differences between 1.1.1.1 and 1.1.1.1.2.1 into random.c 
floss$ cvs update 
cvs update: Updating . 
C README.txt 
cvs update: Updating a-subdir 
C a-subdir/whatever.c 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
M b-subdir/random.c 
floss$  
@end example

Dos de los ficheros tienen conflictos. No importa, con su saber hacer 
jarandom resuelve los conflictos, entrega y etiqueta el tronco 
indicando una fusi@'on con @'exito.

@example
floss$ emacs README.txt a-subdir/whatever.c 
 ... 
floss$ cvs ci -m "merged from Exotic_Greetings-branch (conflicts resolved)"
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in README.txt; 
/usr/local/newrepos/myproj/README.txt,v  <--  README.txt 
new revision: 1.16; previous revision: 1.15 
done 
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.5; previous revision: 1.4 
done 
Checking in b-subdir/random.c; 
/usr/local/newrepos/myproj/b-subdir/random.c,v  <--  random.c 
new revision: 1.2; previous revision: 1.1 
done 
floss$ cvs tag merged-Exotic_Greetings 
cvs tag: Tagging . 
T README.txt 
T foo.gif 
T hello.c 
cvs tag: Tagging a-subdir 
T a-subdir/whatever.c 
cvs tag: Tagging a-subdir/subsubdir 
T a-subdir/subsubdir/fish.c 
cvs tag: Tagging b-subdir 
T b-subdir/random.c 
floss$  
@end example

Mientras, qsmith no necesita esperar que termine la fusi@'on para 
continuar el desarrollo si hace una etiqueta del conjunto de cambios 
que jrandom fusion@'o (m@'as tarde, jrandom necesitar@'a saber el nombre 
de esta etiqueta; en general las derivaciones dependen de una frecuente 
y completa comunicaci@'on entre los desarrolladores):

@example
paste$ cvs tag Exotic_Greetings-1 
cvs tag: Tagging . 
T README.txt 
T foo.gif 
T hello.c 
cvs tag: Tagging a-subdir 
T a-subdir/whatever.c 
cvs tag: Tagging a-subdir/subsubdir 
T a-subdir/subsubdir/fish.c 
cvs tag: Tagging b-subdir 
T b-subdir/random.c 
paste$ emacs a-subdir/whatever.c 
 ... 
paste$ cvs ci -m "print a randomly capitalized greeting" 
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.3.2.2; previous revision: 1.3.2.1 
done 
paste$  
@end example

Y por supuesto cuando qsmith haya hecho sus cambios tendr@'a que etiquetar:

@example
paste$ cvs -q tag Exotic_Greetings-2 
T README.txt 
T foo.gif 
T hello.c 
T a-subdir/whatever.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
paste$  
@end example

Mientras todo esto sucede jrandom hace un cambio en un fichero 
distinto, uno que qsmith no ha tocado en sus ediciones:

@example
floss$ emacs README.txt 
 ... 
floss$ cvs ci -m "Mention new Exotic Greeting features" README.txt 
Checking in README.txt; 
/usr/local/newrepos/myproj/README.txt,v  <--  README.txt 
new revision: 1.17; previous revision: 1.16 
done 
floss$  
@end example

En este momento qsmith ha entregado un nuevo cambio en su derivaci@'on 
y jrandom ha entregado otro cambio no conflictivo en un fichero 
distinto del tronco. Observe que sucede cuando jrandom trata de fusionar
desde la derivaci@'on de nuevo:

@example
floss$ cvs -q update -j Exotic_Greetings-branch 
RCS file: /usr/local/newrepos/myproj/README.txt,v 
retrieving revision 1.14 
retrieving revision 1.14.2.1 
Merging differences between 1.14 and 1.14.2.1 into README.txt 
rcsmerge: warning: conflicts during merge 
RCS file: /usr/local/newrepos/myproj/a-subdir/whatever.c,v 
retrieving revision 1.3 
retrieving revision 1.3.2.2 
Merging differences between 1.3 and 1.3.2.2 into whatever.c 
rcsmerge: warning: conflicts during merge 
RCS file: /usr/local/newrepos/myproj/b-subdir/random.c,v 
retrieving revision 1.1 
retrieving revision 1.1.1.1.2.1 
Merging differences between 1.1 and 1.1.1.1.2.1 into random.c 
floss$ cvs -q update 
C README.txt 
C a-subdir/whatever.c 
floss$  
@end example

¡Hay conflictos! ¿Esperaba esto?

El problema radica en el significado de fusionar. En @ref{Una introduccion 
a CVS} expliqu@'e que cuando usted ejecuta

@example
floss$ cvs update -j BRANCH 
@end example

en una copia de trabajo, CVS fusiona en la copia de trabajo las 
diferencias entre la raiz BRANCH y su estado actual. El problema con 
este comportamiento es que, en esta situaci@'on, la mayor@'{@dotless{i}}a de esos 
cambios ya hab@'{@dotless{i}}an sido incorporados al tronco la primera vez que jrandom
hizo una fusi@'on. Cuando CVS intent@'o fusionarlos de nuevo (sobre ellos 
mismos que es como estaban) se produce naturalmente un conflicto.

Lo que jrandom realmente quer@'{@dotless{i}}a hacer era fusionar en su copia de trabajo
los cambios entre la m@'as reciente fusi@'on del tronco con su estado actual. 
Usted puede hacer esto usando dos -j indicadores para actualizar, como 
deber@'{@dotless{i}}a recordar en @ref{Una introduccion a CVS}, siempre que sepa que 
revisi@'on corresponde con cada indicador. Afortunadamente qsmith hiz@'o una 
etiqueta exactamente en el @'ultimo punto de fusi@'on (¡hurra por planificar 
con antelaci@'on!), por lo que esto no ser@'a problema. Primero veamos como 
jrandom puede devolver su copia de trabajo un estado limpio, desde el 
que puede rehacer la fusi@'on:

@example
floss$ rm README.txt a-subdir/whatever.c 
floss$ cvs -q update 
cvs update: warning: README.txt was lost 
U README.txt 
cvs update: warning: a-subdir/whatever.c was lost 
U a-subdir/whatever.c 
floss$  
@end example

Ahora ella puede hacer la fusi@'on, usando la etiqueta colocada 
convenientemente por qsmith.

@example
floss$ cvs -q update -j Exotic_Greetings-1 -j Exotic_Greetings-branch 
RCS file: /usr/local/newrepos/myproj/a-subdir/whatever.c,v 
retrieving revision 1.3.2.1 
retrieving revision 1.3.2.2 
Merging differences between 1.3.2.1 and 1.3.2.2 into whatever.c 
floss$ cvs -q update 
M a-subdir/whatever.c 
floss$  
@end example

Mucho mejor. Los cambios de qsmith han sido incorporados a whatever.c;
jrandom puede hacer una entrega y etiquetado:


@example
floss$ cvs -q ci -m "merged again from Exotic_Greetings (1)"
Checking in a-subdir/whatever.c; 
/usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c 
new revision: 1.6; previous revision: 1.5 
done 
floss$ cvs -q tag merged-Exotic_Greetings-1 
T README.txt 
T foo.gif 
T hello.c 
T a-subdir/whatever.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
floss$  
@end example

Incluso si qsmith hubiese olvidado etiquetar en el punto de fusi@'on, 
las esperanzas no estar@'{@dotless{i}}a perdidas. Si jrandom supiese aproximadamente 
cuando hizo qsmith su primera entrega ella podr@'{@dotless{i}}a tratar de filtrar 
por la fecha:

@example
floss$ cvs update -j Exotic_Greetings-branch:3pm -j Exotic_Greetings_branch 
@end example

Aunque @'util como @'ultimo recurso, filtrar por fecha no es tan bueno 
porque selecciona los cambios basandose en los recuerdos de la gnete 
en vez de en designaciones que dependan del desarrollador. Si el primer 
conjunto de cambios fusionados de qsmith hubiera ocurrido en varias 
entregas en vez de s@'olo una jrandom pudiera equivocadamente elegir una 
fecha u hora que tomara algunos de los cambios, pero no todos.

No es necesario que cada punto etiquetado en los cambios de qsmith sea 
enviado al repositorio un una simple entrega. Ocurri@'o as@'{@dotless{i}} casualmente 
en el ejemplo. En la vida real, qsmith pudo haber hecho varias entregas 
entre cada etiquetado. @'El puede trabajar de forma aislada en su derivaci@'on 
tanto como quiera. La raz@'on de las etiquetas es registar sucesivos 
puntos en la derivaci@'on donde considere que los cambios deban ser 
fusionados con la rama principal. Siempre que jrandom fusione 
usando dos indicadores -j y sea cuidadoso al usar las etiquetas de 
ramificaci@'on de qsmith en el orden apropiado y una s@'ola vez por cada un 
la rama principal padecer el problema de la doble fusi@'on.

Podr@'{@dotless{i}}an ocurrir conflictos, pero @'estos ser@'{@dotless{i}}an de la inevitable clase que 
requiere resoluci@'on humana; situaciones en las que tanto el tronco como 
la derivaci@'on realizan cambios en la misma @'area de c@'odigo.

@c ----------------------------------------------------------------
@node La Aproximaci@'on de la Cola de Milano -- Fusionar dentro y fuera de la rama principal
@subsection La Aproximaci@'on de la Cola de Milano -- Fusionar dentro y fuera de la rama principal 

Fusionar repetidamente de derivaci@'on a tronco es bueno para la gente del 
tronco ya que ven todos sus cambios y los de la derivaci@'on. Sin embargo 
el desarrollador de la derivaci@'on no obtiene nunca los cambios producidos
en el tronco.

Para permitir esto el desarrollador de la derivaci@'on debe realizar un 
paso extra cuando tenga ganas de hacer una fusi@'on de los cambios m@'as 
recientes del tronco y resolver los inevitables conflictos que surgan:

@example
paste$ cvs update -j CABEZA
@end example

La etiqueta especial reservada @code{CABEZA} se@~nala el estado actual del 
tronco. La orden anterior fusiona en el tronco los cambios entre la raiz 
de la actual derivaci@'on (@code{Exotic_Greetings-branch}) y la revisi@'on 
m@'as alta de cada fichero del tronco. Por supuesto qsmith tiene que 
etiquetar de nuevo despu@'es de hacer esto para que los desarrolladores del 
tronco eviten accidentalmente fusionar sus propios cambios cuando 
intenten conseguir los de qsmith.

De la misma manera el desarrollador de la derivaci@'on puede usar las 
etiquetas de fusi@'on del tronco como l@'{@dotless{i}}mites, permitinedo a la derivaci@'on 
fusionar exactamente aquellos cambios entre la @'ultima fusi@'on y el estado
actual del tronco (de la misma manera que el tronco fusiona). Por 
ejemplo, supongamos que jrandom ha hecho algunos cambios a hello.c 
despu@'es de fusionar la derivaci@'on:
 
@example
floss$ emacs hello.c 
 ... 
floss$ cvs ci -m "clarify algorithm" hello.c 
Checking in hello.c; 
/usr/local/newrepos/myproj/hello.c,v  <--  hello.c 
new revision: 1.22; previous revision: 1.21 
done 
floss$  
@end example

Despu@'es puede qsmith fusionar esos cambios en el tronco, entregar, y,
por supuesto, etiquetar.

@example
paste$ cvs -q update -j merged-Exotic_Greetings-1 -j HEAD 
RCS file: /usr/local/newrepos/myproj/hello.c,v 
retrieving revision 1.21 
retrieving revision 1.22 
Merging differences between 1.21 and 1.22 into hello.c 
paste$ cvs -q update 
M hello.c 
paste$ cvs -q ci -m "merged trunk, from merged-Exotic_Greetings-1 to HEAD" 
Checking in hello.c; 
/usr/local/newrepos/myproj/hello.c,v  <--  hello.c 
new revision: 1.21.2.1; previous revision: 1.21 
done 
paste$ cvs -q tag merged-merged-Exotic_Greetings-1 
T README.txt 
T foo.gif 
T hello.c 
T a-subdir/whatever.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
paste$  
@end example

Observe que a jrandom no etiquet@'o despu@'es de entregar los cambios a 
hello.c pero si qsmith. El principio utilizado aqu@'{@dotless{i}} es que aunque usted 
no necesita etiquetar despu@'es de hacer cualquier pequeno cambio si 
deber@'{@dotless{i}}a hacerlo despu@'es de fusionar o entregar su l@'{@dotless{i}}nea de desarrollo
a un estado que permita la fusi@'on. De este modo otras personas, quiz@'a en 
otras derivaciones tienen un punto de referencia en el cual basarse para 
sus propias fusiones.

@c -------------------------------------------------------------------
@node La Aproximaci@'on del Pez Volador -- Una forma m@'as simple de hacerlo
@subsection La Aproximaci@'on del Pez Volador -- Una forma m@'as simple de hacerlo

Hay una variante m@'as simple, aunque un poco m@'as limitada, que la anterior.
En ella, los desarrolladores de la derivaci@'on se congelan o paran mientras 
el tronco se fusiona, y despu@'es los desarrolladores del tronco crean una 
nueva derivaci@'on, que reemplaza la anterior. Los desarrolladores de la 
antigua derivaci@'on cambian a esa nueva derivaci@'on y siguen trabajando. 
Este ciclo sigue hasta uqe no hay m@'as necesidad de desarrollo en la 
derivaci@'on. Funciona as@'{@dotless{i}} (supondremos que jrandom@@floss est@'a en el tronco 
y qsmith@@paste est@'e en la derivaci@'on como hasta ahora):
 

@example
floss$ cvs tag -b BRANCH-1 
paste$ cvs checkout -r BRANCH-1 myproj 
@end example

Tronco y derivaci@'on empiezan a funcionar y pasado un tiempo los 
desarrolladores deciden que tienen que fusionar la derivaci@'on en 
el tronco:

@example
paste$ cvs ci -m "committing all uncommitted changes" 
floss$ cvs update -j BRANCH-1 
@end example

Todos los cambios de la rama se fusionan y los desarrolladores paran 
su trabajo mientras que los desarrolladores del tronco resuelven 
cualquier conflicto, entregan, etiquetan y crean una nueva derivaci@'on:

@example
floss$ cvs ci -m "merged from BRANCH-1" 
floss$ cvs tag merged-from-BRANCH-1 
floss$ cvs tag -b BRANCH-2 
@end example

Ahora los desarrolladores de la derivaci@'on cambian sus copias de trabajo 
a la nueva derivaci@'on sabiendo que no perder@'an ning@'un cambio no 
entregado ya que estaban actualizados cuando la fusi@'on ocurri@'o ya la 
nueva derivaci@'on viene de un tronco que incorpora los cambios de la 
nueva derivaci@'on:

@example
paste$ cvs update -r BRANCH-2 
@end example

Y el ciclo contin@'ua del mismo modo indefinidamente; sustituya 
BRANCH-2 por BRANCH-1 y BRANCH-3 por BRANCH-2.

Llamo a esta t@'ecnica @dfn{Pez Volador} porque la derivaci@'on est@'a 
constantemente emergiendo del tronco, viajando una corta distancia y 
uni@'endose a @'el despu@'es. Las ventajas de esta aproximaci@'on son que 
es simple (el tronco siempre fusiona todos los cambios para una 
derivaci@'on dada) y los desarrolladores no tinene que resolver 
conflictos (cada vez trabajan con una nueva y limpia derivaci@'on). Las 
desventajas son que la gente de la derivaci@'on debe esperar sin poder
hacer nada hasta que se haya fusionado el tronco (que puede durar 
un tiempo arbitrario dependiendo de c@'omo haya que resolver los conflictos). 
Otra peque@~na desventaja es habr@'a muchas derivaciones sin usar en vez de 
etiquetas no_derivaci@'on. Si no le importa tener millones de peque@~nas y 
obsoletas derivaciones y puede anticipar claramente fusiones libres de 
problemas el Pez Volador pueda ser el modo m@'as f@'acil en t@'erminos mentales.

@c --------------------------------------------------------------------
@node Derivaciones y expansi@'on de palabras -- Enemigos naturales
@subsection Derivaciones y expansi@'on de palabras -- Enemigos naturales

Si sus ficheros contienen palabras de expansi@'on en RCS que se 
sustituyen de forma distinta en la derivaci@'on y en el tronco casi 
seguro que tendr@'a conflictos en las fusiones. Incluso si nada cambia
las palabras de expansi@'on se sobrepondr@'an y sus sustituciones no se podr@'an 
hacer. Por ejemplo; if README.txt contiene esto en el tronco

@example
$Revision: 1.4 $ 
@end example

y esto en la derivaci@'on

@example
$Revision: 1.4 $ 
@end example

entonces cuando sea realizada la fusi@'on obtendr@'a el siguiente conflicto:

@example
floss$ cvs update -j Exotic_Greetings-branch
RCS file: /usr/local/newrepos/myproj/README.txt,v
retrieving revision 1.14
retrieving revision 1.14.2.1
Merging differences between 1.14 and 1.14.2.1 into README.txt
rcsmerge: warning: conflicts during merge
floss$ cat README.txt
 ... 
<<<<<<< README.txt 
key $Revision: 1.4 $ 
======= 
key $Revision: 1.4 $ 
>>>>>>> 1.14.2.1 
 ... 
floss$  
@end example

Para evitar esto, usted puede temporalmente desabilitar la expansi@'on de 
palabras pasando la opci@'on -kk (No s@'e que significa; ¿"kill keywords" 
(mata palabras) quiz@'a?) cuando haga la fusi@'on:

@example
floss$ cvs update -kk -j Exotic_Greetings-branch 
RCS file: /usr/local/newrepos/myproj/README.txt,v 
retrieving revision 1.14 
retrieving revision 1.14.2.1 
Merging differences between 1.14 and 1.14.2.1 into README.txt 
floss$ cat README.txt 
 ... 
$Revision: 1.4 $ 
 ... 
floss$  
@end example

Tiene que tener cuidado con una cosa; si usa -kk, invalida cualquier 
otro modo de expansi@'on de palabras que pueda haber establecido para ese 
fichero. Espec@'{@dotless{i}}ficamente esto es un problema para los ficheros binarios 
que normalmente usan -kb (que suprime todas las palabras de expansi@'on 
y conversiones de fin de l@'{@dotless{i}}nea). Por lo tanto si tiene ficheros binarios
en una derivaci@'on no use -kk. Trate los conflictos manualmente.

@c ------------------------------------------------------------------
@node Vigilando fuentes de terceras partes (Derivaciones comerciales)
@section Vigilando fuentes de terceras partes (Derivaciones comerciales)

De vez en cuando un sitio pudiera hacer un cambio local al c@'odigo de 
un programa obtenido del exterior. Si la fuente exterior no incorpora 
los cambios locales (y habr@'{@dotless{i}}a muchas razones leg@'{@dotless{i}}timas para no hacerlo),
el sitio tiene que mantener sus cambios en cada actualizaci@'on del 
software.

CVS puede ayudar en esta tarea a trav@'es de una caracter@'{@dotless{i}}stica conocida 
como @dfn{derivaciones comerciales}. De hecho, derivaciones comerciales 
est@'a detr@'as de los ahora misteriosos dos finales argumentos de la orden 
@code{cvs import}; la etiqueta comercial y la de entrega final que vimos 
en @ref{Una introduccion a CVS}.

He aqu@'{@dotless{i}} como funciona. La importaci@'on inicial is como cualquier otra 
importaci@'on de un proyecto en CVS (excepto que tendr@'a que elegir la 
etiqueta comercial con un poco de cuidado):

@example
floss$ pwd 
/home/jrandom/theirproj-1.0 
floss$ cvs import -m "Import of TheirProj 1.0" theirproj Them THEIRPROJ_1_0
N theirproj/INSTALL 
N theirproj/README 
N theirproj/src/main.c 
N theirproj/src/parse.c 
N theirproj/src/digest.c 
N theirproj/doc/random.c 
N theirproj/doc/manual.txt 

No conflicts created by this import 

floss$  
@end example

Despu@'es debe obtener una copia de trabajo, hacer sus modificaciones 
locales y entregar:

@example
floss$ cvs -q co theirproj 
U theirproj/INSTALL 
U theirproj/README 
U theirproj/doc/manual.txt 
U theirproj/doc/random.c 
U theirproj/src/digest.c 
U theirproj/src/main.c 
U theirproj/src/parse.c 
floss$ cd theirproj 
floss$ emacs src/main.c src/digest.c 
 ... 
floss$ cvs -q update 
M src/digest.c 
M src/main.c 
floss$ cvs -q ci -m "changed digestion algorithm; added comment to main" 
Checking in src/digest.c; 
/usr/local/newrepos/theirproj/src/digest.c,v  <--  digest.c 
new revision: 1.2; previous revision: 1.1 
done 
Checking in src/main.c; 
/usr/local/newrepos/theirproj/src/main.c,v  <--  main.c 
new revision: 1.2; previous revision: 1.1 
done 
floss$  
@end example

Un a@~no m@'as tarde la siguiente versi@'on del programa llega de Ellos, S.A.,
y ustede debe incorporar sus cambios locales a ella. Los cambios de 
ellos y los suyos se sobreponen ligeramente. Ellos han a@~nadido un nuevo 
fichero, modificado un par de ficheros que usted no toc@'o y otros dos 
que usted si modific@'o.

Primero tiene que hacer otra importaci@'on para obtener las nuevas fuentes.
Casi todo estaba como en la importaci@'on inicial; usted est@'a importando el 
mismo proyecto del repositorio y de la misma derivaci@'on comercial. La 
@'unica diferencia es en la etiqueta de entrega final:

@example
floss$ pwd 
/home/jrandom/theirproj-2.0 
floss$ cvs -q import -m "Import of TheirProj 2.0" theirproj Them THEIRPROJ_2_0
U theirproj/INSTALL 
N theirproj/TODO 
U theirproj/README 
cvs import: Importing /usr/local/newrepos/theirproj/src 
C theirproj/src/main.c 
U theirproj/src/parse.c 
C theirproj/src/digest.c 
cvs import: Importing /usr/local/newrepos/theirproj/doc 
U theirproj/doc/random.c 
U theirproj/doc/manual.txt 

2 conflicts created by this import. 
Use the following command to help the merge: 

       cvs checkout -jThem:yesterday -jThem theirproj 

floss$  
@end example

Dios m@'{@dotless{i}}o; No hemos visto que CVS sea tan @'util. Nos est@'a diciendo que
orden ejecutar para fusionar los cambios. Y casi est@'a bien. En realidad 
el comando funciona (asumiendo que sustituye @code{yesterday} (ayer) por un 
intervalo de tiempo que incluya la primera primera importaci@'on pero no 
la segunda). Yo prefiero hacerlo mediante etiquetas de entrega final:

@example
floss$ cvs checkout -j THEIRPROJ_1_0 -j THEIRPROJ_2_0 theirproj 
cvs checkout: Updating theirproj 
U theirproj/INSTALL 
U theirproj/README 
U theirproj/TODO 
cvs checkout: Updating theirproj/doc 
U theirproj/doc/manual.txt 
U theirproj/doc/random.c 
cvs checkout: Updating theirproj/src 
U theirproj/src/digest.c 
RCS file: /usr/local/newrepos/theirproj/src/digest.c,v 
retrieving revision 1.1.1.1 
retrieving revision 1.1.1.2 
Merging differences between 1.1.1.1 and 1.1.1.2 into digest.c 
rcsmerge: warning: conflicts during merge 
U theirproj/src/main.c 
RCS file: /usr/local/newrepos/theirproj/src/main.c,v 
retrieving revision 1.1.1.1 
retrieving revision 1.1.1.2 
Merging differences between 1.1.1.1 and 1.1.1.2 into main.c 
U theirproj/src/parse.c 
floss$  
@end example

Observe como la importaci@'on nos indica que hay dos conflictos pero 
la fusi@'on parece ver s@'olo uno. Esto es porque la idea de conflicto 
en CVS es un poco diferente que en las otras ocasiones. B@'asicamente 
la importaci@'on informa de conflictos cuando usted y el distribuidor 
modifican un fichero entre la @'ultima importaci@'on y esta. Sin embargo, 
cuando se fusiona o actualiza la definici@'on de conflicto es la usual,
cambios que se sobreponen. Cambios que no se sobreponen son fusionados 
de la forma normal y el fichero se marca como modificado.

Un @code{diff} verifica que s@'olo uno de los ficheros tiene conflictos:


@example
floss$ cvs -q update 
C src/digest.c 
M src/main.c 
floss$ cvs diff -c 
Index: src/digest.c 
===================================================================
RCS file: /usr/local/newrepos/theirproj/src/digest.c,v 
retrieving revision 1.2 
diff -c -r1.2 digest.c 
*** src/digest.c        1999/07/26 08:02:18     1.2 
-- src/digest.c        1999/07/26 08:16:15 
*************** 
*** 3,7 **** 
-- 3,11 ---- 
 void 
 digest () 
 @{ 
+ <<<<<<< digest.c 
   printf ("gurgle, slorp\n"); 
+ ======= 
+   printf ("mild gurgle\n"); 
+ >>>>>>> 1.1.1.2 
 @} 
Index: src/main.c 
=================================================================== 
RCS file: /usr/local/newrepos/theirproj/src/main.c,v 
retrieving revision 1.2 
diff -c -r1.2 main.c 
*** src/main.c  1999/07/26 08:02:18     1.2 
-- src/main.c  1999/07/26 08:16:15 
*************** 
*** 7,9 **** 
-- 7,11 ---- 
 @{ 
   printf ("Goodbye, world!\n"); 
 @} 
+  
+ /* I, the vendor, added this comment for no good reason. */ 
floss$  
@end example

A partir de aqu@'{@dotless{i}} deber@'a resolver los conflictos como cualquier otra 
fusi@'on:

@example
floss$ emacs  src/digest.c  src/main.c 
 ... 
floss$ cvs -q update 
M src/digest.c 
M src/main.c 
floss$ cvs diff src/digest.c 
cvs diff src/digest.c  
Index: src/digest.c 
=================================================================== 
RCS file: /usr/local/newrepos/theirproj/src/digest.c,v 
retrieving revision 1.2 
diff -r1.2 digest.c 
6c6 
<   printf ("gurgle, slorp\n"); 
-- 
>   printf ("mild gurgle, slorp\n"); 
floss$  
@end example

Entones entregue los cambios

@example
floss$ cvs -q ci -m "Resolved conflicts with import of 2.0" 
Checking in src/digest.c; 
/usr/local/newrepos/theirproj/src/digest.c,v  <--  digest.c 
new revision: 1.3; previous revision: 1.2 
done 
Checking in src/main.c; 
/usr/local/newrepos/theirproj/src/main.c,v  <--  main.c 
new revision: 1.3; previous revision: 1.2 
done 
floss$  
@end example

y espere la pr@'oxima versi@'on del distribuidor. (Por supuesto tendr@'a que 
comprobar que sus antiguas modificaciones todav@'{@dotless{i}}a funcionan).

@c ---------------------------------------------------------------
@node Exportar para distribuci@'on p@'ublica
@section Exportar para distribuci@'on p@'ublica
@c @indexkff export command

CVS es un buen mecanismo de distribuci@'on para desarrolladores, pero la 
mayor@'{@dotless{i}}a de usuarios obtendr@'an el software a trav@'es de un paquete 
descargable. Este paquete normalmente no es una copia de trabajo de CVS;
es un @'arbol de c@'odigo que puede ser f@'acilmente configurado y compilado 
en el sistema del usuario.

Sin embargo, CVS ofrece un mecanismo que ayuda a crear ese paquete,
la orden @w{@code{cvs export}} (Exportar). @dfn{Exportar} un proyecto es 
como obtener una copia de trabajo del proyecto, excepto que se obtiene 
el directorio completo del proyecto @emph{sin} los subdirectorios 
administrativos. O sea, que no obtiene una copia de trabajo sino el c@'odigo 
fuente completo que no sabe nado sobre d@'onde vino o que versiones de CVS 
tienen sus ficheros. As@'{@dotless{i}} la copia exportada es como lo que el p@'ublico ve 
cuando descarga y desempaqueta un distribuci@'on. Asumiendo que el proyecto 
est@'a organizado para que sea directamente compilable desde la copia de 
trabajo (y as@'{@dotless{i}} es como deber@'{@dotless{i}}a estar), entonces todav@'{@dotless{i}}a ser@'a compilable 
en la copia exportada.

La orden @code{export} funciona igual que @code{checkout}, excepto que 
requiere una etiqueta o fecha. Por ejemplo, aqu@'{@dotless{i}} hemos etiquetado el 
proyecto con un nombre para el lanzamiento final y hemos exportado 
bas@'andonos en eso:


@example
floss$ pwd
/home/jrandom/myproj
floss$ cvs -q tag R_1_0
T README.txt
T hello.c
T a-subdir/whatever.c
T a-subdir/subsubdir/fish.c
T b-subdir/random.c
floss$ cd ..
floss$ cvs -d /usr/local/newrepos -q export -r R_1_0 -d myproj-1.0 myproj
U myproj-1.0/README.txt
U myproj-1.0/hello.c
U myproj-1.0/a-subdir/whatever.c
U myproj-1.0/a-subdir/subsubdir/fish.c
U myproj-1.0/b-subdir/random.c
floss$ cd myproj-1.0
floss$ ls
README.txt  a-subdir  b-subdir  hello.c
@end example

Observe que como la @code{export} no es llamada desde una copia de trabajo 
ha sido necesario usar la opci@'on global @code{-d} para decirle a CVS qu@'e 
repositorio usar. En este ejemolo en particular, adem@'as, exportamos a un 
directorio expl@'{@dotless{i}}citamente nombrado (@code{myproj-1.0}) en vez del 
directorio por defecto con el nombre del proyecto (@code{myproy}, porque 
ya hab@'{@dotless{i}}a una copia con ese nombre presente. Esta situaci@'on no es 
infrecuente.

Despu@'es de crear la copia mediante export, como en el ejemplo anterior, 
lo que sigue es suficiente para completar la entrega final si el 
proyecto es sencillo:

@example
floss$ tar cf myproj-1.0.tar myproj-1.0
floss$ gzip --best myproj-1.0.tar
floss$ ls
myproj/   myproj-1.0/   myproj-1.0.tar.gz
floss$ rm -rf myproj-1.0
floss$ mv myproj-1.0.tar.gz /home/ftp/pub/myproj/
@end example

Ejecutar todas estas @'ordenes a mano es raro. Lo normal es que 
@w{@code{cvs export}} sea llamada desde una rutina que maneje todos 
los aspectos de la entrega final y el proceso de empaquetado. Debido 
a que hay varias entregas de prueba antes del lanzamiento final es 
deseable que los procedimientos para crear un paquete se automatizen.

@c --------------------------------------------------------------------
@node El humilde gur@'u
@section El humilde gur@'u

Si usted ha leido y comprendido e incluso mejor, ha experimentado con
todo lo de este cap@'{@dotless{i}}tulo, puede asegurar que no le quedan muchas m@'as 
cosas en CVS por aprender; al menos hasta que alguien a@~nada una 
nueva e importante caracter@'{@dotless{i}}stica a CVS. Todo lo que necesita saber para 
usar CVS en un gran proyecto ha sido presentado.

Antes de que esto se le suba a la cabeza perm@'{@dotless{i}}tame insistir en la sugerencia, 
hecha ya en el cap@'{@dotless{i}}tulo 4, de que se suscriba a la lista de 
correo @email{info-cvs@@gnu.org}. A pesar de una proporci@'on de ruido 
com@'un a la mayor@'{@dotless{i}}a de listas de correo en Internet, lo bueno que le 
llega merece la pena esperarlo. He estado suscrito durante el tiempo que 
estuve escribiendo este cap@'{@dotless{i}}tulo y estar@'{@dotless{i}}a sorprendido de la cantidad de 
importantes de detalles que aprend@'{@dotless{i}} sobre el comportamiento de CVS 
leyendo los correos de otras personas. Si va a usar CVS seriamente y 
especialmente si usted es un administrador de CVS en un grupo de 
desarrolladores se puede beneficiar del conocimiento compartido 
entre todos los dem@'as usuarios serios que hay por ah@'{@dotless{i}}.






