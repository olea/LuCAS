@c ---------------------------------------------------------------------
@node Una introduccion a CVS
@unnumbered Una introduccion a CVS
@cindex overview
@cindex tutorial

@comment Este cap@'{@dotless{i}}tulo ha sido traducido por
@comment Javier Fern@'andez-Sanguino Pe@~na <jfs@@computer.org>
@comment y revisado por David Rey <david@@saug.org> .
@comment -
@comment Se ceden todos los derechos bajo la licencia de documentaci@'on de 
@comment la GNU (fdl) que se puede encontrar en http://www.gnu.org/

@quotation
@cartouche
@emph{No puedo imaginarme programar sin @'el.. ¡ser@'{@dotless{i}}a como saltar
en paraca@'{@dotless{i}}das sin un paraca@'{@dotless{i}}das!}

@center @emph{--Brian Fitzpatrick hablando de CVS}
@end cartouche
@end quotation

Este cap@'{@dotless{i}}tulo presenta los fundamentos en los que se basa CVS,
ofreciendo a continuaci@'on un recorrido detallado por el uso
cotidiano de CVS. Los conceptos se presentan de forma secuencial,
as@'{@dotless{i}} que si es Ud. un novato en CVS, la mejor manera de leer este
cap@'{@dotless{i}}tulo ser@'a empezar por el principio e ir ley@'endolo paso a paso,
sin saltarse nada.




@menu
* Conceptos B@'asicos::            C@'omo pensar en CVS.
* Un d@'{@dotless{i}}a con CVS::               Una sesi@'on de ejemplo.
* Otros comandos @'utiles de CVS:: Cosas de mayor o menor utilidad.
* Ramas::                        Separar el desarrollo en corrientes paralelas.
@end menu

@c ------------------------------------------------------------------
@node Conceptos B@'asicos
@section Conceptos B@'asicos

Si nunca ha usado antes CVS (o ning@'un otro sistema de control de
versiones), es f@'acil desconcertarse con algunas de las suposiciones
que @'este hace. Lo que parece causar m@'as confusi@'on inicialmente sobre
CVS, es que se usa para dos cosas que aparentemente no guardan relaci@'on
alguna: guardar registros, y al mismo tiempo hacer posible la colaboraci@'on.
Sin embargo, se da el caso de que estas dos funciones est@'an estrechamente
relacionadas.

Se hizo necesario guardar registros porque las personas quer@'{@dotless{i}}an comparar
el estado actual de un programa con el estado en el que encontraba en
un momento dado en el pasado. Por ejemplo, en el transcurso normal de la
implantaci@'on de una nueva funci@'on, un desarrollador puede llevar el
programa a un estado en el que resulta inutilizable, estado que
posiblemente perdurar@'a hasta que la implantaci@'on de la nueva funci@'on
est@'e casi hecha. Por desgracia, se da la casualidad de que @'este suele
ser precisamente el momento en el que alguien informa de un fallo en
la @'ultima versi@'on distribuida al p@'ublico; para solucionar el problema
(que podr@'{@dotless{i}}a estar tambi@'en presente en la versi@'on actual de las fuentes),
el programa ha de volver de nuevo a un estado utilizable.

Restaurar un estado determinado es tarea f@'acil si el historial del c@'odigo
fuente se mantiene bajo CVS. El desarrollador puede simplemente decir:
"Dame el programa tal como estaba hace tres semanas", o quiz@'as, "Dame
el programa en el estado en el que se encontraba en el momento de hacer
nuestra @'ultima distribuci@'on p@'ublica".  Si nunca ha disfrutado de este
c@'omodo acceso a "fotograf@'{@dotless{i}}as" hist@'oricas, posiblemente se sorprenda de
la rapidez con la que llegar@'a a depender de @'el. En mi caso, personalmente
ahora siempre uso control de revisiones en mis proyectos de programaci@'on,
puesto que es algo que me ha salvado en multitud de ocasiones.

Para comprender c@'omo est@'a @'esto relacionado con la colaboraci@'on, deberemos
observar con m@'as detalle el mecanismo ofrecido por CVS para ayudar a muchas
personas a trabajar en un mismo proyecto. Pero, antes de que lleguemos ah@'{@dotless{i}},
echemos un vistazo al mecanismo que CVS *no* proporciona (o que, por lo
menos, no fomenta): el bloqueo de ficheros. Si ha usado alg@'un otro sistema
de control de versiones, quiz@'as est@'e familiarizado con el modelo de
desarrollo bloquear-modificar-desbloquear, en el que un desarrollador
obtiene primero un acceso exclusivo de escritura (un bloqueo) sobre el
fichero que va a editar, hace los cambios, y a continuaci@'on elimina el
bloqueo para permitir que otros desarrolladores puedan acceder al fichero.
Si alguien tiene un bloqueo establecido sobre un fichero, esa persona
deber@'a "liberarlo" para que usted pueda bloquear el fichero y comenzar
a hacer sus cambios (en algunas implantaciones usted podr@'{@dotless{i}}a "robarle" el
bloqueo, pero con frecuencia esto viene a ser una desagradable sorpresa
para la otra persona, ¡y en ning@'un caso una pr@'actica aconsejable!).

Este sistema es factible cuando los desarrolladores se conocen, saben
qui@'en se propone hacer qu@'e en un momento dado, y pueden comunicarse
con los dem@'as r@'apidamente en caso de que alguien no pueda trabajar
por tener limitado su acceso. Sin embargo, si el grupo de desarrolladores
se hace demasiado grande o no es posible una comunicaci@'on fluida entre
ellos, gestionar cuestiones de bloqueo de ficheros comenzar@'a a restar
tiempo al desarrollo del c@'odigo, para convertirse en un problema constante
que puede ser contraproducente para el normal discurrir del proyecto.

CVS propone una soluci@'on intermedia: en lugar de obligar a los
desarrolladores a coordinarse entre s@'{@dotless{i}} para evitar conflictos, CVS
les permite editar el c@'odigo de forma simult@'anea, asume la tarea de
integrar todos los cambios, y guarda un registro de todos los conflictos
que vayan surgiendo. El proceso utiliza el modelo copiar-modificar-fusionar,
que viene a funcionar de la forma siguiente:

@enumerate

@item
El desarrollador A solicita a CVS una copia de trabajo, esto es,
un @'arbol de directorios que contiene los ficheros que conforman el
proyecto. Esta operaci@'on es tambi@'en conocida como "obtener una copia"
(comando "checkout"), y es como tomar un libro prestado de una biblioteca.

@item
El desarrollador A edita libremente su copia de trabajo. Al mismo
tiempo, otros desarrolladores pueden estar atareados con sus propias
copias de trabajo. Puesto que todas son copias separadas, no hay
interferencias: es como si todos los desarrolladores tuvieran su
propia copia del mismo libro, y todos estuvieran trabajando anotando
comentarios en los m@'argenes o reescribiendo determinadas p@'aginas de
forma independiente.

@item
El desarrollador A termina sus cambios y los env@'{@dotless{i}}a (comando "commit")
a CVS junto con un informe de cambios, que es un comentario que explica
la naturaleza y prop@'osito de los cambios que ha realizado. Esto es el
equivalente a informar a la biblioteca de los cambios que ha hecho al
libro y el porqu@'e de los mismos. Entonces, la biblioteca incorpora
estos cambios a la "copia maestra", donde se guardan de forma
permanente.

@item
Mientras tanto, y tambi@'en por medio de CVS, otros desarrolladores
pueden consultar a la biblioteca para ver si la copia maestra ha
cambiado recientemente, en cuyo caso CVS actualizar@'a autom@'aticamente
sus copias de trabajo personales. (Esta parte es m@'agica y maravillosa,
y espero que sepa apreciarla. ¡Imagine lo diferente que ser@'{@dotless{i}}a el mundo
si los libros de verdad funcionasen de esta forma!)


@end enumerate

Por lo que concierne a CVS, todos los desarrolladores de un proyecto son
iguales. La decisi@'on de cu@'ando actualizar o cu@'ando enviar al almac@'en es
un tema de preferencias personales o de pol@'{@dotless{i}}tica establecida entre los
miembros que participan en el proyecto. Una de las estrategias m@'as
comunes para proyectos de programaci@'on es la de siempre actualizar
antes de empezar a trabajar en un cambio importante, y enviar los
cambios s@'olo cuando @'estos hayan sido finalizados y probados, a fin
de que la copia principal se mantenga en todo momento en un estado
"ejecutable".

Quiz@'as se est@'e preguntando lo que ocurre cuando los desarrolladores A y B,
cada uno trabajando en su copia de trabajo personal, hacen distintos
cambios al mismo trozo de texto y despu@'es ambos env@'{@dotless{i}}an sus cambios.
Esto se conoce como @dfn{conflicto}, y CVS se percata del mismo en
cuanto el desarrollador B intenta enviar sus cambios: en lugar de
permitir que el desarrollador B proceda, CVS anuncia que ha descubierto
un conflicto y coloca marcadores de conflicto (marcas de texto f@'acilmente
reconocibles) en el lugar de su copia local donde se ha descubierto el
conflicto. En ese lugar se mostrar@'an ambos paquetes de cambios,
convenientemente ordenados para hacer f@'acil su comparaci@'on. El
desarrollador B deber@'a entonces solucionar el problema y enviar
una nueva revisi@'on con el conflicto resuelto. Quiz@'as los dos
desarrolladores deban hablar entre ellos para solucionar el problema;
CVS s@'olo avisa a los desarrolladores de que hay un conflicto, dejando
bajo su responsabilidad la tarea de resolverlo.

¿Y qu@'e hay de la copia maestra?  En terminolog@'{@dotless{i}}a oficial de CVS, se la
conoce como "repositorio" del proyecto, y es simplemente un @'arbol
de ficheros guardado en un servidor central. Sin entrar en mucho detalle
sobre su estructura (pero lea @ref{Administracion del Repositorio}), veamos
lo que el repositorio debe hacer para cumplir con los requisitos del
ciclo copiar-enviar-actualizar. Considere el siguiente caso:

@enumerate

@item
Dos desarrolladores, A y B, obtienen una copia de trabajo de un proyecto
al mismo tiempo. El proyecto se encuentra en su punto de partida: nadie
ha hecho todav@'{@dotless{i}}a cambio alguno, as@'{@dotless{i}} que todos los ficheros est@'an todav@'{@dotless{i}}a
en su estado original e impoluto.

@item
El desarrollador A empieza de inmediato a trabajar, y pronto env@'{@dotless{i}}a su
primer paquete de cambios.

@item
Mientras tanto, el desarrollador B est@'a viendo la televisi@'on.

@item
El desarrollador A, trabajando como si el mundo se acabase al d@'{@dotless{i}}a
siguiente, env@'{@dotless{i}}a su segundo paquete de cambios. En este momento, el
historial del repositorio contiene los ficheros originales, seguidos
por el primer paquete de cambios introducidos por A, que a su vez
han ido seguidos por estos @'ultimos cambios.

@item
Mientras tanto, el desarrollador B est@'a jugando a su videojuego favorito.


@item
De pronto, el desarrollador C se une al proyecto y obtiene su copia de
trabajo del repositorio. La copia del desarrollador C refleja los dos
primeros paquetes de cambios de A, puesto que ya estaban en el repositorio
cuando C obtuvo su copia.

@item
El desarrollador A, que ha estado programando como un poseso, completa
y env@'{@dotless{i}}a su tercer paquete de cambios.

@item
Por @'ultimo, e ignorando la actividad fren@'etica habida recientemente,
B decide que es hora de empezar a trabajar. No se molesta en actualizar
su copia; simplemente comienza a editar ficheros, algunos de los cuales
pueden ser ficheros en los que A ha estado trabajando. Un poco m@'as tarde,
el desarrollador B env@'{@dotless{i}}a sus primeros cambios.

@end enumerate

Llegados a este punto, pueden suceder dos cosas. Si ninguno de los
ficheros editados por B han sido editados por A, el env@'{@dotless{i}}o tiene @'exito.
Sin embargo, si CVS percibe que algunos de los ficheros de B est@'an
pasados de fecha con respecto a las @'ultimas copias disponibles en el
repositorio, y todos esos ficheros han sido tambi@'en cambiados por B en su
copia de trabajo, CVS informa a B de que debe hacer una actualizaci@'on
antes de enviar estos ficheros.

Cuando el desarrollador B efect@'ua la actualizaci@'on, CVS reune todos los
cambios realizados por A en la copia local de los ficheros de B. Parte
del trabajo de A puede entrar en conflicto con los cambios no enviados
por B, mientras que otros pueden no hacerlo. Aquellas partes que no lo
hacen son simplemente aplicadas en las copias de B, sin m@'as, pero los
cambios que supongan un conflicto deber@'an ser resueltos por B para poder
ser enviados.

Si el desarrollador C efect@'ua ahora una actualizaci@'on, recibir@'a del
repositorio algunos cambios nuevos, que ser@'an aqu@'ellos pertenecientes
al tercer env@'{@dotless{i}}o de A, y los pertenecientes al primero @emph{con @'exito} de B
(que en realidad podr@'{@dotless{i}}an proceder del segundo intento de B de enviar,
asumiendo que el primer intento de B tuviese como resultado el que B
se viera obligado a resolver alg@'un conflicto).

Para que CVS pueda servir los cambios en la secuencia correcta a los
desarrolladores cuyas copias de trabajo puedan no estar sincronizadas
en mayor o menor grado, el repositorio necesita guardar todos los env@'{@dotless{i}}os
recibidos desde el comienzo del proyecto. En la pr@'actica, el repositorio
de CVS los guarda todos en ficheros de diferencias (tambi@'en llamados "diffs")
sucesivos. As@'{@dotless{i}} pues, incluso para una copia de trabajo muy antigua, CVS
es capaz de establecer las diferencias entre la copia de trabajo y el
estado actual del repositorio, y es por tanto capaz de actualizar la copia
de trabajo de una forma eficiente. Esto hace que los desarrolladores puedan
en cualquier momento revisar f@'acilmente el historial del proyecto, y
conseguir copias de trabajo tan antiguas como sea necesario.

A pesar de que, estrictamente hablando, el repositorio podr@'{@dotless{i}}a conseguir
los mismos resultados por otros medios, en la pr@'actica guardar ficheros
de diferencias es una forma simple e intuitiva de implantar la
funcionalidad necesaria. Adem@'as, este m@'etodo tiene la ventaja a@~nadida
de que, usando apropiadamente el programa "patch", CVS puede reconstruir
cualquier estado previo del @'arbol de ficheros y, por tanto, llevar una
copia de trabajo de un estado a otro. Esto permite que cualquiera pueda
obtener una copia del proyecto tal y como era en un momento determinado,
a la vez que permite mostrar las diferencias, en formato diff, entre dos
estados del @'arbol sin afectar a la copia de trabajo de nadie.

Por lo tanto, las mismas funcionalidades que son necesarias para dar un
@'util acceso al historial del proyecto tambi@'en resultan @'utiles para
proporcionar a un grupo de desarrolladores descentralizado y descoordinado
la posibilidad de colaborar en el proyecto.

Por ahora, puede ignorar todos los detalles de c@'omo configurar un
repositorio, administrar el acceso a los usuarios, y navegar por formatos
de fichero espec@'{@dotless{i}}ficos de CVS (los cuales se cubrir@'an en @ref{Administracion 
del Repositorio}); de momento, nos centraremos en c@'omo hacer cambios en
una copia de trabajo.

Pero antes, aqu@'{@dotless{i}} va una r@'apida explicaci@'on de los t@'erminos:

@itemize

@item
@dfn{Revisi@'on} Un cambio aplicado y registrado en el historial de un fichero o
conjunto de ficheros. Una revisi@'on es una "instant@'anea" de un proyecto
que cambia constantemente.

@item
@dfn{Repositorio} La copia maestra en la que CVS guarda el historial de
revisiones al completo efectuadas en un proyecto. Cada proyecto tiene
exactamente *un* repositorio.

@item
@dfn{Copia de trabajo} La copia en la que puede de hecho hacer cambios
al proyecto. Puede haber muchas copias de trabajo de un proyecto
dado. Por regla general, cada desarrollador tiene su propia copia de
trabajo.

@item
@dfn{Obtener una copia} ("check out") Solicitar una copia de trabajo al
repositorio. Su copia de trabajo refleja el estado del proyecto en el
momento de obtenerla; cuando Ud. y otros desarrolladores hacen cambios,
deben enviarlos ("commit") y actualizarlos ("update") tanto para "publicar"
sus cambios como para ver los que han hecho los dem@'as.

@item
@dfn{Enviar} ("commit") Enviar cambios de su copia local al repositorio central.
Tambi@'en conocido como @dfn{check-in}.

@item
@dfn{Informe de cambios} Un comentario que se adjunta a una revisi@'on
cuando @'esta se env@'{@dotless{i}}a, describiendo los cambios realizados. Otros pueden
leer los informes de cambios para obtener un resumen de lo que ha estado
sucediendo en un proyecto.

@item
@dfn{Actualizar} ("update") Incorporar a su copia de trabajo los cambios que
otros han hecho y est@'an presentes en el repositorio, y comprobar si su copia
de trabajo tiene alg@'un cambio que no ha enviado todav@'{@dotless{i}}a. Tenga cuidado y
no confunda esto con el env@'{@dotless{i}}o; son operaciones complementarias. Recuerde,
lo que hace una actualizaci@'on es sincronizar su copia de trabajo con la
copia presente en el repositorio.

@item
@dfn{Conflicto} La situaci@'on que se da cuando dos desarrolladores intentan
enviar cambios que han hecho al mismo pasaje de un fichero. CVS se da cuenta
de ello e informa del conflicto, pero son los desarrolladores quienes
tienen que resolverlo.

@end itemize

@c ---------------------------------------------------------------------
@node Un d@'{@dotless{i}}a con CVS
@section Un d@'{@dotless{i}}a con CVS

Esta secci@'on describe algunas operaciones b@'asicas de CVS, para a continuaci@'on
presentarle un ejemplo de sesi@'on de trabajo que cubre el uso que suele
hacerse de CVS. A medida que vayamos avanzando por esta gu@'{@dotless{i}}a, empezaremos
tambi@'en a ver c@'omo funciona CVS interiormente.

Si bien no necesita comprender todos y cada uno de los detalles de CVS
para poder utilizarlo, unos conocimientos b@'asicos de c@'omo funciona le
ser@'an de inestimable ayuda a la hora de elegir la mejor forma de conseguir
un resultado. CVS se parece m@'as a una bicicleta que a un coche, en el
sentido de que sus mecanismos son completamente transparentes para quien
le interese examinarlos. Al igual que con una bicicleta, puede subirse
encima y empezar a pedalear inmediatamente; sin embargo, si se toma alg@'un
tiempo para aprender c@'omo funciona el cambio de marchas, ser@'a capaz de
utilizarlo de forma mucho m@'as eficaz. (En el caso de CVS, no estoy seguro
de si la transparencia fue un criterio de dise@~no deliberado o algo
accidental, pero parece que es una propiedad compartida con muchos otros
programas libres. Las implantaciones que son visibles desde fuera tienen
la ventaja de fomentar el que los usuarios contribuyan [a mejorar el
software], exponi@'endoles desde el primer momento el funcionamiento
interno del sistema.)

@ifnottex

Cada parte del recorrido har@'a uso de los conocimientos presentados en las
etapas anteriores. Por tanto, si @'esta es su primera vez, le recomiendo que
empiece por el principio y lea el texto de forma secuencial, sin saltarse
nada. El men@'u presentado abajo est@'a pensado para ser @'util para los
visitantes habituales -- no deber@'{@dotless{i}}a usarlo para acceder inmediatamente
a una secci@'on que le resulte de particular inter@'es a menos que est@'e
familiarizado con el material expuesto en las secciones anteriores.
@end ifnottex

@menu
* Convenciones empleadas en este Recorrido::
* Invocaci@'on de CVS::
* Acceder a un Repositorio::
* Comenzar un nuevo Proyecto::
* Obtener una copia de trabajo::
* Versi@'on vs. Revisi@'on::
* Hacer un cambio::
* Ver lo que Ud. (y otros) han hecho - comandos Update y Diff::
* CVS y argumentos impl@'{@dotless{i}}citos::
* Enviar cambios al repositorio::
* N@'umeros de revisi@'on::
* Detecci@'on y resoluci@'on de conflictos::
* Averiguar qui@'en hizo qu@'e (leyendo informes de cambios)::
* Examinar y deshacer cambios::
* El m@'etodo lento de deshacer cosas::
* El m@'etodo r@'apido de deshacer cosas::
@end menu

@c ---------------------------------------------------------------------
@node Convenciones empleadas en este Recorrido
@subsection Convenciones empleadas en este Recorrido

Este recorrido tiene lugar en un entorno UNIX. CVS tambi@'en funciona en
sistemas operativos Windows y Macintosh, y Tim Endres de Ice Engineering
ha escrito incluso un cliente en Java (v@'ease http://www.trustice.com/java/jcvs),
que puede ejecutarse en cualquier lugar donde corra Java. Sin embargo,
voy a suponer que la mayor@'{@dotless{i}}a de los usuarios de CVS -tanto actuales
como potenciales- est@'an seguramente trabajando en un entorno UNIX basado
en l@'{@dotless{i}}nea de comandos. Si usted no figura entre @'estos, los ejemplos en el
recorrido deber@'{@dotless{i}}an ser f@'aciles de adaptar a otros interfaces. Una vez
que entienda los conceptos, podr@'a sentarse delante de cualquier interfaz
de CVS y empezar a trabajar con @'el (cr@'eame, yo lo he hecho muchas veces).

Los ejemplos que se presentan en este recorrido est@'an orientados a
personas que van a usar CVS para trabajar en proyectos de programaci@'on.
Sin embargo, el uso de CVS es aplicable a todo tipo de documentos de
texto, no s@'olo a c@'odigo fuente.

Esta gu@'{@dotless{i}}a tambi@'en asume que tiene CVS ya instalado (por omisi@'on, est@'a ya
presente en muchos de los sistemas libres UNIX m@'as populares, as@'{@dotless{i}} que puede
que lo tenga ya instalado sin saberlo) y que ya dispone de acceso a un
repositorio. Incluso si no es as@'{@dotless{i}}, puede beneficiarse de la lectura de
esta gu@'{@dotless{i}}a. En @ref{Administracion del Repositorio}, aprender@'a c@'omo instalar
CVS y configurar repositorios.

Suponiendo que CVS est@'e ya instalado, deber@'{@dotless{i}}a tomarse un momento para
encontrar el manual de CVS en l@'{@dotless{i}}nea. Se conoce familiarmente como el
"Cederqvist" (tomando el apellido de Per Cederqvist, su autor original),
viene incluido con la fuente de CVS y viene a ser por lo general la
referencia m@'as actualizada que se encuentra disponible. Est@'a escrito
en formato Texinfo y deber@'{@dotless{i}}a estar disponible en sistemas Unix en la
jerarqu@'{@dotless{i}}a de documentaci@'on "Info". Puede leerlo con el programa de
de comandos "info":

@example
floss$ info cvs
@end example

o bien pulsando Ctrl+H y despu@'es escribiendo "i" (o Esc+x info) dentro de
Emacs. Si ninguno de estos m@'etodos funciona para usted, consulte a su
experto local en Unix (o mire @ref{Administracion del Repositorio} para los problemas
relacionados con la instalaci@'on). Seguramente querr@'a tener el Cederqvist
a mano si va a usar CVS regularmente.

@c ---------------------------------------------------------------------
@node Invocaci@'on de CVS
@subsection Invocaci@'on de CVS

CVS es un s@'olo programa, pero puede hacer muchas cosas diferentes:
actualizar, enviar, ramificar, diferenciar, etc.. Cuando invoque a CVS
deber@'a especificar qu@'e operaci@'on desea realizar. As@'{@dotless{i}} pues, el formato de
invocaci@'on de CVS viene a ser:

@example
floss$ cvs comando
@end example

Por ejemplo, puede usar


@example
floss$ cvs update
floss$ cvs diff
floss$ cvs commit
@end example

etc@'etera. (No se moleste de momento en intentar ejecutar ninguna de estas
@'ordenes, puesto que no har@'an nada mientras no disponga de una copia de
trabajo; pronto llegaremos a ese punto.)

Tanto CVS como sus comandos pueden admitir opciones. Las opciones que
afectan al comportamiento de CVS, independientemente del comando que se
ejecute, se llaman opciones globales, mientras que las opciones que son
espec@'{@dotless{i}}ficas de los comandos se llaman simplemente opciones de comando.
Las opciones globales siempre van a la izquierda del comando, mientras
que las opciones de comando van a la derecha. As@'{@dotless{i}}, en

@example
floss$ cvs -Q update -p
@end example

-Q es una opci@'on global, y -p es una opci@'on del comando. (Si siente
curiosidad, -Q significa "en silencio", es decir, esta opci@'on eliminar@'{@dotless{i}}a
toda salida de diagn@'ostico y mostrar@'{@dotless{i}}a los mensajes de error @'unicamente
si el comando no puede cumplir con su cometido por alguna raz@'on; por su
parte, -p forzar@'{@dotless{i}}a el env@'{@dotless{i}}o de los resultados de la actualizaci@'on a la
salida est@'andar, en lugar de hacerlo a los ficheros).

@c -----------------------------------------------------------------
@node Acceder a un Repositorio
@subsection Acceder a un Repositorio

Antes de hacer nada, deber@'a decirle a CVS d@'onde se encuentra el repositorio
al que desea acceder. Esto no es problema si ya ha obtenido una copia de
trabajo de ese repositorio, dado que cualquier copia de trabajo sabe de
qu@'e repositorio procede, con lo cual CVS puede deducir autom@'aticamente
el repositorio al que corresponde una copia de trabajo cualquiera. Sin
embargo, vamos a suponer que no dispone usted todav@'{@dotless{i}}a de una copia de
trabajo, as@'{@dotless{i}} que tiene que decirle a CVS expl@'{@dotless{i}}citamente d@'onde ir. Esto
se hace con la opci@'on global -d (de "directorio", una abreviatura
para la que hay una justificaci@'on hist@'orica, aunque la -r de "repositorio"
hubiera sido mejor), seguido por la senda que apunta al repositorio.

Por ejemplo, asumiendo que el repositorio se encuentra en el sistema local
en /usr/local/cvs (un lugar bastante est@'andar),

@example
floss$ cvs -d /usr/local/cvs comando
@end example

En muchos casos, sin embargo, el repositorio estar@'a en otra m@'aquina, y por
tanto deber@'a usar la red para llegar hasta @'el. CVS ofrece varios m@'etodos
de acceso; cu@'al de ellos ser@'a el que utilice es algo que depende
fundamentalmente de los requisitos de seguridad de la m@'aquina en la que
se encuentra alojado el repositorio (a la que, de ahora en adelante, nos
referiremos como "el servidor"). La configuraci@'on del servidor para permitir
varios m@'etodos de acceso remoto se comenta en @ref{Administracion del Repositorio}; aqu@'{@dotless{i}} trataremos
s@'olo la parte de cliente.

Afortunadamente, todos los m@'etodos de acceso remoto comparten una misma
sintaxis de invocaci@'on. En general, para especificar un repositorio remoto
y no uno local, lo que har@'a es utilizar una senda m@'as larga. Primero debe
indicar al m@'etodo de acceso, delimitado en cada lado por s@'{@dotless{i}}mbolos de dos
puntos, seguido del nombre de usuario y el nombre del servidor unidos por
el s@'{@dotless{i}}mbolo @@, otros dos puntos de separaci@'on, y, finalmente, la senda
del directorio del repositorio en el servidor.

Veamos el m@'etodo de acceso @dfn{pserver}, que significa "servidor autentificado
por clave":

@example
floss$ cvs -d :pserver:jluis@@cvs.foobar.com:/usr/local/cvs login
(Logging in to jluis@@cvs.foobar.com)
CVS password: (introduzca aqu@'{@dotless{i}} su contrase@~na de CVS)
floss$ 
@end example

La larga senda del repositorio que sigue a la opci@'on -d ha ordenado a
CVS que use el m@'etodo de acceso pserver, con el nombre de usuario jluis,
en el servidor cvs.foobar.com, que tiene un repositorio CVS en /usr/local/cvs.
Por cierto, no hay ninguna raz@'on para que el nombre del servidor sea
"cvs.algun_lugar.com"; esto es simplemente una convenci@'on com@'un, pero
podr@'{@dotless{i}}a haber sido tambi@'en:

@example
floss$ cvs -d :pserver:jluis@@fish.foobar.org:/usr/local/cvs comando
@end example

El comando que se ejecut@'o en nuestro ejemplo fue "login", que verifica
que dispone usted de autorizaci@'on para trabajar en este repositorio.
CVS le pedir@'a una contrase@~na, contactando a continuaci@'on con el servidor
para verificarla. Siguiendo la costumbre Unix, "cvs login" no devolver@'a
ninguna informaci@'on adicional si la operaci@'on tiene @'exito, aunque s@'{@dotless{i}}
mostrar@'a un mensaje de error si algo sale mal (por ejemplo, si la
contrase@~na es incorrecta).

S@'olo tiene que autentificarse una vez desde su m@'aquina local ante un
servidor CVS. Una vez que el proceso de autentificaci@'on tiene @'exito, CVS
guarda la contrase@~na en su directorio personal, en un fichero llamado
.cvspass. CVS consultar@'a este fichero cada vez que se conecte al repositorio
a trav@'es del m@'etodo pserver, as@'{@dotless{i}} que s@'olo tiene que ejecutar "login" la
primera vez que acceda a un determinado servidor de CVS desde un sistema
cliente particular. Por supuesto, puede volver a ejecutar cvs login en
cualquier momento, si por ejemplo se hubiera cambiado la contrase@~na.

Observaci@'on: pserver es en este momento el @'unico m@'etodo de acceso que
requiere un proceso de autentificaci@'on inicial como @'este; con el resto
de m@'etodos de acceso puede empezar a ejecutar comandos de CVS inmediatamente.

Una vez que ha guardado la informaci@'on de autentificaci@'on en su fichero
.cvspass, puede ejecutar otros comandos de CVS utilizando la misma
sintaxis en la l@'{@dotless{i}}nea de comando:

@example
floss$ cvs -d :pserver:jluis@@cvs.foobar.com:/usr/local/cvs comando
@end example

Hacer que pserver funcione en Windows puede requerir un paso adicional.
Windows carece del concepto Unix de un directorio personal, as@'{@dotless{i}} que CVS
no sabe d@'onde poner el fichero .cvspass; deber@'a especificar para ello un
lugar concreto. Generalmente se indica la ra@'{@dotless{i}}z de la unidad C: como el
directorio personal:

@example
C:\WINDOWS> set HOME=C: 
C:\WINDOWS> cvs -d :pserver:jluis@@cvs.foobar.com:/usr/local/cvs login 
(Logging in to jluis@@cvs.foobar.com) 
CVS password: (introduzca aqu@'{@dotless{i}} su contrase@~na)
C:\WINDOWS> 
@end example

Cualquier carpeta existente en la jerarqu@'{@dotless{i}}a de ficheros resultar@'a v@'alida,
aunque posiblemente prefiera evitar utilizar unidades de red, dado que el
contenido de su fichero .cvspass ser@'{@dotless{i}}a entonces visible para cualquiera
que pudiese acceder a esa unidad.

Adem@'as de pserver, CVS soporta tambi@'en los m@'etodos ext -que utiliza un
programa de conexi@'on externo. como rsh @'o ssh-, kserver -para el sistema
de seguridad Kerberos versi@'on 4-, y gserver, que usa el GSSAPI, esto es,
el API de Generic Security Services, y tambi@'en las versiones 5 y posteriores
de Kerberos. Todos estos m@'etodos son similares a pserver, si bien cada uno
presenta sus propias idiosincrasias.

De ellos, el m@'etodo @code{ext} es probablemente el que m@'as se usa
habitualmente. Si tiene la posibilidad de conectarse a un servidor
mediante rsh o ssh, puede usar el m@'etodo @code{ext}. Puede probarlo de
esta forma:

@example
floss$ rsh -l jluis cvs.foobar.com 
Password:  (introduzca aqu@'{@dotless{i}} su contrase@~na de usuario)
@end example

Bien, vamos a asumir que ha entrado y salido con @'exito del servidor
con rsh, as@'{@dotless{i}} que ahora est@'a de nuevo en el sistema cliente original:

@example
floss$ CVS_RSH=rsh; export CVS_RSH
floss$ cvs -d :ext:jluis@@cvs.foobar.com:/usr/local/cvs comando
@end example

La primera l@'{@dotless{i}}nea (empleando la sintaxis del shell Bourne de Unix) da a la
variable de entorno CVS_RSH el valor rsh, que le dice a CVS que utilice el
programa rsh para conectarse. La segunda l@'{@dotless{i}}nea puede ser cualquier comando
de CVS; se le solicitar@'a su contrase@~na para que CVS pueda conectarse con
el servidor.

Si est@'a en el shell C en lugar del shell Bourne, pruebe esto:


@example
floss% setenv CVS_RSH rsh
@end example

y para Windows, pruebe esto:

@example
C:\WINDOWS> set CVS_RSH=rsh
@end example

El resto de esta gu@'{@dotless{i}}a emplear@'a la sintaxis Bourne; adapte los ejemplos
a su entorno como necesite.


Para usar ssh (el shell seguro) en lugar de rsh, basta con que cree la
variable de entorno CVS_RSH de la forma apropiada:

@example
floss$ CVS_RSH=ssh; export CVS_RSH
@end example

No se eche a temblar por el hecho de que el nombre de la variable es
CVS_RSH y Ud. le est@'a dando el valor ssh. Hay razones hist@'oricas para
esto (la socorrida excusa Unix para todo, lo s@'e...). CVS_RSH puede apuntar
al nombre de cualquier programa capaz de conectarle a un servidor remoto,
ejecutar comandos y recibir su salida. Despu@'es de rsh, ssh es posiblemente
el programa m@'as com@'un que cumple estos requisitos, aunque probablemente
existan otros. Tenga en cuenta que este programa no debe modificar su flujo
de informaci@'on de ninguna manera. Esto deja fuera al rsh de Windows NT,
puesto que convierte (o intenta convertir) entre las convenciones de fin
de l@'{@dotless{i}}nea de DOS y Unix. En su caso, deber@'a conseguir alg@'un otro rsh para
Windows, o bien utilizar un m@'etodo de acceso distinto.

Los m@'etodos gserver y kserver no se utilizan tanto como los dem@'as y no
se cubren aqu@'{@dotless{i}}. Son bastante parecidos a lo que aqu@'{@dotless{i}} se ha cubierto
hasta ahora; para m@'as informaci@'on sobre ellos, lea el Cederqvist.

Si s@'olo utiliza un repositorio y no quiere estar constantemente tecleando
"-d repositorio", s@'olo tiene que crear la variable de entorno CVSROOT
(que quiz@'as deber@'{@dotless{i}}a haber sido llamada CVSREPOS, pero ya es demasiado
tarde para eso):

@example
floss$ CVSROOT=/usr/local/cvs 
floss$ export CVSROOT 
floss$ echo $CVSROOT 
/usr/local/cvs 
floss$ 
@end example

o quiz@'as

@example
floss$ CVSROOT=:pserver:jluis@@cvs.foobar.com:/usr/local/cvs 
floss$ export CVSROOT 
floss$ echo $CVSROOT 
:pserver:jluis@@cvs.foobar.com:/usr/local/cvs 
floss$ 
@end example

El resto de esta gu@'{@dotless{i}}a asume que ya ha creado la variable CVSROOT apuntando
a su repositorio favorito, as@'{@dotless{i}} que los ejemplos no mostrar@'an la opci@'on
-d. Si necesita acceder a muchos repositorios distintos, no deber@'{@dotless{i}}a crear
la variable CVSROOT, sino limitarse a usar "-d repositorio" para indicar
el repositorio a utilizar.

@c ---------------------------------------------------------------------
@node Comenzar un nuevo Proyecto
@subsection Comenzar un nuevo Proyecto

Si est@'a estudiando el manejo de CVS para trabajar en un proyecto que ya
se encuentra bajo control de CVS (es decir, que se guarda en un repositorio
en alguna parte), probablemente querr@'a saltarse esta parte e ir directamente
a la siguiente, "Obtener una copia de trabajo". Sin embargo, si lo que desea
es tomar un c@'odigo fuente ya existente y ponerlo bajo CVS, esta secci@'on es
para usted. F@'{@dotless{i}}jese en que, a pesar de todo, se asume que dispone de acceso
a un repositorio; vea @ref{Administracion del Repositorio} si necesita configurar un
repositorio.

Introducir un nuevo proyecto en un repositorio de CVS es lo que se conoce como
@dfn{importar}. El comando CVS a utilizar, como quiz@'as ya haya adivinado, es

@example
floss$ cvs import
@end example

excepto que le hacen falta m@'as opciones (y debe estar en el sitio
apropiado) para que el comando tenga @'exito. Primero, vaya al directorio
ra@'{@dotless{i}}z de su @'arbol de proyectos:

@example
floss$ cd miproyecto
floss$ ls
README.txt  a-subdir/   b-subdir/   hello.c
floss$
@end example

Este proyecto tiene dos ficheros (README.txt y hello.c) en el nivel
m@'as alto, adem@'as de dos subdirectorios (a-subdir y b-subdir), y algunos
ficheros m@'as (no mostrados en el ejemplo) dentro de esos subdirectorios.
Al importar un proyecto, CVS importa todo lo que hay en el @'arbol, empezando
por el directorio actual y yendo a continuaci@'on a todos los directorios que
haya por debajo de @'este. Por tanto, deber@'{@dotless{i}}a asegurarse de que s@'olo los
ficheros que hay en este momento en el @'arbol son los que desea que formen
parte del proyecto de forma permanente. Cualquier vieja copia de seguridad,
borrador, etc., deber@'{@dotless{i}}an ser eliminados antes.

La sintaxis general del comando de importaci@'on es

@example
floss$ cvs import -m "mensaje" miproyecto marca_suministrador marca_lanzamiento
@end example

La opci@'on -m (de "mensaje") sirve para especificar un breve informe
que describe la importaci@'on. @'Este ser@'a el primer informe de cambios
que afecta al proyecto en todo su conjunto; cada env@'{@dotless{i}}o realizado en
el futuro tendr@'a su propio informe de cambios. Estos informes son obligatorios;
si no se utiliza la opci@'on -m, CVS lanzar@'a autom@'aticamente un editor
(consultando previamente la variable de entorno EDITOR) para que escriba
en @'el el informe a utilizar. Una vez que guarde el informe en disco y
salga del editor, el proceso de importaci@'on seguir@'a adelante.

El siguiente argumento es el nombre del proyecto (usaremos "miproyecto").
@'Este es el nombre con el cual podr@'a obtener copias desde el repositorio.
(Lo que realmente sucede es que se crea un directorio con ese nombre en el
repositorio; encontrar@'a m@'as informaci@'on al respecto en @ref{Administracion del Repositorio}.)  El nombre
que elija no tiene por qu@'e ser igual al del directorio actual, aunque
en la mayor@'{@dotless{i}}a de los casos lo ser@'a.

Los argumentos marca_suministrador y marca_lanzamiento son informaci@'on de
registro adicional para CVS. No se preocupe de ellos ahora; poco importa
lo que utilice en este momento. En @ref{CVS avanzado} podr@'a ver las raras ocasiones
en las que son significativos; por ahora, utilizaremos un nombre de usuario y
"start" respectivamente para estos dos argumentos.

As@'{@dotless{i}} pues, ya estamos listos para utilizar import:

@example
floss$ cvs import -m "importaci@'on inicial a CVS" miproyecto jluis start
N miproyecto/hello.c
N miproyecto/README.txt
cvs import: Importing /usr/local/cvs/miproyecto/a-subdir
N miproyecto/a-subdir/loquesea.c
cvs import: Importing /usr/local/cvs/miproyecto/a-subdir/subsubdir
N miproyecto/a-subdir/subsubdir/fish.c
cvs import: Importing /usr/local/cvs/miproyecto/b-subdir
N miproyecto/b-subdir/random.c

No conflicts created by this import
floss$
@end example

¡Enhorabuena! Si ha ejecutado este comando (o algo similar), ya ha hecho por
fin algo que afecta al repositorio.

Observando la salida del comando import, se dar@'a cuenta de que CVS precede
cada nombre de fichero con una letra, en este caso la "N" para indicar que
se trata de un nuevo fichero. El uso de una letra a la izquierda para indicar
el estado de un fichero es algo com@'un en la salida de los comandos de CVS,
tal como veremos m@'as adelante tambi@'en con los comandos "update" y "checkout".

Llegados a este punto, podr@'{@dotless{i}}a pensar que, puesto que ha importado el proyecto,
puede empezar a trabajar en el @'arbol inmediatamente. @'Este, sin embargo, no es
el caso: el @'arbol de directorios actual no es todav@'{@dotless{i}}a una copia de trabajo de
CVS. Fue el origen para el comando de importaci@'on, cierto, pero no por @'eso se
ha convertido por arte de magia en una copia de trabajo de CVS: para obtener
una copia en la que poder trabajar, deber@'a tomarla del repositorio.

Pero antes, sin embargo, quiz@'as quiera archivar el @'arbol de directorios
actual. El motivo es que, una vez que las fuentes est@'an en CVS, no querr@'a
liarse y editar por error copias que no est@'an bajo control de versi@'on
(puesto que esos cambios no se convertir@'an en parte del historial del
proyecto). De ahora en adelante querr@'a hacer todas las ediciones sobre la
copia de trabajo. Por otra parte, no le interesar@'a eliminar completamente
el @'arbol que ha importado, puesto que no ha verificado todav@'{@dotless{i}}a si el
repositorio dispone realmente de todos los ficheros. Por supuesto, puede
estar un 99.999% seguro de que es as@'{@dotless{i}} dado que el comando de importaci@'on
no devolvi@'o ning@'un error, pero, ¿por qu@'e correr riesgos? A menudo vale la
pena ser paranoico, como puede confirmarle cualquier programador. As@'{@dotless{i}} que
haga algo como esto:

@example
floss$ ls
README.txt  a-subdir/   b-subdir/   hello.c
floss$ cd ..
floss$ ls
miproyecto/
floss$ mv miproyecto era_miproyecto
floss$ ls
era_miproyecto/
floss$
@end example

Hecho. Ahora sigue teniendo los ficheros originales, pero est@'an claramente
marcados como correspondientes a una versi@'on obsoleta, as@'{@dotless{i}} que no estar@'an
ah@'{@dotless{i}} estorb@'andole cuando obtenga una verdadera copia de trabajo. Ahora s@'{@dotless{i}},
por fin, est@'a listo para obtenerla.

@c ------------------------------------------------------------------
@node Obtener una copia de trabajo
@subsection Obtener una copia de trabajo

El comando para obtener un proyecto es exactamente el que cree que es:

@example
floss$ cvs checkout miproyecto
cvs checkout: Updating miproyecto 
U miproyecto/README.txt 
U miproyecto/hello.c 
cvs checkout: Updating miproyecto/a-subdir 
U miproyecto/a-subdir/loquesea.c 
cvs checkout: Updating miproyecto/a-subdir/subsubdir 
U miproyecto/a-subdir/subsubdir/fish.c 
cvs checkout: Updating miproyecto/b-subdir 
U miproyecto/b-subdir/random.c

floss$ ls 
miproyecto/      era_miproyecto/ 
floss$ cd miproyecto 
floss$ ls 
CVS/        README.txt  a-subdir/   b-subdir/   hello.c 
floss$ 
@end example

Guau... ¡su primera copia de trabajo! Su contenido es exactamente el
mismo que el que ha importado, con el a@~nadido de un subdirectorio
llamado "CVS". Ah@'{@dotless{i}} es donde CVS guarda la informaci@'on de control de
versiones. De hecho, cada directorio presente en el proyecto tiene un
subdirectorio CVS:

@example
floss$ ls a-subdir
CVS/        subsubdir/  loquesea.c 
floss$ ls a-subdir/subsubdir/ 
CVS/    fish.c 
floss$ ls b-subdir
CVS/      random.c
@end example

El hecho de que CVS guarde la informaci@'on de revisiones en subdirectorios
llamados CVS conlleva que su proyecto no puede tener nunca subdirectorios
propios llamados CVS. En la pr@'actica, nunca he o@'{@dotless{i}}do que esto supusiese un
problema.

Antes de editar ning@'un fichero, echemos una ojeada a la caja negra:

@example
floss$ cd CVS 
floss$ ls 
Entries     Repository  Root 
floss$ cat Root 
/usr/local/cvs 
floss$ cat Repository 
miproyecto 
floss$ 
@end example

Nada misterioso por aqu@'{@dotless{i}}. El fichero Root apunta al repositorio, y el fichero
Repository apunta a un proyecto dentro del repositorio. Si esto le parece un
poco confuso, perm@'{@dotless{i}}tame que se lo explique.

Hay una confusi@'on muy extendida sobre la terminolog@'{@dotless{i}}a empleada en CVS,
y es que la palabra "repositorio" se utiliza para hacer referencia a dos
cosas distintas. A veces, se utiliza para aludir al directorio ra@'{@dotless{i}}z del
repositorio (por ejemplo, /usr/local/cvs), que puede contener muchos
proyectos; esto es a lo que se refiere el fichero Root. Pero, otras veces,
se refiere a un subdirectorio particular espec@'{@dotless{i}}fico de un proyecto dentro
de la ra@'{@dotless{i}}z de un repositorio (por ejemplo /usr/local/cvs/miproyecto,
/usr/local/cvs/tuproyecto, o /usr/local/cvs/fish). El fichero "Repository"
dentro de un subdirectorio CVS toma el segundo significado.

En este libro, "repositorio" generalmente significa "ra@'{@dotless{i}}z", es decir, el
repositorio situado en el nivel m@'as alto, si bien, ocasionalmente, se
usar@'a para hacer referencia a un subdirectorio espec@'{@dotless{i}}fico de un proyecto.
Si el sentido que se le intenta dar no queda claro dentro del contexto,
habr@'a texto que lo clarifique. Tenga en cuenta que el fichero "Repository"
puede a veces contener la senda absoluta al nombre del proyecto en lugar
de una senda relativa. Esto hace un tanto redundante al fichero Root:

@example
floss$ cd CVS 
floss$ cat Root 
:pserver:jluis@@cvs.foobar.com:/usr/local/cvs 
floss$ cat Repository 
/usr/local/cvs/miproyecto 
floss$ 
@end example

El fichero "Entries" contiene informaci@'on sobre cada uno de los ficheros
que forman parte del proyecto. Cada l@'{@dotless{i}}nea se corresponde con un fichero,
y s@'olo hay l@'{@dotless{i}}neas para ficheros o subdirectorios en el directorio padre
inmediato. @'Este es el fichero CVS/Entries del directorio ra@'{@dotless{i}}z de miproyecto:

@example
floss$ cat Entries 
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999// 
/hello.c/1.1.1.1/Sun Apr 18 18:18:22 1999// 
D/a-subdir//// 
D/b-subdir////
@end example

El formato de cada l@'{@dotless{i}}nea es


@example
/nombre de fichero/n@'umero de revisi@'on/fecha de @'ultima modificaci@'on//
@end example

y las l@'{@dotless{i}}neas de directorios vienen precedidas de la letra "D". En realidad,
CVS no guarda un historial de los cambios realizados en los directorios,
as@'{@dotless{i}} que los campos de n@'umero de revisi@'on y fecha est@'an vac@'{@dotless{i}}os.

Las marcas de fecha guardan la fecha y hora de la @'ultima actualizaci@'on
(en horario universal, no local) de los ficheros presentes en la copia de
trabajo. De esta forma, CVS puede saber f@'acilmente si un fichero ha sido
modificado desde la @'ultima obtenci@'on de copia de trabajo, actualizaci@'on
o env@'{@dotless{i}}o. Si la fecha registrada por el sistema de ficheros difiere de la
fecha anotada en el fichero CVS/Entries, CVS sabe (sin ni siquiera tener que
consultar el repositorio) que el fichero ha sido probablemente modificado.

Si examina los ficheros CVS/* en uno de los subdirectorios

@example
floss$ cd a-subdir/CVS 
floss$ cat Root 
/usr/local/cvs 
floss$ cat Repository 
miproyecto/a-subdir 
floss$ cat Entries 
/loquesea.c/1.1.1.1/Sun Apr 18 18:18:22 1999// 
D/subsubdir//// 
floss$ 
@end example

ver@'a que el repositorio ra@'{@dotless{i}}z no ha cambiado, pero el fichero "Repository"
indica la situaci@'on de este subdirectorio dentro del proyecto, y el
fichero "Entries" contiene l@'{@dotless{i}}neas distintas.

Inmediatamente despu@'es de hacer una importaci@'on, el n@'umero de revisi@'on
de cada fichero en el proyecto se muestra como 1.1.1.1. Este n@'umero
inicial de revisi@'on es un caso un poco especial, as@'{@dotless{i}} que no lo veremos
en detalle a@'un; echaremos un vistazo m@'as de cerca a los n@'umeros de
revisi@'on una vez que hayamos hecho algunos cambios.

@c ------------------------------------------------------------------
@node Versi@'on vs. Revisi@'on
@subsection Versi@'on vs. Revisi@'on

El n@'umero interno de revisi@'on que CVS guarda para cada fichero no tiene
nada que ver con el n@'umero de versi@'on del producto del que los ficheros
forman parte. Por ejemplo, puede tener un proyecto formado por tres ficheros,
cuyos n@'umeros internos de revisi@'on a 3 de mayo de 1999 eran 1.2, 1.7 y 2.48.
Ese mismo d@'{@dotless{i}}a, empaqueta una nueva distribuci@'on del programa y la distribuye
como ChachiSoft Versi@'on 3. Esto es una decisi@'on puramente de marketing y no
afecta para nada a las revisiones de CVS. Los n@'umeros de revisi@'on de CVS
son invisibles para sus clientes (a menos que les d@'e acceso al repositorio);
el @'unico n@'umero visible al p@'ublico es el "3" de Versi@'on 3. Por lo que respecta
a CVS, podr@'{@dotless{i}}a haberlo llamado Versi@'on 1729 si lo desease; el n@'umero de versi@'on
(o de distribuci@'on) no tiene nada que ver con el seguimiento interno de
cambios que realiza CVS.

Para evitar confusiones, emplear@'e la palabra "revisi@'on" para referirme
solamente a los n@'umeros de revisi@'on interna de los ficheros controlados
por CVS. A pesar de ello, me tomar@'e la libertad de llamar a CVS un
"sistema de control de versiones", puesto que "sistema de control de
revisiones" suena demasiado pedante.

@c -------------------------------------------------------------------
@node Hacer un cambio
@subsection Hacer un cambio

El proyecto, tal y como est@'a en estos momentos, no hace mucho. Aqu@'{@dotless{i}} est@'an
los contenidos de hello.c:

@example
floss$ cat hello.c 
#include <stdio.h>

void 
main () 
@{
   printf ("¡Hola, mundo!\n"); 
@}
@end example

Ea, vamos a realizar nuestro primer cambio al proyecto desde que lo
importamos; vamos a a@~nadir la l@'{@dotless{i}}nea
  
@example
printf ("¡Adi@'os, mundo!\n");
@end example

justo despu@'es de "¡Hola, mundo!". Llame a su editor favorito y haga el
cambio:

@example
floss$ emacs hello.c
  ... 
@end example

@'Este ha sido un cambio relativamente sencillo, en el que es poco posible
que olvide lo que hizo. Pero en un proyecto m@'as amplio, y m@'as complejo,
es muy posible que se ponga a editar un fichero, sea interrumpido por otra
cosa, y, cuando vuelva varios d@'{@dotless{i}}as m@'as tarde, sea incapaz de recordar
exactamente lo que hizo, o incluso si cambi@'o algo en absoluto. Lo cual nos
trae a nuestra primera situaci@'on "CVS salva su vida": comparar su copia de
trabajo con la que se encuentra en el repositorio.

@c -----------------------------------------------------------------
@node Ver lo que Ud. (y otros) han hecho - comandos Update y Diff
@subsection Ver lo que Ud. (y otros) han hecho - comandos Update y Diff

Hasta ahora nos hemos referido a la "actualizaci@'on" como una forma de
traer a su copia de trabajo los cambios que se han realizado en el
repositorio, es decir, como una manera de obtener los cambios hechos
por otras personas. Sin embargo, la actualizaci@'on es un proceso algo
m@'as complejo que esto, puesto que compara el estado global de su copia
de trabajo con el estado del proyecto que se encuentra en el repositorio.
Incluso si nada ha cambiado en el repositorio desde que se obtuvo la
copia, puede que algo en la copia de trabajo s@'{@dotless{i}} lo haya hecho, y
"update" tambi@'en le mostrar@'a esto:

@example
floss$ cvs update 
cvs update: Updating . 
M hello.c 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir
@end example

La "M" al lado de hello.c significa que el fichero ha sido modificado
desde que se obtuvo la copia, y que las modificaciones no se han enviado
a@'un al repositorio.

A veces, todo lo que necesita es simplemente saber qu@'e ficheros ha
editado. Sin embargo, si desea echar un vistazo m@'as de cerca a los
cambios, puede solicitar un informe detallado en formato diff. El
comando diff compara los ficheros que puedan haberse modificado en
la copia de trabajo con sus hom@'onimos en el repositorio, mostrando
a continuaci@'on cualquier posible diferencia:


@example
floss$ cvs diff 
cvs diff: Diffing . 
Index: hello.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.1.1.1 
diff -r1.1.1.1 hello.c 
6a7 
>   printf ("¡Adi@'os, mundo!\n"); 
cvs diff: Diffing a-subdir 
cvs diff: Diffing a-subdir/subsubdir 
cvs diff: Diffing b-subdir
@end example

Aunque un poco liosa, esta informaci@'on es @'util, si bien todav@'{@dotless{i}}a hay un
mont@'on de ruido ah@'{@dotless{i}}. Para empezar, puede ignorar la mayor parte de las
l@'{@dotless{i}}neas del comienzo, dado que s@'olo hacen referencia al nombre del fichero
del repositorio e indican el n@'umero de la @'ultima revisi@'on enviada al mismo.
Son datos @'utiles en otras circunstancias (las veremos en detalle m@'as
adelante), pero no las necesita cuando s@'olo quiere hacerse una idea de
los cambios que se han hecho en la copia de trabajo.

Una molestia m@'as seria a la hora de leer el diff es que CVS anuncia su
entrada en escena a medida que va entrando en cada directorio durante la
actualizaci@'on. Esto puede ser @'util durante largas actualizaciones en
grandes proyectos, puesto que le da una idea del tiempo que va a necesitar
el comando, pero ahora mismo lo @'unico que hace es molestarle mientras
intenta interpretar lo que est@'a leyendo. As@'{@dotless{i}} pues, dig@'amosle a CVS que
no diga nada sobre su trabajo, con la opci@'on global -Q (de "Que te
calles", obviamente):

@example
floss$ cvs -Q diff 
Index: hello.c 
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.1.1.1 
diff -r1.1.1.1 hello.c 
6a7 
>   printf ("¡Adi@'os, mundo!\n");
@end example

Mejor - al menos, parte del ruido ha desaparecido. Sin embargo, el diff
es a@'un dif@'{@dotless{i}}cil de leer. Le est@'a diciendo que en la l@'{@dotless{i}}nea 6 se a@~nadi@'o una
l@'{@dotless{i}}nea nueva (que se convirti@'o en la l@'{@dotless{i}}nea 7) cuyo contenido es:

@example
printf ("¡Adi@'os, mundo!\n");
@end example

El signo ">" que precede a la l@'{@dotless{i}}nea en el diff le dice que esta l@'{@dotless{i}}nea est@'a
presente en la nueva versi@'on del fichero, pero no en la antigua.

Sin embargo, el formato podr@'{@dotless{i}}a ser a@'un m@'as legible. Muchas personas
encuentran el formato "de contexto" de diff m@'as f@'acil de leer, porque
muestra menos l@'{@dotless{i}}neas de contexto delimitando los cambios. Los diffs de
contexto pueden generarse pasando a diff la opci@'on -c:

@example
floss$ cvs -Q diff -c 
Index: hello.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.1.1.1 
diff -c -r1.1.1.1 hello.c 
*** hello.c     1999/04/18 18:18:22     1.1.1.1 
--- hello.c     1999/04/19 02:17:07 
*************** 
*** 4,7 **** 
---4,8 -- 
  main () 
  @{
    printf ("¡Hola, mundo!\n"); 
+   printf ("¡Adi@'os, mundo!\n"); 
  @}
@end example

¡Esto s@'{@dotless{i}} est@'a claro! Incluso si no est@'a acostumbrado a leer diffs de
contexto, un vistazo a esta informaci@'on mostrar@'a de forma bastante
obvia lo que ha sucedido: se a@~nadi@'o una nueva l@'{@dotless{i}}nea (el + en la primera
columna significa que se ha a@~nadido una l@'{@dotless{i}}nea) entre la l@'{@dotless{i}}nea que
imprime "¡Hola, mundo!" y la llave final.

No es necesario que seamos capaces de interpretar perfectamente los diffs
de contexto (esto es trabajo para el programa "patch"), pero le ser@'a @'util
tomarse un tiempo para adquirir al menos una cierta familiaridad con el
formato. Las primeras dos l@'{@dotless{i}}neas (despu@'es del rollo del comienzo) son

@example
*** hello.c     1999/04/18 18:18:22     1.1.1.1 
--- hello.c     1999/04/19 02:17:07
@end example

y le dicen qu@'e se est@'a comparando con qu@'e. En este caso, la revisi@'on
1.1.1.1 de hello.c se est@'a comparando con una versi@'on modificada del
mismo fichero (motivo por el cual no aparece n@'umero alguno de revisi@'on
en la segunda l@'{@dotless{i}}nea, porque los cambios de la copia de trabajo no se
han enviado todav@'{@dotless{i}}a al repositorio). Las l@'{@dotless{i}}neas de asteriscos y guiones
identifican secciones situadas m@'as adelante en el fichero de diferencias.
M@'as adelante, una l@'{@dotless{i}}nea de asteriscos seguida de una franja de valores
precede a una secci@'on del fichero original. Despu@'es, una l@'{@dotless{i}}nea de guiones,
con una franja de n@'umeros de l@'{@dotless{i}}nea nuevos y potencialmente distintos,
precede a una secci@'on del fichero modificado. Estas secciones est@'an
organizadas por pares: por un lado la parte del fichero antiguo, y por
otro lado la parte del fichero nuevo.

Nuestro fichero de diferencias tiene uno de estos pares:


@example
*************** 
*** 4,7 **** 
--- 4,8 -- 
  main () 
  @{ 
    printf ("¡Hola, mundo!\n"); 
+   printf ("¡Adi@'os, mundo!\n"); 
  @}
@end example

La primera secci@'on del par est@'a vac@'{@dotless{i}}a, lo que significa que no se ha
eliminado nada del fichero original. La segunda secci@'on indica que, en
el lugar correspondiente del nuevo fichero, se ha a@~nadido una nueva
l@'{@dotless{i}}nea, que aparece marcada con un signo "+". (Cuando el diff cita partes
de ficheros, se reserva las primeras dos columnas a la izquierda para c@'odigos
especiales, como el "+", as@'{@dotless{i}} que el trozo entero aparenta estar justificado
a la izquierda con dos espacios. Esta justificaci@'on extra desaparece, por
supuesto, cuando se aplica el fichero de diferencias.)

La franja de n@'umeros de l@'{@dotless{i}}neas muestra el alcance del par de diferencias,
incluyendo l@'{@dotless{i}}neas de contexto. En el fichero original, el par estaba en las
l@'{@dotless{i}}neas 4 a la 7; en el nuevo fichero, son las l@'{@dotless{i}}neas 4 a la 8 debido a la
nueva l@'{@dotless{i}}nea que se ha a@~nadido. F@'{@dotless{i}}jese en que el fichero de diferencias no
necesita ense@~nar ninguna cosa del fichero original puesto que no se ha
eliminado nada; s@'olo nos ha mostrado la franja afectada y ha continuaci@'on
ha saltado a la segunda secci@'on del par de diferencias.

Aqu@'{@dotless{i}} hay otro diff de contexto, procedente esta vez de un proyecto real m@'{@dotless{i}}o:

@example
floss$ cvs -Q diff -c 
Index: cvs2cl.pl 
=================================================================== 
RCS file: /usr/local/cvs/kfogel/code/cvs2cl/cvs2cl.pl,v 
retrieving revision 1.76 
diff -c -r1.76 cvs2cl.pl 
*** cvs2cl.pl   1999/04/13 22:29:44     1.76 
--- cvs2cl.pl   1999/04/19 05:41:37 
*************** 
*** 212,218 **** 
          # can contain uppercase and lowercase letters, digits, '-', 
          # and '_'. However, it's not our place to enforce that, so 
          # we'll allow anything CVS hands us to be a tag: 
!         /^\s([^:]+): ([0-9.]+)$/;
          push (@@@{$symbolic_names@{$2@}@}, $1);
        @}
      @}
-- 212,218 --
          # can contain uppercase and lowercase letters, digits, '-',
          # and '_'. However, it's not our place to enforce that, so
          # we'll allow anything CVS hands us to be a tag:
!         /^\s([^:]+): ([\d.]+)$/;
          push (@@@{$symbolic_names@{$2@}@}, $1);
        @}
      @}
@end example

El signo de exclamaci@'on indica que la l@'{@dotless{i}}nea marcada difiere del fichero
antiguo al nuevo. Dado que no hay ning@'un signo "+" o "-", sabemos que el
n@'umero total de l@'{@dotless{i}}neas del fichero sigue siendo el mismo.

@'Estas son otras diferencias de contexto del mismo proyecto, esta vez un poco
m@'as complejas:

@example
floss$ cvs -Q diff -c 
Index: cvs2cl.pl 
=================================================================== 
RCS file: /usr/local/cvs/kfogel/code/cvs2cl/cvs2cl.pl,v 
retrieving revision 1.76 
diff -c -r1.76 cvs2cl.pl 
*** cvs2cl.pl   1999/04/13 22:29:44     1.76 
--- cvs2cl.pl   1999/04/19 05:58:51 
*************** 
*** 207,217 **** 
@}
        else    # we're looking at a tag name, so parse & store it
        @{
-         # According to the Cederqvist manual, in node "Tags", "Tag
-         # names must start with an uppercase or lowercase letter and
-         # can contain uppercase and lowercase letters, digits, '-',
-         # and '_'. However, it's not our place to enforce that, so
-         # we'll allow anything CVS hands us to be a tag:
          /^\s([^:]+): ([0-9.]+)$/;
          push (@@@{$symbolic_names@{$2@}@}, $1);
        @}
- 207,212 --
***************
*** 223,228 ****
--- 218,225 --
      if (/^revision (\d\.[0-9.]+)$/) @{
        $revision = "$1";
      @}
+ 
+     # Esta l@'{@dotless{i}}nea ha sido a@~nadida, lo admito, s@'olo para este ejemplo de diff.
  
      # If have file name but not time and author, and see date or
      # author, then grab them:
@end example

Este fichero diff tiene dos pares de diferencias. En el primero se han
eliminado cinco l@'{@dotless{i}}neas (estas l@'{@dotless{i}}neas se muestran s@'olo en la primera
secci@'on del par, y la cuenta de l@'{@dotless{i}}neas de la segunda secci@'on indica que
tiene menos l@'{@dotless{i}}neas).  Una l@'{@dotless{i}}nea continua de asteriscos hace las veces de
delimitador entre pares, y en el segundo par vemos que se han a@~nadido dos
l@'{@dotless{i}}neas: una l@'{@dotless{i}}nea en blanco y un comentario in@'util. Observe c@'omo los n@'umeros
de l@'{@dotless{i}}nea compensan el efecto del par anterior. En el fichero original, la
franja del segundo par iba desde 223 hasta 228; en el nuevo fichero,
dado que la eliminaci@'on tuvo lugar en el primer par, la franja de l@'{@dotless{i}}neas
abarca desde la 218 hasta la 225.

Enhorabuena, en este momento tiene posiblemente toda la experiencia que
necesita para poder interpretar ficheros de diferencias.

@c --------------------------------------------------------------------
@node CVS y argumentos impl@'{@dotless{i}}citos
@subsection CVS y argumentos impl@'{@dotless{i}}citos

En cada uno de los comandos de CVS explicados hasta el momento, quiz@'as
se haya dado cuenta de que no hemos indicado fichero alguno en la l@'{@dotless{i}}nea
de comando. Por ejemplo, hemos utilizado

@example
floss$ cvs diff
@end example

en lugar de

@example
floss$ cvs diff hello.c
@end example

y

@example
floss$ cvs update
@end example

en lugar de 

@example
floss$ cvs update hello.c
@end example

El principio que dicta esto es que si usted no indica ning@'un nombre de
fichero, CVS actuar@'a sobre todos los ficheros sobre los que el comando
resultar@'{@dotless{i}}a apropiado. Esto incluye tambi@'en ficheros en subdirectorios
situados por debajo del directorio actual; CVS autom@'aticamente desciende
desde el directorio actual hasta cada subdirectorio en el @'arbol. Por
ejemplo, si modific@'o b-subdir/random.c y a-subdir/subsubdir/fish.c,
invocar una actualizaci@'on podr@'{@dotless{i}}a devolver unos resultados como @'estos:

@example
floss$ cvs update 
cvs update: Updating . 
M hello.c 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
M a-subdir/subsubdir/fish.c 
cvs update: Updating b-subdir 
M b-subdir/random.c 
floss$ 
@end example

o mejor a@'un:

@example
floss$ cvs -q update 
M hello.c 
M a-subdir/subsubdir/fish.c 
M b-subdir/random.c 
floss$ 
@end example

Nota: La opci@'on -q es una versi@'on "ligera" de -Q. Si se hubiera usado -Q,
el comando no habr@'{@dotless{i}}a mostrado nada en absoluto, porque las notas de
modificaci@'on son consideradas mensajes de informaci@'on no esenciales.
La versi@'on en min@'usculas, -q, es menos estricta: suprime los mensajes
que posiblemente no queramos, a la vez que permite que otros mensajes,
posiblemente m@'as @'utiles, s@'{@dotless{i}} lleguen hasta nosotros.


Tambi@'en puede nombrar ficheros espec@'{@dotless{i}}ficos que desee actualizar:

@example
floss$ cvs update hello.c b-subdir/random.c  
M hello.c 
M b-subdir/random.c 
floss$ 
@end example

y CVS s@'olo examinar@'a estos ficheros, ignorando cualquier otro.

Lo cierto es que es m@'as habitual no limitar la actualizaci@'on a
determinados ficheros, puesto que en la mayor@'{@dotless{i}}a de los casos querr@'a
actualizar el @'arbol de directorios al completo de una sola vez. En todo
caso, recuerde que las actualizaciones que hacemos aqu@'{@dotless{i}} a modo de ejemplo
s@'olo muestran que algunos ficheros se han modificado de forma local, porque
a@'un no se ha cambiado nada en el repositorio. Cuando otras personas est@'an
trabajando en el mismo proyecto que usted, siempre existe la posibilidad de
que la actualizaci@'on incorpore algunos cambios nuevos del repositorio en
sus ficheros locales, en cuyo caso s@'{@dotless{i}} puede resultarle @'util indicar los
ficheros en concreto que desea actualizar.

El mismo principio puede aplicarse a otros comandos de CVS. Por ejemplo,
con diff, puede ver los cambios habidos en un fichero cada vez:

@example
floss$ cvs diff -c b-subdir/random.c  
Index: b-subdir/random.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 random.c
*** b-subdir/random.c   1999/04/18 18:18:22     1.1.1.1
--- b-subdir/random.c   1999/04/19 06:09:48
***************
*** 1 ****
! /* Un fichero en C completamente vac@'{@dotless{i}}o. */
--- 1,8 --
! /* Imprimir un n@'umero aleatorio. */
! 
! #include <stdio.h>
! 
! void main ()
! @{
!   printf ("un n@'umero aleatorio\n");
! @}
@end example

o ver todos los cambios de una sola vez (ag@'arrese al asiento, esto va a ser un
diff bastante grande): 

@example
floss$ cvs -Q diff -c
Index: hello.c
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 hello.c
*** hello.c     1999/04/18 18:18:22     1.1.1.1
--- hello.c     1999/04/19 02:17:07
***************
*** 4,7 ****
--- 4,8 --
  main ()
  @{
    printf ("¡Hola, mundo!\n");
+   printf ("¡Adi@'os, mundo!\n");
  @}
Index: a-subdir/subsubdir/fish.c
===================================================================
RCS file: /usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 fish.c
*** a-subdir/subsubdir/fish.c   1999/04/18 18:18:22     1.1.1.1
--- a-subdir/subsubdir/fish.c   1999/04/19 06:08:50
***************
*** 1 ****
! /* Un fichero en C completamente vac@'{@dotless{i}}o. */
--- 1,8 --
! #include <stdio.h>
! 
! void main ()
! @{
!   while (1) @{
!     printf ("fish\n");
!   @}
! @}
Index: b-subdir/random.c
===================================================================
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 random.c
*** b-subdir/random.c   1999/04/18 18:18:22     1.1.1.1
--- b-subdir/random.c   1999/04/19 06:09:48
***************
*** 1 ****
! /* Un fichero en C completamente vac@'{@dotless{i}}o. */
--- 1,8 --
! /* Imprimir un n@'umero aleatorio. */
! 
! #include <stdio.h>
! 
! void main ()
! @{
!   printf ("un n@'umero aleatorio\n");
! @}
@end example

En cualquier caso, como puede ver en estos diffs, queda claro que el proyecto
est@'a listo para debutar. Enviemos los cambios al repositorio.

@c -------------------------------------------------------------------
@node Enviar cambios al repositorio
@subsection Enviar cambios al repositorio

El comando @dfn{commit} env@'{@dotless{i}}a las modificaciones al repositorio. Si no indica
ning@'un fichero, el comando enviar@'a todos los cambios al repositorio; sin
embargo, si as@'{@dotless{i}} lo prefiere, puede indicarle el nombre de uno o m@'as ficheros
concretos a enviar, en cuyo caso el resto de los ficheros ser@'an ignorados.

Aqu@'{@dotless{i}} enviamos un fichero nombr@'andolo expresamente, y otros dos por alusiones:

@example
floss$ cvs commit -m "ahora tambi@'en dice adi@'os" hello.c
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <--  hello.c
new revision: 1.2; previous revision: 1.1
done
floss$ cvs commit -m "a@~nadido c@'odigo C"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in a-subdir/subsubdir/fish.c;
/usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v  <--  fish.c
new revision: 1.2; previous revision: 1.1
done
Checking in b-subdir/random.c;
/usr/local/cvs/miproyecto/b-subdir/random.c,v  <--  random.c
new revision: 1.2; previous revision: 1.1
done
floss$ 
@end example

Det@'engase un momento a leer la salida detenidamente. La mayor parte de
lo que dice se explica por s@'{@dotless{i}} solo. Una cosa de la que tal vez se d@'e
cuenta es que los n@'umeros de revisi@'on se han incrementado (como era de
esperar), pero las revisiones originales se listan como 1.1 en
lugar de 1.1.1.1 como vimos anteriormente para el caso del fichero
Entries.

Hay una explicaci@'on para esta discrepancia, pero no es muy importante,
y tiene que ver con un significado especial que CVS da a la revisi@'on
1.1.1.1: en la mayor parte de los casos, podemos decir simplemente que
los ficheros reciben un n@'umero de revisi@'on 1.1 al hacer una importaci@'on,
pero, -por motivos que s@'olo CVS conoce- el n@'umero aparece como 1.1.1.1
en el fichero Entries hasta que el fichero es enviado al repositorio
por primera vez.

@c -----------------------------------------------------------------
@node N@'umeros de revisi@'on
@subsection N@'umeros de revisi@'on

Cada fichero en un proyecto tiene su propio n@'umero de revisi@'on. Cuando
un fichero es enviado al repositorio, la @'ultima parte del n@'umero de revisi@'on
se incrementa en una unidad. Por tanto, los diferentes ficheros que forman
parte de un proyecto pueden tener siempre n@'umeros de revisi@'on (a veces
muy) diferentes. Esto s@'olo significa que algunos ficheros han sido
modificados (e incorporados en el repositorio) con m@'as frecuencia que
otros.

En este momento quiz@'as se pregunte qu@'e sentido tiene la parte situada a
la izquierda del punto decimal, cuando la @'unica parte que cambia es la
situada a la derecha. Pues bien, a pesar de que CVS nunca incrementa
autom@'aticamente el n@'umero situado a la izquierda, este n@'umero puede ser
incrementado a petici@'on del usuario. Esto es algo que se usa en muy
contadas ocasiones, y no lo cubriremos en esta gu@'{@dotless{i}}a.

Volviendo al tema, en el proyecto de ejemplo que hemos estado usando,
acab@'abamos de enviar al repositorio los cambios que hab@'{@dotless{i}}amos realizado
en tres ficheros. Cada uno de estos ficheros es ahora la revisi@'on 1.2,
pero el resto de ficheros del proyecto son a@'un la revisi@'on 1.1. Cuando
usted solicita al repositorio una copia de un proyecto, siempre obtiene
la @'ultima revisi@'on de cada fichero all@'{@dotless{i}} presente. Esto es lo que el usuario
mperez ver@'{@dotless{i}}a si ahora mismo solicitase una copia de miproyecto y observase
los n@'umeros de revisi@'on del directorio ra@'{@dotless{i}}z:

@example
paste$ cvs -q -d :pserver:mperez@@cvs.foobar.com:/usr/local/cvs co miproyecto
U miproyecto/README.txt
U miproyecto/hello.c
U miproyecto/a-subdir/loquesea.c
U miproyecto/a-subdir/subsubdir/fish.c
U miproyecto/b-subdir/random.c
paste$ cd miproyecto/CVS
paste$ cat Entries
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//
/hello.c/1.2/Mon Apr 19 06:35:15 1999//
D/a-subdir////
D/b-subdir////
paste$ 
@end example

El fichero hello.c (entre otros) se encuentra ahora en su revisi@'on 1.2,
mientras que el fichero README.txt est@'a a@'un en la revisi@'on inicial
(1.1.1.1, tambi@'en conocida como 1.1).


Si mperez a@~nade ahora la l@'{@dotless{i}}nea

@example
printf ("entre hola y adi@'os\n");
@end example

a hello.c y lo env@'{@dotless{i}}a, el n@'umero de revisi@'on del fichero se incrementar@'a
una vez m@'as:

@example
paste$ cvs ci -m "a@~nadida una nueva l@'{@dotless{i}}nea entremedias"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <--  hello.c
new revision: 1.3; previous revision: 1.2
done
paste$ 
@end example

Ahora hello.c est@'a en la revisi@'on 1.3, fish.c y random.c est@'an a@'un en
la revisi@'on 1.2, y los dem@'as ficheros en la revisi@'on 1.1.

Observe que el comando fue dado como cvs ci en lugar de cvs commit.  La
mayor parte de los comandos CVS tienen una forma abreviada, para hacer
m@'as f@'acil el escribirlos. Para checkout, update y commit, las versiones
abreviadas son co, up y ci, respectivamente. Puede obtener una lista de
todas las formas abreviadas ejecutando el comando @w{@code{cvs --help-synonyms}}.

Normalmente puede ignorar el n@'umero de revisi@'on de un fichero. En la
mayor@'{@dotless{i}}a de los casos, estos n@'umeros son simplemente anotaciones
internas que CVS gestiona autom@'aticamente. Sin embargo, ser capaz de
encontrar y comparar n@'umeros de revisi@'on es algo muy @'util cuando tiene que
obtener (o establecer diferencias respeto a) una copia antigua del fichero.

Examinar el fichero Entries no es la @'unica forma de descubrir un n@'umero
de revisi@'on. Puede usar tambi@'en el comando status:

@example
paste$ cvs status hello.c
===================================================================
File: hello.c           Status: Up-to-date

   Working revision:    1.3     Tue Apr 20 02:34:42 1999
   Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)
@end example

el cual, cuando se invoca sin nombrar ning@'un fichero, muestra el estado
de todos los ficheros que conforman el proyecto:

@example
paste$ cvs status
cvs status: Examining.
===================================================================
File: README.txt        Status: Up-to-date

   Working revision:    1.1.1.1 Sun Apr 18 18:18:22 1999
   Repository revision: 1.1.1.1 /usr/local/cvs/miproyecto/README.txt,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

===================================================================
File: hello.c           Status: Up-to-date

   Working revision:    1.3     Tue Apr 20 02:34:42 1999
   Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

cvs status: Examining a-subdir
===================================================================
File: loquesea.c        Status: Up-to-date

   Working revision:    1.1.1.1 Sun Apr 18 18:18:22 1999
   Repository revision: 1.1.1.1 /usr/local/cvs/miproyecto/a-subdir/loquesea.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

cvs status: Examining a-subdir/subsubdir
===================================================================
File: fish.c            Status: Up-to-date

   Working revision:    1.2     Mon Apr 19 06:35:27 1999
   Repository revision: 1.2     /usr/local/cvs/miproyecto/
                                a-subdir/subsubdir/fish.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

cvs status: Examining b-subdir
===================================================================
File: random.c          Status: Up-to-date

   Working revision:    1.2     Mon Apr 19 06:35:27 1999
   Repository revision: 1.2     /usr/local/cvs/miproyecto/b-subdir/random.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

paste$ 
@end example

Lim@'{@dotless{i}}tese a ignorar las partes de la salida que no entienda; de hecho, @'este
es por regla general un buen consejo al utilizar CVS. A menudo, el peque@~no
trozo de informaci@'on que est@'a buscando vendr@'a acompa@~nado de otra mucha
informaci@'on que no le interesa, y que quiz@'as ni siquiera comprenda. Esta
situaci@'on es normal; simplemente tome lo que necesite y olv@'{@dotless{i}}dese de todo
lo dem@'as.

En el ejemplo anterior, las partes que nos interesan son las primeras
tres l@'{@dotless{i}}neas (sin contar la l@'{@dotless{i}}nea en blanco) de la informaci@'on de estado
de cada fichero. La primera l@'{@dotless{i}}nea es la m@'as importante, puesto que le dice
el nombre del fichero y su estado en la copia de trabajo. Todos los ficheros
est@'an en este momento sincronizados con el repositorio, as@'{@dotless{i}} que todos dicen
@code{Up-to-date}. Sin embargo, si random.c hubiera sido modificado y el cambio
no se hubiese enviado al repositorio, podr@'{@dotless{i}}amos encontrarnos algo como esto:

@example
===================================================================
File: random.c          Status: Locally Modified

   Working revision:    1.2     Mon Apr 19 06:35:27 1999
   Repository revision: 1.2     /usr/local/cvs/miproyecto/b-subdir/random.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)
@end example

Los n@'umeros de revisi@'on de la copia de trabajo y de la copia presente
en el repositorio le informan de si el fichero est@'a o no sincronizado
con la copia que hay en el repositorio. Volviendo a nuestra copia de
trabajo original (la copia de jluis, que no ha visto todav@'{@dotless{i}}a el cambio
habido en hello.c), vemos lo siguiente:

@example
floss$ cvs status hello.c
===================================================================
File: hello.c           Status: Needs Patch

   Working revision:    1.2     Mon Apr 19 02:17:07 1999
   Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

floss$ 
@end example

Esto nos dice que alguien ha efectuado cambios en hello.c, elevando a
1.3 el n@'umero de revisi@'on de la copia que hay en el repositorio, y
que esta copia de trabajo est@'a a@'un en la revisi@'on 1.2. La l@'{@dotless{i}}nea
"Status: Needs Patch" significa que la siguiente actualizaci@'on traer@'a
los cambios del repositorio y los aplicar@'a a la copia de trabajo del
fichero.

Supongamos por un momento que ignoramos completamente el cambio que mperez
ha hecho a hello.c, as@'{@dotless{i}} que no utilizamos status ni update, sino que
simplemente procedemos a editar nuestro fichero local, realizando un
cambio ligeramente distinto en el mismo punto del fichero. Esto nos
lleva a nuestro primer conflicto.

@c --------------------------------------------------------------------
@node Detecci@'on y resoluci@'on de conflictos
@subsection Detecci@'on y resoluci@'on de conflictos

Detectar un conflicto es bastante sencillo. Al invocar una actualizaci@'on,
CVS le dice, bien a las claras, que existe un conflicto. Pero primero,
creemos el conflicto en s@'{@dotless{i}}: editemos el fichero hello.c para insertar
la l@'{@dotless{i}}nea

@example
printf ("este cambio generar@'a un conflicto\n");
@end example

exactamente donde mperez introdujo esto:

@example
printf ("entre hola y adi@'os\n");
@end example

En este momento, el estado de nuestra copia de hello.c es


@example
floss$ cvs status hello.c
===================================================================
File: hello.c           Status: Needs Merge

   Working revision:    1.2     Mon Apr 19 02:17:07 1999
   Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

floss$ 
@end example

lo que significa que ha habido cambios tanto en la copia del repositorio
como en nuestra copia de trabajo, y que estos cambios necesitan ser
fusionados (CVS no es a@'un consciente de que los cambios entrar@'an en
conflicto, porque a@'un no hemos intentado hacer una actualizaci@'on).
Cuando hagamos una actualizaci@'on, veremos esto:

@example
floss$ cvs update hello.c
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.2
retrieving revision 1.3
Merging differences between 1.2 and 1.3 into hello.c
rcsmerge: warning: conflicts during merge
cvs update: conflicts found in hello.c
C hello.c
floss$ 
@end example

La @'ultima l@'{@dotless{i}}nea es la clave. La "C" situada a la izquierda del nombre del
fichero indica que los cambios han sido fusionados [en nuestra copia de
trabajo], pero que entran en conflicto. El contenido de hello.c muestra
ahora ambos cambios:

@example
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
<<<<<<< hello.c
  printf ("este cambio generar@'a un conflicto\n");
=======
  printf ("entre hola y adi@'os\n");
>>>>>>> 1.3
  printf ("¡Adi@'os, mundo!\n");
@}
@end example

Los conflictos siempre se muestran delimitados por marcadores de
conflicto, en el siguiente formato:

@example
<<<<<<< (nombre de fichero)
  (cambios en la copia de trabajo, todav@'{@dotless{i}}a no enviados al repositorio)
  blah blah blah
=======
  (cambios procedentes del repositorio)
  blah blah blah
  etc.
>>>>>>> (@'ultimo n@'umero de revisi@'on en el repositorio)
@end example

El fichero Entries tambi@'en muestra que el fichero se encuentra en este
momento en un estado intermedio:

@example
floss$ cat CVS/Entries
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//
D/a-subdir////
D/b-subdir////
/hello.c/1.3/Result of merge+Tue Apr 20 03:59:09 1999//
floss$ 
@end example

La manera de resolver el conflicto es editar el fichero de forma que
tenga el texto que resulte apropiado, eliminando de paso los marcadores
de conflicto, y despu@'es enviarlo al repositorio. Esto no significa
necesariamente elegir entre uno o otro cambio; podr@'{@dotless{i}}a decidir que ninguno
de los dos cambios es satisfactorio y reescribir la secci@'on donde aparece
el conflicto, o incluso el fichero al completo. En este caso, vamos a
favorecer el primero de los cambios, pero con una puntuaci@'on y uso de
las may@'usculas ligeramente distintos de los empleados por mperez:

@example
floss$ emacs hello.c
  (editamos el fichero...)
floss$ cat hello.c
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("ENTRE HOLA Y ADI@'OS.\n");
  printf ("¡Adi@'os, mundo!\n");
@}
floss$ cvs ci -m "alterada la l@'{@dotless{i}}nea del medio"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c
new revision: 1.4; previous revision: 1.3
done
floss$ 
@end example

@c -------------------------------------------------------------------
@node Averiguar qui@'en hizo qu@'e (leyendo informes de cambios)
@subsection Averiguar qui@'en hizo qu@'e (leyendo informes de cambios)

A estas alturas, el proyecto ha pasado ya por varios cambios. Si est@'a
intentado hacerse una idea de lo sucedido hasta el momento, no querr@'a
necesariamente examinar con detalle cada fichero de diferencias. Examinar
los informes de cambios ser@'{@dotless{i}}a lo ideal, y puede hacerlo con el comando log:

@example
floss$ cvs log   
(p@'aginas y p@'aginas de salida omitidas)
@end example

La salida del comando tiende a ser bastante detallada. Veamos los informes
de cambios para un @'unico fichero:

@example
floss$ cvs log hello.c
RCS file: /usr/local/cvs/miproyecto/hello.c,v
Working file: hello.c
head: 1.4
branch:
locks: strict
access list:
symbolic names:
        start: 1.1.1.1
        jluis: 1.1.1
keyword substitution: kv
total revisions: 5;     selected revisions: 5
description:
--------------
revision 1.4
date: 1999/04/20 04:14:37;  author: jluis;  state: Exp;  lines: +1 -1
alterada la l@'{@dotless{i}}nea del medio
--------------
revision 1.3
date: 1999/04/20 02:30:05;  author: mperez;  state: Exp;  lines: +1 -0
a@~nadida una nueva l@'{@dotless{i}}nea entremedias
--------------
revision 1.2
date: 1999/04/19 06:35:15;  author: jluis;  state: Exp;  lines: +1 -0
ahora tambi@'en dice adi@'os
--------------
revision 1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;
branches:  1.1.1;
Revisi@'on inicial
--------------
revision 1.1.1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;  lines: +0 -0
Importaci@'on inicial en CVS
=========================================================================
floss$ 
@end example

Como es habitual, hay mucha informaci@'on al comienzo que puede simplemente
ignorar. La parte que nos interesa viene despu@'es de cada l@'{@dotless{i}}nea de guiones,
en un formato que se explica por s@'{@dotless{i}} solo.

Cuando se env@'{@dotless{i}}an muchos ficheros a la vez al repositorio, todos tienen un
mismo informe de cambios, algo que puede ser @'util para seguir los cambios.
Por ejemplo, ¿recuerda cuando enviamos fish.c y random.c a la vez? Se hizo
de esta forma:

@example
floss$ cvs commit -m "a@~nadido c@'odigo C"
Checking in a-subdir/subsubdir/fish.c;
/usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v  <-  fish.c
new revision: 1.2; previous revision: 1.1
done
Checking in b-subdir/random.c;
/usr/local/cvs/miproyecto/b-subdir/random.c,v  <-  random.c
new revision: 1.2; previous revision: 1.1
done
floss$ 
@end example

El resultado de esta operaci@'on fue el env@'{@dotless{i}}o de ambos ficheros con un
mismo informe de cambios: "a@~nadido c@'odigo C". Se da el caso de que ambos
ficheros empezaban en la revisi@'on 1.1 y pasaron a la 1.2, pero esto es s@'olo
una coincidencia; si random.c estuviera en la revisi@'on 1.29, habr@'{@dotless{i}}a pasado
a la 1.30 tras concluir este env@'{@dotless{i}}o, y la revisi@'on 1.30 tendr@'{@dotless{i}}a el mismo
informe de cambios que la revisi@'on 1.2 de fish.c.

Al utilizar cvs log con estos ficheros, ver@'a el informe que ambos comparten:


@example
floss$ cvs log a-subdir/subsubdir/fish.c b-subdir/random.c

RCS file: /usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v
Working file: a-subdir/subsubdir/fish.c
head: 1.2
branch:
locks: strict
access list:
symbolic names:
        start: 1.1.1.1
        jluis: 1.1.1
keyword substitution: kv
total revisions: 3;     selected revisions: 3
description:
--------------
revision 1.2
date: 1999/04/19 06:35:27;  author: jluis;  state: Exp;  lines: +8 -1
a@~nadido c@'odigo C
--------------
revision 1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;
branches:  1.1.1;
Revisi@'on inicial
--------------
revision 1.1.1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;  lines: +0 -0
Importaci@'on inicial en CVS
=========================================================================
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
Working file: b-subdir/random.c
head: 1.2
branch:
locks: strict
access list:
symbolic names:
        start: 1.1.1.1
        jluis: 1.1.1
keyword substitution: kv
total revisions: 3;     selected revisions: 3
description:
--------------
revision 1.2
date: 1999/04/19 06:35:27;  author: jluis;  state: Exp;  lines: +8 -1
a@~nadido c@'odigo C
--------------
revision 1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;
branches:  1.1.1;
Revisi@'on inicial
--------------
revision 1.1.1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;  lines: +0 -0
Importaci@'on inicial en CVS
=========================================================================
floss$ 
@end example

Por esta informaci@'on sabr@'a que las dos revisiones fueron parte del mismo
env@'{@dotless{i}}o (el hecho de que las fechas de las dos revisiones sean las mismas,
o muy pr@'oximas entre s@'{@dotless{i}}, es una prueba m@'as).

Examinar los informes de cambios es una buena forma de hacerse r@'apidamente
una idea de lo que ha estado sucediendo en un proyecto o de saber lo
que pas@'o con un fichero espec@'{@dotless{i}}fico en un momento determinado. Existen
tambi@'en muchas herramientas libres dise@~nadas para convertir la salida
bruta de cvs log a formatos m@'as concisos y legibles (por ejemplo, al
estilo ChangeLog de GNU); no cubriremos estas herramientas en esta gu@'{@dotless{i}}a,
pero ser@'an presentadas en @ref{Herramientas de terceros}.

@c -------------------------------------------------------------------
@node Examinar y deshacer cambios
@subsection Examinar y deshacer cambios

Supongamos que, mientras estamos leyendo los informes de cambios, mperez
se percata de que jluis hizo el cambio m@'as reciente a hello.c:

@example
revision 1.4 
date: 1999/04/20 04:14:37;  author: jluis;  state: Exp;  lines: +1 -1 
alterada la l@'{@dotless{i}}nea del medio
@end example

y se pregunta qu@'e hizo jluis exactamente. En t@'erminos formales, la
pregunta que se hace mperez es, "¿Cu@'al es la diferencia entre mi revisi@'on
(1.3) de hello.c, y la revisi@'on de jluis que vino a continuaci@'on (1.4)?"
La forma de averiguarlo es utilizar el comando diff, pero esta vez comparando
las dos @'ultimas revisiones utilizando la opci@'on de comando -r para especificar
ambos n@'umeros:

@example
paste$ cvs diff -c -r 1.3 -r 1.4 hello.c
Index: hello.c
===========================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -c -r1.3 -r1.4
*** hello.c     1999/04/20 02:30:05     1.3
--- hello.c     1999/04/20 04:14:37     1.4
***************
*** 4,9 ****
  main ()
  @{
    printf ("¡Hola, mundo!\n");
!   printf ("entre hola y adi@'os\n");
    printf ("¡Adi@'os, mundo!\n");
  @}
--- 4,9 --
  main ()
  @{
    printf ("¡Hola, mundo!\n");
!   printf ("ENTRE HOLA Y ADI@'OS.\n");
    printf ("¡Adi@'os, mundo!\n");
  @}
paste$
@end example

El cambio es bastante obvio, visto de esta forma. Dado que los n@'umeros
de revisi@'on se dan en orden cronol@'ogico (por lo general, una buena idea),
el comando los muestra de forma ordenada. Si s@'olo se da un n@'umero de
revisi@'on, CVS utiliza como segundo n@'umero la revisi@'on actual del fichero
presente en la copia de trabajo.

Cuando mperez ve estos cambios, decide al momento que le gusta m@'as su
forma de hacer las cosas, as@'{@dotless{i}} que decide "deshacerlo", esto es, ir una
revisi@'on atr@'as.

Sin embargo, esto no significa que desee perder su revisi@'on 1.4. Si bien
en un sentido estrictamente t@'ecnico es probablemente posible conseguir
este efecto en CVS, raramente existe raz@'on alguna para hacerlo. Es mucho
m@'as deseable guardar la revisi@'on 1.4 en el historial y hacer una nueva
revisi@'on 1.5 id@'entica a la 1.3: de esta forma, la operaci@'on de deshacer
se convierte en parte del historial del fichero.

La @'unica pregunta es, ¿c@'omo puede usted obtener el contenido de la revisi@'on
1.3 y ponerlo en la 1.5?

En este caso en particular, dado que el cambio es muy sencillo, mperez
puede seguramente limitarse a editar el fichero a mano para hacerlo
id@'entico a la revisi@'on 1.3, y entonces enviarlo al repositorio. Sin
embargo, si los cambios son m@'as complejos (como suele ocurrir en un
proyecto real), intentar recrear a mano la revisi@'on antigua ser@'a
irremediablemente algo donde se producir@'an errores. Por tanto, vamos
a hacer que mperez utilice CVS para obtener y reenviar el contenido de
la antigua revisi@'on.

Hay dos formas igualmente buenas de conseguir esto: la lenta y dolorosa,
y la r@'apida y vistosa. Vamos a examinar primero la lenta y dolorosa.

@c ---------------------------------------------------------------------
@node El m@'etodo lento de deshacer cosas
@subsection El m@'etodo lento de deshacer cosas

Este m@'etodo utiliza la combinaci@'on de opciones -p y -r al hacer la
actualizaci@'on. La opci@'on -p env@'{@dotless{i}}a el contenido de la revisi@'on indicada a
la salida est@'andar.

De por s@'{@dotless{i}}, no es que esto sea algo terriblemente @'util, dado que el
contenido del fichero desaparecer@'a r@'apidamente por la  ventana, dejando
intacta la copia de trabajo. Sin embargo, redirigiendo la salida est@'andar
al fichero, el fichero terminar@'a recibiendo el contenido de la antigua
revisi@'on. Ser@'{@dotless{i}}a lo mismo que haber editado el fichero a mano para
llevarlo a ese estado.

Primero, sin embargo, mperez necesita ponerse al d@'{@dotless{i}}a respecto al
repositorio:

@example
paste$ cvs update
cvs update: Updating .
U hello.c
cvs update: Updating a-subdir
cvs update: Updating a-subdir/subsubdir
cvs update: Updating b-subdir
paste$ cat hello.c
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("ENTRE HOLA Y ADI@'OS.\n");
  printf ("¡Adi@'os, mundo!\n");
@}
paste$ 
@end example

Lo siguiente que hace es emplear la opci@'on -p al invocar la actualizaci@'on,
para asegurarse de que la revisi@'on 1.3 es justo la que quiere:

@example
paste$ cvs update -p -r 1.3 hello.c
===================================================================
Checking out hello.c
RCS:  /usr/local/cvs/miproyecto/hello.c,v
VERS: 1.3
***************
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("entre hola y adi@'os\n");
  printf ("¡Adi@'os, mundo!\n");
@}
@end example

Ooops, hay algunas l@'{@dotless{i}}neas in@'utiles al comienzo. En realidad estas l@'{@dotless{i}}neas
no se env@'{@dotless{i}}an a la salida est@'andar sino al flujo de error est@'andar, as@'{@dotless{i}} que
son inofensivas. A@'un as@'{@dotless{i}}, estas l@'{@dotless{i}}neas hacen m@'as dif@'{@dotless{i}}cil interpretar la
informaci@'on, y pueden ser suprimidas con -Q:

@example
paste$ cvs -Q update -p -r 1.3 hello.c
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("entre hola y adi@'os\n");
  printf ("¡Adi@'os, mundo!\n");
@}
paste$ 
@end example

Ah@'{@dotless{i}} estamos - esto es exactamente lo que mperez quer@'{@dotless{i}}a obtener. El
siguiente paso es poner ese contenido en el fichero de la copia de
trabajo, usando una redirecci@'on Unix (que es lo que hace el signo ">"):

@example
paste$ cvs -Q update -p -r 1.3 hello.c > hello.c
paste$ cvs update
cvs update: Updating .
M hello.c
cvs update: Updating a-subdir
cvs update: Updating a-subdir/subsubdir
cvs update: Updating b-subdir
paste$ 
@end example

Al hacer ahora la actualizaci@'on, el fichero aparece como modificado, lo
cual tiene sentido dado que su contenido ha cambiado. Espec@'{@dotless{i}}ficamente,
tiene el mismo contenido que la antigua revisi@'on 1.3 (no es que CVS se
d@'e cuenta de que es id@'entica a la revisi@'on antigua, tan s@'olo se da
cuenta de que se ha modificado). Si mperez quiere estar a@'un m@'as seguro,
puede hacer un diff para comprobarlo:

@example
paste$ cvs -Q diff -c
Index: hello.c
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.4
diff -c -r1.4 hello.c
*** hello.c     1999/04/20 04:14:37     1.4
--- hello.c     1999/04/20 06:02:25
***************
*** 4,9 ****
  main ()
  @{
    printf ("¡Hola, mundo!\n");
!   printf ("ENTRE HOLA Y ADI@'OS.\n");
    printf ("¡Adi@'os, mundo!\n");
  @}
--- 4,9 --
  main ()
  @{
    printf ("¡Hola, mundo!\n");
!   printf ("entre hola y adi@'os\n");
    printf ("Adi@'os, mundo!\n");
  @}
paste$ 
@end example

S@'{@dotless{i}}, esto es exactamente lo que @'el quer@'{@dotless{i}}a: una verdadera vuelta atr@'as.
De hecho, es lo contrario del diff que obtuvo previamente. Satisfecho,
lo env@'{@dotless{i}}a:

@example
paste$ cvs ci -m "devuelto al c@'odigo 1.3"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c
new revision: 1.5; previous revision: 1.4
done
paste$ 
@end example

@c ---------------------------------------------------------------
@node El m@'etodo r@'apido de deshacer cosas
@subsection El m@'etodo r@'apido de deshacer cosas

La forma r@'apida y vistosa de deshacer es usar la opci@'on -j (de "juntar")
al comando de actualizaci@'on. Esta opci@'on es similar a -r en el sentido de
que utiliza un n@'umero de revisi@'on, y de que puede usar hasta dos -j a la
vez. CVS calcula la diferencia entre las dos revisiones nombradas y
aplica esta diferencia como un parche al fichero en cuesti@'on (con lo
cual, ser@'a de vital importancia el orden en el que indique estas
revisiones al comando).

As@'{@dotless{i}} pues, asumiendo que la copia de mperez est@'a al d@'{@dotless{i}}a, puede hacer
simplemente lo siguiente:

@example
paste$ cvs update -j 1.4 -j 1.3 hello.c
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.4
retrieving revision 1.3
Merging differences between 1.4 and 1.3 into hello.c
paste$ cvs update
cvs update: Updating .
M hello.c
cvs update: Updating a-subdir
cvs update: Updating a-subdir/subsubdir
cvs update: Updating b-subdir
paste$ cvs ci -m "devuelto al c@'odigo 1.3" hello.c
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <--  hello.c
new revision: 1.5; previous revision: 1.4
done
paste$ 
@end example

Cuando s@'olo es necesario deshacer los cambios habidos en un @'unico fichero,
no hay realmente mucha diferencia entre el m@'etodo lento y el r@'apido. M@'as
adelante, veremos como el m@'etodo r@'apido es mucho mejor para deshacer
m@'ultiples ficheros al mismo tiempo. De momento, utilice simplemente el
m@'etodo que le resulte m@'as c@'omodo.

@c -------------------------------------------------------------------
@heading Deshacer no es un sustituto para la comunicaci@'on

Con toda probabilidad, lo que mperez hizo en nuestro ejemplo fue bastante
desconsiderado por su parte. Al trabajar en un proyecto real con otras
personas, si se considera que alguien ha hecho un cambio poco deseable,
lo primero que deber@'{@dotless{i}}a hacerse es discutir el tema con esa persona. Quiz@'as
haya una buena raz@'on detr@'as del cambio, o puede que esa persona no lo
haya meditado lo suficiente antes de incorporarlo al repositorio. Sea
como fuere, no hay motivo alguno para precipitarse a deshacerlo. CVS
guarda un registro completo de todo lo que va sucediendo, as@'{@dotless{i}} que siempre
puede deshacer los cambios hasta una revisi@'on previa despu@'es de consultar
con la persona que hizo esos cambios.

Si es Ud. el responsable m@'aximo de un proyecto y tiene una fecha l@'{@dotless{i}}mite
para entregarlo, o si considera que tiene todo el derecho -y la necesidad-
de deshacer inmediatamente el cambio sin m@'as dilaci@'on, entonces adelante,
pero lo siguiente que deber@'{@dotless{i}}a hacer es contactar con el autor de los
cambios que ha deshecho, explic@'andole sus motivos y qu@'e hay que hacer
para volver a enviar el cambio.

@c -------------------------------------------------------------------
@node Otros comandos @'utiles de CVS
@section Otros comandos @'utiles de CVS

Llegados a este punto, ya deber@'{@dotless{i}}a sentirse relativamente c@'omodo con el
uso b@'asico de CVS. Dejar@'e por tanto mi tono narrativo y docente para
presentar algunos comandos m@'as que resultan @'utiles, esta vez de forma
m@'as breve:

@menu
* A@~nadir ficheros::
* A@~nadir directorios::
* CVS y ficheros binarios::
* Eliminar ficheros::
* Eliminar directorios::
* Renombrar ficheros y directorios::
* Evitar la fatiga de las opciones::
* Obtener instant@'aneas (fechas y marcas)::
* Formatos de fecha permitidos::
* Marcar un momento en el tiempo (marcas)::
@end menu

@c ------------------------------------------------------------------
@node A@~nadir ficheros
@subsection A@~nadir ficheros

A@~nadir un fichero es un proceso de dos pasos: primero debe ejecutar
el comando add ("a@~nadir") sobre @'el, y despu@'es enviarlo. El fichero no
aparecer@'a en el repositorio hasta que se haya realizado el env@'{@dotless{i}}o:

@example
floss$ cvs add nuevofichero.c
cvs add: scheduling file 'nuevofichero.c' for addition
cvs add: use 'cvs commit' to add this file permanently
floss$ cvs ci -m "a@~nadido nuevofichero.c" nuevofichero.c 
RCS file: /usr/local/cvs/miproyecto/nuevofichero.c,v
done
Checking in nuevofichero.c;
/usr/local/cvs/miproyecto/nuevofichero.c,v  <-  nuevofichero.c
initial revision: 1.1
done
floss$ 
@end example

@c ------------------------------------------------------------------
@node A@~nadir directorios
@subsection A@~nadir directorios

A diferencia del a@~nadido de ficheros, el a@~nadido de directorios es un
proceso de un s@'olo paso; no es necesario emplear "commit" a continuaci@'on:

@example
floss$ mkdir c-subdir 
floss$ cvs add c-subdir
Directory /usr/local/cvs/miproyecto/c-subdir added to the repository 
floss$ 
@end example

Si examina lo que hay dentro del nuevo directorio en la copia de trabajo,
ver@'a que el comando "add" ha a@~nadido autom@'aticamente un subdirectorio
"CVS":

@example
floss$ ls c-subdir 
CVS/ 
floss$ ls c-subdir/CVS 
Entries     Repository  Root 
floss$ 
@end example

Ahora puede a@~nadir ficheros (o nuevos directorios) al directorio que ha
creado, como con cualquier otro directorio de su copia de trabajo.

@c ---------------------------------------------------------------------
@node CVS y ficheros binarios
@subsection CVS y ficheros binarios

Hasta ahora he decidido omitir el secretillo que esconde CVS, que es el
hecho de que no se le dan muy bien los ficheros binarios (bueno, hay
alg@'un que otro secretillo m@'as, pero @'este es desde luego el m@'as vergonzante
de todos). No es que CVS no soporte el uso de binarios; en realidad lo
hace, pero no sin algunos dolores de cabeza.

Todos los ficheros en los que hemos estado trabajando hasta ahora han sido
simples ficheros de texto. CVS tiene algunos trucos especiales para los
ficheros de texto: por ejemplo, cuando est@'a trabajando entre un repositorio
de Unix y una copia de trabajo instalada en un sistema Windows o Macintosh,
convierte los finales de l@'{@dotless{i}}nea de la forma apropiada para cada plataforma.
Por ejemplo, la convenci@'on en Unix es usar simplemente un salto de l@'{@dotless{i}}nea
(LF), mientras que Windows espera una secuencia de retorno de carro y salto
de l@'{@dotless{i}}nea (CR+LF) al final de cada l@'{@dotless{i}}nea. As@'{@dotless{i}}, los ficheros en una copia de
trabajo bajo Windows tendr@'an terminaciones CR+LF, mientras que una copia de
trabajo del mismo proyecto instalada en una m@'aquina Unix tendr@'a
terminaciones LF (el repositorio en s@'{@dotless{i}} siempre utiliza el formato LF).

Otro truco es que CVS detecta en los ficheros de texto la presencia de
cadenas especiales, conocidas como cadenas de texto de palabras clave RCS,
y las sustituye con la informaci@'on de la revisi@'on y otras cosas @'utiles.
Por ejemplo, si su fichero contiene esta cadena:
   
@example
$Revision$
@end example

CVS la expandir@'a en cada env@'{@dotless{i}}o para poner en su lugar el n@'umero de revisi@'on.
Por ejemplo, esta cadena podr@'{@dotless{i}}a convertirse en
   
@example
$Revision: 1.3 $
@end example

CVS mantiene esta cadena al d@'{@dotless{i}}a en el fichero a medida que @'este va
evolucionando. Estas palabras clave se documentan en @ref{CVS avanzado} y
@ref{Herramientas de terceros}.

Esta expansi@'on de cadenas de texto es algo muy @'util en los ficheros de
texto, ya que permite ver los n@'umeros de revisi@'on y otra informaci@'on
sobre un fichero mientras lo est@'a editando. Ahora bien, ¿qu@'e pasa si el
fichero es una imagen JPG? ¿o un programa ejecutable compilado? En estos
casos, CVS podr@'{@dotless{i}}a da@~nar seriamente los ficheros si se pusiera a expandir
cada palabra clave que fuese encontrando. Es m@'as, en un fichero binario
estas cadenas podr@'{@dotless{i}}an aparecer por pura coincidencia.

Por lo tanto, cuando a@~nada un fichero binario, debe decirle a CVS que
desactive tanto la expansi@'on de palabras clave como la conversi@'on de
finales de l@'{@dotless{i}}nea. Para ello, utilice -kb:

@example
floss$ cvs add -kb fichero
floss$ cvs ci -m "a@~nadido esto y lo otro" fichero
  (etc@'etera)
@end example

Por otra parte, en ciertas ocasiones (como es el caso de ficheros de texto
donde posiblemente aparezca alguna referencia a este tipo de palabras
clave), posiblemente desee desactivar solamente la expansi@'on de palabras
clave. Esto se hace con -ko:

@example
floss$ cvs add -ko fichero
floss$ cvs ci -m "a@~nadido esto y lo otro" fichero
  (etc@'etera)
@end example

(De hecho, este mismo cap@'{@dotless{i}}tulo que est@'a leyendo es un ejemplo de este tipo
de casos, merced al ejemplo de @w{@code{$Revision$}} mostrado aqu@'{@dotless{i}}.)

Tenga en cuenta que no tiene sentido utilizar @w{@code{cvs diff}} sobre dos
revisiones de un fichero binario. Diff utiliza un algoritmo basado en
texto que s@'olo puede discernir si dos ficheros binarios son distintos,
pero no la forma en que difieren. Futuras versiones de CVS podr@'{@dotless{i}}an llegar
a ofrecer alguna manera de presentar diferencias entre ficheros binarios.

@c ----------------------------------------------------------------------
@node Eliminar ficheros
@subsection Eliminar ficheros

Eliminar un fichero es similar a a@~nadir uno, con la salvedad de que debe
dar un paso adicional: tendr@'a que eliminar antes el fichero de su copia de
trabajo.

@example
floss$ rm nuevofichero.c
floss$ cvs remove nuevofichero.c
cvs remove: scheduling 'nuevofichero.c' for removal
cvs remove: use 'cvs commit' to remove this file permanently
floss$ cvs ci -m "eliminado nuevofichero.c" nuevofichero.c
Removing nuevofichero.c;
/usr/local/cvs/miproyecto/nuevofichero.c,v  <-  nuevofichero.c
new revision: delete; previous revision: 1.1
done
floss$ 
@end example

F@'{@dotless{i}}jese c@'omo en el segundo y tercer comandos nos referimos a nuevofichero.c
de forma expl@'{@dotless{i}}cita a pesar de que ya no existe en nuestra copia de trabajo.
Por supuesto, en el env@'{@dotless{i}}o, no es estrictamente necesario que nombre el
fichero, siempre que no le importe que el env@'{@dotless{i}}o afecte tambi@'en a cualquier
otra modificaci@'on que haya podido tener lugar en la copia de trabajo.

@c --------------------------------------------------------------------
@node Eliminar directorios
@subsection Eliminar directorios

Como he dicho anteriormente, en realidad CVS no mantiene los directorios
bajo control de versi@'on, sino que, a modo de medida de ahorro, presenta
ciertos comportamientos extra@~nos que en la mayor@'{@dotless{i}}a de los casos hacen
simplemente "lo que conviene". Uno de estos comportamientos extra@~nos es
que los directorios vac@'{@dotless{i}}os pueden tratarse de una forma especial. Si desea
eliminar un directorio de un proyecto, primero borre todos los ficheros
que contenga

@example
floss$ cd dir
floss$ rm fichero1 fichero2 fichero3
floss$ cvs remove fichero1 fichero2 fichero3
  (salida de informaci@'on omitida)
floss$ cvs ci -m "borrados todos los ficheros" fichero1 fichero2 fichero3
  (salida de informaci@'on omitida)
@end example

y despu@'es ejecute "update" en el directorio anterior con la opci@'on -P:

@example
floss$ cd .. 
floss$ cvs update -P 
  (salida de informaci@'on omitida)
@end example

La opci@'on -P le dice al comando "update" que "limpie" cualquier directorio
vac@'{@dotless{i}}o, esto es, que los elimine de la copia de trabajo. Una vez hecho esto,
puede decirse que el directorio ha sido borrado; todos sus ficheros han
desaparecido, y el directorio en s@'{@dotless{i}} es historia (al menos por lo que respecta
a nuestra copia de trabajo, claro, pero sigue habiendo un directorio vac@'{@dotless{i}}o en
el repositorio).

Una interesante contrapartida de este comportamiento es que, cuando se
hace una actualizaci@'on normal, CVS no trae autom@'aticamente a la copia de
trabajo los nuevos directorios que se hayan creado en el repositorio.
Hay un par de justificaciones variopintas para esto, ninguna de las cuales
vale la pena mencionar aqu@'{@dotless{i}}. La explicaci@'on breve es que de vez en cuando
deber@'{@dotless{i}}a ejecutar "update" con la opci@'on -d, orden@'andole que traiga cualquier
nuevo directorio que haya sido creado en el repositorio.

@c -----------------------------------------------------------------
@node Renombrar ficheros y directorios
@subsection Renombrar ficheros y directorios

Renombrar un fichero es equivalente a crearlo con un nuevo nombre y
eliminarlo con el antiguo. En Unix, los comandos son:


@example
floss$ cp nombre_antiguo nuevo_nombre
floss$ rm nombre_antiguo
@end example

Aqu@'{@dotless{i}} est@'a el equivalente en CVS:

@example
floss$ mv nombre_antiguo nuevo_nombre
floss$ cvs remove nombre_antiguo
  (salida omitida)
floss$ cvs add nuevo_nombre
  (salida omitida)
floss$ cvs ci -m "renombrado nombre_antiguo como nuevo_nombre" nombre_antiguo nuevo_nombre
  (salida omitida)
floss$ 
@end example

Para ficheros, @'esto es todo lo que hay que hacer. El renombramiento de
directorios tampoco var@'{@dotless{i}}a mucho: deber@'a crear el nuevo directorio, a@~nadirlo
con cvs add, mover todos los ficheros del directorio antiguo al nuevo,
eliminarlos con cvs remove del directorio antiguo, a@~nadirlos al nuevo con
cvs add, hacer un env@'{@dotless{i}}o con cvs commit para actualizar el repositorio, y
finalmente actualizarse con cvs update -P para que desaparezca de nuestra
copia de trabajo cualquier directorio vac@'{@dotless{i}}o. O sea,

@example
floss$ mkdir nuevo_dir 
floss$ cvs add nuevo_dir 
floss$ mv dir_antiguo/* nuevo_dir 
mv: nuevo_dir/CVS: cannot overwrite directory 
floss$ cd dir_antiguo 
floss$ cvs rm foo.c bar.txt 
floss$ cd ../nuevo_dir 
floss$ cvs add foo.c bar.txt 
floss$ cd ..  
floss$ cvs commit -m "movidos foo.c y bar.txt de dir_antiguo a nuevo_dir"
floss$ cvs update -P
@end example

F@'{@dotless{i}}jese en el mensaje de aviso recibido despu@'es de ejecutar el tercer comando.
Este aviso le comunica que no se puede copiar el subdirectorio CVS/ del
antiguo directorio al nuevo porque ya hay all@'{@dotless{i}} un directorio con este
nombre. Esto es correcto, porque le interesa que el directorio antiguo
mantenga de todos modos su subdirectorio CVS/.

Obviamente, mover directorios de un lado para otro puede ser un poco
engorroso. La mejor pol@'{@dotless{i}}tica es tratar de disponer una buena distribuci@'on
en el momento de importar el proyecto, de forma que no tenga que estar
moviendo luego directorios para aqu@'{@dotless{i}} y para all@'a. M@'as adelante, aprender@'a
un m@'etodo m@'as dr@'astico para mover directorios, esta vez haciendo el cambio
directamente en el repositorio. Sin embargo, es mejor reservar este m@'etodo
para situaciones de emergencia; siempre que sea posible, es mejor gestionar
todo con operaciones de CVS que afecten principalmente a las copias de
trabajo.

@c -------------------------------------------------------------------
@node Evitar la fatiga de las opciones
@subsection Evitar la fatiga de las opciones

La mayor parte de la gente se cansa r@'apidamente de estar escribiendo
continuamente las mismas opciones con cada comando. Si sabe que siempre
va a querer pasar la opci@'on global -Q o que siempre va a usar -c con
diff, ¿por qu@'e tendr@'{@dotless{i}}a que estar escribi@'endolas una y otra vez?

Por suerte, dispone de ayuda para esto. CVS busca un fichero .cvsrc en su
directorio personal. En este fichero puede especificar las opciones que
deban aplicarse por omisi@'on en cada invocaci@'on a CVS. @'Este es un fichero
.cvsrc de ejemplo:

@example
diff -c
update -P
cvs -q
@end example

Si la primera palabra de la l@'{@dotless{i}}nea corresponde a un comando de CVS en
su forma *no* abreviada, las opciones indicadas ah@'{@dotless{i}} ser@'an las que se
utilicen siempre con ese comando. Para indicar opciones globales a
emplear por omisi@'on, deber@'a usar "cvs".

Empleando nuestro ejemplo de arriba, cada vez que el usuario ejecute
cvs diff, la opci@'on -c se incluir@'a autom@'aticamente.

@c -------------------------------------------------------------------
@node Obtener instant@'aneas (fechas y marcas) 
@subsection Obtener instant@'aneas (fechas y marcas) 

Volvamos al ejemplo del programa que est@'a en un estado inoperativo en
el momento en el que recibimos un informe de fallo de un usuario. El
desarrollador necesita de repente acceder al proyecto entero en el
estado en el que se encontraba al hacer la @'ultima distribuci@'on p@'ublica,
aunque muchos ficheros posiblemente habr@'an cambiado desde entonces, y
el n@'umero de revisi@'on de cada fichero seguramente ser@'a distinto en este
momento. Llevar@'{@dotless{i}}a demasiado tiempo revisar los informes de cambios,
adivinar cu@'al era el n@'umero de revisi@'on de cada fichero en el momento
de la distribuci@'on, y despu@'es ejecutar una actualizaci@'on (especificando
el n@'umero de revisi@'on con -r) para cada uno de ellos. En proyectos de
mediano o gran tama@~no (de decenas a cientos de ficheros), ser@'{@dotless{i}}a casi
imposible acometer tama@~na empresa.

Por todo lo cual, CVS proporciona una forma de obtener de una sola vez
revisiones antiguas de los ficheros que forman un proyecto. De hecho,
ofrece dos mecanismos: por fecha -que selecciona las revisiones bas@'andose
en la fecha en que fueron enviadas al repositorio-, y por marca, que
obtiene una "instant@'anea" del proyecto marcada previamente.

Cu@'al de los m@'etodos deber@'a utilizar es algo que depende de la situaci@'on
concreta. El m@'etodo basado basado en fechas funciona pasando la opci@'on
-D al comando "update", que es similar a -r pero en este caso tomando
como argumento fechas en lugar de n@'umeros de revisi@'on:

@example
floss$ cvs -q update -D "1999-04-19" 
U hello.c 
U a-subdir/subsubdir/fish.c 
U b-subdir/random.c 
floss$ 
@end example

Con la opci@'on -D, "update" recupera la revisi@'on m@'as reciente de cada
fichero existente en la fecha dada, devolviendo si es necesario los
ficheros de la copia de trabajo al estado en el que encontes se
encontraban.

Cuando se da una fecha, puede -y generalmente, deber@'{@dotless{i}}a hacerlo- incluir
la hora exacta. Por ejemplo, el comando anterior termin@'o tomando del
repositorio la revisi@'on 1.1 de todo (s@'olo tres ficheros cambiaron,
porque los dem@'as est@'an a@'un en la revisi@'on 1.1). @'Este es el estado de
hello.c para demostrarlo:

@example
floss$ cvs -Q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:          1.1.1.1 Sat Apr 24 22:45:03 1999 
   Repository revision:       1.1.1.1 /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Date:               99.04.19.05.00.00 
floss$ 
@end example

Pero un vistazo atr@'as a los informes de cambios presentados anteriormente
en este cap@'{@dotless{i}}tulo indica que la revisi@'on 1.2 de hello.c se envi@'o sin duda
alguna al repositorio el 19 de Abril de 1999. As@'{@dotless{i}} que, ¿por qu@'e hemos
recibido ahora la revisi@'on 1.1 en lugar de la 1.2?

El problema est@'a en que la fecha "1999-04-19" fue interpretada como "la
medianoche en la que comenz@'o el d@'{@dotless{i}}a 1999-04-19", esto es, el primer
instante de ese d@'{@dotless{i}}a. Esto seguramente no es lo que quiere. El env@'{@dotless{i}}o
de la revisi@'on 1.2 tuvo lugar en un momento posterior de ese d@'{@dotless{i}}a.
Indicando la fecha con mayor exactitud, podemos obtener la revisi@'on 1.2:

@example
floss$ cvs -q update -D "1999-04-19 23:59:59" 
U hello.c 
U a-subdir/subsubdir/fish.c 
U b-subdir/random.c 
floss$ cvs status hello.c 
=================================================================== 
File: hello.c                 Status: Locally Modified 
   Working revision:  1.2     Sat Apr 24 22:45:22 1999 
   Repository revision:       1.2     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                (none) 
   Sticky Date:               99.04.20.04.59.59 
   Sticky Options:    (none) 
floss$ 
@end example

Casi hemos terminado. Si observa atentamente la fecha y hora de la l@'{@dotless{i}}nea
"Sticky Date", parece indicar las 4:59:59 AM, no las 11:59 como se
indic@'o en el comando (m@'as adelante veremos lo que significa "sticky").

Como habr@'a adivinado, la discrepancia se debe a la diferencia entre la
hora local y la hora Universal Coordinada (tambi@'en conocida como la hora
del meridiano de Greenwich). El repositorio guarda siempre las fechas en
Tiempo Universal, pero en su lado cliente CVS suele asumir la hora local
del sistema. En el caso de -D, esto es un poco desafortunado, porque
posiblemente le interese m@'as comparar respecto a la hora recogida en el
repositorio que preocuparse por lo que el sistema local opina de qu@'e
hora es. Puede evitar este problema especificando la zona GMT en el
comando:

@example
floss$ cvs -q update -D "1999-04-19 23:59:59 GMT" 
U hello.c 
floss$ cvs -q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.2     Sun Apr 25 22:38:53 1999 
   Repository revision:       1.2     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                (none) 
   Sticky Date:               99.04.19.23.59.59 
   Sticky Options:    (none) 
floss$ 
@end example

¡Aj@'a! Esto ha hecho que la copia de trabajo quede registrada como uno
de los @'ultimos env@'{@dotless{i}}os realizados el 19 de Abril (a menos que hubiera
alg@'un env@'{@dotless{i}}o en el @'ultimo segundo del d@'{@dotless{i}}a, que no es el caso).

¿Qu@'e sucede ahora si ejecuta "update"?

@example
floss$ cvs update 
cvs update: Updating . 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
floss$ 
@end example

No pasa nada. Pero usted sabe que hay versiones m@'as recientes de por
lo menos tres ficheros, luego, ¿por qu@'e no se incorporan estos ficheros
en su copia de trabajo?

Aqu@'{@dotless{i}} es donde "sticky" entra en juego. Actualizar (¿"desactualizar"?)
con la opci@'on -D hace que la copia de trabajo quede fijada de forma
permanente a esa fecha o a una anterior: en terminolog@'{@dotless{i}}a de CVS, la
copia de trabajo tiene "pegada" una fecha. Una vez que una copia de
trabajo ha adquirido una propiedad pegadiza, se mantiene as@'{@dotless{i}} hasta
que se le diga lo contrario. As@'{@dotless{i}} pues, posteriores actualizaciones
no permitir@'an obtener autom@'aticamente la revisi@'on m@'as reciente, sino
que estar@'an restringidas a la fecha pegada. El si hay algo pegado o
no a un fichero es algo que puede averiguarse ejecutando cvs status,
o bien examinando directamente el fichero CVS/Entries:

@example
floss$ cvs -q update -D "1999-04-19 23:59:59 GMT" 
U hello.c 
floss$ cat CVS/Entries 
D/a-subdir//// 
D/b-subdir//// 
D/c-subdir//// 
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//D99.04.19.23.59.59 
/hello.c/1.2/Sun Apr 25 23:07:29 1999//D99.04.19.23.59.59 
floss$ 
@end example

Si ahora usted modificase su copia de hello.c e intentase despu@'es
enviarla al repositorio,

@example
floss$ cvs update 
M hello.c 
floss$ cvs ci -m "intentando cambiar el pasado" 
cvs commit: cannot commit with sticky date for file 'hello.c' 
cvs [commit aborted]: correct above errors first! 
floss$ 
@end example

CVS no permitir@'{@dotless{i}}a la enviar ese fichero al repositorio, puesto que
ser@'{@dotless{i}}a como permitirle volver atr@'as y cambiar el pasado. Lo de CVS
es gestionar historiales, as@'{@dotless{i}} que bajo ning@'un concepto le permitir@'a
realizar semejante operaci@'on.

Esto no significa, sin embargo, que CVS no sea consciente de todas las
revisiones que se hayan enviado desde aquella fecha. Usted sigue
pudiendo comparar la fecha pegada a la copia de trabajo con otras
revisiones, incluso las futuras:

@example
floss$ cvs -q diff -c -r 1.5 hello.c 
Index: hello.c 
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5 
diff -c -r1.5 hello.c 
*** hello.c   1999/04/24 22:09:27     1.5 
--- hello.c   1999/04/25 00:08:44 
*************** 
*** 3,9 **** 
  void 
  main () 
  @{ 
    printf ("¡Hola, mundo!\n"); 
-   printf ("entre hola y adi@'os\n"); 
    printf ("¡Adi@'os, mundo!\n"); 
  @} 
--- 3,9 -- 
  void 
  main () 
  @{ 
+   /* esta l@'{@dotless{i}}nea fue a@~nadida a una copia de trabajo "desactualizada" */ 
    printf ("¡Hola, mundo!\n"); 
    printf ("¡Adi@'os, mundo!\n"); 
  @} 
@end example

El diff revela que, a 19 de abril de 1999, la l@'{@dotless{i}}nea "entre hola y adi@'os"
no hab@'{@dotless{i}}a sido a@~nadida todav@'{@dotless{i}}a. Tambi@'en muestra la modificaci@'on que hicimos
a la copia de trabajo (a@~nadir el comentario que aparece arriba).

Puede eliminar la fecha pegadiza (o cualquier otra propiedad pegadiza)
haciendo una actualizaci@'on con la opci@'on -A ("-A" significa "reiniciar",
no me pregunte por qu@'e), lo que pone la copia de trabajo de nuevo en
sincron@'{@dotless{i}}a con las revisiones m@'as recientes:

@example
floss$ cvs -q update -A 
U hello.c 
floss$ cvs status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.5     Sun Apr 25 22:50:27 1999 
   Repository revision:       1.5     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                (none) 
   Sticky Date:               (none) 
   Sticky Options:    (none) 
floss$ 
@end example

@c -------------------------------------------------------------------
@node Formatos de fecha permitidos
@subsection Formatos de fecha permitidos

CVS admite una gran variedad de formatos cuando se trata de indicar
fechas. Nunca tendr@'a problemas si decide utilizar el formato ISO 8601
(esto es, en la Organizaci@'on Internacional de Est@'andares, el est@'andar
n@'umero 8601, consulte tambi@'en http://www.saqqara.demon.co.uk/datefmt.htm),
que es el formato empleado en los ejemplos precedentes. Puede tambi@'en
utilizar el formato de fecha empleado en el correo electr@'onico v@'{@dotless{i}}a
Internet tal como se describe en los RFC 822 y 1123 (v@'ease
http://www.rfc-editor.org/rfc/). Por @'ultimo, puede utilizar ciertas
construcciones anglosajonas no ambiguas para especificar una fecha
relativa a la fecha actual.

Lo m@'as probable es que nunca necesite utilizar todos los formatos
disponibles, pero aqu@'{@dotless{i}} van algunos ejemplos para darle una idea de lo
que admite CVS:

@example
floss$ cvs update -D "19 Apr 1999" 
floss$ cvs update -D "19 Apr 1999 20:05" 
floss$ cvs update -D "19/04/1999" 
floss$ cvs update -D "3 days ago" 
floss$ cvs update -D "5 years ago" 
floss$ cvs update -D "19 Apr 1999 23:59:59 GMT" 
floss$ cvs update -D "19 Apr" 
@end example

Las comillas que delimitan las fechas est@'an ah@'{@dotless{i}} para asegurar que el
shell de Unix trata la fecha como un @'unico argumento aunque incluya
espacios en blanco. Las comillas no causar@'an ning@'un problema aunque
la fecha no contenga espacios, as@'{@dotless{i}} que probablemente sea mejor usarlas
siempre.

@c -------------------------------------------------------------------
@node Marcar un momento en el tiempo (marcas)
@subsection Marcar un momento en el tiempo (marcas)

Pedir ficheros seg@'un una fecha concreta es @'util cuando el mero paso
del tiempo es su principal preocupaci@'on. Pero normalmente lo que realmente
querr@'a ser@'a obtener el proyecto tal y como estaba al producirse un
determinado evento concreto: quiz@'as el d@'{@dotless{i}}a de hacer una distribuci@'on
p@'ublica, un punto en el que el proyecto se encontraba en su momento
m@'as estable, o la vez que se a@~nadi@'o o elimin@'o cierta caracter@'{@dotless{i}}stica
importante.

Intentar recordar la fecha en la que tuvo lugar un evento en concreto
o deducir la fecha a partir de los informes de cambios ser@'{@dotless{i}}a un proceso
muy tedioso. Presumiblemente, el evento, en caso de que fuese realmente
importante, se marc@'o como tal en el historial formal de revisiones. El
m@'etodo que ofrece CVS para crear este tipo de marcas se conoce como
@dfn{marcado}.

Las marcas ("tags", N. del T.) se diferencian de los env@'{@dotless{i}}os corrientes
en que no registran ning@'un cambio particular en el texto de los ficheros,
sino m@'as bien un cambio en la forma en que los desarrolladores contemplan
los ficheros. Lo que hace una marca es poner una etiqueta al conjunto de
revisiones representadas por la copia de trabajo de un desarrollador
(lo normal es que la copia de trabajo est@'a completamente al d@'{@dotless{i}}a, as@'{@dotless{i}}
que el nombre de la marca se pone a las revisiones "m@'as recientes y
brillantes" presentes en el repositorio).

Poner una marca es tan sencillo como @'esto:

@example
floss$ cvs -q tag Release-1999_05_01 
T README.txt 
T hello.c 
T a-subdir/loquesea.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
floss$ 
@end example

Este comando asocia el nombre simb@'olico "Release-1999_05_01" a la
instant@'anea representada por esta copia de trabajo. Definida formalmente,
una "instant@'anea" es un conjunto de ficheros del proyecto y los n@'umeros
de revisi@'on asociados con ellos. Estos n@'umeros de revisi@'on no tienen
por qu@'e ser los mismos entre varios ficheros, y de hecho no suelen serlo.
Por ejemplo, suponiendo que la marca se hubiera puesto en el mismo
directorio "miproyecto" que hemos estado utilizando en este cap@'{@dotless{i}}tulo
y que la copia de trabajo estuviese completamente al d@'{@dotless{i}}a, el nombre
simb@'olico "Release-1999_05_01" se asociar@'{@dotless{i}}a a la revisi@'on 1.5 de hello.c,
a la revisi@'on 1.2 de fish.c, a la revisi@'on 1.2 de random.c, y a la revisi@'on
1.1 de todo lo dem@'as.

Quiz@'as le ayude el pensar en una marca como en una senda o cadena que une
varias revisiones de ficheros del proyecto. En la Figura 2.1, una cadena
imaginaria pasa por el n@'umero de revisi@'on marcado en cada fichero del
proyecto.


@example

     Fichero A   Fichero B   Fichero C   Fichero D   Fichero E
     ---------   ---------   ---------   ---------   ---------
     1.1         1.1         1.1         1.1         1.1
 ----1.2-.       1.2         1.2         1.2         1.2
     1.3 |       1.3         1.3         1.3         1.3
          \      1.4       .-1.4-.       1.4         1.4
           \     1.5      /  1.5  \      1.5         1.5
            \    1.6     /   1.6   |     1.6         1.6
             \   1.7    /          |     1.7         1.7
              \  1.8   /           |     1.8       .-1.8------->
               \ 1.9  /            |     1.9      /  1.9
                `1.10'             |     1.10    /   1.10
                 1.11              |     1.11    |
                                   |     1.12    |
                                   |     1.13    |
                                    \    1.14    |
                                     \   1.15   /
                                      \  1.16  /
                                       `-1.17-'

[Figura 2.1: La relaci@'on que puede haber entre una marca y determinadas
revisiones de los ficheros.]

@end example

Ahora, si estira la cadena y la observa de forma longitudinal, podr@'a ver
un momento espec@'{@dotless{i}}fico en el historial del proyecto; concretamente, el
momento en el que se fij@'o la marca (Figura 2.2).

@example

     Fichero A   Fichero B   Fichero C   Fichero D   Fichero E
     ---------   ---------   ---------   ---------   ---------
                                         1.1
                                         1.2
                                         1.3
                                         1.4
                                         1.5
                                         1.6
                                         1.7
                 1.1                     1.8
                 1.2                     1.9
                 1.3                     1.10        1.1
                 1.4                     1.11        1.2
                 1.5                     1.12        1.3
                 1.6                     1.13        1.4
                 1.7         1.1         1.14        1.5
                 1.8         1.2         1.15        1.6
     1.1         1.9         1.3         1.16        1.7
 ----1.2---------1.10--------1.4---------1.17--------1.8------->
     1.3         1.11        1.5         1.17        1.9
                             1.6         1.17        1.10
 
[Figura 2.2: La misma marca vista longitudinalmente respecto al historial
de revisiones.]


@end example

A medida que sigue editando ficheros y enviando cambios, la marca *no*
se mover@'a de su sitio a pesar de que los n@'umeros de revisi@'on se vayan
incrementando. Permanece fija, "pegada" al n@'umero de revisi@'on de cada
fichero al que fue asociada.

Dada su importancia como elementos descriptivos, es una pena que los
informes de cambios no puedan ser incluidos con las marcas, y que las
marcas en s@'{@dotless{i}} no puedan ser p@'arrafos de texto reales. En el ejemplo
anterior, la marca indica de forma bastante obvia que el proyecto se
encontraba en un estado "publicable" en una fecha determinada. Sin
embargo, a veces querr@'a hacer instant@'aneas de un estado m@'as complejo,
lo que puede dar lugar a nombres de marcas un tanto extra@~nos, como:


@example
floss$ cvs tag testing-release-3_pre-19990525-public-release 
@end example

Por regla general, deber@'{@dotless{i}}a intentar mantener las marcas lo m@'as simples
posible al tiempo que incluye toda la informaci@'on necesaria sobre el
evento que est@'a intentando registrar. En caso de duda, es mejor pecar
de demasiado descriptivos - lo agradecer@'a m@'as tarde cuando sea capaz de
determinar gracias a una marca extremadamente descriptiva exactamente
qu@'e circunstancia se registr@'o con ella.

Posiblemente se haya dado cuenta de que no se han usado puntos ni
espacios en el nombre de las marcas. CVS es bastante estricto en lo
que ata@~ne a nombres v@'alidos de marcas: las reglas son que deben comenzar
con una letra y tener letras, d@'{@dotless{i}}gitos, guiones ("-"), y signos de subrayado
("_"). No se pueden utilizar espacios, puntos, signos de dos puntos, comas
ni ning@'un otro s@'{@dotless{i}}mbolo.

Para obtener una instant@'anea haciendo referencia a una marca, deber@'a
usar el nombre de esta marca como si fuera un n@'umero de revisi@'on. Hay
dos formas de obtener instant@'aneas: puede obtener una copia de trabajo
nueva con una determinada marca, o bien puede cambiar una copia de trabajo
ya existente por una marca. Ambos m@'etodos tienen como resultado una copia
de trabajo en la que las revisiones de los ficheros son los asociados a
la marca dada.

La mayor parte de las veces, lo que querr@'a hacer es echar un vistazo al
proyecto tal como @'este se encontraba en el momento de hacer la instant@'anea.
No necesariamente querr@'a hacer esto en su copia de trabajo principal, donde
posiblemente tenga cambios a@'un sin enviar y otras cosas importantes que
preferir@'a salvaguardar, as@'{@dotless{i}} que vamos a suponer que simplemente desea
obtener una copia de trabajo por separado, con la marca. As@'{@dotless{i}} es c@'omo se
hace (¡aseg@'urese de invocar este comando desde cualquier otro lugar que
no sea su copia de trabajo actual o su directorio padre!):


@example
floss$ cvs checkout -r Release-1999_05_01 miproyecto 
cvs checkout: Updating miproyecto 
U miproyecto/README.txt 
U miproyecto/hello.c 
cvs checkout: Updating miproyecto/a-subdir 
U miproyecto/a-subdir/loquesea.c 
cvs checkout: Updating miproyecto/a-subdir/subsubdir 
U miproyecto/a-subdir/subsubdir/fish.c 
cvs checkout: Updating miproyecto/b-subdir 
U miproyecto/b-subdir/random.c 
cvs checkout: Updating miproyecto/c-subdir
@end example


Anteriormente hemos visto c@'omo se utilizaba la opci@'on -r con el comando
"update", donde preced@'{@dotless{i}}a a un n@'umero de revisi@'on. En muchos aspectos, una
marca es como un n@'umero de revisi@'on, porque, para cada fichero, cada marca
se corresponde exactamente con *un* n@'umero de revisi@'on concreto (es ilegal,
y generalmente imposible, tener dos marcas con el mismo nombre en el mismo
proyecto). De hecho, en cualquier lugar donde pueda utilizar un n@'umero de
revisi@'on como argumento de un comando de CVS, podr@'a tambi@'en utilizar el
nombre de una marca, siempre y cuando esa marca se haya creado antes.
Si quiere ver las diferencias entre el estado actual de un fichero y el
estado en el que se encontraba en el momento de realizar la @'ultima
distribuci@'on p@'ublica, puede hacer esto:

@example
floss$ cvs diff -c -r Release-1999_05_01 hello.c 
@end example

Y si quiere volver atr@'as temporalmente a aquella revisi@'on, puede hacer
esto:


@example
floss$ cvs update -r Release-1999_05_01 hello.c 
@end example

La posibilidad de intercambiar nombres de marcas y n@'umeros de revisi@'on
explica algunas de las estrictas reglas que definen qu@'e nombre de marca
es v@'alido y cu@'al no. Imagine por un momento que los puntos fueran legales
en los nombres de las marcas; podr@'{@dotless{i}}a tener una marca llamada "1.3" asociada
a un n@'umero real de revisi@'on como puede ser el "1.47". Si ahora emplease
el comando

@example
floss$ cvs update -r 1.3 hello.c 
@end example

¿c@'omo podr@'{@dotless{i}}a CVS saber si se refiere a la marca llamada "1.3", o a la
mucho m@'as antigua revisi@'on 1.3 de hello.c? Es por esto por lo que existen
este tipo de restricciones en los nombres de las marcas, de forma que
siempre puedan distinguirse f@'acilmente de los n@'umeros de revisi@'on. Un
n@'umero de revisi@'on tiene un punto; el nombre de una marca no. (Tambi@'en
hay motivos para las dem@'as restricciones, generalmente para permitir
que los nombres de las marcas sean f@'aciles de interpretar para CVS.)

Como posiblemente habr@'a ya adivinado, el segundo m@'etodo para obtener una
instant@'anea -esto es, pasar un directorio de trabajo ya existente a las
revisiones marcadas- tambi@'en se realiza por medio de una actualizaci@'on:


@example
floss$ cvs update -r Release-1999_05_01 
cvs update: Updating . 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
cvs update: Updating c-subdir 
floss$ 
@end example

Este comando es similar al que utilizamos para devolver hello.c al estado
en el que se encontraba en @code{Release-1999_05_01}, con la salvedad de que se
omite el nombre del fichero dado que queremos volver atr@'as el proyecto al
completo (si lo desea, puede hacer volver atr@'as solamente un sub-@'arbol del
proyecto, invocando este comando mientras se encuentra en ese subdirectorio
en lugar de hacerlo desde el nivel m@'as alto, aunque muy pocas veces querr@'a
hacer esto).

Observe que, a juzgar por los resultados del comando, no parece que haya
cambiado ning@'un fichero. La copia de trabajo estaba completamente al
d@'{@dotless{i}}a cuando pusimos la marca, y no se hab@'{@dotless{i}}a enviado ning@'un cambio desde
entonces.

Sin embargo, esto no significa que no haya habido ning@'un cambio en absoluto.
La copia de trabajo sabe ahora que responde a una revisi@'on marcada. Cuando
hagamos un cambio e intentemos enviarlo al repositorio (supongamos que hemos
modificado hello.c):

@example
floss$ cvs -q update 
M hello.c 
floss$ cvs -q ci -m "intentando enviar desde una copia de trabajo marcada" 
cvs commit: sticky tag 'Release-1999_05_01' for file 'hello.c' is not a branch 
cvs [commit aborted]: correct above errors first! 
floss$ 
@end example

... CVS impide que el env@'{@dotless{i}}o llegue a producirse (no se preocupe de momento
por lo que significa el mensaje de error - m@'as adelante y en este mismo
cap@'{@dotless{i}}tulo trataremos el tema de las "branches", o ramas para entendernos).
Poco importa si la copia de trabajo lleg@'o a tener una marca a trav@'es de la
obtenci@'on de una copia de trabajo ("checkout") o una simple actualizaci@'on;
la cuesti@'on es que, una vez que est@'a marcada, CVS considera la copia de
trabajo como una instant@'anea est@'atica de un momento particular de la
historia, y CVS no le permitir@'a cambiar la historia, o cuando menos
no se lo pondr@'a f@'acil. Si ejecuta "cvs status" o examina los ficheros
CVS/Entries, podr@'a ver que hay una marca pegada a cada fichero. Por
ejemplo, aqu@'{@dotless{i}} tiene el fichero Entries del directorio ra@'{@dotless{i}}z:


@example
floss$ cat CVS/Entries 
D/a-subdir//// 
D/b-subdir//// 
D/c-subdir//// 
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//TRelease-1999_05_01 
/hello.c/1.5/Tue Apr 20 07:24:10 1999//TRelease-1999_05_01 
floss$ 
@end example

Las marcas, como otras propiedades de car@'acter "pegadizo", pueden
eliminarse con la opci@'on -A durante una actualizaci@'on:

@example
floss$ cvs -q update -A 
M hello.c 
floss$ 
@end example

Sin embargo, la modificaci@'on de hello.c no ha desaparecido; CVS todav@'{@dotless{i}}a
sabe que el fichero ha cambiado respecto a su hom@'onimo en el repositorio:

@example
floss$ cvs -q diff -c hello.c 
Index: hello.c 
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5 
diff -c -r1.5 hello.c 
*** hello.c   1999/04/20 06:12:56     1.5 
--- hello.c   1999/05/04 20:09:17 
*************** 
*** 6,9 **** 
--- 6,10 -- 
    printf ("¡Hola, mundo!\n"); 
    printf ("entre hola y adi@'os\n"); 
    printf ("¡Adi@'os, mundo!\n"); 
+   /* un comentario en la @'ultima l@'{@dotless{i}}nea */ 
  @} 
floss$ 
@end example

Ahora que ha puesto las cosas en orden por medio de la actualizaci@'on, CVS
aceptar@'a hacer un env@'{@dotless{i}}o:

@example
floss$ cvs ci -m "a@~nadido un comentario al final de la funci@'on main" 
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
cvs commit: Examining c-subdir 
Checking in hello.c; 
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c 
new revision: 1.6; previous revision: 1.5 
done 
floss$ 
@end example

Por supuesto, la marca @code{Release-1999_05_01} sigue estando asociada a
la revisi@'on 1.5. Compare el estado del fichero de como estaba antes a como
est@'a despu@'es de eliminar la marca:


@example
floss$ cvs -q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.6     Tue May  4 20:09:17 1999 
   Repository revision:       1.6     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                (none) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$ cvs -q update -r Release-1999_05_01 
U hello.c 
floss$ cvs -q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.5     Tue May  4 20:21:12 1999 
   Repository revision:       1.5     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                Release-1999_05_01 (revision: 1.5) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$
@end example

Y ahora que vengo de decirle que CVS no le permite cambiar la historia,
le ense@~nar@'e precisamente c@'omo cambiarla.

@c --------------------------------------------------------------------
@node Ramas
@section Ramas

Hemos estado concibiendo CVS como un tipo de biblioteca inteligente desde
la que establecer una coordinaci@'on; sin embargo, tambi@'en puede pensarse
en CVS como en una m@'aquina del tiempo (gracias a Jim Blandy por la
analog@'{@dotless{i}}a). Por ahora, s@'olo hemos visto c@'omo se puede revisar el pasado
con CVS, sin afectar a nada. Como todas las buenas m@'aquinas del tiempo,
CVS tambi@'en le permite ir hacia atr@'as en el tiempo para cambiar el pasado.
¿Y a d@'onde nos lleva esto? Los amantes de la ciencia-ficci@'on conocen la
respuesta: a un universo alternativo, que discurre de forma paralela
al nuestro, pero que diverge del nuestro justo desde el punto en el que
se alter@'o el pasado. Una rama de CVS divide el desarrollo de un proyecto
en historias separadas, y paralelas. Los cambios efectuados en una de las
ramas no afectan a las dem@'as.

@menu
* Conceptos b@'asicos sobre ramas::
* Fusi@'on de cambios desde las ramas al tronco::
* Fusiones m@'ultiples::
* Crear una marca o rama sin una copia de trabajo::
@end menu

@c --------------------------------------------------------------------
@node Conceptos b@'asicos sobre ramas
@subsection Conceptos b@'asicos sobre ramas

¿Por qu@'e son @'utiles las ramas?

Volvamos por un momento a la situaci@'on del desarrollador que, mientras
est@'a trabajando en una nueva versi@'on del programa, recibe un informe
de fallo relativo a una versi@'on publicada anteriormente. Suponiendo que el
desarrollador corrija el problema, a@'un tiene que encontrar una forma de
enviar la correcci@'on al cliente. No le servir@'a de nada limitarse a tomar
una copia vieja del programa, parchearla a espaldas de CVS, y enviarla
tal cual: no quedar@'{@dotless{i}}a registro alguno de lo que ha hecho, CVS no sabr@'{@dotless{i}}a
nada de esta correcci@'on, y m@'as adelante, si por un casual se descubriera
un fallo en el propio parche, nadie tendr@'{@dotless{i}}a un punto desde el que comenzar
a intentar reproducir el problema.


Es incluso peor intentar solucionar el fallo en la versi@'on actual e
inestable de las fuentes y entregar esto al cliente. Oh s@'{@dotless{i}}, el fallo
del que se ha dado parte quiz@'as quedase resuelto, pero el resto del
c@'odigo est@'a a medio cocer y por lo general falto de un proceso de pruebas
pertinente. Puede darse el caso de que funcione, pero es seguro que no
est@'a listo para llegar al gran p@'ublico.

Dado que se supone que la @'ultima versi@'on distribuida es estable (dejando
aparte este fallo), la soluci@'on ideal es ir atr@'as y corregir el fallo en
la antigua versi@'on; esto es, crear un universo alternativo en el que la
@'ultima versi@'on p@'ublica incluye la correspondiente correcci@'on.

Y aqu@'{@dotless{i}} es donde entran en juego las ramas. El desarrollador planta una
rama, que parte de la l@'{@dotless{i}}nea principal de desarrollo (el tronco), no
en su revisiones m@'as recientes, sino en el punto de la @'ultima distribuci@'on
p@'ublica. Entonces el desarrollador solicita una copia de trabajo de esta
rama, realiza todos los cambios necesarios para solventar el fallo, y
los env@'{@dotless{i}}a a esa rama, de forma que quede un registro de la correcci@'on
del fallo. Ahora puede hacer p@'ublico un parche intermedio basado en esta
rama, y enviarlo al cliente.

Su cambio no habr@'a afectado al c@'odigo del tronco, puesto que tampoco le
interesar@'{@dotless{i}}a hacerlo sin antes averiguar si el tronco necesita o no que se
aplique sobre @'el la misma correcci@'on. En caso positivo, el desarrollador
puede fusionar los cambios realizados sobre la rama con el c@'odigo presente
en el tronco. Durante el proceso de fusi@'on, CVS calcula los cambios hechos
en la rama desde el momento en el que @'esta sali@'o del tronco hasta el extremo
de la misma (su estado m@'as reciente), y entonces aplica estas diferencias
al proyecto, en el extremo final del tronco. La diferencia entre la ra@'{@dotless{i}}z
de la rama y su extremo final vendr@'{@dotless{i}}a a ser, por supuesto, la correcci@'on
que se ha realizado.

Otra buena forma de imaginar una fusi@'on es como un caso especial del
proceso de actualizaci@'on; la diferencia estriba en que, durante una fusi@'on,
los cambios a incorporar se derivan de la comparaci@'on entre la ra@'{@dotless{i}}z y el
extremo de la rama, en lugar de comparar la copia de trabajo con el
contenido del repositorio.

El proceso de actualizaci@'on es en s@'{@dotless{i}} mismo similar a recibir parches
directamente de los autores, y aplicarlos a mano; de hecho, para
hacer una actualizaci@'on, CVS calcula la diferencia (entendiendo como
"diferencia" el resultado que devolver@'{@dotless{i}}a el comando diff al comparar
dos ficheros distintos) entre la copia de trabajo y el repositorio,
para a continuaci@'on aplicar la diferencia a la copia de trabajo tal
y como lo har@'{@dotless{i}}a el programa "patch". Esto equivale a la forma en
que un desarrollador obtiene cambios del mundo exterior, aplicando
manualmente parches creados por otros.

As@'{@dotless{i}} pues, fusionar con el tronco la rama donde se ha hecho la correcci@'on
es exactamente lo mismo que aceptar un parche que ha hecho otra persona
para corregir el fallo. El autor de ese parche habr@'{@dotless{i}}a generado el parche
a partir de la @'ultima versi@'on hecha p@'ublica, de la misma forma que los
cambios en la rama lo son respecto a esa versi@'on. Si esa parte del c@'odigo
en las fuentes actuales no ha variado mucho desde la @'ultima versi@'on p@'ublica,
la fusi@'on tendr@'a @'exito sin ning@'un problema. Ahora bien, si el c@'odigo es
en este momento lo suficientemente diferente, la fusi@'on derivar@'a en
conflicto (en otras palabras, el parche ser@'a rechazado), y ser@'a necesario
cierto trabajo extra. Normalmente esto se resuelve examinando la parte
donde ha surgido el conflicto, haciendo manualmente los cambios necesarios,
y enviando esos cambios al repositorio. La Figura 2.3 muestra gr@'aficamente
lo que sucede en una rama y en una fusi@'on.


@example

            (rama donde se corrigi@'o el error)
           .---------------->---------------.
          /                                 |
         /                                  |
        /                                   |
       /                                    |
      /                                     V (<---- lugar de la fusi@'on)
 ====*===================================================================>
                (l@'{@dotless{i}}nea principal de desarrollo)
  

[Figura 2.3: Una rama que termina con una fusi@'on. El tiempo transcurre
de izquierda a derecha.]

@end example

Ahora vamos a ver los pasos necesarios para llevar a cabo el procedimiento
descrito. Recuerde que no es realmente el tiempo lo que fluye de izquierda
a derecha en el diagrama, sino m@'as bien el historial de revisiones. La
rama no se habr@'a hecho en el momento de la distribuci@'on, sino que es
creada m@'as tarde, aunque enraizada en las revisiones que formaban parte
de la distribuci@'on.

En nuestro caso, supongamos que los ficheros del proyecto han pasado por
muchas revisiones desde que fueron marcados como @code{Release-1999_05_01}, y que
quiz@'as se hayan a@~nadido tambi@'en nuevos ficheros. Al recibir el informe de fallos
relativo a la antigua distribuci@'on, lo primero que querremos hacer ser@'a crear
una rama que parta de la antigua distribuci@'on, que tuvimos el acierto de marcar
conmo @code{Release-1999_05_01}.

Una forma de hacer esto ser@'{@dotless{i}}a obtener primero una copia de trabajo basada
en dicha marca, y a continuaci@'on crear la rama volviendo a marcar con la
opci@'on -b (de "branch", o "rama" en ingl@'es - N. del T.):


@example
floss$ cd .. 
floss$ ls 
miproyecto/ 
floss$ cvs -q checkout -d miproyecto_antigua_dis -r Release-1999_05_01 miproyecto 
U miproyecto_antigua_dis/README.txt 
U miproyecto_antigua_dis/hello.c 
U miproyecto_antigua_dis/a-subdir/loquesea.c 
U miproyecto_antigua_dis/a-subdir/subsubdir/fish.c 
U miproyecto_antigua_dis/b-subdir/random.c 
floss$ ls 
miproyecto/      miproyecto_antigua_dis/ 
floss$ cd miproyecto_antigua_dis 
floss$ ls 
CVS/      README.txt  a-subdir/   b-subdir/   hello.c 
floss$ cvs -q tag -b Release-1999_05_01-bugfixes 
T README.txt 
T hello.c 
T a-subdir/loquesea.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
floss$ 
@end example

Observe bien el @'ultimo comando. Puede parecer un tanto arbitrario el utilizar
"tag" para crear ramas, pero en realidad hay una raz@'on para ello: el nombre
de la marca servir@'a como una etiqueta con la cual podremos m@'as tarde hacer
alusi@'on a esta rama. Las marcas en las ramas no tienen un aspecto diferente
al de las utilizadas en otra parte, y de hecho est@'an sujetas a las mismas
limitaciones. A algunas personas les gusta incluir siempre la palabra "rama"
en el nombre de la marca (por ejemplo @code{Release-1999_05_01-ramadecorrecci@'on}) para
poder distinguir f@'acilmente entre marcas de rama y otros tipos de marcas. Tal
vez le interese tambi@'en a usted hacer lo mismo si alguna que otra vez se
confunde y solicita la rama equivocada.

(Y ya que estamos, observe la opci@'on -d miproyecto_antigua_dis que pasamos
al comando "checkout" en la primer comando CVS. Esto le dice a checkout que
instale la copia de trabajo en un directorio llamado miproyecto_antigua_dis,
de forma que no confundamos estos ficheros con la versi@'on actual de
miproyecto. Tenga cuidado de no confundir este uso de la -d con la opci@'on
global hom@'onima, o con la opci@'on -d del comando "update".)

Por supuesto, la simple ejecuci@'on del comando "tag" no pone la copia de
trabajo en consonancia con la rama. El hecho de marcar no afecta nunca
a la copia de trabajo; tan s@'olo guarda informaci@'on adicional en el
repositorio para permitirle a usted recuperar en un momento posterior
las revisiones de esa copia de trabajo (como una parte est@'atica del
historial o como una rama, seg@'un el caso).

La recuperaci@'on puede hacerse de dos formas (a estas alturas, seguramente
ya se esperaba oir esto). Puede solicitar una nueva copia de trabajo tomada
de la rama:

@example
floss$ pwd 
/home/loquesea 
floss$ cvs co -d miproyecto_rama -r Release-1999_05_01-bugfixes miproyecto 
@end example

o pasar a ella una copia de trabajo ya existente:

@example
floss$ pwd 
/home/loquesea/miproyecto 
floss$ cvs update -r Release-1999_05_01-bugfixes 
@end example

El resultado final es el mismo (bueno, el nombre del directorio ra@'{@dotless{i}}z
de la nueva copia de trabajo puede ser distinto, pero respecto a los fines
de CVS esto no importa). Si su copia de trabajo actual tiene cambios a@'un
sin enviar, probablemente querr@'a utilizar "checkout" en lugar de "update"
para acceder a la rama; de lo contrario, CVS intentar@'a fusionar los cambios
habidos en su copia de trabajo antes de colocarla en la rama. En este caso
podr@'{@dotless{i}}a encontrarse con alg@'un conflicto, y a@'un en caso de que no fuese as@'{@dotless{i}},
seguir@'{@dotless{i}}a sin tener una rama pura: esos ficheros no reflejar@'an realmente el
estado del programa de acuerdo con la marca designada, puesto que algunos
de ellos contendr@'an modificaciones hechas por usted.

Sea como fuere, vamos a suponer que de una forma o de otra usted obtiene
una copia de trabajo operativa desde la rama deseada:

@example
floss$ cvs -q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.5     Tue Apr 20 06:12:56 1999 
   Repository revision:       1.5     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                Release-1999_05_01-bugfixes 
(branch: 1.5.2) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$ cvs -q status b-subdir/random.c 
=================================================================== 
File: random.c                Status: Up-to-date 
   Working revision:  1.2     Mon Apr 19 06:35:27 1999 
   Repository revision:       1.2 /usr/local/cvs/miproyecto/b-subdir/random.c,v 
   Sticky Tag:                Release-1999_05_01-bugfixes (branch: 1.2.2) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$ 
@end example

(El contenido de las l@'{@dotless{i}}neas @w{@code{Sticky Tag}} se explicar@'a en
breve.) Si modifica hello.c y random.c y env@'{@dotless{i}}a los cambios al repositorio,

@example
floss$ cvs -q update 
M hello.c 
M b-subdir/random.c 
floss$ cvs ci -m "corregidos los viejos fallos de puntuaci@'on"
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in hello.c; 
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c 
new revision: 1.5.2.1; previous revision: 1.5 
done 
Checking in b-subdir/random.c; 
/usr/local/cvs/miproyecto/b-subdir/random.c,v  <-  random.c 
new revision: 1.2.2.1; previous revision: 1.2 
done 
floss$ 
@end example

se dar@'a cuenta de que ocurre algo curioso con los n@'umeros de revisi@'on:

@example
floss$ cvs -q status hello.c b-subdir/random.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.5.2.1 Wed May  5 00:13:58 1999 
   Repository revision:       1.5.2.1 /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                Release-1999_05_01-bugfixes (branch: 1.5.2) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
=================================================================== 
File: random.c                Status: Up-to-date 
   Working revision:  1.2.2.1 Wed May  5 00:14:25 1999 
   Repository revision:       1.2.2.1 /usr/local/cvs/miproyecto/b-subdir/random.c,v 
   Sticky Tag:                Release-1999_05_01-bugfixes (branch: 1.2.2) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$ 
@end example

¡Ahora tienen cuatro d@'{@dotless{i}}gitos en lugar de dos!

Un vistazo m@'as de cerca nos revela que el n@'umero de revisi@'on de cada fichero
es simplemente el n@'umero de la rama (tal como se indica en la l@'{@dotless{i}}nea @w{@code{Sticky Tag}}),
con un d@'{@dotless{i}}gito extra al final.

Lo que est@'a presenciando es tan s@'olo una parte del funcionamiento interno
de CVS. Aunque casi siempre utilizar@'a una rama para marcar una divergencia
que afecte a la globalidad del proyecto, en realidad CVS registra la rama
de forma individual, fichero a fichero. Este proyecto ten@'{@dotless{i}}a cinco
ficheros en el momento de crear la rama, as@'{@dotless{i}} que en realidad se han
creado cinco ramas, todas ellas con la misma marca: @code{Release-1999_05_01-bugfixes}.

La mayor@'{@dotless{i}}a de la gente considera esta forma de hacer las cosas como una
implantaci@'on bastante poco elegante por parte de CVS, pero en realidad
lo que estamos viendo aqu@'{@dotless{i}} es parte del legado de RCS: RCS no sab@'{@dotless{i}}a c@'omo
agrupar ficheros en los proyectos, y a pesar de que CVS s@'{@dotless{i}} lo hace, sigue
utilizando c@'odigo heredado de RCS para manejar las ramas.

Por regla general, usted no necesitar@'a preocuparse demasiado por c@'omo CVS
registra las cosas de forma interna, pero en este caso, resulta @'util
comprender la relaci@'on que existe entre n@'umeros de ramas y n@'umeros de
revisiones. Veamos el fichero hello.c; todo lo que estoy a punto de
decirle sobre hello.c se aplica a cualquier otro fichero presente en
la rama, cambiando los n@'umeros de revisi@'on y de rama seg@'un convenga.

En el momento del nacimiento de la rama, el fichero hello.c se encontraba
en su revisi@'on 1.5. Cuando creamos la rama, se a@~nadi@'o un nuevo n@'umero al
final para as@'{@dotless{i}} formar un n@'umero de rama (CVS elige el primer n@'umero entero
par que no sea cero y que est@'e libre). Por tanto, en este caso, el n@'umero
de rama termin@'o siendo @code{1.5.2}. El n@'umero de la rama no es en s@'{@dotless{i}} mismo
un n@'umero de revisi@'on, pero s@'{@dotless{i}} es la ra@'{@dotless{i}}z (es decir, el prefijo) de todos
los n@'umeros de revisi@'on para hello.c que se emplear@'an en esta rama.

Sin embargo, cuando ejecutamos aquel primer comando "CVS status" en una
copia de trabajo ramificada, el n@'umero de revisi@'on de hello.c apareci@'o
como @code{1.5} solamente, y no como @code{1.5.2.0} o algo parecido. Esto se
debe a que la revisi@'on inicial de una rama es siempre la misma que la
revisi@'on que el fichero tiene en el tronco, donde naci@'o la rama. Por tanto,
CVS mostrar@'a el n@'umero de revisi@'on del tronco en el informe de estado
mientras el fichero sea el mismo tanto en la rama como en el tronco.

Una vez que enviamos una nueva revisi@'on al repositorio, hello.c ya no era
igual en el tronco que en la rama: la copia que estaba en la rama hab@'{@dotless{i}}a
cambiado, mientras que la copia presente en el tronco segu@'{@dotless{i}}a igual. Es
por ello por lo que se asign@'o a hello.c su primer n@'umero de revisi@'on de
rama, tal como pudimos comprobar despu@'es de hacer el env@'{@dotless{i}}o en el informe
de estado, donde su n@'umero de revisi@'on aparec@'{@dotless{i}}a claramente como @code{1.5.2.1}.

Esta misma situaci@'on se aplica al fichero random.c. Su n@'umero de
revisi@'on en el momento de crear la rama era @code{1.2}, as@'{@dotless{i}} que su
primera rama es @code{1.2.2}, y el primer nuevo env@'{@dotless{i}}o de random.c en
esta rama recibi@'o el n@'umero de revisi@'on @code{1.2.2.1}.

No existe ninguna relaci@'on num@'erica entre @code{1.5.2.1} y @code{1.2.2.1}.
No hay raz@'on alguna para pensar que forman parte de la misma rama
excepto por el hecho de que ambos ficheros est@'an marcados con
@code{Release-1999_05_01-bugfixes}, y que la marca est@'a asociada a los
n@'umeros de rama @code{1.5.2} y @code{1.2.2} en los respectivos ficheros.
Por tanto, el nombre de la marca es su @'unico recurso en la rama para
concebirla como una entidad global. Aunque es perfectamente posible
trasladar un fichero a una rama usando directamente el n@'umero de revisi@'on,

@example
floss$ cvs update -r 1.5.2.1 hello.c 
U hello.c 
floss$ 
@end example

casi siempre es una mala idea hacerlo, puesto que estar@'{@dotless{i}}a mezclando la
revisi@'on en la rama de un fichero con las revisiones fuera de rama de
otros. ¿Qui@'en sabe qu@'e ficheros podr@'{@dotless{i}}a perder? Es mejor usar la marca
de la rama para referirse a la rama y tratar todos los ficheros de una
sola vez, evitando referirnos a ning@'un fichero en concreto; de esta
forma no tiene que conocer ni preocuparse del n@'umero de revisi@'on de
rama de ning@'un fichero en particular.

Tambi@'en es posible hacer ramas que nacen de otras ramas, hasta llegar
a niveles que podr@'{@dotless{i}}an considerarse absurdos. Por ejemplo, si un fichero
tuviese el n@'umero de revisi@'on @code{1.5.4.37.2.3}, el historial de sus
revisiones podr@'{@dotless{i}}a esquematizarse con algo como esto:

@example
                  1.1
                   |
                  1.2
                   |
                  1.3
                   |
                  1.4
                   |
                  1.5
                 /   \
                /     \
               /       \
           (1.5.2)   (1.5.4)         <--- (@'estos son n@'umeros de ramas)
             /           \
         1.5.2.1        1.5.4.1
            |              |
         1.5.2.2        1.5.4.2
            |              |
          (etc)          (...)       <--- (34 revisiones omitidas por brevedad)
                           |
                        1.5.4.37
                          /
                         /
                   (1.5.4.37.2)      <--- (esto es tambi@'en un n@'umero de rama)
                       /
                      /
               1.5.4.37.2.1
                     |
               1.5.4.37.2.2
                     |
               1.5.4.37.2.3

[Figura 2.4: Un n@'umero extra@~namente elevado de ramificaciones. El tiempo
transcurre hacia abajo.]


@end example

Naturalmente, s@'olo circunstancias muy especiales har@'{@dotless{i}}an necesario tal
grado de ramificaciones, pero, ¿no es agradable saber que CVS llegar@'a
todo lo lejos que usted se proponga? Las ramas anidadas se crean de la misma
forma que cualquier otra rama: obtenga una copia de trabajo de la rama
@code{N}, ejecute "cvs tag -b nombre_de_rama" sobre ella, y de esta forma
crear@'a la rama @code{N.M} en el repositorio (donde @code{N} representa el
n@'umero de revisi@'on de rama apropiado en cada fichero, como por ejemplo
@code{1.5.2.1}, mientras que @code{M} representa la siguiente rama
disponible al final de ese n@'umero, como por ejemplo @code{2}).

@c ----------------------------------------------------------------------
@node  Fusi@'on de cambios desde las ramas al tronco
@subsection  Fusi@'on de cambios desde las ramas al tronco

Ahora que hemos aplicado la correcci@'on del fallo a la rama, sincronicemos
la copia de trabajo con la revisiones m@'as recientes presentes en el tronco
y veamos si tambi@'en all@'{@dotless{i}} es necesaria la correcci@'on. Vamos a obtener la
copia de trabajo desde la rama empleando "update -A" (en este aspecto, las
marcas de rama son como cualquier otra propiedad pegadiza) y entonces ver
las diferencias respecto a la rama que acabamos de dejar:


@example
floss$ cvs -q update -d -A 
U hello.c 
U b-subdir/random.c 
floss$ cvs -q diff -c -r Release-1999_05_01-bugfixes 
Index: hello.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5.2.1 
retrieving revision 1.6 
diff -c -r1.5.2.1 -r1.6 
*** hello.c   1999/05/05 00:15:07     1.5.2.1 
--- hello.c   1999/05/04 20:19:16     1.6 
*************** 
*** 4,9 **** 
  main () 
  @{ 
    printf ("¡Hola, mundo!\n"); 
!   printf ("entre el saludo y la despedida\n"); 
    printf ("¡Adi@'os, mundo!\n"); 
  @} 
--- 4,10 -- 
  main () 
  @{ 
    printf ("¡Hola, mundo!\n"); 
!   printf ("entre hola y adi@'os\n"); 
    printf ("¡Adi@'os, mundo!\n"); 
+   /* un comentario en la @'ultima l@'{@dotless{i}}nea */ 
  @} 
Index: b-subdir/random.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2.2.1 
retrieving revision 1.2 
diff -c -r1.2.2.1 -r1.2 
*** b-subdir/random.c 1999/05/05 00:15:07     1.2.2.1 
--- b-subdir/random.c 1999/04/19 06:35:27     1.2 
*************** 
*** 4,8 **** 
  void main () 
  @{ 
!   printf ("Un n@'umero aleatorio.\n"); 
  @} 
--- 4,8 -- 
  void main () 
  @{ 
!   printf ("un n@'umero aleatorio\n"); 
  @} 
floss$ 
@end example

El comando "diff" muestra que hay una l@'{@dotless{i}}nea que difiere en la revisi@'on
en rama de hello.c, y que la revisi@'on del tronco de este fichero tiene
un comentario cerca del final que la revisi@'on de la rama no tiene.
Mientras, en random.c, la revisi@'on en la rama tiene una "U" may@'uscula y
un punto, mientras que en la revisi@'on presente en el tronco no aparece esto.

Para fusionar los cambios de una rama con la actual copia de trabajo,
haga una actualizaci@'on con la opci@'on -j (la misma j de "juntar" que
utilizamos anteriormente para revertir un fichero a una revisi@'on m@'as
antigua):

@example
floss$ cvs -q update -d -j Release-1999_05_01-bugfixes 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5 
retrieving revision 1.5.2.1 
Merging differences between 1.5 and 1.5.2.1 into hello.c 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2 
retrieving revision 1.2.2.1 
Merging differences between 1.2 and 1.2.2.1 into random.c 
floss$ cvs -q update 
M hello.c 
M b-subdir/random.c 
floss$ cvs -q ci -m "fusi@'on con la rama Release-1999_05_01-bugfixes" 
Checking in hello.c; 
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c 
new revision: 1.7; previous revision: 1.6 
done 
Checking in b-subdir/random.c; 
/usr/local/cvs/miproyecto/b-subdir/random.c,v  <-  random.c 
new revision: 1.3; previous revision: 1.2 
done 
floss$ 
@end example

Este ejemplo toma los cambios habidos desde la ra@'{@dotless{i}}z de la rama hasta su
extremo final y m@'as reciente, y los fusiona con la copia de trabajo actual,
que a partir de ese momento mostrar@'a esas mismas modificaciones como si
sus ficheros hubieran sido editados a mano para llevarlos a ese estado.
Los cambios son entonces aplicados al tronco, puesto que nada hab@'{@dotless{i}}a cambiado
en el repositorio cuando una copia de trabajo sufri@'o un proceso de fusi@'on.

Si bien en este ejemplo no se han producido conflictos, es bastante posible
(e incluso probable) que hubiera algunos en una fusi@'on hecha en un proyecto
real, en cuyo caso estos conflictos tendr@'{@dotless{i}}an que resolverse igual que
cualquier otro conflicto, para a continuaci@'on poder aplicar los cambios.

@c --------------------------------------------------------------------
@node Fusiones m@'ultiples
@subsection Fusiones m@'ultiples

A veces, una rama seguir@'a teniendo un desarrollo activo a@'un despu@'es de
que su contenido haya sido fusionado con el tronco. Por ejemplo, esto
puede suceder si se descubre un segundo fallo en la antigua distribuci@'on
p@'ublica y este fallo ha de ser corregido en la rama. Cabe la posibilidad
de que alguien no hubiese entendido la broma que hay en random.c, as@'{@dotless{i}}
que tendr@'{@dotless{i}}a usted que a@~nadir una l@'{@dotless{i}}nea explic@'andola:


@example
floss$ pwd 
/home/loquesea/miproyecto_rama 
floss$ cat b-subdir/random.c 
/* Imprimir un n@'umero aleatorio. */ 
#include <stdio.h>
void main () 
@{ 
  printf ("Un n@'umero aleatorio.\n"); 
  printf ("¿Ha entendido el chiste?\n"); 
@} 
floss$ 
@end example

y enviar el cambio. Si tambi@'en es necesario fusionar esa correcci@'on en el
tronco, podr@'{@dotless{i}}a tener la tentaci@'on de utilizar el mismo comando "update"
de antes en la copia de trabajo presente en el tronco para llevar a cabo
la "re-fusi@'on":


@example
floss$ cvs -q update -d -j Release-1999_05_01-bugfixes 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5 
retrieving revision 1.5.2.1 
Merging differences between 1.5 and 1.5.2.1 into hello.c 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2 
retrieving revision 1.2.2.2 
Merging differences between 1.2 and 1.2.2.2 into random.c 
rcsmerge: warning: conflicts during merge 
floss$ 
@end example

Como puede ver, este comando no ha tenido el efecto deseado: nos
encontramos con un conflicto, a pesar de que la copia en el tronco no
hab@'{@dotless{i}}a sido modificada y, por tanto, no esper@'abamos encontrarnos ninguno.

El problema reside en que el comando "update" se ha comportado exactamente
de la forma descrita: ha intentado tomar todos los cambios habidos desde
la ra@'{@dotless{i}}z de la rama y su extremo final, y a continuaci@'on fusionarlos tomando
como referencia la copia de trabajo actual. El @'unico problema est@'a en que
algunos de estos cambios ya hab@'{@dotless{i}}an sido fusionados desde esta copia de
trabajo, de ah@'{@dotless{i}} que surgiese el conflicto:


@example
floss$ pwd 
/home/loquesea/miproyecto 
floss$ cat b-subdir/random.c 
/* Imprimir un n@'umero aleatorio. */ 
#include <stdio.h 
void main () 
@{ 
<<<<<<< random.c 
  printf ("Un n@'umero aleatorio.\n"); 
======= 
  printf ("Un n@'umero aleatorio.\n"); 
  printf ("¿Ha entendido el chiste?\n"); 
>>>>>>> 1.2.2.2
@} 
floss$ 
@end example

Llegados a este punto, podr@'{@dotless{i}}a intentar resolver estos conflictos a mano,
dado que no es dif@'{@dotless{i}}cil ver lo que es necesario hacer en cada fichero.
Sin embargo, es todav@'{@dotless{i}}a mejor tomar medidas desde el principio para evitar
conflictos. Pasando dos opciones "-j" en lugar de una, obtendr@'a s@'olo los
cambios habidos desde la @'ultima vez que hizo una fusi@'on con el extremo
final de la rama, en lugar de tener en consideraci@'on todos los cambios
habidos en ella. La primera -j le da el punto inicial de la rama, y la
la segunda es s@'olo el nombre de la rama, que implica su extremo final y
m@'as reciente.

La cuesti@'on entonces es, ¿c@'omo puede especificar el punto de la rama
desde el que quizo la @'ultima fusi@'on? Una forma de hacerlo ser@'{@dotless{i}}a indicar
una fecha junto con el nombre de la marca dispuesta en la rama. CVS
ofrece para ello una sintaxis especial:


@example
floss$ cvs -q update -d -j "Release-1999_05_01-bugfixes:2 days ago" \ 
                     -j Release-1999_05_01-bugfixes 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2.2.1 
retrieving revision 1.2.2.2 
Merging differences between 1.2.2.1 and 1.2.2.2 into random.c 
floss$ 
@end example

Si el nombre de la rama va seguido de un signo de dos puntos y a
continuaci@'on por una fecha en un formato v@'alido para CVS, CVS
incluir@'a solamente los cambios habidos despu@'es de esa fecha.
De este modo, si sabe que la correcci@'on original del fallo se
envi@'o a la rama hace tres d@'{@dotless{i}}as, el comando precedente fusionar@'{@dotless{i}}a
solamente la segunda correcci@'on.

Una forma mejor de hacer esto, en este caso adelant@'andonos para tener
en cuenta este tipo de eventualidades, ser@'{@dotless{i}}a marcar la rama despu@'es de
implantar cada correcci@'on (s@'olo una marca normal; no se trata de iniciar
una nueva rama ni nada parecido). Supongamos que despu@'es de corregir el
fallo en la rama y aplicar la correcci@'on al repositorio, hacemos esto en
la copia de trabajo de la rama:


@example
floss$ cvs -q tag Release-1999_05_01-bugfixes-correc1 
T README.txt 
T hello.c 
T a-subdir/loquesea.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
floss$ 
@end example

De esa forma, cuando llegue el momento de fusionar el segundo cambio en el
tronco, podr@'a utilizar la marca que ha tenido la buena idea de colocar ah@'{@dotless{i}}
para delimitar la revisi@'on anterior:

@example
floss$ cvs -q update -d -j Release-1999_05_01-bugfixes-correc1 \
                     -j Release-1999_05_01-bugfixes
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2.2.1 
retrieving revision 1.2.2.2 
Merging differences between 1.2.2.1 and 1.2.2.2 into random.c 
floss$ 
@end example

Ni que decir tiene que este m@'etodo es mucho mejor que intentar recordar
cu@'anto tiempo hace que hizo tal o cual modificaci@'on, pero s@'olo funcionar@'a
si se acuerda de marcar la rama cada vez que la fusione con el tronco.
La lecci@'on aprendida aqu@'{@dotless{i}} es, por tanto, ¡marcar pronto y a menudo! Es
mejor pecar de tener demasiadas marcas (siempre y cuando tengan nombres
lo suficientemente descriptivos) que de tener muy pocas. En estos @'ultimos
ejemplos que le he dado no hab@'{@dotless{i}}a ninguna necesidad de que la nueva marca
de la rama tuviese un nombre similar al de la marca de la rama en s@'{@dotless{i}}.
Si bien yo utilic@'e el nombre @code{Release-1999_05_01-bugfixes-correc1}, tambi@'en
podr@'{@dotless{i}}a haber sido @code{correc1}; sin embargo, es preferible emplear el
primero, dado que contiene el nombre de la rama y por tanto no existir@'a
la posibilidad de que sea confundido con la marca de alguna otra rama.
(Recuerde que los nombres de las marcas son @'unicos dentro de los ficheros,
no dentro de las ramas. No puede tener dos marcas llamadas @code{correc1} en el
mismo fichero, aunque se refieran a revisiones que se encuentran en
diferentes ramas.)


@c ------------------------------------------------------------------
@node Crear una marca o rama sin una copia de trabajo
@subsection Crear una marca o rama sin una copia de trabajo

Como ya hemos dicho, marcar es algo que afecta al repositorio, no a la copia
de trabajo. Lo cual da pie a que nos preguntemos: ¿por qu@'e entonces es
necesario disponer de una copia de trabajo para marcar?

Pues bien, el @'unico fin que cumple es el de designar qu@'e proyecto y qu@'e
revisiones en concreto de los ficheros del proyecto se est@'an marcando.
Si pudiera especificar el proyecto y las revisiones independientemente
de la copia de trabajo, no ser@'{@dotless{i}}a necesario disponer de @'esta.

Y mire usted por d@'onde, hay una manera de hacer esto: el comando "rtag"
(de "repository tag", o marca de repositorio, N. del T.). Es muy similar
a "tag"; un par de ejemplos bastar@'an para explicar c@'omo se usa. Volvamos
atr@'as al momento en el que lleg@'o a nuestro buz@'on el primer informe de
fallo y necesit@'abamos crear una rama que partiese de la @'ultima distribuci@'on
p@'ublica. En nuestro caso, lo que hicimos fue solicitar una copia de trabajo
con la marca de distribuci@'on y despu@'es ejecutar @w{@code{tag -b}} sobre ella:

@example
floss$ cvs tag -b Release-1999_05_01-bugfixes 
@end example

Esto cre@'o una rama que part@'{@dotless{i}}a de @code{Release-1999_05_01}. Sin embargo,
puesto que conocemos la marca de la distribuci@'on, podr@'{@dotless{i}}amos haberla usado
en un comando "rtag" para indicar d@'onde plantar la rama exactamente, sin
ni siquera procurarnos antes una copia de trabajo:

@example
floss$ cvs rtag -b -r Release-1999_05_01 Release-1999_05_01-bugfixes miproyecto
@end example

Y @'eso es todo. Este comando puede darse desde cualquier lugar, sea dentro o
fuera de una copia de trabajo. Sin embargo, su variable de entorno CVSROOT
debe apuntar, por supuesto, al repositorio, o bien puede referirse a @'el
empleando la opci@'on global -d. Tambi@'en funciona para marcas que no sean
de ramas, pero es menos @'util de esta forma ya que tendr@'a que indicar el
n@'umero de revisi@'on de cada fichero, uno por uno. (O puede referirse a ellos
empleando una marca, pero entonces obviamente ya tendr@'{@dotless{i}}a una marca ah@'{@dotless{i}},
en cuyo caso, ¿para qu@'e iba a querer poner una segunda marca a ese mismo
grupo de revisiones?)


Ahora ya sabe lo suficiente como para manejarse con CVS, y posiblemente lo
bastante como para empezar a trabajar con otras personas en un proyecto.
Todav@'{@dotless{i}}a quedan algunas caracter@'{@dotless{i}}sticas de menos importancia que no se han
abordado, as@'{@dotless{i}} como algunas opciones para los comandos ya comentados, que
tambi@'en resultan @'utiles. Todas ellas ser@'an presentadas donde corresponda a
lo largo de los pr@'oximos cap@'{@dotless{i}}tulos, en situaciones que le mostrar@'an c@'omo
y por qu@'e utilizarlas. Cuando tenga alguna duda, no dude en consultar el
manual Cederqvist, un recurso indispensable para los usuarios habituales de
CVS.


