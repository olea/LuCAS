This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: Top,  Next: Introduccion,  Up: (dir)



Top
***

* Menu:

* Introduccion::                        ¿Que es este libro?
* Una introduccion a CVS::              Uso básico de CVS  -- un tutorial.
* Administracion del Repositorio::      Como manejar el repositorio de CVS.
* CVS avanzado::                        Lo que saben los gurús.
* Problemas y Soluciones::              FAQs y experiencias de la vida real.
* Referencia de CVS::                   Una referencia de los comandos de CVS, variables, etc.
* Herramientas de terceros::            Otras herramientas que trabajan con CVS.
* Índice::
* GNU General Public License::
* GNU Free Documentation License::


File: cvsbook.info,  Node: Introduccion,  Next: Una introduccion a CVS,  Prev: Top,  Up: Top

Introduccion
************

Esto es un conjunto de capítulos de difusión libre y disponibles online
sobre el uso de CVS (Sistema Concurrente de Versiones) para la
colaboración y el control de versiones. Cubre desde la instalación de
CVS hasta el uso avanzado y la administración. Está dirigido a
cualquiera que use o planee usar CVS.

Estos capítulos están extraídos de una trabajo mayor llamado
`Desarrollo de Código Abierto con CVS' (publicado por The Coriolis
Group (http://www.coriolis.com/), ISBN 1-57610-490-7). El resto del
libro - capítulos 1, 3, 5 y 7 - trata de los desafíos y temas
filosóficos de ejecutar un proyecto de Código Abierto usando CVS.

Aunque los capítulos disponibles libremente en sí mismos constituyen un
libro de CVS completo, ¡esperamos que le gusten lo suficiente como para
comprar una copia impresa del libro entero! Puede pedirlo directamente
del editor en
`http://www.coriolis.com/bookstore/bookdetail.cfm?id=1576104907'.

Estos capítulos están disponibles bajo la GNU General Public License
(http://www.gnu.org/copyleft/gpl.html).  Para más información sobre el
software libre en general, visite `http://www.gnu.org/', and
particularly `http://www.gnu.org/philosophy/free-sw.html'.

Para mandar comentarios o errores sobre este material, por favor, mande
un email a <bug-cvsbook@red-bean.com>. Para noticias y actualizaciones,
visite `http://cvsbook.red-bean.com/'.


File: cvsbook.info,  Node: Una introduccion a CVS,  Next: Administracion del Repositorio,  Prev: Introduccion,  Up: Top

Una introduccion a CVS
**********************

     _No puedo imaginarme programar sin él.. ¡sería como saltar en
     paracaídas sin un paracaídas!_

                    _-Brian Fitzpatrick hablando de CVS_

Este capítulo presenta los fundamentos en los que se basa CVS,
ofreciendo a continuación un recorrido detallado por el uso cotidiano
de CVS. Los conceptos se presentan de forma secuencial, así que si es
Ud. un novato en CVS, la mejor manera de leer este capítulo será
empezar por el principio e ir leyéndolo paso a paso, sin saltarse nada.

* Menu:

* Conceptos Básicos::            Cómo pensar en CVS.
* Un día con CVS::               Una sesión de ejemplo.
* Otros comandos útiles de CVS:: Cosas de mayor o menor utilidad.
* Ramas::                        Separar el desarrollo en corrientes paralelas.


File: cvsbook.info,  Node: Conceptos Básicos,  Next: Un día con CVS,  Up: Una introduccion a CVS

Conceptos Básicos
=================

Si nunca ha usado antes CVS (o ningún otro sistema de control de
versiones), es fácil desconcertarse con algunas de las suposiciones que
éste hace. Lo que parece causar más confusión inicialmente sobre CVS,
es que se usa para dos cosas que aparentemente no guardan relación
alguna: guardar registros, y al mismo tiempo hacer posible la
colaboración.  Sin embargo, se da el caso de que estas dos funciones
están estrechamente relacionadas.

Se hizo necesario guardar registros porque las personas querían comparar
el estado actual de un programa con el estado en el que encontraba en
un momento dado en el pasado. Por ejemplo, en el transcurso normal de la
implantación de una nueva función, un desarrollador puede llevar el
programa a un estado en el que resulta inutilizable, estado que
posiblemente perdurará hasta que la implantación de la nueva función
esté casi hecha. Por desgracia, se da la casualidad de que éste suele
ser precisamente el momento en el que alguien informa de un fallo en la
última versión distribuida al público; para solucionar el problema (que
podría estar también presente en la versión actual de las fuentes), el
programa ha de volver de nuevo a un estado utilizable.

Restaurar un estado determinado es tarea fácil si el historial del
código fuente se mantiene bajo CVS. El desarrollador puede simplemente
decir: "Dame el programa tal como estaba hace tres semanas", o quizás,
"Dame el programa en el estado en el que se encontraba en el momento de
hacer nuestra última distribución pública".  Si nunca ha disfrutado de
este cómodo acceso a "fotografías" históricas, posiblemente se
sorprenda de la rapidez con la que llegará a depender de él. En mi
caso, personalmente ahora siempre uso control de revisiones en mis
proyectos de programación, puesto que es algo que me ha salvado en
multitud de ocasiones.

Para comprender cómo está ésto relacionado con la colaboración,
deberemos observar con más detalle el mecanismo ofrecido por CVS para
ayudar a muchas personas a trabajar en un mismo proyecto. Pero, antes
de que lleguemos ahí, echemos un vistazo al mecanismo que CVS *no*
proporciona (o que, por lo menos, no fomenta): el bloqueo de ficheros.
Si ha usado algún otro sistema de control de versiones, quizás esté
familiarizado con el modelo de desarrollo
bloquear-modificar-desbloquear, en el que un desarrollador obtiene
primero un acceso exclusivo de escritura (un bloqueo) sobre el fichero
que va a editar, hace los cambios, y a continuación elimina el bloqueo
para permitir que otros desarrolladores puedan acceder al fichero.  Si
alguien tiene un bloqueo establecido sobre un fichero, esa persona
deberá "liberarlo" para que usted pueda bloquear el fichero y comenzar
a hacer sus cambios (en algunas implantaciones usted podría "robarle" el
bloqueo, pero con frecuencia esto viene a ser una desagradable sorpresa
para la otra persona, ¡y en ningún caso una práctica aconsejable!).

Este sistema es factible cuando los desarrolladores se conocen, saben
quién se propone hacer qué en un momento dado, y pueden comunicarse con
los demás rápidamente en caso de que alguien no pueda trabajar por
tener limitado su acceso. Sin embargo, si el grupo de desarrolladores
se hace demasiado grande o no es posible una comunicación fluida entre
ellos, gestionar cuestiones de bloqueo de ficheros comenzará a restar
tiempo al desarrollo del código, para convertirse en un problema
constante que puede ser contraproducente para el normal discurrir del
proyecto.

CVS propone una solución intermedia: en lugar de obligar a los
desarrolladores a coordinarse entre sí para evitar conflictos, CVS les
permite editar el código de forma simultánea, asume la tarea de
integrar todos los cambios, y guarda un registro de todos los conflictos
que vayan surgiendo. El proceso utiliza el modelo
copiar-modificar-fusionar, que viene a funcionar de la forma siguiente:

  1. El desarrollador A solicita a CVS una copia de trabajo, esto es,
     un árbol de directorios que contiene los ficheros que conforman el
     proyecto. Esta operación es también conocida como "obtener una
     copia" (comando "checkout"), y es como tomar un libro prestado de
     una biblioteca.

  2. El desarrollador A edita libremente su copia de trabajo. Al mismo
     tiempo, otros desarrolladores pueden estar atareados con sus
     propias copias de trabajo. Puesto que todas son copias separadas,
     no hay interferencias: es como si todos los desarrolladores
     tuvieran su propia copia del mismo libro, y todos estuvieran
     trabajando anotando comentarios en los márgenes o reescribiendo
     determinadas páginas de forma independiente.

  3. El desarrollador A termina sus cambios y los envía (comando
     "commit") a CVS junto con un informe de cambios, que es un
     comentario que explica la naturaleza y propósito de los cambios
     que ha realizado. Esto es el equivalente a informar a la
     biblioteca de los cambios que ha hecho al libro y el porqué de los
     mismos. Entonces, la biblioteca incorpora estos cambios a la
     "copia maestra", donde se guardan de forma permanente.

  4. Mientras tanto, y también por medio de CVS, otros desarrolladores
     pueden consultar a la biblioteca para ver si la copia maestra ha
     cambiado recientemente, en cuyo caso CVS actualizará
     automáticamente sus copias de trabajo personales. (Esta parte es
     mágica y maravillosa, y espero que sepa apreciarla. ¡Imagine lo
     diferente que sería el mundo si los libros de verdad funcionasen
     de esta forma!)


Por lo que concierne a CVS, todos los desarrolladores de un proyecto son
iguales. La decisión de cuándo actualizar o cuándo enviar al almacén es
un tema de preferencias personales o de política establecida entre los
miembros que participan en el proyecto. Una de las estrategias más
comunes para proyectos de programación es la de siempre actualizar
antes de empezar a trabajar en un cambio importante, y enviar los
cambios sólo cuando éstos hayan sido finalizados y probados, a fin de
que la copia principal se mantenga en todo momento en un estado
"ejecutable".

Quizás se esté preguntando lo que ocurre cuando los desarrolladores A y
B, cada uno trabajando en su copia de trabajo personal, hacen distintos
cambios al mismo trozo de texto y después ambos envían sus cambios.
Esto se conoce como "conflicto", y CVS se percata del mismo en cuanto
el desarrollador B intenta enviar sus cambios: en lugar de permitir que
el desarrollador B proceda, CVS anuncia que ha descubierto un conflicto
y coloca marcadores de conflicto (marcas de texto fácilmente
reconocibles) en el lugar de su copia local donde se ha descubierto el
conflicto. En ese lugar se mostrarán ambos paquetes de cambios,
convenientemente ordenados para hacer fácil su comparación. El
desarrollador B deberá entonces solucionar el problema y enviar una
nueva revisión con el conflicto resuelto. Quizás los dos
desarrolladores deban hablar entre ellos para solucionar el problema;
CVS sólo avisa a los desarrolladores de que hay un conflicto, dejando
bajo su responsabilidad la tarea de resolverlo.

¿Y qué hay de la copia maestra?  En terminología oficial de CVS, se la
conoce como "repositorio" del proyecto, y es simplemente un árbol de
ficheros guardado en un servidor central. Sin entrar en mucho detalle
sobre su estructura (pero lea *Note Administracion del Repositorio::),
veamos lo que el repositorio debe hacer para cumplir con los requisitos
del ciclo copiar-enviar-actualizar. Considere el siguiente caso:

  1. Dos desarrolladores, A y B, obtienen una copia de trabajo de un
     proyecto al mismo tiempo. El proyecto se encuentra en su punto de
     partida: nadie ha hecho todavía cambio alguno, así que todos los
     ficheros están todavía en su estado original e impoluto.

  2. El desarrollador A empieza de inmediato a trabajar, y pronto envía
     su primer paquete de cambios.

  3. Mientras tanto, el desarrollador B está viendo la televisión.

  4. El desarrollador A, trabajando como si el mundo se acabase al día
     siguiente, envía su segundo paquete de cambios. En este momento, el
     historial del repositorio contiene los ficheros originales,
     seguidos por el primer paquete de cambios introducidos por A, que
     a su vez han ido seguidos por estos últimos cambios.

  5. Mientras tanto, el desarrollador B está jugando a su videojuego
     favorito.

  6. De pronto, el desarrollador C se une al proyecto y obtiene su
     copia de trabajo del repositorio. La copia del desarrollador C
     refleja los dos primeros paquetes de cambios de A, puesto que ya
     estaban en el repositorio cuando C obtuvo su copia.

  7. El desarrollador A, que ha estado programando como un poseso,
     completa y envía su tercer paquete de cambios.

  8. Por último, e ignorando la actividad frenética habida
     recientemente, B decide que es hora de empezar a trabajar. No se
     molesta en actualizar su copia; simplemente comienza a editar
     ficheros, algunos de los cuales pueden ser ficheros en los que A
     ha estado trabajando. Un poco más tarde, el desarrollador B envía
     sus primeros cambios.


Llegados a este punto, pueden suceder dos cosas. Si ninguno de los
ficheros editados por B han sido editados por A, el envío tiene éxito.
Sin embargo, si CVS percibe que algunos de los ficheros de B están
pasados de fecha con respecto a las últimas copias disponibles en el
repositorio, y todos esos ficheros han sido también cambiados por B en
su copia de trabajo, CVS informa a B de que debe hacer una actualización
antes de enviar estos ficheros.

Cuando el desarrollador B efectúa la actualización, CVS reune todos los
cambios realizados por A en la copia local de los ficheros de B. Parte
del trabajo de A puede entrar en conflicto con los cambios no enviados
por B, mientras que otros pueden no hacerlo. Aquellas partes que no lo
hacen son simplemente aplicadas en las copias de B, sin más, pero los
cambios que supongan un conflicto deberán ser resueltos por B para poder
ser enviados.

Si el desarrollador C efectúa ahora una actualización, recibirá del
repositorio algunos cambios nuevos, que serán aquéllos pertenecientes
al tercer envío de A, y los pertenecientes al primero _con éxito_ de B
(que en realidad podrían proceder del segundo intento de B de enviar,
asumiendo que el primer intento de B tuviese como resultado el que B se
viera obligado a resolver algún conflicto).

Para que CVS pueda servir los cambios en la secuencia correcta a los
desarrolladores cuyas copias de trabajo puedan no estar sincronizadas
en mayor o menor grado, el repositorio necesita guardar todos los envíos
recibidos desde el comienzo del proyecto. En la práctica, el repositorio
de CVS los guarda todos en ficheros de diferencias (también llamados
"diffs") sucesivos. Así pues, incluso para una copia de trabajo muy
antigua, CVS es capaz de establecer las diferencias entre la copia de
trabajo y el estado actual del repositorio, y es por tanto capaz de
actualizar la copia de trabajo de una forma eficiente. Esto hace que
los desarrolladores puedan en cualquier momento revisar fácilmente el
historial del proyecto, y conseguir copias de trabajo tan antiguas como
sea necesario.

A pesar de que, estrictamente hablando, el repositorio podría conseguir
los mismos resultados por otros medios, en la práctica guardar ficheros
de diferencias es una forma simple e intuitiva de implantar la
funcionalidad necesaria. Además, este método tiene la ventaja añadida
de que, usando apropiadamente el programa "patch", CVS puede reconstruir
cualquier estado previo del árbol de ficheros y, por tanto, llevar una
copia de trabajo de un estado a otro. Esto permite que cualquiera pueda
obtener una copia del proyecto tal y como era en un momento determinado,
a la vez que permite mostrar las diferencias, en formato diff, entre dos
estados del árbol sin afectar a la copia de trabajo de nadie.

Por lo tanto, las mismas funcionalidades que son necesarias para dar un
útil acceso al historial del proyecto también resultan útiles para
proporcionar a un grupo de desarrolladores descentralizado y
descoordinado la posibilidad de colaborar en el proyecto.

Por ahora, puede ignorar todos los detalles de cómo configurar un
repositorio, administrar el acceso a los usuarios, y navegar por
formatos de fichero específicos de CVS (los cuales se cubrirán en *Note
Administracion del Repositorio::); de momento, nos centraremos en cómo
hacer cambios en una copia de trabajo.

Pero antes, aquí va una rápida explicación de los términos:

   * "Revisión" Un cambio aplicado y registrado en el historial de un
     fichero o conjunto de ficheros. Una revisión es una "instantánea"
     de un proyecto que cambia constantemente.

   * "Repositorio" La copia maestra en la que CVS guarda el historial de
     revisiones al completo efectuadas en un proyecto. Cada proyecto
     tiene exactamente *un* repositorio.

   * "Copia de trabajo" La copia en la que puede de hecho hacer cambios
     al proyecto. Puede haber muchas copias de trabajo de un proyecto
     dado. Por regla general, cada desarrollador tiene su propia copia
     de trabajo.

   * "Obtener una copia" ("check out") Solicitar una copia de trabajo al
     repositorio. Su copia de trabajo refleja el estado del proyecto en
     el momento de obtenerla; cuando Ud. y otros desarrolladores hacen
     cambios, deben enviarlos ("commit") y actualizarlos ("update")
     tanto para "publicar" sus cambios como para ver los que han hecho
     los demás.

   * "Enviar" ("commit") Enviar cambios de su copia local al
     repositorio central.  También conocido como "check-in".

   * "Informe de cambios" Un comentario que se adjunta a una revisión
     cuando ésta se envía, describiendo los cambios realizados. Otros
     pueden leer los informes de cambios para obtener un resumen de lo
     que ha estado sucediendo en un proyecto.

   * "Actualizar" ("update") Incorporar a su copia de trabajo los
     cambios que otros han hecho y están presentes en el repositorio, y
     comprobar si su copia de trabajo tiene algún cambio que no ha
     enviado todavía. Tenga cuidado y no confunda esto con el envío;
     son operaciones complementarias. Recuerde, lo que hace una
     actualización es sincronizar su copia de trabajo con la copia
     presente en el repositorio.

   * "Conflicto" La situación que se da cuando dos desarrolladores
     intentan enviar cambios que han hecho al mismo pasaje de un
     fichero. CVS se da cuenta de ello e informa del conflicto, pero
     son los desarrolladores quienes tienen que resolverlo.



File: cvsbook.info,  Node: Un día con CVS,  Next: Otros comandos útiles de CVS,  Prev: Conceptos Básicos,  Up: Una introduccion a CVS

Un día con CVS
==============

Esta sección describe algunas operaciones básicas de CVS, para a
continuación presentarle un ejemplo de sesión de trabajo que cubre el
uso que suele hacerse de CVS. A medida que vayamos avanzando por esta
guía, empezaremos también a ver cómo funciona CVS interiormente.

Si bien no necesita comprender todos y cada uno de los detalles de CVS
para poder utilizarlo, unos conocimientos básicos de cómo funciona le
serán de inestimable ayuda a la hora de elegir la mejor forma de
conseguir un resultado. CVS se parece más a una bicicleta que a un
coche, en el sentido de que sus mecanismos son completamente
transparentes para quien le interese examinarlos. Al igual que con una
bicicleta, puede subirse encima y empezar a pedalear inmediatamente;
sin embargo, si se toma algún tiempo para aprender cómo funciona el
cambio de marchas, será capaz de utilizarlo de forma mucho más eficaz.
(En el caso de CVS, no estoy seguro de si la transparencia fue un
criterio de diseño deliberado o algo accidental, pero parece que es una
propiedad compartida con muchos otros programas libres. Las
implantaciones que son visibles desde fuera tienen la ventaja de
fomentar el que los usuarios contribuyan [a mejorar el software],
exponiéndoles desde el primer momento el funcionamiento interno del
sistema.)

Cada parte del recorrido hará uso de los conocimientos presentados en
las etapas anteriores. Por tanto, si ésta es su primera vez, le
recomiendo que empiece por el principio y lea el texto de forma
secuencial, sin saltarse nada. El menú presentado abajo está pensado
para ser útil para los visitantes habituales - no debería usarlo para
acceder inmediatamente a una sección que le resulte de particular
interés a menos que esté familiarizado con el material expuesto en las
secciones anteriores.

* Menu:

* Convenciones empleadas en este Recorrido::
* Invocación de CVS::
* Acceder a un Repositorio::
* Comenzar un nuevo Proyecto::
* Obtener una copia de trabajo::
* Versión vs. Revisión::
* Hacer un cambio::
* Ver lo que Ud. (y otros) han hecho - comandos Update y Diff::
* CVS y argumentos implícitos::
* Enviar cambios al repositorio::
* Números de revisión::
* Detección y resolución de conflictos::
* Averiguar quién hizo qué (leyendo informes de cambios)::
* Examinar y deshacer cambios::
* El método lento de deshacer cosas::
* El método rápido de deshacer cosas::


File: cvsbook.info,  Node: Convenciones empleadas en este Recorrido,  Next: Invocación de CVS,  Up: Un día con CVS

Convenciones empleadas en este Recorrido
----------------------------------------

Este recorrido tiene lugar en un entorno UNIX. CVS también funciona en
sistemas operativos Windows y Macintosh, y Tim Endres de Ice Engineering
ha escrito incluso un cliente en Java (véase
http://www.trustice.com/java/jcvs), que puede ejecutarse en cualquier
lugar donde corra Java. Sin embargo, voy a suponer que la mayoría de
los usuarios de CVS -tanto actuales como potenciales- están seguramente
trabajando en un entorno UNIX basado en línea de comandos. Si usted no
figura entre éstos, los ejemplos en el recorrido deberían ser fáciles
de adaptar a otros interfaces. Una vez que entienda los conceptos,
podrá sentarse delante de cualquier interfaz de CVS y empezar a
trabajar con él (créame, yo lo he hecho muchas veces).

Los ejemplos que se presentan en este recorrido están orientados a
personas que van a usar CVS para trabajar en proyectos de programación.
Sin embargo, el uso de CVS es aplicable a todo tipo de documentos de
texto, no sólo a código fuente.

Esta guía también asume que tiene CVS ya instalado (por omisión, está ya
presente en muchos de los sistemas libres UNIX más populares, así que
puede que lo tenga ya instalado sin saberlo) y que ya dispone de acceso
a un repositorio. Incluso si no es así, puede beneficiarse de la
lectura de esta guía. En *Note Administracion del Repositorio::,
aprenderá cómo instalar CVS y configurar repositorios.

Suponiendo que CVS esté ya instalado, debería tomarse un momento para
encontrar el manual de CVS en línea. Se conoce familiarmente como el
"Cederqvist" (tomando el apellido de Per Cederqvist, su autor original),
viene incluido con la fuente de CVS y viene a ser por lo general la
referencia más actualizada que se encuentra disponible. Está escrito en
formato Texinfo y debería estar disponible en sistemas Unix en la
jerarquía de documentación "Info". Puede leerlo con el programa de de
comandos "info":

     floss$ info cvs

o bien pulsando Ctrl+H y después escribiendo "i" (o Esc+x info) dentro
de Emacs. Si ninguno de estos métodos funciona para usted, consulte a su
experto local en Unix (o mire *Note Administracion del Repositorio::
para los problemas relacionados con la instalación). Seguramente querrá
tener el Cederqvist a mano si va a usar CVS regularmente.


File: cvsbook.info,  Node: Invocación de CVS,  Next: Acceder a un Repositorio,  Prev: Convenciones empleadas en este Recorrido,  Up: Un día con CVS

Invocación de CVS
-----------------

CVS es un sólo programa, pero puede hacer muchas cosas diferentes:
actualizar, enviar, ramificar, diferenciar, etc.. Cuando invoque a CVS
deberá especificar qué operación desea realizar. Así pues, el formato de
invocación de CVS viene a ser:

     floss$ cvs comando

Por ejemplo, puede usar

     floss$ cvs update
     floss$ cvs diff
     floss$ cvs commit

etcétera. (No se moleste de momento en intentar ejecutar ninguna de
estas órdenes, puesto que no harán nada mientras no disponga de una
copia de trabajo; pronto llegaremos a ese punto.)

Tanto CVS como sus comandos pueden admitir opciones. Las opciones que
afectan al comportamiento de CVS, independientemente del comando que se
ejecute, se llaman opciones globales, mientras que las opciones que son
específicas de los comandos se llaman simplemente opciones de comando.
Las opciones globales siempre van a la izquierda del comando, mientras
que las opciones de comando van a la derecha. Así, en

     floss$ cvs -Q update -p

-Q es una opción global, y -p es una opción del comando. (Si siente
curiosidad, -Q significa "en silencio", es decir, esta opción eliminaría
toda salida de diagnóstico y mostraría los mensajes de error únicamente
si el comando no puede cumplir con su cometido por alguna razón; por su
parte, -p forzaría el envío de los resultados de la actualización a la
salida estándar, en lugar de hacerlo a los ficheros).


File: cvsbook.info,  Node: Acceder a un Repositorio,  Next: Comenzar un nuevo Proyecto,  Prev: Invocación de CVS,  Up: Un día con CVS

Acceder a un Repositorio
------------------------

Antes de hacer nada, deberá decirle a CVS dónde se encuentra el
repositorio al que desea acceder. Esto no es problema si ya ha obtenido
una copia de trabajo de ese repositorio, dado que cualquier copia de
trabajo sabe de qué repositorio procede, con lo cual CVS puede deducir
automáticamente el repositorio al que corresponde una copia de trabajo
cualquiera. Sin embargo, vamos a suponer que no dispone usted todavía
de una copia de trabajo, así que tiene que decirle a CVS explícitamente
dónde ir. Esto se hace con la opción global -d (de "directorio", una
abreviatura para la que hay una justificación histórica, aunque la -r
de "repositorio" hubiera sido mejor), seguido por la senda que apunta
al repositorio.

Por ejemplo, asumiendo que el repositorio se encuentra en el sistema
local en /usr/local/cvs (un lugar bastante estándar),

     floss$ cvs -d /usr/local/cvs comando

En muchos casos, sin embargo, el repositorio estará en otra máquina, y
por tanto deberá usar la red para llegar hasta él. CVS ofrece varios
métodos de acceso; cuál de ellos será el que utilice es algo que depende
fundamentalmente de los requisitos de seguridad de la máquina en la que
se encuentra alojado el repositorio (a la que, de ahora en adelante, nos
referiremos como "el servidor"). La configuración del servidor para
permitir varios métodos de acceso remoto se comenta en *Note
Administracion del Repositorio::; aquí trataremos sólo la parte de
cliente.

Afortunadamente, todos los métodos de acceso remoto comparten una misma
sintaxis de invocación. En general, para especificar un repositorio
remoto y no uno local, lo que hará es utilizar una senda más larga.
Primero debe indicar al método de acceso, delimitado en cada lado por
símbolos de dos puntos, seguido del nombre de usuario y el nombre del
servidor unidos por el símbolo @, otros dos puntos de separación, y,
finalmente, la senda del directorio del repositorio en el servidor.

Veamos el método de acceso "pserver", que significa "servidor
autentificado por clave":

     floss$ cvs -d :pserver:jluis@cvs.foobar.com:/usr/local/cvs login
     (Logging in to jluis@cvs.foobar.com)
     CVS password: (introduzca aquí su contraseña de CVS)
     floss$

La larga senda del repositorio que sigue a la opción -d ha ordenado a
CVS que use el método de acceso pserver, con el nombre de usuario jluis,
en el servidor cvs.foobar.com, que tiene un repositorio CVS en
/usr/local/cvs.  Por cierto, no hay ninguna razón para que el nombre
del servidor sea "cvs.algun_lugar.com"; esto es simplemente una
convención común, pero podría haber sido también:

     floss$ cvs -d :pserver:jluis@fish.foobar.org:/usr/local/cvs comando

El comando que se ejecutó en nuestro ejemplo fue "login", que verifica
que dispone usted de autorización para trabajar en este repositorio.
CVS le pedirá una contraseña, contactando a continuación con el servidor
para verificarla. Siguiendo la costumbre Unix, "cvs login" no devolverá
ninguna información adicional si la operación tiene éxito, aunque sí
mostrará un mensaje de error si algo sale mal (por ejemplo, si la
contraseña es incorrecta).

Sólo tiene que autentificarse una vez desde su máquina local ante un
servidor CVS. Una vez que el proceso de autentificación tiene éxito, CVS
guarda la contraseña en su directorio personal, en un fichero llamado
.cvspass. CVS consultará este fichero cada vez que se conecte al
repositorio a través del método pserver, así que sólo tiene que
ejecutar "login" la primera vez que acceda a un determinado servidor de
CVS desde un sistema cliente particular. Por supuesto, puede volver a
ejecutar cvs login en cualquier momento, si por ejemplo se hubiera
cambiado la contraseña.

Observación: pserver es en este momento el único método de acceso que
requiere un proceso de autentificación inicial como éste; con el resto
de métodos de acceso puede empezar a ejecutar comandos de CVS
inmediatamente.

Una vez que ha guardado la información de autentificación en su fichero
.cvspass, puede ejecutar otros comandos de CVS utilizando la misma
sintaxis en la línea de comando:

     floss$ cvs -d :pserver:jluis@cvs.foobar.com:/usr/local/cvs comando

Hacer que pserver funcione en Windows puede requerir un paso adicional.
Windows carece del concepto Unix de un directorio personal, así que CVS
no sabe dónde poner el fichero .cvspass; deberá especificar para ello un
lugar concreto. Generalmente se indica la raíz de la unidad C: como el
directorio personal:

     C:\WINDOWS> set HOME=C:
     C:\WINDOWS> cvs -d :pserver:jluis@cvs.foobar.com:/usr/local/cvs login
     (Logging in to jluis@cvs.foobar.com)
     CVS password: (introduzca aquí su contraseña)
     C:\WINDOWS>

Cualquier carpeta existente en la jerarquía de ficheros resultará
válida, aunque posiblemente prefiera evitar utilizar unidades de red,
dado que el contenido de su fichero .cvspass sería entonces visible
para cualquiera que pudiese acceder a esa unidad.

Además de pserver, CVS soporta también los métodos ext -que utiliza un
programa de conexión externo. como rsh ó ssh-, kserver -para el sistema
de seguridad Kerberos versión 4-, y gserver, que usa el GSSAPI, esto es,
el API de Generic Security Services, y también las versiones 5 y
posteriores de Kerberos. Todos estos métodos son similares a pserver,
si bien cada uno presenta sus propias idiosincrasias.

De ellos, el método `ext' es probablemente el que más se usa
habitualmente. Si tiene la posibilidad de conectarse a un servidor
mediante rsh o ssh, puede usar el método `ext'. Puede probarlo de esta
forma:

     floss$ rsh -l jluis cvs.foobar.com
     Password:  (introduzca aquí su contraseña de usuario)

Bien, vamos a asumir que ha entrado y salido con éxito del servidor con
rsh, así que ahora está de nuevo en el sistema cliente original:

     floss$ CVS_RSH=rsh; export CVS_RSH
     floss$ cvs -d :ext:jluis@cvs.foobar.com:/usr/local/cvs comando

La primera línea (empleando la sintaxis del shell Bourne de Unix) da a
la variable de entorno CVS_RSH el valor rsh, que le dice a CVS que
utilice el programa rsh para conectarse. La segunda línea puede ser
cualquier comando de CVS; se le solicitará su contraseña para que CVS
pueda conectarse con el servidor.

Si está en el shell C en lugar del shell Bourne, pruebe esto:

     floss% setenv CVS_RSH rsh

y para Windows, pruebe esto:

     C:\WINDOWS> set CVS_RSH=rsh

El resto de esta guía empleará la sintaxis Bourne; adapte los ejemplos
a su entorno como necesite.

Para usar ssh (el shell seguro) en lugar de rsh, basta con que cree la
variable de entorno CVS_RSH de la forma apropiada:

     floss$ CVS_RSH=ssh; export CVS_RSH

No se eche a temblar por el hecho de que el nombre de la variable es
CVS_RSH y Ud. le está dando el valor ssh. Hay razones históricas para
esto (la socorrida excusa Unix para todo, lo sé...). CVS_RSH puede
apuntar al nombre de cualquier programa capaz de conectarle a un
servidor remoto, ejecutar comandos y recibir su salida. Después de rsh,
ssh es posiblemente el programa más común que cumple estos requisitos,
aunque probablemente existan otros. Tenga en cuenta que este programa
no debe modificar su flujo de información de ninguna manera. Esto deja
fuera al rsh de Windows NT, puesto que convierte (o intenta convertir)
entre las convenciones de fin de línea de DOS y Unix. En su caso,
deberá conseguir algún otro rsh para Windows, o bien utilizar un método
de acceso distinto.

Los métodos gserver y kserver no se utilizan tanto como los demás y no
se cubren aquí. Son bastante parecidos a lo que aquí se ha cubierto
hasta ahora; para más información sobre ellos, lea el Cederqvist.

Si sólo utiliza un repositorio y no quiere estar constantemente
tecleando "-d repositorio", sólo tiene que crear la variable de entorno
CVSROOT (que quizás debería haber sido llamada CVSREPOS, pero ya es
demasiado tarde para eso):

     floss$ CVSROOT=/usr/local/cvs
     floss$ export CVSROOT
     floss$ echo $CVSROOT
     /usr/local/cvs
     floss$

o quizás

     floss$ CVSROOT=:pserver:jluis@cvs.foobar.com:/usr/local/cvs
     floss$ export CVSROOT
     floss$ echo $CVSROOT
     :pserver:jluis@cvs.foobar.com:/usr/local/cvs
     floss$

El resto de esta guía asume que ya ha creado la variable CVSROOT
apuntando a su repositorio favorito, así que los ejemplos no mostrarán
la opción -d. Si necesita acceder a muchos repositorios distintos, no
debería crear la variable CVSROOT, sino limitarse a usar "-d
repositorio" para indicar el repositorio a utilizar.


File: cvsbook.info,  Node: Comenzar un nuevo Proyecto,  Next: Obtener una copia de trabajo,  Prev: Acceder a un Repositorio,  Up: Un día con CVS

Comenzar un nuevo Proyecto
--------------------------

Si está estudiando el manejo de CVS para trabajar en un proyecto que ya
se encuentra bajo control de CVS (es decir, que se guarda en un
repositorio en alguna parte), probablemente querrá saltarse esta parte
e ir directamente a la siguiente, "Obtener una copia de trabajo". Sin
embargo, si lo que desea es tomar un código fuente ya existente y
ponerlo bajo CVS, esta sección es para usted. Fíjese en que, a pesar de
todo, se asume que dispone de acceso a un repositorio; vea *Note
Administracion del Repositorio:: si necesita configurar un repositorio.

Introducir un nuevo proyecto en un repositorio de CVS es lo que se
conoce como "importar". El comando CVS a utilizar, como quizás ya haya
adivinado, es

     floss$ cvs import

excepto que le hacen falta más opciones (y debe estar en el sitio
apropiado) para que el comando tenga éxito. Primero, vaya al directorio
raíz de su árbol de proyectos:

     floss$ cd miproyecto
     floss$ ls
     README.txt  a-subdir/   b-subdir/   hello.c
     floss$

Este proyecto tiene dos ficheros (README.txt y hello.c) en el nivel más
alto, además de dos subdirectorios (a-subdir y b-subdir), y algunos
ficheros más (no mostrados en el ejemplo) dentro de esos subdirectorios.
Al importar un proyecto, CVS importa todo lo que hay en el árbol,
empezando por el directorio actual y yendo a continuación a todos los
directorios que haya por debajo de éste. Por tanto, debería asegurarse
de que sólo los ficheros que hay en este momento en el árbol son los
que desea que formen parte del proyecto de forma permanente. Cualquier
vieja copia de seguridad, borrador, etc., deberían ser eliminados antes.

La sintaxis general del comando de importación es

     floss$ cvs import -m "mensaje" miproyecto marca_suministrador marca_lanzamiento

La opción -m (de "mensaje") sirve para especificar un breve informe que
describe la importación. Éste será el primer informe de cambios que
afecta al proyecto en todo su conjunto; cada envío realizado en el
futuro tendrá su propio informe de cambios. Estos informes son
obligatorios; si no se utiliza la opción -m, CVS lanzará
automáticamente un editor (consultando previamente la variable de
entorno EDITOR) para que escriba en él el informe a utilizar. Una vez
que guarde el informe en disco y salga del editor, el proceso de
importación seguirá adelante.

El siguiente argumento es el nombre del proyecto (usaremos
"miproyecto").  Éste es el nombre con el cual podrá obtener copias
desde el repositorio.  (Lo que realmente sucede es que se crea un
directorio con ese nombre en el repositorio; encontrará más información
al respecto en *Note Administracion del Repositorio::.)  El nombre que
elija no tiene por qué ser igual al del directorio actual, aunque en la
mayoría de los casos lo será.

Los argumentos marca_suministrador y marca_lanzamiento son información
de registro adicional para CVS. No se preocupe de ellos ahora; poco
importa lo que utilice en este momento. En *Note CVS avanzado:: podrá
ver las raras ocasiones en las que son significativos; por ahora,
utilizaremos un nombre de usuario y "start" respectivamente para estos
dos argumentos.

Así pues, ya estamos listos para utilizar import:

     floss$ cvs import -m "importación inicial a CVS" miproyecto jluis start
     N miproyecto/hello.c
     N miproyecto/README.txt
     cvs import: Importing /usr/local/cvs/miproyecto/a-subdir
     N miproyecto/a-subdir/loquesea.c
     cvs import: Importing /usr/local/cvs/miproyecto/a-subdir/subsubdir
     N miproyecto/a-subdir/subsubdir/fish.c
     cvs import: Importing /usr/local/cvs/miproyecto/b-subdir
     N miproyecto/b-subdir/random.c
     
     No conflicts created by this import
     floss$

¡Enhorabuena! Si ha ejecutado este comando (o algo similar), ya ha
hecho por fin algo que afecta al repositorio.

Observando la salida del comando import, se dará cuenta de que CVS
precede cada nombre de fichero con una letra, en este caso la "N" para
indicar que se trata de un nuevo fichero. El uso de una letra a la
izquierda para indicar el estado de un fichero es algo común en la
salida de los comandos de CVS, tal como veremos más adelante también
con los comandos "update" y "checkout".

Llegados a este punto, podría pensar que, puesto que ha importado el
proyecto, puede empezar a trabajar en el árbol inmediatamente. Éste,
sin embargo, no es el caso: el árbol de directorios actual no es
todavía una copia de trabajo de CVS. Fue el origen para el comando de
importación, cierto, pero no por éso se ha convertido por arte de magia
en una copia de trabajo de CVS: para obtener una copia en la que poder
trabajar, deberá tomarla del repositorio.

Pero antes, sin embargo, quizás quiera archivar el árbol de directorios
actual. El motivo es que, una vez que las fuentes están en CVS, no
querrá liarse y editar por error copias que no están bajo control de
versión (puesto que esos cambios no se convertirán en parte del
historial del proyecto). De ahora en adelante querrá hacer todas las
ediciones sobre la copia de trabajo. Por otra parte, no le interesará
eliminar completamente el árbol que ha importado, puesto que no ha
verificado todavía si el repositorio dispone realmente de todos los
ficheros. Por supuesto, puede estar un 99.999% seguro de que es así
dado que el comando de importación no devolvió ningún error, pero, ¿por
qué correr riesgos? A menudo vale la pena ser paranoico, como puede
confirmarle cualquier programador. Así que haga algo como esto:

     floss$ ls
     README.txt  a-subdir/   b-subdir/   hello.c
     floss$ cd ..
     floss$ ls
     miproyecto/
     floss$ mv miproyecto era_miproyecto
     floss$ ls
     era_miproyecto/
     floss$

Hecho. Ahora sigue teniendo los ficheros originales, pero están
claramente marcados como correspondientes a una versión obsoleta, así
que no estarán ahí estorbándole cuando obtenga una verdadera copia de
trabajo. Ahora sí, por fin, está listo para obtenerla.


File: cvsbook.info,  Node: Obtener una copia de trabajo,  Next: Versión vs. Revisión,  Prev: Comenzar un nuevo Proyecto,  Up: Un día con CVS

Obtener una copia de trabajo
----------------------------

El comando para obtener un proyecto es exactamente el que cree que es:

     floss$ cvs checkout miproyecto
     cvs checkout: Updating miproyecto
     U miproyecto/README.txt
     U miproyecto/hello.c
     cvs checkout: Updating miproyecto/a-subdir
     U miproyecto/a-subdir/loquesea.c
     cvs checkout: Updating miproyecto/a-subdir/subsubdir
     U miproyecto/a-subdir/subsubdir/fish.c
     cvs checkout: Updating miproyecto/b-subdir
     U miproyecto/b-subdir/random.c
     
     floss$ ls
     miproyecto/      era_miproyecto/
     floss$ cd miproyecto
     floss$ ls
     CVS/        README.txt  a-subdir/   b-subdir/   hello.c
     floss$

Guau... ¡su primera copia de trabajo! Su contenido es exactamente el
mismo que el que ha importado, con el añadido de un subdirectorio
llamado "CVS". Ahí es donde CVS guarda la información de control de
versiones. De hecho, cada directorio presente en el proyecto tiene un
subdirectorio CVS:

     floss$ ls a-subdir
     CVS/        subsubdir/  loquesea.c
     floss$ ls a-subdir/subsubdir/
     CVS/    fish.c
     floss$ ls b-subdir
     CVS/      random.c

El hecho de que CVS guarde la información de revisiones en
subdirectorios llamados CVS conlleva que su proyecto no puede tener
nunca subdirectorios propios llamados CVS. En la práctica, nunca he
oído que esto supusiese un problema.

Antes de editar ningún fichero, echemos una ojeada a la caja negra:

     floss$ cd CVS
     floss$ ls
     Entries     Repository  Root
     floss$ cat Root
     /usr/local/cvs
     floss$ cat Repository
     miproyecto
     floss$

Nada misterioso por aquí. El fichero Root apunta al repositorio, y el
fichero Repository apunta a un proyecto dentro del repositorio. Si esto
le parece un poco confuso, permítame que se lo explique.

Hay una confusión muy extendida sobre la terminología empleada en CVS,
y es que la palabra "repositorio" se utiliza para hacer referencia a dos
cosas distintas. A veces, se utiliza para aludir al directorio raíz del
repositorio (por ejemplo, /usr/local/cvs), que puede contener muchos
proyectos; esto es a lo que se refiere el fichero Root. Pero, otras
veces, se refiere a un subdirectorio particular específico de un
proyecto dentro de la raíz de un repositorio (por ejemplo
/usr/local/cvs/miproyecto, /usr/local/cvs/tuproyecto, o
/usr/local/cvs/fish). El fichero "Repository" dentro de un
subdirectorio CVS toma el segundo significado.

En este libro, "repositorio" generalmente significa "raíz", es decir, el
repositorio situado en el nivel más alto, si bien, ocasionalmente, se
usará para hacer referencia a un subdirectorio específico de un
proyecto.  Si el sentido que se le intenta dar no queda claro dentro
del contexto, habrá texto que lo clarifique. Tenga en cuenta que el
fichero "Repository" puede a veces contener la senda absoluta al nombre
del proyecto en lugar de una senda relativa. Esto hace un tanto
redundante al fichero Root:

     floss$ cd CVS
     floss$ cat Root
     :pserver:jluis@cvs.foobar.com:/usr/local/cvs
     floss$ cat Repository
     /usr/local/cvs/miproyecto
     floss$

El fichero "Entries" contiene información sobre cada uno de los ficheros
que forman parte del proyecto. Cada línea se corresponde con un fichero,
y sólo hay líneas para ficheros o subdirectorios en el directorio padre
inmediato. Éste es el fichero CVS/Entries del directorio raíz de
miproyecto:

     floss$ cat Entries
     /README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//
     /hello.c/1.1.1.1/Sun Apr 18 18:18:22 1999//
     D/a-subdir////
     D/b-subdir////

El formato de cada línea es

     /nombre de fichero/número de revisión/fecha de última modificación//

y las líneas de directorios vienen precedidas de la letra "D". En
realidad, CVS no guarda un historial de los cambios realizados en los
directorios, así que los campos de número de revisión y fecha están
vacíos.

Las marcas de fecha guardan la fecha y hora de la última actualización
(en horario universal, no local) de los ficheros presentes en la copia
de trabajo. De esta forma, CVS puede saber fácilmente si un fichero ha
sido modificado desde la última obtención de copia de trabajo,
actualización o envío. Si la fecha registrada por el sistema de
ficheros difiere de la fecha anotada en el fichero CVS/Entries, CVS
sabe (sin ni siquiera tener que consultar el repositorio) que el
fichero ha sido probablemente modificado.

Si examina los ficheros CVS/* en uno de los subdirectorios

     floss$ cd a-subdir/CVS
     floss$ cat Root
     /usr/local/cvs
     floss$ cat Repository
     miproyecto/a-subdir
     floss$ cat Entries
     /loquesea.c/1.1.1.1/Sun Apr 18 18:18:22 1999//
     D/subsubdir////
     floss$

verá que el repositorio raíz no ha cambiado, pero el fichero
"Repository" indica la situación de este subdirectorio dentro del
proyecto, y el fichero "Entries" contiene líneas distintas.

Inmediatamente después de hacer una importación, el número de revisión
de cada fichero en el proyecto se muestra como 1.1.1.1. Este número
inicial de revisión es un caso un poco especial, así que no lo veremos
en detalle aún; echaremos un vistazo más de cerca a los números de
revisión una vez que hayamos hecho algunos cambios.


File: cvsbook.info,  Node: Versión vs. Revisión,  Next: Hacer un cambio,  Prev: Obtener una copia de trabajo,  Up: Un día con CVS

Versión vs. Revisión
--------------------

El número interno de revisión que CVS guarda para cada fichero no tiene
nada que ver con el número de versión del producto del que los ficheros
forman parte. Por ejemplo, puede tener un proyecto formado por tres
ficheros, cuyos números internos de revisión a 3 de mayo de 1999 eran
1.2, 1.7 y 2.48.  Ese mismo día, empaqueta una nueva distribución del
programa y la distribuye como ChachiSoft Versión 3. Esto es una
decisión puramente de marketing y no afecta para nada a las revisiones
de CVS. Los números de revisión de CVS son invisibles para sus clientes
(a menos que les dé acceso al repositorio); el único número visible al
público es el "3" de Versión 3. Por lo que respecta a CVS, podría
haberlo llamado Versión 1729 si lo desease; el número de versión (o de
distribución) no tiene nada que ver con el seguimiento interno de
cambios que realiza CVS.

Para evitar confusiones, emplearé la palabra "revisión" para referirme
solamente a los números de revisión interna de los ficheros controlados
por CVS. A pesar de ello, me tomaré la libertad de llamar a CVS un
"sistema de control de versiones", puesto que "sistema de control de
revisiones" suena demasiado pedante.


File: cvsbook.info,  Node: Hacer un cambio,  Next: Ver lo que Ud. (y otros) han hecho - comandos Update y Diff,  Prev: Versión vs. Revisión,  Up: Un día con CVS

Hacer un cambio
---------------

El proyecto, tal y como está en estos momentos, no hace mucho. Aquí
están los contenidos de hello.c:

     floss$ cat hello.c
     #include <stdio.h>
     
     void
     main ()
     {
        printf ("¡Hola, mundo!\n");
     }

Ea, vamos a realizar nuestro primer cambio al proyecto desde que lo
importamos; vamos a añadir la línea

     printf ("¡Adiós, mundo!\n");

justo después de "¡Hola, mundo!". Llame a su editor favorito y haga el
cambio:

     floss$ emacs hello.c
       ...

Éste ha sido un cambio relativamente sencillo, en el que es poco posible
que olvide lo que hizo. Pero en un proyecto más amplio, y más complejo,
es muy posible que se ponga a editar un fichero, sea interrumpido por
otra cosa, y, cuando vuelva varios días más tarde, sea incapaz de
recordar exactamente lo que hizo, o incluso si cambió algo en absoluto.
Lo cual nos trae a nuestra primera situación "CVS salva su vida":
comparar su copia de trabajo con la que se encuentra en el repositorio.

