This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: Ficheros informativos,  Next: Subdirectorios,  Up: Anatomia de una distribucion CVS

Ficheros informativos
---------------------

En el nivel superior del árbol de la distribución, encontrará algunos
ficheros que contienen información útil (y enlaces a información más
detallada).  Estos ficheros son, en orden de importancia aproximado:

   * `NEWS' - Este fichero enumera los cambios de una versión a la
     siguiente, en orden cronológico inverso (es decir, la más reciente
     al principio).  Si ya ha estado usando CVS durante un tiempo y se
     ha actualizado a una nueva versión, debería mirar en el fichero
     NEWS para ver qué nuevas funciones están disponibles.  Además,
     aunque la mayoría de los cambios de CVS conservan compatibilidad
     hacia atrás, de vez en cuando hay cambios no compatibles. Es mejor
     leer algo acerca de ellos aquí que sorprenderse cuando CVS no se
     comporte como espera que lo haga.

   * `BUGS' - Este fichero contiene exactamente lo que piensa: una
     lista de errores conocidos en CVS.  Generalmente no harán que la
     versión de CVS sea inutilizable, pero debería leer el fichero cada
     vez que instale una nueva versión.

   * `DEVEL-CVS' - Este fichero es la "constitución" de CVS.  Describe
     el proceso mediante el cual se aceptan los cambios en la
     distribución principal de CVS y los procedimientos mediante los
     que una persona se convierte en desarrollador de CVS.  No necesita
     leerlo si sólo quiere usar CVS; sin embargo, resulta muy
     interesante si quiere comprender cómo los esfuerzos descoordinados
     de gente repartida por todo el mundo convergen en un programa que
     funciona.  Y por supuesto, hace falta leerlo si planea enviar un
     parche (sea para reparar un error o para una nueva característica)
     a CVS.

   * `HACKING' - Pese a su nombre, el fichero HACKING no dice mucho del
     diseño o implementación de CVS.  Es principalmente una guía de
     estándares de programación y otros asuntos técnicos para gente que
     piense en escribir un parche para CVS.  Puede verse como un
     apéndice del fichero DEVEL-CVS.  Después de comprender la
     filosofía básica del desarrollo de CVS, debe leer el fichero
     HACKING para traducir esta filosofía a unas prácticas concretas de
     programación.

   * `FAQ' - Éste es el documento de "Preguntas Frecuentes" (FAQ o
     "Frequently Asked Questions" en inglés). Desgraciadamente ha
     tenido una historia de mantenimiento bastante irregular.  David
     Grubbs se encargó de él hasta 1995.  En ese momento
     (presumiblemente) estaba muy ocupado, y el fichero languideció
     durante un tiempo.  Finalmente, in 1997, Pascal Molli retomó el
     mantenimiento.  Molli tampoco tuvo tiempo para mantenerlo a mano,
     pero al menos encontró tiempo para ponerlo en su sistema
     automático FAQ-O-Matic, que permite al público mantener las FAQ de
     un modo descentralizado (básicamente, cualquiera puede editar o
     añadir entradas mediante un formulario Web).  Probablemente esto
     fue una buena idea, puesto que al menos las FAQ están siendo
     actualizadas de nuevo; sin embargo, la organización general y el
     control de calidad no son del mismo nivel que si una única persona
     las mantuviera.

     La versión maestra de las FAQ está siempre disponible en el sitio
     Web de Molli (`http://www.loria.fr/~molli/cvs-index.html', bajo el
     enlace "Documentation").  El fichero FAQ que se encuentra en las
     distribuciones CVS se genera automáticamente desde la base de
     datos de FAQ-O-Matic, así que para cuando llega al público está un
     poco anticuado. Sin embargo, puede ser de gran ayuda si busca
     sugerencias y ejemplos sobre cómo hacer algo específico (como
     fusionar una rama enorme al tronco o "resucitar" un fichero
     eliminado).  La mejor forma de usarlo es como documento de
     referencia; puede abrirlo en su editor favorito y hacer búsquedas
     de los términos que le interesen.  Intentar usarlo como un
     tutorial sería un error - le faltan demasiados puntos importantes
     sobre CVS para servir de guía completa.



File: cvsbook.info,  Node: Subdirectorios,  Next: El manual Cederqvist,  Prev: Ficheros informativos,  Up: Anatomia de una distribucion CVS

Subdirectorios
--------------

La distribución CVS contiene unos cuantos subdirectorios.  En el curso
de una instalación normal no tendrá que navegar por ellos, pero si
quiere curiosear por las fuentes, está bien saber qué hace cada cosa.
Aquí están:

     contrib/
     diff/
     doc/
     emx/
     lib/
     man/
     os2/
     src/
     tools/
     vms/
     windows-NT/
     zlib/

La mayoría de ellos pueden ignorarse.  Los subdirectorios emx/, os2/,
vms/, and windows-NT/ contienen código fuente específico del sistema
operativo, por lo que usted sólo los necesitaría si realmente está
tratando de arreglar un problema a nivel de código en CVS (una situación
improbable, aunque no sería la primera vez).  Los subdirectorios diff/
and zlib/ contienen implementaciones internas de CVS del programa diff
y de la biblioteca de compresión GNU zip, respectivamente. (CVS usa la
última para reducir el número de bits que tiene que enviar por la red
cuando accede a repositorios remotos.)

Los subdirectorios contrib/ y tools/ contienen programas libres hechos
por terceros para usarse con CVS.  En contrib/, encontrará una
ordenación de guiones de consola ("shell scripts", N. del T.) pequeños y
especializados (lea contrib/README para averiguar lo que hacen).  El
subdirectorio tools/ solía contener contribuciones, pero ahora contiene
un fichero README que dice en parte:

     Este subdirectorio antiguamente contenía herramientas que pueden usarse
     con CVS.  En particular, solía contener una copia de la versión 1.x de
     pcl-cvs. Pcl-cvs es una interfaz de Emacs para CVS.
     
     Si está buscando pcl-cvs le sugerimos la versión 2.x de pcl-cvs en:
         ftp://ftp.weird.com/pub/local/

El paquete PCL-CVS a que se refiere es muy práctico, y tengo más que
decir sobre él en *Note Herramientas de terceros::.

Los subdirectorios src/ y lib/ contienen el grueso del código fuente de
CVS, incluido el codigo interno de CVS.  Las principales estructuras de
datos y órdenes están implementados en src/, mientras que lib/ contiene
pequeños módulos de código de utilidad general que usa CVS.

El subdirectorio man/ contiene las páginas man de CVS (para el sistema
de manual en línea de Unix).  Cuando ejecutó "make install", se
incorporaron dentro de las páginas man de su sistema Unix, así que
puede escribir

     floss$ man cvs

y conseguir una introducción y referencia de subórdenes (algo concisas)
para CVS.  Aunque son útiles como referencia rápida, las páginas del
manual pueden no estar tan actualizadas ni ser tan completas como el
manual Cederqvist (vea la próxima sección); sin embargo, si sirve de
consuelo, es más probable que las páginas del manual estén incompletas
que realmente sean incorrectas.


File: cvsbook.info,  Node: El manual Cederqvist,  Next: Otras fuentes de información,  Prev: Subdirectorios,  Up: Anatomia de una distribucion CVS

El manual Cederqvist
--------------------

Con esto llegamos al subdirectorio doc/, cuyo habitante más importante
es el famoso "Cederqvist".  Hoy en día seguramente sea excesivo llamarlo
"el Cederqvist".  Aunque Per Cederqvist (de Signum Support, Linkoping
Suecia, www.signum.se) escribió la primera versión alrededor de 1992,
muchas otras personas lo han actualizado desde entonces.  Por ejemplo,
cuando los desarrolladores añaden una nueva característica a CVS,
generalmente también la documentan en el Cederqvist.

El Manual Cederqvist está escrito en formato Texinfo, usado por el
proyecto GNU porque es relativamente fácil producir salidas tanto en
línea como impresas a partir de él (en los formatos Info y PostScript
respectivamente).  El fichero maestro Texinfo es doc/cvs.texinfo, pero
las distribuciones CVS vienen con los ficheros Info y PostScript
pregenerados, así que no tiene que preocuparse de ejecutar herramientas
Texinfo.

Aunque el Cederqvist puede usarse como introducción y tutorial,
probablemente sea más útil como documento de referencia.  Por esa
razón, la mayoría de la gente navega por él en línea en lugar de
imprimirlo (aunque el fichero PostScript es `doc/cvs.ps', para aquellos
que tengan papel de sobra).  Si ésta es la primera vez que ha instalado
CVS en su sistema, tendrá que hacer un paso extra para asegurarse de
que el manual está accesible en línea.

Los ficheros Info (doc/cvs.info, doc/cvs.info-1, doc/cvs.info-2, etc.)
se instalaron cuando ejecutó "make install".  Aunque los ficheros se
copiaron en el árbol Info del sistema, puede que aún tenga que añadir
una línea para CVS en la tabla de contenidos de Info, el nodo "Top".
(Esto sólo será necesario si es la primera vez que ha instalado CVS en
su sistema; de lo contrario, la entrada de instalaciones anteriores
debería estar ya en la tabla de contenidos.)

Si ha añadido nueva documentación Into antes, puede que esté
familiarizado con el proceso.  Primero averigüe dónde se instalaron las
páginas Info.  Si usó la instalación por defecto (en /usr/local/),
entonces los ficheros Info son /usr/local/info/cvs.info*.  Si al
instalar usó

     floss$ ./configure --prefix=/usr

los ficheros acabaron siendo /usr/info/cvs.*.  Después de localizar los
ficheros, necesitará añadir una línea para CVS en la tabla de
contenidos de Info, que está en un fichero llamado dir en ese
directorio (así que en el último caso sería /usr/info/dir).  Si no
tiene acceso como root pídale a su administrador que lo haga.  Aquí hay
un extracto de dir antes de añadir la referencia a la documentación CVS:

     * Bison: (bison).         The Bison parser generator.
     * Cpp: (cpp).             The GNU C preprocessor.
     * Flex: (flex).           A fast scanner generator

Y aquí está la misma zona de dir despues:

     * Bison: (bison).         The Bison parser generator.
     * Cpp: (cpp).             The GNU C preprocessor.
     * Cvs: (cvs).             Concurrent Versions System
     * Flex: (flex).           A fast scanner generator

El formato de la línea es muy importante.  Debe incluir el asterisco,
los espacios y los dos puntos en `* Cvs:', y los paréntesis y el punto
en `(cvs).' detrás de él.  Si falta cualquiera de estos elementos, el
formato del Info dir estará corrupto, y será incapaz de leer el
Cederqvist.

Una vez que el manual esté instalado y referenciado desde la tabla de
contenidos, podrá leerlo con cualquier navegador compatible con Info.
Los que estarán instalados con mayor seguridad en un sistema Unix
típico son el lector Info de línea de órdenes, que puede invocarse así
si quiere ir directo a las páginas de CVS

     floss$ info cvs

y el incluido en Emacs, que se invoca escribiendo

     M-x info

o

     C-h i

Tómese el tiempo necesario para conseguir poner a punto el Cederqvist
correctamente en su sistema cuando instale CVS; acortará mucho el
camino cuando tenga que buscar algo.


File: cvsbook.info,  Node: Otras fuentes de información,  Prev: El manual Cederqvist,  Up: Anatomia de una distribucion CVS

Otras fuentes de información
----------------------------

Además del Cederqvist, las FAQ, y los demás ficheros de la propia
distribución, hay recursos de Internet dedicados a CVS.  Si va a
administrar un servidor CVS seguramente quiera unirse a la lista de
correo info-cvs.  Para suscribirse envíe un mensaje a
<info-cvs-request@gnu.org> (la lista en sí es <info-cvs@gnu.org>).  El
tráfico puede ser de medio a alto, de unos 10 a 20 mensajes diarios,
casi siempre preguntas buscando respuestas. La mayoría de ellas pueden
borrarse sin leerlas (a no ser que quiera ayudar a la gente
respondiendo a sus preguntas, que siempre está bien), pero de vez en
cuando alguien anuncia el descubrimiento de un error, o un parche que
implementa alguna característica que usted ha estado esperando.

También puede apuntarse a la lista de correo formal de informes de
errores, que incluye todos los informes de error enviados. Probablemente
no sea necesario, a menos que pretenda ayudar a arreglar los errores,
que sería estupendo, o que sea terriblemente paranoico y quiera estar
enterado de todos los problemas que otros encuentren con CVS. Si quiere
apuntarse, envíe un mensaje a <bug-cvs-request@gnu.org>.

También hay un grupo de noticias de Usenet, `comp.software.config-mgmt',
en el que se habla de control de versiones y sistemas de administración
de configuraciones en general, y donde hay mucha discusión acerca de
CVS.

Por último, hay al menos tres sitios Web dedicados a CVS.  El de Cyclic
Software `http://www.cyclic.com' ha sido la página principal informal
de CVS durante algunos años, y probablemente lo seguirá siendo en el
futuro próximo.  Cyclic Software también proporciona espacio en el
servidor y acceso por red para el repositorio en el que se guardan las
fuentes de CVS.  Las páginas web de Cyclic contienen multitud de
enlaces a parches experimentales para CVS, herramientas de terceros que
trabajan con CVS, documentación, archivos de listas de correo, y todo
lo demás.  Si no puede encontrar lo que necesita en la distribución,
`http://www.cyclic.com' es el lugar para empezar a buscar.

Otros dos buenos sitios son el de Pascal Molli
`http://www.loria.fr/~molli/cvs-index.html' y el de Sean Dreilinger
`http://durak.org/cvswebsites/'.  La mayor atracción del sitio de Molli
la forman, por supuesto, las FAQ, pero también tiene enlaces a
herramientas relacionadas con CVS y archivos de listas de correo.  El
sitio de Dreilinger se especializa en información sobre el uso de CVS
para administrar documentos Web y también tiene un motor de búsqueda
específico para CVS.


File: cvsbook.info,  Node: Iniciando un repositorio,  Next: El servidor de autentificacion de contrasen~as,  Prev: Anatomia de una distribucion CVS,  Up: Administracion del Repositorio

Iniciando un repositorio
========================

Una vez que el ejecutable CVS esté instalado en su sistema, podrá
empezar a usarlo en seguida como cliente para acceder a repositorios
remotos, siguiendo los procedimientos descritos en *Note Una
introduccion a CVS::.  Sin embargo, si quiere servir revisiones desde
su máquina, tendrá que crear un repositorio en ella.  La orden para
hacerlo es

     floss$ cvs -d /usr/local/nuevorepos init

donde `/usr/local/nuevorepos' es la ruta a donde usted quiera que esté
el repositorio (por supuesto, deberá tener permiso de escritura en ese
directorio, lo que podría implicar ejecutar la orden como root).  En
cierto modo puede parecer poco intuitivo que la localización del
repositorio nuevo se especifique antes de la suborden init en lugar de
después de él, pero usando la opción -d sigue siendo consistente con
otras órdenes CVS.

La orden acabará silenciosamente después de ejecutarse.  Vamos a
examinar el nuevo directorio:

     floss$ ls -ld /usr/local/nuevorepos
     drwxrwxr-x   3 root     root         1024 Jun 19 17:59 /usr/local/nuevorepos/
     floss$ cd /usr/local/nuevorepos
     floss$ ls
     CVSROOT
     floss$ cd CVSROOT
     floss$ ls
     checkoutlist     config,v        history     notify     taginfo,v
     checkoutlist,v   cvswrappers     loginfo     notify,v   verifymsg
     commitinfo       cvswrappers,v   loginfo,v   rcsinfo    verifymsg,v
     commitinfo,v     editinfo        modules     rcsinfo,v
     config           editinfo,v      modules,v   taginfo
     
     floss$

El único subdirectorio del repositorio nuevo - CVSROOT/ - contiene
varios ficheros de administración que controlan el comportamiento de
CVS.  Más adelante examinaremos esos ficheros uno a uno; por ahora,
nuestro objetivo sólo es conseguir que el repositorio funcione.  En
este caso, "funcionar" significa que los usuarios puedan importar,
actualizar, obtener copias de trabajo y enviar cambios a los proyectos.

No hay que confundir la variable de entorno CVSROOT introducida en
*Note Una introduccion a CVS:: con este subdirectorio CVSROOT del
repositorio.  No tienen nada que ver - es una coincidencia
desafortunada que compartan el mismo nombre.  La primera es una forma
de evitarles a los usuarios tener que teclear
`-d <situación-del-repositorio>' cada vez que usen CVS; el segundo es
el directorio de administración de un repositorio.

Una vez que el repositorio se haya creado, deberá ocuparse de sus
permisos.  CVS no requiere de ningún permiso estándar particular o
sistema de propiedad de ficheros; simplemente necesita acceso de
escritura al repositorio.  Sin embargo - en parte por razones de
seguridad, pero sobre todo por su propia salud como administrador -
recomiendo encarecidamente que siga los siguientes pasos:

  1. Añada un grupo de Unix `cvs' a su sistema.  Cualquier usuario que
     necesite acceder al repositorio debería estar en el grupo.  Por
     ejemplo, la línea del fichero `/etc/group' de mi máquina es:

          cvs:*:105:kfogel,sussman,jimb,noel,lefty,fitz,craig,anonymous,jluis

  2. Haga que la propiedad y permisos del repositorio reflejen este
     nuevo grupo:

          floss$ cd /usr/local/nuevorepos
          floss$ chgrp -R cvs .
          floss$ chmod ug+rwx . CVSROOT


Ahora cualquiera de los usuarios listados en el grupo podrá empezar un
proyecto ejecutando `cvs import' como se describió en *Note Una
introduccion a CVS::. Las órdenes "checkout", "update" y "commit"
también deberían funcionar.  También podrán entrar en el repositorio
desde localizaciones remotas usando el método `:ext:', asumiendo que
tienen acceso por rsh o ssh a la máquina del repositorio.  (Se habrá
percatado de que las órdenes "chgrp" y "chmod" en el ejemplo de arriba
le dieron acceso de escritura a un usuario llamado `anonymous', que no
es lo que uno esperaría.  La razón es que incluso los usuarios anónimos
y de sólo lectura del repositorio necesitan acceso de escritura a nivel
del sistema, para que sus procesos CVS puedan crear ficheros de bloqueo
temporales dentro del repositorio.  CVS no asegura la restricción de
"sólo lectura" del acceso anónimo por medio de permisos de ficheros Unix
sino por otros medios, de lo que se hablará en *Note Acceso anonimo::.)

Si su repositorio está destinado a servir proyectos al público en
general, en cuyo caso los contribuidores no tendrán necesariamente
cuentas en la máquina del repositorio, debería configurar ahora el
servidor de autentificación de contraseñas (*note El servidor de
autentificacion de contrasen~as::).  Es necesario para acceso anónimo
de sólo lectura, y seguramente sea la manera más fácil de asegurar
acceso al envío de cambios a ciertas personas sin tener que darles
cuentas completas en la máquina.


File: cvsbook.info,  Node: El servidor de autentificacion de contrasen~as,  Next: Acceso anonimo,  Prev: Iniciando un repositorio,  Up: Administracion del Repositorio

El servidor de autentificacion de contrasen~as
==============================================

Antes de seguir los pasos necesarios para configurar el servidor de
contraseñas vamos a examinar cómo funcionan este tipo de conexiones en
teoría.  Cuando un cliente remoto CVS usa el método `:pserver:' para
conectarse a un repositorio, el cliente está contactando en realidad
con un número de puerto específico en la máquina servidora - en
concreto el número de puerto 2401 (que es 49 al cuadrado, si le
interesan este tipo de cosas).  El puerto 2401 es el puerto designado
por defecto para el servidor pserver de CVS, aunque se podría
configurar para usar un puerto diferente siempre que el cliente y el
servidor estén de acuerdo en ello.

El servidor CVS en realidad no está esperando conexiones a ese puerto -
el servidor no empezará hasta que realmente llegue una conexión. En vez
de ello, el programa Unix "inetd" (InterNET Daemon) está escuchando en
ese puerto, y necesita saber que cuando reciba una petición de conexión
ahi, debería iniciar el servidor CVS y conectarlo al cliente entrante.

Esto se consigue modificando los ficheros de configuración de inetd:
`/etc/services' y `/etc/inetd.conf'.  El fichero de servicios asigna
números de puerto a nombres de servicios e inetd.conf le dice a inetd
qué hacer para un nombre de servicio dado.

Primero ponga una línea como ésta en /etc/services (después de
asegurarse de que la línea no existe ya):

     cvspserver	2401/tcp

Luego, escriba esto en /etc/inetd.conf:

     cvspserver stream tcp nowait root /usr/local/bin/cvs cvs \
        --allow-root=/usr/local/nuevorepos pserver

(En el fichero real, esto deberá ser una única línea larga, sin barra
inversa \).  Si su sistema usa una envoltura de TCP ("tcp wrapper", N.
del T.), puede que quiera usar algo como esto en vez de lo anterior:

     cvspserver stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/cvs \
        --allow-root=/usr/local/nuevorepos pserver

Ahora reinicie inetd para que tenga en cuenta los cambios en sus
ficheros de configuración (si no sabe cómo reiniciar el demonio,
simplemente reinicie la máquina - esto también funcionará).

Esto es suficiente para permitir conexiones, pero también querrá
configurar contraseñas especiales de CVS - separadas de las contraseñas
de login de los usuarios - de modo que la gente pueda acceder al
repositorio sin poner en peligro la seguridad general del sistema.

El fichero de contraseñas de CVS es CVSROOT/passwd en el repositorio.
No se creó por defecto cuando ejecutó cvs init, porque CVS no sabe
seguro si usará pserver.  Incluso si el fichero de contraseñas se ha
creado, CVS no tendrá forma de saber los nombres de usuario y
contraseñas a crear.  Así que usted tendrá que crear uno por sí mismo;
aquí hay una muestra de fichero CVSROOT/passwd:

     kfogel:rKa5jzULzmhOo
     anonymous:XR4EZcEs0szik
     melissa:tGX1fS8sun6rY:pubcvs

El formato es tan simple como parece.  Cada línea es:

     <NOMBREUSUARIO>:<CONTRASEÑA_CIFRADA>:<NOMBREUSUARIO_SISTEMA_OPCIONAL>

Los dos puntos adicionales seguidos de un nombre de usuario de sistema
opcional le dicen a CVS que las conexiones autentificadas con
NOMBREUSUARIO deberían ejecutarse como la cuenta de sistema
NOMBREUSUARIO_SISTEMA  - en otras palabras, que la sesión CVS sólo
sería capaz de hacer en el repositorio las cosas que alguien conectado
como NOMBREUSUARIO_SISTEMA podría hacer.

Si no se da un nombre de usuario de sistema, NOMBREUSUARIO deberá
coincidir con un nombre de cuenta real del sistema, y la sesión se
ejecutará con los permisos de ese usuario.  En cualquier caso, la
contraseña cifrada no debería ser la misma que la contraseña real de
acceso del usuario.  Debería ser una contraseña independiente usada
sólo para conexiones a CVS pserver.

La contraseña se cifra usando el mismo algoritmo que las contraseñas
estándar de Unix, almacenadas en /etc/passwd.  Puede que se pregunte en
este punto, ¿cómo se consigue una versión cifrada de una contraseña?
Para las contraseñas de sistema Unix, la orden passwd se encarga del
cifrado en /etc/passwd por usted.  Por desgracia no hay una orden
equivalente a passwd en cvs (se ha propuesto varias veces, pero nadie
se ha puesto a escribirlo - ¿lo hará usted. quizá?).

Esto es un inconveniente, pero sólo pequeño.  Si no hay otra opción,
siempre podrá cambiar temporalmente la contraseña de sistema de un
usuario usando passwd, copiar y pegar el texto cifrado de /etc/passwd
en CVSROOT/passwd, y restaurar la antigua contraseña (en ciertos
sistemas las contraseñas cifradas se encuentran en /etc/shadow y sólo el
administrador o root puede leerlas.)

Este proceso es factible pero bastante incómodo.  Sería mucho más fácil
tener una utilidad de línea de órdenes que tomara una contraseña en
texto plano como su argumento y diera como salida la versión cifrada.
Aquí está esa herramienta, escrita en Perl:

     #!/usr/bin/perl
     
     srand (time());
     my $randletter = "(int (rand (26)) + (int (rand (1) + .5) % 2 ? 65 : 97))";
     my $salt = sprintf ("%c%c", eval $randletter, eval $randletter);
     my $plaintext = shift;
     my $crypttext = crypt ($plaintext, $salt);
     
     print "${crypttext}\n";

Yo guardo el guión anterior en `/usr/local/bin/cryptout.pl':

     floss$ ls -l /usr/local/bin/cryptout.pl
     
     -rwxr-xr-x   1   root   root   265  Jun 14 20:41 /usr/local/bin/cryptout.pl
     floss$ cryptout.pl "some text"
     sB3A79YDX5L4s
     
     floss$

Si usara la salida de este ejemplo para crear la siguiente entrada en
CVSROOT/passwd

     jluis:sB3A79YDX5L4s:craig

entonces la gente podría conectarse al repositorio con la siguiente
orden:

     remote$ cvs -d :pserver:jluis@floss.red-bean.com:/usr/local/nuevorepos login

Escribirían entonces `some text' como contraseña y a partir de entonces
podrían ejecutar órdenes CVS con los mismos privilegios de acceso que
el usuario de sistema `craig'.

Si alguien intenta autentificarse con un nombre de usuario y contraseña
que no aparecen en CVSROOT/passwd, CVS comprobará si ese nombre de
usuario y contraseña están presentes en /etc/passwd.  Si lo están (y si
la contraseña coincide, por supuesto), CVS proporcionará el acceso.  Se
comporta de esta forma para comodidad del administrador, para no tener
que añadir entradas a CVSROOT/passwd por separado para los usuarios
comunes del sistema.  Sin embargo, este comportamiento también es un
agujero de seguridad, porque significa que si uno de esos usuarios se
conecta al servidor CVS, su contraseña de acceso al sistema circulará
por la red en texto claro, potencialmente vulnerable a los ojos de
husmeadores de contraseñas.  Un poco más adelante, aprenderá cómo
desactivar este comportamiento "problemático", para que CVS consulte
sólo su propio fichero passwd.  Tanto si lo deja activado o
desactivado, probablemente debería obligar a los usuarios de CVS que
también tengan cuentas en el sistema a mantener contraseñas distintas
para las dos funciones.

Aunque el fichero passwd autentifica para todo el repositorio, con un
poco de trabajo adicional podrá usarlo incluso para proporcionar acceso
específico de proyecto.  Aquí hay un método:

Suponga que quiere proporcionar acceso a algunos desarrolladores
remotos al proyecto `foo', y a otros acceso al proyecto `bar', y no
quiere que los desarrolladores de un proyecto tengan acceso al envío de
cambios al otro.  Puede conseguir esto creando cuentas de usuario y
grupos específicos de proyecto en el sistema y luego referirse a esas
cuentas en el fichero CVSROOT/passwd.

Aquí está el extracto relevante de /etc/passwd en cuestión

     cvs-foo:*:600:600:Cuenta Pública CVS para el Proyecto Foo:/usr/local/cvs:/bin/false
     cvs-bar:*:601:601:Cuenta Pública CVS para el Proyecto Bar:/usr/local/cvs:/bin/false

y de /etc/group

     cvs-foo:*:600:cvs-foo
     cvs-bar:*:601:cvs-bar

y, finalmente, CVSROOT/passwd:

     kcunderh:rKa5jzULzmhOo:cvs-foo
     jmankoff:tGX1fS8sun6rY:cvs-foo
     brebard:cAXVPNZN6uFH2:cvs-foo
     xwang:qp5lsf7nzRzfs:cvs-foo
     dstone:JDNNF6HeX/yLw:cvs-bar
     twp:glUHEM8KhcbO6:cvs-bar
     ffranklin:cG6/6yXbS9BHI:cvs-bar
     yyang:YoEqcCeCUq1vQ:cvs-bar

Algunos de los nombres de usuario de CVS se refieren a las cuentas de
usuario de sistema `cvs-foo' y otras a `cvs-bar'.  Dado que CVS se
ejecuta bajo la ID de usuario de la cuenta de sistema, simplemente
tendrá que asegurarse de que en las partes de interés del repositorio
sólo pueden escribir los usuarios y grupos adecuados.  Si se asegura de
que las cuentas de usuario de sistema estén bien atadas (sin contraseña
de acceso al sistema válida, con `/bin/false' como shell), el sistema
será razonablemente seguro (¡pero mire más adelante en este capítulo
acerca de los permisos CVSROOT!).  Además, CVS registra los cambios e
informes de cambios bajo el nombre de usuario de CVS, no bajo el nombre
de usuario de sistema, así que usted podrá saber quién es responsable
de un cambio dado.


File: cvsbook.info,  Node: Acceso anonimo,  Next: Estructura del repositorio,  Prev: El servidor de autentificacion de contrasen~as,  Up: Administracion del Repositorio

Acceso anonimo
==============

Hasta ahora sólo hemos visto cómo usar el servidor de autentificación
de contraseñas para dar acceso total al repositorio (aunque es cierto
que se puede restringir ese acceso mediante permisos de fichero Unix
cuidadosamente elegidos).  Pasar a acceso anónimo y de sólo lectura es
un paso simple: sólo hay que añadir un nuevo fichero, o quizá dos, en
CVSROOT/.  Los nombres de los ficheros son `readers' y `writers' - el
primero contiene una lista de nombres de usuario que pueden leer el
repositorio solamente, y el segundo los usuarios que pueden leer y
escribir.

Si lista un nombre de usuario en CVSROOT/readers, ese usuario tendrá
acceso de sólo lectura a todos los proyectos del repositorio.  Si lista
un nombre de usuario en CVSROOT/writers, ese usuario tendrá acceso a
escritura, y todos los usuarios de pserver que no estén listados en
writers tendrán acceso de sólo lectura (es decir, si el fichero writers
existe, implica acceso de sólo lectura para todos los que no estén
listados en él).  Si el mismo nombre de usuario se encuentra listado en
los dos ficheros, CVS resuelve el conflicto del modo más conservador:
el usuario tendrá acceso de sólo lectura.

El formato de los ficheros es muy simple: un usuario por línea (no
olvide poner una nueva línea en blanco después del último usuario).  Un
fichero readers de muestra sería:

     anonymous
     splotnik
     guest
     jbrowse

Hay que notar que los ficheros se refieren a nombres de usuario de CVS,
no de sistema.  Si usa alias de usuario en el fichero CVSROOT/passwd
(poniendo un nombre de usuario de sistema después de los segundos dos
puntos), el nombre de usuario más a la izquierda es el que hay que
listar en el fichero readers o writers.

Para ser preciso, hay una descripción formal del comportamiento del
servidor para decidir si dar acceso de sólo lectura o de lectura y
escritura:

Si existe un fichero readers y este usuario está listado en él, se le
dará acceso de sólo lectura.  Si existe un fichero writers y este
usuario no está listado en él, se le dará también acceso de sólo
lectura (esto es cierto incluso si existe un fichero readers pero esa
persona no está listada en él).  Si esa persona está listada en ambos,
se le dará acceso de sólo lectura.  En todos los demás casos, a esa
persona se le dará acceso completo de lectura y escritura.

Así, un repositorio típico con acceso a CVS anónimo tendrá esto (o algo
parecido) en CVSROOT/passwd

     anonymous:XR4EZcEs0szik

esto (o algo parecido) en /etc/passwd

     anonymous:!:1729:105:Usuario CVS Anónimo:/usr/local/nuevorepos:/bin/false

y esto en CVSROOT/readers:

     anonymous

Y, por supuesto, la configuración mencionada anteriormente en
/etc/services y /etc/inetd.conf.  ¡Y eso es todo!

Hay que remarcar que algunos sistemas Unix antiguos no permiten nombres
de usuario mayores de ocho caracteres.  Una forma de arreglar esto
sería llamar al usuario `anon' en lugar de `anonymous' en
CVSROOT/passwd y los ficheros de sistema, porque la gente asume a
menudo que anon es una abreviatura de anonymous de todas formas.  Pero
sería mejor poner algo como esto en el fichero CVSROOT/passwd

     anonymous:XR4EZcEs0szik:cvsanon

(y luego, por supuesto, usar `cvsanon' en los ficheros de sistema).  De
este modo será capaz de publicar una dirección de repositorio que use
`anonymous', que es más o menos el estándar ahora.  La gente que acceda
al repositorio con

     cvs -d :pserver:anonymous@cvs.foobar.com:/usr/local/nuevorepos (etc...)

realmente ejecutarían en el servidor como cvsanon (o lo que sea).  Pero
no necesitarían conocer o preocuparse de cómo están configuradas las
cosas en el lado del servidor - sólo verían la dirección publicada.


File: cvsbook.info,  Node: Estructura del repositorio,  Next: Formato RCS,  Prev: Acceso anonimo,  Up: Administracion del Repositorio

Estructura del repositorio
==========================

El nuevo repositorio aún no tiene proyectos en él.  Vamos a volver a
ejecutar la importación inicial de *Note Una introduccion a CVS::,
observando lo que le ocurre al repositorio.  (Por simplicidad, todos
las órdenes asumen que la variable de entorno CVSROOT tiene el valor
/usr/local/nuevorepos, así que no hay necesidad de especificar el
repositorio con -d en importaciones y comprobaciones.)

     floss$ ls /usr/local/nuevorepos
     CVSROOT/
     floss$ pwd
     /home/jluis/src/
     floss$ ls
     miproyecto/
     floss$ cd miproyecto
     floss$ cvs import -m "importación inicial a CVS" miproyecto jluis start
     N miproyecto/README.txt
     N miproyecto/hello.c
     cvs import: Importing /usr/local/nuevorepos/miproyecto/a-subdir
     N miproyecto/a-subdir/loquesea.c
     cvs import: Importing /usr/local/nuevorepos/miproyecto/a-subdir/subsubdir
     N miproyecto/a-subdir/subsubdir/fish.c
     cvs import: Importing /usr/local/nuevorepos/miproyecto/b-subdir
     N miproyecto/b-subdir/random.c
     
     No conflicts created by this import
     
     floss$ ls /usr/local/nuevorepos
     CVSROOT/  miproyecto/
     floss$ cd /usr/local/nuevorepos/miproyecto
     floss$ ls
     README.txt,v  a-subdir/     b-subdir/	  hello.c,v
     floss$ cd a-subdir
     floss$ ls
     subsubdir/    loquesea.c,v
     floss$ cd ..
     
     floss$

Antes de importar, el repositorio contenía sólo su área de
administración, CVSROOT.  Después de la importación ha aparecido un
nuevo directorio - `miproyecto' -.  Los ficheros y subdirectorios
existentes en ese nuevo directorio se parecen sospechosamente a los del
proyecto que hemos importado, excepto que los ficheros tienen el sufijo
`,v'.  Éstos son ficheros de control de versión en formato RCS (la `,v'
quiere decir "versión"), y son el esqueleto del repositorio.  Cada
fichero RCS almacena la historia de revisiones de su correspondiente
fichero del proyecto, incluyendo todas las ramas y marcas.


File: cvsbook.info,  Node: Formato RCS,  Next: Qué ocurre cuando elimina un fichero,  Prev: Estructura del repositorio,  Up: Administracion del Repositorio

Formato RCS
===========

No necesita conocer nada del formato RCS para usar CVS (aunque hay un
escrito excelente incluido en la distribución fuente, vea doc/RCSFILES).
Sin embargo, una comprensión básica del formato puede ser de inmensa
ayuda para resolver problemas con CVS, así que echaremos un pequeño
vistazo a uno de los ficheros, `hello.c,v'.  Aquí está su contenido:

     head     1.1;
     branch   1.1.1;
     access   ;
     symbols  start:1.1.1.1 jluis:1.1.1;
     locks    ; strict;
     comment  @ * @;
     
     1.1
     date     99.06.20.17.47.26;  author jluis;  state Exp;
     branches 1.1.1.1;
     next;
     
     1.1.1.1
     date     99.06.20.17.47.26;  author jluis;  state Exp;
     branches ;
     next;
     
     desc
     @@
     
     1.1
     log
     @Initial revision
     @
     text
     @#include <stdio.h>
     
     void
     main ()
     {
       printf ("¡Hola, mundo!\n");
     }
     @
     
     1.1.1.1
     log
     @importación inicial a CVS
     @
     text
     @@

¡Uff!  La mayoría de esto se puede ignorar; no hace falta que se
preocupe de la relación entre 1.1 y 1.1.1.1, por ejemplo, o de la rama
implicada 1.1.1 - en realidad no son significativas, desde un punto de
vista del usuario o incluso del administrador.  Lo que debería
comprender es el formato en general.  Al comienzo hay una colección de
cabeceras:

     head     1.1;
     branch   1.1.1;
     access   ;
     symbols  start:1.1.1.1 jluis:1.1.1;
     locks    ; strict;
     comment  @ * @;

Más abajo hay grupos de metainformación sobre cada revisión (pero aún
sin mostrar el contenido de esa revisión), como:

     1.1
     date     99.06.20.17.47.26;  author jluis;  state Exp;
     branches 1.1.1.1;
     next     ;

Y finalmente, el informe de cambios ("log message", N. del T.) y texto
de una revisión real:

     1.1
     log
     @Initial revision
     @
     text
     @#include <stdio.h>
     
     void
     main ()
     {
       printf ("¡Hola, mundo!\n");
     }
     @
     
     1.1.1.1
     log
     @importación inicial a CVS
     @
     text
     @@

Si lo mira de cerca verá que el contenido de la primera revisión se
guarda bajo la cabecera 1.1, pero en ella el informe de cambios es
"Initial revision", mientras que el mensaje que usamos en realidad a la
hora de importar fue "importación inicial a CVS".  No es necesario que
se preocupe por esta discrepancia ahora.  Ocurre porque las
importaciones son circunstancias especiales: para que importaciones
repetidas en el mismo proyecto tengan un efecto útil, la importación en
realidad coloca la revisión inicial en el tronco principal y en una
rama especial (las razones para ello se aclararán cuando veamos
derivaciones comerciales en *Note CVS avanzado::).  Por ahora puede
tratar `1.1' y `1.1.1.1' como la misma cosa.

El fichero se vuelve aún más revelador después de que enviemos con
commit la primera modificación a hello.c:

     floss$ cvs -Q co miproyecto
     floss$ cd miproyecto
     floss$ emacs hello.c
         (haga algunos cambios al fichero)
     
     floss$ cvs ci -m "ahora también dice adiós"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in hello.c;
     /usr/local/nuevorepos/miproyecto/hello.c,v  <--  hello.c
     new revision: 1.2; previous revision: 1.1
     done

Si mira en el repositorio a hello.c,v verá el efecto del envío de
cambios:

     head  1.2;
     access;
     symbols
           start:1.1.1.1 jluis:1.1.1;
     locks; strict;
     comment   @ * @;
     
     1.2
     date   99.06.21.01.49.40;   author jluis;   state Exp;
     branches;
     next   1.1;
     
     1.1
     date   99.06.20.17.47.26;   author jluis;   state Exp;
     branches
            1.1.1.1;
     next   ;
     
     1.1.1.1
     date   99.06.20.17.47.26;   author jluis;   state Exp;
     branches;
     next   ;
     
     desc
     @@
     
     1.2
     log
     @ahora también dice adiós
     @
     text
     @#include <stdio.h>
     
     void
     main ()
     {
       printf ("¡Hola, mundo!\n");
       printf ("¡Adiós, mundo!\n");
     }
     @
     
     1.1
     log
     @Initial revision
     @
     text
     @d7 1
     @
     
     1.1.1.1
     log
     @importación inicial a CVS
     @
     text
     @@

Ahora el contenido completo de la revisión 1.2 está guardado en el
fichero, y el texto para la revisión 1.1 ha sido reemplazado por la
fórmula críptica:

     d7 1

El `d7 1' es un código diff que quiere decir "empezando en la línea 7,
borrar 1 línea".  En otras palabras, ¡para obtener la Revisión 1.1,
borre la línea 7 de la Revisión 1.2!  Pruébelo usted mismo.  Verá que
de hecho produce la Revisión 1.1 - simplemente se deshace de la línea
que añadimos al fichero.

Esto demuestra el principio básico del formato RCS: Almacena sólo las
diferencias entre revisiones, ahorrando con ello un montón de espacio
comparado con guardar cada revisión entera.  Para volver desde la
última revisión a la anterior, parchea la última revisión usando el
diff almacenado.  Por supuesto, esto significa que cuanto más hacia
atrás viaje en la historia de revisiones, habrá que realizar más
operaciones de parcheo (por ejemplo, si el fichero está en la Revisión
1.7 y a CVS se le pide que muestre la Revisión 1.4, tendrá que producir
la 1.6 parcheando hacia atrás la 1.7, luego la 1.5 parcheando la 1.6, y
finalmente la 1.4 parcheando la 1.5).  Por suerte, las revisiones
antiguas son además las menos solicitadas, así que el sistema RCS
funciona bastante bien en la práctica: Cuanto más reciente sea una
revisión, más "barata" es de obtener.

En cuanto a la información de cabecera al principio del fichero, no
necesita saber lo que significa todo ello.  Sin embargo, los efectos de
ciertas operaciones se muestran muy claramente en las cabeceras, y una
pequeña familiaridad con ellas puede resultar útil.

Cuando envía cambios de una nueva revisión al tronco, la etiqueta `head'
se actualiza (note cómo cambió a 1.2 en el ejemplo anterior, cuando se
envió el cambio de la segunda revisión a hello.c).  Cuando añade un
fichero como binario o lo marca, esas operaciones se registran también
en las cabeceras.  Como ejemplo, vamos a añadir foo.jpg como fichero
binario para después marcarlo un par de veces:

     floss$ cvs add -kb foo.jpg
     cvs add: scheduling file 'foo.jpg' for addition
     cvs add: use 'cvs commit' to add this file permanently
     floss$ cvs -q commit -m "añadida una imagen aleatoria; pregunte a \
        jluis@red-bean.com el motivo"
     RCS file: /usr/local/nuevorepos/miproyecto/foo.jpg,v
     done
     Checking in foo.jpg;
     /usr/local/nuevorepos/miproyecto/foo.jpg,v  <--  foo.jpg
     initial revision: 1.1
     done
     floss$ cvs tag alguna_marca_aleatoria foo.jpg
     T foo.jpg
     floss$ cvs tag OTRA-MARCA foo.jpg
     T foo.jpg
     floss$

Examine ahora la sección "header" de foo.jpg,v en el repositorio:

     head   1.1;
     access;
     symbols
           OTRA-MARCA:1.1
           alguna_marca_aleatoria:1.1;
     locks; strict;
     comment   @# @;
     expand	@b@;

Fíjese en la b en la línea "expand" del final - se debe a haber usado el
parámetro -kb al añadir el fichero, y quiere decir que el fichero no
sufrirá expansiones de palabra clave o nueva línea, que ocurrirían
normalmente durante obtenciones de copia y actualizaciones si fuera un
fichero de texto normal.  Las marcas aparecen en la sección "symbols",
una por línea - ambas están asociadas a la primera revisión, puesto que
eso es lo que se marcó ambas veces.  (Esto también ayuda a explicar por
qué los nombres de marca pueden sólo contener letras, números, guiones
y guiones bajos.  Si la propia marca contuviera puntos o comas, su
registro RCS podría ser ambiguo, porque no habría forma de encontrar el
enlace textual entre la marca y la revisión a la que está asociada.)

El formato RCS siempre va entre signos @
========================================

El símbolo `@' se usa como delimitador de campos en los ficheros RCS, lo
que significa que si aparece alguno en el texto de un fichero o en un
informe de cambios, deberá estar comentado (de lo contrario, CVS
interpretaría incorrectamente que está marcando el final de ese campo).
Se comenta poniéndolo doble - es decir, CVS siempre interpreta `@@'
como un "signo @ literal", nunca como un "fin de campo actual".  Cuando
enviamos los cambios a foo.jpg, el informe de cambios fue

     "añadida una imagen aleatoria; pregunte a jluis@red-bean.com el motivo"

que se almacena en foo.jpg,v así:

     1.1
     log
     @añadida una imagen aleatoria; pregunte a jluis@@red-bean.com el motivo
     @

El signo @ en jluis@@red-bean.com se descomentará automáticamente cada
vez que CVS obtenga el informe de cambios:

     floss$ cvs log foo.jpg
     RCS file: /usr/local/nuevorepos/miproyecto/foo.jpg,v
     Working file: foo.jpg
     head: 1.1
     branch:
     locks: strict
     access list:
     symbolic names:
           OTRA-MARCA: 1.1
           alguna_marca_aleatoria: 1.1
     keyword substitution: b
     total revisions: 1;	selected revisions: 1
     description:
     ----------------------------
     revision 1.1
     date: 1999/06/21 02:56:18;  author: jluis;  state: Exp;
     añadida una imagen aleatoria: pregunte a jluis@red-bean.com el motivo
     ============================================================================
     
     floss$

El único motivo por el que debería preocuparse es por si alguna vez
tiene que editar a mano ficheros RCS (una circunstancia rara, aunque le
ha pasado a más de uno) Debe acordarse entonces de usar signos dobles @
en contenidos de la revisión e informes de cambios.  Si no lo hace, el
fichero RCS estará corrupto y probablemente tendrá un comportamiento
extraño e indeseable.

Hablando de editar a mano ficheros RCS, no se deje engañar por los
permisos en el repositorio:

     floss$ ls -l
     total 6
     -r--r--r--   1 jluis   users         410 Jun 20 12:47 README.txt,v
     drwxrwxr-x   3 jluis   users        1024 Jun 20 21:56 a-subdir/
     drwxrwxr-x   2 jluis   users        1024 Jun 20 21:56 b-subdir/
     -r--r--r--   1 jluis   users         937 Jun 20 21:56 foo.jpg,v
     -r--r--r--   1 jluis   users         564 Jun 20 21:11 hello.c,v
     
     floss$

(Para los que no estén familiarizados con la salida de "ls" en Unix, las
líneas `-r--r--r--' de la izquierda básicamente quieren decir que los
ficheros se pueden leer pero no cambiar.)  Aunque los ficheros parecen
ser de sólo lectura para todos, también hay que tener en cuenta los
permisos de directorio:

     floss$ ls -ld .
     drwxrwxr-x   4 jluis   users        1024 Jun 20 22:16 ./
     floss$

El propio directorio miproyecto/ - y sus subdirectorios - es accesible
para escritura por el propietario (jluis) y el grupo (users).  Esto
significa que CVS (ejecutándose como jluis o como cualquiera del grupo
users) puede crear y borrar ficheros en esos directorios, incluso si no
puede editar directamente los ficheros a presentes.  CVS edita un
fichero RCS haciendo una copia separada de él, de forma que usted haga
todos sus cambios en una copia temporal, y luego reemplaza el fichero
RCS existente con el nuevo.  (Pero por favor, no pregunte por qué los
ficheros son de sólo lectura - hay razones históricas para ello,
relacionadas con la forma en que RCS trabaja cuando se ejecuta como
programa en solitario.)

Por cierto, puede que usted no desee que el grupo de los ficheros sea
`users', considerando que el directorio raíz del repositorio se le
asignó explícitamente el grupo `cvs'.  Puede corregir el problema
ejecutando esta orden dentro del repositorio:

     floss$ cd /usr/local/nuevorepos
     floss$ chgrp -R cvs miproyecto

Las reglas habituales Unix de creación de ficheros rigen qué grupo se
asigna a los nuevos ficheros que aparecen en el repositorio, así que de
vez en cuando puede que necesite ejecutar "chgrp" o "chmod" en ciertos
ficheros o directorios del repositorio (ajustar el bit SGID con
`chmod g+s' es a menudo una buena estrategia: hace que los hijos de un
directorio hereden el grupo propietario del directorio, que por lo
general es lo que quiere que pase en el repositorio).  No hay reglas
rápidas acerca de cómo debería estructurar los permisos del repositorio;
depende de quién esté trabajando en qué proyectos.


File: cvsbook.info,  Node: Qué ocurre cuando elimina un fichero,  Next: El directorio administrativo CVSROOT/,  Prev: Formato RCS,  Up: Administracion del Repositorio

Qué ocurre cuando elimina un fichero
====================================

Cuando elimina un fichero de un proyecto, no desaparece simplemente.
CVS debe ser capaz de recuperar esos ficheros cuando solicite una
revisión antigua del proyecto.  En lugar de ello, el fichero se pone en
el `Attic', ático literalmente:

     floss$ pwd
     /home/jluis/src/miproyecto
     floss$ ls /usr/local/nuevorepos/miproyecto/
     README.txt,v  a-subdir/     b-subdir/     foo.jpg,v   hello.c,v
     floss$ rm foo.jpg
     floss$ cvs rm foo.jpg
     cvs remove: scheduling 'foo.jpg' for removal
     cvs remove: use 'cvs commit' to remove this file permanently
     floss$ cvs ci -m "Eliminado foo.jpg" foo.jpg
     Removing foo.jpg;
     /usr/local/nuevorepos/miproyecto/foo.jpg,v  <--  foo.jpg
     new revision: delete; previous revision: 1.1
     done
     floss$ cd /usr/local/nuevorepos/miproyecto/
     floss$ ls
     Attic/      README.txt,v  a-subdir/     b-subdir/   hello.c,v
     floss$ cd Attic
     floss$ ls
     foo.jpg,v
     floss$

En cada directorio del repositorio de un proyecto, la presencia de un
subdirectorio `Attic/' indica que se ha borrado al menos un fichero de
ese directorio (esto quiere decir que no debería usar directorios
llamados Attic en sus proyectos).  Sin embargo, CVS no mueve
simplemente el fichero RCS a Attic/; además envía el cambio con una
nueva revisión al fichero, con un estado especial de revisión de
`dead', muerto.  Aquí está la sección de interés de Attic/foo.jpg,v:

     1.2
     date   99.06.21.03.38.07;   author jluis;   state dead;
     branches;
     next	1.1;

Si el fichero se vuelve a traer de nuevo a la vida, CVS tiene una forma
de registrar que estaba muerto en algún punto del pasado y que ahora
está vivo otra vez.

Esto quiere decir que si quiere restaurar un fichero eliminado, no puede
sacarlo del Attic/ simplemente y ponerlo de nuevo en el proyecto.  En
lugar de ello, tiene que hacer algo como lo siguiente con una copia de
trabajo:

     floss$ pwd
     /home/jluis/src/miproyecto
     floss$ cvs -Q update -p -r 1.1 foo.jpg > foo.jpg
     floss$ ls
     CVS/       README.txt   a-subdir/   b-subdir/   foo.jpg     hello.c
     floss$ cvs add -kb foo.jpg
     cvs add: re-adding file foo.jpg (in place of dead revision 1.2)
     cvs add: use 'cvs commit' to add this file permanently
     floss$ cvs ci -m "revivida imagen jpg" foo.jpg
     Checking in foo.jpg;
     /usr/local/nuevorepos/miproyecto/foo.jpg,v  <-- foo.jpg
     new revision: 1.3; previous revision: 1.2
     done
     floss$ cd /usr/local/nuevorepos/miproyecto/
     floss$ ls
     Attic/	      a-subdir/     foo.jpg,v
     README.txt,v  b-subdir/     hello.c,v
     floss$ ls Attic/
     floss$

Queda mucho más por saber del formato RCS, pero esto es suficiente para
que un administrador de CVS mantenga un repositorio.  Es bastante raro
que realmente haya que editar un fichero RCS; normalmente sólo tendrá
que ajustar permisos de ficheros en el repositorio, al menos si mi
propia experiencia sirve de guía.  Sin embargo, cundo CVS empieze a
comportarse de forma realmente extraña (raro, pero no completamente
fuera de lo posible), puede que quiera mirar dentro de los ficheros RCS
para averiguar qué está pasando.

