<html><head><title>Encontrar quién vigila qué</title><link rel=next href="Recomendar-a-la-gente-usar-alarmas.html">
<link rel=previous href="Controlar-qué-acciones-son-vigiladas.html">
<link rel=up href="Alarmas--CVS-como-telefono-.html">
</head>
<body>
<p>
Node:<a name="Encontrar-quién-vigila-qué.html">Encontrar quién vigila qué</a>,
Next:<a rel=next href="Recomendar-a-la-gente-usar-alarmas.html">Recomendar a la gente usar alarmas</a>,
Previous:<a rel=previous href="Controlar-qué-acciones-son-vigiladas.html">Controlar qué acciones son vigiladas</a>,
Up:<a rel=up href="Alarmas--CVS-como-telefono-.html">Alarmas (CVS como telefono)</a>
<hr><br>

<h3>Encontrar quién vigila qué</h3>

<p>Alguna vez puede interesarle saber quien está vigilando o editando un
fichero sin antes de ejecutar <code>cvs edit</code> o ver quién está editando qué
sin añadirse a ninguna lista de vigilancia. O podría haber olvidado
su propio estatus. Después de haber establecido algunas alarmas y haber
entregado algunos ficheros es fácil saber que está uno vigilando y
editando.

<p>CVS proporciona dos comandos para mostrar quién está vigilando y editando
qué ficheros - <code>cvs watchers</code> y <code>cvs editors</code>:

<pre>floss$ whoami
jrandom
floss$ cvs watch add hello.c
floss$ cvs watchers hello.c
hello.c jrandom  edit unedit  commit
floss$ cvs watch remove -a unedit hello.c
floss$ cvs watchers hello.c
hello.c jrandom  edit commit
floss$ cvs watch add README.txt
floss$ cvs watchers
README.txt      jrandom edit    unedit  commit
hello.c jrandom edit    commit
floss$
</pre>

<p>Observe que la última orden <code>cvs watchers</code> no especifica ningún
fichero y así muestra los vigilantes para todos los ficheros que
estén siendo vigilados.

<p>Todas las órdenes <code>watch</code> y <code>edit</code> tienen en común con otras órdenes
CVS esta característica. Si usted especifica nombres de ficheros estas
órdenes actuan sobre ellos. Si se especifican nombres de directorio
actuan sobre cada fichero de ese directorio y sus subdirectorios. Si no
especifica nada, actuan sobre el directorio actual y sus subdirectorios. 
Siguiendo con la sesión del ejemplo anterior:

<pre>floss$ cvs watch add a-subdir/whatever.c
floss$ cvs watchers
README.txt      jrandom edit    unedit  commit
hello.c jrandom edit    commit
a-subdir/whatever.c     jrandom edit    unedit  commit
floss$ cvs watch add
floss$ cvs watchers
README.txt      jrandom edit    unedit  commit
foo.gif jrandom edit    unedit  commit
hello.c jrandom edit    commit  unedit
a-subdir/whatever.c     jrandom edit    unedit  commit
a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit
b-subdir/random.c       jrandom edit    unedit  commit
floss$
</pre>

<p>El penúltimo comando hizó a jrandom un vigilante de todos los ficheros
del proyecto y el último mostró cada lista de cada fichero del proyecto. 
La salida de <code>cvs&nbsp;watchers</code> puede que no perfectamente
alineado por columnas debido a que se mezclan tabuladores con
información de longitud variable, pero el formateo de las líneas es
consistente.

<pre>[FILENAME] [espacio en blanco] WATCHER [espacio en blanco]
ACTIONS-BEING-WATCHED...
</pre>

<p>Observe qué pasa cuando qsmith empieza a editar uno de los ficheros:

<pre>paste$ cvs edit hello.c
paste$ cvs watchers
README.txt      jrandom edit    unedit  commit
foo.gif jrandom edit    unedit  commit
hello.c jrandom edit    commit  unedit
       qsmith  tedit   tunedit tcommit
a-subdir/whatever.c     jrandom edit    unedit  commit
a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit
b-subdir/random.c       jrandom edit    unedit  commit
</pre>

<p>El fichero hello.c tiene un nuevo vigilante: qsmith (observe que el
nombre del fichero no se repite sino que se deja un espacio en blanco
al principio de la línea; esto es importante si usted alguna vez
escribiera un programa que compila la salida de la orden). 
Ya que está editando el fichero hello.c, qsmith tendrá una
<dfn>temporary watch alarma temporal</dfn> sobre el fichero, la cual
se terminará cuando haga una entrega sobre éste. 
El prefijo ð<code>t</code> delante de cada acción indica que son
alarmas termporales. 
Si qsmith se añade a la lista de vigilantes regulares de hello.c

<pre>paste$ cvs watch add hello.c
README.txt      jrandom edit    unedit  commit
foo.gif jrandom edit    unedit  commit
hello.c jrandom edit    commit  unedit
       qsmith  tedit   tunedit tcommit edit    unedit  commit
a-subdir/whatever.c     jrandom edit    unedit  commit
a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit
b-subdir/random.c       jrandom edit    unedit  commit
</pre>

<p>se encontrará a la vez como un vigilante temporal y un vigilante
permanente. Se puede decir que el estatus de vigilante permanente
sobrepasa al temporal. Entonces la línea sería como:

<pre>        qsmith  edit    unedit  commit
</pre>

<p>Sin embargo, CVS no puede reemplazar las alarmas temporales porque
sabe que orden ocurren las acciones. ¿Se quitará qsmith de la lista
permanente de vigilancia antes de acabar su sesión de edición?, o
¿acabará sus ediciones siendo todavía un vigilante?. En el primer caso
las acciones <code>edit / unedit / commit</code> desaparecen mientras que
<code>tedit / tunedit / tcommit</code> permanecen; en el segundo caso ocurre
lo contrario. De cualquier forma esto no será de gran importancia. 
Casi siempre lo que usted hará es ejecutar

<pre>floss$ cvs watchers
</pre>

<p>o

<pre>floss$ cvs editors
</pre>

<p>desde el nivel más alto para ver quién está haciendo qué. No necesita
conocer los detalles de quien está vigilando que acciones: lo
importante son las personas y los ficheros.

</body></html>

