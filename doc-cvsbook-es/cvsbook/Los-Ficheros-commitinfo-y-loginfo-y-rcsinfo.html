<html><head><title>Los Ficheros commitinfo y loginfo y rcsinfo</title><link rel=next href="Los-Ficheros-verifymsg-y-rcsinfo.html">
<link rel=previous href="El-Fichero-modules.html">
<link rel=up href="El-directorio-administrativo-CVSROOT-.html">
</head>
<body>
<p>
Node:<a name="Los-Ficheros-commitinfo-y-loginfo-y-rcsinfo.html">Los Ficheros commitinfo y loginfo y rcsinfo</a>,
Next:<a rel=next href="Los-Ficheros-verifymsg-y-rcsinfo.html">Los Ficheros verifymsg y rcsinfo</a>,
Previous:<a rel=previous href="El-Fichero-modules.html">El Fichero modules</a>,
Up:<a rel=up href="El-directorio-administrativo-CVSROOT-.html">El directorio administrativo CVSROOT/</a>
<hr><br>

<h3>Los Ficheros commitinfo y loginfo y rcsinfo</h3>

<p>La mayoría de los demás ficheros de administración proporcionan
<dfn>puntos de comtrol</dfn> ("hooks", N. del T.) programáticos en varias partes
del proceso de envío de cambios (por ejemplo, la capacidad de validar informes
de cambios o estados de fichero antes de permitir el envío, o la capacidad de
notificar a un grupo de desarrolladores cada vez que se haga un envío en cierto
directorio del repositorio).

<p>Por lo general, los ficheros comparten una sintaxis común.  Cada línea es
de la forma:

<pre>EXPRESIÓN_REGULAR    PROGRAMA_A_EJECUTAR
</pre>

<p>La expresión regular se probará con el directorio en el que se está haciendo
el envío (con el nombre de directorio relativo al nivel más alto del
repositorio).  Si coincide se ejecutará el programa designado.  Al programa
se le pasarán los nombres de cada uno de los ficheros del envío; puede
hacer lo que le parezca con esos nombres, incluso abrir los ficheros y
examinar sus contenidos.  Si el programa devuelve un estado de salida
distinto de cero, se impide que se haga el envío.

<p>Las (<dfn>expresiones regulares</dfn> son un sistema para describir de forma concisa
clases de cadenas.  Si no está familiarizado con las expresiones regulares,
puede hacerlo con el siguiente resumen: <code>foo</code> coincidiría con todos los
ficheros con nombres conteniendo <code>foo</code>; y <code>foo.*bar</code> coincidiría con
todos los ficheros con nombres conteniendo <code>foo</code>, seguido de cualquier
número de caracteres, y seguido por la cadena <code>bar</code>.  Es por ello que las
subcadenas normales coinciden consigo mismas, pero <code>.</code> y <code>*</code> son
especiales.  <code>.</code> coincide con cualquier caracter, y <code>*</code> quiere decir
"coincide con cualquier número de veces, incluyendo cero, del caracter
precedente".  Los signos <code>^</code> y <code>$</code> indican "encuentra al principio y
final de la cadena", respectivamente; por tanto, <code>^foo.*bar.*baz$</code>
encontraría las cadenas que comenzaran con <code>foo</code>, que contuvieran
<code>bar</code> en medio, y que acabaran con <code>baz</code>.  Esto es todo lo que vamos
a profundizar; este resumen es una pequeña parte muy abreviada de la sintaxis
completa de las expresiones regulares.)

<p>El fichero <dfn>commitinfo</dfn> está para puntos de control genéricos que quiera
ejecutar en todos los envíos.  Aquí hay algunas líneas commitinfo de ejemplo:

<pre>^a-subdir*     /usr/local/bin/comprobar-asubdir.sh
ou             /usr/local/bin/validar-proyecto.pl
</pre>

<p>Así que cualquier envío en miproyecto/a-subdir/ coincidiría con la primera
línea, por lo que se ejecutaría el guión comprobar-asubdir.sh.  Un envío en
cualquier proyecto cuyo nombre (nombre real de directorio del repositorio,
no necesariamente nombre del módulo) contenga la cadena <code>ou</code> ejecutaría
el guión validar-proyecto.pl, a menos que el envío ya haya coincidido
con la línea a-subdir anterior.

<p>En lugar de una expresión regular se puede usar la palabra <code>DEFAULT</code>
o <code>ALL</code>.  La línea DEFAULT (o la primera línea DEFAULT si hay más de
una) se ejecutará si no coincide ninguna expresión regular, y cada una de
las líneas ALL se ejecutará además de todas las líneas que puedan coincidir.

<p>Los nombres de ficheros que se pasan al programa no se refieren a ficheros
RCS - hacen referencia a ficheros normales, cuyos contenidos son exactamente
los mismos que los de la copia de trabajo de la que se están enviando cambios. 
El único aspecto inusual es que CVS los tiene guardados temporalmente dentro
del repositorio, así que estarán disponibles para los programas que se estén
ejecutando en la máquina en la que está el repositorio.

<p>El fichero <dfn>loginfo</dfn> es similar a commitinfo, excepto en que en lugar
de actuar en los contenidos de los ficheros, actúa en los informes de cambios. 
El lado izquierdo del fichero loginfo contiene expresiones regulares, quizá
incluyendo líneas DEFAULT y ALL.  El programa invocado a la derecha recibe
el informe de cambios en su entrada estándar; puede hacer lo que quiera con esa
entrada.

<p>El programa de la derecha también puede admitir un número arbitrario de
argumentos de línea de órdenes.  Uno de esos argumentos puede ser un código
especial <code>%</code>, a expandir por CVS en tiempo de ejecución como sigue:

<pre>%s    ------&gt;      nombre(s) de fichero(s) afectados por el envío de cambios
%V    ------&gt;      número(s) de revisión antes del envío de cambios
%v    ------&gt;      número(s) de revisión después del envío de cambios
</pre>

<p>La expansión empieza siempre con el subdirectorio del repositorio (relativo
al nivel superior del repositorio), seguido de la información del fichero. 
Por ejemplo, si los ficheros afectados por el envío de cambios fueran foo, bar
y baz, todos en <code>miproyecto/a-subdir</code>, <code>%s</code> se expandiría en:

<pre>miproyecto/a-subdir  foo  bar  baz
</pre>

<p>mientras que <code>%V</code> se expandiría para mostrar los números de revisión
antiguos:

<pre>miproyecto/a-subdir  1.7  1.134  1.12
</pre>

<p>y <code>%v</code> los números de revisión nuevos:

<pre>miproyecto/a-subdir  1.8  1.135  1.13
</pre>

<p>Puede combinar expresiones con <code>%</code> delimitándolas con llaves siguiendo
al signo <code>%</code> - esto las expandirá en series de sublistas separadas
por comas, cada una conteniendo la información correspondiente a un fichero
del envío.  Por ejemplo, <code>%{sv}</code> se expandiría en

<pre>miproyecto/a-subdir  foo,1.8  bar,1.135  baz,1.13
</pre>

<p>y <code>%{sVv}</code> se expandiría en

<pre>miproyecto/a-subdir  foo,1.7,1.8  bar,1.134,1.135  baz,1.12,1.13
</pre>

<p>(Puede que tenga que mirar con cuidado para distinguir las comas de los puntos
decimales en estos ejemplos.)

<p>Aquí hay un fichero loginfo de ejemplo:

<pre>^miproyecto$   /usr/local/nuevorepos/CVSROOT/log.pl \
   -m miproyecto-devel@foobar.com %s
ou             /usr/local/bin/ou-notify.pl  %{sv}
DEFAULT        /usr/local/bin/default-notify.pl  %{sVv}
</pre>

<p>En la primera línea, cualquier envío de cambios en el subdirectorio miproyecto
del repositorio invoca <code>log.pl</code>, pasándole una dirección de correo
electrónico (a la que <code>log.pl</code> enviará un correo con el informe de
cambios), seguido del repositorio, seguido de todos los ficheros del envío.

<p>En la segunda línea, cualquier envío de cambios en un subdirectorio del
repositorio que contenga la cadena <code>ou</code> invocará el guión (imaginario)
<code>notificar-ou.pl</code>, pasándole el repositorio seguido de los nombres de los
ficheros y de los nuevos números de revisión de los ficheros del envío.

<p>La tercera línea invoca el guión (también imaginario)
<code>notificar-defecto.pl</code> para cualquier envío que no coincida con ninguna
de las dos línes anteriores, pasándole toda la información posible (ruta al
repositorio, nombres de fichero, revisiones antiguas y revisiones nuevas).

</body></html>

