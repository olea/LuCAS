<html><head><title>Los Ficheros verifymsg y rcsinfo</title><link rel=next href="El-Fichero-taginfo.html">
<link rel=previous href="Los-Ficheros-commitinfo-y-loginfo-y-rcsinfo.html">
<link rel=up href="El-directorio-administrativo-CVSROOT-.html">
</head>
<body>
<p>
Node:<a name="Los-Ficheros-verifymsg-y-rcsinfo.html">Los Ficheros verifymsg y rcsinfo</a>,
Next:<a rel=next href="El-Fichero-taginfo.html">El Fichero taginfo</a>,
Previous:<a rel=previous href="Los-Ficheros-commitinfo-y-loginfo-y-rcsinfo.html">Los Ficheros commitinfo y loginfo y rcsinfo</a>,
Up:<a rel=up href="El-directorio-administrativo-CVSROOT-.html">El directorio administrativo CVSROOT/</a>
<hr><br>

<h3>Los Ficheros verifymsg y rcsinfo</h3>

<p>A veces puede que solamente quiera un programa que verifique que los
informes de cambios se ajustan a un cierto estándar y que detenga el envío si
no se cumple ese estándar.  Esto puede conseguirse usando <code>verifymsg</code>,
posiblemente con algo de ayuda de <code>rcsinfo</code>.

<p>El fichero <dfn>verifymsg</dfn> es la combinación habitual de expresiones
regulares y programas.  El programa recibe el informe de cambios por la entrada
estándar; es de suponer que realizará ciertas comprobaciones para verificar
que el informe de cambios cumple ciertos criterios, y finalmente sale con
estado cero o distinto de cero.  En este último caso, el envío fallará.

<p>Mientras tanto, el lado izquierdo de rcsinfo tiene las expresiones regulares
habituales, pero el lado derecho señala a ficheros de plantilla en vez de a
programas.  Un fichero de plantilla podría ser algo como esto

<pre>Condición:
Arreglar:
Comentarios:
</pre>

<p>o alguna otra colección de campos que se supone que un desarrollador debe
rellenar para formar un informe de cambios válido.  La plantilla no es muy útil
si todo el mundo hace envíos de cambios usando la opción -m explícitamente,
pero muchos desarrolladores prefieren no hacerlo.  En lugar de ello, ejecutan

<pre>floss$ cvs commit
</pre>

<p>y esperan que CVS lance automáticamente un editor de texto (como se
especifica en la variable de entorno EDITOR).  Ahí escriben un informe de
cambios, guardan el fichero y se salen del editor, después de lo cual CVS
continúa con el envío.

<p>En ese escenario, se insertaría una plantilla rcsinfo en el editor antes
de que el usuario comience a escribir, de forma que se mostrarían los
campos junto con un recordatorio para rellenarlos.  Entonces, cuando el
usuario haga un envío de cambios, se invocará el programa apropiado en
<code>verifymsg</code>.  Presumiblemente comprobará que el informe sigue ese
formato, y su estado de salida reflejará los resultados de su investigación
(con cero indicando éxito).

<p>Como ayuda a los programas de verificación, la ruta a la plantilla del
fichero rcsinfo se añade como último argumento en la línea de órdenes
de <code>verifymsg</code>; de esa forma el programa puede basar su proceso de
verificación en la propia plantilla si se desea.

<p>Observe que cuando alguien obtiene una copia de trabajo en
una máquina remota, el fichero de plantilla rcsinfo correspondiente se
envía al cliente también (se almacena en el subdirectorio CVS/ de la
copia de trabajo).  Sin embargo esto significa que si se cambia el
fichero rcsinfo del servidor después de esto, el cliente no verá los
cambios sin volver a obtener una copia del proyecto (con actualizar
simplemente no funcionará).

<p>Fíjese también en que en el fichero verifymsg no se admite la palabra
clave ALL (aunque DEFAULT sigue valiendo).  Esto es para hacer más
sencillo saltarse guiones de verificación por defecto y aplicar otros
específicos para los subdirectorios.

</body></html>

