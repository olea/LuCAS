<html><head><title>Mis envíos (commits) parecen tener lugar a trozos y no atómicamente</title><link rel=next href="CVS-ignora-los-permisos-que-pongo---por-qué-lo-hace-.html">
<link rel=previous href="El-método-pserver-SIGUE-sin-funcionar.html">
<link rel=up href="Algunos-Problemas-de-la-Vida-Real--con-Soluciones-.html">
</head>
<body>
<p>
Node:<a name="Mis-envíos--commits--parecen-tener-lugar-a-trozos-y-no-atómicamente.html">Mis envíos (commits) parecen tener lugar a trozos y no atómicamente</a>,
Next:<a rel=next href="CVS-ignora-los-permisos-que-pongo---por-qué-lo-hace-.html">CVS ignora los permisos que pongo; ¿por qué lo hace?</a>,
Previous:<a rel=previous href="El-método-pserver-SIGUE-sin-funcionar.html">El método pserver SIGUE sin funcionar</a>,
Up:<a rel=up href="Algunos-Problemas-de-la-Vida-Real--con-Soluciones-.html">Algunos Problemas de la Vida Real (con Soluciones)</a>
<hr><br>

<h3>Mis envíos (commits) parecen tener lugar a trozos y no atómicamente</h3>

<p>Esto es porque CVS hace los envíos a trozos, y no atómicamente. :-)

<p>Más específicamente, las operaciones de CVS tienen lugar directorio a
directorio. Cuando hacemos un commit (o update o cualquier cosa)
afectando a varios directorio, CVS bloquea cada directorio mientras hace
la operación en él, desbloqueándolo antes de pasar al siguiente.

<p>Para proyectos pequeños o medianos, raramente será esto un problema, ni
notaremos que la operación no es atómica. Sin embargo, en proyectos
grandes, se pueden dar escenarios como el siguiente (imaginemos que el
proyecto tiene al menos dos directorios A y B, con muchos ficheros):

<ol type=1 start=1>

</p><li>El usuario pperez inicia un envío (commit), afectando a ficheros de
ambos directorios. CVS envía los ficheros de B en primer lugar (porque
el usuario lo especificó en ese orden).

<li>El usuario jsuerte inicia una actualización (update). Por alguna razón,
supongamos que ésta se inicia copiando el directorio A (CVS no garantiza
ningún orden por su cuenta). Obsérvse que no hay bloqueo aun porque
pperez aun no está activo en A.

<li>Ahora, el envío de pperez finaliza B, se va a A y finaliza A.

<li>Finalmente, la actualización de jsuerte se va a B y finaliza.

</ol>

<p>Claramente, cuando todo acaba, la copia de trabajo de jsuerte refleja
los cambios de pperez en B pero no en A. Aunque pperez intentase hacerlo
atómicamente, no hay forma. Ahora la copia de jsuerte está en un estado
que desconoce pperez.

<p>La solución, por supuesto, es que jsuerte haga de nuevo el cvs
update.

<p>El fallo de no permitir transacciones atómicas es considerado
ampliamente como un error de CVS. La única razón por la que los cerrojos
no se establecen en la raíz del repositorio es porque esto resultaría
inaceptable para grandes proyectos con múltiples desarrolladores. Para
mitigar este problema, en CVS se escogió bloquear a nivel de cada
directorio, reduciendo así la contención. Alguna vez alguien podría
modificar CVS para acelerar sus operaciones, de manera que se mejore
esta situación.

<p>Para más información, véase el nodo <cite>Concurrency</cite> del manual de
Cederqvist.

</body></html>

