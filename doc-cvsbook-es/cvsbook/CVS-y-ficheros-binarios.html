<html><head><title>CVS y ficheros binarios</title><link rel=next href="Eliminar-ficheros.html">
<link rel=previous href="Añadir-directorios.html">
<link rel=up href="Otros-comandos-útiles-de-CVS.html">
</head>
<body>
<p>
Node:<a name="CVS-y-ficheros-binarios.html">CVS y ficheros binarios</a>,
Next:<a rel=next href="Eliminar-ficheros.html">Eliminar ficheros</a>,
Previous:<a rel=previous href="Añadir-directorios.html">Añadir directorios</a>,
Up:<a rel=up href="Otros-comandos-útiles-de-CVS.html">Otros comandos útiles de CVS</a>
<hr><br>

<h3>CVS y ficheros binarios</h3>

<p>Hasta ahora he decidido omitir el secretillo que esconde CVS, que es el
hecho de que no se le dan muy bien los ficheros binarios (bueno, hay
algún que otro secretillo más, pero éste es desde luego el más vergonzante
de todos). No es que CVS no soporte el uso de binarios; en realidad lo
hace, pero no sin algunos dolores de cabeza.

<p>Todos los ficheros en los que hemos estado trabajando hasta ahora han sido
simples ficheros de texto. CVS tiene algunos trucos especiales para los
ficheros de texto: por ejemplo, cuando está trabajando entre un repositorio
de Unix y una copia de trabajo instalada en un sistema Windows o Macintosh,
convierte los finales de línea de la forma apropiada para cada plataforma. 
Por ejemplo, la convención en Unix es usar simplemente un salto de línea
(LF), mientras que Windows espera una secuencia de retorno de carro y salto
de línea (CR+LF) al final de cada línea. Así, los ficheros en una copia de
trabajo bajo Windows tendrán terminaciones CR+LF, mientras que una copia de
trabajo del mismo proyecto instalada en una máquina Unix tendrá
terminaciones LF (el repositorio en sí siempre utiliza el formato LF).

<p>Otro truco es que CVS detecta en los ficheros de texto la presencia de
cadenas especiales, conocidas como cadenas de texto de palabras clave RCS,
y las sustituye con la información de la revisión y otras cosas útiles. 
Por ejemplo, si su fichero contiene esta cadena:

<pre>$Revision$
</pre>

<p>CVS la expandirá en cada envío para poner en su lugar el número de revisión. 
Por ejemplo, esta cadena podría convertirse en

<pre>$Revision: 1.3 $
</pre>

<p>CVS mantiene esta cadena al día en el fichero a medida que éste va
evolucionando. Estas palabras clave se documentan en <a href="CVS-avanzado.html">CVS avanzado</a> y
<a href="Herramientas-de-terceros.html">Herramientas de terceros</a>.

<p>Esta expansión de cadenas de texto es algo muy útil en los ficheros de
texto, ya que permite ver los números de revisión y otra información
sobre un fichero mientras lo está editando. Ahora bien, ¿qué pasa si el
fichero es una imagen JPG? ¿o un programa ejecutable compilado? En estos
casos, CVS podría dañar seriamente los ficheros si se pusiera a expandir
cada palabra clave que fuese encontrando. Es más, en un fichero binario
estas cadenas podrían aparecer por pura coincidencia.

<p>Por lo tanto, cuando añada un fichero binario, debe decirle a CVS que
desactive tanto la expansión de palabras clave como la conversión de
finales de línea. Para ello, utilice -kb:

<pre>floss$ cvs add -kb fichero
floss$ cvs ci -m "añadido esto y lo otro" fichero
  (etcétera)
</pre>

<p>Por otra parte, en ciertas ocasiones (como es el caso de ficheros de texto
donde posiblemente aparezca alguna referencia a este tipo de palabras
clave), posiblemente desee desactivar solamente la expansión de palabras
clave. Esto se hace con -ko:

<pre>floss$ cvs add -ko fichero
floss$ cvs ci -m "añadido esto y lo otro" fichero
  (etcétera)
</pre>

<p>(De hecho, este mismo capítulo que está leyendo es un ejemplo de este tipo
de casos, merced al ejemplo de <code>$Revision$</code> mostrado aquí.)

<p>Tenga en cuenta que no tiene sentido utilizar <code>cvs&nbsp;diff</code> sobre dos
revisiones de un fichero binario. Diff utiliza un algoritmo basado en
texto que sólo puede discernir si dos ficheros binarios son distintos,
pero no la forma en que difieren. Futuras versiones de CVS podrían llegar
a ofrecer alguna manera de presentar diferencias entre ficheros binarios.

</body></html>

