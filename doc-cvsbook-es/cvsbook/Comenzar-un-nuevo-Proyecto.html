<html><head><title>Comenzar un nuevo Proyecto</title><link rel=next href="Obtener-una-copia-de-trabajo.html">
<link rel=previous href="Acceder-a-un-Repositorio.html">
<link rel=up href="Un-día-con-CVS.html">
</head>
<body>
<p>
Node:<a name="Comenzar-un-nuevo-Proyecto.html">Comenzar un nuevo Proyecto</a>,
Next:<a rel=next href="Obtener-una-copia-de-trabajo.html">Obtener una copia de trabajo</a>,
Previous:<a rel=previous href="Acceder-a-un-Repositorio.html">Acceder a un Repositorio</a>,
Up:<a rel=up href="Un-día-con-CVS.html">Un día con CVS</a>
<hr><br>

<h3>Comenzar un nuevo Proyecto</h3>

<p>Si está estudiando el manejo de CVS para trabajar en un proyecto que ya
se encuentra bajo control de CVS (es decir, que se guarda en un repositorio
en alguna parte), probablemente querrá saltarse esta parte e ir directamente
a la siguiente, "Obtener una copia de trabajo". Sin embargo, si lo que desea
es tomar un código fuente ya existente y ponerlo bajo CVS, esta sección es
para usted. Fíjese en que, a pesar de todo, se asume que dispone de acceso
a un repositorio; vea <a href="Administracion-del-Repositorio.html">Administracion del Repositorio</a> si necesita configurar un
repositorio.

<p>Introducir un nuevo proyecto en un repositorio de CVS es lo que se conoce como
<dfn>importar</dfn>. El comando CVS a utilizar, como quizás ya haya adivinado, es

<pre>floss$ cvs import
</pre>

<p>excepto que le hacen falta más opciones (y debe estar en el sitio
apropiado) para que el comando tenga éxito. Primero, vaya al directorio
raíz de su árbol de proyectos:

<pre>floss$ cd miproyecto
floss$ ls
README.txt  a-subdir/   b-subdir/   hello.c
floss$
</pre>

<p>Este proyecto tiene dos ficheros (README.txt y hello.c) en el nivel
más alto, además de dos subdirectorios (a-subdir y b-subdir), y algunos
ficheros más (no mostrados en el ejemplo) dentro de esos subdirectorios. 
Al importar un proyecto, CVS importa todo lo que hay en el árbol, empezando
por el directorio actual y yendo a continuación a todos los directorios que
haya por debajo de éste. Por tanto, debería asegurarse de que sólo los
ficheros que hay en este momento en el árbol son los que desea que formen
parte del proyecto de forma permanente. Cualquier vieja copia de seguridad,
borrador, etc., deberían ser eliminados antes.

<p>La sintaxis general del comando de importación es

<pre>floss$ cvs import -m "mensaje" miproyecto marca_suministrador marca_lanzamiento
</pre>

<p>La opción -m (de "mensaje") sirve para especificar un breve informe
que describe la importación. Éste será el primer informe de cambios
que afecta al proyecto en todo su conjunto; cada envío realizado en
el futuro tendrá su propio informe de cambios. Estos informes son obligatorios;
si no se utiliza la opción -m, CVS lanzará automáticamente un editor
(consultando previamente la variable de entorno EDITOR) para que escriba
en él el informe a utilizar. Una vez que guarde el informe en disco y
salga del editor, el proceso de importación seguirá adelante.

<p>El siguiente argumento es el nombre del proyecto (usaremos "miproyecto"). 
Éste es el nombre con el cual podrá obtener copias desde el repositorio. 
(Lo que realmente sucede es que se crea un directorio con ese nombre en el
repositorio; encontrará más información al respecto en <a href="Administracion-del-Repositorio.html">Administracion del Repositorio</a>.)  El nombre
que elija no tiene por qué ser igual al del directorio actual, aunque
en la mayoría de los casos lo será.

<p>Los argumentos marca_suministrador y marca_lanzamiento son información de
registro adicional para CVS. No se preocupe de ellos ahora; poco importa
lo que utilice en este momento. En <a href="CVS-avanzado.html">CVS avanzado</a> podrá ver las raras ocasiones
en las que son significativos; por ahora, utilizaremos un nombre de usuario y
"start" respectivamente para estos dos argumentos.

<p>Así pues, ya estamos listos para utilizar import:

<pre>floss$ cvs import -m "importación inicial a CVS" miproyecto jluis start
N miproyecto/hello.c
N miproyecto/README.txt
cvs import: Importing /usr/local/cvs/miproyecto/a-subdir
N miproyecto/a-subdir/loquesea.c
cvs import: Importing /usr/local/cvs/miproyecto/a-subdir/subsubdir
N miproyecto/a-subdir/subsubdir/fish.c
cvs import: Importing /usr/local/cvs/miproyecto/b-subdir
N miproyecto/b-subdir/random.c

No conflicts created by this import
floss$
</pre>

<p>¡Enhorabuena! Si ha ejecutado este comando (o algo similar), ya ha hecho por
fin algo que afecta al repositorio.

<p>Observando la salida del comando import, se dará cuenta de que CVS precede
cada nombre de fichero con una letra, en este caso la "N" para indicar que
se trata de un nuevo fichero. El uso de una letra a la izquierda para indicar
el estado de un fichero es algo común en la salida de los comandos de CVS,
tal como veremos más adelante también con los comandos "update" y "checkout".

<p>Llegados a este punto, podría pensar que, puesto que ha importado el proyecto,
puede empezar a trabajar en el árbol inmediatamente. Éste, sin embargo, no es
el caso: el árbol de directorios actual no es todavía una copia de trabajo de
CVS. Fue el origen para el comando de importación, cierto, pero no por éso se
ha convertido por arte de magia en una copia de trabajo de CVS: para obtener
una copia en la que poder trabajar, deberá tomarla del repositorio.

<p>Pero antes, sin embargo, quizás quiera archivar el árbol de directorios
actual. El motivo es que, una vez que las fuentes están en CVS, no querrá
liarse y editar por error copias que no están bajo control de versión
(puesto que esos cambios no se convertirán en parte del historial del
proyecto). De ahora en adelante querrá hacer todas las ediciones sobre la
copia de trabajo. Por otra parte, no le interesará eliminar completamente
el árbol que ha importado, puesto que no ha verificado todavía si el
repositorio dispone realmente de todos los ficheros. Por supuesto, puede
estar un 99.999% seguro de que es así dado que el comando de importación
no devolvió ningún error, pero, ¿por qué correr riesgos? A menudo vale la
pena ser paranoico, como puede confirmarle cualquier programador. Así que
haga algo como esto:

<pre>floss$ ls
README.txt  a-subdir/   b-subdir/   hello.c
floss$ cd ..
floss$ ls
miproyecto/
floss$ mv miproyecto era_miproyecto
floss$ ls
era_miproyecto/
floss$
</pre>

<p>Hecho. Ahora sigue teniendo los ficheros originales, pero están claramente
marcados como correspondientes a una versión obsoleta, así que no estarán
ahí estorbándole cuando obtenga una verdadera copia de trabajo. Ahora sí,
por fin, está listo para obtenerla.

</body></html>

