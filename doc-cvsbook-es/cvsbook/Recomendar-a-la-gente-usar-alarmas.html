<html><head><title>Recomendar a la gente usar alarmas</title><link rel=next href="Cómo-aparecen-las-alarmas-en-el-repositorio.html">
<link rel=previous href="Encontrar-quién-vigila-qué.html">
<link rel=up href="Alarmas--CVS-como-telefono-.html">
</head>
<body>
<p>
Node:<a name="Recomendar-a-la-gente-usar-alarmas.html">Recomendar a la gente usar alarmas</a>,
Next:<a rel=next href="Cómo-aparecen-las-alarmas-en-el-repositorio.html">Cómo aparecen las alarmas en el repositorio</a>,
Previous:<a rel=previous href="Encontrar-quién-vigila-qué.html">Encontrar quién vigila qué</a>,
Up:<a rel=up href="Alarmas--CVS-como-telefono-.html">Alarmas (CVS como telefono)</a>
<hr><br>

<h3>Recomendar a la gente usar alarmas</h3>

<p>Habrá observado que el funcionamiento de las alarmas depende, en
última instancia de la colaboración de todos los desarrolladores. 
Si alguien empieza a editar un fichero sin ejecutar <code>cvs edit</code>,
nadie lo sabrá hasta que los cambios se entreguen. Como <code>cvs edit</code>
se usa a un nivel superior y no está dentro de la rutina normal de
desarrollo las personas pueden olvidarse fácilmente de hacerlo.

<p>Aunque CVS no puede forzar a alguien a usar <code>cvs edit</code>, tiene un
mecanismo que es permite a recordar a los usuarios a hacerlo;
la orden <code>watch on</code>:

<pre>floss$ cvs -q co myproj
U myproj/README.txt
U myproj/foo.gif
U myproj/hello.c
U myproj/a-subdir/whatever.c
U myproj/a-subdir/subsubdir/fish.c
U myproj/b-subdir/random.c
floss$ cd myproj
floss$ cvs watch on hello.c
floss$
</pre>

<p>Ejecutando <code>cvs watch</code> sobre hello.c, jrandom hace que futuras
obtenciones de copias de myproj hagan que hello.c sea de sólo lectura en la
copia de trabajo. Cuando qsmith intenta trabajar sobre él comprobará
que es de sólo lectura y se le recordará que debe ejecutar primero
<code>cvs edit</code>:

<pre>paste$ cvs -q co myproj
U myproj/README.txt
U myproj/foo.gif
U myproj/hello.c
U myproj/a-subdir/whatever.c
U myproj/a-subdir/subsubdir/fish.c
U myproj/b-subdir/random.c
paste$ cd myproj
paste$ ls -l
total 6
drwxr-xr-x   2 qsmith    users        1024 Jul 19 01:06 CVS/
-rw-r--r--   1 qsmith    users          38 Jul 12 11:28 README.txt
drwxr-xr-x   4 qsmith    users        1024 Jul 19 01:06 a-subdir/
drwxr-xr-x   3 qsmith    users        1024 Jul 19 01:06 b-subdir/
-rw-r--r--   1 qsmith    users         673 Jun 20 22:47 foo.gif
-r--r--r--   1 qsmith    users         188 Jul 18 01:20 hello.c
paste$
</pre>

<p>Cuando lo ha hecho, el fichero será de lectura-escritura. Entonces lo
podrá editar y cuando haga entregas, pasa a modo de sólo lectura:

<pre>paste$ cvs edit hello.c
paste$ ls -l hello.c
-rw-r--r--   1 qsmith    users         188 Jul 18 01:20 hello.c
paste$ emacs hello.c
  ...
paste$ cvs commit -m "decir hello en arameo" hello.c
Checking in hello.c;
/usr/local/newrepos/myproj/hello.c,v  &lt;--  hello.c
new revision: 1.12; previous revision: 1.11
done
paste$ ls -l hello.c
-r--r--r--   1 qsmith    users         210 Jul 19 01:12 hello.c
paste$
</pre>

<p>Al hacer esta edición y entrega se enviarán notificaciones a todos los
vigilantes de hello.c. Observe que jranadom no es necesariamente uno de
ellos. Al ejecutar <code>cvs watch</code> sobre hello.c jrandom no se añadió asimismo
a la lista de vigilancia para ese fichero; simplemente especificó qe
se deberían obtener copias  en modo de sólo lectura. Las personas que quieren
vigilar un fichero deben añadirse a la lista de vigilancia. CVS no puede
hacer nada sobre esto.

<p>Establecer alarmas en un simple fichero sería la excepción. Generalmente
es más común establecer las alarmas sobre un proyecto:

<pre>floss$ cvs -q co myproj
U myproj/README.txt
U myproj/foo.gif
U myproj/hello.c
U myproj/a-subdir/whatever.c
U myproj/a-subdir/subsubdir/fish.c
U myproj/b-subdir/random.c
floss$ cd myproj
floss$ cvs watch on
floss$
</pre>

<p>Esta acción equivale a anunciar una potitica de decisión para todo el
proyecto: <em>"Por favor, use cvs edit para advertir a los vigilantes en
que está trabajando y vigile cuantos ficheros le interesen o sean de su
responsabilidad."</em> Cada fichero del proyecto será actualizado en modo
de sólo lectura, y así a la gente se le recordará que se espera que
usen <code>cvs edit</code> antes de trabajar en algo.

<p>Curiosamente, aunque obtenciones de copias de ficheros vigilados se hacen
en modo de sólo lectura, las actualizaciones no lo son. Si qsmith ha
obtenido una copia de trabajo antes de que jrandom hiciera <code>cvs watch</code>
sus ficheros serían le lectura-escritura quedando así incluso después de
hacer actualizaciones. Sin embargo, cualquier fichero que entregue
después de que jrandom estableciera las alarmas será de sólo lectura. 
Si jrandom quita las alarmas:

<pre>floss$ cvs watch off
</pre>

<p>los ficheros de sólo lectura de qsmith no se convierte mágicamente en
ficheros de lectura-escritura. Por otro lado, después de hacer una entrega
volverán a modo lectura-escritura de nuevo (como si las alarmas todavía
estuviaran puestas).

<p>Observe que qsmith podría, si fuese malicioso, hacer los ficheros de
su copia de trabajo escribibles usando la orden estándar de Unix
<code>chmod</code> saltándose <code>cvs&nbsp;edit</code> por completo.

<pre>paste$ chmod u+w hello.c
</pre>

<p>o si quisiera hacerlo todo en una pasada.

<pre>paste$ chmod -R u+w .
</pre>

<p>No hay nada que CVS pueda hacer sobre esto. Las copias de trabajo son
por su propia naturaleza privadas. Las alarmas pueden permitir su
escrutinio al público tanto como lo permita el desarrollador. 
Sólamente cuando un desarrollador hace algo que afecte al
repositorio (como una entrega) su privacidad se pierde incondicinalmente.

<p>La relación entre <code>watch add</code>, <code>watch remove</code>, <code>watch on</code>
y <code>watch off</code>
podría parecer confusa. Para aclarar esto resumamos  el esquema general:
<code>add</code> y <code>remove</code> sirven para añadir o quitar usuarios de la
lista de vigilancia de un fichero; no tiene nada que ver con que
los ficheros sean de sólo lectura al obtener la copia de trabajo o
después de la entrega. <code>on</code> y <code>off</code> sirven para los permisos
de los ficheros. No tienen nada que ver con la lista de vigilancia;
más bien son herramientas par ayudar a los desarrolladores a recordar
la política de alarmas haciendo que los ficheros de la copia de trabajo
sean de sólo lectura.

<p>Todo esto parece un poco inconsistente. De algún modo el usar alarmas
parece ir en contra de la esencia de CVS. Se desvía del universo
ideal de múltiples desarrrolladores editando libremente en sus copias
de trabajo, ocultos unos de otros hasta que hacen una entrega. Con las
alarmas CVS da a los desarrolladores atajos para informarse mutuamente
lo que pasa en sus copias de trabajo. Sin embargo no tiene forma de
imponer las políticas de observación ni un concepto de que constituye
una sesión de edición. Aun así las alarmas pueden ser útiles en ciertas
ocasiones.

</body></html>

