@c ---------------------------------------------------------------------
@node Administracion del Repositorio
@unnumbered Administracion del Repositorio

@comment Este capítulo ha sido traducido por
@comment Emilio Murcia Pacheco <emmurcia@@terra.es>
@comment  
@comment Se ceden todos los derechos bajo la licencia de documentación de 
@comment la GNU (fdl) que se puede encontrar en http://www.gnu.org/


En @ref{Una introduccion a CVS}, usted ha aprendido bastante de CVS para usarlo
de forma eficaz como participante de un proyecto.  Sin embargo, si va a ser
administrador de un proyecto, necesitará conocer cómo instalar CVS y
administrar repositorios.  En este capítulo descorreremos la cortina y
observaremos en detalle cómo se estructura el repositorio, y cómo lo utiliza
CVS.  Aprenderá los pasos más importantes por los que pasa CVS
durante las actualizaciones y envíos ("commits"), y cómo puede modificar su
comportamiento.  Comprendiendo cómo trabaja CVS, será también capaz de
encontrar las causas de los problemas, y resolverlos de forma mantenible.

Esto puede parecer muy complicado, pero recuerde que CVS ya ha probado
ser bastante duradero, y seguramente seguirá usándose durante muchos años más.
Lo que aprenda ahora le será de utilidad durante mucho tiempo.  CVS también
tiende a hacerse más indispensable cuanto más lo use.  Si va a depender tanto
de algo (y hágame caso, así será), realmente vale la pena que llegue a
conocerlo.

Con esto en mente, vamos a comenzar por el principio: poniendo CVS en su
sistema.

@menu
* Consiguiendo e instalando CVS::                 Poniendo CVS en su sistema.
* Anatomia de una distribucion CVS::              Qué hay en la distribución CVS.
* Iniciando un repositorio::                      Poniendo a punto un repositorio.
* El servidor de autentificacion de contrasen~as:: Un método de acceso remoto.
* Acceso anonimo::                                Garantizando acceso al público.
* Estructura del repositorio::                    Cómo se organiza el repositorio.
* Formato RCS::                                   Cómo funciona el almacenamiento en el repositorio.
* Qué ocurre cuando elimina un fichero::          CVS reserva un ático para los ficheros antiguos.
* El directorio administrativo CVSROOT/::         Ficheros de configuración del servidor en tiempo de ejecución.                                                                  
* Correos de envío de cambios::                   Fijando envíos automáticos de notificaciones.
* Averiguando más::                               Otras fuentes de información.
@end menu

@c -----------------------------------------------------
@node Consiguiendo e instalando CVS
@section Consiguiendo e instalando CVS

En muchos casos, no tendrá que salir a buscar CVS, porque ya estará
en su sistema.  Si posee una de las distribuciones principales de Linux
o FreeBSD, seguramente está instalado en /usr/bin o alguna otra localización
probable.  Si no, los usuarios de Red Hat Linux pueden encontrar por lo
general un RPM ("Red Hat Package", o Paquete de Red Hat) con la última versión
de CVS (o casi la última) en sus distribuciones.  Y los usuarios de Debian
pueden instalar el último paquete Debian con estas órdenes:

@example
floss$ apt-get update
floss$ apt-get install cvs
@end example

Si CVS no está ya en su máquina, probablemente tendrá que compilarlo a partir
del código fuente.  Si no es un usuario de Unix, seguramente encuentre más
fácil conseguir un binario precompilado para su sistema operativo (más adelante
se detalla este aspecto).  Afortunadamente, CVS está totalmente
@dfn{autoconfigurado} -- es decir, utiliza el mecanismo de autoconfiguración de
GNU, con lo que la compilación a partir de las fuentes es sorprendentemente
sencilla.

@menu
* Consiguiendo y compilando CVS bajo Unix::
* Consiguiendo e instalando CVS bajo Windows::
* Consiguiendo e instalando CVS en un Macintosh::
* Limitaciones de las versiones Windows y Macintosh::
@end menu

@c ---------------------------
@node Consiguiendo y compilando CVS bajo Unix
@subsection Consiguiendo y compilando CVS bajo Unix

En el momento de escribir esto, existen dos sitios principales de los que
se puede descargar CVS.  Uno es el servidor FTP de la Fundación para el
Software Libre, @uref{ftp://ftp.gnu.org/gnu/cvs/}, que ofrece CVS como
herramienta oficial GNU.  El otro es el sitio de descarga de Cyclic Software.
Cyclic Software es, si no el "administrador" de CVS, sí el "administrador de
los administradores", proporcionando un servidor de repositorio y acceso para
descargar a usuarios y desarrolladores.  Distribuyen versiones desde
@uref{http://download.cyclic.com/pub/}.

Cualquiera de los dos sitios es bueno.  En el siguiente ejemplo, uso el sitio
de Cyclic Software.  Si dirige su cliente FTP (seguramente su navegador Web)
hacia allí, verá una lista de directorios, algo como esto:

@example
Index of /pub
    cvs-1.10.5/            18-Feb-99 21:36      -
    cvs-1.10.6/            17-May-99 10:34      -
    cvs-1.10/              09-Dec-98 17:26      -
    macintosh/             23-Feb-99 00:53      -
    os2/                   09-Dec-98 17:26      -
    packages/              09-Dec-98 17:26      -
    rcs/                   09-Dec-98 17:26      -
    tkcvs/                 09-Dec-98 17:26      -
    training/              09-Dec-98 17:26      -
    unix/                  09-Dec-98 17:26      -
    vms/                   09-Dec-98 17:26      -
@end example

Preste atención a los directorios que empiezan por "cvs-" (puede ignorar
la mayoría de los demás).  Hay tres directorios de este tipo, lo que significa
que se enfrenta a una elección: Descargar la versión llamada "estable",
o ir a por una versión intermedia más reciente (pero menos probada).  Las
versiones estables tienen sólo un punto decimal, como en "cvs-1.10", mientras
que las versiones intermedias tienen incrementos de versión menores añadidos
al final, como en "1.10.5".

El sitio de GNU sólo ofrece las versiones principales, no las intermedias,
así que no verá todas las anteriores si consigue CVS desde aquí.  En general,
las versiones intermedias han sido bastante seguras, y a veces
resuelven problemas encontrados en las versiones principales.  La mejor
política es ir a por la versión intermedia más alta, pero si encuentra
cualquier problema con ella, prepárese para bajar a la versión anterior, tantas
veces como sea necesario.  La versión más alta listada en el ejemplo anterior
es cvs-1.10.6.  Entrando en ese directorio, veremos esto:

@example
Index of /pub/cvs-1.10.6
    cvs-1.10.6.tar.gz      17-May-99 08:44   2.2M
@end example

Esto es -- el código fuente completo de CVS.  Descárguelo a su máquina
y estará preparado para compilar.  En este punto, si ya esta familiarizado
con el proceso de compilación estándar para herramientas GNU, sabrá qué hacer
y probablemente no necesite leer nada desde aquí a la sección
@ref{Anatomia de una distribucion CVS}.  Por otra parte, si no está seguro
de cómo continuar, siga leyendo....

Los siguientes ejemplos e instrucciones de compilación asumen que posee una
distribución estándar de Unix.  Cualquiera de las versiones libres de Unix
(por ejemplo, FreeBSD o Linux) debería funcionar sin problemas, como debería
ocurrir en las principales versiones comerciales de Unix (como SunOS/Solaris,
AIX, HP-UX, o Ultrix).  Incluso si estas instrucciones no funcionan para usted
exactamente como están escritas, no renuncie a la esperanza.  Aunque cubrir los
detalles de compilar en cada sistema operativo está fuera de los objetivos de
este libro, daré indicaciones de otras fuentes de ayuda más adelante en este
capítulo.

De todas formas, para seguir adelante con la compilación, primero descomprima
el fichero tar usando GNU unzip y tar (si no los tiene instalados en su
sistema, puede conseguir gunzip de @uref{ftp://ftp.gnu.org/gnu/gzip/} y la
versión GNU de tar de @uref{ftp://ftp.gnu.org/gnu/tar/}):

@example
floss$ gunzip cvs-1.10.6.tar.gz
floss$ tar xvf cvs-1.10.6.tar
@end example

Verá muchos nombres de fichero volando por su pantalla.

Ahora tendrá un nuevo directorio en su máquina -- cvs-1.10.6 --, que contendrá
el código fuente de CVS.  Entre al directorio y configure CVS para su sistema,
usando el guión "configure" proporcionado:

@example
floss$ cd cvs-1.10.6
floss$  ./configure
creating cache ./config.cache
checking for gcc... gcc
checking whether we are using GNU C... yes
checking whether gcc accepts -g... yes
checking how to run the C preprocessor... gcc -E
  (etc)
@end example

Cuando la orden "configure" finalice, el árbol fuente sabrá todo lo que
necesita saber para compilarse en su máquina.  El siguiente paso consiste
en escribir:

@example
floss$ make
@end example

Verá muchas líneas de salida en su pantalla, después escriba:

@example
floss$ make install
@end example

Verá aún más líneas de salida volando; cuando haya acabado del todo, CVS
estará instalado en su sistema.  (Seguramente necesitará hacer este último
paso como superusuario.)

Por defecto, el ejecutable de CVS acabará siendo @file{/usr/local/bin/cvs}.
Esto asume que usted tiene un programa "make" decente instalado en su sistema
(de nuevo, si no tiene uno, consiga el "make" del proyecto GNU en
@uref{ftp://ftp.gnu.org/gnu/make/}).

Si quiere que CVS se instale en una ruta distinta de /usr/local/bin, debería
cambiar la forma en que ejecuta el paso inicial de configuración.  Por ejemplo,

@example
floss$ ./configure --prefix=/usr
@end example

da lugar a que CVS esté instalado como /usr/bin/cvs (siempre acaba en
PREFIX/bin/cvs).  El prefijo por defecto es /usr/local, que está bien para
la mayoría de las instalaciones.

Nota Para Usuarios Experimentados: Aunque las versiones antiguas de CVS
consistían en más que un mero ejecutable puesto que dependían de tener
instalado RCS también, este no ha sido el caso desde la Versión 1.10.
Por ello, no necesita preocuparse por ninguna librería o ejecutable
aparte de cvs mismo.

Si solamente pretende usar CVS para acceder a repositorios remotos, lo
anterior es todo lo que necesita hacer.  Si además planea servir un
repositorio desde su sistema, serán necesarios algunos pasos adicionales
que se explican más adelante en este capítulo.

@c ---------------------------
@node Consiguiendo e instalando CVS bajo Windows
@subsection Consiguiendo e instalando CVS bajo Windows

A menos que sea realmente fanático respecto a tener el código fuente de
su ejecutable, no necesitará compilar CVS a partir de las fuentes en su
caja Windows.  Al contrario que en Unix, probablemente las herramientas
necesarias para compilar no existan en su sistema, por lo que una compilación
implicaría primero conseguir estas herramientas.  Dado que eso está fuera de
los objetivos de este libro, simplemente daré unas instrucciones para conseguir
un binario de CVS precompilado.

Antes de nada hay que notar que las distribuciones binarias de CVS
para Windows generalmente se hacen sólo para las versiones principales
de CVS -- no para las intermedias -- y no se encuentran en el sitio
FTP de GNU.  Así que necesitará ir al sitio de descarga de Cyclic
Software, donde en el directorio de la versión principal,
@uref{http://download.cyclic.com/pub/cvs-1.10/}, verá un subdirectorio
adicional

@example
Index of /pub/cvs-1.10
    cvs-1.10.tar.gz        14-Aug-98 09:35   2.4M
    windows/
@end example

dentro del cual hay un fichero ZIP:

@example
Index of /pub/cvs-1.10/windows
    cvs-1.10-win.zip       14-Aug-98 10:10   589k
@end example

Este fichero ZIP contiene una distribución binaria de CVS.  Descárguela
y descomprima este fichero ZIP:

@example
floss$ unzip cvs-1.10-win.zip

Archive:  cvs-1.10-win.zip
  inflating: cvs.html
  inflating: cvs.exe
  inflating: README
  inflating: FAQ
  inflating: NEWS
  inflating: patch.exe
  inflating: win32gnu.dll
@end example

El fichero README contiene instrucciones detalladas.  Para la mayoría de
las instalaciones, pueden resumirse como sigue: Ponga todos los ficheros EXE
y DLL en un directorio incluido en su PATH.  Además, si va a usar el método
pserver para acceder a un repositorio remoto, quizá necesite añadir lo
siguiente a su fichero @file{C:\AUTOEXEC.BAT} y reiniciar:

@example
set HOME=C:
@end example

Esto le dice a CVS dónde almacenar el fichero .cvspass.

Actualmente CVS bajo Windows no puede servir repositorios a máquinas
remotas; puede ser un cliente (conectándose a repositorios remotos), y
operar en modo local (usando un repositorio en la misma máquina).  Por
lo general, este libro asume que CVS bajo Windows funciona como cliente.
Sin embargo, no debería ser demasiado difícil poner a punto un
repositorio local bajo Windows después de leer las instrucciones
orientadas a Unix del resto de este capítulo.

Si sólo accede a repositorios remotos, puede que ni siquiera necesite
ejecutar CVS.  Existe una utilidad llamada WinCvs que implementa sólo la
parte cliente de CVS.  Se distribuye por separado de CVS pero, como CVS,
está disponible libremente bajo la Licencia Pública General (GPL) de GNU.
Hay más información disponible en @uref{http://www.wincvs.org}.

@c -------------------------
@node Consiguiendo e instalando CVS en un Macintosh
@subsection Consiguiendo e instalando CVS en un Macintosh

CVS está disponible para Macintosh, pero no como parte de la
distribución principal.  De momento, hay realmente disponibles tres
clientes CVS para Macintosh por separado:

@itemize
@item MacCvs -- @uref{http://www.wincvs.org}
@item MacCVSClient -- @uref{http://www.glink.net.hk/~jb/MacCVSClient}
      o @uref{http://www.cyclic.com/maccvsclient/}
@item MacCVS Pro -- @uref{http://www.maccvs.org}
@end itemize

Francamente, no sé cuál es el mejor.  Pruébelos todos, no necesariamente
en el orden dado, y vea cuál le gusta.  MacCVS Pro parece tener un
desarrollo activo.  MacCvs aparentemente es un proyecto compañero de
WinCVS y comparte página web con él. (En el momento de escribir esto, un
aviso en la página de WinCVS afirma: "El desarrolo de MacCvs se reanudará
pronto.", ignoro lo que signifique esto.)

@c -------------------------------------------------------------
@node Limitaciones de las versiones Windows y Macintosh
@subsection Limitaciones de las versiones Windows y Macintosh

Las distribuciones de CVS para Windows y Macintosh están por lo general
limitadas en funcionalidad.  Todas pueden actuar como clientes, en el
sentido de que pueden contactar con un servidor de repositorio para obtener
una copia válida, enviar cambios, actualizar, etc.  Pero no pueden servir
repositorios por ellas mismas.  Si la configura correctamente, la versión
de Windows podrá usar un repositorio en un disco local, pero aún no podrá
servir proyectos desde ese repositorio a otras máquinas.  En general, si
desea tener un repositorio CVS accesible por red, deberá ejecutar el servidor
CVS en una máquina Unix.

@c -----------------------------------------------------
@node Anatomia de una distribucion CVS
@section Anatomia de una distribucion CVS

Las instrucciones anteriores están diseñadas para ponerle en marcha
rápidamente, pero hay mucho más dentro de una distribución de fuentes de
CVS que simplemente el código.  Aquí tiene un repaso rápido al árbol
fuente, de forma que sepa qué partes son recursos útiles y cuáles
pueden ignorarse.

@menu
* Ficheros informativos::           NEWS, BUGS, FAQ, etc.
* Subdirectorios::                  Cómo está organizada la distribución.
* El manual Cederqvist::            El Manual En Línea De CVS.
* Otras fuentes de información::    Dónde más encontrar ayuda.
@end menu

@c ---------------------------------------------------
@node Ficheros informativos
@subsection Ficheros informativos

En el nivel superior del árbol de la distribución, encontrará algunos
ficheros que contienen información útil (y enlaces a información más
detallada).  Estos ficheros son, en orden de importancia aproximado:

@itemize

@item
@file{NEWS} -- Este fichero enumera los cambios de una versión a la siguiente,
en orden cronológico inverso (es decir, la más reciente al principio).  Si
ya ha estado usando CVS durante un tiempo y se ha actualizado a una nueva
versión, debería mirar en el fichero NEWS para ver qué nuevas funciones
están disponibles.  Además, aunque la mayoría de los cambios de CVS conservan
compatibilidad hacia atrás, de vez en cuando hay cambios no compatibles. Es
mejor leer algo acerca de ellos aquí que sorprenderse cuando CVS no se comporte
como espera que lo haga.

@item
@file{BUGS} -- Este fichero contiene exactamente lo que piensa: una lista de
errores conocidos en CVS.  Generalmente no harán que la versión de CVS sea
inutilizable, pero debería leer el fichero cada vez que instale una nueva
versión.

@item
@file{DEVEL-CVS} -- Este fichero es la "constitución" de CVS.  Describe
el proceso mediante el cual se aceptan los cambios en la distribución principal
de CVS y los procedimientos mediante los que una persona se convierte en
desarrollador de CVS.  No necesita leerlo si sólo quiere usar CVS; sin embargo,
resulta muy interesante si quiere comprender cómo los esfuerzos descoordinados
de gente repartida por todo el mundo convergen en un programa que funciona.  Y
por supuesto, hace falta leerlo si planea enviar un parche (sea para reparar
un error o para una nueva característica) a CVS.

@item
@file{HACKING} -- Pese a su nombre, el fichero HACKING no dice mucho
del diseño o implementación de CVS.  Es principalmente una guía de
estándares de programación y otros asuntos técnicos para gente que piense
en escribir un parche para CVS.  Puede verse como un apéndice del fichero
DEVEL-CVS.  Después de comprender la filosofía básica del desarrollo
de CVS, debe leer el fichero HACKING para traducir esta filosofía a unas
prácticas concretas de programación.

@item
@file{FAQ} -- Éste es el documento de "Preguntas Frecuentes" (FAQ o "Frequently
Asked Questions" en inglés). Desgraciadamente ha tenido una historia de
mantenimiento bastante irregular.  David Grubbs se encargó de él hasta
1995.  En ese momento (presumiblemente) estaba muy ocupado, y el fichero
languideció durante un tiempo.  Finalmente, in 1997, Pascal Molli retomó
el mantenimiento.  Molli tampoco tuvo tiempo para mantenerlo a mano, pero al
menos encontró tiempo para ponerlo en su sistema automático FAQ-O-Matic,
que permite al público mantener las FAQ de un modo descentralizado
(básicamente, cualquiera puede editar o añadir entradas mediante un formulario
Web).  Probablemente esto fue una buena idea, puesto que al menos las FAQ están
siendo actualizadas de nuevo; sin embargo, la organización general y el control
de calidad no son del mismo nivel que si una única persona las mantuviera.

La versión maestra de las FAQ está siempre disponible en el sitio Web de Molli
(@uref{http://www.loria.fr/~molli/cvs-index.html}, bajo el enlace
"Documentation").  El fichero FAQ que se encuentra en las distribuciones CVS se
genera automáticamente desde la base de datos de FAQ-O-Matic, así que para
cuando llega al público está un poco anticuado. Sin embargo, puede ser de
gran ayuda si busca sugerencias y ejemplos sobre cómo hacer algo específico
(como fusionar una rama enorme al tronco o "resucitar" un fichero eliminado).
La mejor forma de usarlo es como documento de referencia; puede abrirlo
en su editor favorito y hacer búsquedas de los términos que le interesen.
Intentar usarlo como un tutorial sería un error -- le faltan demasiados puntos
importantes sobre CVS para servir de guía completa.

@end itemize

@c -------------------------
@node Subdirectorios
@subsection Subdirectorios

La distribución CVS contiene unos cuantos subdirectorios.  En el curso de
una instalación normal no tendrá que navegar por ellos, pero si quiere
curiosear por las fuentes, está bien saber qué hace cada cosa.  Aquí están:

@example
contrib/
diff/
doc/
emx/
lib/
man/
os2/
src/
tools/
vms/
windows-NT/
zlib/
@end example

La mayoría de ellos pueden ignorarse.  Los subdirectorios emx/, os2/,
vms/, and windows-NT/ contienen código fuente específico del sistema
operativo, por lo que usted sólo los necesitaría si realmente está
tratando de arreglar un problema a nivel de código en CVS (una situación
improbable, aunque no sería la primera vez).  Los subdirectorios diff/
and zlib/ contienen implementaciones internas de CVS del programa diff
y de la biblioteca de compresión GNU zip, respectivamente. (CVS usa la
última para reducir el número de bits que tiene que enviar por la red
cuando accede a repositorios remotos.)

Los subdirectorios contrib/ y tools/ contienen programas libres hechos
por terceros para usarse con CVS.  En contrib/, encontrará una
ordenación de guiones de consola ("shell scripts", N. del T.) pequeños y
especializados (lea contrib/README para averiguar lo que hacen).  El
subdirectorio tools/ solía contener contribuciones, pero ahora contiene
un fichero README que dice en parte:

@example
Este subdirectorio antiguamente contenía herramientas que pueden usarse
con CVS.  En particular, solía contener una copia de la versión 1.x de
pcl-cvs. Pcl-cvs es una interfaz de Emacs para CVS.

Si está buscando pcl-cvs le sugerimos la versión 2.x de pcl-cvs en:
    ftp://ftp.weird.com/pub/local/
@end example

El paquete PCL-CVS a que se refiere es muy práctico, y tengo más que
decir sobre él en @ref{Herramientas de terceros}.

Los subdirectorios src/ y lib/ contienen el grueso del código fuente
de CVS, incluido el codigo interno de CVS.  Las principales estructuras
de datos y órdenes están implementados en src/, mientras que lib/
contiene pequeños módulos de código de utilidad general que usa CVS.

El subdirectorio man/ contiene las páginas man de CVS (para el sistema
de manual en línea de Unix).  Cuando ejecutó "make install", se incorporaron
dentro de las páginas man de su sistema Unix, así que puede escribir

@example
floss$ man cvs
@end example

y conseguir una introducción y referencia de subórdenes (algo concisas) para
CVS.  Aunque son útiles como referencia rápida, las páginas del manual pueden
no estar tan actualizadas ni ser tan completas como el manual Cederqvist (vea
la próxima sección); sin embargo, si sirve de consuelo, es más probable que
las páginas del manual estén incompletas que realmente sean incorrectas.

@c -------------------------
@node El manual Cederqvist
@subsection El manual Cederqvist

Con esto llegamos al subdirectorio doc/, cuyo habitante más importante es
el famoso @dfn{Cederqvist}.  Hoy en día seguramente sea excesivo llamarlo
"el Cederqvist".  Aunque Per Cederqvist (de Signum Support, Linkoping
Suecia, www.signum.se) escribió la primera versión alrededor de 1992, muchas
otras personas lo han actualizado desde entonces.  Por ejemplo, cuando los
desarrolladores añaden una nueva característica a CVS, generalmente también
la documentan en el Cederqvist.

El Manual Cederqvist está escrito en formato Texinfo, usado por el proyecto
GNU porque es relativamente fácil producir salidas tanto en línea como
impresas a partir de él (en los formatos Info y PostScript respectivamente).
El fichero maestro Texinfo es doc/cvs.texinfo, pero las distribuciones CVS
vienen con los ficheros Info y PostScript pregenerados, así que no tiene
que preocuparse de ejecutar herramientas Texinfo.

Aunque el Cederqvist puede usarse como introducción y tutorial, probablemente
sea más útil como documento de referencia.  Por esa razón, la mayoría de la
gente navega por él en línea en lugar de imprimirlo (aunque el fichero
PostScript es @file{doc/cvs.ps}, para aquellos que tengan papel de sobra).
Si ésta es la primera vez que ha instalado CVS en su sistema, tendrá que
hacer un paso extra para asegurarse de que el manual está accesible en línea.

Los ficheros Info (doc/cvs.info, doc/cvs.info-1, doc/cvs.info-2, etc.)
se instalaron cuando ejecutó "make install".  Aunque los ficheros se copiaron
en el árbol Info del sistema, puede que aún tenga que añadir una línea
para CVS en la tabla de contenidos de Info, el nodo "Top". (Esto sólo será
necesario si es la primera vez que ha instalado CVS en su sistema;
de lo contrario, la entrada de instalaciones anteriores debería estar ya
en la tabla de contenidos.)

Si ha añadido nueva documentación Into antes, puede que esté familiarizado
con el proceso.  Primero averigüe dónde se instalaron las páginas Info.
Si usó la instalación por defecto (en /usr/local/), entonces los ficheros
Info son /usr/local/info/cvs.info*.  Si al instalar usó

@example
floss$ ./configure --prefix=/usr
@end example

los ficheros acabaron siendo /usr/info/cvs.*.  Después de localizar los
ficheros, necesitará añadir una línea para CVS en la tabla de contenidos de
Info, que está en un fichero llamado dir en ese directorio (así que en el
último caso sería /usr/info/dir).  Si no tiene acceso como root pídale a su
administrador que lo haga.  Aquí hay un extracto de dir antes de añadir
la referencia a la documentación CVS:

@example
* Bison: (bison).         The Bison parser generator.
* Cpp: (cpp).             The GNU C preprocessor.
* Flex: (flex).           A fast scanner generator
@end example

Y aquí está la misma zona de dir despues:

@example
* Bison: (bison).         The Bison parser generator.
* Cpp: (cpp).             The GNU C preprocessor.
* Cvs: (cvs).             Concurrent Versions System
* Flex: (flex).           A fast scanner generator
@end example

El formato de la línea es muy importante.  Debe incluir el asterisco,
los espacios y los dos puntos en @w{@samp{* Cvs:}}, y los paréntesis y
el punto en @samp{(cvs).} detrás de él.  Si falta cualquiera de estos
elementos, el formato del Info dir estará corrupto, y será incapaz
de leer el Cederqvist.

Una vez que el manual esté instalado y referenciado desde la tabla de
contenidos, podrá leerlo con cualquier navegador compatible con Info.
Los que estarán instalados con mayor seguridad en un sistema Unix
típico son el lector Info de línea de órdenes, que puede invocarse
así si quiere ir directo a las páginas de CVS

@example
floss$ info cvs
@end example

y el incluido en Emacs, que se invoca escribiendo

@example
M-x info
@end example

o

@example
C-h i
@end example

Tómese el tiempo necesario para conseguir poner a punto el Cederqvist
correctamente en su sistema cuando instale CVS; acortará mucho el
camino cuando tenga que buscar algo.

@c -------------------------
@node Otras fuentes de información
@subsection Otras fuentes de información

Además del Cederqvist, las FAQ, y los demás ficheros de la propia
distribución, hay recursos de Internet dedicados a CVS.  Si va a
administrar un servidor CVS seguramente quiera unirse a la lista de
correo info-cvs.  Para suscribirse envíe un mensaje a
@email{info-cvs-request@@gnu.org} (la lista en sí es
@email{info-cvs@@gnu.org}).  El tráfico puede ser de medio a alto,
de unos 10 a 20 mensajes diarios, casi siempre preguntas buscando
respuestas. La mayoría de ellas pueden borrarse sin leerlas (a no
ser que quiera ayudar a la gente respondiendo a sus preguntas, que
siempre está bien), pero de vez en cuando alguien anuncia el
descubrimiento de un error, o un parche que implementa alguna
característica que usted ha estado esperando.

También puede apuntarse a la lista de correo formal de informes de
errores, que incluye todos los informes de error enviados. Probablemente
no sea necesario, a menos que pretenda ayudar a arreglar los errores,
que sería estupendo, o que sea terriblemente paranoico y quiera estar
enterado de todos los problemas que otros encuentren con CVS. Si quiere
apuntarse, envíe un mensaje a @email{bug-cvs-request@@gnu.org}.

También hay un grupo de noticias de Usenet, @code{comp.software.config-mgmt},
en el que se habla de control de versiones y sistemas de administración
de configuraciones en general, y donde hay mucha discusión acerca de CVS.

Por último, hay al menos tres sitios Web dedicados a CVS.  El de Cyclic
Software @uref{http://www.cyclic.com} ha sido la página principal informal
de CVS durante algunos años, y probablemente lo seguirá siendo en el futuro
próximo.  Cyclic Software también proporciona espacio en el servidor y
acceso por red para el repositorio en el que se guardan las fuentes de CVS.
Las páginas web de Cyclic contienen multitud de enlaces a parches
experimentales para CVS, herramientas de terceros que trabajan con CVS,
documentación, archivos de listas de correo, y todo lo demás.  Si no puede
encontrar lo que necesita en la distribución, @uref{http://www.cyclic.com}
es el lugar para empezar a buscar.

Otros dos buenos sitios son el de Pascal Molli
@uref{http://www.loria.fr/~molli/cvs-index.html} y el de Sean Dreilinger
@uref{http://durak.org/cvswebsites/}.  La mayor atracción del sitio de
Molli la forman, por supuesto, las FAQ, pero también tiene enlaces a
herramientas relacionadas con CVS y archivos de listas de correo.
El sitio de Dreilinger se especializa en información sobre el uso de
CVS para administrar documentos Web y también tiene un motor de búsqueda
específico para CVS.

@c -----------------------------------------------------
@node Iniciando un repositorio
@section Iniciando un repositorio

Una vez que el ejecutable CVS esté instalado en su sistema, podrá empezar
a usarlo en seguida como cliente para acceder a repositorios remotos, siguiendo
los procedimientos descritos en @ref{Una introduccion a CVS}.  Sin embargo,
si quiere servir revisiones desde su máquina, tendrá que crear un repositorio
en ella.  La orden para hacerlo es

@example
floss$ cvs -d /usr/local/nuevorepos init
@end example

donde @file{/usr/local/nuevorepos} es la ruta a donde usted quiera que esté
el repositorio (por supuesto, deberá tener permiso de escritura en ese
directorio, lo que podría implicar ejecutar la orden como root).  En cierto
modo puede parecer poco intuitivo que la localización del repositorio nuevo se
especifique antes de la suborden init en lugar de después de él, pero usando
la opción -d sigue siendo consistente con otras órdenes CVS.

La orden acabará silenciosamente después de ejecutarse.  Vamos a examinar el
nuevo directorio:

@example
floss$ ls -ld /usr/local/nuevorepos
drwxrwxr-x   3 root     root         1024 Jun 19 17:59 /usr/local/nuevorepos/
floss$ cd /usr/local/nuevorepos
floss$ ls
CVSROOT
floss$ cd CVSROOT
floss$ ls
checkoutlist     config,v        history     notify     taginfo,v
checkoutlist,v   cvswrappers     loginfo     notify,v   verifymsg
commitinfo       cvswrappers,v   loginfo,v   rcsinfo    verifymsg,v
commitinfo,v     editinfo        modules     rcsinfo,v
config           editinfo,v      modules,v   taginfo

floss$
@end example

El único subdirectorio del repositorio nuevo -- CVSROOT/ -- contiene
varios ficheros de administración que controlan el comportamiento de CVS.
Más adelante examinaremos esos ficheros uno a uno; por ahora, nuestro
objetivo sólo es conseguir que el repositorio funcione.  En este caso,
"funcionar" significa que los usuarios puedan importar, actualizar,
obtener copias de trabajo y enviar cambios a los proyectos.

No hay que confundir la variable de entorno CVSROOT introducida en @ref{Una
introduccion a CVS} con este subdirectorio CVSROOT del repositorio.  No tienen
nada que ver -- es una coincidencia desafortunada que compartan el mismo
nombre.  La primera es una forma de evitarles a los usuarios tener que teclear
@w{@samp{-d <situación-del-repositorio>}} cada vez que usen CVS; el segundo
es el directorio de administración de un repositorio.

Una vez que el repositorio se haya creado, deberá ocuparse de sus permisos.
CVS no requiere de ningún permiso estándar particular o sistema de propiedad
de ficheros; simplemente necesita acceso de escritura al repositorio.
Sin embargo -- en parte por razones de seguridad, pero sobre todo por su propia
salud como administrador -- recomiendo encarecidamente que siga los siguientes
pasos:

@enumerate

@item
Añada un grupo de Unix @code{cvs} a su sistema.  Cualquier usuario que
necesite acceder al repositorio debería estar en el grupo.  Por ejemplo,
la línea del fichero @file{/etc/group} de mi máquina es:

@example
cvs:*:105:kfogel,sussman,jimb,noel,lefty,fitz,craig,anonymous,jluis
@end example

@item
Haga que la propiedad y permisos del repositorio reflejen este
nuevo grupo:

@example
floss$ cd /usr/local/nuevorepos
floss$ chgrp -R cvs .
floss$ chmod ug+rwx . CVSROOT
@end example

@end enumerate

Ahora cualquiera de los usuarios listados en el grupo podrá empezar un
proyecto ejecutando @w{@code{cvs import}} como se describió en
@ref{Una introduccion a CVS}. Las órdenes "checkout", "update" y "commit"
también deberían funcionar.  También podrán entrar en el repositorio desde
localizaciones remotas usando el método @code{:ext:}, asumiendo
que tienen acceso por rsh o ssh a la máquina del repositorio.
(Se habrá percatado de que las órdenes "chgrp" y "chmod" en el ejemplo de
arriba le dieron acceso de escritura a un usuario llamado @code{anonymous},
que no es lo que uno esperaría.  La razón es que incluso los usuarios
anónimos y de sólo lectura del repositorio necesitan acceso de escritura
a nivel del sistema, para que sus procesos CVS puedan crear ficheros de
bloqueo temporales dentro del repositorio.  CVS no asegura la restricción
de "sólo lectura" del acceso anónimo por medio de permisos de ficheros Unix
sino por otros medios, de lo que se hablará en @ref{Acceso anonimo}.)

Si su repositorio está destinado a servir proyectos al público en general,
en cuyo caso los contribuidores no tendrán necesariamente cuentas en la
máquina del repositorio, debería configurar ahora el servidor de
autentificación de contraseñas
(@pxref{El servidor de autentificacion de contrasen~as}).  Es
necesario para acceso anónimo de sólo lectura, y seguramente sea la
manera más fácil de asegurar acceso al envío de cambios a ciertas personas
sin tener que darles cuentas completas en la máquina.

@c -----------------------------------------------------
@node El servidor de autentificacion de contrasen~as
@section El servidor de autentificacion de contrasen~as

Antes de seguir los pasos necesarios para configurar el servidor de
contraseñas vamos a examinar cómo funcionan este tipo de conexiones en teoría.
Cuando un cliente remoto CVS usa el método @code{:pserver:} para conectarse
a un repositorio, el cliente está contactando en realidad con un número de
puerto específico en la máquina servidora -- en concreto el número de puerto
2401 (que es 49 al cuadrado, si le interesan este tipo de cosas).  El puerto
2401 es el puerto designado por defecto para el servidor pserver de CVS, aunque
se podría configurar para usar un puerto diferente siempre que el cliente
y el servidor estén de acuerdo en ello.

El servidor CVS en realidad no está esperando conexiones a ese puerto
-- el servidor no empezará hasta que realmente llegue una conexión. En vez de
ello, el programa Unix "inetd" (InterNET Daemon) está escuchando en ese puerto,
y necesita saber que cuando reciba una petición de conexión ahi, debería
iniciar el servidor CVS y conectarlo al cliente entrante.

Esto se consigue modificando los ficheros de configuración de inetd:
@file{/etc/services} y @file{/etc/inetd.conf}.  El fichero de servicios
asigna números de puerto a nombres de servicios e inetd.conf le dice a
inetd qué hacer para un nombre de servicio dado.

Primero ponga una línea como ésta en /etc/services (después de asegurarse
de que la línea no existe ya):

@example
cvspserver	2401/tcp
@end example

Luego, escriba esto en /etc/inetd.conf:

@example
cvspserver stream tcp nowait root /usr/local/bin/cvs cvs \
   --allow-root=/usr/local/nuevorepos pserver
@end example

(En el fichero real, esto deberá ser una única línea larga, sin barra
inversa \).  Si su sistema usa una envoltura de TCP ("tcp wrapper", N. del T.),
puede que quiera usar algo como esto en vez de lo anterior:

@example
cvspserver stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/cvs \
   --allow-root=/usr/local/nuevorepos pserver
@end example

Ahora reinicie inetd para que tenga en cuenta los cambios en sus ficheros
de configuración (si no sabe cómo reiniciar el demonio, simplemente reinicie
la máquina -- esto también funcionará).

Esto es suficiente para permitir conexiones, pero también querrá configurar
contraseñas especiales de CVS -- separadas de las contraseñas de login de
los usuarios -- de modo que la gente pueda acceder al repositorio sin
poner en peligro la seguridad general del sistema.

El fichero de contraseñas de CVS es CVSROOT/passwd en el repositorio.
No se creó por defecto cuando ejecutó cvs init, porque CVS no sabe seguro
si usará pserver.  Incluso si el fichero de contraseñas se ha creado, CVS
no tendrá forma de saber los nombres de usuario y contraseñas a crear.
Así que usted tendrá que crear uno por sí mismo; aquí hay una muestra de
fichero CVSROOT/passwd:

@example
kfogel:rKa5jzULzmhOo
anonymous:XR4EZcEs0szik
melissa:tGX1fS8sun6rY:pubcvs
@end example

El formato es tan simple como parece.  Cada línea es:

@c por hacer: ¿quitar los corchetes angulares aquí?
@example
<NOMBREUSUARIO>:<CONTRASEÑA_CIFRADA>:<NOMBREUSUARIO_SISTEMA_OPCIONAL>
@end example

Los dos puntos adicionales seguidos de un nombre de usuario de sistema
opcional le dicen a CVS que las conexiones autentificadas con NOMBREUSUARIO
deberían ejecutarse como la cuenta de sistema NOMBREUSUARIO_SISTEMA  -- en
otras palabras, que la sesión CVS sólo sería capaz de hacer en el repositorio
las cosas que alguien conectado como NOMBREUSUARIO_SISTEMA podría hacer.

Si no se da un nombre de usuario de sistema, NOMBREUSUARIO deberá coincidir
con un nombre de cuenta real del sistema, y la sesión se ejecutará con los
permisos de ese usuario.  En cualquier caso, la contraseña cifrada no debería
ser la misma que la contraseña real de acceso del usuario.  Debería ser
una contraseña independiente usada sólo para conexiones a CVS pserver.

La contraseña se cifra usando el mismo algoritmo que las contraseñas
estándar de Unix, almacenadas en /etc/passwd.  Puede que se pregunte en
este punto, ¿cómo se consigue una versión cifrada de una contraseña?
Para las contraseñas de sistema Unix, la orden passwd se encarga del
cifrado en /etc/passwd por usted.  Por desgracia no hay una orden
equivalente a passwd en cvs (se ha propuesto varias veces, pero nadie
se ha puesto a escribirlo -- ¿lo hará usted. quizá?).

Esto es un inconveniente, pero sólo pequeño.  Si no hay otra opción,
siempre podrá cambiar temporalmente la contraseña de sistema de un
usuario usando passwd, copiar y pegar el texto cifrado de /etc/passwd
en CVSROOT/passwd, y restaurar la antigua contraseña (en ciertos sistemas
las contraseñas cifradas se encuentran en /etc/shadow y sólo el
administrador o root puede leerlas.)

Este proceso es factible pero bastante incómodo.  Sería mucho más fácil
tener una utilidad de línea de órdenes que tomara una contraseña en texto
plano como su argumento y diera como salida la versión cifrada.  Aquí está
esa herramienta, escrita en Perl:

@example
#!/usr/bin/perl

srand (time());
my $randletter = "(int (rand (26)) + (int (rand (1) + .5) % 2 ? 65 : 97))";
my $salt = sprintf ("%c%c", eval $randletter, eval $randletter);
my $plaintext = shift;
my $crypttext = crypt ($plaintext, $salt);

print "$@{crypttext@}\n";
@end example

Yo guardo el guión anterior en @file{/usr/local/bin/cryptout.pl}:

@example
floss$ ls -l /usr/local/bin/cryptout.pl

-rwxr-xr-x   1   root   root   265  Jun 14 20:41 /usr/local/bin/cryptout.pl
floss$ cryptout.pl "some text"
sB3A79YDX5L4s

floss$
@end example

Si usara la salida de este ejemplo para crear la siguiente entrada en
CVSROOT/passwd

@example
jluis:sB3A79YDX5L4s:craig
@end example

entonces la gente podría conectarse al repositorio con la siguiente orden:

@example
remote$ cvs -d :pserver:jluis@@floss.red-bean.com:/usr/local/nuevorepos login
@end example

Escribirían entonces @code{some text} como contraseña y a partir de
entonces podrían ejecutar órdenes CVS con los mismos privilegios de acceso
que el usuario de sistema @code{craig}.

Si alguien intenta autentificarse con un nombre de usuario y contraseña que
no aparecen en CVSROOT/passwd, CVS comprobará si ese nombre de usuario y
contraseña están presentes en /etc/passwd.  Si lo están (y si la contraseña
coincide, por supuesto), CVS proporcionará el acceso.  Se comporta de esta
forma para comodidad del administrador, para no tener que añadir entradas
a CVSROOT/passwd por separado para los usuarios comunes del sistema.
Sin embargo, este comportamiento también es un agujero de seguridad, porque
significa que si uno de esos usuarios se conecta al servidor CVS, su
contraseña de acceso al sistema circulará por la red en texto claro,
potencialmente vulnerable a los ojos de husmeadores de contraseñas.
Un poco más adelante, aprenderá cómo desactivar este comportamiento
"problemático", para que CVS consulte sólo su propio fichero passwd.
Tanto si lo deja activado o desactivado, probablemente debería
obligar a los usuarios de CVS que también tengan cuentas en el sistema a
mantener contraseñas distintas para las dos funciones.

Aunque el fichero passwd autentifica para todo el repositorio, con un poco
de trabajo adicional podrá usarlo incluso para proporcionar acceso
específico de proyecto.  Aquí hay un método:

Suponga que quiere proporcionar acceso a algunos desarrolladores
remotos al proyecto @code{foo}, y a otros acceso al proyecto @code{bar},
y no quiere que los desarrolladores de un proyecto tengan acceso al envío
de cambios al otro.  Puede conseguir esto creando cuentas de usuario y
grupos específicos de proyecto en el sistema y luego referirse a esas
cuentas en el fichero CVSROOT/passwd.

Aquí está el extracto relevante de /etc/passwd en cuestión

@example
cvs-foo:*:600:600:Cuenta Pública CVS para el Proyecto Foo:/usr/local/cvs:/bin/false
cvs-bar:*:601:601:Cuenta Pública CVS para el Proyecto Bar:/usr/local/cvs:/bin/false
@end example

y de /etc/group

@example
cvs-foo:*:600:cvs-foo
cvs-bar:*:601:cvs-bar
@end example

y, finalmente, CVSROOT/passwd:

@example
kcunderh:rKa5jzULzmhOo:cvs-foo
jmankoff:tGX1fS8sun6rY:cvs-foo
brebard:cAXVPNZN6uFH2:cvs-foo
xwang:qp5lsf7nzRzfs:cvs-foo
dstone:JDNNF6HeX/yLw:cvs-bar
twp:glUHEM8KhcbO6:cvs-bar
ffranklin:cG6/6yXbS9BHI:cvs-bar
yyang:YoEqcCeCUq1vQ:cvs-bar
@end example

Algunos de los nombres de usuario de CVS se refieren a las cuentas de
usuario de sistema @code{cvs-foo} y otras a @code{cvs-bar}.  Dado que
CVS se ejecuta bajo la ID de usuario de la cuenta de sistema, simplemente
tendrá que asegurarse de que en las partes de interés del repositorio
sólo pueden escribir los usuarios y grupos adecuados.  Si se asegura de
que las cuentas de usuario de sistema estén bien atadas (sin contraseña de
acceso al sistema válida, con @file{/bin/false} como shell), el sistema será
razonablemente seguro (¡pero mire más adelante en este capítulo acerca de los
permisos CVSROOT!).  Además, CVS registra los cambios e informes de cambios
bajo el nombre de usuario de CVS, no bajo el nombre de usuario de sistema,
así que usted podrá saber quién es responsable de un cambio dado.


@c -----------------------------------------------------
@node Acceso anonimo
@section Acceso anonimo

Hasta ahora sólo hemos visto cómo usar el servidor de autentificación
de contraseñas para dar acceso total al repositorio (aunque es cierto que
se puede restringir ese acceso mediante permisos de fichero Unix cuidadosamente
elegidos).  Pasar a acceso anónimo y de sólo lectura es un paso simple:
sólo hay que añadir un nuevo fichero, o quizá dos, en CVSROOT/.  Los nombres
de los ficheros son @code{readers} y @code{writers} -- el primero contiene
una lista de nombres de usuario que pueden leer el repositorio solamente, y el
segundo los usuarios que pueden leer y escribir.

Si lista un nombre de usuario en CVSROOT/readers, ese usuario tendrá acceso
de sólo lectura a todos los proyectos del repositorio.  Si lista un nombre de
usuario en CVSROOT/writers, ese usuario tendrá acceso a escritura, y todos
los usuarios de pserver que no estén listados en writers tendrán acceso de
sólo lectura (es decir, si el fichero writers existe, implica acceso de sólo
lectura para todos los que no estén listados en él).  Si el mismo nombre de
usuario se encuentra listado en los dos ficheros, CVS resuelve el conflicto
del modo más conservador: el usuario tendrá acceso de sólo lectura.

El formato de los ficheros es muy simple: un usuario por línea (no olvide
poner una nueva línea en blanco después del último usuario).  Un fichero
readers de muestra sería:

@example
anonymous
splotnik
guest
jbrowse
@end example

Hay que notar que los ficheros se refieren a nombres de usuario de CVS, no
de sistema.  Si usa alias de usuario en el fichero CVSROOT/passwd (poniendo
un nombre de usuario de sistema después de los segundos dos puntos), el
nombre de usuario más a la izquierda es el que hay que listar en el fichero
readers o writers.

Para ser preciso, hay una descripción formal del comportamiento del servidor
para decidir si dar acceso de sólo lectura o de lectura y escritura:

Si existe un fichero readers y este usuario está listado en él, se le
dará acceso de sólo lectura.  Si existe un fichero writers y este usuario
no está listado en él, se le dará también acceso de sólo lectura (esto
es cierto incluso si existe un fichero readers pero esa persona no está
listada en él).  Si esa persona está listada en ambos, se le dará acceso
de sólo lectura.  En todos los demás casos, a esa persona se le dará
acceso completo de lectura y escritura.

Así, un repositorio típico con acceso a CVS anónimo tendrá esto (o algo
parecido) en CVSROOT/passwd

@example
anonymous:XR4EZcEs0szik
@end example

esto (o algo parecido) en /etc/passwd

@example
anonymous:!:1729:105:Usuario CVS Anónimo:/usr/local/nuevorepos:/bin/false
@end example

y esto en CVSROOT/readers:

@example
anonymous
@end example

Y, por supuesto, la configuración mencionada anteriormente en /etc/services
y /etc/inetd.conf.  ¡Y eso es todo!

Hay que remarcar que algunos sistemas Unix antiguos no permiten nombres de
usuario mayores de ocho caracteres.  Una forma de arreglar esto sería llamar
al usuario @code{anon} en lugar de @code{anonymous} en CVSROOT/passwd y
los ficheros de sistema, porque la gente asume a menudo que anon es una
abreviatura de anonymous de todas formas.  Pero sería mejor poner algo
como esto en el fichero CVSROOT/passwd

@example
anonymous:XR4EZcEs0szik:cvsanon
@end example

(y luego, por supuesto, usar @code{cvsanon} en los ficheros de sistema).
De este modo será capaz de publicar una dirección de repositorio que use
@code{anonymous}, que es más o menos el estándar ahora.  La gente
que acceda al repositorio con

@example
cvs -d :pserver:anonymous@@cvs.foobar.com:/usr/local/nuevorepos (etc...)
@end example

realmente ejecutarían en el servidor como cvsanon (o lo que sea).  Pero
no necesitarían conocer o preocuparse de cómo están configuradas las cosas
en el lado del servidor -- sólo verían la dirección publicada.

@c -----------------------------------------------------
@node Estructura del repositorio
@section Estructura del repositorio

El nuevo repositorio aún no tiene proyectos en él.  Vamos a volver a
ejecutar la importación inicial de @ref{Una introduccion a CVS},
observando lo que le ocurre al repositorio.  (Por simplicidad, todos
las órdenes asumen que la variable de entorno CVSROOT tiene el valor
/usr/local/nuevorepos, así que no hay necesidad de especificar el
repositorio con -d en importaciones y comprobaciones.)

@example
floss$ ls /usr/local/nuevorepos
CVSROOT/
floss$ pwd
/home/jluis/src/
floss$ ls
miproyecto/
floss$ cd miproyecto
floss$ cvs import -m "importación inicial a CVS" miproyecto jluis start
N miproyecto/README.txt
N miproyecto/hello.c
cvs import: Importing /usr/local/nuevorepos/miproyecto/a-subdir
N miproyecto/a-subdir/loquesea.c
cvs import: Importing /usr/local/nuevorepos/miproyecto/a-subdir/subsubdir
N miproyecto/a-subdir/subsubdir/fish.c
cvs import: Importing /usr/local/nuevorepos/miproyecto/b-subdir
N miproyecto/b-subdir/random.c

No conflicts created by this import

floss$ ls /usr/local/nuevorepos
CVSROOT/  miproyecto/
floss$ cd /usr/local/nuevorepos/miproyecto
floss$ ls
README.txt,v  a-subdir/     b-subdir/	  hello.c,v
floss$ cd a-subdir
floss$ ls
subsubdir/    loquesea.c,v
floss$ cd ..

floss$
@end example

Antes de importar, el repositorio contenía sólo su área de administración,
CVSROOT.  Después de la importación ha aparecido un nuevo directorio
-- @file{miproyecto} --.  Los ficheros y subdirectorios existentes en ese
nuevo directorio se parecen sospechosamente a los del proyecto que hemos
importado, excepto que los ficheros tienen el sufijo @code{,v}.  Éstos son
ficheros de control de versión en formato RCS (la @code{,v} quiere decir
"versión"), y son el esqueleto del repositorio.  Cada fichero RCS almacena
la historia de revisiones de su correspondiente fichero del proyecto,
incluyendo todas las ramas y marcas.

@c -----------------------------------------------------
@node Formato RCS
@section Formato RCS

No necesita conocer nada del formato RCS para usar CVS (aunque hay un
escrito excelente incluido en la distribución fuente, vea doc/RCSFILES).
Sin embargo, una comprensión básica del formato puede ser de inmensa
ayuda para resolver problemas con CVS, así que echaremos un pequeño vistazo
a uno de los ficheros, @file{hello.c,v}.  Aquí está su contenido:

@example
head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 jluis:1.1.1;
locks    ; strict;
comment  @@ * @@;

1.1
date     99.06.20.17.47.26;  author jluis;  state Exp;
branches 1.1.1.1;
next;

1.1.1.1
date     99.06.20.17.47.26;  author jluis;  state Exp;
branches ;
next;

desc
@@@@

1.1
log
@@Initial revision
@@
text
@@#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
@}
@@

1.1.1.1
log
@@importación inicial a CVS
@@
text
@@@@
@end example

¡Uff!  La mayoría de esto se puede ignorar; no hace falta que se preocupe
de la relación entre 1.1 y 1.1.1.1, por ejemplo, o de la rama implicada 1.1.1
-- en realidad no son significativas, desde un punto de vista del usuario o
incluso del administrador.  Lo que debería comprender es el formato en general.
Al comienzo hay una colección de cabeceras:

@example
head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 jluis:1.1.1;
locks    ; strict;
comment  @@ * @@;
@end example

Más abajo hay grupos de metainformación sobre cada revisión (pero aún sin
mostrar el contenido de esa revisión), como:

@example
1.1
date     99.06.20.17.47.26;  author jluis;  state Exp;
branches 1.1.1.1;
next     ;
@end example

Y finalmente, el informe de cambios ("log message", N. del T.) y texto de una
revisión real:

@example
1.1
log
@@Initial revision
@@
text
@@#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
@}
@@

1.1.1.1
log
@@importación inicial a CVS
@@
text
@@@@
@end example

Si lo mira de cerca verá que el contenido de la primera revisión se
guarda bajo la cabecera 1.1, pero en ella el informe de cambios es "Initial
revision", mientras que el mensaje que usamos en realidad a la hora de
importar fue "importación inicial a CVS".  No es necesario que se preocupe
por esta discrepancia ahora.  Ocurre porque las importaciones son
circunstancias especiales: para que importaciones repetidas en el
mismo proyecto tengan un efecto útil, la importación en realidad coloca
la revisión inicial en el tronco principal y en una rama especial (las
razones para ello se aclararán cuando veamos derivaciones comerciales
en @ref{CVS avanzado}).  Por ahora puede tratar @code{1.1} y
@code{1.1.1.1} como la misma cosa.

El fichero se vuelve aún más revelador después de que enviemos con commit
la primera modificación a hello.c:

@example
floss$ cvs -Q co miproyecto
floss$ cd miproyecto
floss$ emacs hello.c
    (haga algunos cambios al fichero)

floss$ cvs ci -m "ahora también dice adiós"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in hello.c;
/usr/local/nuevorepos/miproyecto/hello.c,v  <--  hello.c
new revision: 1.2; previous revision: 1.1
done
@end example

Si mira en el repositorio a hello.c,v verá el efecto del envío de cambios:

@example
head  1.2;
access;
symbols
      start:1.1.1.1 jluis:1.1.1;
locks; strict;
comment   @@ * @@;

1.2
date   99.06.21.01.49.40;   author jluis;   state Exp;
branches;
next   1.1;

1.1
date   99.06.20.17.47.26;   author jluis;   state Exp;
branches
       1.1.1.1;
next   ;

1.1.1.1
date   99.06.20.17.47.26;   author jluis;   state Exp;
branches;
next   ;

desc
@@@@

1.2
log
@@ahora también dice adiós
@@
text
@@#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("¡Adiós, mundo!\n");
@}
@@

1.1
log
@@Initial revision
@@
text
@@d7 1
@@

1.1.1.1
log
@@importación inicial a CVS
@@
text
@@@@
@end example

Ahora el contenido completo de la revisión 1.2 está guardado en el fichero,
y el texto para la revisión 1.1 ha sido reemplazado por la fórmula críptica:

@example
d7 1
@end example

El @w{@code{d7 1}} es un código diff que quiere decir "empezando en la línea 7,
borrar 1 línea".  En otras palabras, ¡para obtener la Revisión 1.1, borre la
línea 7 de la Revisión 1.2!  Pruébelo usted mismo.  Verá que de hecho produce
la Revisión 1.1 -- simplemente se deshace de la línea que añadimos al fichero.

Esto demuestra el principio básico del formato RCS: Almacena sólo las
diferencias entre revisiones, ahorrando con ello un montón de espacio comparado
con guardar cada revisión entera.  Para volver desde la última revisión a la
anterior, parchea la última revisión usando el diff almacenado.  Por supuesto,
esto significa que cuanto más hacia atrás viaje en la historia de revisiones,
habrá que realizar más operaciones de parcheo (por ejemplo, si el fichero está
en la Revisión 1.7 y a CVS se le pide que muestre la Revisión 1.4, tendrá que
producir la 1.6 parcheando hacia atrás la 1.7, luego la 1.5 parcheando la 1.6,
y finalmente la 1.4 parcheando la 1.5).  Por suerte, las revisiones antiguas
son además las menos solicitadas, así que el sistema RCS funciona bastante bien
en la práctica: Cuanto más reciente sea una revisión, más "barata" es de
obtener.

En cuanto a la información de cabecera al principio del fichero, no necesita
saber lo que significa todo ello.  Sin embargo, los efectos de ciertas
operaciones se muestran muy claramente en las cabeceras, y una pequeña
familiaridad con ellas puede resultar útil.

Cuando envía cambios de una nueva revisión al tronco, la etiqueta @code{head}
se actualiza (note cómo cambió a 1.2 en el ejemplo anterior, cuando se envió el
cambio de la segunda revisión a hello.c).  Cuando añade un fichero como binario
o lo marca, esas operaciones se registran también en las cabeceras.  Como
ejemplo, vamos a añadir foo.jpg como fichero binario para después marcarlo
un par de veces:

@example
floss$ cvs add -kb foo.jpg
cvs add: scheduling file 'foo.jpg' for addition
cvs add: use 'cvs commit' to add this file permanently
floss$ cvs -q commit -m "añadida una imagen aleatoria; pregunte a \
   jluis@@red-bean.com el motivo"
RCS file: /usr/local/nuevorepos/miproyecto/foo.jpg,v
done
Checking in foo.jpg;
/usr/local/nuevorepos/miproyecto/foo.jpg,v  <--  foo.jpg
initial revision: 1.1
done
floss$ cvs tag alguna_marca_aleatoria foo.jpg
T foo.jpg
floss$ cvs tag OTRA-MARCA foo.jpg
T foo.jpg
floss$
@end example

Examine ahora la sección "header" de foo.jpg,v en el repositorio:

@example
head   1.1;
access;
symbols
      OTRA-MARCA:1.1
      alguna_marca_aleatoria:1.1;
locks; strict;
comment   @@# @@;
expand	@@b@@;
@end example

Fíjese en la b en la línea "expand" del final -- se debe a haber usado el
parámetro -kb al añadir el fichero, y quiere decir que el fichero no
sufrirá expansiones de palabra clave o nueva línea, que ocurrirían
normalmente durante obtenciones de copia y actualizaciones si fuera un fichero
de texto normal.  Las marcas aparecen en la sección "symbols", una por línea
-- ambas están asociadas a la primera revisión, puesto que eso es lo que se
marcó ambas veces.  (Esto también ayuda a explicar por qué los nombres de
marca pueden sólo contener letras, números, guiones y guiones bajos.  Si la
propia marca contuviera puntos o comas, su registro RCS podría ser ambiguo,
porque no habría forma de encontrar el enlace textual entre la marca y la
revisión a la que está asociada.)

@c -----------------------------------------------------
@heading El formato RCS siempre va entre signos @@

El símbolo @code{@@} se usa como delimitador de campos en los ficheros RCS, lo
que significa que si aparece alguno en el texto de un fichero o en un informe
de cambios, deberá estar comentado (de lo contrario, CVS interpretaría
incorrectamente que está marcando el final de ese campo).  Se comenta
poniéndolo doble -- es decir, CVS siempre interpreta @code{@@@@} como un
"signo @@ literal", nunca como un "fin de campo actual".  Cuando enviamos los
cambios a foo.jpg, el informe de cambios fue

@example
"añadida una imagen aleatoria; pregunte a jluis@@red-bean.com el motivo"
@end example

que se almacena en foo.jpg,v así:

@example
1.1
log
@@añadida una imagen aleatoria; pregunte a jluis@@@@red-bean.com el motivo
@@
@end example

El signo @@ en jluis@@@@red-bean.com se descomentará automáticamente
cada vez que CVS obtenga el informe de cambios:

@example
floss$ cvs log foo.jpg
RCS file: /usr/local/nuevorepos/miproyecto/foo.jpg,v
Working file: foo.jpg
head: 1.1
branch: 
locks: strict
access list: 
symbolic names: 
      OTRA-MARCA: 1.1
      alguna_marca_aleatoria: 1.1
keyword substitution: b
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1.1
date: 1999/06/21 02:56:18;  author: jluis;  state: Exp; 
añadida una imagen aleatoria: pregunte a jluis@@red-bean.com el motivo
============================================================================

floss$ 
@end example

El único motivo por el que debería preocuparse es por si alguna vez tiene
que editar a mano ficheros RCS (una circunstancia rara, aunque le ha pasado
a más de uno) Debe acordarse entonces de usar signos dobles @@ en contenidos
de la revisión e informes de cambios.  Si no lo hace, el fichero RCS estará
corrupto y probablemente tendrá un comportamiento extraño e indeseable.

Hablando de editar a mano ficheros RCS, no se deje engañar por los
permisos en el repositorio:

@example
floss$ ls -l
total 6
-r--r--r--   1 jluis   users         410 Jun 20 12:47 README.txt,v
drwxrwxr-x   3 jluis   users        1024 Jun 20 21:56 a-subdir/
drwxrwxr-x   2 jluis   users        1024 Jun 20 21:56 b-subdir/
-r--r--r--   1 jluis   users         937 Jun 20 21:56 foo.jpg,v
-r--r--r--   1 jluis   users         564 Jun 20 21:11 hello.c,v

floss$ 
@end example

(Para los que no estén familiarizados con la salida de "ls" en Unix, las
líneas @code{-r--r--r--} de la izquierda básicamente quieren decir que los
ficheros se pueden leer pero no cambiar.)  Aunque los ficheros parecen ser
de sólo lectura para todos, también hay que tener en cuenta los permisos
de directorio:

@example
floss$ ls -ld . 
drwxrwxr-x   4 jluis   users        1024 Jun 20 22:16 ./ 
floss$
@end example

El propio directorio miproyecto/ -- y sus subdirectorios -- es accesible para
escritura por el propietario (jluis) y el grupo (users).  Esto significa
que CVS (ejecutándose como jluis o como cualquiera del grupo users) puede
crear y borrar ficheros en esos directorios, incluso si no puede editar
directamente los ficheros a presentes.  CVS edita un fichero RCS haciendo
una copia separada de él, de forma que usted haga todos sus cambios en una
copia temporal, y luego reemplaza el fichero RCS existente con el nuevo.
(Pero por favor, no pregunte por qué los ficheros son de sólo lectura -- hay
razones históricas para ello, relacionadas con la forma en que RCS trabaja
cuando se ejecuta como programa en solitario.)

Por cierto, puede que usted no desee que el grupo de los ficheros sea
@code{users}, considerando que el directorio raíz del repositorio se le
asignó explícitamente el grupo @code{cvs}.  Puede corregir el problema
ejecutando esta orden dentro del repositorio:

@example
floss$ cd /usr/local/nuevorepos
floss$ chgrp -R cvs miproyecto
@end example

Las reglas habituales Unix de creación de ficheros rigen qué grupo se
asigna a los nuevos ficheros que aparecen en el repositorio, así que
de vez en cuando puede que necesite ejecutar "chgrp" o "chmod" en ciertos
ficheros o directorios del repositorio (ajustar el bit SGID con
@w{@code{chmod g+s}} es a menudo una buena estrategia: hace que los hijos
de un directorio hereden el grupo propietario del directorio, que por lo
general es lo que quiere que pase en el repositorio).  No hay reglas
rápidas acerca de cómo debería estructurar los permisos del repositorio;
depende de quién esté trabajando en qué proyectos.

@c -----------------------------------------------------
@node Qué ocurre cuando elimina un fichero
@section Qué ocurre cuando elimina un fichero

Cuando elimina un fichero de un proyecto, no desaparece simplemente.  CVS
debe ser capaz de recuperar esos ficheros cuando solicite una revisión
antigua del proyecto.  En lugar de ello, el fichero se pone en el
@code{Attic}, ático literalmente:

@example
floss$ pwd
/home/jluis/src/miproyecto
floss$ ls /usr/local/nuevorepos/miproyecto/
README.txt,v  a-subdir/     b-subdir/     foo.jpg,v   hello.c,v
floss$ rm foo.jpg
floss$ cvs rm foo.jpg
cvs remove: scheduling 'foo.jpg' for removal
cvs remove: use 'cvs commit' to remove this file permanently
floss$ cvs ci -m "Eliminado foo.jpg" foo.jpg
Removing foo.jpg; 
/usr/local/nuevorepos/miproyecto/foo.jpg,v  <--  foo.jpg
new revision: delete; previous revision: 1.1
done
floss$ cd /usr/local/nuevorepos/miproyecto/
floss$ ls
Attic/      README.txt,v  a-subdir/     b-subdir/   hello.c,v
floss$ cd Attic
floss$ ls
foo.jpg,v
floss$
@end example

En cada directorio del repositorio de un proyecto, la presencia de un
subdirectorio @file{Attic/} indica que se ha borrado al menos un fichero
de ese directorio (esto quiere decir que no debería usar directorios llamados
Attic en sus proyectos).  Sin embargo, CVS no mueve simplemente el fichero
RCS a Attic/; además envía el cambio con una nueva revisión al fichero, con
un estado especial de revisión de @code{dead}, muerto.  Aquí está la sección
de interés de Attic/foo.jpg,v:

@example
1.2
date   99.06.21.03.38.07;   author jluis;   state dead; 
branches; 
next	1.1; 
@end example

Si el fichero se vuelve a traer de nuevo a la vida, CVS tiene una forma
de registrar que estaba muerto en algún punto del pasado y que ahora está
vivo otra vez.

Esto quiere decir que si quiere restaurar un fichero eliminado, no puede
sacarlo del Attic/ simplemente y ponerlo de nuevo en el proyecto.  En lugar
de ello, tiene que hacer algo como lo siguiente con una copia de trabajo:

@example
floss$ pwd
/home/jluis/src/miproyecto
floss$ cvs -Q update -p -r 1.1 foo.jpg > foo.jpg
floss$ ls
CVS/       README.txt   a-subdir/   b-subdir/   foo.jpg     hello.c
floss$ cvs add -kb foo.jpg
cvs add: re-adding file foo.jpg (in place of dead revision 1.2) 
cvs add: use 'cvs commit' to add this file permanently
floss$ cvs ci -m "revivida imagen jpg" foo.jpg
Checking in foo.jpg; 
/usr/local/nuevorepos/miproyecto/foo.jpg,v  <-- foo.jpg
new revision: 1.3; previous revision: 1.2
done
floss$ cd /usr/local/nuevorepos/miproyecto/
floss$ ls
Attic/	      a-subdir/     foo.jpg,v
README.txt,v  b-subdir/     hello.c,v
floss$ ls Attic/
floss$ 
@end example

Queda mucho más por saber del formato RCS, pero esto es suficiente para
que un administrador de CVS mantenga un repositorio.  Es bastante raro
que realmente haya que editar un fichero RCS; normalmente sólo tendrá
que ajustar permisos de ficheros en el repositorio, al menos si mi propia
experiencia sirve de guía.  Sin embargo, cundo CVS empieze a comportarse
de forma realmente extraña (raro, pero no completamente fuera de lo
posible), puede que quiera mirar dentro de los ficheros RCS para averiguar
qué está pasando.

@c -----------------------------------------------------
@node El directorio administrativo CVSROOT/
@section El directorio administrativo CVSROOT/

Los ficheros de nuevorepos/CVSROOT/ no son parte de ningún proyecto, sino
que se usan para controlar el comportamiento de CVS en el repositorio.
La mejor forma de editar esos ficheros es obtener una copia de trabajo de
CVSROOT con "checkout", igual que para un proyecto normal:

@example
floss$ cvs co CVSROOT
cvs checkout: Updating CVSROOT
U CVSROOT/checkoutlist
U CVSROOT/commitinfo
U CVSROOT/config
U CVSROOT/cvswrappers
U CVSROOT/editinfo
U CVSROOT/loginfo
U CVSROOT/modules
U CVSROOT/notify
U CVSROOT/rcsinfo
U CVSROOT/taginfo
U CVSROOT/verifymsg
floss$ 
@end example

Miraremos los ficheros en order aproximado de importancia.  Fíjese en
que cada uno de los ficheros viene con un comentario explicativo al
comienzo (el convenio para comentarios es el mismo para todos ellos: un
signo @code{#} al principio de la línea indica un comentario, y CVS
ignora estas líneas cuando procesa los ficheros).  Recuerde que cualquier
cambio que haga a los ficheros de administración de la copia de trabajo
obtenida no afectará al comportamiento de CVS hasta que envíe los cambios.

Si usted es extremadamente consciente de la seguridad, puede que quiera
configurar los permisos de fichero en CVSROOT para que sean diferentes de
los permisos en cualquier parte del repositorio, para tener bien controlado
quién puede enviar cambios a CVSROOT.  Como verá un poco más adelante, el
ser capaz de modificar los ficheros de CVSROOT básicamente le da a cualquier
usuario CVS -- incluso a los remotos -- la capacidad de ejecutar cualquier
orden en la máquina del repositorio.

@menu
* El Fichero config::
* El Fichero modules::
* Los Ficheros commitinfo y loginfo y rcsinfo::
* Los Ficheros verifymsg y rcsinfo::
* El Fichero taginfo::
* El Fichero cvswrappers::
* El Fichero editinfo::
* El Fichero notify::
* El Fichero checkoutlist::
@end menu

@c --------------------------------------
@node El Fichero config
@subsection El Fichero config
@cindex config file

El fichero @dfn{config} le permite configurar ciertos parámetros de
comportamiento global.  Sigue un formato muy estricto

@example
PARÁMETRO=VALOR
(etc) 
@end example

sin permitirse espacios adicionales.  Por ejemplo, aquí hay un posible fichero
config:

@example
SystemAuth=yes
TopLevelAdmin=no
PreservePermissions=no
@end example

(Una entrada ausente equivaldría a @code{no}.)

El parámetro @code{SystemAuth} controla si CVS debería mirar en el fichero
de sistema passwd si falla al encontrar un determinado nombre de usuario en
el fichero CVSROOT/passwd.  Las distribuciones de CVS vienen con él puesto a
@code{no} para ser conservadoras en cuanto a la seguridad del sistema.

@code{TopLevelAdmin} le dice a CVS si hacer un directorio CVS/ hermano
cuando obtiene una copia de trabajo.  Este directorio CVS/ podría no estar
dentro de la copia de trabajo, sino junto a ella.  Sería conveniente
habilitarlo si usted tiende (y los usuarios del repositorio tienden) a obtener
copias de muchos proyectos diferentes en el mismo repositorio.  De lo contrario
debería dejarlo desactivado, ya que puede ser desconcertante ver que aparece
un directorio CVS/ adicional donde no lo espera.

@code{PreservePermissions} controla si se conservan los permisos de
fichero y otra metainformación en la historia de revisiones.  Ésta es
una característica algo oscura que seguramente no valga la pena describir
en detalle.  Si está interesado vea el nodo @cite{Special Files} en el
Cederqvist (@dfn{nodo} es una palabra de Texinfo para una posición
particular en un documento Info.  Para ir a un nodo mientras se lee Info,
teclee @kbd{g} seguido del nombre del nodo, desde cualquier parte del
documento).

@code{LockDir} también es una característica usada raramente.  En
circunstancias especiales, querrá decirle a CVS que cree sus ficheros de
bloqueo en algún sitio distinto de los subdirectorios del proyecto, para evitar
problemas de permisos.  Estos ficheros de bloqueo impiden que CVS tropiece
consigo mismo al realizar múltiples operaciones en el mismo directorio del
repositorio a la vez.  En general, nunca tendrá que preocuparse por ello, pero
a veces puede que los usuarios tengan problemas actualizando u obteniendo
copias de trabajo desde un directorio del repositorio porque son incapaces de
crear un fichero de bloqueo (CVS necesita crear un fichero de bloqueo, incluso
en operaciones de sólo lectura, para evitar situaciones en las que podría
acabar leyendo mientras otra invocación de CVS está escribiendo).  El remedio
habitual para esto es cambiar los permisos del repositorio, pero cuando esto
no es factible, el parámetro LockDir puede resultar práctico.

No hay más parámetros por el momento, pero puede que en versiones futuras de
CVS se añadan otros nuevos; debería comprobar siempre el Cederqvist o el propio
fichero config de la distribución para ver los cambios.
@c por hacer: ¡o el fichero NEWS!

@c ----------------------------
@node El Fichero modules
@subsection El Fichero modules
@cindex modules file

En modules puede definir aliases y grupos alternativos de proyectos en el
repositorio.  La línea de module más básica es de la forma:

@example
NOMBRE_MÓDULO   DIRECTORIO_EN_REPOSITORIO
@end example

por ejemplo,

@example
mp    miproyecto
asub  miproyecto/a-subdir
@end example

(Las rutas dadas a la derecha son relativas al directorio raíz del repositorio.)
Esto les da a los desarrolladores un nombre alternativo con el que obtener una
copia de un proyecto o parte de un proyecto:

@example
floss$ cvs co mp
cvs checkout: Updating mp
U mp/README.txt
U mp/foo.jpg
U mp/hello.c
cvs checkout: Updating mp/a-subdir
U mp/a-subdir/loquesea.c
cvs checkout: Updating mp/a-subdir/subsubdir
U mp/a-subdir/subsubdir/fish.c
cvs checkout: Updating mp/b-subdir
U mp/b-subdir/random.c
@end example

o

@example
floss$ cvs -d /usr/local/nuevorepos/ co asub
cvs checkout: Updating asub
U asub/loquesea.c
cvs checkout: Updating asub/subsubdir
U asub/subsubdir/fish.c
@end example

Note cómo en ambos casos el nombre del módulo pasó a ser el nombre del
directorio creado para la copia de trabajo.  En el caso de asub, ni siquiera
se preocupó del directorio intermedio miproyecto/, sino que en lugar de ello
creó un asub/ en un nivel superior, aunque venía de miproyecto/a-subdir en el
repositorio.  Las actualizaciones, envíos de cambios y todos las órdenes CVS
funcionarán normalmente en esas copias de trabajo -- lo único raro que tienen
son sus nombres.

Poniendo nombres de ficheros después del nombre de directorio podrá definir
un módulo consistente sólo en algunos de los ficheros de un directorio del
repositorio dado. Por ejemplo

@example
readme  miproyecto  README.txt
@end example

y

@example
no-readme  miproyecto  hello.c  foo.jpg
@end example

permitirían las siguientes obtenciones de copia respectivamente:

@example
floss$ cvs -q co readme
U readme/README.txt
floss$ cvs -q co no-readme
U no-readme/hello.c
U no-readme/foo.jpg
floss$
@end example

Puede definir un módulo que incluya múltiples directorios de repositorio
usando la opción -a (para @code{alias}), pero fíjese en que se investigarán
los directorios bajo sus nombres originales.  Por ejemplo, esta línea

@example
dosproyectos  -a  miproyecto  tuproyecto
@end example

le permitiría hacer esto (asumiendo que tanto miproyecto/ como tuproyecto/
están en el repositorio):

@example
floss$ cvs co dosproyectos
U miproyecto/README.txt
U miproyecto/foo.jpg
U miproyecto/hello.c
U miproyecto/a-subdir/loquesea.c
U miproyecto/a-subdir/subsubdir/fish.c
U miproyecto/b-subdir/random.c
U tuproyecto/README
U tuproyecto/foo.c
U tuproyecto/un-subdir/fichero1.c
U tuproyecto/un-subdir/fichero2.c
U tuproyecto/un-subdir/otro-subdir/bla.c
@end example

El nombre @code{dosproyectos} es un recurso conveniente para meterse en los
dos proyectos, pero no afecta a los nombres de las copias de trabajo.
(Por cierto, no hay necesidad de que los módulos alias se refieran a
múltiples directorios; podríamos haber omitido dosproyectos, en cuyo caso aún
se habría obtenido una copia de miproyecto bajo el nombre @code{miproyecto}.)

Los módulos pueden incluso referirse a otros módulos, poniéndoles como
prefijo un signo &:

@example
mp    miproyecto
asub  miproyecto/a-subdir
dosproyectos -a miproyecto tuproyecto
dp  &dosproyectos
@end example

Hacer un checkout de @code{dp} tendría exactamente el mismo resultado que
el de @code{dosproyectos}.

Hay algunos otros trucos que puede hacer con módulos, la mayoría de ellos
más infrecuentes que los que se acaban de presentar.  Vea el nodo modules
en el Cederqvist para obtener información sobre ellos.

@c ----------------------------------------------------------
@node Los Ficheros commitinfo y loginfo y rcsinfo
@subsection Los Ficheros commitinfo y loginfo y rcsinfo

La mayoría de los demás ficheros de administración proporcionan
@dfn{puntos de comtrol} ("hooks", N. del T.) programáticos en varias partes
del proceso de envío de cambios (por ejemplo, la capacidad de validar informes
de cambios o estados de fichero antes de permitir el envío, o la capacidad de
notificar a un grupo de desarrolladores cada vez que se haga un envío en cierto
directorio del repositorio).

Por lo general, los ficheros comparten una sintaxis común.  Cada línea es
de la forma:

@example
EXPRESIÓN_REGULAR    PROGRAMA_A_EJECUTAR
@end example

La expresión regular se probará con el directorio en el que se está haciendo
el envío (con el nombre de directorio relativo al nivel más alto del
repositorio).  Si coincide se ejecutará el programa designado.  Al programa
se le pasarán los nombres de cada uno de los ficheros del envío; puede
hacer lo que le parezca con esos nombres, incluso abrir los ficheros y
examinar sus contenidos.  Si el programa devuelve un estado de salida
distinto de cero, se impide que se haga el envío.

Las (@dfn{expresiones regulares} son un sistema para describir de forma concisa
clases de cadenas.  Si no está familiarizado con las expresiones regulares,
puede hacerlo con el siguiente resumen: @code{foo} coincidiría con todos los
ficheros con nombres conteniendo @code{foo}; y @code{foo.*bar} coincidiría con
todos los ficheros con nombres conteniendo @code{foo}, seguido de cualquier
número de caracteres, y seguido por la cadena @code{bar}.  Es por ello que las
subcadenas normales coinciden consigo mismas, pero @code{.} y @code{*} son
especiales.  @code{.} coincide con cualquier caracter, y @code{*} quiere decir
"coincide con cualquier número de veces, incluyendo cero, del caracter
precedente".  Los signos @code{^} y @code{$} indican "encuentra al principio y
final de la cadena", respectivamente; por tanto, @code{^foo.*bar.*baz$}
encontraría las cadenas que comenzaran con @code{foo}, que contuvieran
@code{bar} en medio, y que acabaran con @code{baz}.  Esto es todo lo que vamos
a profundizar; este resumen es una pequeña parte muy abreviada de la sintaxis
completa de las expresiones regulares.)

@cindex commitinfo
El fichero @dfn{commitinfo} está para puntos de control genéricos que quiera
ejecutar en todos los envíos.  Aquí hay algunas líneas commitinfo de ejemplo:

@example
^a-subdir*     /usr/local/bin/comprobar-asubdir.sh
ou             /usr/local/bin/validar-proyecto.pl
@end example

Así que cualquier envío en miproyecto/a-subdir/ coincidiría con la primera
línea, por lo que se ejecutaría el guión comprobar-asubdir.sh.  Un envío en
cualquier proyecto cuyo nombre (nombre real de directorio del repositorio,
no necesariamente nombre del módulo) contenga la cadena @code{ou} ejecutaría
el guión validar-proyecto.pl, a menos que el envío ya haya coincidido
con la línea a-subdir anterior.

En lugar de una expresión regular se puede usar la palabra @code{DEFAULT}
o @code{ALL}.  La línea DEFAULT (o la primera línea DEFAULT si hay más de
una) se ejecutará si no coincide ninguna expresión regular, y cada una de
las líneas ALL se ejecutará además de todas las líneas que puedan coincidir.

Los nombres de ficheros que se pasan al programa no se refieren a ficheros
RCS -- hacen referencia a ficheros normales, cuyos contenidos son exactamente
los mismos que los de la copia de trabajo de la que se están enviando cambios.
El único aspecto inusual es que CVS los tiene guardados temporalmente dentro
del repositorio, así que estarán disponibles para los programas que se estén
ejecutando en la máquina en la que está el repositorio.

@cindex loginfo
El fichero @dfn{loginfo} es similar a commitinfo, excepto en que en lugar
de actuar en los contenidos de los ficheros, actúa en los informes de cambios.
El lado izquierdo del fichero loginfo contiene expresiones regulares, quizá
incluyendo líneas DEFAULT y ALL.  El programa invocado a la derecha recibe
el informe de cambios en su entrada estándar; puede hacer lo que quiera con esa
entrada.

El programa de la derecha también puede admitir un número arbitrario de
argumentos de línea de órdenes.  Uno de esos argumentos puede ser un código
especial @code{%}, a expandir por CVS en tiempo de ejecución como sigue:

@example
%s    ------>      nombre(s) de fichero(s) afectados por el envío de cambios
%V    ------>      número(s) de revisión antes del envío de cambios
%v    ------>      número(s) de revisión después del envío de cambios
@end example

La expansión empieza siempre con el subdirectorio del repositorio (relativo
al nivel superior del repositorio), seguido de la información del fichero.
Por ejemplo, si los ficheros afectados por el envío de cambios fueran foo, bar
y baz, todos en @file{miproyecto/a-subdir}, @code{%s} se expandiría en:

@example
miproyecto/a-subdir  foo  bar  baz
@end example

mientras que @code{%V} se expandiría para mostrar los números de revisión
antiguos:

@example
miproyecto/a-subdir  1.7  1.134  1.12
@end example

y @code{%v} los números de revisión nuevos:

@example
miproyecto/a-subdir  1.8  1.135  1.13
@end example

Puede combinar expresiones con @code{%} delimitándolas con llaves siguiendo
al signo @code{%} -- esto las expandirá en series de sublistas separadas
por comas, cada una conteniendo la información correspondiente a un fichero
del envío.  Por ejemplo, @code{%@{sv@}} se expandiría en

@example
miproyecto/a-subdir  foo,1.8  bar,1.135  baz,1.13
@end example

y @code{%@{sVv@}} se expandiría en

@example
miproyecto/a-subdir  foo,1.7,1.8  bar,1.134,1.135  baz,1.12,1.13
@end example

(Puede que tenga que mirar con cuidado para distinguir las comas de los puntos
decimales en estos ejemplos.)

Aquí hay un fichero loginfo de ejemplo:

@example
^miproyecto$   /usr/local/nuevorepos/CVSROOT/log.pl \
   -m miproyecto-devel@@foobar.com %s
ou             /usr/local/bin/ou-notify.pl  %@{sv@}
DEFAULT        /usr/local/bin/default-notify.pl  %@{sVv@}
@end example

En la primera línea, cualquier envío de cambios en el subdirectorio miproyecto
del repositorio invoca @file{log.pl}, pasándole una dirección de correo
electrónico (a la que @file{log.pl} enviará un correo con el informe de
cambios), seguido del repositorio, seguido de todos los ficheros del envío.

En la segunda línea, cualquier envío de cambios en un subdirectorio del
repositorio que contenga la cadena @code{ou} invocará el guión (imaginario)
@file{notificar-ou.pl}, pasándole el repositorio seguido de los nombres de los
ficheros y de los nuevos números de revisión de los ficheros del envío.

La tercera línea invoca el guión (también imaginario)
@file{notificar-defecto.pl} para cualquier envío que no coincida con ninguna
de las dos línes anteriores, pasándole toda la información posible (ruta al
repositorio, nombres de fichero, revisiones antiguas y revisiones nuevas).

@c ----------------------------------------------
@node Los Ficheros verifymsg y rcsinfo
@subsection Los Ficheros verifymsg y rcsinfo

A veces puede que solamente quiera un programa que verifique que los
informes de cambios se ajustan a un cierto estándar y que detenga el envío si
no se cumple ese estándar.  Esto puede conseguirse usando @code{verifymsg},
posiblemente con algo de ayuda de @code{rcsinfo}.

El fichero @dfn{verifymsg} es la combinación habitual de expresiones
regulares y programas.  El programa recibe el informe de cambios por la entrada
estándar; es de suponer que realizará ciertas comprobaciones para verificar
que el informe de cambios cumple ciertos criterios, y finalmente sale con
estado cero o distinto de cero.  En este último caso, el envío fallará.

Mientras tanto, el lado izquierdo de rcsinfo tiene las expresiones regulares
habituales, pero el lado derecho señala a ficheros de plantilla en vez de a
programas.  Un fichero de plantilla podría ser algo como esto

@example
Condición: 
Arreglar: 
Comentarios: 
@end example

o alguna otra colección de campos que se supone que un desarrollador debe
rellenar para formar un informe de cambios válido.  La plantilla no es muy útil
si todo el mundo hace envíos de cambios usando la opción -m explícitamente,
pero muchos desarrolladores prefieren no hacerlo.  En lugar de ello, ejecutan

@example
floss$ cvs commit
@end example

y esperan que CVS lance automáticamente un editor de texto (como se
especifica en la variable de entorno EDITOR).  Ahí escriben un informe de
cambios, guardan el fichero y se salen del editor, después de lo cual CVS
continúa con el envío.

En ese escenario, se insertaría una plantilla rcsinfo en el editor antes
de que el usuario comience a escribir, de forma que se mostrarían los
campos junto con un recordatorio para rellenarlos.  Entonces, cuando el
usuario haga un envío de cambios, se invocará el programa apropiado en
@file{verifymsg}.  Presumiblemente comprobará que el informe sigue ese
formato, y su estado de salida reflejará los resultados de su investigación
(con cero indicando éxito).

Como ayuda a los programas de verificación, la ruta a la plantilla del
fichero rcsinfo se añade como último argumento en la línea de órdenes
de @code{verifymsg}; de esa forma el programa puede basar su proceso de
verificación en la propia plantilla si se desea.

Observe que cuando alguien obtiene una copia de trabajo en
una máquina remota, el fichero de plantilla rcsinfo correspondiente se
envía al cliente también (se almacena en el subdirectorio CVS/ de la
copia de trabajo).  Sin embargo esto significa que si se cambia el
fichero rcsinfo del servidor después de esto, el cliente no verá los
cambios sin volver a obtener una copia del proyecto (con actualizar
simplemente no funcionará).

Fíjese también en que en el fichero verifymsg no se admite la palabra
clave ALL (aunque DEFAULT sigue valiendo).  Esto es para hacer más
sencillo saltarse guiones de verificación por defecto y aplicar otros
específicos para los subdirectorios.

@c -------------------------------------------
@node El Fichero taginfo
@subsection El fichero taginfo

Lo que loginfo hace con los informes de cambios, taginfo lo hace con las
marcas.  El lado izquierdo de taginfo está formado por expresiones regulares
como siempre, y al lado derecho hay programas.  A cada programa se le pasan
automáticamente argumentos cuando se invoca una "CVS tag", en este orden:

@example
arg 1:          nombre de marca
arg 2:          operación ("añadir" => tag, "mover" => tag -F, "borrar" => \
   tag -d)
arg 3:          repositorio
arg 4, 5, etc:  revisión del fichero [revisión del fichero ...]
@end example

Si el programa devuelve un resultado distinto de cero, la marca se aborta.

No hemos cubierto la opción -F para marcas antes de ahora, pero es
exactamente lo que implica lo de arriba: una forma de mover una marca de
una revisión a otra.  Por ejemplo, si se añade la marca @code{Funciona_Bien}
a la Revisión 1.7 de un fichero y quiere añadirla en su lugar a la
Revisión 1.11, haría esto

@example
cvs tag -r 1.11 -F Funciona_Bien foo.c
@end example

que elimina la marca de 1.7, o dondequiera que estuviera anteriormente
en ese fichero, y la pone en 1.11.

@c ------------------------------------------
@node El Fichero cvswrappers
@subsection El Fichero cvswrappers

El fichero de nombre redundante cvswrappers le da una forma de especificar
que ciertos ficheros deberían tratarse como binarios, basado en sus nombres
de fichero.  CVS no asume que todos los ficheros .jpg sean imágenes JPG, por
ejemplo, así que no usa automáticamente -kb cuando añade ficheros JPG.
No obstante, algunos proyectos encontrarían muy útil simplemente designar
todos los ficheros JPG como binarios.  Ésta es la línea de cvswrappers para
hacerlo:

@example
*.jpg -k 'b'
@end example

La @code{b} está separada y entre comillas porque no es el único modo
de expansión de palabras clave RCS posible; también podría especificarse
@code{o}, que indica que no se expandan palabras clave con el signo
@code{$}, sino hacer conversión de nueva línea.  Sin embargo, @code{b}
es el parámetro más frecuente.

Hay algunos otros modos que se pueden especificar desde el fichero
wrappers, pero se utilizan en situaciones tan raras que posiblemente no
valga la pena documentarlos aquí (es decir: el autor nunca ha tenido
que usarlos).  Vea el nodo @cite{Wrappers} en el Cederqvist si siente
curiosidad.

@c ----------------------------------------------------
@node El Fichero editinfo
@subsection El Fichero editinfo

Este fichero está obsoleto, pese a que sigue estando incluido en las
distribuciones.  Ignórelo.

@c ----------------------------------------------------
@node El Fichero notify
@subsection El Fichero notify

Este fichero se usa junto con las características de @code{alarmas} de CVS,
que se describen en @ref{CVS avanzado}.  Nada de ello tendrá sentido hasta
que comprenda qué son las alarmas (son una característica útil pero
no esencial), así que vea @ref{CVS avanzado} para obtener detalles sobre
este fichero y sobre las alarmas.

@c ----------------------------------------------------
@node El Fichero checkoutlist
@subsection El Fichero checkoutlist

Si mira en CVSROOT/, verá qué copias de trabajo de los ficheros existen,
junto a sus ficheros de revisión RCS:

@example
floss$ ls /usr/local/nuevorepos/CVSROOT
checkoutlist     config,v       history     notify     taginfo
checkoutlist,v   cvswrappers    loginfo     notify,v   taginfo,v
commitinfo       cvswrappers,v  loginfo,v   passwd     verifymsg
commitinfo,v     editinfo       modules     rcsinfo    verifymsg,v
config           editinfo,v     modules,v   rcsinfo,v

floss$ 
@end example

CVS presta sólo atención a las versiones de trabajo, no a los ficheros RCS,
cuando está buscando una guía sobre cómo comportarse.  Por tanto, siempre que
haga un envío de cambios de su copia de trabajo de CVSROOT/ (de la que podría
obtenerse incluso, después de todo, una copia de trabajo desde otra máquina
distinta), CVS actualiza automáticamente todos los ficheros cambiados en el
propio repositorio.  Sabrá que esto ocurre porque CVS mostrará un mensaje al
final de estos envíos:

@example
floss$ cvs ci -m "añadidos módulos mp y asub" modules
Checking in modules; 
/usr/local/nuevorepos/CVSROOT/modules,v  <--  modules
new revision: 1.2; previous revision: 1.1
done
cvs commit: Rebuilding administrative file database
@end example

CVS se entera automáticamente de lo que pasa con los ficheros estándar de
administración, y los reconstruirá en CVSROOT/ cuando sea necesario.  Si
decide poner ficheros personalizados en CVSROOT/ (como programas o ficheros
de plantilla rcsinfo), tendrá que decirle explícitamente a CVS que los
trate del mismo modo.

Éste es el propósito del fichero checkoutlist.  Tiene un formato distinto
al de la mayoría de los ficheros que hemos visto hasta ahora

@example
NOMBRE_FICHERO     MENSAJE_DE_ERROR_SI_NO_PUEDE_OBTENERSE_COPIA_DEL_FICHERO
@end example

por ejemplo,

@example
log.pl           imposible obtener copia de / actualizar log.pl en CVSROOT

bugfix.tmpl      imposible obtener copia de / actualizar bugfix.tmpl en CVSROOT
@end example

Tradicionalmente algunos ficheros de CVSROOT no se someten a control de
revisión.  Uno de ellos es el fichero @dfn{history}, que mantiene un registro
en vivo de todas las acciones en el repositorio para usarse con las órdenes
@w{@code{cvshistory}} (que lista actividades de marcas, obtenciones de copias
y actualizaciones para un fichero o un directorio del proyecto dado). A
propósito, si simplemente elimina el fichero @file{history} CVS detendrá
servicialmente ese registro.

Nota: a veces el fichero history es la causa de problemas con los permisos,
y la forma más fácil de resolverlos es o eliminarlo o hacerlo modificable por
todo el mundo.

Otro fichero de administración @code{no sujeto a revisión} es passwd, dado que
obtener una copia suya por la red comprometería las contraseñas (aunque estén
cifradas).  Tendrá que decidir basándose en su propia situación de seguridad
si quiere añadir passwd a checkoutlist o no; por defecto no está.

Dos notas finales sobre el directorio CVSROOT/: Es posible, si comete un
error lo bastante grande, que envíe cambios de un fichero administrativo que
esté estropeado de tal forma que impida que se haga cualquier otro envío.
Si hace esto, ¡por supuesto que no será capaz de enviar una versión corregida
del fichero administrativo!. La solución es ir y editar a mano la copia de
trabajo del repositorio del fichero administrativo para corregir el problema;
puede que el repositorio entero esté inaccesible hasta que haga esto.

Además, en aras de la seguridad, asegúrese de que en el directorio CVSROOT/
sólo pueden escribir usuarios en quienes confía (con @code{confianza} quiero
decir que confíe tanto en sus intenciones como en su capacidad para no
poner en peligro sus contraseñas).  Los ficheros @file{*info} le dan a la
gente la capacidad de invocar programas en general, así que cualquiera
que pueda hacer envíos o editar ficheros en el directorio CVSROOT/ puede
en la práctica ejecutar cualquier orden del sistema.  Esto es algo que
siempre debe tener en mente.

@c -------------------------------------------------------
@node Correos de envío de cambios
@section Correos de envío de cambios

Con el fichero loginfo es como se configuran los correos de envío de cambios
-- correos automáticos que se envían a todos los que trabajan en un proyecto
siempre que se realiza un envío de cambios.  (Puede que no parezca
intuitivo que esto se haga en loginfo en vez de en commitinfo,
pero la razón para ello es que se quiere incluir el informe de cambios en el
correo).  El programa para hacer el envío -- @file{contrib/log.pl} en
la distribución fuente de CVS -- puede instalarse en cualquier parte
del sistema.  Yo lo pongo en el subdirectorio CVSROOT/ del repositorio,
pero es cuestión de gustos.

Puede que necesite editar ligeramente @file{log.pl} para conseguir que
funcione en su sistema, posiblemente cambiando la primera línea para
que señale a su intérprete Perl, y quizá cambiando la línea

@example
$mailcmd = "| Mail -s 'Actualización CVS: $modulepath'";
@end example

para que llame a su gestor de correo favorito, que puede llamarse @code{Mail}
o no.  Una vez que lo haya configurado a su gusto, podrá añadir líneas como
estas a su loginfo:

@example
listerizer CVSROOT/log.pl %s -f CVSROOT/commitlog -m listerizer@@red-bean.com
RoadMail   CVSROOT/log.pl %s -f CVSROOT/commitlog -m roadmail@@red-bean.com
bk/*score  CVSROOT/log.pl %s -f CVSROOT/commitlog -m \
                                        bkscore-devel@@red-bean.com
@end example

El @code{%s} se expande a los nombres de los ficheros afectados por el envío
de cambios; la opción -f para @file{log.pl} requiere un nombre de fichero
al que el informe de cambios se añadirá (de forma que CVSROOT/commitlog será un
fichero siempre creciente de informes de cambios); y el modificador -m admite
una dirección de correo electrónico, a la que @file{log.pl} enviará un
mensaje sobre el envío de cambios.  La dirección es generalmente una lista de
correo, pero puede especificar la opción -m tantas veces como sean necesarias
en una línea de órdenes para log.pl.

@c --------------------------------------------------------------
@node Averiguando más
@section Averiguando más

Aunque este capítulo trata de dar una introducción a la instalación y
administración de CVS, me he dejado cosas que o bien se usan muy raramente
como para que valga la pena mencionarlas o bien ya están bien documentadas en
el manual Cederqvist.  La última categoría incluye la puesta a punto de los
otros métodos de acceso remoto: RSH/SSH, kserver (Kerberos 4) y GSSAPI
(que incluye Kerberos 5 entre otras cosas).  Debería notarse que no hay que
hacer nada especial para las conexiones con RSH/SSH, aparte de asegurarse
de que el usuario en cuestión puede entrar en la máquina del repositorio
usando RSH o SSH.  Si pueden y CVS está instalado tanto en el cliente como
en el servidor, y tienen los permisos adecuados para usar el repositorio
directamente desde la máquina servidora, deberían poder acceder al
repositorio remotamente por medio del método :ext:.

Las descripciones de algunas características especializadas de CVS se han
dejado para capítulos posteriores, para que puedan introducirse en contextos
en los que su utilidad es evidente.  Pueden encontrarse consejos generales
de solución de problemas de CVS en @ref{Problemas y Soluciones}.  Aunque
no es necesario leerse el manual Cederqvist entero, debería familiarizarse
con él; será una herramienta de referencia de valor incalculable.  Si por
alguna razón no tiene Info en su máquina y no quiere imprimir el manual, puede
hojearlo en línea en @uref{http://durak.org/cvswebsites/doc/} o
@uref{http://www.loria.fr/~molli/cvs/doc/cvs_toc.html}.
