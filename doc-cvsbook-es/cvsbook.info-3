This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: Añadir directorios,  Next: CVS y ficheros binarios,  Prev: Añadir ficheros,  Up: Otros comandos útiles de CVS

Añadir directorios
------------------

A diferencia del añadido de ficheros, el añadido de directorios es un
proceso de un sólo paso; no es necesario emplear "commit" a
continuación:

     floss$ mkdir c-subdir
     floss$ cvs add c-subdir
     Directory /usr/local/cvs/miproyecto/c-subdir added to the repository
     floss$

Si examina lo que hay dentro del nuevo directorio en la copia de
trabajo, verá que el comando "add" ha añadido automáticamente un
subdirectorio "CVS":

     floss$ ls c-subdir
     CVS/
     floss$ ls c-subdir/CVS
     Entries     Repository  Root
     floss$

Ahora puede añadir ficheros (o nuevos directorios) al directorio que ha
creado, como con cualquier otro directorio de su copia de trabajo.


File: cvsbook.info,  Node: CVS y ficheros binarios,  Next: Eliminar ficheros,  Prev: Añadir directorios,  Up: Otros comandos útiles de CVS

CVS y ficheros binarios
-----------------------

Hasta ahora he decidido omitir el secretillo que esconde CVS, que es el
hecho de que no se le dan muy bien los ficheros binarios (bueno, hay
algún que otro secretillo más, pero éste es desde luego el más
vergonzante de todos). No es que CVS no soporte el uso de binarios; en
realidad lo hace, pero no sin algunos dolores de cabeza.

Todos los ficheros en los que hemos estado trabajando hasta ahora han
sido simples ficheros de texto. CVS tiene algunos trucos especiales
para los ficheros de texto: por ejemplo, cuando está trabajando entre
un repositorio de Unix y una copia de trabajo instalada en un sistema
Windows o Macintosh, convierte los finales de línea de la forma
apropiada para cada plataforma.  Por ejemplo, la convención en Unix es
usar simplemente un salto de línea (LF), mientras que Windows espera
una secuencia de retorno de carro y salto de línea (CR+LF) al final de
cada línea. Así, los ficheros en una copia de trabajo bajo Windows
tendrán terminaciones CR+LF, mientras que una copia de trabajo del
mismo proyecto instalada en una máquina Unix tendrá terminaciones LF
(el repositorio en sí siempre utiliza el formato LF).

Otro truco es que CVS detecta en los ficheros de texto la presencia de
cadenas especiales, conocidas como cadenas de texto de palabras clave
RCS, y las sustituye con la información de la revisión y otras cosas
útiles.  Por ejemplo, si su fichero contiene esta cadena:

     $Revision$

CVS la expandirá en cada envío para poner en su lugar el número de
revisión.  Por ejemplo, esta cadena podría convertirse en

     $Revision: 1.3 $

CVS mantiene esta cadena al día en el fichero a medida que éste va
evolucionando. Estas palabras clave se documentan en *Note CVS
avanzado:: y *Note Herramientas de terceros::.

Esta expansión de cadenas de texto es algo muy útil en los ficheros de
texto, ya que permite ver los números de revisión y otra información
sobre un fichero mientras lo está editando. Ahora bien, ¿qué pasa si el
fichero es una imagen JPG? ¿o un programa ejecutable compilado? En estos
casos, CVS podría dañar seriamente los ficheros si se pusiera a expandir
cada palabra clave que fuese encontrando. Es más, en un fichero binario
estas cadenas podrían aparecer por pura coincidencia.

Por lo tanto, cuando añada un fichero binario, debe decirle a CVS que
desactive tanto la expansión de palabras clave como la conversión de
finales de línea. Para ello, utilice -kb:

     floss$ cvs add -kb fichero
     floss$ cvs ci -m "añadido esto y lo otro" fichero
       (etcétera)

Por otra parte, en ciertas ocasiones (como es el caso de ficheros de
texto donde posiblemente aparezca alguna referencia a este tipo de
palabras clave), posiblemente desee desactivar solamente la expansión
de palabras clave. Esto se hace con -ko:

     floss$ cvs add -ko fichero
     floss$ cvs ci -m "añadido esto y lo otro" fichero
       (etcétera)

(De hecho, este mismo capítulo que está leyendo es un ejemplo de este
tipo de casos, merced al ejemplo de `$Revision$' mostrado aquí.)

Tenga en cuenta que no tiene sentido utilizar `cvs diff' sobre dos
revisiones de un fichero binario. Diff utiliza un algoritmo basado en
texto que sólo puede discernir si dos ficheros binarios son distintos,
pero no la forma en que difieren. Futuras versiones de CVS podrían
llegar a ofrecer alguna manera de presentar diferencias entre ficheros
binarios.


File: cvsbook.info,  Node: Eliminar ficheros,  Next: Eliminar directorios,  Prev: CVS y ficheros binarios,  Up: Otros comandos útiles de CVS

Eliminar ficheros
-----------------

Eliminar un fichero es similar a añadir uno, con la salvedad de que debe
dar un paso adicional: tendrá que eliminar antes el fichero de su copia
de trabajo.

     floss$ rm nuevofichero.c
     floss$ cvs remove nuevofichero.c
     cvs remove: scheduling 'nuevofichero.c' for removal
     cvs remove: use 'cvs commit' to remove this file permanently
     floss$ cvs ci -m "eliminado nuevofichero.c" nuevofichero.c
     Removing nuevofichero.c;
     /usr/local/cvs/miproyecto/nuevofichero.c,v  <-  nuevofichero.c
     new revision: delete; previous revision: 1.1
     done
     floss$

Fíjese cómo en el segundo y tercer comandos nos referimos a
nuevofichero.c de forma explícita a pesar de que ya no existe en
nuestra copia de trabajo.  Por supuesto, en el envío, no es
estrictamente necesario que nombre el fichero, siempre que no le
importe que el envío afecte también a cualquier otra modificación que
haya podido tener lugar en la copia de trabajo.


File: cvsbook.info,  Node: Eliminar directorios,  Next: Renombrar ficheros y directorios,  Prev: Eliminar ficheros,  Up: Otros comandos útiles de CVS

Eliminar directorios
--------------------

Como he dicho anteriormente, en realidad CVS no mantiene los directorios
bajo control de versión, sino que, a modo de medida de ahorro, presenta
ciertos comportamientos extraños que en la mayoría de los casos hacen
simplemente "lo que conviene". Uno de estos comportamientos extraños es
que los directorios vacíos pueden tratarse de una forma especial. Si
desea eliminar un directorio de un proyecto, primero borre todos los
ficheros que contenga

     floss$ cd dir
     floss$ rm fichero1 fichero2 fichero3
     floss$ cvs remove fichero1 fichero2 fichero3
       (salida de información omitida)
     floss$ cvs ci -m "borrados todos los ficheros" fichero1 fichero2 fichero3
       (salida de información omitida)

y después ejecute "update" en el directorio anterior con la opción -P:

     floss$ cd ..
     floss$ cvs update -P
       (salida de información omitida)

La opción -P le dice al comando "update" que "limpie" cualquier
directorio vacío, esto es, que los elimine de la copia de trabajo. Una
vez hecho esto, puede decirse que el directorio ha sido borrado; todos
sus ficheros han desaparecido, y el directorio en sí es historia (al
menos por lo que respecta a nuestra copia de trabajo, claro, pero sigue
habiendo un directorio vacío en el repositorio).

Una interesante contrapartida de este comportamiento es que, cuando se
hace una actualización normal, CVS no trae automáticamente a la copia de
trabajo los nuevos directorios que se hayan creado en el repositorio.
Hay un par de justificaciones variopintas para esto, ninguna de las
cuales vale la pena mencionar aquí. La explicación breve es que de vez
en cuando debería ejecutar "update" con la opción -d, ordenándole que
traiga cualquier nuevo directorio que haya sido creado en el
repositorio.


File: cvsbook.info,  Node: Renombrar ficheros y directorios,  Next: Evitar la fatiga de las opciones,  Prev: Eliminar directorios,  Up: Otros comandos útiles de CVS

Renombrar ficheros y directorios
--------------------------------

Renombrar un fichero es equivalente a crearlo con un nuevo nombre y
eliminarlo con el antiguo. En Unix, los comandos son:

     floss$ cp nombre_antiguo nuevo_nombre
     floss$ rm nombre_antiguo

Aquí está el equivalente en CVS:

     floss$ mv nombre_antiguo nuevo_nombre
     floss$ cvs remove nombre_antiguo
       (salida omitida)
     floss$ cvs add nuevo_nombre
       (salida omitida)
     floss$ cvs ci -m "renombrado nombre_antiguo como nuevo_nombre" nombre_antiguo nuevo_nombre
       (salida omitida)
     floss$

Para ficheros, ésto es todo lo que hay que hacer. El renombramiento de
directorios tampoco varía mucho: deberá crear el nuevo directorio,
añadirlo con cvs add, mover todos los ficheros del directorio antiguo
al nuevo, eliminarlos con cvs remove del directorio antiguo, añadirlos
al nuevo con cvs add, hacer un envío con cvs commit para actualizar el
repositorio, y finalmente actualizarse con cvs update -P para que
desaparezca de nuestra copia de trabajo cualquier directorio vacío. O
sea,

     floss$ mkdir nuevo_dir
     floss$ cvs add nuevo_dir
     floss$ mv dir_antiguo/* nuevo_dir
     mv: nuevo_dir/CVS: cannot overwrite directory
     floss$ cd dir_antiguo
     floss$ cvs rm foo.c bar.txt
     floss$ cd ../nuevo_dir
     floss$ cvs add foo.c bar.txt
     floss$ cd ..
     floss$ cvs commit -m "movidos foo.c y bar.txt de dir_antiguo a nuevo_dir"
     floss$ cvs update -P

Fíjese en el mensaje de aviso recibido después de ejecutar el tercer
comando.  Este aviso le comunica que no se puede copiar el
subdirectorio CVS/ del antiguo directorio al nuevo porque ya hay allí
un directorio con este nombre. Esto es correcto, porque le interesa que
el directorio antiguo mantenga de todos modos su subdirectorio CVS/.

Obviamente, mover directorios de un lado para otro puede ser un poco
engorroso. La mejor política es tratar de disponer una buena
distribución en el momento de importar el proyecto, de forma que no
tenga que estar moviendo luego directorios para aquí y para allá. Más
adelante, aprenderá un método más drástico para mover directorios, esta
vez haciendo el cambio directamente en el repositorio. Sin embargo, es
mejor reservar este método para situaciones de emergencia; siempre que
sea posible, es mejor gestionar todo con operaciones de CVS que afecten
principalmente a las copias de trabajo.


File: cvsbook.info,  Node: Evitar la fatiga de las opciones,  Next: Obtener instantáneas (fechas y marcas),  Prev: Renombrar ficheros y directorios,  Up: Otros comandos útiles de CVS

Evitar la fatiga de las opciones
--------------------------------

La mayor parte de la gente se cansa rápidamente de estar escribiendo
continuamente las mismas opciones con cada comando. Si sabe que siempre
va a querer pasar la opción global -Q o que siempre va a usar -c con
diff, ¿por qué tendría que estar escribiéndolas una y otra vez?

Por suerte, dispone de ayuda para esto. CVS busca un fichero .cvsrc en
su directorio personal. En este fichero puede especificar las opciones
que deban aplicarse por omisión en cada invocación a CVS. Éste es un
fichero .cvsrc de ejemplo:

     diff -c
     update -P
     cvs -q

Si la primera palabra de la línea corresponde a un comando de CVS en su
forma *no* abreviada, las opciones indicadas ahí serán las que se
utilicen siempre con ese comando. Para indicar opciones globales a
emplear por omisión, deberá usar "cvs".

Empleando nuestro ejemplo de arriba, cada vez que el usuario ejecute
cvs diff, la opción -c se incluirá automáticamente.


File: cvsbook.info,  Node: Obtener instantáneas (fechas y marcas),  Next: Formatos de fecha permitidos,  Prev: Evitar la fatiga de las opciones,  Up: Otros comandos útiles de CVS

Obtener instantáneas (fechas y marcas)
--------------------------------------

Volvamos al ejemplo del programa que está en un estado inoperativo en
el momento en el que recibimos un informe de fallo de un usuario. El
desarrollador necesita de repente acceder al proyecto entero en el
estado en el que se encontraba al hacer la última distribución pública,
aunque muchos ficheros posiblemente habrán cambiado desde entonces, y
el número de revisión de cada fichero seguramente será distinto en este
momento. Llevaría demasiado tiempo revisar los informes de cambios,
adivinar cuál era el número de revisión de cada fichero en el momento
de la distribución, y después ejecutar una actualización (especificando
el número de revisión con -r) para cada uno de ellos. En proyectos de
mediano o gran tamaño (de decenas a cientos de ficheros), sería casi
imposible acometer tamaña empresa.

Por todo lo cual, CVS proporciona una forma de obtener de una sola vez
revisiones antiguas de los ficheros que forman un proyecto. De hecho,
ofrece dos mecanismos: por fecha -que selecciona las revisiones
basándose en la fecha en que fueron enviadas al repositorio-, y por
marca, que obtiene una "instantánea" del proyecto marcada previamente.

Cuál de los métodos deberá utilizar es algo que depende de la situación
concreta. El método basado basado en fechas funciona pasando la opción
-D al comando "update", que es similar a -r pero en este caso tomando
como argumento fechas en lugar de números de revisión:

     floss$ cvs -q update -D "1999-04-19"
     U hello.c
     U a-subdir/subsubdir/fish.c
     U b-subdir/random.c
     floss$

Con la opción -D, "update" recupera la revisión más reciente de cada
fichero existente en la fecha dada, devolviendo si es necesario los
ficheros de la copia de trabajo al estado en el que encontes se
encontraban.

Cuando se da una fecha, puede -y generalmente, debería hacerlo- incluir
la hora exacta. Por ejemplo, el comando anterior terminó tomando del
repositorio la revisión 1.1 de todo (sólo tres ficheros cambiaron,
porque los demás están aún en la revisión 1.1). Éste es el estado de
hello.c para demostrarlo:

     floss$ cvs -Q status hello.c
     ===================================================================
     File: hello.c                 Status: Up-to-date
        Working revision:          1.1.1.1 Sat Apr 24 22:45:03 1999
        Repository revision:       1.1.1.1 /usr/local/cvs/miproyecto/hello.c,v
        Sticky Date:               99.04.19.05.00.00
     floss$

Pero un vistazo atrás a los informes de cambios presentados
anteriormente en este capítulo indica que la revisión 1.2 de hello.c se
envió sin duda alguna al repositorio el 19 de Abril de 1999. Así que,
¿por qué hemos recibido ahora la revisión 1.1 en lugar de la 1.2?

El problema está en que la fecha "1999-04-19" fue interpretada como "la
medianoche en la que comenzó el día 1999-04-19", esto es, el primer
instante de ese día. Esto seguramente no es lo que quiere. El envío de
la revisión 1.2 tuvo lugar en un momento posterior de ese día.
Indicando la fecha con mayor exactitud, podemos obtener la revisión 1.2:

     floss$ cvs -q update -D "1999-04-19 23:59:59"
     U hello.c
     U a-subdir/subsubdir/fish.c
     U b-subdir/random.c
     floss$ cvs status hello.c
     ===================================================================
     File: hello.c                 Status: Locally Modified
        Working revision:  1.2     Sat Apr 24 22:45:22 1999
        Repository revision:       1.2     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:                (none)
        Sticky Date:               99.04.20.04.59.59
        Sticky Options:    (none)
     floss$

Casi hemos terminado. Si observa atentamente la fecha y hora de la línea
"Sticky Date", parece indicar las 4:59:59 AM, no las 11:59 como se
indicó en el comando (más adelante veremos lo que significa "sticky").

Como habrá adivinado, la discrepancia se debe a la diferencia entre la
hora local y la hora Universal Coordinada (también conocida como la hora
del meridiano de Greenwich). El repositorio guarda siempre las fechas en
Tiempo Universal, pero en su lado cliente CVS suele asumir la hora local
del sistema. En el caso de -D, esto es un poco desafortunado, porque
posiblemente le interese más comparar respecto a la hora recogida en el
repositorio que preocuparse por lo que el sistema local opina de qué
hora es. Puede evitar este problema especificando la zona GMT en el
comando:

     floss$ cvs -q update -D "1999-04-19 23:59:59 GMT"
     U hello.c
     floss$ cvs -q status hello.c
     ===================================================================
     File: hello.c                 Status: Up-to-date
        Working revision:  1.2     Sun Apr 25 22:38:53 1999
        Repository revision:       1.2     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:                (none)
        Sticky Date:               99.04.19.23.59.59
        Sticky Options:    (none)
     floss$

¡Ajá! Esto ha hecho que la copia de trabajo quede registrada como uno
de los últimos envíos realizados el 19 de Abril (a menos que hubiera
algún envío en el último segundo del día, que no es el caso).

¿Qué sucede ahora si ejecuta "update"?

     floss$ cvs update
     cvs update: Updating .
     cvs update: Updating a-subdir
     cvs update: Updating a-subdir/subsubdir
     cvs update: Updating b-subdir
     floss$

No pasa nada. Pero usted sabe que hay versiones más recientes de por lo
menos tres ficheros, luego, ¿por qué no se incorporan estos ficheros en
su copia de trabajo?

Aquí es donde "sticky" entra en juego. Actualizar (¿"desactualizar"?)
con la opción -D hace que la copia de trabajo quede fijada de forma
permanente a esa fecha o a una anterior: en terminología de CVS, la
copia de trabajo tiene "pegada" una fecha. Una vez que una copia de
trabajo ha adquirido una propiedad pegadiza, se mantiene así hasta que
se le diga lo contrario. Así pues, posteriores actualizaciones no
permitirán obtener automáticamente la revisión más reciente, sino que
estarán restringidas a la fecha pegada. El si hay algo pegado o no a un
fichero es algo que puede averiguarse ejecutando cvs status, o bien
examinando directamente el fichero CVS/Entries:

     floss$ cvs -q update -D "1999-04-19 23:59:59 GMT"
     U hello.c
     floss$ cat CVS/Entries
     D/a-subdir////
     D/b-subdir////
     D/c-subdir////
     /README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//D99.04.19.23.59.59
     /hello.c/1.2/Sun Apr 25 23:07:29 1999//D99.04.19.23.59.59
     floss$

Si ahora usted modificase su copia de hello.c e intentase después
enviarla al repositorio,

     floss$ cvs update
     M hello.c
     floss$ cvs ci -m "intentando cambiar el pasado"
     cvs commit: cannot commit with sticky date for file 'hello.c'
     cvs [commit aborted]: correct above errors first!
     floss$

CVS no permitiría la enviar ese fichero al repositorio, puesto que
sería como permitirle volver atrás y cambiar el pasado. Lo de CVS es
gestionar historiales, así que bajo ningún concepto le permitirá
realizar semejante operación.

Esto no significa, sin embargo, que CVS no sea consciente de todas las
revisiones que se hayan enviado desde aquella fecha. Usted sigue
pudiendo comparar la fecha pegada a la copia de trabajo con otras
revisiones, incluso las futuras:

     floss$ cvs -q diff -c -r 1.5 hello.c
     Index: hello.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.5
     diff -c -r1.5 hello.c
     *** hello.c   1999/04/24 22:09:27     1.5
     --- hello.c   1999/04/25 00:08:44
     ***************
     *** 3,9 ****
       void
       main ()
       {
         printf ("¡Hola, mundo!\n");
     -   printf ("entre hola y adiós\n");
         printf ("¡Adiós, mundo!\n");
       }
     --- 3,9 --
       void
       main ()
       {
     +   /* esta línea fue añadida a una copia de trabajo "desactualizada" */
         printf ("¡Hola, mundo!\n");
         printf ("¡Adiós, mundo!\n");
       }

El diff revela que, a 19 de abril de 1999, la línea "entre hola y adiós"
no había sido añadida todavía. También muestra la modificación que
hicimos a la copia de trabajo (añadir el comentario que aparece arriba).

Puede eliminar la fecha pegadiza (o cualquier otra propiedad pegadiza)
haciendo una actualización con la opción -A ("-A" significa "reiniciar",
no me pregunte por qué), lo que pone la copia de trabajo de nuevo en
sincronía con las revisiones más recientes:

     floss$ cvs -q update -A
     U hello.c
     floss$ cvs status hello.c
     ===================================================================
     File: hello.c                 Status: Up-to-date
        Working revision:  1.5     Sun Apr 25 22:50:27 1999
        Repository revision:       1.5     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:                (none)
        Sticky Date:               (none)
        Sticky Options:    (none)
     floss$


File: cvsbook.info,  Node: Formatos de fecha permitidos,  Next: Marcar un momento en el tiempo (marcas),  Prev: Obtener instantáneas (fechas y marcas),  Up: Otros comandos útiles de CVS

Formatos de fecha permitidos
----------------------------

CVS admite una gran variedad de formatos cuando se trata de indicar
fechas. Nunca tendrá problemas si decide utilizar el formato ISO 8601
(esto es, en la Organización Internacional de Estándares, el estándar
número 8601, consulte también
http://www.saqqara.demon.co.uk/datefmt.htm), que es el formato empleado
en los ejemplos precedentes. Puede también utilizar el formato de fecha
empleado en el correo electrónico vía Internet tal como se describe en
los RFC 822 y 1123 (véase http://www.rfc-editor.org/rfc/). Por último,
puede utilizar ciertas construcciones anglosajonas no ambiguas para
especificar una fecha relativa a la fecha actual.

Lo más probable es que nunca necesite utilizar todos los formatos
disponibles, pero aquí van algunos ejemplos para darle una idea de lo
que admite CVS:

     floss$ cvs update -D "19 Apr 1999"
     floss$ cvs update -D "19 Apr 1999 20:05"
     floss$ cvs update -D "19/04/1999"
     floss$ cvs update -D "3 days ago"
     floss$ cvs update -D "5 years ago"
     floss$ cvs update -D "19 Apr 1999 23:59:59 GMT"
     floss$ cvs update -D "19 Apr"

Las comillas que delimitan las fechas están ahí para asegurar que el
shell de Unix trata la fecha como un único argumento aunque incluya
espacios en blanco. Las comillas no causarán ningún problema aunque la
fecha no contenga espacios, así que probablemente sea mejor usarlas
siempre.


File: cvsbook.info,  Node: Marcar un momento en el tiempo (marcas),  Prev: Formatos de fecha permitidos,  Up: Otros comandos útiles de CVS

Marcar un momento en el tiempo (marcas)
---------------------------------------

Pedir ficheros según una fecha concreta es útil cuando el mero paso del
tiempo es su principal preocupación. Pero normalmente lo que realmente
querrá será obtener el proyecto tal y como estaba al producirse un
determinado evento concreto: quizás el día de hacer una distribución
pública, un punto en el que el proyecto se encontraba en su momento más
estable, o la vez que se añadió o eliminó cierta característica
importante.

Intentar recordar la fecha en la que tuvo lugar un evento en concreto o
deducir la fecha a partir de los informes de cambios sería un proceso
muy tedioso. Presumiblemente, el evento, en caso de que fuese realmente
importante, se marcó como tal en el historial formal de revisiones. El
método que ofrece CVS para crear este tipo de marcas se conoce como
"marcado".

Las marcas ("tags", N. del T.) se diferencian de los envíos corrientes
en que no registran ningún cambio particular en el texto de los
ficheros, sino más bien un cambio en la forma en que los
desarrolladores contemplan los ficheros. Lo que hace una marca es poner
una etiqueta al conjunto de revisiones representadas por la copia de
trabajo de un desarrollador (lo normal es que la copia de trabajo está
completamente al día, así que el nombre de la marca se pone a las
revisiones "más recientes y brillantes" presentes en el repositorio).

Poner una marca es tan sencillo como ésto:

     floss$ cvs -q tag Release-1999_05_01
     T README.txt
     T hello.c
     T a-subdir/loquesea.c
     T a-subdir/subsubdir/fish.c
     T b-subdir/random.c
     floss$

Este comando asocia el nombre simbólico "Release-1999_05_01" a la
instantánea representada por esta copia de trabajo. Definida
formalmente, una "instantánea" es un conjunto de ficheros del proyecto
y los números de revisión asociados con ellos. Estos números de
revisión no tienen por qué ser los mismos entre varios ficheros, y de
hecho no suelen serlo.  Por ejemplo, suponiendo que la marca se hubiera
puesto en el mismo directorio "miproyecto" que hemos estado utilizando
en este capítulo y que la copia de trabajo estuviese completamente al
día, el nombre simbólico "Release-1999_05_01" se asociaría a la
revisión 1.5 de hello.c, a la revisión 1.2 de fish.c, a la revisión 1.2
de random.c, y a la revisión 1.1 de todo lo demás.

Quizás le ayude el pensar en una marca como en una senda o cadena que
une varias revisiones de ficheros del proyecto. En la Figura 2.1, una
cadena imaginaria pasa por el número de revisión marcado en cada
fichero del proyecto.


          Fichero A   Fichero B   Fichero C   Fichero D   Fichero E
          ---------   ---------   ---------   ---------   ---------
          1.1         1.1         1.1         1.1         1.1
      ----1.2-.       1.2         1.2         1.2         1.2
          1.3 |       1.3         1.3         1.3         1.3
               \      1.4       .-1.4-.       1.4         1.4
                \     1.5      /  1.5  \      1.5         1.5
                 \    1.6     /   1.6   |     1.6         1.6
                  \   1.7    /          |     1.7         1.7
                   \  1.8   /           |     1.8       .-1.8------->
                    \ 1.9  /            |     1.9      /  1.9
                     `1.10'             |     1.10    /   1.10
                      1.11              |     1.11    |
                                        |     1.12    |
                                        |     1.13    |
                                         \    1.14    |
                                          \   1.15   /
                                           \  1.16  /
                                            `-1.17-'
     
     [Figura 2.1: La relación que puede haber entre una marca y determinadas
     revisiones de los ficheros.]

Ahora, si estira la cadena y la observa de forma longitudinal, podrá ver
un momento específico en el historial del proyecto; concretamente, el
momento en el que se fijó la marca (Figura 2.2).


          Fichero A   Fichero B   Fichero C   Fichero D   Fichero E
          ---------   ---------   ---------   ---------   ---------
                                              1.1
                                              1.2
                                              1.3
                                              1.4
                                              1.5
                                              1.6
                                              1.7
                      1.1                     1.8
                      1.2                     1.9
                      1.3                     1.10        1.1
                      1.4                     1.11        1.2
                      1.5                     1.12        1.3
                      1.6                     1.13        1.4
                      1.7         1.1         1.14        1.5
                      1.8         1.2         1.15        1.6
          1.1         1.9         1.3         1.16        1.7
      ----1.2---------1.10--------1.4---------1.17--------1.8------->
          1.3         1.11        1.5         1.17        1.9
                                  1.6         1.17        1.10
     
     [Figura 2.2: La misma marca vista longitudinalmente respecto al historial
     de revisiones.]

A medida que sigue editando ficheros y enviando cambios, la marca *no*
se moverá de su sitio a pesar de que los números de revisión se vayan
incrementando. Permanece fija, "pegada" al número de revisión de cada
fichero al que fue asociada.

Dada su importancia como elementos descriptivos, es una pena que los
informes de cambios no puedan ser incluidos con las marcas, y que las
marcas en sí no puedan ser párrafos de texto reales. En el ejemplo
anterior, la marca indica de forma bastante obvia que el proyecto se
encontraba en un estado "publicable" en una fecha determinada. Sin
embargo, a veces querrá hacer instantáneas de un estado más complejo,
lo que puede dar lugar a nombres de marcas un tanto extraños, como:

     floss$ cvs tag testing-release-3_pre-19990525-public-release

Por regla general, debería intentar mantener las marcas lo más simples
posible al tiempo que incluye toda la información necesaria sobre el
evento que está intentando registrar. En caso de duda, es mejor pecar
de demasiado descriptivos - lo agradecerá más tarde cuando sea capaz de
determinar gracias a una marca extremadamente descriptiva exactamente
qué circunstancia se registró con ella.

Posiblemente se haya dado cuenta de que no se han usado puntos ni
espacios en el nombre de las marcas. CVS es bastante estricto en lo que
atañe a nombres válidos de marcas: las reglas son que deben comenzar
con una letra y tener letras, dígitos, guiones ("-"), y signos de
subrayado ("_"). No se pueden utilizar espacios, puntos, signos de dos
puntos, comas ni ningún otro símbolo.

Para obtener una instantánea haciendo referencia a una marca, deberá
usar el nombre de esta marca como si fuera un número de revisión. Hay
dos formas de obtener instantáneas: puede obtener una copia de trabajo
nueva con una determinada marca, o bien puede cambiar una copia de
trabajo ya existente por una marca. Ambos métodos tienen como resultado
una copia de trabajo en la que las revisiones de los ficheros son los
asociados a la marca dada.

La mayor parte de las veces, lo que querrá hacer es echar un vistazo al
proyecto tal como éste se encontraba en el momento de hacer la
instantánea.  No necesariamente querrá hacer esto en su copia de
trabajo principal, donde posiblemente tenga cambios aún sin enviar y
otras cosas importantes que preferirá salvaguardar, así que vamos a
suponer que simplemente desea obtener una copia de trabajo por
separado, con la marca. Así es cómo se hace (¡asegúrese de invocar este
comando desde cualquier otro lugar que no sea su copia de trabajo
actual o su directorio padre!):

     floss$ cvs checkout -r Release-1999_05_01 miproyecto
     cvs checkout: Updating miproyecto
     U miproyecto/README.txt
     U miproyecto/hello.c
     cvs checkout: Updating miproyecto/a-subdir
     U miproyecto/a-subdir/loquesea.c
     cvs checkout: Updating miproyecto/a-subdir/subsubdir
     U miproyecto/a-subdir/subsubdir/fish.c
     cvs checkout: Updating miproyecto/b-subdir
     U miproyecto/b-subdir/random.c
     cvs checkout: Updating miproyecto/c-subdir

Anteriormente hemos visto cómo se utilizaba la opción -r con el comando
"update", donde precedía a un número de revisión. En muchos aspectos,
una marca es como un número de revisión, porque, para cada fichero,
cada marca se corresponde exactamente con *un* número de revisión
concreto (es ilegal, y generalmente imposible, tener dos marcas con el
mismo nombre en el mismo proyecto). De hecho, en cualquier lugar donde
pueda utilizar un número de revisión como argumento de un comando de
CVS, podrá también utilizar el nombre de una marca, siempre y cuando
esa marca se haya creado antes.  Si quiere ver las diferencias entre el
estado actual de un fichero y el estado en el que se encontraba en el
momento de realizar la última distribución pública, puede hacer esto:

     floss$ cvs diff -c -r Release-1999_05_01 hello.c

Y si quiere volver atrás temporalmente a aquella revisión, puede hacer
esto:

     floss$ cvs update -r Release-1999_05_01 hello.c

La posibilidad de intercambiar nombres de marcas y números de revisión
explica algunas de las estrictas reglas que definen qué nombre de marca
es válido y cuál no. Imagine por un momento que los puntos fueran
legales en los nombres de las marcas; podría tener una marca llamada
"1.3" asociada a un número real de revisión como puede ser el "1.47".
Si ahora emplease el comando

     floss$ cvs update -r 1.3 hello.c

¿cómo podría CVS saber si se refiere a la marca llamada "1.3", o a la
mucho más antigua revisión 1.3 de hello.c? Es por esto por lo que
existen este tipo de restricciones en los nombres de las marcas, de
forma que siempre puedan distinguirse fácilmente de los números de
revisión. Un número de revisión tiene un punto; el nombre de una marca
no. (También hay motivos para las demás restricciones, generalmente
para permitir que los nombres de las marcas sean fáciles de interpretar
para CVS.)

Como posiblemente habrá ya adivinado, el segundo método para obtener una
instantánea -esto es, pasar un directorio de trabajo ya existente a las
revisiones marcadas- también se realiza por medio de una actualización:

     floss$ cvs update -r Release-1999_05_01
     cvs update: Updating .
     cvs update: Updating a-subdir
     cvs update: Updating a-subdir/subsubdir
     cvs update: Updating b-subdir
     cvs update: Updating c-subdir
     floss$

Este comando es similar al que utilizamos para devolver hello.c al
estado en el que se encontraba en `Release-1999_05_01', con la salvedad
de que se omite el nombre del fichero dado que queremos volver atrás el
proyecto al completo (si lo desea, puede hacer volver atrás solamente
un sub-árbol del proyecto, invocando este comando mientras se encuentra
en ese subdirectorio en lugar de hacerlo desde el nivel más alto,
aunque muy pocas veces querrá hacer esto).

Observe que, a juzgar por los resultados del comando, no parece que haya
cambiado ningún fichero. La copia de trabajo estaba completamente al
día cuando pusimos la marca, y no se había enviado ningún cambio desde
entonces.

Sin embargo, esto no significa que no haya habido ningún cambio en
absoluto.  La copia de trabajo sabe ahora que responde a una revisión
marcada. Cuando hagamos un cambio e intentemos enviarlo al repositorio
(supongamos que hemos modificado hello.c):

     floss$ cvs -q update
     M hello.c
     floss$ cvs -q ci -m "intentando enviar desde una copia de trabajo marcada"
     cvs commit: sticky tag 'Release-1999_05_01' for file 'hello.c' is not a branch
     cvs [commit aborted]: correct above errors first!
     floss$

... CVS impide que el envío llegue a producirse (no se preocupe de
momento por lo que significa el mensaje de error - más adelante y en
este mismo capítulo trataremos el tema de las "branches", o ramas para
entendernos).  Poco importa si la copia de trabajo llegó a tener una
marca a través de la obtención de una copia de trabajo ("checkout") o
una simple actualización; la cuestión es que, una vez que está marcada,
CVS considera la copia de trabajo como una instantánea estática de un
momento particular de la historia, y CVS no le permitirá cambiar la
historia, o cuando menos no se lo pondrá fácil. Si ejecuta "cvs status"
o examina los ficheros CVS/Entries, podrá ver que hay una marca pegada
a cada fichero. Por ejemplo, aquí tiene el fichero Entries del
directorio raíz:

     floss$ cat CVS/Entries
     D/a-subdir////
     D/b-subdir////
     D/c-subdir////
     /README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//TRelease-1999_05_01
     /hello.c/1.5/Tue Apr 20 07:24:10 1999//TRelease-1999_05_01
     floss$

Las marcas, como otras propiedades de carácter "pegadizo", pueden
eliminarse con la opción -A durante una actualización:

     floss$ cvs -q update -A
     M hello.c
     floss$

Sin embargo, la modificación de hello.c no ha desaparecido; CVS todavía
sabe que el fichero ha cambiado respecto a su homónimo en el
repositorio:

     floss$ cvs -q diff -c hello.c
     Index: hello.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.5
     diff -c -r1.5 hello.c
     *** hello.c   1999/04/20 06:12:56     1.5
     --- hello.c   1999/05/04 20:09:17
     ***************
     *** 6,9 ****
     --- 6,10 --
         printf ("¡Hola, mundo!\n");
         printf ("entre hola y adiós\n");
         printf ("¡Adiós, mundo!\n");
     +   /* un comentario en la última línea */
       }
     floss$

Ahora que ha puesto las cosas en orden por medio de la actualización,
CVS aceptará hacer un envío:

     floss$ cvs ci -m "añadido un comentario al final de la función main"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     cvs commit: Examining c-subdir
     Checking in hello.c;
     /usr/local/cvs/miproyecto/hello.c,v  <-  hello.c
     new revision: 1.6; previous revision: 1.5
     done
     floss$

Por supuesto, la marca `Release-1999_05_01' sigue estando asociada a la
revisión 1.5. Compare el estado del fichero de como estaba antes a como
está después de eliminar la marca:

     floss$ cvs -q status hello.c
     ===================================================================
     File: hello.c                 Status: Up-to-date
        Working revision:  1.6     Tue May  4 20:09:17 1999
        Repository revision:       1.6     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:                (none)
        Sticky Date:               (none)
        Sticky Options:            (none)
     floss$ cvs -q update -r Release-1999_05_01
     U hello.c
     floss$ cvs -q status hello.c
     ===================================================================
     File: hello.c                 Status: Up-to-date
        Working revision:  1.5     Tue May  4 20:21:12 1999
        Repository revision:       1.5     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:                Release-1999_05_01 (revision: 1.5)
        Sticky Date:               (none)
        Sticky Options:            (none)
     floss$

Y ahora que vengo de decirle que CVS no le permite cambiar la historia,
le enseñaré precisamente cómo cambiarla.


File: cvsbook.info,  Node: Ramas,  Prev: Otros comandos útiles de CVS,  Up: Una introduccion a CVS

Ramas
=====

Hemos estado concibiendo CVS como un tipo de biblioteca inteligente
desde la que establecer una coordinación; sin embargo, también puede
pensarse en CVS como en una máquina del tiempo (gracias a Jim Blandy
por la analogía). Por ahora, sólo hemos visto cómo se puede revisar el
pasado con CVS, sin afectar a nada. Como todas las buenas máquinas del
tiempo, CVS también le permite ir hacia atrás en el tiempo para cambiar
el pasado.  ¿Y a dónde nos lleva esto? Los amantes de la
ciencia-ficción conocen la respuesta: a un universo alternativo, que
discurre de forma paralela al nuestro, pero que diverge del nuestro
justo desde el punto en el que se alteró el pasado. Una rama de CVS
divide el desarrollo de un proyecto en historias separadas, y
paralelas. Los cambios efectuados en una de las ramas no afectan a las
demás.

* Menu:

* Conceptos básicos sobre ramas::
* Fusión de cambios desde las ramas al tronco::
* Fusiones múltiples::
* Crear una marca o rama sin una copia de trabajo::

