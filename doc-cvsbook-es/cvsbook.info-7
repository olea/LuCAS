This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: Controlar qué acciones son vigiladas,  Next: Encontrar quién vigila qué,  Prev: Cómo acabar una sesión de edición,  Up: Alarmas (CVS como telefono)

Controlar qué acciones son vigiladas
------------------------------------

Por defecto los vigilantes son noficados ante tres acciones: ediciones,
entregas, y terminación de sesión. Sin embargo si usted sólo quiere ser
notificado, por ejemplo en las entregas, puede restringir sus
notificaciones con el indicador -a  de la orden watch (a  por action).

     floss$ cvs watch add -a commit hello.c

Es posible pasar el indicador -a dos veces si quiere ser advertido de
entregas y notificaciones.

     floss$ cvs watch add -a edit -a commit hello.c

Añadir alarmas con el indicador -a no causará la eliminación de ninguna
de sus existentes alarmas. Si estaba vigilando para las tres acciones
sobre hello.c, el ejecutar

     floss$ cvs watch add -a commit hello.c

no tiene efecto - usted seguirá teniendo las tres acciones.  Para
quitar las alarmas hay que hacer lo siguiente

     floss$ cvs watch remove hello.c

Esta orden, por defecto quita las tres clases de acciones. Especificando
la acción mediante -a se quitan sólo las alarmas que se especifiquen en
la línea de órdenes:

     floss$ cvs watch remove -a commit hello.c

Esto indica que usted desea dejear de recibir notificaciones sobre
entregas pero seguirá recibiendo notificaciones sobre ediciones y
terminación de edición (asumiendo que tenía vigilancia para estas dos
acciones).

Hay dos opciones que se pueden pasar al indicador -a: all ó none (todas
ó niguna).  _all_ significa que las acciones que se vigilarán son las
tres antes mencionadas y _none_ ninguna de ellas.  Ya que el
comportamiento por defecto de CVS sin el indicador -a es vigilar todas
las acciones y si no se vigila ninguna es como estar fuera de la lista
de vigilancia es dificil imaginar una situación en la que que se usen
estas dos opciones. Sin embargo, "cvs edit" también usa lleva el
indicador -a, y en esta caso puede ser útil especificar _all_ ó _none_.
Por ejemplo, alguien que va a trabajar brevemente en un fichero quizá
no quiera ser notificado sobre lo que están haciendo otros en ese
fichero. La orden

     paste$ whoami
     qsmith
     paste$ cvs edit -a none README.txt

hace que vigilantes de README.txt sean notificados de que qsmith va a
trabajar en él, pero qsmith no será un vigilante temporal de README.txt
durante su sesión de edición ya que pidió explicitamente no vigilar
ninguna acción.

Observe que esto sólo afecta a lo que usted está vigilando con la orden
`cvs watch'. Usted puede dejar de vigilar cualquier fichero pero esto
no afectará a las alarmas de los demás.


File: cvsbook.info,  Node: Encontrar quién vigila qué,  Next: Recomendar a la gente usar alarmas,  Prev: Controlar qué acciones son vigiladas,  Up: Alarmas (CVS como telefono)

Encontrar quién vigila qué
--------------------------

Alguna vez puede interesarle saber quien está vigilando o editando un
fichero sin antes de ejecutar `cvs edit' o ver quién está editando qué
sin añadirse a ninguna lista de vigilancia. O podría haber olvidado su
propio estatus. Después de haber establecido algunas alarmas y haber
entregado algunos ficheros es fácil saber que está uno vigilando y
editando.

CVS proporciona dos comandos para mostrar quién está vigilando y
editando qué ficheros - `cvs watchers' y `cvs editors':

     floss$ whoami
     jrandom
     floss$ cvs watch add hello.c
     floss$ cvs watchers hello.c
     hello.c jrandom  edit unedit  commit
     floss$ cvs watch remove -a unedit hello.c
     floss$ cvs watchers hello.c
     hello.c jrandom  edit commit
     floss$ cvs watch add README.txt
     floss$ cvs watchers
     README.txt      jrandom edit    unedit  commit
     hello.c jrandom edit    commit
     floss$

Observe que la última orden `cvs watchers' no especifica ningún fichero
y así muestra los vigilantes para todos los ficheros que estén siendo
vigilados.

Todas las órdenes `watch' y `edit' tienen en común con otras órdenes
CVS esta característica. Si usted especifica nombres de ficheros estas
órdenes actuan sobre ellos. Si se especifican nombres de directorio
actuan sobre cada fichero de ese directorio y sus subdirectorios. Si no
especifica nada, actuan sobre el directorio actual y sus subdirectorios.
Siguiendo con la sesión del ejemplo anterior:

     floss$ cvs watch add a-subdir/whatever.c
     floss$ cvs watchers
     README.txt      jrandom edit    unedit  commit
     hello.c jrandom edit    commit
     a-subdir/whatever.c     jrandom edit    unedit  commit
     floss$ cvs watch add
     floss$ cvs watchers
     README.txt      jrandom edit    unedit  commit
     foo.gif jrandom edit    unedit  commit
     hello.c jrandom edit    commit  unedit
     a-subdir/whatever.c     jrandom edit    unedit  commit
     a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit
     b-subdir/random.c       jrandom edit    unedit  commit
     floss$

El penúltimo comando hizó a jrandom un vigilante de todos los ficheros
del proyecto y el último mostró cada lista de cada fichero del proyecto.
La salida de `cvs watchers' puede que no perfectamente alineado por
columnas debido a que se mezclan tabuladores con información de
longitud variable, pero el formateo de las líneas es consistente.

     [FILENAME] [espacio en blanco] WATCHER [espacio en blanco]
     ACTIONS-BEING-WATCHED...

Observe qué pasa cuando qsmith empieza a editar uno de los ficheros:

     paste$ cvs edit hello.c
     paste$ cvs watchers
     README.txt      jrandom edit    unedit  commit
     foo.gif jrandom edit    unedit  commit
     hello.c jrandom edit    commit  unedit
            qsmith  tedit   tunedit tcommit
     a-subdir/whatever.c     jrandom edit    unedit  commit
     a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit
     b-subdir/random.c       jrandom edit    unedit  commit

El fichero hello.c tiene un nuevo vigilante: qsmith (observe que el
nombre del fichero no se repite sino que se deja un espacio en blanco
al principio de la línea; esto es importante si usted alguna vez
escribiera un programa que compila la salida de la orden).  Ya que está
editando el fichero hello.c, qsmith tendrá una "temporary watch alarma
temporal" sobre el fichero, la cual se terminará cuando haga una
entrega sobre éste.  El prefijo ð`t' delante de cada acción indica que
son alarmas termporales.  Si qsmith se añade a la lista de vigilantes
regulares de hello.c

     paste$ cvs watch add hello.c
     README.txt      jrandom edit    unedit  commit
     foo.gif jrandom edit    unedit  commit
     hello.c jrandom edit    commit  unedit
            qsmith  tedit   tunedit tcommit edit    unedit  commit
     a-subdir/whatever.c     jrandom edit    unedit  commit
     a-subdir/subsubdir/fish.c       jrandom edit    unedit  commit
     b-subdir/random.c       jrandom edit    unedit  commit

se encontrará a la vez como un vigilante temporal y un vigilante
permanente. Se puede decir que el estatus de vigilante permanente
sobrepasa al temporal. Entonces la línea sería como:

             qsmith  edit    unedit  commit

Sin embargo, CVS no puede reemplazar las alarmas temporales porque sabe
que orden ocurren las acciones. ¿Se quitará qsmith de la lista
permanente de vigilancia antes de acabar su sesión de edición?, o
¿acabará sus ediciones siendo todavía un vigilante?. En el primer caso
las acciones `edit / unedit / commit' desaparecen mientras que `tedit /
tunedit / tcommit' permanecen; en el segundo caso ocurre lo contrario.
De cualquier forma esto no será de gran importancia.  Casi siempre lo
que usted hará es ejecutar

     floss$ cvs watchers

o

     floss$ cvs editors

desde el nivel más alto para ver quién está haciendo qué. No necesita
conocer los detalles de quien está vigilando que acciones: lo
importante son las personas y los ficheros.


File: cvsbook.info,  Node: Recomendar a la gente usar alarmas,  Next: Cómo aparecen las alarmas en el repositorio,  Prev: Encontrar quién vigila qué,  Up: Alarmas (CVS como telefono)

Recomendar a la gente usar alarmas
----------------------------------

Habrá observado que el funcionamiento de las alarmas depende, en última
instancia de la colaboración de todos los desarrolladores.  Si alguien
empieza a editar un fichero sin ejecutar `cvs edit', nadie lo sabrá
hasta que los cambios se entreguen. Como `cvs edit' se usa a un nivel
superior y no está dentro de la rutina normal de desarrollo las
personas pueden olvidarse fácilmente de hacerlo.

Aunque CVS no puede forzar a alguien a usar `cvs edit', tiene un
mecanismo que es permite a recordar a los usuarios a hacerlo; la orden
`watch on':

     floss$ cvs -q co myproj
     U myproj/README.txt
     U myproj/foo.gif
     U myproj/hello.c
     U myproj/a-subdir/whatever.c
     U myproj/a-subdir/subsubdir/fish.c
     U myproj/b-subdir/random.c
     floss$ cd myproj
     floss$ cvs watch on hello.c
     floss$

Ejecutando `cvs watch' sobre hello.c, jrandom hace que futuras
obtenciones de copias de myproj hagan que hello.c sea de sólo lectura
en la copia de trabajo. Cuando qsmith intenta trabajar sobre él
comprobará que es de sólo lectura y se le recordará que debe ejecutar
primero `cvs edit':

     paste$ cvs -q co myproj
     U myproj/README.txt
     U myproj/foo.gif
     U myproj/hello.c
     U myproj/a-subdir/whatever.c
     U myproj/a-subdir/subsubdir/fish.c
     U myproj/b-subdir/random.c
     paste$ cd myproj
     paste$ ls -l
     total 6
     drwxr-xr-x   2 qsmith    users        1024 Jul 19 01:06 CVS/
     -rw-r--r--   1 qsmith    users          38 Jul 12 11:28 README.txt
     drwxr-xr-x   4 qsmith    users        1024 Jul 19 01:06 a-subdir/
     drwxr-xr-x   3 qsmith    users        1024 Jul 19 01:06 b-subdir/
     -rw-r--r--   1 qsmith    users         673 Jun 20 22:47 foo.gif
     -r--r--r--   1 qsmith    users         188 Jul 18 01:20 hello.c
     paste$

Cuando lo ha hecho, el fichero será de lectura-escritura. Entonces lo
podrá editar y cuando haga entregas, pasa a modo de sólo lectura:

     paste$ cvs edit hello.c
     paste$ ls -l hello.c
     -rw-r--r--   1 qsmith    users         188 Jul 18 01:20 hello.c
     paste$ emacs hello.c
       ...
     paste$ cvs commit -m "decir hello en arameo" hello.c
     Checking in hello.c;
     /usr/local/newrepos/myproj/hello.c,v  <--  hello.c
     new revision: 1.12; previous revision: 1.11
     done
     paste$ ls -l hello.c
     -r--r--r--   1 qsmith    users         210 Jul 19 01:12 hello.c
     paste$

Al hacer esta edición y entrega se enviarán notificaciones a todos los
vigilantes de hello.c. Observe que jranadom no es necesariamente uno de
ellos. Al ejecutar `cvs watch' sobre hello.c jrandom no se añadió
asimismo a la lista de vigilancia para ese fichero; simplemente
especificó qe se deberían obtener copias  en modo de sólo lectura. Las
personas que quieren vigilar un fichero deben añadirse a la lista de
vigilancia. CVS no puede hacer nada sobre esto.

Establecer alarmas en un simple fichero sería la excepción. Generalmente
es más común establecer las alarmas sobre un proyecto:

     floss$ cvs -q co myproj
     U myproj/README.txt
     U myproj/foo.gif
     U myproj/hello.c
     U myproj/a-subdir/whatever.c
     U myproj/a-subdir/subsubdir/fish.c
     U myproj/b-subdir/random.c
     floss$ cd myproj
     floss$ cvs watch on
     floss$

Esta acción equivale a anunciar una potitica de decisión para todo el
proyecto: _"Por favor, use cvs edit para advertir a los vigilantes en
que está trabajando y vigile cuantos ficheros le interesen o sean de su
responsabilidad."_ Cada fichero del proyecto será actualizado en modo
de sólo lectura, y así a la gente se le recordará que se espera que
usen `cvs edit' antes de trabajar en algo.

Curiosamente, aunque obtenciones de copias de ficheros vigilados se
hacen en modo de sólo lectura, las actualizaciones no lo son. Si qsmith
ha obtenido una copia de trabajo antes de que jrandom hiciera `cvs
watch' sus ficheros serían le lectura-escritura quedando así incluso
después de hacer actualizaciones. Sin embargo, cualquier fichero que
entregue después de que jrandom estableciera las alarmas será de sólo
lectura.  Si jrandom quita las alarmas:

     floss$ cvs watch off

los ficheros de sólo lectura de qsmith no se convierte mágicamente en
ficheros de lectura-escritura. Por otro lado, después de hacer una
entrega volverán a modo lectura-escritura de nuevo (como si las alarmas
todavía estuviaran puestas).

Observe que qsmith podría, si fuese malicioso, hacer los ficheros de su
copia de trabajo escribibles usando la orden estándar de Unix `chmod'
saltándose `cvs edit' por completo.

     paste$ chmod u+w hello.c

o si quisiera hacerlo todo en una pasada.

     paste$ chmod -R u+w .

No hay nada que CVS pueda hacer sobre esto. Las copias de trabajo son
por su propia naturaleza privadas. Las alarmas pueden permitir su
escrutinio al público tanto como lo permita el desarrollador.
Sólamente cuando un desarrollador hace algo que afecte al repositorio
(como una entrega) su privacidad se pierde incondicinalmente.

La relación entre `watch add', `watch remove', `watch on' y `watch off'
podría parecer confusa. Para aclarar esto resumamos  el esquema general:
`add' y `remove' sirven para añadir o quitar usuarios de la lista de
vigilancia de un fichero; no tiene nada que ver con que los ficheros
sean de sólo lectura al obtener la copia de trabajo o después de la
entrega. `on' y `off' sirven para los permisos de los ficheros. No
tienen nada que ver con la lista de vigilancia; más bien son
herramientas par ayudar a los desarrolladores a recordar la política de
alarmas haciendo que los ficheros de la copia de trabajo sean de sólo
lectura.

Todo esto parece un poco inconsistente. De algún modo el usar alarmas
parece ir en contra de la esencia de CVS. Se desvía del universo ideal
de múltiples desarrrolladores editando libremente en sus copias de
trabajo, ocultos unos de otros hasta que hacen una entrega. Con las
alarmas CVS da a los desarrolladores atajos para informarse mutuamente
lo que pasa en sus copias de trabajo. Sin embargo no tiene forma de
imponer las políticas de observación ni un concepto de que constituye
una sesión de edición. Aun así las alarmas pueden ser útiles en ciertas
ocasiones.


File: cvsbook.info,  Node: Cómo aparecen las alarmas en el repositorio,  Prev: Recomendar a la gente usar alarmas,  Up: Alarmas (CVS como telefono)

Cómo aparecen las alarmas en el repositorio
-------------------------------------------

Para acabar con las cajas negras y los misterios sin solución vamos a
hacer una rápida mirada a cómo las alarmas son implementadas en el
repositorio. Será rápido ya que no es agradable.

Cuando usted establece una alarma

     floss$ pwd
     /home/jrandom/myproj
     floss$ cvs watch add hello.c
     floss$ cvs watchers
     hello.c jrandom edit    unedit  commit
     floss$

CVS la guarda en un fichero especial, `CVS/fileattr', del subdirectorio
apropiado del repositorio.

     floss$ cd /usr/local/newrepos
     floss$ ls
     CVSROOT/   myproj/
     floss$ cd myproj
     floss$ ls
     CVS/          a-subdir/     foo.gif,v
     README.txt,v  b-subdir/     hello.c,v
     floss$ cd CVS
     floss$ ls
     fileattr
     floss$ cat fileattr
     Fhello.c        _watchers=jrandom>edit+unedit+commit
     floss$

El hecho de que fileattr sea almacenado en un subdirectorio llamado CVS
del repositorio no significa que el repositorio se haya convertido en
una copia de trabajo. Simplemente el nombre `CVS' estaba ya reservado
en la copia de trabajo para guardar información con lo que no habrá
ningún proyecto que necesite un subdirectorio con ese nombre en el
repositorio.

No describiré el formato de `fileattr' formalmente; se puede ver
bastante bien estudiando los cambios que ocurren en él entre orden y
orden.

     floss$ cvs watch add hello.c
     floss$ cat /usr/local/newrepos/myproj/CVS/fileattr
     Fhello.c        _watchers=jrandom>edit+unedit+commit
     floss$ cvs watch add README.txt
     floss$ cat /usr/local/newrepos/myproj/CVS/fileattr
     Fhello.c        _watchers=jrandom>edit+unedit+commit
     FREADME.txt     _watchers=jrandom>edit+unedit+commit
     floss$ cvs watch on hello.c
     floss$ cat /usr/local/newrepos/myproj/CVS/fileattr
     Fhello.c        _watchers=jrandom>edit+unedit+commit;_watched=
     FREADME.txt     _watchers=jrandom>edit+unedit+commit
     floss$ cvs watch remove hello.c
     floss$ cat /usr/local/newrepos/myproj/CVS/fileattr
     Fhello.c        _watched=
     FREADME.txt     _watchers=jrandom>edit+unedit+commit
     floss$ cvs watch off hello.c
     floss$ cat /usr/local/newrepos/myproj/CVS/fileattr
     FREADME.txt     _watchers=jrandom>edit+unedit+commit
     floss$

Registros de edición son almacenados en fileatrr también.  Esto es lo
que pasa cuando qsmith se añade asimismo como un editor.

     paste$ cvs edit hello.c
     
     floss$ cat /usr/local/newrepos/myproj/CVS/fileattr
     Fhello.c        _watched=;_editors=qsmith>Tue Jul 20 04:53:23 1999 GMT+floss\
     +/home/qsmith/myproj;_watchers=qsmith>tedit+tunedit+tcommit
     FREADME.txt     _watchers=jrandom>edit+unedit+commit

Finalmente, observe que CVS quita le fichero fileattr y subdirectorio
CVS cuando no hay más vigilantes o editores para cualquier fichero en
ese directorio:

     paste$ cvs unedit
     
     floss$ cvs watch off
     floss$ cvs watch remove
     floss$ cat /usr/local/newrepos/myproj/CVS/fileattr
     cat: /usr/local/newrepos/myproj/CVS/fileattr: No such file or directory
     floss$

Debe quedar claro depués de esta breve exposición que los detalles del
tratamiento del formato de fileattr se dejan a CVS. La principal razón
para tener una comprensión básica del formato, además de la satisfacción
inherente de saber que es lo que ocurre detrás de las cortinas, es si
usted va a escribir una extensión a las alarmas de CVS, o está
depurando algún error en ellas. Es suficiente con que no se alarme si ve
CVS/ subdirectorios apareciendo y desapareciendo de su repositorio.
Son los únicos lugares seguros que CVS tiene para almacenar
meta-información como las listas de vigilancia.


File: cvsbook.info,  Node: Mensajes log y correos electrónicos a la entrega,  Next: Cambiar un mensaje log después de una entrega,  Prev: Alarmas (CVS como telefono),  Up: CVS avanzado

Mensajes log y correos electrónicos a la entrega
================================================

Los correos electrónicos a la entrega son enviados cuando se hace una
entrega y muestran el mensaje log y los ficheros involucrados en ésta.
Normalmente van para todos los partipantes en el proyecto y algunas
veces para otras partes interesadas. Los detalles para establecer
correos a la entrega son cubiertos en *Note Administracion del
Repositorio::, por lo que no los repetiremos aquí. He observado, sin
embargo, algunos efectos inesperados en los proyectos. Efectos que
usted debería tener en cuenta si estable correos electrónicos a la
entrega.

Prepárese para que la mayoría de los mensajes sean ignorados. Que se
lean o no dependerá, al menos en parte, en la frecuencia con que se
hagan entregas en su proyecto. ¿Entregan los desarrolladores un cambio
grande al final de día, o hacen pequeños cambios durante la jornada? En
el último caso los desarrolladores recibirán más mensajes y es problabe
que presten menos atención a ellos.

Esto no significa que los mensajes no son útiles, sino que no debe
contar con que cada persona va a leer cada mensaje. Es un modo
conveniente de para las personas de mantener información de quién está
haciendo qué (sin la intrusión de las alarmas). Cuando los correos van
a una lista de correos pública subscribible son un mecanismo
maravilloso para dar a usuarios interesados (y futuros desarrolladores)
una oportunidad para ver lo que ocurre en el código a nivel básico.

Podría tener un desarrollador designado para vigilar todos los mensajes
log y tener un visión general de la actividad en todo el proyecto (por
supuesto, un buen jefe de proyectos estará probablemente haciendo esto).
Si hay una clara división de responsabilidades, es decir, ciertos
desarrolladores están a cargo de algún subdirectorio del proyecto, usted
podría usar algún lenguaje interpretado sobre CVSROOT/loginfo para que
cada responsable reciba notificaciones especiales de cambios hechos en
su área. Esto aseguraría que los desarrolladores leen al menos los
correos involucrados en sus subdirectorios.

Un interesante efecto que surge cuando los correos no son ignorados.
La gente empieza a usarlos como un método de comunicación en tiempo
real.  Ésta es la clase de mensaje log que podría resultar:

     Acabada la forma de retroalimentación; arreglados los colores de las
     fuentes y el fondo. Bien, ¿alguien quiere almorzar en 'Los claveles'?

No hay nada malo en esto y hace los mensajes log más entretenidos cuando
se repasan más tarde. Sin embargo hay que ser consciente de que los
mensajes log se guardan para siempre en el historial del proyecto. Por
ejemplo, quejarse de las especificaciones de un cliente es un
pasatiempo entre los programadores; no es dificil imaginar a alguien
entregando un mensaje log como éste, sabiendo que otros programadores
lo verán en su correo:

     Cambiar los cuatro digitos del año por dos en la salida. Lo que el
     cliente pide, el cliente recibe, no importa lo estúpido y malo que sea.

Esto hace los correos más divertidos pero, ¿qué ocurriría si el cliente
revisara los mensajes log? (Apostaría a que debido a esto más de un
sitio ha configurado su CVSROOT/loginfo para que invoque scripts que
matengan libre de palabras ofensivas los mensajes log.)

El efecto global de los correos a la entraga sería que la gente no
escribe mensajes log demasiandos cortos o complicados, lo cual está
bien. Sin embargo hay que recordar que su audiencia no son sólo la gente
que recibe los correos sino cualquiera que pudiera leer estos mensajes
log.


File: cvsbook.info,  Node: Cambiar un mensaje log después de una entrega,  Next: Deshacerse de una copia de trabajo,  Prev: Mensajes log y correos electrónicos a la entrega,  Up: CVS avanzado

Cambiar un mensaje log después de una entrega
=============================================

Por si alguien escribe un mensaje log deplorable, CVS permite que éste
se puede reescribier después de que se haya entregado. Se hace con el
indicador -m de la orden admit (esta orden se verá en más detalle más
adelante) y permite cambiar un mensaje log (por revisión, por fichero)
cada vez.  Así es como funciona:

     floss$ cvs admin -m 1.7:"Cambiar cuatro dígitos del año por dos en la
     salida." date.c
     RCS file: /usr/local/newrepos/someproj/date.c,v
     done
     floss$

El mensaje ofensivo original que fue entregado en la revisión 1.7 ha
sido reemplazado por uno más inocente (aunque también más soso).  No
olvide los dos puntos separando el número de revisión del nuevo mensaje
log.

Si el mensaje original fue entregado en múltiples fichros, tendrá que
ejecurar `cvs admit' para cada uno de ellos, porque el número de
revisión será distinto en cada fichero. Así, esta es una de las pocas
órdenes en las que CVS requiere que se pase como argumento el nombre de
un fichero:

     floss$ cvs admin -m 1.2:"mensaje log muy aburrido" hello.c REAME.txt foo.gif
     cvs admin: while processing more than one file:
     cvs [admin aborted]: attempt to specify a numeric revision
     floss$

Obtendría el mismo error si no le pasa ningún nombre de fichero. Parace
confuso pero la razón es que CVS asumiría como argumentos implícitos
todos los ficheros de directorio actual.

     floss$ cvs admin -m 1.2:"mensaje log muy aburrido"
     cvs admin: while processing more than one file:
     cvs [admin aborted]: attempt to specify a numeric revision
     floss$

Desgraciadamente esto lo encontramos a menudo en los mensajes de error.
Usted debe ver las cosas desde el punto de vista de CVS para que los
mensajes tengan sentido.

Invocar `admin -m' cambia el historial del proyecto por lo que debe
usarlo con cuidado. No habrá forma de saber que un mensaje log fue
cambiado alguna vez. Parecerá como si esa revisión fue entregada con el
nuevo mensaje. No quedará huella del mensaje antiguo en ningún sitio (a
no ser que salve el correo que se entregó la primera vez).

Aunque por su nombre pueda parecer que sólo administradores designados
de CVS pueden usarlo cualquiera puede ejecutar `cvs admin' si tiene
acceso de escritura en el proyecto.  Sin embargo, es mejor usarlo con
cuidado; la habilidad de cambiar el historial de un proyecto es poca
comparado con el daño potencial que se puede hacer. Vea *Note
Referencia de CVS:: para saber más sobre `admin' y también como
restringir su uso.


File: cvsbook.info,  Node: Deshacerse de una copia de trabajo,  Next: Historial -- Un resumen de la actividad del repositorio,  Prev: Cambiar un mensaje log después de una entrega,  Up: CVS avanzado

Deshacerse de una copia de trabajo
==================================

En un uso típico de CVS, el modo de deshacerse del directorio que
contiene una copia de trabajo es quitarlo como se haría con cualquier
árbol de directorios:

     paste$ rm -rf myproj

Sin embargo al hacerlo de esta manera otros desarrolladores no sabrán
que ha dejado de trabajar en él. CVS proporciona una orden para dejar
una copia de trabajor explícitamente. Piense de un lanzamiento como lo
contrario de una entrega; usted le dice al repositorio que ya ha hecho
su trabajo con la copia de trabajo. Como la entrega, el lanzamiento es
invocado desde el directorio padre del arbol.

     paste$ pwd
     /home/qsmith/myproj
     paste$ cd ..
     paste$ ls
     myproj
     paste$ cvs release myproj
     You have [0] altered files in this repository.
     Are you sure you want to release directory 'myproj': y
     paste$

(Usted tiene [0] ficheros alterados en este repositorio, Está seguro de
que quiere lanzarlos (y borrar) el directorio 'myproj': si

Por ahora la versión 1.10.6 no permite que la orden `release' deduzca
la localización del repositorio examinando la copia de trabajo ya que
`release' es invocado fuera de la copia de trabajo no dentro de ella.
Usted debe pasar la opición global  `-d <REPOS>' o asegurarse que la
variable de entorno CVSROOT está correcta. (Esto se podría arreglar en
futuras versiones.)

Cederqvist afirma que si se usa `release' en vez de borrar el
directorio de trabajo, la gente que vigila los ficheros liberados será
notificada como si hubieran ejecutado `unedit'. Lo he probado
experimentalmente y parece que no es verdad.


File: cvsbook.info,  Node: Historial -- Un resumen de la actividad del repositorio,  Next: Anotaciones -- Sumario detallado de la actividad del proyecto,  Prev: Deshacerse de una copia de trabajo,  Up: CVS avanzado

Historial - Un resumen de la actividad del repositorio
======================================================

En *Note Administracion del Repositorio:: comenté brebemente la orden
`history'.  Ésta orden muestra un resumen de todos las obtenciones
_checkouts_, entregas _commits_, actualizaciones _updates_, etiquetas
_rtags_, y entregas finales _releases_ hechos en el repositorio (al
menos, desde que `logging' fue activado mediante la creación del
fichero CVSROOT/history en el repositorio). Puede controlar el formato y
contenidos del resumen con varias optciones.

El primer paso es asegurarse que `logging' esta activo en su
repositorio.  El administrador del repositorio debe asegurarse de que
existe un fichero history

     floss$ cd /usr/local/newrepos/CVSROOT
     floss$ ls -l history
     ls: history: No such file or directory
     floss$

y si no exite crearlo de la siguiente forma:

     floss$ touch history
     floss$ ls -l history
     -rw-r--r--   1 jrandom   cvs           0 Jul 22 14:57 history
     floss$

Este para el historial, `history' debe ser escribible por cualquiera que
use el repositorio ya que de otra forma se obtendrá un error cada vez
que ejecute alguna orden de CVS que modifique ese fichero. La foram más
simple es hacer el fichero escribible por todo el mundo:

     floss$ chmod a+rw history
     floss$ ls -l history
     -rw-rw-rw-   1 jrandom   cvs           0 Jul 22 14:57 history
     floss$

Si el repositorio fue creado con la orden `cvs init', el fichero
`history' ya existirá. Tal vez que tuviese que arreglar los permisos de
escritura.

Se asume en el resto de los ejemplos que `history logging' se ha
activado durante un tiempo y por lo tanto ha habido tiempo para alguna
información se haya acumulado en el historial (fichero `history').

La salida de `cvs history' es en cierta forma dificil (probablemente se
creó pensando en que se tratataría mediante otros programas y no
mediante personas, aunque con un poco de estudio se puede leer).
Ejecutémoslo y veamos lo que obtenemos.

     paste$ pwd
     /home/qsmith/myproj
     paste$ cvs history -e -a
     O 07/25 15:14 +0000 qsmith  myproj =mp=     ~/*
     M 07/25 15:16 +0000 qsmith  1.14 hello.c    myproj == ~/mp
     U 07/25 15:21 +0000 qsmith  1.14 README.txt myproj == ~/mp
     G 07/25 15:21 +0000 qsmith  1.15 hello.c    myproj == ~/mp
     A 07/25 15:22 +0000 qsmith  1.1  goodbye.c  myproj == ~/mp
     M 07/25 15:23 +0000 qsmith  1.16 hello.c    myproj == ~/mp
     M 07/25 15:26 +0000 qsmith  1.17 hello.c    myproj == ~/mp
     U 07/25 15:29 +0000 qsmith  1.2  goodbye.c  myproj == ~/mp
     G 07/25 15:29 +0000 qsmith  1.18 hello.c    myproj == ~/mp
     M 07/25 15:30 +0000 qsmith  1.19 hello.c    myproj == ~/mp
     O 07/23 03:45 +0000 jrandom myproj =myproj= ~/src/*
     F 07/23 03:48 +0000 jrandom        =myproj= ~/src/*
     F 07/23 04:06 +0000 jrandom        =myproj= ~/src/*
     M 07/25 15:12 +0000 jrandom 1.13 README.txt myproj == ~/src/myproj
     U 07/25 15:17 +0000 jrandom 1.14 hello.c    myproj == ~/src/myproj
     M 07/25 15:18 +0000 jrandom 1.14 README.txt myproj == ~/src/myproj
     M 07/25 15:18 +0000 jrandom 1.15 hello.c    myproj == ~/src/myproj
     U 07/25 15:23 +0000 jrandom 1.1  goodbye.c  myproj == ~/src/myproj
     U 07/25 15:23 +0000 jrandom 1.16 hello.c    myproj == ~/src/myproj
     U 07/25 15:26 +0000 jrandom 1.1  goodbye.c  myproj == ~/src/myproj
     G 07/25 15:26 +0000 jrandom 1.17 hello.c    myproj == ~/src/myproj
     M 07/25 15:27 +0000 jrandom 1.18 hello.c    myproj == ~/src/myproj
     C 07/25 15:30 +0000 jrandom 1.19 hello.c    myproj == ~/src/myproj
     M 07/25 15:31 +0000 jrandom 1.20 hello.c    myproj == ~/src/myproj
     M 07/25 16:29 +0000 jrandom 1.3  whatever.c myproj/a-subdir == ~/src/myproj
     paste$

¿No está claro?

Antes de examinar la salida, observe que la orden incluye dos opciones:
-e y -a. Cuando usted ejecuta `histoy', casi siempre le pasará opciones
para indicar que datos y en que formato los verá. En esto difiere de la
mayoria de las órdenes de CVS, que normalmente hacen cosas útiles sin
necesidad de opciones. En este ejemplo, los dos indicadores significan
respectivamente "todas las cosas" (del inglés _everything_), que muestra
todas las claves de eventos que han ocurrido, y "todo" (del inglés
_all_), por todos los usuarios.

Otro modo en que `history' se diferencia de otros comandos es que,
aunque normalmente se invoca dentro de una copia de trabajo, no sólo
está restringida su salida a esa copia del projecto sino que también
muestra todo el historial de eventos de todos los proyectos del
repositorio. La copia de trabajo sólo indica a CVS desde que
repositorio conseguir los datos del historial. (En el ejemplo anterior,
los únicos datos de historial de ese repositorio son los del proyecto
`myproj', por lo tanto eso es lo que vemos.)

El formato general de salida es:

     CÓDIGO FECHA_Y_HORA USUARIO [REVISION] [FICHERO] DIRECTORIO_DEL_REPOSITORIO
     NOMBRE_DEL_DIRECTORIO_DE_TRABAJO

Aunque la salida de esta orden fue diseñado para ser compacto y usado
como entrado por otros programas, CVS le da bastante control sobre su
contenido.  Las opciones mostradas en la Tabla 6.2 controlan sobre que
tipos de eventos se informa.

     Tabla 6.1  Significado del código de las letras.
     
     Letra	        Significado
     ======          =========================================================
     O		Obtener
     T		Tag
     F		Entrega final
     W		Actualizar (no de un fichero de usuario, eliminación en las
                     entradas del fichero)
     U		Actualizar (fichero sobrescribe un fichero de usuario
                     no modificado)
     G		Actualizar (fichero fusionado exitosamente con un fichero
                     modificado de usuario)
     C		Actualizar (fichero fusionado, pero existen conflictos con
                     fichero de usuario)
     M		Entregar (de un fichero modificado)
     A		Entregar (un fichero añadido)
     R		Entregar (el borrado de un fichero)
     E		Exportar

     Tabla 6.2  Opciones de filtrado sobre tipo de evento.
     
     Opción	        Significado
     ==========      =========================================================
     -m MODULO	Muestra eventos del historial que afecten a MODULO
     -c		Muestra las entregas.
     -o		Muestra las obtenciones.
     -T		Muestra los tag.
     -x CODE(S)	Muestra los eventos de tipo CODE (uno o más de OTFWUGCMARE).
     -e		Muestra todos los eventos. Una ver seleccionados los tipos
                     de eventos se puede filtrar más con las opciones de la
                     Tabla 6.3.

     Tabla 6.3  Opciones a filtrar por el usuario.
     
     Opción	        Significado
     ==========      =========================================================
     -a		Muestra las acciones hechas por todos los usuarios
     -w              Muestra sólo las acciones hechas dentro de la copia de
                     trabajo.
     -l		Muestra sólo la última vez que este usuario realizó la
                     acción
     -u USUARIO      Muestra los registros para USUARIO


File: cvsbook.info,  Node: Anotaciones -- Sumario detallado de la actividad del proyecto,  Next: Anotaciones y ramificaciones,  Prev: Historial -- Un resumen de la actividad del repositorio,  Up: CVS avanzado

Anotaciones - Sumario detallado de la de la actividad del proyecto
==================================================================

La orden `annotaded'
====================

Mientras que la orden `history' da una visión general sobre la
actividad del proyecto, "annotate" es un modo de acercarse con más
detalle a esa visión. Con `annotate' usted puede ver quién fue la
última perosna que tocó cada línea de un fichro, y en que revisión se
hizó.

     floss$ cvs annotate
     Annotations for README.txt
     ***************
     1.14         (jrandom  25-Jul-99): blah
     1.13         (jrandom  25-Jul-99): test 3 for history
     1.12         (qsmith   19-Jul-99): test 2
     1.11         (qsmith   19-Jul-99): test
     1.10         (jrandom  12-Jul-99): blah
     1.1          (jrandom  20-Jun-99): Just a test project.
     1.4          (jrandom  21-Jun-99): yeah.
     1.5          (jrandom  21-Jun-99): nope.
     Annotations for hello.c
     ***************
     1.1          (jrandom  20-Jun-99): #include <stdio.h>
     1.1          (jrandom  20-Jun-99):
     1.1          (jrandom  20-Jun-99): void
     1.1          (jrandom  20-Jun-99): main ()
     1.1          (jrandom  20-Jun-99): {
     1.15         (jrandom  25-Jul-99):   /* another test for history */
     1.13         (qsmith   19-Jul-99):   /* random change number two */
     1.10         (jrandom  12-Jul-99):   /* test */
     1.21         (jrandom  25-Jul-99):   printf ("Hellooo, world!\n");
     1.3          (jrandom  21-Jun-99):   printf ("hmmm\n");
     1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n");
     1.11         (qsmith   18-Jul-99):   /* added this comment */
     1.16         (qsmith   25-Jul-99):   /* will merge these changes */
     1.18         (jrandom  25-Jul-99):   /* will merge these changes too */
     1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n");
     1.1          (jrandom  20-Jun-99): }
     Annotations for a-subdir/whatever.c
     ***************
     1.3          (jrandom  25-Jul-99): /* A completely non-empty C file. */
     Annotations for a-subdir/subsubdir/fish.c
     ***************
     1.2          (jrandom  25-Jul-99): /* An almost completely empty C file. */
     Annotations for b-subdir/random.c
     ***************
     1.1          (jrandom  20-Jun-99): /* A completely empty C file. */
     floss$

La salida de `annotate' es bastante intuitiva. A la izquiera está el
número de revisión, desarrollador, y la fecha en que esa línea fué
añadida o modificada. A la derecha está la línea en questión en su
actual versión. Como cada línea es comentado se puede ver el contenido
entero del fichero a la derecha de la información anotada.

Si especifica un número de revisión, las anotaciones son dadas para esa
revisión lo cual quiere decir que se muestran la más reciente
modificacione para cada línea a esa o una anterior revisión. Este es
probablemente el modo más comunmente usado. Se examina una revision
particular de un fichero para determinar que desarrolladores estaban
activos en cada parte de un fichero.

En el ejemplo anterior se puede ver que la más reciente revisión de
hello.c es la 1.21, en la que jrandom hizo algo en la línea:

     printf ("Hellooo, world!\n");

Un modo de ver lo que ella hizo es usar `diff' de esa revisión con la
anterior:

     floss$ cvs diff -r 1.20 -r 1.21 hello.c
     Index: hello.c
     ===================================================================
     RCS file: /usr/local/newrepos/myproj/hello.c,v
     retrieving revision 1.20
     retrieving revision 1.21
     diff -r1.20 -r1.21
     9c9
     <   printf ("Hello, world!\n");
     --
     >   printf ("Hellooo, world!\n");
     floss$

Otro modo de verlo manteniendo la amplia visión de la actividad de cada
uno es comparando las actuales anotaciones con las anotaciones de una
revisión anterior:

     floss$ cvs annotate -r 1.20 hello.c
     Annotations for hello.c
     ***************
     1.1          (jrandom  20-Jun-99): #include <stdio.h>
     1.1          (jrandom  20-Jun-99):
     1.1          (jrandom  20-Jun-99): void
     1.1          (jrandom  20-Jun-99): main ()
     1.1          (jrandom  20-Jun-99): {
     1.15         (jrandom  25-Jul-99):   /* another test for history */
     1.13         (qsmith   19-Jul-99):   /* random change number two */
     1.10         (jrandom  12-Jul-99):   /* test */
     1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n");
     1.3          (jrandom  21-Jun-99):   printf ("hmmm\n");
     1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n");
     1.11         (qsmith   18-Jul-99):   /* added this comment */
     1.16         (qsmith   25-Jul-99):   /* will merge these changes */
     1.18         (jrandom  25-Jul-99):   /* will merge these changes too */
     1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n");
     1.1          (jrandom  20-Jun-99): }
     floss$

Aunque el `diff' muestra los cambios sobre el texto de forma más
concisa, la anotación puede ser preferible ya que coloca estos cambios
en su contexto histórico al mostrar desde cuando ha estado presente esa
línea (en este caso desde la revisión 1.1). Ese conocimiento puede
ayudarle a decidir si mirar en los mensajes log para averiguar los
motivos del cambio:

     floss$ cvs log -r 1.21 hello.c
     RCS file: /usr/local/newrepos/myproj/hello.c,v
     Working file: hello.c
     head: 1.21
     branch:
     locks: strict
     access list:
     symbolic names:
            random-tag: 1.20
            start: 1.1.1.1
            jrandom: 1.1.1
     keyword substitution: kv
     total revisions: 22;    selected revisions: 1
     description:
     ----------------------------
     revision 1.21
     date: 1999/07/25 20:17:42;  author: jrandom;  state: Exp;  lines: +1 -1
     say hello with renewed enthusiasm
     ============================================================================
     floss$

Además de la opción -r, se puede filtrar las anotaciones con la opción
-D DATE:

     floss$ cvs annotate -D "5 weeks ago" hello.c
     Annotations for hello.c
     ***************
     1.1          (jrandom  20-Jun-99): #include <stdio.h>
     1.1          (jrandom  20-Jun-99):
     1.1          (jrandom  20-Jun-99): void
     1.1          (jrandom  20-Jun-99): main ()
     1.1          (jrandom  20-Jun-99): {
     1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n");
     1.1          (jrandom  20-Jun-99): }
     floss$ cvs annotate -D "3 weeks ago" hello.c
     Annotations for hello.c
     ***************
     1.1          (jrandom  20-Jun-99): #include <stdio.h>
     1.1          (jrandom  20-Jun-99):
     1.1          (jrandom  20-Jun-99): void
     1.1          (jrandom  20-Jun-99): main ()
     1.1          (jrandom  20-Jun-99): {
     1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n");
     1.3          (jrandom  21-Jun-99):   printf ("hmmm\n");
     1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n");
     1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n");
     1.1          (jrandom  20-Jun-99): }
     floss$


File: cvsbook.info,  Node: Anotaciones y ramificaciones,  Next: Usando expansión de palabras,  Prev: Anotaciones -- Sumario detallado de la actividad del proyecto,  Up: CVS avanzado

Anotaciones y ramificaciones
============================

Por defecto, las anotaciones muestran siempren la actividad de la rama
principal de desarrollo. Incluso aunque se llame desde una copia de
trabajo derivada se muestra las anotaciones de la rama principal a
menos que se especifique lo contrario. (Dependiendo de su punto de
vista esta tendencia de favorecer el tronco principal se puedría
considerar un error o una característica.) Puede anotar una
ramificación o derivación pasando el nombre de ésta como argumento de
-r. He aquí un ejemplo de una copia de trabajo cuyo fichero hello.c
está en una derivación llamada `Brancho_Gratuito', con al menos un
cambio entregado en esa rama:

     floss$ cvs status hello.c
     ===================================================================
     File: hello.c           Status: Up-to-date
     
       Working revision:    1.10.2.2        Sun Jul 25 21:29:05 1999
       Repository revision: 1.10.2.2        /usr/local/newrepos/myproj/hello.c,v
       Sticky Tag:          Brancho_Gratuito (branch: 1.10.2)
       Sticky Date:         (none)
       Sticky Options:      (none)
     
     floss$ cvs annotate hello.c
     Annotations for hello.c
     ***************
     1.1          (jrandom  20-Jun-99): #include <stdio.h>
     1.1          (jrandom  20-Jun-99):
     1.1          (jrandom  20-Jun-99): void
     1.1          (jrandom  20-Jun-99): main ()
     1.1          (jrandom  20-Jun-99): {
     1.10         (jrandom  12-Jul-99):   /* test */
     1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n");
     1.3          (jrandom  21-Jun-99):   printf ("hmmm\n");
     1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n");
     1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n");
     1.1          (jrandom  20-Jun-99): }
     floss$ cvs annotate -r Brancho_Gratuito hello.c
     Annotations for hello.c
     ***************
     1.1          (jrandom  20-Jun-99): #include <stdio.h>
     1.1          (jrandom  20-Jun-99):
     1.1          (jrandom  20-Jun-99): void
     1.1          (jrandom  20-Jun-99): main ()
     1.1          (jrandom  20-Jun-99): {
     1.10         (jrandom  12-Jul-99):   /* test */
     1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n");
     1.10.2.2     (jrandom  25-Jul-99):   printf ("hmmmmm\n");
     1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n");
     1.10.2.1     (jrandom  25-Jul-99):   printf ("added this line");
     1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n");
     1.1          (jrandom  20-Jun-99): }
     floss$

También puede pasar el número de la ramificación:

     floss$ cvs annotate -r 1.10.2 hello.c
     Annotations for hello.c
     ***************
     1.1          (jrandom  20-Jun-99): #include <stdio.h>
     1.1          (jrandom  20-Jun-99):
     1.1          (jrandom  20-Jun-99): void
     1.1          (jrandom  20-Jun-99): main ()
     1.1          (jrandom  20-Jun-99): {
     1.10         (jrandom  12-Jul-99):   /* test */
     1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n");
     1.10.2.2     (jrandom  25-Jul-99):   printf ("hmmmmm\n");
     1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n");
     1.10.2.1     (jrandom  25-Jul-99):   printf ("added this line");
     1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n");
     1.1          (jrandom  20-Jun-99): }
     floss$

o el número de revisión completo de la ramificación:

     floss$ cvs annotate -r 1.10.2.1 hello.c
     Annotations for hello.c
     ***************
     1.1          (jrandom  20-Jun-99): #include <stdio.h>
     1.1          (jrandom  20-Jun-99):
     1.1          (jrandom  20-Jun-99): void
     1.1          (jrandom  20-Jun-99): main ()
     1.1          (jrandom  20-Jun-99): {
     1.10         (jrandom  12-Jul-99):   /* test */
     1.1          (jrandom  20-Jun-99):   printf ("Hello, world!\n");
     1.3          (jrandom  21-Jun-99):   printf ("hmmm\n");
     1.4          (jrandom  21-Jun-99):   printf ("double hmmm\n");
     1.10.2.1     (jrandom  25-Jul-99):   printf ("added this line");
     1.2          (jrandom  21-Jun-99):   printf ("Goodbye, world!\n");
     1.1          (jrandom  20-Jun-99): }
     floss$

Si hace esto, recuerde que los números son sólo válidos parar ese
fichero particualr. En general es mejor usar el nombre de esa
ramificación si ello es posible.

