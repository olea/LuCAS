@c ---------------------------------------------------------------------
@node Referencia de CVS
@unnumbered Referencia de CVS
@cindex CVS reference
@cindex reference (CVS)

This chapter is a complete reference to CVS commands, repository
administrative files, keyword substitution, run control files, working
copy files, and environment variables -- everything in CVS as of CVS
version 1.10.7 (more accurately, as of August 20, 1999).

@menu
* Ordenes y Opciones::                  Todos las opciones y ordenes CVS globales
* Claves de Sustitucion (Claves RCS)::  CVS puede mantener texto por vd.
* Ficheros de Administracion del Repositorio::      Ficheos en el lado del servidor que afecta a CVS.
* Ficheros de Control de Ejecucion::                    Ficheros en el lado del cliente que afectan a CVS.
* Working Copy Files::                   Administrivia in the working copy.
* Environment Variables::                Environment variables affecting CVS.
@end menu

@c ----------------------------------------------------------------------
@node Ordenes y Opciones
@section Ordenes y Opciones
@cindex command reference

Esta sección es una referencia de todos los mandatos CVS. Si usted no está
familiarizado con las convenciones sintácticas compartidas por la mayoría
de los mandatos CVS, se sugiere leer las subsecciones relevantes antes de
echar un vistazo a cualquier mandato en particular.

@menu
* Organización y Convenciones::             Cómo leer esta sección.
* Patrones Generales En Los Mandatos CVS::    Los mandatos CVS comparten algunas propiedades.
* Formatos de Fecha::                         CVS acepta una variedad de formatos de fecha.
* Opciones Globales::                         Una lista de todas las opciones globales de CVS.
* add::                                       Mandato @code{add}.
* admin::                                     Mandato @code{admin}.
* annotate::                                  Mandato @code{annotate}.
* checkout::                                  Mandato @code{checkout}.
* commit::                                    Mandato @code{commit}.
* diff::                                      Mandato @code{diff}.
* edit::                                      Mandato @code{edit}.
* editors::                                   Mandato @code{editors}.
* export::                                    Mandato @code{export}.
* gserver::                                   Mandato @code{gserver}.
* import::                                    Mandato @code{import}.
* init::                                      Mandato @code{init}.
* kserver::                                   Mandato @code{kserver}.
* log::                                       Mandato @code{log}.
* login::                                     Mandato @code{login}.
* logout::                                    Mandato @code{logout}.
* pserver::                                   Mandato @code{pserver}.
* rdiff::                                     Mandato @code{rdiff}.
* release::                                   Mandato @code{release}.
* remove::                                    Mandato @code{remove}.
* rtag::                                      Mandato @code{rtag}.
* server::                                    Mandato @code{server}.
* status::                                    Mandato @code{status}.
* tag::                                       Mandato @code{tag}.
* unedit::                                    Mandato @code{unedit}.
* update::                                    Mandato @code{update}.
* watch::                                     Mandato @code{watch}.
* watchers::                                  Mandato @code{watchers}.
@end menu

@c ---------------------------------------------------------------------
@node Organización y Convenciones
@subsection Organización y Convenciones

Esta sección está organizada alfabéticamente para hacerle fácil
encontrar un mandato u opción particular. Las siguiente convenciones
son usadas:

@itemize

@item
Los argumentos a mandatos y opciones tienen todos sus caracteres en
may\'usculas en la sinopsis que encabeza cada explicación.  (Nota: en
la versión treeware del libro, los meta-argumentos están en cursiva
además de estar en mayúsculas; debido a la limitación de las fuentes
estándar de terminal, he omitido la cursiva aquí).

@item
Los ítems opcionales aparecen entre corchetes: @code{[ ]}.
(Esto funciona correctamente porque los corchetes no son usados
en la sintaxis de CVS).

@item
Si debe elegir una opción de una lista, las elecciones se separan por
barras, como esto: @code{x|y|z}. (Y, por tanto, las barras (@code{/})
se deberían interpretar literalmente -- no dividen elecciones
de una lista).

@item
Los plurales y los puntos suspensivos indican múltiples opciones,
usualmente separadas por espacio. Por ejemplo, FILES significa uno o
más ficheros, pero [FILES] significa cero o más ficheros. La
entrada [&MOD...] significa un ampersand seguido inmediatamente
por el nombre de un módulo, depués espacio, después tal vez
otro ampersand-módulo, y así sucesivamente, cero o más veces.
(Los puntos suspensivos se usan porque un plural podría no dejar
claro si el ampersand se necesita sólo la primera vez o todas para
cada módulo).

Cuando un plural está entre paréntesis, como en FILE(S), significa
que aunque técnicamente puede haber dos o más ficheros, usualmente
sólo hay uno.

@item
REV se utiliza habitualmente para referir a un argumento de revisión.
Esto es normalmente, bien un número de revisión, bien un nombre de
etiqueta. Hay pocos sitios en CVS en que puede usar uno, pero no el otro,
y estos sitios están señalados en el texto.

@end itemize

@c ----------------------------------------------------------------------
@node Patrones Generales En Los Mandatos CVS
@subsection Patrones Generales En Los Mandatos CVS

Los mandatos de CVS poseen este formato:

@example
cvs [OPCIONES_GLOBALES] MANDATO [OPCIONES] [FICHEROS]
@end example

El segundo juego de opciones se llama a veces @dfn{opciones de mandato}.
Debido a que hay tantos, sin embargo, lo llamaré simplemente "opciones"
en la mayoría de los sitios para ahorrar espacio.

Muchos mandatos están pensados para ejecutarse en la copia de trabajo y,
por tanto, pueden ser invocados sin argumentos de fichero. Estos mandatos
se ejecutarán en todos los ficheros del directorio actual e
inferiores. Así, cuando me refiera al "fichero" o "ficheros" en
el texto, estoy hablando acerca de los ficheros en los que CVS actúa.
Dependiendo de cómo invoca CVS, estos ficheros pueden, o no, haber
sido mencionados explícitamente en la línea de mandatos.

@c ----------------------------------------------------------------------
@node Formatos de Fecha
@subsection Formatos de Fecha

Muchas opciones toman un argumento de fecha. CVS acepta una gran variedad
de formatos de fecha -- demasiados para ser listados aquí. Cuando dude,
use el formato estándar ISO 8601:

@example
1999-08-23
@end example

Esto significa "23 de agosto de 1999" (de hecho, en inglés "23 August
1999" es una especificador de fecha perfectamente válido también,
siempre y cuando recuerde encerrarlo entre comillas). Si necesita
la hora de un día también, puede hacer esto:

@example
"1999-08-23 21:20:30 CDT"
@end example

Puede incluso usar ciertas construcciones en inglés, como "now" (hoy),
"yesterday" (ayer), y "12 days ago" (hace doce días). En general,
puede experimentar con seguridad con formatos de fecha; si CVS entiende
su formato, muy fácilmente lo entenderá en el modo en que usted
trataba de expresarlo. Si no lo entiende, saldrá con un error
inmediatamente.

@c ----------------------------------------------------------------------
@node Opciones Globales
@subsection Opciones Globales

Aquí están todas las opciones globales de CVS.

@heading @code{--allow-root=REPOSITORY}

La primera opción global alfabéticamente es una que no se usa nunca
en la línea de mandatos. La opción --alow-root se usa con el
mandato @code{pserver} para permitir acceso acreditado al repositorio
dicho (que es el nivel alto de un repositorio, como
@file{/usr/local/newrepos}, no un subdirectorio de proyecto como
@file{/usr/local/newrepos/myproj}).

Esta opción global no se usa virtualmente nunca en la línea
de mandatos. Normalmente el único sitio donde lo usaría
es en los ficheros @file{/etc/inetd.conf} (ver @ref{Administracion del
Repositorio}), que es también casi el único sitio donde el mandato
@code{pserver} se usa.

Cada repositorio a ser accedido vía @w{@code{cvs pserver}} en un
servidor dado, necesita la correspondiente opción --allow-root en
@file{/etc/inetd.conf}. Éste es un dispositivo de seguridad, pensado
para asegurar que cualquiera no puede usar un pserver de CVS para 
conseguir acceso a repositorios privados.

(Ver @ref{El servidor de autentificacion de contrasen~as} también en el nodo
@cite{Servidor Acreditado por Clave} en el manual Cederqvist.)

@heading @code{-a}

Esto acredita todas las comunicaciones con el servidor. Esta opción
no tiene efecto a no ser que se esté conectado vía servidor
GSSAPI (gserver). Las conexiones GSSAPI no se cubren en este libro, porque
son todavía usadas raramente (aunque esto puede cambiar). (Ver
las notas @cite{Opciones Globales} y @cite{Acreditación GSSAPI} en el
manual Cederqvist para obtener más información.)

@heading @code{-b} (Caído en desuso)

Esta opción especifica formalmente el directorio donde los
ejecutables del RCS se encuentran. CVS ahora implementa las
funciones RCS internamente, por lo que esta opción no surte
efecto (se mantiene sólo por compatibilidad retrospectiva).

@heading @w{@code{-d} REPOSITORIO}

Esto especifica el repositorio, que puede ser una ruta absoluta o
una expresión más compleja involucrando método de conexión,
nombre de usuario, servidor y ruta. Si es una expresión especificando
un método de conexión, la sintaxis general es:

@example
:MÉTODO:USUARIO@@NOMBRE_DEL_SERVIDOR:RUTA_AL_REPOSITORIO
@end example

Aquí hay ejemplos usando cada uno de los métodos de conexión:

@itemize

@item
@code{:ext:jcualquiera@@floss.red-bean.com:/usr/local/newrepos} -- Conecta
usando @code{rsh}, @code{ssh}, o algún otro programa de conexión
externo. Si la variable de entorno @code{$CVS_RSH} no está
especificada, la opción por omisión es @code{rsh}; de otro modo, usa
el valor de esta variable.

@item
@code{:server:jcualquiera@@floss.red-bean.com:/usr/local/newrepos} -- Como
@code{:ext:}, pero usa la implementación interna de rsh. (Esto puede
no estar disponible en todas las plataformas.)

@item
@code{:pserver:jcualquiera@@floss.red-bean.com:/usr/local/newrepos} --
Conecta usando el servidor de acreditación de claves (ver
@ref{El servidor de autentificacion de contrasen~as} en @ref{Administracion
del Repositorio}; ver también el mandato @ref{login}.)

@item
@code{:kserver:jrandom@@floss.red-bean.com:/usr/local/newrepos} --
Conecta usando acreditación Kerberos.

@item
@code{:gserver:jrandom@@floss.red-bean.com:/usr/local/newrepos} --
Conecta usando acreditación GSSAPI.

@item
@code{:fork:jcualquiera@@floss.red-bean.com:/usr/local/newrepos} -- Conecta
a un repositorio local, pero usando el protocolo de red cliente/servidor
en vez de acceder directamente a los ficheros del repositorio. Esto es
útil para comprobar y depurar comportamientos de CVS en remoto desde
su máquina local.

@item
@code{:local:jcualquiera@@floss.red-bean.com:/usr/local/newrepos} --
Accede a un repositorio local directamente, como si se diera sólo
la ruta absoluta al respositorio.

@end itemize

@heading @w{@code{-e} EDITOR}

Invoca EDITOR para su mensaje de entrega, si el mensaje de entrega no
se especifica en la línea de mandatos con la opción -m.
Normalmente, si no da un mensaje con la opción -m, CVS invoca el
editor basado en las variables de entorno @code{$CVSEDITOR},
@code{$VISUAL}, o @code{$EDITOR}, que comprueba en este orden. Fallado
esto, invoca el editor popular de Unix @code{vi}.

Si pasa tanto la opción -e como la -m en una entrega, el -e no se
tiene en cuenta a favor del mensaje de entrega dado en la línea
de mandatos (de este modo es seguro usar -e en un fichero @file{.cvsrc}).

@heading @code{-f}

Esta opción global suprime la lectura del fichero @file{.cvsrc}.

@heading @w{@code{--help} [MANDATO] o @code{-H} [MANDATO]}

Estas dos opciones son sinónimas. Si no se especifica MANDATO, se
imprime un mensaje de uso básico a la salida estándar. Si se
especifica MANDATO, se imprime un mensaje de uso para ese mandato.

@heading @code{--help-options}

Imprime una lista con todas las opciones globales de CVS, con breves
explicaciones.

@heading @code{--help-synonyms}

Imprime una lista de mandatos CVS y sus formatos cortos ("up" para
"update", y así sucesivamente).

@heading @code{-l}

Suprime el registro del mandato en el fichero @file{CVSROOT/history} en
el repositorio. El mandato se ejecuta normalmente, pero no se realiza
ninguna archivación en el fichero de historial.

@heading @code{-n}

No cambia ningún fichero en la copia de trabajo o en el repositorio.
En otras palabras, el mandato se ejecuta como una "ejecución en
seco" -- CVS corre a través de la mayoría de los pasos del
mandato pero evita cualquier clase de ejecución.

Ésto es útil cuando quiere ver qué habría hecho el mandato
si usted lo hubiera ejecutado. Un escenario común es cuando quiere ver
qué ficheros de su directorio de trabajo han sido alterados, pero no
una actualización completa (que podrí traer cambios del
repositorio). Ejecutando @w{@code{cvs -n update}}, puede ver un sumario
de qué ha sido hecho localmente, sin cambiar su copia de trabajo.

@heading @code{-q}

Esto pide a CVS ser moderadamente silencioso, suprimiendo la impresión
de mensajes de información no importantes. Qué es considerado
"importante" depende del mandato. Por ejemplo, en actualizaciones, los
mensajes que CVS imprime normalmente al entrar en cada subdirectorio de
la copia de trabajo se suprimen, pero los mensajes de estado de una
línea para los ficheros modificados o actualizados se siguen
imprimiendo.

@heading @code{-Q}

Esto pide a CVS ser muy silencioso suprimiendo toda la salida excepto
los que son absolutamente necesario para completar el mandato. Los
mandatos cuyo único propósito es producir alguna salida (como
@code{diff} o @code{annotate}), de hecho, siguen dando esa salida.
Sin embargo, los mandatos que podrían tener un efecto independiente
de cualquier mensaje que pudieran imprimir (como @code{update} o
@code{commit}) no imprimen nada.

@heading @code{-r}

Hace que los ficheros de trabajo sean creados como de sólo lectura
(el mismo efecto que configurando la variable de entorno
@code{CVSREAD}).

Si usted pasa esta opción, las obtenciones y las entregas hacen
los ficheros de sólo lectura en su copia de trabajo (asumiendo
que su sistema operativo lo permita). Francamente, no sé por
qué alguien podría querer usar alguna vez esta opción.

@heading @w{@code{-s} VARIABLE@code{=}VALOR}

Esto asigna el VALOR a la variable interna de CVS llamada
VARIABLE.

En el lado del repositorio, los fichero disparadores
@file{CVSROOT/*info} puede expandir tales variables a valores
que fueron asignados en la opción -s. Por ejemplo, si
@file{CVSROOT/loginfo} contiene una línea como esta

@example
miproyecto  /usr/local/bin/foo.pl $@{=PEZ@}
@end example

y alguien ejecuta una entrega desde una copia de trabajo miproyecto
así

@example
floss$ cvs -s PEZ=carpa commit -m "arreglado el bug cebo"
@end example

el script @file{foo.pl} se invoca con @code{carpa} como un argumento.
Note la sintaxis chula, así: El signo del dólar, igual y las
llaves son todas necesarias -- si alguno de ellos falta, la
expansión no toma lugar (al menos no como se trataba). Los nombres
de variables sólo pueden contener alfanuméricos y subrayados.
Aunque no se requiere que estén en mayúsculas, la mayoría
de la gente parece seguir esta convención.

Puede usar el indicador -s tantas veces como quiera en un mandato
simple. Sin embargo, si el script disparador se refiere a variables 
que no son asignadas en una invocación particular de CVS, el mandato
también tiene éxito, pero ninguna de las variables se expande, y
el usuario ve un aviso. Por ejemplo, si loginfo tiene esto

@example
miproyecto  /usr/local/bin/foo.pl  $@{=PEZ@}  $@{=AVE@}
@end example

pero el mismo mandato de antes se ejecuta

@example
floss$ cvs -s PEZ=carpa commit -m "arreglado el bug cebo"
@end example

la persona que ejecuta el mandato ve un mensaje de aviso como este
(puesto al final de la salida)

@example
loginfo:31: no such user variable $@{=AVE@}
@end example

(loginfo:31: variable de usuario inexistente) y el script @file{foo.pl}
se invoca sin argumentos. Pero si se ejecuta este mandato

@example
floss$ cvs -s PEZ=carpa -s AVE=buitre commit -m "arreglado el bug cebo"
@end example

aquí no habría aviso, y tanto @code{$@{=PEZ@}} como
@code{$@{=AVE@}} en loginfo estarían correctamente expandidos.
En cualquier caso, la entrega en sí misma, tendría éxito.

Aunque estos ejemplos usan todos @code{commit}, la expansión de
variables puede hacerse con cualquier mandato CVS que pueda ser
notificado en un fichero disparador @file{CVSROOT/} -- que es por
lo que la opción -s es global.

(Vea la sección @ref{Ficheros de Administracion del Repositorio} más
adelante en este capítulo para obtener más detalles sobre la
expansión de variables en ficheros disparadores.)

@heading @w{@code{-T} DIRECTORIO}

Guarda cualquier fichero temporal en el DIRECTORIO en vez de donde CVS
lo pone normalmente (específicamente, esto sustituye el valor de
la variable de entorno @code{$TMPDIR}, si existiera). DIRECTORIO
debería ser una ruta absoluta.

Esta opción es útil cuando usted no tiene que permiso de
escritura (y, por tanto, CVS tampoco) a los directorios
temporales usuales.

@heading @code{-t}

Traza la ejecución del mandato de CVS. Esto hace a CVS imprimir
mensajes mostrando los pasos que se dan a lo largo de la ejecución
de un mandato. Puede encontrarlo particularmente útil en conjunción
con la opción global -n, para prever los efectos de un mandato poco
familiar antes de ejecutarlo de verdad. También puede ser útil
cuando intenta descubrir por qué un mandato falló.

@heading @w{@code{-v} o @code{--version}}

Hace que CVS imprima información de sus versiones y derechos de
copia y después salga sin error.

@heading @code{-w}

Hace que los ficheros de trabajo sean creados como lectura-escritura
(remplaza cualquier configuración de las variables de entorno
@code{$CVSREAD}). Debido, de todos modos, a que los ficheros se crean
por omisión en modo lectura-escritura, esta opción se usa raramente.

Si tanto -r como -w se pasan, -w domina.

@heading @code{-x}

Encripta todas las comunicaciones con el servidor. Esta opción no
tiene efecto a no ser que esté conectando vía servidor
GSSAPI (gserver). Las conexiones GSSAPI no se cubren en este libro,
porque son todavía raramente usadas (aunque esto puede cambiar).
(Ver los nodos @cite{Opciones Globales} y @cite{Acreditación GSSAPI}
en el manual Cederqvist para ampliar información.)

@heading @w{@code{-z} NIVEL-GZIP}

Ajusta el nivel de compresión en las comunicaciones con el servidor.
El argumento NIVEL-GZIP debe ser un número entre el uno y el nueve.
El nivel uno es compresión mínima (muy rápida, pero poca
compresión). El nivel nueve es la compresión más alta (aunque es mucho tiempo
de CPU, pero asegura que comprime los datos). El nivel nueve es
solamente útil en conexiones de red muy rapidas. La mayor parte
de la gente encuentra los niveles entre el tres y el cinco los más
benificiosos.

Un espacio entre -z y su argumento es opcional.

@c -----------------------------------------------------
@node add
@subsection add

@w{Sinopsis: add [OPCIONES] FICHEROS}

@itemize
@item Nombres alternativos -- ad, new
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Copia de trabajo
@end itemize

Añade un fichero o ficheros nuevos a un proyecto existente. Aunque
se conecta con el repositorio para obtener confirmación, el fichero no
aparece en el acto en él hasta que se realiza la siguiente llamada a commit
(Ver también @ref{remove} e @ref{import}.)

Opciones:

@itemize

@item
-kCLAVE_DE_MODO_DE_SUSTITUCIÓN -- Especifica que el fichero va a ser
almacenado con la clave de sustitución de RCS dada. No hay espacio
entre -k y su argumento. (Ver la sección @ref{Claves de Sustitucion 
(Claves RCS)} más adelante en este capítulo para tener una lista
completa de modos válidos y ejemplos.)

@item
-m MENSAJE -- Graba el MENSAJE como mensaje de creación, o descripción,
para el fichero. Éste es diferente de un mensaje de registro por revisión
-- cada campo tiene una sola descripción. Las descripciones son
opcionales.

Hasta la versión 1.10.7, hay un bug en CVS por el que la descripción
se pierde se añade un fichero via CVS cliente/servidor. El resto del 
proceso de añadido funciona correctamente, sin embargo, si sirve
de consuelo.

@end itemize

@c -----------------------------------------------------
@node admin
@subsection admin

@w{Synopsis: admin [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- adm, rcs
@item Requiere -- Copia de trabajo, repositorio
@item Cambios -- Repositorio
@end itemize

Este mandato es una interfaz a las distintas tareas de administración
-- especialmente, tareas aplicables a ficheros RCS individuales en
el repositorio, como cambiar la clave de sustitución o cambiar
un mensaje de registro después de que haya sido entregado.

Aunque admin se comporta recursivamente, si no hay ficheros dados como
argumentos, normalmente usted querrá nombrarlos explícitamente.
Es muy raro que un mandato admin suelto tenga sentido cuando se aplica
a todos los ficheros en un proyecto, o incluso un directorio. De este
modo, cuando las siguientes explicaciones se refieran al "fichero",
quere decir el fichero o (raramente) los ficheros pasados como
argumentos al mandato admin.

@cindex cvsadmin group

Si hay un grupo de sistema llamado @code{cvsadmin} en la máquina del
repositorio, sólo los miembros de este grupo pueden ejecutar admin
(con la excepción de la orden @w{@code{cvs admin -k}}, que siempre
se permite). Así, usted puede impedir admin para todos los usuarios
configurando el grupo para no tener usuarios.

Opciones:

@itemize

@item
-AFICHERO_VIEJO -- (En desuso) Adjunta la lista de accesos RCS del
FICHERO_VIEJO  a la lista de accesos del fichero que es el argumento
de admin. CVS no tiene en cuenta las listas de acceso RCS, así
que esta opción es inútil.

@item
-a USUARIO1 [,USUARIO2...] -- (En desuso) Adjunta los usuarios en la
lista separada por comas a la lista de acceso del fichero. Como -A,
esta opción es inútil en CVS.

@item
-bREV -- Especifica la revisión de la rama por omisión del fichero
(usualmente el tronco) a REV. No necesita normalmente esta opción,
pero podría usarla para volver a una versión de un vendedor
si está usando ramas de vendedores. No debe haber espacio entre
la opción -b y su argumento.

@item
-cPREFIJO_DE_COMENTARIO -- (En desuso) Especifica la cabecera de comentario
del fichero a PREFIJO_DE_COMENTARIO. El encabezamiento del comentario no se
usa por CVS ni incluso por recientes versiones de RCS; así, esta
opción es inútil y se incluye sólo por compatibilidad
retrospectiva.

@item
-eUSUARIO1[,USUARIO2...] -- (En desuso) Quita los nombres de usuario que
aparecen en la lista separada por comas de la lista de acceso del fichero
RCS. Como -a y -A, esta opción es ya inútil en CVS.

@item
-i o -I -- Estas dos han caído tan en desuso que ni siquiera voy
a contarle qué hacían. (Ver el manual Cederqvist si siente
curiosidad).

@item
-kMODO -- Especifica la clave de sustitución por omisión del fichero a
MODO. Esta opción se comporta como la opción -k para añadir, sólo
le proporciona una manera de cambiar el modo de un fichero después de
que haya sido añadido. (Ver la sección @ref{Claves de Sustitucion
(Claves RCS)} más adelante en el capítulo para ver modos válidos).
No debe haber espacio entre -k y su argumento.

@item
-L -- Configura el candado a @code{strict}. (Ver -l abajo.)

@item
-l[REV] -- Cierra la revisión del fichero a REV. Si REV es omitido,
cierra la última revisión en la rama por omisión (usualmente el
tronco). Si REV es una rama, cierra la última revisión de la rama.

La intención de esta opción es proporcionarle un modo de hacer
@dfn{obtenciones reservadas}, donde sólo un usuario a la vez puede
estar editando un fichero. No estoy seguro de lo útil que es esto
realmente, pero si quiere probarlo, debe probablemente hacerlo en
conjunción con el script @file{rcslock.pl} en el directorio de la
distribución @file{contrib/}. Ver comentarios en este fichero para
obtener más información. Entre otras cosas, estos comentarios indican
que el bloqueo debe ser configurado a @code{strict}. (Ver -L.) No
hay espacio entre -l y su argumento.

@item
-mREV:MENSAJE -- Cambia el registro de mensajes para la revisión REV
a MENSAJE. Muy útil -- junto con -k, esta es probablemente la opción
de administración más usada. No hay espacio entre la opción y los
argumentos o alrededor de las comas entre dos argumentos. De hecho,
MENSAJE puede contener espacios dentro (en tal caso, recuerde rodearlo
por comillas para que el shell sepa que todo ello es una sola cosa).

@item
-NNOMBRE[:[REV]] -- Igual que -n, excepto que fuerza el remplazo de cualquier
asignamiento existente del nombre simbólico NOMBRE, en vez de salir
con un error.

@item
-nNOMBRE[:[REV]] -- Éste es un interfaz genérico a asignar, renombrar y
borrar etiquetas. No hay razón, que yo sepa, de preferirlo al
mandato tag y las variadas opciones disponibles ahí (-d, -r,
-b, -f, y esas). Recomiendo usar, en cambio, el mandato tag. El NOMBRE y
la REVisión opcional pueden ser combinadas de las siguientes formas:

@c inner list
@itemize 

@item 
Si sólo se da el argumento NOMBRE, el nombre simbólico (etiqueta)
llamado NOMBRE se borra.

@item
Si NOMBRE: se da pero no REV, NOMBRE se asigna a la última revisión
en la rama por omisión (usualmente el tronco).

@item
Si NOMBRE:REV se da, el NOMBRE se asigna a esa revisión. REV puede
ser un nombre simbólico en sí mismo, en este caso se
traduce a un número de revisión primero (puede ser un número
de rama).

@item
Si REV es un número de rama y le sigue un punto (@code{.}), NOMBRE
se adjunta a la revisión más alta de esa rama. Si REV es simplemente
$, NOMBRE se adjunta a los números de revisión encontrados en las
cadenas de claves en los ficheros de trabajo.

En todos los casos donde NOMBRE se asigna, CVS sale con un error si
había una etiqueta llamada NOMBRE en el fichero (pero vea -N). No
hay espacios entre -n y sus argumentos.

@c end inner list
@end itemize

@item
-oRANGO -- Borra las revisiones especificadas por RANGO (también
conocido como "anticuar", de ahí la -o). El rango puede ser
especificado de uno de las siguientes modos:

@c inner list
@itemize
@item
REV1::REV2 -- Colapsa todas las revisiones intermedias entre REV1 y
REV2, de modo que el historial de revisiones vaya directamente de
REV1 a REV2. Después de esto, cualquier revisión entre las dos
ya no existirá, y habrá un salto discontinuo en la secuencia de
números de revisiones.

@item
::REV -- Colapsa todas las revisiones entre el principio de la
rama de REVisión (que puede ser el principio del tronco) y la
REVisión, no inclusive, por supuesto. REV es la primera revisión
de esta línea.

@item
REV:: -- Colapsa todas las revisiones entre REV y el final de su
rama (que puede ser el tronco). REV es entonces la última revisión
de esta línea.

@item
REV -- Borra la revisión REV (-o1.8 sería equivalente a
-o1.7::1.9).

@item
REV1:REV2 -- Borra las revisiones de REV1 a REV2, incluídas.
Deben estar en la misma rama. Después de esto, no puede recuperar
REV1, REV2, o cualquier otra de las revisiones entre ellas.

@item
:REV -- Borra las revisiones entre el comienzo de la rama (o tronco)
a REV, incluída. (Ver el aviso precedente.)

Note que las revisiones que se borran pueden tener ramas o bloqueos.
Si cualquiera de las revisiones tiene nombres simbólicos adjuntos,
deberá borrarlos primero con tag -d o admin -n. (De hecho, ahora mismo
CVS sólo protege contra el borrado de revisiones con nombres
simbólicos si está usando una de las sintaxis ::, pero las
sintaxis con coma tal vez cambien pronto a este comportamiento también).

En vez de usar esta opción para deshacer una entrega mala, puede
entregar una nueva revisión de deshaga el cambio erróneo. No hay
espacios entre -o y sus argumentos.

@c end inner list
@end itemize

@item
-q -- Dice a CVS que se ejecute silenciosamente -- no se imprimen
mensajes de diagnóstico (simplemente como la opción global -q).

@item
-sESTADO[:REV] -- Configura el atributo de estado de la revisión
REV a ESTADO. Si REV se omite, la última revisión en la rama
por omisión (usualmente el tronco) se usa. Si REV es una etiqueta
de rama o número, se usa la última revisión de esta rama.

Cualquier cadena de letras o números es aceptable para ESTADO;
unos estados comúnmente usados son Exp para Experimental, Stab para
Estable y Rel para Lanzamiento. (De hecho, CVS ajusta el estado a Exp
cuando un fichero se crea).
Note que CVS usa el estado "dead" para sus propios propósitos, así
que no lo especifique.

Los estados se muestran en la salida de registro de CVS y en las
claves RCS $Log y $State en los ficheros. No hay espacio entre -s
y sus argumentos.

@item
-t[FICHERO_DESC] -- Remplaza la descripción (mensaje de creación)
para el fichero con contenidos FICHERO_DESC, o lo lee de la entrada
estándar si no se especifica FICHERO_DESC.

Esta útil opción, desafortunadamente, no funciona actualmente
en CVS cliente/servidor. Además, si lo itenta en cliente/servidor
y omite FICHERO_DESC, cualquier descripción existente para el
fichero es cortada y remplazada por una cadena vacía. Si
necesita reescribir la descripción de un fichero, hágalo
bien usando sólo CVS local en la misma máquina que el
repositorio o -t-CADENA (ver adelante). No hay espacio entre -t
y su argumento. FICHERO_DESC puede no comanzar con guión (@code{-}).

@item
-t-CADENA -- Como -t, excepto que CADENA es tomada directamente como
la nueva descripción. CADENA puede contener espacios, en cuyo
caso debe rodearla por comillas. A diferencia de la otra sintaxis para
-t, esta funciona tanto en cliente/servidor como localmente.

@item
-U -- Configura el bloqueo a no-estricto. (Ver opciones -l y -L,
discutidas anteriormente.)

@item
-u[REV] -- Libera la revisión REV. (Ver -l). Si se omite REV, CVS
libera el último bloqueo mantenido por el solicitante. Si algún
otro que el dueño de un bloqueo lo rompe, un mensaje
por correo electrónico se envía al dueño original del
bloqueo. El contenido de este mensaje se solicita en la entrada
estándar de la persona que rompe el bloqueo. No hay espacio entre
-u y su argumento.

@item
-VNÚMERO_DE_VERSIÓN_CVS -- (En desuso) Esto solía ser un modo
de pedir a CVS producir ficheros RCS aceptables para versiones
anteriores de RCS. Ahora el formato RCS usado por CVS está quedándose
lejos del formato RCS usado por RCS, así que la opción es inútil.
Especificarla acaba en un error.

@item
-xSUFIJO -- (En desuso) Teóricamente, esto le da un modo de especificar
el sufijo de los nombres de fichero RCS. Sin embargo, CVS y las herramientas
relacionadas dependen todos del sufijo por omisión (,v), así que esta
opción no hace nada.

@end itemize

@c -----------------------------------------------------
@node annotate
@subsection annotate

@w{Sinopsis: annotate [OPCIONES] [FICHERO]}

@itemize
@item Nombre alternativo -- ann
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Nada
@end itemize

Muestra información de quién ha sido el último en modificar
cada línea de salida correspondiente a una línea del fichero.
De izquierda a derecha, la línea muestra el número de revisión
de la última modificación de esa l\'inea, una expresión entre
paréntesis conteniendo el usuario y la fecha de la modificación,
una coma, y los contenidos de la línea en el fichero.

Por ejemplo, si un fichero tiene este aspecto

@example
este es un fichero de prueba
tiene muchas líneas
quiero decir "dos"
@end example

las anotaciones para este fichero podrían parecer esto

@example
1.1          (jcualquiera  22-Aug-99): este es un fichero de prueba
1.1          (jcualquiera  22-Aug-99): tiene muchas líneas
1.2          (jcualquiera  22-Aug-99): quiero decir "dos"
@end example

de donde puede saber que las primeras dos líneas se escribieron
en la revisión inicial, y la última fue añadida o modificada
(también por jcualquiera) en la Revisión 1.2.

Opciones:

@itemize

@item
-D FECHA -- Muestra las anotaciones de la última revisión no más
antigua que FECHA.

@item
-f -- Fuerza el uso de una revisión de la etiqueta especificada o
si la fecha no se encuentra. Puede usar esto en combinación con -D
o -r para asegurar que hay alguna salida del mandato annotate, incluso
si sólo se muestra la revisión 1.1 del fichero.

@item
-l -- Local.  Ejecutar sólo en el directorio de trabajo actual.
No desciende dentro de los subdirectorios.

@item
-R -- Recursivo.  Desciende dentro de los subdirectorios (por omisión).
El punto en la opción -R se hace para sustituir cualquier opción
-l puesta en un fichero .cvsrc.

@item
-r REV -- Muestra las anotaciones de la revisión REV (puede ser un
número de revisión o una etiqueta).

@end itemize

@c -----------------------------------------------------
@node checkout
@subsection checkout

@w{Sinopsis: checkout [OPCIONES] PROYECTO(S)}

@itemize
@item Nombres alternativos -- co, get
@item Requiere -- Repository
@item Cambios -- Current directory
@end itemize

Obtiene un módulo del repositorio en una copia de trabajo. La
copia de trabajo se crea si no existe ya y se actualiza si
existe. (Ver también @ref{update}.)

Opciones:

@itemize

@item
-A -- Borra cualquier etiqueta adhesiva, fechas adhesivas, o -k
adhesivas (clave de modo de sustitución RCS). Esto es como la
opción -A para actualizar y es probablemente usada más a
menudo que con la obtención.

@item
-c -- No obtiene; simplemente imprime el fichero @file{CVSROOT/modules},
ordenado, en la salida estándar.  Es un buen modo de obtener un
resumen de qué proyectos están en el repositorio.  Sin embargo,
un proyecto sin una entrada en modules no aparece (esta situación
es muy normal porque el nombre del directorio de alto nivel del
proyecto en el repositorio funciona como el nombre por omisión
del módulo del proyecto).

@item
-D FECHA -- Obtiene la última revisión no más vieja que FECHA.
Esta opción es adhesiva, así que no podrá entregar desde
la copia de trabajo sin borrar la fecha adhesiva. (Ver -A). Esta opci\on
también implica -P, descrita más tarde.

@item
-d DIR -- Crea la copia de trabajo en un directorio llamado DIR, en vez
de crear el directorio con el mismo nombre que el módulo obtenido.
Si obtiene sólo una porción de un proyecto y la porción está
ubicada en cualquier parte que no sea el nivel más alto del proyecto,
los directorios son omitidos. Puede usar -N para suprimir este comportamiento
de colapso de directorios.

@item
-f -- Fuerza la obtención de la revisión de cabecera si la etiqueta
especificada o la fecha no se encuentra.  Se usa muy a menudo en
combinación con -D o -R para asegurar que algo siempre se obtiene.

@item
@w{-j REV[:FECHA] o -j REV1[:FECHA] -j REV2[:FECHA]} -- Une (mezcla)
dos líneas de desarrollo.  Esto es simplemente como la opción -j
para actualizar, donde es más comúnmente usado. (Vea @ref{update}
para detalles.)

@item
-k MODO -- Sustituye la clave RCS de acuerdo con MODO (que puede
sustituir los modos por omisión de los ficheros). (Vea la sección
@ref{Claves de Sustitucion (Claves RCS)} más adelante en este
capítulo con los modos válidos.) El modo elegideo será
adhesivo -- futuras actualizaciones de la copia de trabajo mantendrán
este modo.

@item
-l -- Local.  Obtiene sólo el directorio de alto nivel del proyecto.
No procesa subdirectorios.

@item
-N -- Suprime el colapso de directorios vacíos con la opción -d
(Vea -d.)

@item
-n -- No ejecuta ningún programa que fue especificado con -o en
@file{CVSROOT/modules}.  (Ver la sección @ref{Ficheros de
Administracion del Repositorio} más adelante en este cap\'itulo
para obtener más información.)

@item
-P -- Poda directorios vacíos de la copia de trabajo (como la
opción -P de update).

@item
-p -- Obtiene a la salida estándar, no a ficheros (como la
opción -p de update).

@item
-R -- Obtiene también subdirectorios (por omisión).  (Ver también
la opción -f.)

@item
-r ETIQUETA -- Obtiene el proyecto con revisión ETIQUETA (no tendría
sentido especificar una revisión numérica para ETIQUETA, aunque CVS
se lo permita).  Esta opción es adhesiva e implica -P.

@item
-s -- Como -c, pero muestra el estado de cada módulo y ordena por estado.
(Ver @ref{modules} en la sección @ref{Ficheros de Administracion del
Repositorio} para ampliar información.)

@end itemize

@c -----------------------------------------------------
@node commit
@subsection commit

@w{Synopsis: commit [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- ci, com
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Repositorio (Y área administrativa de la copia de trabajo)
@end itemize

Entrega los cambios de una copia de trabajo al repositorio.

Opciones:

@itemize

@item
-F FICHERO_MSJ -- Usa los contenidos de FICHERO_MSJ para los mensajes
de registro en vez de invocar un editor.  Esta opción no puede
combinarse con -m.

@item
-f -- Fuerza la entrega de una nueva revisión incluso si no se
han hecho cambios a los ficheros.  @code{commit} no es recursivo con
esta opción (implica -l).  Puede forzar la recursión con -R.

El significado de -f no concuerda con su significado usual ("forzar a
la revisión de cabecera") en los mandatos de CVS.

@item
-l -- Local.  Entrega los cambios del directorio actual sólo.  No
desciende a los subdirectorios.

@item
-m MENSAJE -- Usa MENSAJE como mensaje de registro en vez de
invocar un editor.  No puede ser usado con -F.

@item
-n -- No ejecuta ningún programa de módulo. (Ver la sección
@ref{Ficheros de Administracion del Repositorio} en este capítulo
para obtener más información sobre los programas de módulo.

@item
-R -- Entrega los cambios de los subdirectorios al igual que desde
el directorio actual (por omisión).  Esta opción se usa sólo para
contrarrestar el efecto de un -l en @file{.cvsrc}.

@item
-r REV -- Entrega hasta la revisión REV, que debe ser, o una rama,
o una revisión en el tronco que es más alta que cualquier
revisión existente.  Al entregar en una rama siempre se va al extremo
de la rama (extendiéndola); no puede entregar a una expecífica
revisión de una rama.  El uso de esta opción configura la nueva
revisión como un sticky tag del fichero.  Esto puede ser borrado
con update -A.

La opción -r REV implica -f también.  Una nueva revisión se
entrega incluso si no hay cambios que entregar.

@end itemize

@c -----------------------------------------------------
@node diff
@subsection diff

@w{Synopsis: diff [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- di, dif
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Nada
@end itemize

Muestra las diferencias entre dos revisiones (un formato diff de Unix).
Cuando es invocado sin opciones, CVS diferencia la revisión base
del repositorio entre los (posiblemente no entregados) contenidos de
la copia de trabajo. Las revisiones @dfn{base} son las últimas revisiones
en esta copia recogida del repositorio; note que podría haber
incluso revisiones posteriores en el repositorio, si otro entregó
cambios pero la copia de trabajo todavía no se ha actualizado.
(Ver también @ref{rdiff}).

Opciones:

@itemize

@item
-D FECHA -- Diferencia entre las últimas revisiones no posteriores a
FECHA.  Se comporta como -r REV, excepto que usa las fechas en vez de
revisiones.  (Ver -r para obtener más detalles).

@item
-k MODO -- Expande las claves RCS en las diferencias de acuerdo al MODO.
(Ver la sección @ref{Claves de Sustitucion (Claves RCS)} en este
capítulo para posibles modos.)

@item
-l -- Local.  Si no hay ficheros especificados como argumentos, esta
opción diferencia en el directorio actual, pero no desciende dentro
de los subdirectorios.

@item
-R -- Recursivo.  Esta opción es la contraria a -l.  Este es el
comportamiento por omisión, así que la única razón para
especificar -R es contrarrestar un -l en un fichero @file{.cvsrc}.

@item
-r REV or -r REV1 -r REV2 -- Diferencia entre las revisiones
especificadas.  Con una opción -r, se diferencian revisiones REV
contra su copia de trabajo de este fichero (así cuando múltiples
ficheros están siendo diferenciados, REV es casi siempre una etiqueta).
Con dos opciones -r, diferencia REV1 entre REV2 para cada fichero
(y la copia de trabajo es, por tanto, irrelevante). Las dos revisiones
pueden estar en cualquier orden -- REV1 no tiene tiene por qué ser
una revisión anterior a REV2.  La salida refleja las direcciones
del cambio.  Con ninguna opción -r, muestra las diferencias entre
el fichero de trabajo y la revisión en la que está basado.

@end itemize

Opciones de Compatibilidad de Diff

Además de las opciones precedentes, cvs diff también comparte
multitud de opciones con la versión GNU del programa de l\'inea de
mantados diff estándar. Lo que sigue es una lista completa de estas
opciones, junto con una explicación de algunos de los más
comúnmente usados. (Ver la documentación del GNU diff para las
otras).

@example
-0 -1 -2 -3 -4 -5 -6 -7 -8 -9 
    --binary
    --brief
    --changed-group-format=ARG
    -c
      -C NL\'INEAS
      --context[=L\'INEAS]
    -e --ed
    -t --expand-tabs
    -f --forward-ed
    --horizon-lines=ARG
    --ifdef=ARG
    -w --ignore-all-space
    -B --ignore-blank-lines
    -i --ignore-case
    -I REGEXP
       --ignore-matching-lines=REGEXP
    -h
    -b --ignore-space-change
    -T --initial-tab
    -L ETIQUETA
      --label=ETIQUETA
    --left-column
    -d --minimal
    -N --new-file
    --new-line-format=ARG
    --old-line-format=ARG
    --paginate
    -n --rcs
    -s --report-identical-files
    -p
    --show-c-function
    -y --side-by-side
    -F REGEXP
    --show-function-line=REGEXP
    -H --speed-large-files
    --suppress-common-lines
    -a --text
    --unchanged-group-format=ARG
    -u
      -U NL\'INEAS
      --unified[=L\'INEAS]
    -V ARG
    -W COLUMNAS
      --width=COLUMNAS
@end example

Lo que sigue son las opciones del GNU diff más frecuentemente usadas
con cvs diff.

@itemize

@item
-B -- No tiene en cuenta las diferencias que son meramente inserción
o borrado de líneas vacías (líneas que no contienen nada
más que caracteres de espacio).

@item
-b -- No tiene en cuenta las diferencias en la cantidad de espacios.
Esta opción trata todas las secuencias de espacios como si fueran
iguales y no hace caso de los espacios en el final de la línea.
Más técnicamente, esta opción colapsa cada secuencia de espacios
en la salida a un simple espacio y quita cualquier espacio del final
de cada línea, antes de realizar la diferenciación.
(Ver también -w).

@item
-c -- Muestra la salida en el contexto del formato diff, tomando
por omisión tres líneas de contexto por diferencia (en
beneficio del programa patch, que requiere como mínimo dos
líneas de contexto).

@item
-C NUM -- context=NUM -- Como -c, pero con NUM líneas de contexto.

@item
-i -- Compara sin tener en cuenta mayúsculas/minúsculas.  Trata
las versiones de mayúsculas y minúsculas de una letra como
la misma.

@item
-u -- Muestra la salida en un formato unificado diff.

@item
-w -- No tiene en cuenta todas las diferencias de espacios, incluso
cuando una cara de la entrada tiene espacios donde las otras no
tenían.  Esencialmente una versión más fuerte de -b.

@end itemize

@c -----------------------------------------------------
@node edit
@subsection edit

@w{Synopsis: edit [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- ninguno
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Permisos en la copia de trabajo, lista de observaciones en el repositorio
@end itemize

Señala que esta a punto de empezar a editar un fichero o ficheros observados.
Atambién le añade como un observador temporal a la lista de observadores del
fichero (será quitado cuando haga cvs unedit). (Ver también @ref{watch},
@ref{watchers}, @ref{unedit} y @ref{editors}.)

Opciones:

@itemize

@item
-a ACCIONES -- Especifica para qué acciones quiere ser un observador
temporal.  Las ACCIONES pueden ser edit, unedit, commit, all o none.
(Si no usa -a, la observación temporal será para todas las acciones.)

@item
-l -- Se\~ala la edición de los ficheros sólo para el directorio de
trabajo actual.

@item
-R -- Recursivo (ésto es por omisión).  Contrario de b;
necesitaría pasar -R sólo para contrarrestar un -l en un
fichero @file{.cvsrc}.

@end itemize

@c -----------------------------------------------------
@node editors
@subsection editors

@w{Synopsis: editors [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- ninguno
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Nada
@end itemize

Muestra quién está actualmente editando un fichero observado
(Ver también @ref{watch}, @ref{watchers}, @ref{edit} y @ref{unedit}.)

Opciones:

@itemize

@item
-l -- Local.  Mustra los editores de ficheros en el directorio de
trabajo actual sólo.

@item
-R -- Recursivo.  Muestra los editores para los ficheros en este
directorio y sus subdirectorios (por omisión).  Necesitará pasar
-R para contrarrestar un -l en un fichero @file{.cvsrc}, no
obstante.

@end itemize

@c -----------------------------------------------------
@node export
@subsection export

@w{Synopsis: export [OPCIONES] PROYECTO(S)}

@itemize
@item Nombres alternativos -- exp, ex
@item Requiere -- Repositorio
@item Cambia -- Directorio actual
@end itemize

Exporta los ficheros del repositorio para crear un árbol de proyecto
que no es una copia de trabajo (no tiene subdirectorios CVS/ administrativos).
Útil principalmente para empaquetar distribuciones.

Opciones:

@itemize

@item
-D FECHA -- Exporta las últimas revisiones no posteriores a FECHA.

@item
-d DIR -- Exporta en DIR (en otro caso, por omisión es en el nombre del
módulo).

@item
-f -- Fuerza el uso de revisiones de cabecera, si una etiqueta dada
o una fecha resulta en que no se encuentra nada (para usar con -D
o -r).

@item
-k MODO -- Expande una clave RCS de acuerdo al MODO.  (Ver la sección
@ref{Claves de Sustitucion (Claves RCS)} más adelante en este
caítulo.)

@item
-l -- Local.  Exporta sólo el nivel alto del proyecto, no los
subdirectorios.

@item
-N -- No "colapsa" directorios itermedios vacíos.  Esta opción
es como la opción -N para la obtención (@pxref{checkout}).

@item
-n -- No ejecuta un programa de módulo como podría ser
especificado en @file{CVSROOT/modules}.  (Ver @ref{Ficheros de
Administracion del Repositorio} más adelante en este campítulo
para obtener más detalles acerca de esto).

@item
-P -- Borra directorios vacíos (como la opción -P para
la obtención o actualización).

@item
-R -- Recursivo.  Exporta todos los subdirectorios del proyecto (por
omisión).  La única razón para especificar -R es para contrarrestar
un -l en un fichero @file{.cvsrc}.

@item
-r REV -- Exporta la revisión REV.  Rev es casi ciertamente un nombre
de etiqueta, no una revisión numérica.

@end itemize

@c -----------------------------------------------------
@node gserver
@subsection gserver

@w{Sinopsis: gserver}

Éste es el servidor GSSAPI (Servicios Generales de Seguridad API). Este
mandato no se ejecuta normalmente por usuarios.  En vez de esto, se arranca
en el lado del servidor cuando un usuario conecta desde un cliente con el
método de acceso @code{:gserver:}:

@example
cvs -d :gserver:floss.red-bean.com:/usr/local/nuevorepos checkout miproyecto
@end example

GSSAPI provee, entre otras cosas, la Versión 5 de Kerberos; para la
versión 4, usar @code{:kserver:}.

Ajustando y usando una librería GSSAPI en sus máquinas está
fuera del alcance de este libro.  (Ver sin embargo el nodo
@cite{Acreditación GSSAPI} en el manual Cederqvist para obtener
ayudas más útiles).

Opciones: ninguna. 

history [OPCIONES] [SUBCADENA_FICHERO(S)]

@itemize
@item Nombres alternativos -- hi, his
@item Requiere -- Repositorio, CVSROOT/history
@item Cambia -- Nada
@end itemize

Muestra un historial de la actividad en el repositorio.  Específicamente,
esta opción muestra los registros de obtenciones, entregas, etiquetados,
actualizaciones y lanzamientros.  Por omisión, la opción muestra las
obtenciones (pero vea la opción -x).  Este mandato no funciona si no
hay fichero @file{CVSROOT/history} en el repositorio.

El mandato history difiere de otros mandatos CVS en muchos sentidos.
Primero, deben proporcionarse opciones normalmente para hacer algo
útil (y muchas de estas opciones significan diferentes cosas para
el historial que para otros mandatos).  Segundo, en vez de hablar
de nombres completos de fichero como argumentos, toma una o más
subcadenas para coincidir con nombres de fichero (todas las grabaciones
que coincidan con al menos una de estas subcadenas se recuperan).
Tercero, la salida del historial tiene aspecto de basura hasta que aprenda
a leerla, así que explicaré el formato de salida en una sección
especial después de las opciones.  (Ver también @ref{log}.)

Opciones:

@itemize

@item
-a -- Muestra el historial para todos los usuarios (de otro modo, es
por omisión uno mismo).

@item
-b CADENA -- Muestra los datos conteniendo la CADENA en el nombre del
módulo, nombre del fichero o ruta al repositorio.

@item
-c -- Muestra entregas.

@item
-D FECHA -- Muestra los datos desde FECHA (los formatos de fecha de
CVS están disponibles).

@item
-e -- Todo -- Muestra todos los tipos de registros.

@item
-f FICHERO -- Muestra los eventos más recientes concernientes a FICHERO.
Puede especificar esta opción muchas veces.  Esto es diferente del
significado usual de -f en los mandatos CVS: "Forzar a la revisión de
cabecera como última solución."

@item
-l -- Muestra el registro representando el último (como en "más
reciente") evento de cada proyecto.  Esto es diferente del significado
usual de -l en mandatos CVS: "Ejecutar localmente, no recursivamente".

@item
-m MÓDULO -- Esto produce un informe sobre el MÓDULO (nombre de
proyecto). Puede especificar esta opción muchas veces.

@item
-n MÓDULO -- Muestra los eventos más recientes sobre MÓDULO.
Por ejemplo, obtener el módulo concierne al módulo únicamente,
pero modificar o actualizar un fichero dentro del módulo, trata
del fichero, no del módulo.  Puede especificar esta opción muchas
veces.  Ésto es diferente del significado usual de -n en los mandatos
CVS: "No ejecutar un programa CVSROOT/modules."

@item
-o -- Muestra los registros de obtenciones (por omisión).

@item
-p REPOS -- Muestra los datos de un directorio particular en el
repositorio. Puede especificar esta opción muchas veces.  El
significado de esta opción difiere del significado usual de -p en los
mandatos CVS: "Encaminar los datos a la salida estándar en vez de
hacia un fichero".

Esta opción parece estar por lo menos parcialmente rota desde el
verano de 1999.

@item
-r REV -- Muestra los registros refirientes a versiones desde que la revisión
o etiqueta llamada REV aparece en ficheros RCS individuales.  En cada fichero
RCS se busca la revisión o etiqueta.

@item
-T -- Muestra todos los eventos de etiquetado.

@item
-t ETIQUETA -- Muestra los registros desde que la ETIQUETA fue últimamente
añadida al fichero de historial.  Esto difiere del flag -r en donde se lee
sólo el fichero @file{CVSROOT/history}, no los ficheros RCS y es, por tanto,
mucho más rápido.

@item
-u USUARIO -- Muestra los eventos asociados con USUARIO.  Puede especificar
esta opción muchas veces.

@item
-w -- Muestra los registros que están asociados con el directorio de
trabajo del cual está invocando history.

@item
-X FICHERO_HISTORIAL -- Usa FICHERO_HISTORIAL en vez de
@file{CVSROOT/history}.  Esta opción es principalmente para
depurado y no se apoya oficialmente; aun con todo, puede encontrarla
útil (tal vez para generar informes legibles-por-humanos de ficheros
viejos de historial que ha conservado por ahí).

@item
-x TIPOS -- Muestra eventos especificados en TIPOS.  Cada tipo está
representado por una simple letra, del juego @samp{TOEFWUCGMAR}; cualquier
número de letras puede ser combinado.  Aquí está lo que
significan:

@c inner list
@itemize
@item T -- Etiqueta
@item O -- Obtención
@item E -- Exportación
@item F -- Lanzamiento
@item W -- Actualización (fichero obsoleto más nuevo quitado de la copia de trabjo)
@item U -- Actualización (fichero que fue entregado sobre un fichero de usuario)
@item C -- Actualización (mezclado, con conflictos)
@item G -- Actualización (mezclado, sin conflictos)
@item M -- Entrega (el fichero fue modificado)
@item A -- Entrega (el fichero fue añadido)
@item R -- Entrega (el fichero fue borrado)
@c end inner list
@end itemize

Por omisión, si no se proporcionan opciones -x, es para mostrar
obtenciones (como @w{@code{-x O}}).

@item
-z ZONA -- Muestra tiempos en la salida para el huso ZONE.  ZONE es
un nombre de huso abreviado, como UTC, GMT, BST, CDT, CCT y así.
Una lista completa de husos está disponible en TimezoneTable en el
fichero @file{lib/getdate.c} en la distribución de fuentes de CVS.

@end itemize

Salida de historial

La salida del mandato history es una serie de líneas; cada línea
representa un "evento de historial" y comienza con una sola letra de
código indicando qué tipo de evento es.  Por ejemplo:

@example
floss$ cvs history -D yesterday -x TMO
M 08/21 20:19 +0000 jcualquiera 2.2           baar       miproyecto == <remote>
M 08/22 04:18 +0000 jcualquiera 1.2           README     miproyecto == <remote>
O 08/22 05:15 +0000 jcualquiera myproj =myproj= ~/src/*
M 08/22 05:33 +0000 jcualquiera 2.18          README.txt miproyecto == ~/src/myproj
O 08/22 14:25 CDT jcualquiera miproyecto =miproyecto= ~/src/*
O 08/22 14:26 CDT jcualquiera [99.08.23.19.26.03] miproyecto =miproyecto= ~/src/*
O 08/22 14:28 CDT jcualquiera [Saludos_Exoticos-rama] miproyecto =miproyecto= ~/src/*
@end example

Las letras de código son las mismas que para la opción -x recientemente
descrita.  Siguiendo el código de letra en la fecha de un evento (expresada
en tiempo UTC/GMT, a no ser que se use la opción -z), seguida del usuario
responsable del evento.

Después del usuario podría haber un número de revisión, etiqueta, o
fecha, pero sólo si es apropiada para el evento (la fecha o etiqueta
estarán en corchetes y formateados como se muestra en el ejemplo
precedente).  Si usted entrega un fichero, muestra el nuevo número de
revisión; si obtiene con -D o -r, la fecha o etiqueta adhesiva
se muestra dentro de corchetes.  Para una obtención sencilla, nada
extra se muestra.

Luego viene el nombre del fichero en cuestión, o nombre del módulo en
el evento que es sobre un módulo.  En el anterior, las siguientes dos cosas
son el nombre de la copia de trabajo del módulo obtenido (entre dos signos
de igual), seguida por su localización en el directorio personal del usuario
(home).  (El nombre de la copia de trabajo obtenida puede diferir del nombre
del módulo si flag -d es usado con checkout).

@c -----------------------------------------------------
@node import
@subsection import

@w{Sinopsis: import [OPCIONES] REPOSITORIO ETIQUETA_VENDEDOR ETIQUETA_LANZAMIENTO(S)}

@itemize
@item Nombres alternativos -- im, imp
@item Requiere -- Repositiorio, directorio actual (el directorio de fuentes)
@item Changes -- Repositorio
@end itemize

Importa nuevas fuentes en el repositorio, bien creando un nuevo proyecto o
creando una nueva revisión de vendedor en una rama de vendedor de un
proyecto existente. (Ver @ref{CVS avanzado} para obtener una explicación
básica de las ramas de vendedor en la importación, que le ayudará
a entender lo siguiente).

Es normal usar import para añadir muchos ficheros o directorios de vez
o para crear un nuevo proyecto.  Para anñadir simples ficheros, debe
usar add.

Opciones:

@itemize

@item
-b RAMA -- Importa a la rama de vendedor RAMA.  (RAMA es un número de
rama actual, no una etiqueta).  Esto se usa raramente pero puede ser
útil si coge las fuentes del mismo proyecto de diferentes vendedores.
Un mandato de importación normal asume que los fuentes deben ser
importados en la rama de vendedor por omisión, que es "1.1.1".  Debido
a que es por omisión, normalmente no tiene que preocuparse en especificarlo
con -b:

@example
floss$ cvs import -m "importando del vendedor 1" su_proyecto ELLOS1 ELLOS1-0
@end example

Para importar a una rama de vendedor distinta de la que es por omisión,
debe especificar un número de rama diferente explícitamente:

@example
floss$ cvs import -b 1.1.3 -m "del vendedor 2" su_proyecto ELLOS2 ELLOS2-0
@end example

La rama 1.1.3 puede absorver futuras importaciones y ser mezclada como
cualquier otra rama de vendedor.  Sin embargo, debe asegurarse que en
cualquier futura importación que especifique @w{@code{-b 1.1.3}} también
debe usar la misma etiqueta de vendedor (@code{ELLOS2}). CVS no
comprueba que el nombre de vendedor coincida con la etiqueta de
vendedor.  Sin embargo, si no coinciden, ocurrirán cosas extrañas e
impredecibles.

Las ramas de vendedor están numeradas con impares, lo contrario de
ramas regulares.

@item
-d -- Toma la fecha de modificación como la fecha de importación en
vez de usar la fecha actual.  Esto no funciona con CVS cliente/servidor.

@item
-I NOMBRE -- Da nombres de fichero que deben no ser tenidos en cuenta en
la importación.  Puede usar esta opción muchas veces en una importación.
Los patrones con comodines están admitidos: @code{*.foo} significa no
tener en cuenta todo lo que termine en @file{.foo}. (Ver @ref{cvsignore}
en @ref{Ficheros de Administracion del Repositorio} para obtener
detalles acerca de los comodines).

Los siguientes ficheros y nombres de directorios son obviados por omisión:

@example
	.
	..
	.#*
	#*
	,*
	_$*
	*~
	*$
	*.a
	*.bak
	*.BAK
	*.elc
	*.exe
	*.ln
	*.o
	*.obj
	*.olb
	*.old
	*.orig
	*.rej
	*.so
	*.Z
	.del-*
	.make.state
	.nse_depinfo
	core
	CVS
	CVS.adm
	cvslog.*
	RCS
	RCSLOG
	SCCS
	tags
	TAGS
@end example

Puede suprimir que no se tengan en cuenta estos patrones de nombre
de fichero, así como cualquiera especificado en @file{.cvsignore},
@file{CVSROOT/cvsignore}, y la variable de entorno @code{$CVSIGNORE},
usando @w{@code{-I !}}. Esto es,

@example
floss$ cvs import -I ! -m "importando el universo" proyecto VENDEDOR VENDEDOR_0
@end example

importa todos los ficheros en el árbol de directorio actual, incluso
los que serían normalmente desechados.

Usar @w{@code{-I !}} borra cualquier lista de ficheros a no tener en cuenta
que haya sido creada hasta este punto, así que cualquier opción
-I que venga después debería ser anulada, pero cualquiera que
venga después todavía contará.  Así,

@example
floss$ cvs import -I ! -I LÉAME.txt -m "algunos msj" su_proyecto ELLOS ELLOS_0
@end example

no es lo mismo que

@example
floss$ cvs import -I LÉAME.txt -I ! -m "algunos msj" su_proyecto ELLOS ELLOS_0
@end example

El primero obvia (no importa) LÉAME.txt, mientras que el último lo importa.

@item
-k MODO -- Configura la clave de modo de sustitución RCS por omisión para los
ficheros importados.  (Ver @ref{Claves de Sustitucion (Claves RCS)} más
adelante en este capítulo para obtener una lista de modo válidos).

@item
-m MENSAJE -- Registra MENSAJE como mensaje de registro de importación.

@item
-W SPEC -- Especifica filtros basados en nombres de fichero que deben ser usados
efectivamente para la importación.  Puede usar esta opción muchas veces.
(Vea @ref{cvswrappers} en @ref{Ficheros de Administracion del Repositorio} para
obtener detalles acerca de las especificaciones de cobertura).

@end itemize

@c -----------------------------------------------------
@node init
@subsection init

@w{Sinopsis: init NUEVO_REPOSITORIO}

@itemize
@item Nombres alternativos -- Ninguno
@item Requiere -- Localización para el nuevo repositorio
@item Crea -- Repositorio
@end itemize

Crea un nuevo repositorio (que es, el raíz de un repositorio
en el cual se almacenan muchos proyectos diferentes).  Casi siempre
deseará usar la opción global -d con esto, como en

@example
floss$ cvs -d /usr/local/otro_nombre_de_repositorio init
@end example

porque, incluso si tiene la variable de entorno CVSROOT ajustada,
está apuntando probablemente a un repositorio existente, que
puede ser inservible e incluso peligroso en el contexto de este
mandato. (Véase @ref{Administracion del Repositorio} para averiguar
los pasos adicionales que se deberían tomar después de inicializar
un nuevo repositorio).

Opciones: Ninguna.

@c -----------------------------------------------------
@node kserver
@subsection kserver

@w{Sinopsis: kserver}

Este es un servidor Kerberos.  (Si tiene la versión 4 de las librerías
de Kerberos o anteriores -- Versión 5 usa GSSAPI, ver @ref{gserver}.) Este
mandato normalmente no se ejecuta directamente por usuarios pero se ejecuta
en el lado del servidor cuando un usuario conecta desde un cliente con el
método de acceso @code{:kserver:}:

@example
cvs -d :kserver:floss.red-bean.com:/usr/local/nuevorepos checkout miproyecto
@end example

Configurar y usar Kerberos en su máquina está fuera del alcance de este
libro.  (Sin embargo, vea @cite{Acreditación Kerberos} en el manual
Cederqvist para obtener ayuda más útil.)

Opciones: Ninguna. 

@c -----------------------------------------------------
@node log
@subsection log

@w{Sinopsis: log [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- lo, rlog
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Nada
@end itemize

Muestra mensajes de registro para un proyecto, o para ficheros dentro
de un proyecto.  La salida de resitro no está precisamente en el mismo
estilo que la salida de otros mandatos CVS, porque el registro se
basa en un programa RCS más viejo (rlog).  Su formato de salida
da una cabecera, conteniendo varias piezas de información sobre
el fichero no-específica-de-una-revisión, seguida de los mensajes
de registro (arreglados por revisión).  Cada revisión no muestra
meramente el número de revisión y los mensajes de registro, sino
también el autor y la fecha de el cambio y el número de líneas
añadidas o borradas.  Siempre imprimidas en UTC (GMT), no en fecha
local.

Debido a que la salida de log es por fichero, una simple entrega
que involucra múltiples ficheros puede no parecer conceptualmente
como un cambio atómico.  Sin embargo, si lee todos los mensajes de
registro y fechas cuidadosamente, podrá reconstruir qué ocurrió.
(Para obtener más información sobre una herramienta que puede
reformatear salida de log de muchos ficheros de una forma más
legible, vea @ref{cvs2cl -- Genera ChangeLogs al estilo GNU}
en @ref{Herramientas de terceros} para obtener más detalles).
(Ver también @ref{history file}).

Opciones:

Mientras lee las siguientes opciones de filtrado, puede no
quedar completamente claro cómo se comportan cuando se combinan.
Un descripción precisa del comportamiento del registro es la que toma la
intersección de las revisiones seleccionadas por -d, -s y -w, cuando
intersectan con la unión de las seleccionadas por -b y -r.

@itemize

@item
-b -- Imprime información de registro acerca de la rama por omisión
solamente (usualmente la rama más alta del tronco).  Esto se hace
usualmente para evitar la impresión de los mensajes de registro
de ramas laterales de desarrollo.

@item
-dFECHAS -- Imprime información de registro para sólo las revisiones
que coincidan con la fecha o rango de fechas dado por FECHAS, una
lista separada por comas.  Las fechas se pueden dar en cualquiera de
los formatos usuales (ver @ref{Formatos de Fecha} anteriormente
en esta sección) y puede ser combinado en rangos como a continuación:

@c inner list
@itemize

@item
FECHA1<FECHA2 -- Selecciona las revisiones creadas entre FECHA1 y FECHA2.
Si FECHA1 es más vieja que FECHA2, use en cambio @code{>}; de otro
modo no se obtendrán mensajes de registro.

@item
<FECHA FECHA> -- Todas las fechas desde FECHA o más tempranas.

@item
>FECHA FECHA< -- Todas las revisiones de FECHA o más adelante.

@item
FECHA --  Simplemente selecciona la revisión simple más reciente
desde FECHA o más temprana.

@c end inner list
@end itemize

Puede usar @code{<=} y @code{>=} en vez de @code{<} y @code{>} para
indicar un rango exclusivo (de otro modo, los rangos son inclusivos).
Los rangos múltiples pueden ser separados por comas, por ejemplo

@example
floss$ cvs log -d"1999-06-01<1999-07-01;1999-08-01<1999-09-01"
@end example

selecciona los mensajes de registro de revisiones entregadas en
junio o agosto de 1999 (pasando julio).  No puede haber espacio
entre -d y sus argumentos.

@item
-h -- Imprime sólo la información de cabecera de cada fichero,
que incluye el nombre del fichero, el directorio de trabajo, la
revisión de cabecera, la rama por omisi\'n, la lista de
acceso, los bloqueos, los nombres simbólicos (etiquetas) y la
clave de modo de sustituci\'n por omisión.  No se imprimen
mensajes de registro.

@item
-l -- Local.  Se ejecuta sólo para los ficheros en el directorio
de trabajo actual.

@item
-N -- Omite la lista de nombres simbólicos (etiquetas) de la
cabecera.  Esto puede ser útil cuando su proyecto tiene muchas
etiquetas que no está interesado en ver en los mensajes de
registro.

@item
-R -- Imprime el nombre del fichero RCS en el repositorio.

Esto es diferente del significado usual de -R: "recursivo". No hay
modo de contrarrestar un -l para este mandato, así que no
ponga log -l en su @file{.cvsrc}.

@item
-rREVS -- Muestra información de registro para las revisiones
especificadas en REVS, una lista separada por comas.  REVS puede
contener tanto números de revisión y etiquetas. Los rangos
pueden ser especificados así:

@c inner list
@itemize

@item
REV1:REV2 -- Revisiones desde REV1 a REV2 (deben estar en la misma
rama).

@item
:REV -- Revisiones desde el comienzo de la rama de REV hasta, e
incluyendo REV.

@item
REV: -- Revisiones desde REV hasta el final de la rama de REV.

@item
RAMA -- Todas las revisiones de esta rama, desde la raíz hasta
la punta.

@item
RAMA1:RAMA2 -- Un rango de ramas -- todas las revisiones de todas
las ramas de este rango.

@item
RAMA. -- La última revisión (punta) de una RAMA.

@c end inner list
@end itemize

Finalmente, un solo -r, sin argumento, significa seleccionar la última
revisión en la rama por omisión (normalmente el tronco).  No puede
haber espacio entre -r y sus argumentos.

Si el argumento a -r es una lista, está separada por comas, no por
punto y coma, como -d.

@item
-sESTADOS -- Selecciona las revisiones cuyos atributos de estado coincida
con uno de los estados dados por ESTADOS, una lista separada por comas.
No puede haber espacios entre -s y sus argumentos.

Si los argumentos a -s son una lista, están separado por comas, no por
puntos y comas como -d.

@item
-t -- Como -h, pero también incluye la descripción del fichero (su
mensaje de creación).

@item
-wUSUARIOS -- Selecciona las revisiones entregadas por usuarios cuyos nombres
de usuario aparezcan en la lista de usuarios separada por comas.  Un -w
suelto sin USUARIOS significa tomar el nombre de usuario de la persona
que ejecute cvs log.

Recuerde que cuando los sobrenombres de usuario se efectúan (ver
sección @ref{El servidor de autentificacion de contrasen~as} en
@ref{Administracion del Repositorio}), CVS registra el nombre de
usuario CVS, no el nombre de usuario de sistema, en cada entrega.
Puede no haber espacio entre -w y sus argumentos.

Si el argumento a -w es una lista, está separada por comas, no
separada por puntos y comas como -d.

@end itemize

@c -----------------------------------------------------
@node login
@subsection login

@w{Sinopsis: login}

@itemize
@item Nombres alternativos -- logon, lgn
@item Requiere -- Repositorio
@item Cambia -- fichero ~/.cvspass
@end itemize

Establece contacto con un servidor CVS y confirma la información
de acreditación para un repositorio en particular.  Este mandato
no afecta ni a la copia de trabajo ni al repositorio; simplemente
confirma una clave (para usar con el método de acceso :pserver:) con
un repositorio y almacena la clave para uso posterior en el fichero
.cvspass en su directorio de trabajo.  Mandatos futuros que accedan
al mismo repositorio con el mismo nombre de usuario no requerirán
que vuelva a ejecutar login, porque el CVS del lado del cliente
consultará el fichero .cvspass para obtener la clave.

Si usa este mandato, debe especificar un repositorio usando el método
de acceso pserver, como en esto

@example
floss$ cvs -d :pserver:jcualquiera@@floss.red-bean.com:/usr/local/nuevorepos
@end example

o configurando la variable de entorno CVSROOT.

Si cambia la clave en el lado del servidor, debe volver a ejecutar login.

Opciones: Ninguna.

@c -----------------------------------------------------
@node logout
@subsection logout

@w{Sinopsis: logout}

@itemize
@item Nombres alternativos -- None
@item Requiere -- fichero ~/.cvspass
@item Cambia -- fichero ~/.cvspass
@end itemize

Lo contrario que login -- borra la clave para este repositorio de
.cvspass.

Opciones: Ninguna.

@c -----------------------------------------------------
@node pserver
@subsection pserver

@w{Sinopsis: pserver}

@itemize
@item Nombres alternativos -- Ninguno
@item Requiere -- Repositorio
@item Cambia -- Nada
@end itemize

Es el servidor de acreditación por clave.  Este mandato normalmente
no se ejecuta directamente por usuarios, pero se ejecuta desde
@file{/etc/inetd.conf} en el servidor cuando un usuario se conecta
desde un cliente con el método de acceso @code{:pserver:}. (Ver
también los mandatos @ref{login} y @ref{logout}, y el fichero
@file{.cvspass} en la sección @ref{Ficheros de Control de Ejecucion}
en este capítulo.  Ver @ref{Administracion del Repositorio} para
obtener más detalles acerca de configurar un servidor CVS de
acreditación por clave).

Opciones: Ninguna. 

@c -----------------------------------------------------
@node rdiff
@subsection rdiff

@w{Sinopsis: rdiff [OPTIONS] PROJECTS}

@itemize
@item Nombres alternativos -- patch, pa
@item Requiere -- Repositorio
@item Cambia -- Nada
@end itemize

Es como el mandato diff, excepto que opera directamente en el repositorio
y, por tanto, no requiere copia de trabajo. Este mandato sirve para
obtener las diferencias entre un lanzamiento y otro de su proyecto
en un formato adecuado como entrada al programa patch (tal vez para que
pueda distribuir ficheros parche a usuarios que quieran una actualización).

La operación del programa patch está fuera del alcance de este libro.
Sin embargo, note que si el fichero de parche contiene diferencias para
ficheros en subdirectorios, puede necesitar usar la opción -p de
patch para permitir que aplique las diferencias correctamente.  (Ver
la documentación de patch para obtener más información acerca de
esto).  (Ver también @ref{diff}).

Opciones:

@itemize

@item
-c -- Imprime salida en el formato de contexto diff (por omisión).

@item
-D FECHA o -D FECHA1 -D FECHA2 -- Con una fecha, esto muestra las diferencias
entre los ficheros desde FECHA hasta las revisiones de cabecera.
Con dos fechas, muestra las diferencias entre las fechas.

@item
-f -- Fuerza el uso de una revisión de cabecera si no se ecuentran
revisiones coincidentes para la opción -D o -r (de otro modo,
rdiff no tendría en cuenta el fichero).

@item
-l -- Local.  No desciende a los subdirectorios.

@item
-R -- Recursivo.  Desciende a los subdirectorios (por omisión).
Sólo tiene que especificar esta opción para contrarrestar un -l
en su .cvsrc.

@item
-r REV -r REV1 -r REV2 -- Con una revisión, esto muestra las diferencias
entre la revisión REV de los ficheros y la revisión de cabecera.  Con
dos, muestra las diferencias entre las revisiones.

@item
-s -- Muestra un sumario de diferencias.  Esto muestra qué ficheros
han sido añadidos, modificados o borrados, sin mostrar los cambios en
sus contenidos.  La salida tiene este aspecto:

@example
floss$ cvs -Q rdiff -s -D 1999-08-20 mi_proyecto
File mi_proyecto/Cosa.txt is new; current revision 1.4
File mi_proyecto/LÉAME.txt changed from revision 2.1 to 2.20
File mi_proyecto/baar is new; current revision 2.3
@end example

@item
-t -- Muestra la diferencia entre las dos revisiones superiores de
cada fichero. Esto es un atajo útil para determinar los cambios
más recientes en un proyecto.  Esta opción es incompatible con
-D y -r.

@item
-u -- Imprime salida en formato unidiff.  Las versiones más viejas
del parche no pueden manejar formato unidiff; por tanto, no use -u
si está intentando generar un fichero de parche distribuible -- use
-c en su lugar.

@item
-V (En desuso) -- CVS ahora da un error si intenta usar esta opción.
La he incluido aquí sólo en caso de que vea algún script viejo
intentando usarla.

@end itemize

@c -----------------------------------------------------
@node release
@subsection release

@w{Sinopsis: release [OPCIONES] DIRECTORIO}

@itemize
@item Nombres alternativos -- re, rel
@item Requiere -- Copia de trabajo
@item Cambia -- Copia de trabajo, CVSROOT/history
@end itemize

Cancela una obtención (indica que la copia de trabajo y no está
en uso). A diferencia de la mayoría de los mandatos CVS que
operan en una copia de trabajo, esta no se invoca dentro de la
copia de trabajo, sino directamente encima de ella (en su directorio
padre).  Debe configurar su variable de entorno CVSROOT o bien usar
la opción global -d, ya que CVS no podrá encontrar el repositorio
desde la copia de trabajo.

Usar release nunca es necesario.  Debido a que CVS no hace bloqueo
normalmente, puede simplemente borrar su copia de trabajo.

Sin embargo, si no ha entregado cambios en su copia de trabajo y
quiere que la cesación del trabajo sea notificada en el fichero
CVSROOT/history (ver mandato history), debe usar release.  CVS
primero comprueba cualquier cambio no entregado; si hay alguno,
avisa y pregunta si continuar. Una vez que la copia de trabajo esté
lanzada, este hecho se graba en el fichero del repositorio CVSROOT/history.

Opciones:

@itemize

@item
-d -- Borra la copia de trabajo si el lanzamiento tiene éxito. Sin -d,
la copia de trabajo permanece en el disco después del lanzamiento.

@end itemize

Si creó cualquier directorio nuevo dentro de su copia de trabajo pero
no los añadió al repositorio, serán borrados junto con el resto de
la copia de trabajo, si especificó la opción -d.

@c -----------------------------------------------------
@node remove
@subsection remove

@w{Synopsis: remove [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- rm, delete
@item Requiere -- Copia de trabajo
@item Cambia -- Copia de trabajo
@end itemize

Borra un fichero de un proyecto.  Normalmente, el fichero en sí
mismo ya está borrado del disco cuando invoca este mandato
(pero vea -f).  Aunque este mandato opera recursivamente por omisión,
es común nombrar explícitamente el los ficheros que se van a
borrar.  Note lo que implica la anterior afirmación:
Usualmente, ejecuta cvs remove en los ficheros que no ya existen
en su copia de trabajo.

Aunque se conecta con el repositorio para obtener confirmación, el fichero
no se borra efectivamente hasta que una entrega posterior se realiza.
Incluso entonces, el fichero RCS no se borra realmente de repositorio; si
es borrado del tronco, se mueve al subdirectorio Attic/, donde todavía
está disponible para su existencia en las ramas.  Si se borra de una rama,
su localización no se cambia, pero una nueva revisión con el estado
dead (muerta) se añade a la rama (Ver también @ref{add}).

Opciones:

@itemize

@item
-f -- Fuerza.  Borra el fichero de desco antes de borrarlo del CVS.
Este significado difiere del usual significado de -f en los mandatos CVS:
"Forzar a la revisión de cabecera".

@item
-l -- Local.  Ejecuta sólo en el directorio de trabajo.

@item
-R -- Recursivo.  Desciende dentro de los subdirectorios (por omisión).
Esta opción existe sólo para contrarrestar un -l en .cvsrc.

@end itemize

@c -----------------------------------------------------
@node rtag
@subsection rtag

@w{Sinopsis: rtag [OPCIONES] TAG PROJECTO(S)}

@itemize
@item Nombres alternativos -- rt, rfreeze
@item Requiere -- Repositorio
@item Cambia -- Repositorio
@end itemize

Etiqueta un módulo directamente en el repositorio (no requiere
copia de trabajo). Probablemente necesita tener su variable de
entorno CVSROOT configurada o usar la opción global -d para que
esto funcione.  (Ver también @ref{tag}).

Opciones: 

@itemize

@item
-a -- Borra la etiqueta de cualquier fichero borrado, porque los
ficheros borrados permanecen en el repositorio para propósitos
de historial, pero ya no son considerados parte del proyecto vivo.
Aunque es ilegal etiquetar ficheros con un nombre de etiqueta que
ya está en uso, no debería interferir si el nombre sólo
es usado en ficheros borrados (los cuales, desde el actual punto
de vista del proyecto, ya no existen).

@item
-b -- Crea una nueva rama, con nombre de rama ETIQUETA.

@item
-D FECHA -- Etiqueta la última revisión no posterior a FECHA.

@item
-d -- Borra la etiqueta.  No se hace ningún registro de este
cambio -- la etiqueta simplemente desaparece.  CVS no mantiene
un historial de cambios para las etiquetas.

@item
-F -- Fuerza la reasignación del nombre de la etiqueta, si
ocurre que ya existe para alguna otra revisión del fichero.

@item
-f -- Fuerza a la revisión de cabecera si una etiqueta dada o
fecha no es encontrada. (Ver -r y -D).

@item
-l -- Local.  Ejecuta en el directorio actual solamente.

@item
-n -- No ejecuta un programa de etiquetación de CVSROOT/modules
(Vea la sección @ref{Ficheros de Administracion del Repositorio}
más adelante en este capítulo para obtener detalles acerca
de estos programas).

@item
-R -- Recursivo.  Desciende dentro de subdirectorios (por omisión).
La opción -R existe sólo para contrarrestar un -l en un .cvsrc.

@item
-r REV -- Etiqueta la revisión REV (que puede ser en sí un nombre
de etiqueta).

@end itemize

@c -----------------------------------------------------
@node server
@subsection server

@w{Sinopsis: server}

Comienza un servidor CVS.  Este mandato no se invoca nunca por usuarios
(a no ser que esté intentando depurar el protocolo cliente/servidor),
así que permítame limitarme a mencionarla.

Opcions: Ninguna.

@c -----------------------------------------------------
@node status
@subsection status

@w{Synopsis: status [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- st, stat
@item Requiere -- Copia de trabajo
@item Cambia -- Nada
@end itemize

Muestra el estado de los ficheros en la copia de trabajo

Opciones: 

@itemize

@item
-l -- Local.  Se ejecuta en el directorio actual solamente.

@item
-R -- Recursivo.  Desciende dentro de los subdirectorios
(por omisión). La opción -R existe sólo para
contrarrestar un -l en .cvsrc.

@item
-v -- Muestra información de etiquetas para el fichero.

@end itemize

@c -----------------------------------------------------
@node tag
@subsection tag

@w{Sinopsis: tag [OPCIONES] TAG [FICHEROS]}

@itemize
@item Nombres alternativos -- ta, freeze
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Repositorio
@end itemize

Asigna un nombre a una revisión particular o colección de revisiones
para un proyecto.  Muchas veces se llama "tomar una instantánea" del proyecto.
Este mandato también se usa para crear ramas en CVS.  (Ver la opción
-b -- ver también @ref{rtag}).

Opciones:

@itemize

@item
-b -- Crea una rama llamada TAG.

@item
-c -- Comprueba que la copia de trabajo no tenga cambios sin entregar.
Si es así, el mandato sale con un aviso, y no se hace el etiquetado.

@item
-D FECHA -- Etiqueta la última revisión no posterior a FECHA.

@item
-d -- Borra la etiqueta.  No se graba este cambio; la etiqueta
simplemente desaparece.  CVS no mantiene un historial de cambios
de las etiquetas.

@item
-F -- Fuerza la reasignación del nombre de la etiqueta, si
ocurre que existe ya para otras revisiones del fichero.

@item
-f -- Fuerza a la revisión de cabecera si una etiqueta dada o fecha
no es encontrada.  (Ver -r y -D).

@item
-l -- Local.  Ejecuta sólo en el directorio actual.

@item
-R -- Recursivo.  Desciende en los subdirectorios (por omisión).
La opción -R existe sólo para contrarrestar un -l en un .cvsrc.

@item
-r REV -- Etiqueta la revisión REV (que puede ser en sí un
nombre de etiqueta).

@end itemize

@c -----------------------------------------------------
@node unedit
@subsection unedit

@w{Sinopsis: unedit [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- Ninguno
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- listas de edición/observación en el repositorio
@end itemize

Avisa a los observadores de que ha terminado de editar un fichero. (Ver
también @ref{watch}, @ref{watchers}, @ref{edit} y @ref{editors}).

Opciones:

@itemize

@item
-l -- Local.  Avisa sobre la edición para los ficheros del
directorio de trabajo solamente.

@item
-R -- Recursivo (contrario de -l).  Recursivo es por omisión;
la única razón de pasar -R es contrarrestar un -l en su
fichero .cvsrc.

@end itemize

@c -----------------------------------------------------
@node update
@subsection update

@w{Sinopsis: update [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- up, upd
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Copia de trabajo
@end itemize

Mezcla los cambios del repositorio en su copia de trabajo.  Como
efecto colateral, indica qué ficheros en su copia de trabajo están
modificados (pero si la opción global -Q se pasa, estas indicaciones
no se imprimen).  (Véase también @ref{checkout}).

Opciones:

@itemize

@item
-A -- Borra cualquier etiqueta adhesiva, o cualquier clave RCS de modo
de expansión adhesiva.  Esto puede resultar en que los contenidos de
los ficheros cambian, si las revisiones de la cabeza del tronco son
diferentes del las anteriores revisiones adhesivas .  (Imagine -A como
si fuera una obtención fresca del tronco de un proyecto).

@item
-C -- Borra cualquier fichero localmente alterado y los remplaza con las
últimas versiones del repositorio.  Esto no es necesariamente lo mismo
que revertir los ficheros, dado que el repositorio podría tener
cambios desde la última actualización u obtención.  Cualquier
modificación se salva en @file{.#fechero.rev}.

Nota: Esta opción fue implementada en enero de 2000; si su CVS fue
adquirido antes que entonces, tendrá que actualizarlo.

@item
-D FECHA -- Actualiza a la revisión más reciente no posterior a FECHA.
Esta opción es adhesiva e implica -P.  Si la copia de trabajo tiene fecha
adhesiva, las entregas no son posibles.

@item
-d -- Recupera directorios ausentes -- esto es, directorios que existen
en el repositorio pero no todavía en la copia de trabajo.  Tales
directorios puden haber sido creados en el repositorio después de que
la copia de trabajo fuera obtenida.  Sin esta opción, update sólo
opera en los directorios presentes en la copia de trabajo; los ficheros
se traen desde el repositorio, pero los nuevos directorios no. (Ver
también -P).

@item
-f -- Fuerza a la revisión de cabecera si no se encuentran revisiones
coincidentes con las opciones -D o -r.

@item
-I NOMBRE -- Como la opción -I de import.

@item
-j REV[:FECHA] o -j REV1[:FECHA] -j REV2[:FECHA] -- Une, o mezcla, dos
líneas de desarrollo.  No teniendo en cuenta el argumento opcional
de FECHA por el momento (lo retomaremos luego), así es cómo -j
funciona: Si sólo se da una, toma todos los cambios desde el ancestro
común a REV y los mezcla en la copia de trabajo.  El @dfn{acestro común}
es la última revisión que es acestral a ambas revisiones en el directorio
de trabajo y a REV.  Si se dan dos opciones -j, mezcla los cambios de
REV1 a REV2 en la copia de trabajo.

Las etiquetas especiales HEAD y BASE pueden ser usadas como argumentos de
-j; significan la más reciente revisión del repositorio y la revisión
en la que se basa la copia actual, respectivamente.

Y para los argumentos opcionales de FECHA, si REV es una rama, se
toma normalmente el significado de la última revisión no
posterior a FECHA.  La fecha debe estar separada de la revisión
por una coma, sin espacios, por ejemplo:

@example
floss$ cvs update -j UnaRama:1999-07-01 -j UnaRama:1999-08-01
@end example

En este ejemplo, diferentes fechas en la misma rama se usan, así
el efecto es tomar los cambios en esta rama desde julio a agosto y
mezclarlos en la copia de trabajo.  Sin embargo, note que no se
requiere que la rama sea la misma en ambas opciones -j.

@item
-k MODO -- Realiza una sustitución RCS de acuerdo al MODO.
(Vea la sección @ref{Claves de Sustitucion (Claves RCS)} más
adelante en este capítulo).  El modo permanece adhesivo en la
copia de trabajo, así que afectará a futuras actualizaciones
(pero vea -A).

@item
-l -- Local.  Actualiza sólo el directorio actual.

@item
-P -- Poda los directorios vacíos.  Cualquier directorio
controlado por CVS que no contenga ficheros al final de la actualización
se borra de la copia de trabajo.  (Ver también -d).

@item
-p -- Envía los contenidos del fichero a la salida estándar
en vez de a los ficheros.  Usando normalmente para revertir a una
revisión anterior sin producir etiquetas adhesivas en la copia de
trabajo.  Por ejemplo:

@example
floss$ cvs update -p -r 1.3 LÉAME.txt > LÉAME.txt
@end example

Ahora LÉAME.txt en la copia de trabajo tiene los contenidos de su
pasada revisión 1.3, simplemente como si lo tuviera editado a mano
en este estado.

@item
-R -- Recursivo.  Desciende a los subdirectorios para actualizar
(por omisión).  La única razón por la que lo especificaría
sería para contrarrestar un -l en .cvsrc.

@item
-r REV -- Actualiza (o rejuvenece) a la revisión REV.  Cuando
actualiza una copia de trabajo entera, REV es habitualmente una
etiqueta (regular o rama).  Sin embargo, cuando actualice un fichero
individual, es tan probable que sea un número de revisión como
una etiqueta.

Esta opción es adhesiva.  Si los ficheros se cambian a una etiqueta
que no sea de una rama o revisiones adhesivas, no pueden ser omitidas
hasta que lo adhesivo se quite.  (Véase -A).  Si REV es una
etiqueta de rama, sin embargo, las entrgas son posibles.  Simplemente
se entregarán nuevas revisiones en esta rama.

@item
-WSPEC -- Especifica filtros de cobertura para usarse durante la
actualización.  Puede usar esta opción muchas veces.  (Vea
@ref{cvswrappers} en @ref{Ficheros de Administracion del Repositorio}
en este capítulo para obtener más detalles sobre las
especificaciones de cobertura).  No hay espacio entre -W y su
argumento.

@end itemize

@c -----------------------------------------------------
@node watch
@subsection watch

@w{Sinopsis: watch on|off|add|remove [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- Ninguno
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Lista de observaciones en el repositorio
@end itemize

Configura en observación en uno o más ficheros.  A diferencia de
la mayoría de los mandatos de CVS, la observación
requiere un submandato adicional para hacer algo útil.  (Véase
también @ref{watchers}, @ref{edit}, @ref{editors}, @ref{unedit} y
@ref{users}).

Submandatos:

@itemize

@item
on -- Declara que los ficheros están siendo observados.  Esto
significa que se crean en modo de sólo-lectura en la obtención,
y los usuarios deben hacer cvs edit para crearlos como lectura-escritura
(notificar a cualquier observador que el fichero ahora está siendo
editado).  Conectar una observación no le añade a la lista de
observadores para ningún fichero. (Vea @w{@code{watch add}} y
@w{@code{watch remove}} para eso).

@item
off -- Contrario de watch on.  Declara que los ficheros ya no están
siendo observados.

@item
add -- Le añade a la lista de observadores para este fichero.
Usted será notificado cuando alguien entregue o ejecute cvs edit o
cvs unedit (pero vea la opción -a).

@item
remove -- Contrario de watch add.  Le borra de la lista de observadores
para este fichero.

@end itemize

Opciones (para usar cualquier submandato de observación).  Las tres
funciones tienen los mismos significados que para editar:

@itemize

@item
-a ACCIONES

@item
-l

@item
-R

@end itemize

@c -----------------------------------------------------
@node watchers
@subsection watchers

@w{Sinopsis: watchers [OPCIONES] [FICHEROS]}

@itemize
@item Nombres alternativos -- Ninguno
@item Requiere -- Copia de trabajo, repositorio
@item Cambia -- Nada
@end itemize

Muestra quién está observando qué ficheros.

Opciones -- estas opciones significan la misma cosa aquí que
para @ref{edit}:

@itemize

@item
-l

@item
-R

@end itemize

@c ----------------------------------------------------------------------
@node Claves de Sustitucion (Claves RCS)
@section Claves de Sustitucion (Claves RCS)

CVS puede realizar algunas sustituciones en ficheros, permitiéndole
que mantenga automáticamente alguna información actualizada en sus ficheros.
Todas las sustituciones se realizan a través de unos patrones de palabras
claves determinadas, rodeadas por los símbolos de dolar. Por ejemplo:


@example
$Revision: 1.6 $
@end example

en un fichero se expande a algo como

@example
$Revision: 1.6 $
@end example

y CVS seguirá manteniendo la cadena de revisión actualizada a medida
que se añaden nuevas revisiones.

@menu
* Controlling Keyword Expansion::          How to use keywords in your files.
* List Of Keywords::                       All the keywords.
@end menu

@c ----------------------------------------------------------------------
@node Controlling Keyword Expansion
@subsection Controlling Keyword Expansion

By default, CVS performs keyword expansion unless you tell it to stop.
You can permanently suppress keyword expansion for a file with the -k
option when you add the file to the project, or you can turn it off
later by invoking admin with -k.  The -k option offers several different
modes of keyword control; usually you want mode o or b, for example:

@example
floss$ cvs add -ko chapter-9.sgml
@end example

This command added @file{chapter-9.sgml} to the project with keyword
expansion turned off.  It sets the file's default keyword expansion mode
to @code{o}, which means no substitution. (Actually, the "o" stands for
"old", meaning to substitute the string with its old value, which is the
same as substituting it for itself, resulting in no change.  I'm sure
this logic made sense to somebody at the time.)

Each file's default keyword mode is stored in the repository.  However,
each working copy can also have its own local keyword substitution mode
-- accomplished with the -k options to checkout or update.  You can also
have a mode in effect for the duration of just one command, with the -k
option to diff.

Here are all the possible modes, presented with the -k option prepended
(as one would type at a command line).  Any of these options can be used
as either the default or local keyword substitution mode for a file:

@itemize

@item
-kkv -- Expands to keyword and value.  This is the default keyword
expansion mode, so you don't need to set it for new files.  You might
use it to change a file from another keyword mode, however.

@item
-kkvl -- Like -kkv, but includes the locker's name if the revision is
currently locked.  (See the -l option to admin for more on this.)

@item
-kk -- Won't expand values in keyword strings, just uses the keyword
name.  For example, with this option,

@example
$Revision: 1.6 $
@end example

and

@example
$Revision: 1.6 $
@end example

would both "expand" (okay, contract) to:

@example
$Revision: 1.6 $
@end example

@item
-ko -- Reuses the keyword string found in the file (hence "o" for
"old"), as it was in the working file just before the commit.

@item
-kb -- Like -ko, but also suppresses interplatform line-end conversions.
The "b" stands for "binary"; it is the mode you should use for binary
files.

@item
-kv -- Substitutes the keyword with its value, for example

@example
$Revision: 1.6 $
@end example

might become: 

@example
1.5
@end example

Of course, after that's happened once, future substitutions will not
take place, so this option should be used with care.

@end itemize

@c ----------------------------------------------------------------------
@node List Of Keywords
@subsection List Of Keywords

These are all the dollar-sign-delimited keywords that CVS recognizes.
Following is a list of the keyword, a brief description, and an example
of its expanded form:

@itemize

@item
$Author: jfs $ -- Author of the change:

@example
$Author: jfs $
@end example

@item
$Date: 2002/12/05 19:10:27 $ -- The date and time of the change, in UTC (GMT):

@example
$Date: 2002/12/05 19:10:27 $
@end example

@item
$Header: /home/cvs/lucas/doc-cvsbook-es/chapter-9.texi,v 1.6 2002/12/05 19:10:27 jfs Exp $ -- Various pieces of information thought to be useful: full
path to the RCS file in the repository, revision, date (in UTC), author,
state, and locker. (Lockers are rare; although in the following example,
qsmith has a lock.):

@example
$Header: /usr/local/newrepos/myproj/hello.c,v 1.1 1999/06/01 \
03:21:13 jrandom Exp qsmith $
@end example

@item
$Id: chapter-9.texi,v 1.6 2002/12/05 19:10:27 jfs Exp $ -- Like $Header: /home/cvs/lucas/doc-cvsbook-es/chapter-9.texi,v 1.6 2002/12/05 19:10:27 jfs Exp $, but without the full path to the RCS file:

@example
$Id: chapter-9.texi,v 1.6 2002/12/05 19:10:27 jfs Exp $
@end example

@item
$Log: chapter-9.texi,v $
Revision 1.6  2002/12/05 19:10:27  jfs
Ahora el documento compila incluyendo los acentos en castellano, he seguido
los consejos de
http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
Sin embargo sería conveniente revisar por qué los nombres de nodo que se
referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?

Revision 1.5  2002/12/05 17:12:19  jfs
Actualizado el LEAME y traducido (un poco) el capítulo 9

Revision 1.4  2002/12/03 13:04:59  carlosgarcia
Traduccion de main, introduction e index

Revision 1.3  2002/11/27 16:25:32  carlosgarcia
Falta traducir el final del fichero
 -- The log message of this revision, along with the revision
number, date, and author.  Unlike other keywords, the previous
expansions are not replaced.  Instead, they are pushed down, so that the
newest expansion appears at the top of an ever-growing stack of $Log: chapter-9.texi,v $
newest expansion appears at the top of an ever-growing stack of Revision 1.6  2002/12/05 19:10:27  jfs
newest expansion appears at the top of an ever-growing stack of Ahora el documento compila incluyendo los acentos en castellano, he seguido
newest expansion appears at the top of an ever-growing stack of los consejos de
newest expansion appears at the top of an ever-growing stack of http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
newest expansion appears at the top of an ever-growing stack of Sin embargo sería conveniente revisar por qué los nombres de nodo que se
newest expansion appears at the top of an ever-growing stack of referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
newest expansion appears at the top of an ever-growing stack of
newest expansion appears at the top of an ever-growing stack of Revision 1.5  2002/12/05 17:12:19  jfs
newest expansion appears at the top of an ever-growing stack of Actualizado el LEAME y traducido (un poco) el capítulo 9
newest expansion appears at the top of an ever-growing stack of
newest expansion appears at the top of an ever-growing stack of Revision 1.4  2002/12/03 13:04:59  carlosgarcia
newest expansion appears at the top of an ever-growing stack of Traduccion de main, introduction e index
newest expansion appears at the top of an ever-growing stack of
newest expansion appears at the top of an ever-growing stack of Revision 1.3  2002/11/27 16:25:32  carlosgarcia
newest expansion appears at the top of an ever-growing stack of Falta traducir el final del fichero
newest expansion appears at the top of an ever-growing stack of
messages:

@example
$Log: chapter-9.texi,v $
Revision 1.6  2002/12/05 19:10:27  jfs
Ahora el documento compila incluyendo los acentos en castellano, he seguido
los consejos de
http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
Sin embargo sería conveniente revisar por qué los nombres de nodo que se
referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?

Revision 1.5  2002/12/05 17:12:19  jfs
Actualizado el LEAME y traducido (un poco) el capítulo 9

Revision 1.4  2002/12/03 13:04:59  carlosgarcia
Traduccion de main, introduction e index

Revision 1.3  2002/11/27 16:25:32  carlosgarcia
Falta traducir el final del fichero
    Revision 1.12  1999/07/19 06:12:43  jrandom
    say hello in Aramaic
@end example

	Any text preceding the $Log: chapter-9.texi,v $
	Any text preceding the Revision 1.6  2002/12/05 19:10:27  jfs
	Any text preceding the Ahora el documento compila incluyendo los acentos en castellano, he seguido
	Any text preceding the los consejos de
	Any text preceding the http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
	Any text preceding the Sin embargo sería conveniente revisar por qué los nombres de nodo que se
	Any text preceding the referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
	Any text preceding the
	Any text preceding the Revision 1.5  2002/12/05 17:12:19  jfs
	Any text preceding the Actualizado el LEAME y traducido (un poco) el capítulo 9
	Any text preceding the
	Any text preceding the Revision 1.4  2002/12/03 13:04:59  carlosgarcia
	Any text preceding the Traduccion de main, introduction e index
	Any text preceding the
	Any text preceding the Revision 1.3  2002/11/27 16:25:32  carlosgarcia
	Any text preceding the Falta traducir el final del fichero
	Any text preceding the keyword on the same line will be prepended to the downward expansions too; this is so that if you use it in a comment in a program source file, all of the expansion is commented, too. 

@item
$Locker:  $ -- Name of the person who has a lock on this revision (usually
no one):

@example
$Locker:  $
@end example

@item
$Name:  $ -- Name of the sticky tag:

@example
$Name:  $
@end example

@item
$RCSfile: chapter-9.texi,v $ -- Name of the RCS file in the repository:

@example
$RCSfile: chapter-9.texi,v $
@end example

@item
$Revision: 1.6 $ -- Revision number:

@example
$Revision: 1.6 $
@end example

@item
$Source: /home/cvs/lucas/doc-cvsbook-es/chapter-9.texi,v $ -- Full path to the RCS file in the repository:

@example
$Source: /home/cvs/lucas/doc-cvsbook-es/chapter-9.texi,v $
@end example

@item
$State: Exp $ -- State of this revision:

@example
$State: Exp $
@end example

@end itemize

@c ----------------------------------------------------------------------
@node Ficheros de Administracion del Repositorio
@section Ficheros de Administracion del Repositorio

The repository's administrative files are stored in the CVSROOT
subdirectory of the repository.  These files control various aspects of
CVS's behavior (in that repository only, of course).

You may also want to refer to the discussion of administrative files in
@ref{Administracion del Repositorio}, which includes examples.

@menu
* Storage And Editing::      How to make changes to the administrative files.
* Shared Syntax::            Most administrative files share a common syntax.
* Shared Variables::         Some administrative files can expand variables.
* User Variables::           How to expand run-time variables set by users.
* checkoutlist::             The @file{checkoutlist} file.
* commitinfo::               The @file{commitinfo} file.
* config::                   The @file{config} file.
* cvsignore::                The @file{cvsignore} file.
* cvswrappers::              The @file{cvswrappers} file.
* editinfo::                 The @file{editinfo} file.
* history file::             The @file{history} file.
* loginfo::                  The @file{loginfo} file.
* modules::                  The @file{modules} file.
* notify::                   The @file{notify} file.
* passwd::                   The @file{passwd} file.
* rcsinfo::                  The @file{rcsinfo} file.
* taginfo::                  The @file{taginfo} file.
* users::                    The @file{users} file.
* val-tags::                 The @file{val-tags} file.
* verifymsg::                The @file{verifymsg} file.
@end menu

@c ----------------------------------------------------------------------
@node Storage And Editing
@subsection Storage And Editing

Generally, the administrative files are kept under revision control just
like any other file in the repository (the exceptions are noted).
However, unlike other files, checked-out copies of the administrative
files are stored in the repository, right next to their corresponding
RCS files in the @file{CVSROOT} subdirectory.  It is these checked-out
copies which actually govern CVS's behavior.

The normal way to modify the administrative files is to check out a
working copy of the CVSROOT module, make your changes, and commit.  CVS
updates the checked-out copies in the repository automatically.  (See
@ref{checkoutlist}.)  In an emergency, however, it is also possible to
edit the checked-out copies in the repository directly.

@c ----------------------------------------------------------------------
@node Shared Syntax
@subsection Shared Syntax

In all of the administrative files, a @code{#} at the beginning of a line
signifies a comment; that line is ignored by CVS.  A backslash preceding
a newline quotes the newline out of existence.

Some of the files (commitinfo, loginfo, taginfo, and rcsinfo) share more
syntactic conventions as well.  In these files, on the left of each line
is a regular expression (which is matched against a file or directory
name), and the rest of the line is a program, possibly with arguments,
which is invoked if something is done to a file matching the regular
expression.  The program is run with its working directory set to the
top of the repository.

In these files, there are two special regular expressions that may be
used: ALL and DEFAULT.  ALL matches any file or directory, whether or
not there is some other match for it, and DEFAULT matches only if
nothing else matched.

@c ----------------------------------------------------------------------
@node Shared Variables
@subsection Shared Variables

The info files also allow certain variables to be expanded at runtime.
To expand a variable, precede it with a dollar sign (and put it in curly
braces just to be safe).  Here are the variables CVS knows about:

@itemize

@item
$@{CVSROOT@} -- The top of the repository.

@item
$@{RCSBIN@} -- (Obsolete) Don't use this variable.  It is only
applicable in CVS Version 1.9.18 and older.  Specifying it now may
result in an error.

@item
$@{CVSEDITOR@} $@{VISUAL@} $@{EDITOR@} -- These all expand to the editor
that CVS is using for a log message.

@item
$@{USER@} -- The user running CVS (on the server side).

@end itemize

@c ----------------------------------------------------------------------
@node User Variables
@subsection User Variables

Users can also set their own variables when they run any CVS
command.  (See the -s global option.)  These variables can be accessed
in the @file{*info} files by preceding them with an equal sign, as in
$@{=VAR@}.

@c -----------------------------------------------------
@node checkoutlist
@subsection checkoutlist

This contains a list of files for which checked-out copies should be
kept in the repository.  Each line gives the file name and an error
message for CVS to print if, for some reason, the file cannot be checked
out in the repository:

@example
FILENAME  ERROR_MESSAGE
@end example

Because CVS already knows to keep checked-out copies of the existing
administrative files, they do not need to be listed in checkoutlist.
Specifically, the following files never need entries in checkoutlist:
loginfo, rcsinfo, editinfo, verifymsg, commitinfo, taginfo, ignore,
checkoutlist, cvswrappers, notify, modules, readers, writers, and
config.
@cindex CVSROOT checked-out files
@cindex checked-out files
@cindex checkoutlist (files automatically included)

@c -----------------------------------------------------
@node commitinfo
@subsection commitinfo

Specifies programs to run at commit time, based on what's being
committed.  Each line consists of a regular expression followed by a
command template:

@example
REGULAR_EXPRESSION PROGRAM [ARGUMENTS]
@end example

The PROGRAM is passed additional arguments following any arguments you
may have written into the template.  These additional arguments are the
full path to the repository, followed by the name of each file about to
be committed.  These files can be examined by PROGRAM; their contents
are the same as those of the working copy files about to be committed.
If PROGRAM exits with nonzero status, the commit fails; otherwise, it
succeeds.  (See also @ref{Shared Syntax} earlier in this chapter.)

@c -----------------------------------------------------
@node config
@subsection config

Controls various global (non-project-specific) repository parameters.
The syntax of each line is

@example
ParameterName=yes|no
@end example

except for the LockDir parameter, which takes an absolute pathname as
argument.

The following parameters are supported:

@itemize

@item
RCSBIN (default: @code{=no}) -- (Obsolete) This option is silently
accepted for backwards compatibility, but no longer has any effect.

@item
SystemAuth (default: @code{=no}) -- If @code{yes}, CVS pserver
authentication tries the system user database -- usually
@file{/etc/passwd} -- if a username is not found in
@file{CVSROOT/passwd}.  If @code{no}, the user must exist in
@file{CVSROOT/passwd} to gain access via the @code{:pserver:} method.

@item
PreservePermissions (default: @code{=no}) -- If @code{yes}, CVS tries to
preserve permissions and other special file system information (such as
device numbers and symbolic link targets) for files.  You probably don't
want to do this, as it does not necessarily behave as expected. (See the
node @cite{Special Files} in the Cederqvist manual for details.)

@item
TopLevelAdmin (default: @code{=no}) -- If @code{yes}, checkouts create a
@file{CVS/} subdirectory next to each working copy tree (in the parent
directory of the working copy).  This can be useful if you will be
checking out many working copies from the same repository; on the other
hand, setting it here affects everyone who uses this repository.

@item
LockDir (unset by default) -- The argument after the equal sign is a
path to a directory in which CVS can create lockfiles.  If not set,
lockfiles are created in the repository, in locations corresponding to
each project's RCS files.  This means that users of those projects must
have file-system-level write access to those repository directories.

@end itemize

@c -----------------------------------------------------
@node cvsignore
@subsection cvsignore

Ignores certain files when doing updates, imports, or releases.  By
default, CVS already ignores some kinds of files. (For a full list, see
the -I option to import, earlier in this chapter.)  You can add to this
list by putting additional file names or wildcard patterns in the
cvsignore file.  Each line gives a file name or pattern, for example:

@example
README.msdos
*.html
blah?.out
@end example

This causes CVS to ignore any file named @file{README.msdos}, any file
ending in @file{.html}, and any file beginning with @file{blah} and
ending with @file{.out}.  (Technically, you can name multiple files or
patterns on each line, separated by whitespace, but it is more readable
to keep them to one per line.  The whitespace separation rule does,
unfortunately, mean that there's no way to specify a space in a file
name, except to use wildcards.)

A @code{!} anywhere in the list cancels all previous entries.  (See
@ref{$CVSIGNORE} in the section @ref{Environment Variables} in
this chapter for a fuller discussion of ignore processing.)

@c -----------------------------------------------------
@node cvswrappers 
@subsection cvswrappers 

Specifies certain filtering behaviors based on file name.  Each line has
a file-globbing pattern (that is, a file name or file wildcards),
followed by an option indicating the filter type and an argument for the
option.

Options: 

@itemize

@item
-m -- Specifies an update method.  Possible arguments are MERGE, which
means to merge changes into working files automatically, and COPY, which
means don't try to automerge but present the user with both versions of
the file and let them work it out.  MERGE is the default, except for
binary files (those whose keyword substitution mode is -kb).  (See the
@ref{Claves de Sustitucion (Claves RCS)} section in this chapter.)
Files marked as binary automatically use the COPY method, so there is no
need to make a -m COPY wrapper for them.

@item
-k -- Specifies a keyword substitution mode.  All of the usual modes are
possible.  (See the @ref{Claves de Sustitucion (Claves RCS)} section in
this chapter for a complete list.)

@end itemize

Here is an example cvswrappers file:

@example
*.blob    -m COPY
*.blink   -k o
@end example

This cvswrappers file says to not attempt merges on files ending in
@file{.blob} and suppress keyword substitution for files ending in
@file{.blink}.  (See also the file @file{.cvswrappers} in the
@ref{Working Copy Files} section in this chapter.)

@c -----------------------------------------------------
@node editinfo
@subsection editinfo

This file is obsolete.  Very.

@c -----------------------------------------------------
@node history file
@subsection history file

Stores an ever-accumulating history of activity in the repository, for
use by the cvs history command.  To disable this feature, simply remove
the history file.  If you don't remove the file, you should probably
make it world-writeable to avoid permission problems later.

The contents of this file do not modify CVS's behavior in any way
(except for the output of cvs history, of course).

@c -----------------------------------------------------
@node loginfo
@subsection loginfo

Specifies programs to run on the log message for each commit, based on
what's being committed.  Each line consists of a regular expression
followed by a command template:

@example
REGULAR_EXPRESSION PROGRAM [ARGUMENTS]
@end example

The PROGRAM is passed the log message on its standard input.

Several special codes are available for use in the arguments: @code{%s}
expands to the names of the files being committed, @code{%V} expands to
the old revisions from before the commit, and @code{%v} expands to the
new revisions after the commit.  When there are multiple files involved,
each element of the expansion is separated from the others by
whitespace.  For example, in a commit involving two files, @code{%s}
might expand into @w{@code{hello.c README.txt}}, and @code{%v} into
@w{@code{1.17 1.12}}.

You may combine codes inside curly braces, in which case, each unit of
expansion is internally separated by commas and externally separated
from the other units by whitespace.  Continuing the previous example,
@code{%@{sv@}} expands into @w{@code{hello.c,1.17 README.txt,1.12}}.

If any @code{%} expansion is done at all, the expansion is prefixed by
the path to the project subdirectory (relative to the top of the
repository).  So that last expansion would actually be:

@example
myproj  hello.c,1.17  README.txt,1.12
@end example

If PROGRAM exits with nonzero status, the commit fails; otherwise, it
succeeds.  (See also the @ref{Shared Syntax} section in this
chapter.)

@c -----------------------------------------------------
@node modules
@subsection modules

This maps names to repository directories.  The general syntax of each
line is:

@example
@w{MODULE [OPTIONS] [&OTHERMODULE...] [DIR] [FILES]}
@end example

DIR need not be a top-level project directory -- it could be a
subdirectory.  If any FILES are specified, the module consists of only
those files from the directory.

An ampersand followed by a module name means to include the expansion of
that module's line in place.

Options:

@itemize

@item
-a -- This is an @dfn{alias} module, meaning it expands literally to
everything after the OPTIONS.  In this case, the usual DIR/FILES
behavior is turned off, and everything after the OPTIONS is treated as
other modules or repository directories.

If you use the -a option, you may exclude certain directories from other
modules by putting them after an exclamation point (!).  For example

@example
top_proj -a !myproj/a-subdir !myproj/b-subdir myproj
@end example

means that checking out @code{top_proj} will get all of @code{myproj}
except @code{a-subdir} and @code{b-subdir}.

@item
-d NAME -- Names the working directory NAME instead of the module name.

@item
-e PROGRAM -- Runs PROGRAM whenever files in this module are exported.

@item
-i PROGRAM -- Runs PROGRAM whenever files in this module are committed.
The program is given a single argument -- the full pathname in the
repository of the file in question. (See @ref{commitinfo},
@ref{loginfo}, and @ref{verifymsg} for more sophisticated ways to
run commit-triggered programs.)

@item
-o PROGRAM -- Runs PROGRAM whenever files in this module are checked
out.  The program is given a single argument, the name of the module.

@item
-s STATUS -- Declares a status for the module.  When the modules file is
printed (with cvs checkout -s), the modules are sorted by module status
and then by name.  This option has no other effects in CVS, so go wild.
You can use it to sort anything -- status, person responsible for the
module, or the module's file language, for example.

@item
-t PROGRAM -- Runs PROGRAM whenever files in this module are tagged with
cvs rtag.  The program is passed two arguments: the name of the module
and the tag name.  The program is not used for tag, only for rtag.  I
have no idea why this distinction is made.  You may find the taginfo
file more useful if you want to run programs at tag time.

@item
-u PROGRAM -- Runs PROGRAM whenever a working copy of the module is
updated from its top-level directory.  The program is given a single
argument, the full path to the module's repository.

@end itemize

@c -----------------------------------------------------
@node notify
@subsection notify

Controls how the notifications for watched files are performed. (You may
want to read up on the watch and edit commands, or see the section
@ref{Alarmas (CVS como telefono)} in @ref{CVS avanzado}.)  Each line is
of the usual form:

@w{REGULAR_EXPRESSION PROGRAM [ARGUMENTS]}

A @code{%s} in ARGUMENTS is expanded to the name of the user to be
notified, and the rest of the information regarding the notification is
passed to PROGRAM on standard input (usually this information is a brief
message suitable for emailing to the user).  (See the section
@ref{Shared Syntax} earlier in this chapter.)

As shipped with CVS, the notify file has one line

@example
ALL mail %s -s "CVS notification"
@end example

which is often all you need.

@c -----------------------------------------------------
@node passwd
@subsection passwd

Provides authentication information for the pserver access method.  Each
line is of the form:

@w{USER:ENCRYPTED_PASSWORD[:SYSTEM_USER]}

If no SYSTEM_USER is given, USER is taken as the system username.

@c -----------------------------------------------------
@node rcsinfo
@subsection rcsinfo

Specifies a form that should be filled out for log messages that are
written with an interactive editor.  Each line of rcsinfo looks like:

@w{REGULAR_EXPRESSION FILE_CONTAINING_TEMPLATE}

This template is brought to remote working copies at checkout time, so
if the template file or rcsinfo file changes after checkout, the remote
copies won't know about it and will continue to use the old template.
(See also the section @ref{Shared Syntax} in this chapter.)

@c -----------------------------------------------------
@node taginfo
@subsection taginfo

Runs a program at tag time (usually done to check that the tag name
matches some pattern).  Each line is of the form:

@w{REGULAR_EXPRESSION PROGRAM}

The program is handed a set group of arguments.  In order, they are the
tag name, the operation (see below), the repository, and then as many
file name/revision-number pairs as there are files involved in the tag.
The file/revision pairs are separated by whitespace, like the rest of
the arguments.

The operation is one of @code{add}, @code{mov}, or @code{del}
(@code{mov} means the -F option to tag was used).

If PROGRAM exits with nonzero status, the tag operation will not
succeed.  (See also the section @ref{Shared Syntax} in this chapter.)

@c -----------------------------------------------------
@node users
@subsection users

Maps usernames to email addresses.  Each line looks like:

@w{USERNAME:EMAIL_ADDRESS}

This sends watch notifications to EMAIL_ADDRESS instead of to USERNAME
at the repository machine.  (All this really does is control the
expansion of %s in the notify file.)  If EMAIL_ADDRESS includes
whitespace, make sure to surround it with quotes.

If user aliasing is being used in the passwd file, the username that
will be matched is the CVS username (the one on the left), not the
system username (the one on the right, if any).

@c -----------------------------------------------------
@node val-tags
@subsection val-tags

Caches valid tag names for speedier lookups.  You should never need to
edit this file, but you may need to change its permissions, or even
ownership, if people are having trouble retrieving or creating tags.

@c -----------------------------------------------------
@node verifymsg
@subsection verifymsg

Used in conjunction with rcsinfo to verify the format of log messages.
Each line is of the form:

@w{REGULAR_EXPRESSION PROGRAM [ARGUMENTS]}

The full path to the current log message template (see @ref{rcsinfo}
earlier in this chapter) is appended after the last argument written in
the verifymsg file.  If PROGRAM exits with nonzero status, the commit
fails.

@c ----------------------------------------------------------------------
@node Ficheros de Control de Ejecucion
@section Ficheros de Control de Ejecucion

There are a few files on the client (working copy) side that affect
CVS's behavior.  In some cases, they are analogs of repository
administrative files; in other cases, they control behaviors that are
only appropriate for the client side.

@subsection @file{.cvsrc}

Specifies options that you want to be used automatically with every CVS
command.  The format of each line is

@w{COMMAND OPTIONS}

where each COMMAND is an unabbreviated CVS command, such as checkout or
update (but not co or up).  The OPTIONS are those that you want to
always be in effect when you run that command.  Here is a common
@file{.cvsrc} line:

@example
update -d -P
@end example

To specify global options, simple use cvs as the COMMAND.

@subsection @file{.cvsignore}

Specifies additional ignore patterns.  (See @ref{cvsignore} in the
@ref{Ficheros de Administracion del Repositorio} section in this chapter for the
syntax.)

You can have a .cvsignore file in your home directory, which will apply
every time you use CVS.  You can also have directory-specific ones in
each project directory of a working copy (these last only apply to the
directory where the .cvsignore is located, and not to its
subdirectories).

(See @ref{$CVSIGNORE} in the section @ref{Environment Variables}
in this chapter, for a fuller discussion of ignore processing.)

@subsection @file{.cvspass}

Stores passwords for each repository accessed via the pserver method.
Each line is of the form:

@w{REPOSITORY LIGHTLY_SCRAMBLED_PASSWORD}

The password is essentially stored in cleartext -- a very mild
scrambling is done to prevent accidental compromises (such as the root
user unintentionally looking inside the file).  However, this scrambling
will not deter any serious-minded person from gaining the password if
they get access to the file.

The .cvspass file is portable.  You can copy it from one machine to
another and have all of your passwords at the new machine, without ever
having run cvs login there.  (See also the @ref{login} and
@ref{logout} commands.)

@subsection @file{.cvswrappers}

This is a client side version of the cvswrappers file.  (See the
@ref{Ficheros de Administracion del Repositorio} section in this chapter.)
There can be a @file{.cvswrappers} file in your home directory and in
each directory of a working copy directory, just as with
@file{.cvsignore}.

@c ----------------------------------------------------------------------
@node Working Copy Files
@section Working Copy Files

The CVS/ administrative subdirectories in each working copy contain some
subset of the following files.

@itemize @bullet
@item
CVS/Base/
@item
CVS/Baserev
@item
CVS/Baserev.tmp
@item
CVS/Checkin.prog
@item
CVS/Entries
@item
CVS/Entries.Backup
@item
CVS/Entries.Log
@item
CVS/Entries.Static
@item
CVS/Notify
@item
CVS/Notify.tmp
@item
CVS/Repository
@item
CVS/Root
@item
CVS/Tag
@item
CVS/Template
@item
CVS/Update.prog
@end itemize

Here is what each file or directory does:

@subsection @w{@file{CVS/Base/}  (directory)}

If watches are on, @w{@code{cvs edit}} stores the original copy of the
file in this directory.  That way, @w{@code{cvs unedit}} can work even
if it can't reach the server.

@subsection @file{CVS/Baserev}

Lists the revision for each file in @file{Base/}.  Each line looks like
this:

@example
FILE/REVISION/EXPANSION
@end example

EXPANSION is currently ignored to allow for, well, future expansion.

@subsection @file{CVS/Baserev.tmp}

This is the temp file for the preceding.  (See @file{CVS/Notify.tmp} or
@file{CVS/Entries.Backup} later on for further explanation.)

@subsection @file{CVS/Checkin.prog}

Records the name of the program specified by the -i option in the
modules file.  (See the @ref{Ficheros de Administracion del Repositorio} section
in this chapter.)

@subsection @file{CVS/Entries}

Stores the revisions for the files in this directory.  Each line is of
the form:

@example
@w{[CODE_LETTER]/FILE/REVISION/DATE/[KEYWORD_MODE]/[STICKY_OPTION]}
@end example

If CODE_LETTER is present, it must be @code{D} for directory (anything
else is silently ignored by CVS, to allow for future expansion), and the
rest of the items on the line are absent.

This file is always present.

@subsection @file{CVS/Entries.Backup}

This is just a temp file.  If you're writing some program to modify the
@file{Entries} file, have it write the new contents to
@file{Entries.backup} and then atomically rename it to @file{Entries}.

@subsection @file{CVS/Entries.Log}

This is basically a patch file to be applied to @file{Entries} after
@file{Entries} has been read (this is an efficiency hack, to avoid
having to rewrite all of @file{Entries} for every little change).  The
format is the same as @file{Entries}, except that there is an additional
mandatory code letter at the front of every line: An @code{A} means this
line is to be added to what's in @file{Entries}; @code{R} means it's to
be removed from what's in @file{Entries}.  Any other letters should be
silently ignored, to allow for future expansion.

@subsection @file{CVS/Entries.Static}

If this file exists, it means only part of the directory was fetched
from the repository, and CVS will not create additional files in that
directory.  This condition can usually be cleared by using
@w{@code{update -d}}.

@subsection @file{CVS/Notify}

Stores notifications that have not yet been sent to the server.

@subsection @file{CVS/Notify.tmp}

Temp file for @file{Notify}.  The usual procedure for modifying
@file{Notify} is to write out @file{Notify.tmp} and then rename it to
@file{Notify}.

@subsection @file{CVS/Repository}

The path to the project-specific subdirectory in the repository.  This
may be an absolute path, or it may be relative to the path given in
Root.

This file is always present.

@subsection @file{CVS/Root}

This is the repository; that is, the value of the @code{$CVSROOT}
environment variable or the argument to the -d global option.

This file is always present.

@subsection @file{CVS/Tag}

If there is a sticky tag or date on this directory, it is recorded in
the first line of the file.  The first character is a single letter
indicating the type of tag: @code{T}, @code{N}, or @code{D}, for branch
tag, nonbranch tag, or date respectively.  The rest of the line is the
tag or date itself.

@subsection @file{CVS/Template}

Contains a log message template as specified by the rcsinfo file.  (See
@ref{Ficheros de Administracion del Repositorio} earlier in this chapter.)  It
is relevant only for remote working copies; working copies on the same
machine as the repository just read rcsinfo directly.

@subsection @file{CVS/Update.prog}

Records the name of the program specified by the -u option in the
modules file.  (See the @ref{Ficheros de Administracion del Repositorio} section
in this chapter.)

@c ----------------------------------------------------------------------
@node Environment Variables
@section Environment Variables

These are all the environment variables that affect CVS.

@menu
* $COMSPEC::
* $CVS_CLIENT_LOG::
* $CVS_CLIENT_PORT::
* $CVSEDITOR::
* $CVSIGNORE::
* $CVS_IGNORE_REMOTE_ROOT::
* $CVS_PASSFILE::
* $CVS_RCMD_PORT::
* $CVSREAD::
* $CVSROOT::
* $CVS_RSH::
* $CVS_SERVER::
* $CVS_SERVER_SLEEP::
* $CVSUMASK::
* $CVSWRAPPERS::
* $EDITOR::
* $HOME %HOMEDRIVE% %HOMEPATH%::
* $PATH::
* $TEMP $TMP $TMPDIR::
* $VISUAL::
@end menu

@c -----------------------------------------------------
@node $COMSPEC
@subsection $COMSPEC

This is used in OS/2 only; it specifies the name of the command
interpreter.  It defaults to @code{CMD.EXE}.

@c -----------------------------------------------------
@node $CVS_CLIENT_LOG
@subsection $CVS_CLIENT_LOG

Used for debugging the client/server protocol.  Set this variable to a
file name before you start using CVS; all traffic to the server will be
logged in filename.in, and everything from the server will be logged in
filename.out.

@c -----------------------------------------------------
@node $CVS_CLIENT_PORT
@subsection $CVS_CLIENT_PORT

Used in Kerberos-authenticated client/server access.

@c -----------------------------------------------------
@node $CVSEDITOR
@subsection $CVSEDITOR

Specifies the program to use to edit log messages for commits.  This
overrides @code{$EDITOR} and @code{$VISUAL}.

@c -----------------------------------------------------
@node $CVSIGNORE
@subsection $CVSIGNORE

A whitespace-separated list of file names and wildcard patterns that CVS
should ignore.  (See also the -I option to the @ref{import} command.)

This variable is appended last to the ignore list during a command.  The
list is built up in this order: @file{CVSROOT/cvsignore}, the
@file{.cvsignore} file in your home directory, the @code{$CVSIGNORE}
variable, any -I command option, and finally the contents of
@file{.cvsignore} files in the working copy used as CVS works in each
directory.  A @code{!} as the ignore specification at any point
nullifies the entire ignore list built up to that point.

@c -----------------------------------------------------
@node $CVS_IGNORE_REMOTE_ROOT
@subsection $CVS_IGNORE_REMOTE_ROOT

Recently obsolete.

@c -----------------------------------------------------
@node $CVS_PASSFILE
@subsection $CVS_PASSFILE

Tells CVS to use some file other than .cvspass in your home directory.
(See the file @file{.cvspass} in the @ref{Ficheros de Control de Ejecucion} section in
this chapter.)

@c -----------------------------------------------------
@node $CVS_RCMD_PORT
@subsection $CVS_RCMD_PORT

Specifies the port number to contact the rcmd daemon on the server side.
(This variable is currently ignored in Unix CVS clients.)

@c -----------------------------------------------------
@node $CVSREAD
@subsection $CVSREAD

Makes working copy files read-only on checkout and update, if possible
(the default is for them to be read-write).  (See also the -r global
option.)

@c -----------------------------------------------------
@node $CVSROOT
@subsection $CVSROOT

This specifies the path to the repository.  This is overridden with the
-d global option and by the ambient repository for a given working copy.
The path to the repository may be preceded by an access method,
username, and host, according to the following syntax:

@example
[[:METHOD:][[USER@@]HOST]:]/REPOSITORY_PATH
@end example

See the -d global option, in the section @ref{Opciones Globales} near
the beginning of this chapter, for a list of valid methods.

@c -----------------------------------------------------
@node $CVS_RSH
@subsection $CVS_RSH

Specifies an external program for connecting to the server when using
the @code{:ext:} access method.  Defaults to @code{rsh}, but @code{ssh}
is a common replacement value.

@c -----------------------------------------------------
@node $CVS_SERVER
@subsection $CVS_SERVER

Program to invoke for CVS on the server side.  Defaults to @code{cvs},
of course.

@c -----------------------------------------------------
@node $CVS_SERVER_SLEEP
@subsection $CVS_SERVER_SLEEP

Delays the start of the server child process by the specified number of
seconds.  This is used only for debugging, to allow time for a debugger
to connect.

@c -----------------------------------------------------
@node $CVSUMASK
@subsection $CVSUMASK

Permissions for files and directories in the repository.  (You probably
don't want to set this; it doesn't work for client/server anyway.)

@c -----------------------------------------------------
@node $CVSWRAPPERS
@subsection $CVSWRAPPERS

A whitespace-separated list of file names, wildcards, and arguments that
CVS should use as wrappers. (See @ref{cvswrappers} in the
@ref{Ficheros de Administracion del Repositorio} section in this chapter for
more information.)

@c -----------------------------------------------------
@node $EDITOR
@subsection $EDITOR

(See @ref{$CVSEDITOR}.)

@c -----------------------------------------------------
@node $HOME %HOMEDRIVE% %HOMEPATH%
@subsection $HOME %HOMEDRIVE% %HOMEPATH%
@cindex $HOME
@cindex %HOMEDRIVE%
@cindex %HOMEPATH%

Where the @file{.cvsrc}, @file{.cvspass}, and other such files are found
(under Unix, only @code{$HOME} is used).  In Windows NT,
@code{%HOMEDRIVE%} and @code{%HOMEPATH%} might be set for you; in
Windows 95, you may need to set them for yourself.

In Windows 95, you may also need to set @code{%HOME%}.  Make sure not to
give it a trailing backslash; use set @code{HOME=C:} or something
similar.

@c -----------------------------------------------------
@node $PATH
@subsection $PATH

Obsolete.

@c -----------------------------------------------------
@node $TEMP $TMP $TMPDIR
@subsection $TEMP $TMP $TMPDIR
@cindex $TEMP
@cindex $TMP
@cindex $TMPDIR

Where temporary files go (the server uses TMPDIR; Windows NT uses TMP).
Setting this on the client side will not affect the server.  Setting
this on either side will not affect where CVS stores temporary lock
files.  (See @ref{config} in the @ref{Ficheros de Administracion del 
Repositorio} section in this chapter for more information.)

@c -----------------------------------------------------
@node $VISUAL
@subsection $VISUAL

(See @ref{$CVSEDITOR}.)
