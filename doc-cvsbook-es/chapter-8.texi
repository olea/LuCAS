@c ---------------------------------------------------------
@node Problemas y Soluciones
@unnumbered Problemas y Soluciones

@comment Este capítulo ha sido traducido por:
@comment Juan José Amor Iglesias <jjamor@@hispalinux.es>
@comment se ceden todos los derechos bajo la licencia de documentación de
@comment la GNU (fdl) que se puede encontrar en http://www.gnu.org/
@comment  
@comment $Id: chapter-8.texi,v 1.5 2002/12/05 19:10:27 jfs Exp $


Comenté en capítulos anteriores que CVS no es un software de "caja
negra". Las cajas negras no le permiten ver lo que hay dentro; no le dan
acceso interno que le permita arreglar (o estropear) cosas. La causa es
que la caja negra normalmente no necesitará ser revisada por usted. Casi
siempre, el software funcionará correctamente, por lo que los usuarios
no necesitarán acceso interno. Pero cuando las cajas negras fallan,
tienden a hacerlo completamente. Cualquier problema será un "exitazo",
puesto que no hay muchas opciones para reparar.

CVS es más bien como una caja perfectamente transparente. Sus partes
"móviles" están expuestas directamente al entorno, y fallos de ese
entorno (permisos inesperados en ficheros, comandos interrumpidos,
procesos en competencia, etc) pueden a veces influir en el mecanismo
interno y producir fallos. Pero aunque CVS no siempre funciona a la
perfección, raramente falla por completo. Tiene la ventaja de tener una
"degradación gradual": el porcentaje de fallos es proporcional al número
y severidad de problemas con el entorno. Si tenemos suficiente idea
acerca de lo que CVS está tratando de hacer -- y cómo lo quiere hacer --
sabremos qué hacer cuando las cosas van mal.

Aunque no puedo listar todos los problemas que puede encontrar, he
incluido algunos de los más habituales. Este capítulo está dividido en
dos partes: la primera describe aquellas partes del entorno a las que
CVS es más sensible (principalmente, permisos del repositorio y de la copia
de trabajo del área administrativa), y la segunda describe algunos de
los problemas que se encuentran con más frecuencia y sus
soluciones. Observando cómo se gestionan esas situaciones, obtendremos
una capacidad para acercarnos a la solución de otros problemas con CVS
no descritos aquí.

@menu
* Causas Usualmente Sospechosas::            Cosas que suelen causar problemas.
* Trucos Habituales::                        Técnicas de diagnosis habituales.
* Algunos Problemas de la Vida Real (con Soluciones):: Compendio de problemas típicos.
@end menu

@c ---------------------------------------------------------------
@node Causas Usualmente Sospechosas
@section Causas Usualmente Sospechosas

Como administradores de CVS (léase "médicos del CVS"), encontraremos que
el 90 por ciento de los problemas de nuestros usuarios estarán causados
por copias de trabajo inconsistentes, y el otro 90 por ciento por
permisos incorrectos en el repositorio. No obstante, antes de investigar
cualquier situación concreta, mostraremos una vista rápida de la copia
de trabajo del área administrativa y revisaremos algunas cosas
importantes acerca de los permisos en el repositorio.

@menu
* La Copia de Trabajo del Área Administrativa::
* Permisos del Repositorio::
@end menu

@c ----------------------------------------------------------------
@node La Copia de Trabajo del Área Administrativa
@subsection La Copia de Trabajo del Área Administrativa

Ya vimos la estructura de la copia de trabajo en @ref{Una 
introduccion a CVS}; en esta sección entraremos un poco más en detalle.
Casi todos los detalles conciernen a los ficheros de los directorios
administrativos bajo CVS/. Ya conocemos los ficheros Entries, Root y
Repository, pero en el directorio CVS/ también puede haber otros
ficheros, según las circunstancias. Describiré esos ficheros aquí,
parcialmente para que no nos sorprenda encontrarlos, y también para que
sepamos cómo corregir errores que eventualmente se produzcan en ellos. 

@heading @file{CVS/Entries.Log}

A veces, aparecerá un extraño fichero @file{CVS/Entries.Log}. El único
propósito de este fichero es hacer de cache temporal de los cambios
menores de CVS/Entries, hasta que haya suficientes cambios acumulados
para modificar este fichero. CVS no es capaz de editar directamente el
fichero Entries, por el contrario tiene que leerlo y sobreescribirlo por
completo para cualquier cambio. Para evitar excesiva carga, CVS a veces
guarda los cambios pequeños en Entries.log, hasta la próxima vez que
necesite reescribir el fichero Entries.

El formato de Entries.log es como el de Entries, salvo que además
incluye una letra al principio de cada línea. @code{A} significa que la
línea será añadida al fichero Entries, y @code{R} significa que esa
línea será borrada.

Casi siempre podemos ignorar el fichero Entries.log; es raro que un
administrador tenga que entender la información que contiene. Sin
embargo, si estamos depurando algún problema que nos pide examinar el
fichero Entries, probablemente tengamos que echar un vistazo también a
Entries.log.

@heading @file{CVS/Entries.Backup}

El fichero CVS/Entries.backup es el que usa CVS para escribir un fichero
Entries nuevo, antes de renombrarlo a @file{Entries} (similarmente al
mecanismo de escribir en ficheros temporales RCS y luego renombrarlos
convenientemente). Debido a que se renombra a Entries cuando está
acabado, serán pocas las veces que veremos el fichero Entries.Backup; si
lo vemos alguna vez se deberá probablemente a la interrupción de un
proceso CVS en medio de alguna operación.

@heading @file{CVS/Entries.Static}

Si existe el fichero CVS/Entries.Static, significa que el directorio
completo no ha sido extraido del repositorio. (Cuando CVS sabe que un
directorio está en un estado incompleto, él no añadirá ficheros
adicionales a ese directorio.)

El fichero Entries.Static existe durante las operaciones de checkout y
actualización, y se borra inmediatamente al completar la operación. Si
vemos el fichero, significará que CVS fue interrumpido, y su existencia
impide a CVS crear cualquier fichero nuevo en la copia de
trabajo. (Ahora bien , ejecutando @w{@code{cvs update -d}} se soluciona
el problema y se borra Entries.Static.)

La ausencia de Entries.Static no implica necesariamente que la copia de
trabajo incluya todos los ficheros del proyecto. Tan pronto se crea un
nuevo directorio en el repositorio del proyecto, y alguien actualiza su
copia sin incluir el flag -d a la orden update, el nuevo directorio no
se creará en la copia de trabajo. Localmente, CVS no sabe que existe el
nuevo directorio, luego él mismo borrará el fichero Entries.Static
cuando la actualización termine, aunque el nuevo directorio no se haya
creado en la copia de trabajo.

@heading @file{CVS/Tag}

Si existe el fichero CVS/Tag, nombrará a un tag asociado, en cierto
sentido, con el directorio. Digo "en cierto sentido" ya que, como
sabemos, CVS no mantiene información sobre versiones de directorios y,
hablando con precisión, no puede asociar tags a ellos. Los tags se
asocian solo a ficheros normales o, más precisamente, a revisiones
concretas de ficheros normales.

Sin embargo, si cada fichero de un directorio está en un tag concreto,
CVS presupone que el directorio también está en ese tag. Por ejemplo, si
íbamos a extraer de CVS una copia de trabajo de una rama concreta:

@example
floss$ cvs co -r Bugfix_Rama_1
@end example

y luego insertamos un fichero en ella, querremos que la versión inicial
del fichero esté en esa rama también. Por razones similares, CVS
también necesita conocer si el directorio tiene un tag de que no es rama
(non-branch) o la fecha puesta en él.

Los ficheros de tags contienen una línea. El primer carácter de la línea
es un código de una letra que indica qué clase de tag es, y el resto es
el nombre del tag. Actualmente, CVS solo utiliza las siguientes tres
letras como código:

@itemize

@item
T -- Tag de rama

@item
N -- Tag de que no es rama (regular tag)

@item
D -- Fecha "pegada", que se utiliza si un comando como

@example
floss$ cvs checkout -D 1999-05-15 myproj
@end example

o

@example
floss$ cvs update -D 1999-05-15 myproj
@end example

se ejecuta.

@end itemize

(Si vemos cualquier otro código de una letra, simplemente nos indicará
que CVS ha añadido un nuevo tipo de tag posteriormente a la escritura de
este libro.)

El fichero Tag no debe ser borrado manualmente; en su lugar use @w{@code{cvs
update -A}}.

@heading Rarezas

Hay otros ficheros que ocasionalmente se encontrarán en un directorio CVS/:

@itemize
@item CVS/Checkin.prog, CVS/Update.prog
@item CVS/Notify, CVS/Notify.tmp
@item CVS/Base/, CVS/Baserev, CVS/Baserev.tmp
@item CVS/Template
@end itemize

Estos ficheros no son, normalmente, causa de problemas, por lo que
simplemente los vamos a listar (véase @ref{Referencia de CVS} para conocer
su significado completo).

@c -------------------------------------------------------------------
@heading Portabilidad y extensiones futuras.

Conforme se añadan nuevas características a CVS, podrán aparecer nuevos
ficheros (no listados aquí) en las áreas administrativas. Conforme
dichos ficheros sean añadidos, probablemente serán documentados en el
manual de Cederqvist, en la sección @cite{Working Directory
Storage}. También podemos mirar en el código fuente, en src/cvs.h, si
preferimos aprender a partir de las fuentes.

Finalmente, observemos que todos los ficheros CVS/* -- actuales y
futuros -- siguen las convenciones de final de línea apropiadas al
sistema en uso (por ejemplo, LF para Unix o CR/LF para Windows). Esto
significa que si llevamos una copia de trabajo desde una plataforma a
otra, puede suceder que CVS no pueda manejarla (además, podemos tener
otros problemas, debido a que los ficheros controlados por el sistema de
versiones pueden tener ellos mismos un fin de línea inapropiado).

@c --------------------------------------------------------
@node Permisos del Repositorio
@subsection Permisos del Repositorio

CVS no necesita ningún esquema específico de permisos -- puede manejar
una amplia variedad de esquemas. Sin embargo, para evitar situaciones
confusas, se debe configurar el repositorio siguiendo como mínimo los
siguientes criterios:

@itemize 

@item
Si un usuario quiere algún tipo de acceso -- incluso acceso solo-lectura
-- a un determinado directorio del repositorio, normalmente necesitará
permisos de escritura a nivel de sistema sobre ese directorio. Esto es
necesario ya que CVS crea ficheros cerrojo temporales en el repositorio
para asegurarse la consistencia de los datos. Aun en operaciones de solo
lectura (como la extracción o actualización de una copia de trabajo), se
crearán cerrojos, para asegurar que los datos permanecen constantes
durante la operación.

Como se indica en @ref{Administracion del Repositorio}, podemos salvar este
requisito ajustando el parámetro LockDir del fichero CVSROOT/config. Por
ejemplo:

@example
LockDir=/usr/local/cvslocks
@end example

Por supuesto, habrá que asegurarse de que todos los usuarios de CVS
pueden escribir sobre /usr/local/cvslocks. De otro modo, el directorio
será el del repositorio; si somos muy estrictos con la seguridad,
deberíamos cambiar este directorio por otro.

@item
Asegurémosnos de que el fichero CVSROOT/history es escribible por todo
el mundo, ya que si este fichero existe, casi todas las operaciones de CVS
intentarán concatenar su histórico en este fichero, y si no lo pueden
hacer terminarán con error.

Por desgracia (e inexplicablemente), el fichero de histórico no se crea
escribible por todo el mundo cuando se crea un repositorio nuevo con cvs
init. Al menos con la versión actual de CVS, debemos cambiar los
permisos de manera explícita una vez creado el repositorio (o
simplemente borrarlo, si no queremos que se almacenen los históricos).

(Este problema puede terminar pronto -- acabo de enviar un parche a los
mantenedores de CVS para que se cree el histórico con los permisos
apropiados cuando se crea. Luego si usamos una versión de CVS posterior
a septiembre de 1999, probablemente el problema habrá desaparecido.)

@item
Por razones de seguridad, hay que asegurarse de que los usuarios de CVS
no tienen acceso de escritura a nivel de Unix al directorio CVSROOT.
Si alguien tiene acceso de inserción en CVSROOT, podría editar cualquier
fichero disparador de su elección (commitinfo, loginfo, etc), invocando
cualquier programa que desee. En general, el acceso a CVSROOT por parte
de un usuario de CVS implica la posibilidad de ejecutar cualquier
comando del sistema.


@end itemize

@c -------------------------------------------------------
@node Trucos Habituales
@section Trucos Habituales

Este capítulo está organizado como una serie de preguntas y respuestas,
de manera similar a una FAQ (Preguntas Frecuentes) de Internet. Todas
ellas se basan en la experiencia habitual con CVS. Pero antes de mostrar
casos más individuales, tomemos unos minutos para considerar los
problemas de CVS desde un punto de vista más general.

El primer paso en la resolución de un problema con CVS es determinar si
sucede en una copia de trabajo o es un problema del repositorio. La
mejor técnica para hacerlo, es ver si el problema se repite en
copias de trabajo distintas del mismo repositorio. Si sucede así, será
probablemente un problema del repositorio; en otro caso estará limitado
a la copia local.

Los problemas con las copias de trabajo suelen encontrarse más
frecuentemente, simplemente porque son más numerosas que los
repositorios y no porque sean más "inestables". Aunque con algo de
paciencia se pueden resolver la mayoría de los problemas, muchas veces
la solución más sencilla y eficiente será borrar y volver a crear la
copia de trabajo.

Por supuesto, si crear la copia de trabajo resulta tedioso, o hay muchas
cosas pendientes de enviar al repositorio como para permitirse el lujo
de borrarlo, o simplemente somos de los que queremos averiguar el por
qué de las cosas, siempre podemos intentarlo. En primer lugar,
normalmente miraremos los subdirectorios CVS/, comprobando los ficheros
y sus permisos. A veces, los permisos se hacen misteriosamente de solo
lectura o simplemente sin permisos de lectura. Sospechamos que es debido
a que los usuarios se equivocan con alguna orden Unix relacionada y
cambian los permisos sin saberlo.

Los problemas en el repositorio se suelen producir por permisos
incorrectos en ficheros y directorios. Si sospechamos que el problema
pueda deberse a esto, primero miremos cuál es el UID efectivo en el
repositorio de la persona que origina el problema. Con usuarios locales
y remotos, suele ser un problema con el usuario que se especificó
durante la creación de la copia de trabajo. Si se usa el método pserver
con alias de usuario (véase la sección @ref{Acceso anonimo} en el capítulo
@ref{Administracion del Repositorio}), el ID de usuario efectivo estará en el
fichero CVSROOT/passwd. Si no se ve esto a tiempo puede provocarnos una
gran pérdida de tiempo buscando la solución al problema en otros sitios.

Y ahora veamos problemas más concretos...

@c ---------------------------------------------------------------
@node Algunos Problemas de la Vida Real (con Soluciones)
@section Algunos Problemas de la Vida Real (con Soluciones)

Las siguientes son situaciones que se me han dado en mi experiencia como
administrador de CVS (más algunas cosas que no son problemas realmente,
simplemente cuestiones que he oido por ahí y creo interesante contar
aquí). La lista pretende ser bastante completa y puede repetir cosas que
ya hayamos visto en capítulos anteriores.

Las situaciones se listan de acuerdo a la frecuencia con la que se
suelen dar, poniendo en primer lugar las más habituales.

@menu
* CVS dice que está esperando un cerrojo; ¿qué significa esto?::
* CVS dice que un fichero ha fallado la comprobación Up-To-Date (actualizado); ¿qué hago?::
* El método de acceso pserver no funciona::
* El método pserver SIGUE sin funcionar::
* Mis envíos (commits) parecen tener lugar a trozos y no atómicamente::
* CVS ignora los permisos que pongo; ¿por qué lo hace?::
* El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qué?::
* Mi copia de trabajo está en diferentes ramas ¿una ayuda?::
* Cuando hago export -d a veces pierdo commits recientes::
* Obtengo un error de val-tags; ¿qué hago?::
* Tengo problemas con los tags adhesivos; ¿cómo evitarlos?::
* Las extracciones/actualizaciones terminan con el error 'cannot expand modules'::
* No puedo desactivar los watches::
* Mis ficheros binarios se han corrompido::
* CVS no hace correctamente las conversiones de fin de línea::
* ¿Cómo se borra un directorio del proyecto?::
* ¿Puedo copiar ficheros .cvspass o parte de ellos?::
* Acabo de enviar algunos ficheros con un mensaje histórico incorrecto::
* Necesito mover ficheros sin perder el histórico de revisiones::
* ¿Como puedo obtener la lista de todas las etiquetas del proyecto?::
* ¿Como obtener una lista de todos los proyectos del repositorio?::
* Algunos comandos fallan en remoto pero no en local; ¿cómo lo depuramos?::
* Mi problema no está explicado en este capítulo::
* Creo que he descubierto un bug en CVS; ¿qué hago?::
* He añadido una característica a CVS; ¿a quién la envío?::
* ¿Como puedo mantenerme informado de las novedades en CVS?::
@end menu

@c ---------------------------------------------------------------------
@node CVS dice que está esperando un cerrojo; ¿qué significa esto?
@subsection CVS dice que está esperando un cerrojo; ¿qué significa esto?

Si vemos un mensaje como este:

@example
cvs update: [22:58:26] waiting for qsmith's lock in /usr/local/newrepos/myproj
@end example

significa que estamos intentando acceder a un subdirectorio del
repositorio que está bloqueado por otro proceso CVS en este momento. Un
proceso está corriendo en ese subdirectorio, luego puede hacerlo
inconsistente a otros procesos CVS que quieran acceder a él.

Sin embargo, si el mensaje de espera persiste mucho tiempo,
probablemente indique que un proceso CVS ha fallado en su limpieza
final, por alguna razón. Puede pasar cuando CVS muere de pronto e
inesperadamente, por una caída de la máquina del repositorio, por ejemplo.

La solución es borrar los ficheros de cerrojo a mano del subdirectorio
del repositorio en cuestión. Entremos en ese lugar y busquemos ficheros
con el nombre @file{#cvs.lock} o que empiecen por @file{#cvs.wfl} o
@file{#cvs.rfl}. Comparemos las fechas de los ficheros con los instantes
de inicio de cualquier proceso CVS actual. Si los ficheros no han podido
ser creados por esos procesos (son más antiguos), podemos borrarlos
tranquilamente. Los procesos CVS en espera se darán cuenta del borrado
(normalmente cada 30 segundos lo revisan) y terminarán su operación.

Véase el nodo @cite{Locks} en el manual de Cederqvist para más detalle.

@c ---------------------------------------------------------------------
@node CVS dice que un fichero ha fallado la comprobación Up-To-Date (actualizado); ¿qué hago?
@subsection CVS dice que un fichero ha fallado la comprobación Up-To-Date (actualizado); ¿qué hago?

Evitemos el pánico -- solo significa que el fichero ha cambiado en el
repositorio desde la última vez que nos lo bajamos o actualizamos.

Ejecutemos @w{@code{cvs update}} en el fichero para mezclar los cambios
del repositorio con los que hayamos hecho nosotros. Si los cambios
recibidos entran en conflicto con los nuestros, edítese el fichero para
resolver los conflictos. A continuación intentemos de nuevo enviar los
cambios al repositorio -- tendrá exito, a menos que otra persona haya
vuelto a actualizar el fichero durante su trabajo.

@c ---------------------------------------------------------------------
@node El método de acceso pserver no funciona
@subsection El método de acceso pserver no funciona

La causa más común, pero no precisamente obvia, es que hayamos olvidado
la opción @code{--allow-root} en la configuración de inetd.

Recordemos este ejemplo de línea de /etc/inetd.conf:

@example
cvspserver stream tcp nowait root /usr/local/bin/cvs cvs \
          --allow-root=/usr/local/newrepos pserver
@end example

(En el fichero real será una sola línea, sin barra invertida.)

La parte @code{--allow-root=/usr/local/newrepos} es una medida de
seguridad, para asegurarnos de que la gente no pueda usar CVS para
obtener acceso pserver a repositorios que se supone no son servidos
remotamente. Cualquier repositorio que se desee accesible por pserver,
debe estar mencionado en la opción @code{--allow-root}. Podemos tener
todas las opciones de este tipo que deseemos, para dar acceso a todos
los repositorios que hagan falta (mientras no llenemos la longitud
máxima de línea de la configuración del inetd).

Véase el capítulo @ref{Administracion del Repositorio} para más detalle sobre
la configuración del servidor autentificado con contraseña.

@c ---------------------------------------------------------------------
@node El método pserver SIGUE sin funcionar
@subsection El método pserver SIGUE sin funcionar

De acuerdo, si el problema no es la ausencia de una opción
@code{--allow-root}, veamos otras posibles causas:

@itemize

@item
El usuario no tiene una entrada en el fichero CVSROOT/passwd, y el
fichero CVSROOT/config tiene la opción SystemAuth=no, por lo que CVS no
buscará el usuario en el fichero de usuarios del sistema (o bien
SystemAuth=yes pero no existe ese usuario en el sistema).

@item
El usuario tiene una entrada en el fichero CVSROOT/passwd, pero no hay
usuario con ese nombre en el sistema, por lo que no se puede mapear a un
usuario válido.

@item
La contraseña es incorrecta (aunque como CVS suele informar de esto
convenientemente, casi seguro que nuestro problema no será éste).

@item
Todo está correcto en los ficheros de claves y en /etc/inetd.conf, pero
se nos olvidó una entrada como ésta en /etc/services:

@example
cvspserver      2401/tcp
@end example

por lo que inetd no es capaz de saber qué puerto es cvspserver.

@end itemize

@c ---------------------------------------------------------------------
@node Mis envíos (commits) parecen tener lugar a trozos y no atómicamente
@subsection Mis envíos (commits) parecen tener lugar a trozos y no atómicamente

Esto es porque CVS hace los envíos a trozos, y no atómicamente. :-)

Más específicamente, las operaciones de CVS tienen lugar directorio a
directorio. Cuando hacemos un commit (o update o cualquier cosa)
afectando a varios directorio, CVS bloquea cada directorio mientras hace
la operación en él, desbloqueándolo antes de pasar al siguiente.

Para proyectos pequeños o medianos, raramente será esto un problema, ni
notaremos que la operación no es atómica. Sin embargo, en proyectos
grandes, se pueden dar escenarios como el siguiente (imaginemos que el
proyecto tiene al menos dos directorios A y B, con muchos ficheros):

@enumerate

@item
El usuario pperez inicia un envío (commit), afectando a ficheros de
ambos directorios. CVS envía los ficheros de B en primer lugar (porque
el usuario lo especificó en ese orden).

@item
El usuario jsuerte inicia una actualización (update). Por alguna razón,
supongamos que ésta se inicia copiando el directorio A (CVS no garantiza
ningún orden por su cuenta). Obsérvse que no hay bloqueo aun porque
pperez aun no está activo en A.

@item
Ahora, el envío de pperez finaliza B, se va a A y finaliza A.

@item
Finalmente, la actualización de jsuerte se va a B y finaliza.

@end enumerate

Claramente, cuando todo acaba, la copia de trabajo de jsuerte refleja
los cambios de pperez en B pero no en A. Aunque pperez intentase hacerlo
atómicamente, no hay forma. Ahora la copia de jsuerte está en un estado
que desconoce pperez.

La solución, por supuesto, es que jsuerte haga de nuevo el cvs
update.

El fallo de no permitir transacciones atómicas es considerado
ampliamente como un error de CVS. La única razón por la que los cerrojos
no se establecen en la raíz del repositorio es porque esto resultaría
inaceptable para grandes proyectos con múltiples desarrolladores. Para
mitigar este problema, en CVS se escogió bloquear a nivel de cada
directorio, reduciendo así la contención. Alguna vez alguien podría
modificar CVS para acelerar sus operaciones, de manera que se mejore
esta situación.

Para más información, véase el nodo @cite{Concurrency} del manual de
Cederqvist.

@c ---------------------------------------------------------------------
@node CVS ignora los permisos que pongo; ¿por qué lo hace?
@subsection CVS ignora los permisos que pongo; ¿por qué lo hace?

En general, CVS no realiza un muy buen trabajo para preservar los
permisos de los ficheros. Cuando importamos un proyecto y luego lo
extraemos, no hay garantía de que en la copia de trabajo obtenida los
ficheros tengan los mismos permisos que cuando fueron importados. Más
bien, lo que sucede es que los ficheros de la copia de trabajo se crean
con el esquema de permisos estándar que tengamos en nuestra cuenta de usuario.

Sin embargo, hay al menos una excepción. Si queremos almacenar scripts
de shell ejecutables en el proyecto, podemos mantenerlos ejecutables en
todas las copias de trabajo sin más que hacer ejecutable el fichero del
repositorio:

@example
floss$ ls -l /usr/local/mirepo/unproyecto
total 6
-r--r--r--   1 jsuerte  users         630 Aug 17 01:10 README.txt,v
-r-xr-xr-x   1 jsuerte  users        1041 Aug 17 01:10 scrub.pl,v*
-r--r--r--   1 jsuerte  users         750 Aug 17 01:10 hola.c,v
@end example

Nótese que aunque el fichero es ejecutable, se mantiene en solo-lectura,
como debe ser en todos los ficheros de un repositorio (recordar que CVS
trabaja haciendo los cambios sobre una copia temporal del fichero RCS,
que luego reemplaza al original).

Cuando importamos o añadimos un fichero ejecutable, CVS preserva los
bits de ejecución, de manera que si los permisos iniciales son
correctos, en general no habrá que preocuparse más. Sin embargo, si
accidentalmente añadimos el fichero antes de hacerlo ejecutable, debemos
ir al repositorio y cambiar los bits a mano sobre el fichero RCS.

Los permisos del repositorio siempre predominan. Si el fichero no es
ejecutable en el repositorio pero sí lo es en la copia de trabajo,
cuando hagamos una actualización seguirá como esté en el repositorio.
Cuando los permisos de los ficheros cambian misteriosamente puede ser
frustrante. Si esto sucede, comprobar primero los permisos en el
repositorio y ver si podemos resolverlo ajustando los permisos sobre los
ficheros RCS.

Recientemente se añadió a CVS una característica denominada
@code{PreservePermissions} que puede aliviar alguno de estos
problemas. Sin embargo, usando esta característica pueden producirse
otros resultados inesperados (por lo que no recomiendo usarla
siempre). Nos debemos asegurar de leer antes los nodos @cite{config} y
@cite{Special Files} del manual de Cederqvist antes de incluir
@code{PreservePermissions=yes} en CVSROOT/config.

@c ---------------------------------------------------------------------
@node El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qué?
@subsection El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qué?

Para conexiones pserver, el CVS del lado cliente intenta encontrar el
fichero .cvspass en el directorio principal de la cuenta (HOME). Las
máquinas con Windows no tienen un directorio "home" natural, por lo que
CVS consulta la variable @code{%HOME%}. Sin embargo, hay que ser
cuidadosos con esta variable. Esto funcionará:

@example
set HOME=C:
@end example

Pero esto no:

@example
set HOME=C:\
@end example

Esta barra extra es suficiente para confundir a CVS y será incapaz de
abrir el fichero @file{C:\\.cvspass}.

La más rápida y segura solución, pues, es poner

@example
set HOME=C:
@end example

en el fichero autoexec.bat y reiniciar. El pserver de CVS debe funcionar
ahora correctamente.

@c ---------------------------------------------------------------------
@node Mi copia de trabajo está en diferentes ramas ¿una ayuda?
@subsection Mi copia de trabajo está en diferentes ramas ¿una ayuda?

¿Hablamos de diferentes subdirectorios de la copia de trabajo en
diferentes ramas? Probablemente hemos ejecutado updates con la opción
-r, pero en lugares distintos de la raíz de la copia de trabajo.

No hay problema. Si queremos volver a lo correcto, ejecutemos esto

@example
cvs update -r HEAD
@end example

o esto

@example
cvs update -A
@end example

desde el directorio raíz. O, si lo que queremos es poner la copia de
trabajo a una de las ramas, hacer esto:

@example
cvs update -r Nombre_rama
@end example

No hay problema por tener uno o dos subdirectorios de la copia de
trabajo pertenecientes a diferentes ramas, si lo que queremos es hacer
algún trabajo en esa rama temporalmente solo en esos ficheros. Sin
embargo, será una buena idea normalmento volver cuando acabemos -- la
vida será mucho menos confusa cuando toda nuestra copia de trabajo
pertenezca a la misma línea de desarrollo.

@c ------------------------------------------------------------------------
@node Cuando hago export -d a veces pierdo commits recientes
@subsection Cuando hago export -d a veces pierdo commits recientes

Esto se debe a una diferencia entre el reloj de la máquina del
repositorio y el local. Podemos resolverlo ajustando uno o ambos
relojes, o especificando una fecha distinta con la opción -D. Es
perfectamente aceptable el especificar una fecha del futuro (tal como -D
tomorrow), si esto puede compensar la diferencia de tiempos.

@c ---------------------------------------------------------------------
@node Obtengo un error de val-tags; ¿qué hago?
@subsection Obtengo un error de val-tags; ¿qué hago?

Si obtenemos un error como este:

@example
cvs [export aborted]: cannot write /usr/local/myproj/CVSROOT/val-tags: \
   Operation not permitted
@end example

significa que el CVS del usuario está corriendo y no tiene permiso para
escribir el fichero CVSROOT/val-tags. Este fichero almacena nombres de 
tags, para que CVS tenga una manera rápida de determinar qué tags son
válidos. Desafortunadamente, CVS a veces modifica este fichero en
operaciones que deberían ser solo-lectura respecto del repositorio, como
una simple extracción (check-out) del proyecto.

Esto es un error de CVS y debe haberse corregido mientras leemos
esto. Hasta entonces, la solución es hacer que el fichero val-tags sea
escribible por todo el mundo o, si esto falla, borrarlo o poner de
propietario al usuario que está intentando operar. (Podríamos pensar que
cambiar los permisos es suficiente, pero a veces he tenido que tambiar
también al propietario.)

@c ---------------------------------------------------------------------
@node Tengo problemas con los tags adhesivos; ¿cómo evitarlos?
@subsection Tengo problemas con los tags adhesivos; ¿cómo evitarlos?

Algunas operaciones del CVS hacen que la copia de trabajo tengan un
@dfn{tag adhesivo}, que es un tag que corresponde a cada revisión de
cada fichero (en el caso de una rama, el tag adhesivo se aplica a
cualquier fichero que se añada a la copia de trabajo). Obtendremos un
área de trabajo con tags adhesivos cuando extraigamos o actualicemos por
tag o por fecha, por ejemplo:

@example
floss$ cvs update -r Nombre_Tag
@end example

o

@example
floss$ cvs checkout -D '1999-08-16'
@end example

Si se usa una fecha o un nombre de tag que no sea rama, la copia de
trabajo será una foto congelada de ese momento en el histórico del
proyecto -- por lo que naturalmente no podremos enviar cambios de
ninguna clase desde él.

Para eliminar un tag adhesivo actualizaremos con el flag -A

@example
floss$ cvs update -A
@end example

que limpia todos los tags adhesivos y actualiza cada fichero a su
revisión más reciente.

@c ---------------------------------------------------------------------
@node Las extracciones/actualizaciones terminan con el error 'cannot expand modules'
@subsection Las extracciones/actualizaciones terminan con el error 'cannot expand modules'

Esto es un ejemplo de error fatal de CVS; probablemente alguien lo
intentará corregir pronto, pero mientras tanto nos molestará. El error
es similar al siguiente:

@example
floss$ cvs co -d bwf-misc user-space/bwf/writings/misc 
cvs server: cannot find module `user-space/bwf/writings/misc' - ignored
cvs [checkout aborted]: cannot expand modules
@end example

CVS aparenta estar diciendo que hay algo mal en el fichero
CVSROOT/modules. Sin embargo, lo que realmente ocurre es un problema de
permisos del repositorio. El directorio que estamos intentando extraer
no es legible, o uno de sus ancestros no lo es. En este caso, era un
ancestro:

@example
floss$ ls -ld /usr/local/cvs/user-space/bwf

drwx------  19 bwf      users        1024 Aug 17 01:24 bwf/
@end example

Como vemos no hay que preocuparse demasiado -- es simplemente otro
problema de permisos.

@c ---------------------------------------------------------------------
@node No puedo desactivar los watches
@subsection No puedo desactivar los watches

Probablemente habremos ejecutado

@example
floss$ cvs watch remove
@end example

en todos los ficheros, pero se nos olvidó hacer esto otro:

@example
floss$ cvs watch off
@end example

Una sugerencia para diagnosticar errores con los watches: a veces puede
clarificar mucho simplemente el entrar en el repositorio y examinar el
fichero CVS/fileattr directamente. Véase @ref{Administracion del Repositorio}
para más información sobre esto.

@c ---------------------------------------------------------------------
@node Mis ficheros binarios se han corrompido
@subsection Mis ficheros binarios se han corrompido

¿Nos hemos acordado de usar el modificador -kb al insertarlos? Si no fue
así, CVS puede haber realizado expansiones de macros RCS o conversiones
de fin de línea. La solución más simple es marcarlos como binarios,

@example
floss$ cvs admin -kb ejemplo.gif
@end example

y luego enviar una versión corregida del fichero. CVS no corromperá
nuevos envíos de este fichero, puesto que ya sabe que es binario.

@c ---------------------------------------------------------------------
@node CVS no hace correctamente las conversiones de fin de línea
@subsection CVS no hace correctamente las conversiones de fin de línea

Si hemos ejecutado el cliente CVS en una plataforma no Unix, y no
tenemos las conversiones correctas de final de línea, se deberá
normalmente a que hemos añadido los ficheros accidentalmente como
binarios (opción -kb). Esto puede corregirse en el repositorio con el
comando:

@example
floss$ cvs admin -kkv FICHERO
@end example

El modificador -kkv solicita hacer la expansión de macros normal y las
conversiones de fin de línea (internamente, CVS se confunde con la
diferencia entre la expansión de macros y la conversión de fin de
línea. Esta confusión da lugar a que las opciones de -k siempre
controlan ambos aspectos a la vez).


Por desgracia, este comando de administración solo corrige el fichero en
el repositorio, es decir, nuestra copia local seguirá considerándose
como binaria. Siempre podemos editar a mano el fichero CVS/Entries
eliminando la opción -kb de la línea correspondiente.

@c ---------------------------------------------------------------------
@node ¿Cómo se borra un directorio del proyecto?
@subsection ¿Cómo se borra un directorio del proyecto?

Bien, no podemos borrar el directorio realmente, pero podemos borrar
todos los ficheros que haya dentro (primero hacemos cvs remove y luego
commit). Una vez que el directorio está vacío, se eliminará de las
copias de trabajo usando la opción -P durante cualquier actualización.

@c ---------------------------------------------------------------------
@node ¿Puedo copiar ficheros .cvspass o parte de ellos?
@subsection ¿Puedo copiar ficheros .cvspass o parte de ellos?

Sí, claro. Se pueden copiar de una máquina a otra, o se pueden
transferir líneas individuales de un fichero .cvspass a otro. Para
servidores con acceso lento, esto puede ser más rápido que hacer cvs
login en cada máquina.

Recordemos que si transportamos un fichero .cvspass entre dos máquinas
con diferentes convenciones de fin de línea, probablemente no
funcionarán (por supuesto, siempre se puede corregir este problema a mano).

@c ---------------------------------------------------------------------
@node Acabo de enviar algunos ficheros con un mensaje histórico incorrecto
@subsection Acabo de enviar algunos ficheros con un mensaje histórico incorrecto

Para resolver esto no hay que editar nada del repositorio. Simplemente
ejecutemos cvs admin con la opción -m. Recuérdese no dejar espacios
entre -m y el argumento, y acitar el mensaje histórico tal como se haría
normalmente:

@example
floss$ cvs admin -m1.17:'Recientes mejoras en mi mejor programa.' hola.c
@end example

@c ---------------------------------------------------------------------
@node Necesito mover ficheros sin perder el histórico de revisiones
@subsection Necesito mover ficheros sin perder el histórico de revisiones

En el repositorio, copiemos (no movamos) los ficheros RCS al nuevo lugar
deseado. Esto debe respetar sus antiguas localizaciones. Ahora, desde
una copia de trabajo, hagamos lo siguiente:

@example
floss$ rm ficheroviejo1 ficheroviejo2 ...
floss$ cvs remove ficheroviejo1 ficheroviejo2 ...
floss$ cvs commit -m 'Ficheros movidos ...'
@end example

Cuando la gente haga actualizaciones, CVS borrará los ficheros viejos y
los creará en sus nuevos sitios, tal como si se hubiera hecho la
operación de añadir normalmente (excepto por el hecho de que se siguen
usando los números de revisión anteriores).

@c ---------------------------------------------------------------------
@node ¿Como puedo obtener la lista de todas las etiquetas del proyecto?
@subsection ¿Como puedo obtener la lista de todas las etiquetas del proyecto?

Actualmente no hay forma de hacerlo con CVS. Es algo demandado por los
usuarios y se espera que en futuras versiones esté disponible. Puede que
pronto (incluso ya) existe un comando @w{@code{cvs tags}} o similar.

Hasta entonces, hay aproximaciones. Podemos ejecutar cvs log -h y leer
las secciones de la salida con la cabecera @code{symbolic names:}. O
bien, si estamos en la máquina del repositorio, podemos mirar en el
principio de algunos ficheros RCS. Todas las etiquetas (rama y no
rama) se listan en el campo @code{symbols}:

@example
floss$ head /usr/local/nuevorep/hola.c,v
head	2.0;
access;
symbols
	Release_1_0:1.22
	Exotic_Greetings-2:1.21
	merged-Exotic_Greetings-1:1.21
	Exotic_Greetings-1:1.21
	merged-Exotic_Greetings:1.21
	Exotic_Greetings-branch:1.21.0.2
	Root-of-Exotic_Greetings:1.21
	start:1.1.1.1
	jrandom:1.1.1;
locks; strict;
comment	@@ * @@;
@end example

@c ---------------------------------------------------------------------
@node ¿Como obtener una lista de todos los proyectos del repositorio?
@subsection ¿Como obtener una lista de todos los proyectos del repositorio?

Al igual que sucede con la lista de etiquetas, no está implementado en
la versión actual de CVS, pero se entiende que lo estará pronto. Imagino
el comando similar a cvs list, con una forma abreviada cvs ls, y
probablemente ambos analizarán los módulos y listarán los subdirectorios.

Por ahora, examinando el fichero CVSROOT/modules (directamente o
ejecutando cvs checkout -c) podemos conseguirlo. Sin embargo, si nadie
ha hecho un módulo para un proyecto, no veremos nada sobre ese proyecto
en el fichero modules.

@c ---------------------------------------------------------------------
@node Algunos comandos fallan en remoto pero no en local; ¿cómo lo depuramos?
@subsection Algunos comandos fallan en remoto pero no en local; ¿cómo lo depuramos?

A veces hay un problema de comunicación entre el cliente y el
servidor. Y puede ser un error de CVS.

CVS proporciona un mecanismo de trazar el protocolo entre el cliente y
el servidor. Antes de ejecutar el comando en la máquina local (con la
copia de trabajo), crear la variable @code{CVS_CLIENT_LOG}. En un shell
de Bash se haría así:

@example
floss$ CVS_CLIENT_LOG=clog; export CVS_CLIENT_LOG
@end example

Una vez creada la variable, CVS almacenará las comunicaciones entre
cliente y servidor en dos ficheros con el nombre basado en el valor de
la variable anterior:

@example
floss$ ls
CVS/        LEAME.txt    a-subdir/    b-subdir/    prueba.gif     hola.c
floss$ cvs update
? clog.in
? clog.out
cvs server: Updating .
cvs server: Updating a-subdir
cvs server: Updating a-subdir/subsubdir
cvs server: Updating b-subdir
floss$ ls
CVS/              a-subdir/    clog.in     prueba.gif
LEAME.txt        b-subdir/    clog.out    hola.c
floss$ 
@end example

El fichero @file{clog.in} contiene lo enviado por el cliente al
servidor, y el fichero @file{clog.out} contiene los mensajes del
servidor al cliente. Vemos por ejemplo el contenido de clog.out:

@example
Valid-requests Root Valid-responses valid-requests Repository           \
Directory Max-dotdot Static-directory Sticky Checkin-prog Update-prog   \
Entry Kopt Checkin-time Modified Is-modified UseUnchanged Unchanged     \
Notify Questionable Case Argument Argumentx Global_option Gzip-stream   \
wrapper-sendme-rcsOptions Set expand-modules ci co update diff log add  \
remove update-patches gzip-file-contents status rdiff tag rtag import   \
admin export history release watch-on watch-off watch-add watch-remove  \
watchers editors init annotate noop
ok
M ? clog.in
M ? clog.out
E cvs server: Updating .
E cvs server: Updating a-subdir
E cvs server: Updating a-subdir/subsubdir
E cvs server: Updating b-subdir
ok
@end example

El fichero clog.in es más complicado, puesto que incluye números de
versión y otras informaciones por cada fichero.

No podemos dedicar espacio aquí a documentar el protocolo, pero podemos
leer las páginas Info de @code{cvsclient} que vienen con el paquete de
CVS para más información. Comprobaremos que aunque no siempre nos dé una
respuesta, mirar el histórico del protocolo puede darnos una buena pista.

@c ---------------------------------------------------------------------
@node Mi problema no está explicado en este capítulo
@subsection Mi problema no está explicado en este capítulo

Lo mejor es enviar una descripción del problema a la lista de discusión
sobre CVS, @email{info-cvs@@gnu.org}. Los miembros están dispersos por
todo el mundo, y por tanto a todas horas suele haber alguien que nos
ayudará casi de inmediato. Para apuntarse a la lista hay que enviar un
mensaje a @email{info-cvs-request@@gnu.org}. Se agradecerá que nosotros
también ayudemos a resolver problemas a los demás.

@c ---------------------------------------------------------------------
@node Creo que he descubierto un bug en CVS; ¿qué hago?
@subsection Creo que he descubierto un bug en CVS; ¿qué hago?

CVS no es perfecto ... si hemos intentado consultar el manual o
preguntar por ahí y aun creemos que es un bug, podemos hacer lo siguiente:

Hay que enviar una descripción lo más completa posible del error a
@email{bug-cvs@@gnu.org}. A esta lista también podemos suscribirnos
escribiendo a @email{bug-cvs-request@@gnu.org}. Hay que incluir en
nuestra consulta los números de versión (cliente y servidor) y el modo
de reproducir el error.

Si hubiéramos escrito un parche para corregir el error, incluyámoslo y
mencionémoslo en la línea del asunto del mensaje. Los desarrolladores lo
agradecerán infinitamente.

(En el manual de Cederqvist, en el nodo @cite{BUGS}, encontraremos más
detalles sobre cómo seguir estos procedimientos. También hay información
en el fichero HACKING de la distribución del código fuente).


@c ---------------------------------------------------------------------
@node He añadido una característica a CVS; ¿a quién la envío?
@subsection He añadido una característica a CVS; ¿a quién la envío?

Al igual que con los errores, enviaremos el parche a
@email{bug-cvs@@gnu.org}. Antes tenemos que asegurarnos de que hemos
leído el mencionado fichero HACKING.

@c ---------------------------------------------------------------------
@node ¿Como puedo mantenerme informado de las novedades en CVS?
@subsection ¿Como puedo mantenerme informado de las novedades en CVS?

Las técnicas de resolución de problemas y los errores conocidos
descritos en este capítulo son para la versión de CVS 1.10.7
(aproximadamente). Pero el mundo CVS se mueve rápidamente. Mientras que
escribía los últimos capítulos, el mantenimiento de CVS pasó de Cyclic
Software a SourceGear Inc (@uref{http://www.sourcegear.com}), quienes
habían comprado Cyclic. SourceGear ha anunciado públicamente su
intención de participar activamente en el equipo de desarrolladores de
CVS y ha recibido la aprobación de la gente de Cyclic, quienes eran más
o menos los que lo lideraban hasta ahora (la dirección
@uref{http://www.cyclic.com} seguirá funcionando, sin embargo, de manera
que todas las URL dadas aquí aún valen).

SourceGear está, en este preciso momento, ocupada organizando y puliendo
varios parches que estaban circulando por ahí, con la intención de
incorporar los que puedan a CVS. Algunos parches probablemente
corregirán errores vistos aquí, y otros añadirán nuevas opciones a los
usuarios.

La mejor forma de mantenerse informado de la evolución es leer el
fichero NEWS de la distribución de CVS, vigilando además las listas de
correo y buscando cambios en el manual de Cederqvist y en la versión en
línea, en inglés, de este libro (@uref{http://cvsbook.red-bean.com}).
