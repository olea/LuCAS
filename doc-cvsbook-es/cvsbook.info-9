This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: Problemas y Soluciones,  Next: Referencia de CVS,  Prev: CVS avanzado,  Up: Top

Problemas y Soluciones
**********************

Comenté en capítulos anteriores que CVS no es un software de "caja
negra". Las cajas negras no le permiten ver lo que hay dentro; no le dan
acceso interno que le permita arreglar (o estropear) cosas. La causa es
que la caja negra normalmente no necesitará ser revisada por usted. Casi
siempre, el software funcionará correctamente, por lo que los usuarios
no necesitarán acceso interno. Pero cuando las cajas negras fallan,
tienden a hacerlo completamente. Cualquier problema será un "exitazo",
puesto que no hay muchas opciones para reparar.

CVS es más bien como una caja perfectamente transparente. Sus partes
"móviles" están expuestas directamente al entorno, y fallos de ese
entorno (permisos inesperados en ficheros, comandos interrumpidos,
procesos en competencia, etc) pueden a veces influir en el mecanismo
interno y producir fallos. Pero aunque CVS no siempre funciona a la
perfección, raramente falla por completo. Tiene la ventaja de tener una
"degradación gradual": el porcentaje de fallos es proporcional al número
y severidad de problemas con el entorno. Si tenemos suficiente idea
acerca de lo que CVS está tratando de hacer - y cómo lo quiere hacer -
sabremos qué hacer cuando las cosas van mal.

Aunque no puedo listar todos los problemas que puede encontrar, he
incluido algunos de los más habituales. Este capítulo está dividido en
dos partes: la primera describe aquellas partes del entorno a las que
CVS es más sensible (principalmente, permisos del repositorio y de la
copia de trabajo del área administrativa), y la segunda describe
algunos de los problemas que se encuentran con más frecuencia y sus
soluciones. Observando cómo se gestionan esas situaciones, obtendremos
una capacidad para acercarnos a la solución de otros problemas con CVS
no descritos aquí.

* Menu:

* Causas Usualmente Sospechosas::            Cosas que suelen causar problemas.
* Trucos Habituales::                        Técnicas de diagnosis habituales.
* Algunos Problemas de la Vida Real (con Soluciones):: Compendio de problemas típicos.


File: cvsbook.info,  Node: Causas Usualmente Sospechosas,  Next: Trucos Habituales,  Up: Problemas y Soluciones

Causas Usualmente Sospechosas
=============================

Como administradores de CVS (léase "médicos del CVS"), encontraremos que
el 90 por ciento de los problemas de nuestros usuarios estarán causados
por copias de trabajo inconsistentes, y el otro 90 por ciento por
permisos incorrectos en el repositorio. No obstante, antes de investigar
cualquier situación concreta, mostraremos una vista rápida de la copia
de trabajo del área administrativa y revisaremos algunas cosas
importantes acerca de los permisos en el repositorio.

* Menu:

* La Copia de Trabajo del Área Administrativa::
* Permisos del Repositorio::


File: cvsbook.info,  Node: La Copia de Trabajo del Área Administrativa,  Next: Permisos del Repositorio,  Up: Causas Usualmente Sospechosas

La Copia de Trabajo del Área Administrativa
-------------------------------------------

Ya vimos la estructura de la copia de trabajo en *Note Una introduccion
a CVS::; en esta sección entraremos un poco más en detalle.  Casi todos
los detalles conciernen a los ficheros de los directorios
administrativos bajo CVS/. Ya conocemos los ficheros Entries, Root y
Repository, pero en el directorio CVS/ también puede haber otros
ficheros, según las circunstancias. Describiré esos ficheros aquí,
parcialmente para que no nos sorprenda encontrarlos, y también para que
sepamos cómo corregir errores que eventualmente se produzcan en ellos.

`CVS/Entries.Log'
=================

A veces, aparecerá un extraño fichero `CVS/Entries.Log'. El único
propósito de este fichero es hacer de cache temporal de los cambios
menores de CVS/Entries, hasta que haya suficientes cambios acumulados
para modificar este fichero. CVS no es capaz de editar directamente el
fichero Entries, por el contrario tiene que leerlo y sobreescribirlo por
completo para cualquier cambio. Para evitar excesiva carga, CVS a veces
guarda los cambios pequeños en Entries.log, hasta la próxima vez que
necesite reescribir el fichero Entries.

El formato de Entries.log es como el de Entries, salvo que además
incluye una letra al principio de cada línea. `A' significa que la
línea será añadida al fichero Entries, y `R' significa que esa línea
será borrada.

Casi siempre podemos ignorar el fichero Entries.log; es raro que un
administrador tenga que entender la información que contiene. Sin
embargo, si estamos depurando algún problema que nos pide examinar el
fichero Entries, probablemente tengamos que echar un vistazo también a
Entries.log.

`CVS/Entries.Backup'
====================

El fichero CVS/Entries.backup es el que usa CVS para escribir un fichero
Entries nuevo, antes de renombrarlo a `Entries' (similarmente al
mecanismo de escribir en ficheros temporales RCS y luego renombrarlos
convenientemente). Debido a que se renombra a Entries cuando está
acabado, serán pocas las veces que veremos el fichero Entries.Backup; si
lo vemos alguna vez se deberá probablemente a la interrupción de un
proceso CVS en medio de alguna operación.

`CVS/Entries.Static'
====================

Si existe el fichero CVS/Entries.Static, significa que el directorio
completo no ha sido extraido del repositorio. (Cuando CVS sabe que un
directorio está en un estado incompleto, él no añadirá ficheros
adicionales a ese directorio.)

El fichero Entries.Static existe durante las operaciones de checkout y
actualización, y se borra inmediatamente al completar la operación. Si
vemos el fichero, significará que CVS fue interrumpido, y su existencia
impide a CVS crear cualquier fichero nuevo en la copia de trabajo.
(Ahora bien , ejecutando `cvs update -d' se soluciona el problema y se
borra Entries.Static.)

La ausencia de Entries.Static no implica necesariamente que la copia de
trabajo incluya todos los ficheros del proyecto. Tan pronto se crea un
nuevo directorio en el repositorio del proyecto, y alguien actualiza su
copia sin incluir el flag -d a la orden update, el nuevo directorio no
se creará en la copia de trabajo. Localmente, CVS no sabe que existe el
nuevo directorio, luego él mismo borrará el fichero Entries.Static
cuando la actualización termine, aunque el nuevo directorio no se haya
creado en la copia de trabajo.

`CVS/Tag'
=========

Si existe el fichero CVS/Tag, nombrará a un tag asociado, en cierto
sentido, con el directorio. Digo "en cierto sentido" ya que, como
sabemos, CVS no mantiene información sobre versiones de directorios y,
hablando con precisión, no puede asociar tags a ellos. Los tags se
asocian solo a ficheros normales o, más precisamente, a revisiones
concretas de ficheros normales.

Sin embargo, si cada fichero de un directorio está en un tag concreto,
CVS presupone que el directorio también está en ese tag. Por ejemplo, si
íbamos a extraer de CVS una copia de trabajo de una rama concreta:

     floss$ cvs co -r Bugfix_Rama_1

y luego insertamos un fichero en ella, querremos que la versión inicial
del fichero esté en esa rama también. Por razones similares, CVS
también necesita conocer si el directorio tiene un tag de que no es rama
(non-branch) o la fecha puesta en él.

Los ficheros de tags contienen una línea. El primer carácter de la línea
es un código de una letra que indica qué clase de tag es, y el resto es
el nombre del tag. Actualmente, CVS solo utiliza las siguientes tres
letras como código:

   * T - Tag de rama

   * N - Tag de que no es rama (regular tag)

   * D - Fecha "pegada", que se utiliza si un comando como

          floss$ cvs checkout -D 1999-05-15 myproj

     o

          floss$ cvs update -D 1999-05-15 myproj

     se ejecuta.


(Si vemos cualquier otro código de una letra, simplemente nos indicará
que CVS ha añadido un nuevo tipo de tag posteriormente a la escritura de
este libro.)

El fichero Tag no debe ser borrado manualmente; en su lugar use
`cvs update -A'.

Rarezas
=======

Hay otros ficheros que ocasionalmente se encontrarán en un directorio
CVS/:

   * CVS/Checkin.prog, CVS/Update.prog

   * CVS/Notify, CVS/Notify.tmp

   * CVS/Base/, CVS/Baserev, CVS/Baserev.tmp

   * CVS/Template

Estos ficheros no son, normalmente, causa de problemas, por lo que
simplemente los vamos a listar (véase *Note Referencia de CVS:: para
conocer su significado completo).

Portabilidad y extensiones futuras.
===================================

Conforme se añadan nuevas características a CVS, podrán aparecer nuevos
ficheros (no listados aquí) en las áreas administrativas. Conforme
dichos ficheros sean añadidos, probablemente serán documentados en el
manual de Cederqvist, en la sección `Working Directory Storage'.
También podemos mirar en el código fuente, en src/cvs.h, si preferimos
aprender a partir de las fuentes.

Finalmente, observemos que todos los ficheros CVS/* - actuales y
futuros - siguen las convenciones de final de línea apropiadas al
sistema en uso (por ejemplo, LF para Unix o CR/LF para Windows). Esto
significa que si llevamos una copia de trabajo desde una plataforma a
otra, puede suceder que CVS no pueda manejarla (además, podemos tener
otros problemas, debido a que los ficheros controlados por el sistema de
versiones pueden tener ellos mismos un fin de línea inapropiado).


File: cvsbook.info,  Node: Permisos del Repositorio,  Prev: La Copia de Trabajo del Área Administrativa,  Up: Causas Usualmente Sospechosas

Permisos del Repositorio
------------------------

CVS no necesita ningún esquema específico de permisos - puede manejar
una amplia variedad de esquemas. Sin embargo, para evitar situaciones
confusas, se debe configurar el repositorio siguiendo como mínimo los
siguientes criterios:

   * Si un usuario quiere algún tipo de acceso - incluso acceso
     solo-lectura - a un determinado directorio del repositorio,
     normalmente necesitará permisos de escritura a nivel de sistema
     sobre ese directorio. Esto es necesario ya que CVS crea ficheros
     cerrojo temporales en el repositorio para asegurarse la
     consistencia de los datos. Aun en operaciones de solo lectura
     (como la extracción o actualización de una copia de trabajo), se
     crearán cerrojos, para asegurar que los datos permanecen constantes
     durante la operación.

     Como se indica en *Note Administracion del Repositorio::, podemos
     salvar este requisito ajustando el parámetro LockDir del fichero
     CVSROOT/config. Por ejemplo:

          LockDir=/usr/local/cvslocks

     Por supuesto, habrá que asegurarse de que todos los usuarios de CVS
     pueden escribir sobre /usr/local/cvslocks. De otro modo, el
     directorio será el del repositorio; si somos muy estrictos con la
     seguridad, deberíamos cambiar este directorio por otro.

   * Asegurémosnos de que el fichero CVSROOT/history es escribible por
     todo el mundo, ya que si este fichero existe, casi todas las
     operaciones de CVS intentarán concatenar su histórico en este
     fichero, y si no lo pueden hacer terminarán con error.

     Por desgracia (e inexplicablemente), el fichero de histórico no se
     crea escribible por todo el mundo cuando se crea un repositorio
     nuevo con cvs init. Al menos con la versión actual de CVS, debemos
     cambiar los permisos de manera explícita una vez creado el
     repositorio (o simplemente borrarlo, si no queremos que se
     almacenen los históricos).

     (Este problema puede terminar pronto - acabo de enviar un parche a
     los mantenedores de CVS para que se cree el histórico con los
     permisos apropiados cuando se crea. Luego si usamos una versión de
     CVS posterior a septiembre de 1999, probablemente el problema
     habrá desaparecido.)

   * Por razones de seguridad, hay que asegurarse de que los usuarios
     de CVS no tienen acceso de escritura a nivel de Unix al directorio
     CVSROOT.  Si alguien tiene acceso de inserción en CVSROOT, podría
     editar cualquier fichero disparador de su elección (commitinfo,
     loginfo, etc), invocando cualquier programa que desee. En general,
     el acceso a CVSROOT por parte de un usuario de CVS implica la
     posibilidad de ejecutar cualquier comando del sistema.



File: cvsbook.info,  Node: Trucos Habituales,  Next: Algunos Problemas de la Vida Real (con Soluciones),  Prev: Causas Usualmente Sospechosas,  Up: Problemas y Soluciones

Trucos Habituales
=================

Este capítulo está organizado como una serie de preguntas y respuestas,
de manera similar a una FAQ (Preguntas Frecuentes) de Internet. Todas
ellas se basan en la experiencia habitual con CVS. Pero antes de mostrar
casos más individuales, tomemos unos minutos para considerar los
problemas de CVS desde un punto de vista más general.

El primer paso en la resolución de un problema con CVS es determinar si
sucede en una copia de trabajo o es un problema del repositorio. La
mejor técnica para hacerlo, es ver si el problema se repite en copias
de trabajo distintas del mismo repositorio. Si sucede así, será
probablemente un problema del repositorio; en otro caso estará limitado
a la copia local.

Los problemas con las copias de trabajo suelen encontrarse más
frecuentemente, simplemente porque son más numerosas que los
repositorios y no porque sean más "inestables". Aunque con algo de
paciencia se pueden resolver la mayoría de los problemas, muchas veces
la solución más sencilla y eficiente será borrar y volver a crear la
copia de trabajo.

Por supuesto, si crear la copia de trabajo resulta tedioso, o hay muchas
cosas pendientes de enviar al repositorio como para permitirse el lujo
de borrarlo, o simplemente somos de los que queremos averiguar el por
qué de las cosas, siempre podemos intentarlo. En primer lugar,
normalmente miraremos los subdirectorios CVS/, comprobando los ficheros
y sus permisos. A veces, los permisos se hacen misteriosamente de solo
lectura o simplemente sin permisos de lectura. Sospechamos que es debido
a que los usuarios se equivocan con alguna orden Unix relacionada y
cambian los permisos sin saberlo.

Los problemas en el repositorio se suelen producir por permisos
incorrectos en ficheros y directorios. Si sospechamos que el problema
pueda deberse a esto, primero miremos cuál es el UID efectivo en el
repositorio de la persona que origina el problema. Con usuarios locales
y remotos, suele ser un problema con el usuario que se especificó
durante la creación de la copia de trabajo. Si se usa el método pserver
con alias de usuario (véase la sección *Note Acceso anonimo:: en el
capítulo *Note Administracion del Repositorio::), el ID de usuario
efectivo estará en el fichero CVSROOT/passwd. Si no se ve esto a tiempo
puede provocarnos una gran pérdida de tiempo buscando la solución al
problema en otros sitios.

Y ahora veamos problemas más concretos...


File: cvsbook.info,  Node: Algunos Problemas de la Vida Real (con Soluciones),  Prev: Trucos Habituales,  Up: Problemas y Soluciones

Algunos Problemas de la Vida Real (con Soluciones)
==================================================

Las siguientes son situaciones que se me han dado en mi experiencia como
administrador de CVS (más algunas cosas que no son problemas realmente,
simplemente cuestiones que he oido por ahí y creo interesante contar
aquí). La lista pretende ser bastante completa y puede repetir cosas que
ya hayamos visto en capítulos anteriores.

Las situaciones se listan de acuerdo a la frecuencia con la que se
suelen dar, poniendo en primer lugar las más habituales.

* Menu:

* CVS dice que está esperando un cerrojo; ¿qué significa esto?::
* CVS dice que un fichero ha fallado la comprobación Up-To-Date (actualizado); ¿qué hago?::
* El método de acceso pserver no funciona::
* El método pserver SIGUE sin funcionar::
* Mis envíos (commits) parecen tener lugar a trozos y no atómicamente::
* CVS ignora los permisos que pongo; ¿por qué lo hace?::
* El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qué?::
* Mi copia de trabajo está en diferentes ramas ¿una ayuda?::
* Cuando hago export -d a veces pierdo commits recientes::
* Obtengo un error de val-tags; ¿qué hago?::
* Tengo problemas con los tags adhesivos; ¿cómo evitarlos?::
* Las extracciones/actualizaciones terminan con el error 'cannot expand modules'::
* No puedo desactivar los watches::
* Mis ficheros binarios se han corrompido::
* CVS no hace correctamente las conversiones de fin de línea::
* ¿Cómo se borra un directorio del proyecto?::
* ¿Puedo copiar ficheros .cvspass o parte de ellos?::
* Acabo de enviar algunos ficheros con un mensaje histórico incorrecto::
* Necesito mover ficheros sin perder el histórico de revisiones::
* ¿Como puedo obtener la lista de todas las etiquetas del proyecto?::
* ¿Como obtener una lista de todos los proyectos del repositorio?::
* Algunos comandos fallan en remoto pero no en local; ¿cómo lo depuramos?::
* Mi problema no está explicado en este capítulo::
* Creo que he descubierto un bug en CVS; ¿qué hago?::
* He añadido una característica a CVS; ¿a quién la envío?::
* ¿Como puedo mantenerme informado de las novedades en CVS?::


File: cvsbook.info,  Node: CVS dice que está esperando un cerrojo; ¿qué significa esto?,  Next: CVS dice que un fichero ha fallado la comprobación Up-To-Date (actualizado); ¿qué hago?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

CVS dice que está esperando un cerrojo; ¿qué significa esto?
------------------------------------------------------------

Si vemos un mensaje como este:

     cvs update: [22:58:26] waiting for qsmith's lock in /usr/local/newrepos/myproj

significa que estamos intentando acceder a un subdirectorio del
repositorio que está bloqueado por otro proceso CVS en este momento. Un
proceso está corriendo en ese subdirectorio, luego puede hacerlo
inconsistente a otros procesos CVS que quieran acceder a él.

Sin embargo, si el mensaje de espera persiste mucho tiempo,
probablemente indique que un proceso CVS ha fallado en su limpieza
final, por alguna razón. Puede pasar cuando CVS muere de pronto e
inesperadamente, por una caída de la máquina del repositorio, por
ejemplo.

La solución es borrar los ficheros de cerrojo a mano del subdirectorio
del repositorio en cuestión. Entremos en ese lugar y busquemos ficheros
con el nombre `#cvs.lock' o que empiecen por `#cvs.wfl' o `#cvs.rfl'.
Comparemos las fechas de los ficheros con los instantes de inicio de
cualquier proceso CVS actual. Si los ficheros no han podido ser creados
por esos procesos (son más antiguos), podemos borrarlos tranquilamente.
Los procesos CVS en espera se darán cuenta del borrado (normalmente
cada 30 segundos lo revisan) y terminarán su operación.

Véase el nodo `Locks' en el manual de Cederqvist para más detalle.


File: cvsbook.info,  Node: CVS dice que un fichero ha fallado la comprobación Up-To-Date (actualizado); ¿qué hago?,  Next: El método de acceso pserver no funciona,  Prev: CVS dice que está esperando un cerrojo; ¿qué significa esto?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

CVS dice que un fichero ha fallado la comprobación Up-To-Date (actualizado); ¿qué hago?
---------------------------------------------------------------------------------------

Evitemos el pánico - solo significa que el fichero ha cambiado en el
repositorio desde la última vez que nos lo bajamos o actualizamos.

Ejecutemos `cvs update' en el fichero para mezclar los cambios del
repositorio con los que hayamos hecho nosotros. Si los cambios
recibidos entran en conflicto con los nuestros, edítese el fichero para
resolver los conflictos. A continuación intentemos de nuevo enviar los
cambios al repositorio - tendrá exito, a menos que otra persona haya
vuelto a actualizar el fichero durante su trabajo.


File: cvsbook.info,  Node: El método de acceso pserver no funciona,  Next: El método pserver SIGUE sin funcionar,  Prev: CVS dice que un fichero ha fallado la comprobación Up-To-Date (actualizado); ¿qué hago?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

El método de acceso pserver no funciona
---------------------------------------

La causa más común, pero no precisamente obvia, es que hayamos olvidado
la opción `--allow-root' en la configuración de inetd.

Recordemos este ejemplo de línea de /etc/inetd.conf:

     cvspserver stream tcp nowait root /usr/local/bin/cvs cvs \
               --allow-root=/usr/local/newrepos pserver

(En el fichero real será una sola línea, sin barra invertida.)

La parte `--allow-root=/usr/local/newrepos' es una medida de seguridad,
para asegurarnos de que la gente no pueda usar CVS para obtener acceso
pserver a repositorios que se supone no son servidos remotamente.
Cualquier repositorio que se desee accesible por pserver, debe estar
mencionado en la opción `--allow-root'. Podemos tener todas las
opciones de este tipo que deseemos, para dar acceso a todos los
repositorios que hagan falta (mientras no llenemos la longitud máxima
de línea de la configuración del inetd).

Véase el capítulo *Note Administracion del Repositorio:: para más
detalle sobre la configuración del servidor autentificado con
contraseña.


File: cvsbook.info,  Node: El método pserver SIGUE sin funcionar,  Next: Mis envíos (commits) parecen tener lugar a trozos y no atómicamente,  Prev: El método de acceso pserver no funciona,  Up: Algunos Problemas de la Vida Real (con Soluciones)

El método pserver SIGUE sin funcionar
-------------------------------------

De acuerdo, si el problema no es la ausencia de una opción
`--allow-root', veamos otras posibles causas:

   * El usuario no tiene una entrada en el fichero CVSROOT/passwd, y el
     fichero CVSROOT/config tiene la opción SystemAuth=no, por lo que
     CVS no buscará el usuario en el fichero de usuarios del sistema (o
     bien SystemAuth=yes pero no existe ese usuario en el sistema).

   * El usuario tiene una entrada en el fichero CVSROOT/passwd, pero no
     hay usuario con ese nombre en el sistema, por lo que no se puede
     mapear a un usuario válido.

   * La contraseña es incorrecta (aunque como CVS suele informar de esto
     convenientemente, casi seguro que nuestro problema no será éste).

   * Todo está correcto en los ficheros de claves y en /etc/inetd.conf,
     pero se nos olvidó una entrada como ésta en /etc/services:

          cvspserver      2401/tcp

     por lo que inetd no es capaz de saber qué puerto es cvspserver.



File: cvsbook.info,  Node: Mis envíos (commits) parecen tener lugar a trozos y no atómicamente,  Next: CVS ignora los permisos que pongo; ¿por qué lo hace?,  Prev: El método pserver SIGUE sin funcionar,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Mis envíos (commits) parecen tener lugar a trozos y no atómicamente
-------------------------------------------------------------------

Esto es porque CVS hace los envíos a trozos, y no atómicamente. :-)

Más específicamente, las operaciones de CVS tienen lugar directorio a
directorio. Cuando hacemos un commit (o update o cualquier cosa)
afectando a varios directorio, CVS bloquea cada directorio mientras hace
la operación en él, desbloqueándolo antes de pasar al siguiente.

Para proyectos pequeños o medianos, raramente será esto un problema, ni
notaremos que la operación no es atómica. Sin embargo, en proyectos
grandes, se pueden dar escenarios como el siguiente (imaginemos que el
proyecto tiene al menos dos directorios A y B, con muchos ficheros):

  1. El usuario pperez inicia un envío (commit), afectando a ficheros de
     ambos directorios. CVS envía los ficheros de B en primer lugar
     (porque el usuario lo especificó en ese orden).

  2. El usuario jsuerte inicia una actualización (update). Por alguna
     razón, supongamos que ésta se inicia copiando el directorio A (CVS
     no garantiza ningún orden por su cuenta). Obsérvse que no hay
     bloqueo aun porque pperez aun no está activo en A.

  3. Ahora, el envío de pperez finaliza B, se va a A y finaliza A.

  4. Finalmente, la actualización de jsuerte se va a B y finaliza.


Claramente, cuando todo acaba, la copia de trabajo de jsuerte refleja
los cambios de pperez en B pero no en A. Aunque pperez intentase hacerlo
atómicamente, no hay forma. Ahora la copia de jsuerte está en un estado
que desconoce pperez.

La solución, por supuesto, es que jsuerte haga de nuevo el cvs update.

El fallo de no permitir transacciones atómicas es considerado
ampliamente como un error de CVS. La única razón por la que los cerrojos
no se establecen en la raíz del repositorio es porque esto resultaría
inaceptable para grandes proyectos con múltiples desarrolladores. Para
mitigar este problema, en CVS se escogió bloquear a nivel de cada
directorio, reduciendo así la contención. Alguna vez alguien podría
modificar CVS para acelerar sus operaciones, de manera que se mejore
esta situación.

Para más información, véase el nodo `Concurrency' del manual de
Cederqvist.


File: cvsbook.info,  Node: CVS ignora los permisos que pongo; ¿por qué lo hace?,  Next: El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qué?,  Prev: Mis envíos (commits) parecen tener lugar a trozos y no atómicamente,  Up: Algunos Problemas de la Vida Real (con Soluciones)

CVS ignora los permisos que pongo; ¿por qué lo hace?
----------------------------------------------------

En general, CVS no realiza un muy buen trabajo para preservar los
permisos de los ficheros. Cuando importamos un proyecto y luego lo
extraemos, no hay garantía de que en la copia de trabajo obtenida los
ficheros tengan los mismos permisos que cuando fueron importados. Más
bien, lo que sucede es que los ficheros de la copia de trabajo se crean
con el esquema de permisos estándar que tengamos en nuestra cuenta de
usuario.

Sin embargo, hay al menos una excepción. Si queremos almacenar scripts
de shell ejecutables en el proyecto, podemos mantenerlos ejecutables en
todas las copias de trabajo sin más que hacer ejecutable el fichero del
repositorio:

     floss$ ls -l /usr/local/mirepo/unproyecto
     total 6
     -r--r--r--   1 jsuerte  users         630 Aug 17 01:10 README.txt,v
     -r-xr-xr-x   1 jsuerte  users        1041 Aug 17 01:10 scrub.pl,v*
     -r--r--r--   1 jsuerte  users         750 Aug 17 01:10 hola.c,v

Nótese que aunque el fichero es ejecutable, se mantiene en solo-lectura,
como debe ser en todos los ficheros de un repositorio (recordar que CVS
trabaja haciendo los cambios sobre una copia temporal del fichero RCS,
que luego reemplaza al original).

Cuando importamos o añadimos un fichero ejecutable, CVS preserva los
bits de ejecución, de manera que si los permisos iniciales son
correctos, en general no habrá que preocuparse más. Sin embargo, si
accidentalmente añadimos el fichero antes de hacerlo ejecutable, debemos
ir al repositorio y cambiar los bits a mano sobre el fichero RCS.

Los permisos del repositorio siempre predominan. Si el fichero no es
ejecutable en el repositorio pero sí lo es en la copia de trabajo,
cuando hagamos una actualización seguirá como esté en el repositorio.
Cuando los permisos de los ficheros cambian misteriosamente puede ser
frustrante. Si esto sucede, comprobar primero los permisos en el
repositorio y ver si podemos resolverlo ajustando los permisos sobre los
ficheros RCS.

Recientemente se añadió a CVS una característica denominada
`PreservePermissions' que puede aliviar alguno de estos problemas. Sin
embargo, usando esta característica pueden producirse otros resultados
inesperados (por lo que no recomiendo usarla siempre). Nos debemos
asegurar de leer antes los nodos `config' y `Special Files' del manual
de Cederqvist antes de incluir `PreservePermissions=yes' en
CVSROOT/config.


File: cvsbook.info,  Node: El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qué?,  Next: Mi copia de trabajo está en diferentes ramas ¿una ayuda?,  Prev: CVS ignora los permisos que pongo; ¿por qué lo hace?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qué?
---------------------------------------------------------------------------

Para conexiones pserver, el CVS del lado cliente intenta encontrar el
fichero .cvspass en el directorio principal de la cuenta (HOME). Las
máquinas con Windows no tienen un directorio "home" natural, por lo que
CVS consulta la variable `%HOME%'. Sin embargo, hay que ser cuidadosos
con esta variable. Esto funcionará:

     set HOME=C:

Pero esto no:

     set HOME=C:\

Esta barra extra es suficiente para confundir a CVS y será incapaz de
abrir el fichero `C:\\.cvspass'.

La más rápida y segura solución, pues, es poner

     set HOME=C:

en el fichero autoexec.bat y reiniciar. El pserver de CVS debe funcionar
ahora correctamente.


File: cvsbook.info,  Node: Mi copia de trabajo está en diferentes ramas ¿una ayuda?,  Next: Cuando hago export -d a veces pierdo commits recientes,  Prev: El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qué?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Mi copia de trabajo está en diferentes ramas ¿una ayuda?
--------------------------------------------------------

¿Hablamos de diferentes subdirectorios de la copia de trabajo en
diferentes ramas? Probablemente hemos ejecutado updates con la opción
-r, pero en lugares distintos de la raíz de la copia de trabajo.

No hay problema. Si queremos volver a lo correcto, ejecutemos esto

     cvs update -r HEAD

o esto

     cvs update -A

desde el directorio raíz. O, si lo que queremos es poner la copia de
trabajo a una de las ramas, hacer esto:

     cvs update -r Nombre_rama

No hay problema por tener uno o dos subdirectorios de la copia de
trabajo pertenecientes a diferentes ramas, si lo que queremos es hacer
algún trabajo en esa rama temporalmente solo en esos ficheros. Sin
embargo, será una buena idea normalmento volver cuando acabemos - la
vida será mucho menos confusa cuando toda nuestra copia de trabajo
pertenezca a la misma línea de desarrollo.


File: cvsbook.info,  Node: Cuando hago export -d a veces pierdo commits recientes,  Next: Obtengo un error de val-tags; ¿qué hago?,  Prev: Mi copia de trabajo está en diferentes ramas ¿una ayuda?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Cuando hago export -d a veces pierdo commits recientes
------------------------------------------------------

Esto se debe a una diferencia entre el reloj de la máquina del
repositorio y el local. Podemos resolverlo ajustando uno o ambos
relojes, o especificando una fecha distinta con la opción -D. Es
perfectamente aceptable el especificar una fecha del futuro (tal como -D
tomorrow), si esto puede compensar la diferencia de tiempos.


File: cvsbook.info,  Node: Obtengo un error de val-tags; ¿qué hago?,  Next: Tengo problemas con los tags adhesivos; ¿cómo evitarlos?,  Prev: Cuando hago export -d a veces pierdo commits recientes,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Obtengo un error de val-tags; ¿qué hago?
----------------------------------------

Si obtenemos un error como este:

     cvs [export aborted]: cannot write /usr/local/myproj/CVSROOT/val-tags: \
        Operation not permitted

significa que el CVS del usuario está corriendo y no tiene permiso para
escribir el fichero CVSROOT/val-tags. Este fichero almacena nombres de
tags, para que CVS tenga una manera rápida de determinar qué tags son
válidos. Desafortunadamente, CVS a veces modifica este fichero en
operaciones que deberían ser solo-lectura respecto del repositorio, como
una simple extracción (check-out) del proyecto.

Esto es un error de CVS y debe haberse corregido mientras leemos esto.
Hasta entonces, la solución es hacer que el fichero val-tags sea
escribible por todo el mundo o, si esto falla, borrarlo o poner de
propietario al usuario que está intentando operar. (Podríamos pensar que
cambiar los permisos es suficiente, pero a veces he tenido que tambiar
también al propietario.)


File: cvsbook.info,  Node: Tengo problemas con los tags adhesivos; ¿cómo evitarlos?,  Next: Las extracciones/actualizaciones terminan con el error 'cannot expand modules',  Prev: Obtengo un error de val-tags; ¿qué hago?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Tengo problemas con los tags adhesivos; ¿cómo evitarlos?
--------------------------------------------------------

Algunas operaciones del CVS hacen que la copia de trabajo tengan un
"tag adhesivo", que es un tag que corresponde a cada revisión de cada
fichero (en el caso de una rama, el tag adhesivo se aplica a cualquier
fichero que se añada a la copia de trabajo). Obtendremos un área de
trabajo con tags adhesivos cuando extraigamos o actualicemos por tag o
por fecha, por ejemplo:

     floss$ cvs update -r Nombre_Tag

o

     floss$ cvs checkout -D '1999-08-16'

Si se usa una fecha o un nombre de tag que no sea rama, la copia de
trabajo será una foto congelada de ese momento en el histórico del
proyecto - por lo que naturalmente no podremos enviar cambios de
ninguna clase desde él.

Para eliminar un tag adhesivo actualizaremos con el flag -A

     floss$ cvs update -A

que limpia todos los tags adhesivos y actualiza cada fichero a su
revisión más reciente.


File: cvsbook.info,  Node: Las extracciones/actualizaciones terminan con el error 'cannot expand modules',  Next: No puedo desactivar los watches,  Prev: Tengo problemas con los tags adhesivos; ¿cómo evitarlos?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Las extracciones/actualizaciones terminan con el error 'cannot expand modules'
------------------------------------------------------------------------------

Esto es un ejemplo de error fatal de CVS; probablemente alguien lo
intentará corregir pronto, pero mientras tanto nos molestará. El error
es similar al siguiente:

     floss$ cvs co -d bwf-misc user-space/bwf/writings/misc
     cvs server: cannot find module `user-space/bwf/writings/misc' - ignored
     cvs [checkout aborted]: cannot expand modules

CVS aparenta estar diciendo que hay algo mal en el fichero
CVSROOT/modules. Sin embargo, lo que realmente ocurre es un problema de
permisos del repositorio. El directorio que estamos intentando extraer
no es legible, o uno de sus ancestros no lo es. En este caso, era un
ancestro:

     floss$ ls -ld /usr/local/cvs/user-space/bwf
     
     drwx------  19 bwf      users        1024 Aug 17 01:24 bwf/

Como vemos no hay que preocuparse demasiado - es simplemente otro
problema de permisos.


File: cvsbook.info,  Node: No puedo desactivar los watches,  Next: Mis ficheros binarios se han corrompido,  Prev: Las extracciones/actualizaciones terminan con el error 'cannot expand modules',  Up: Algunos Problemas de la Vida Real (con Soluciones)

No puedo desactivar los watches
-------------------------------

Probablemente habremos ejecutado

     floss$ cvs watch remove

en todos los ficheros, pero se nos olvidó hacer esto otro:

     floss$ cvs watch off

Una sugerencia para diagnosticar errores con los watches: a veces puede
clarificar mucho simplemente el entrar en el repositorio y examinar el
fichero CVS/fileattr directamente. Véase *Note Administracion del
Repositorio:: para más información sobre esto.


File: cvsbook.info,  Node: Mis ficheros binarios se han corrompido,  Next: CVS no hace correctamente las conversiones de fin de línea,  Prev: No puedo desactivar los watches,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Mis ficheros binarios se han corrompido
---------------------------------------

¿Nos hemos acordado de usar el modificador -kb al insertarlos? Si no fue
así, CVS puede haber realizado expansiones de macros RCS o conversiones
de fin de línea. La solución más simple es marcarlos como binarios,

     floss$ cvs admin -kb ejemplo.gif

y luego enviar una versión corregida del fichero. CVS no corromperá
nuevos envíos de este fichero, puesto que ya sabe que es binario.


File: cvsbook.info,  Node: CVS no hace correctamente las conversiones de fin de línea,  Next: ¿Cómo se borra un directorio del proyecto?,  Prev: Mis ficheros binarios se han corrompido,  Up: Algunos Problemas de la Vida Real (con Soluciones)

CVS no hace correctamente las conversiones de fin de línea
----------------------------------------------------------

Si hemos ejecutado el cliente CVS en una plataforma no Unix, y no
tenemos las conversiones correctas de final de línea, se deberá
normalmente a que hemos añadido los ficheros accidentalmente como
binarios (opción -kb). Esto puede corregirse en el repositorio con el
comando:

     floss$ cvs admin -kkv FICHERO

El modificador -kkv solicita hacer la expansión de macros normal y las
conversiones de fin de línea (internamente, CVS se confunde con la
diferencia entre la expansión de macros y la conversión de fin de
línea. Esta confusión da lugar a que las opciones de -k siempre
controlan ambos aspectos a la vez).

Por desgracia, este comando de administración solo corrige el fichero en
el repositorio, es decir, nuestra copia local seguirá considerándose
como binaria. Siempre podemos editar a mano el fichero CVS/Entries
eliminando la opción -kb de la línea correspondiente.


File: cvsbook.info,  Node: ¿Cómo se borra un directorio del proyecto?,  Next: ¿Puedo copiar ficheros .cvspass o parte de ellos?,  Prev: CVS no hace correctamente las conversiones de fin de línea,  Up: Algunos Problemas de la Vida Real (con Soluciones)

¿Cómo se borra un directorio del proyecto?
------------------------------------------

Bien, no podemos borrar el directorio realmente, pero podemos borrar
todos los ficheros que haya dentro (primero hacemos cvs remove y luego
commit). Una vez que el directorio está vacío, se eliminará de las
copias de trabajo usando la opción -P durante cualquier actualización.


File: cvsbook.info,  Node: ¿Puedo copiar ficheros .cvspass o parte de ellos?,  Next: Acabo de enviar algunos ficheros con un mensaje histórico incorrecto,  Prev: ¿Cómo se borra un directorio del proyecto?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

¿Puedo copiar ficheros .cvspass o parte de ellos?
-------------------------------------------------

Sí, claro. Se pueden copiar de una máquina a otra, o se pueden
transferir líneas individuales de un fichero .cvspass a otro. Para
servidores con acceso lento, esto puede ser más rápido que hacer cvs
login en cada máquina.

Recordemos que si transportamos un fichero .cvspass entre dos máquinas
con diferentes convenciones de fin de línea, probablemente no
funcionarán (por supuesto, siempre se puede corregir este problema a
mano).


File: cvsbook.info,  Node: Acabo de enviar algunos ficheros con un mensaje histórico incorrecto,  Next: Necesito mover ficheros sin perder el histórico de revisiones,  Prev: ¿Puedo copiar ficheros .cvspass o parte de ellos?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Acabo de enviar algunos ficheros con un mensaje histórico incorrecto
--------------------------------------------------------------------

Para resolver esto no hay que editar nada del repositorio. Simplemente
ejecutemos cvs admin con la opción -m. Recuérdese no dejar espacios
entre -m y el argumento, y acitar el mensaje histórico tal como se haría
normalmente:

     floss$ cvs admin -m1.17:'Recientes mejoras en mi mejor programa.' hola.c


File: cvsbook.info,  Node: Necesito mover ficheros sin perder el histórico de revisiones,  Next: ¿Como puedo obtener la lista de todas las etiquetas del proyecto?,  Prev: Acabo de enviar algunos ficheros con un mensaje histórico incorrecto,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Necesito mover ficheros sin perder el histórico de revisiones
-------------------------------------------------------------

En el repositorio, copiemos (no movamos) los ficheros RCS al nuevo lugar
deseado. Esto debe respetar sus antiguas localizaciones. Ahora, desde
una copia de trabajo, hagamos lo siguiente:

     floss$ rm ficheroviejo1 ficheroviejo2 ...
     floss$ cvs remove ficheroviejo1 ficheroviejo2 ...
     floss$ cvs commit -m 'Ficheros movidos ...'

Cuando la gente haga actualizaciones, CVS borrará los ficheros viejos y
los creará en sus nuevos sitios, tal como si se hubiera hecho la
operación de añadir normalmente (excepto por el hecho de que se siguen
usando los números de revisión anteriores).


File: cvsbook.info,  Node: ¿Como puedo obtener la lista de todas las etiquetas del proyecto?,  Next: ¿Como obtener una lista de todos los proyectos del repositorio?,  Prev: Necesito mover ficheros sin perder el histórico de revisiones,  Up: Algunos Problemas de la Vida Real (con Soluciones)

¿Como puedo obtener la lista de todas las etiquetas del proyecto?
-----------------------------------------------------------------

Actualmente no hay forma de hacerlo con CVS. Es algo demandado por los
usuarios y se espera que en futuras versiones esté disponible. Puede que
pronto (incluso ya) existe un comando `cvs tags' o similar.

Hasta entonces, hay aproximaciones. Podemos ejecutar cvs log -h y leer
las secciones de la salida con la cabecera `symbolic names:'. O bien,
si estamos en la máquina del repositorio, podemos mirar en el principio
de algunos ficheros RCS. Todas las etiquetas (rama y no rama) se listan
en el campo `symbols':

     floss$ head /usr/local/nuevorep/hola.c,v
     head	2.0;
     access;
     symbols
     	Release_1_0:1.22
     	Exotic_Greetings-2:1.21
     	merged-Exotic_Greetings-1:1.21
     	Exotic_Greetings-1:1.21
     	merged-Exotic_Greetings:1.21
     	Exotic_Greetings-branch:1.21.0.2
     	Root-of-Exotic_Greetings:1.21
     	start:1.1.1.1
     	jrandom:1.1.1;
     locks; strict;
     comment	@ * @;


File: cvsbook.info,  Node: ¿Como obtener una lista de todos los proyectos del repositorio?,  Next: Algunos comandos fallan en remoto pero no en local; ¿cómo lo depuramos?,  Prev: ¿Como puedo obtener la lista de todas las etiquetas del proyecto?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

¿Como obtener una lista de todos los proyectos del repositorio?
---------------------------------------------------------------

Al igual que sucede con la lista de etiquetas, no está implementado en
la versión actual de CVS, pero se entiende que lo estará pronto. Imagino
el comando similar a cvs list, con una forma abreviada cvs ls, y
probablemente ambos analizarán los módulos y listarán los
subdirectorios.

Por ahora, examinando el fichero CVSROOT/modules (directamente o
ejecutando cvs checkout -c) podemos conseguirlo. Sin embargo, si nadie
ha hecho un módulo para un proyecto, no veremos nada sobre ese proyecto
en el fichero modules.


File: cvsbook.info,  Node: Algunos comandos fallan en remoto pero no en local; ¿cómo lo depuramos?,  Next: Mi problema no está explicado en este capítulo,  Prev: ¿Como obtener una lista de todos los proyectos del repositorio?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Algunos comandos fallan en remoto pero no en local; ¿cómo lo depuramos?
-----------------------------------------------------------------------

A veces hay un problema de comunicación entre el cliente y el servidor.
Y puede ser un error de CVS.

CVS proporciona un mecanismo de trazar el protocolo entre el cliente y
el servidor. Antes de ejecutar el comando en la máquina local (con la
copia de trabajo), crear la variable `CVS_CLIENT_LOG'. En un shell de
Bash se haría así:

     floss$ CVS_CLIENT_LOG=clog; export CVS_CLIENT_LOG

Una vez creada la variable, CVS almacenará las comunicaciones entre
cliente y servidor en dos ficheros con el nombre basado en el valor de
la variable anterior:

     floss$ ls
     CVS/        LEAME.txt    a-subdir/    b-subdir/    prueba.gif     hola.c
     floss$ cvs update
     ? clog.in
     ? clog.out
     cvs server: Updating .
     cvs server: Updating a-subdir
     cvs server: Updating a-subdir/subsubdir
     cvs server: Updating b-subdir
     floss$ ls
     CVS/              a-subdir/    clog.in     prueba.gif
     LEAME.txt        b-subdir/    clog.out    hola.c
     floss$

El fichero `clog.in' contiene lo enviado por el cliente al servidor, y
el fichero `clog.out' contiene los mensajes del servidor al cliente.
Vemos por ejemplo el contenido de clog.out:

     Valid-requests Root Valid-responses valid-requests Repository           \
     Directory Max-dotdot Static-directory Sticky Checkin-prog Update-prog   \
     Entry Kopt Checkin-time Modified Is-modified UseUnchanged Unchanged     \
     Notify Questionable Case Argument Argumentx Global_option Gzip-stream   \
     wrapper-sendme-rcsOptions Set expand-modules ci co update diff log add  \
     remove update-patches gzip-file-contents status rdiff tag rtag import   \
     admin export history release watch-on watch-off watch-add watch-remove  \
     watchers editors init annotate noop
     ok
     M ? clog.in
     M ? clog.out
     E cvs server: Updating .
     E cvs server: Updating a-subdir
     E cvs server: Updating a-subdir/subsubdir
     E cvs server: Updating b-subdir
     ok

El fichero clog.in es más complicado, puesto que incluye números de
versión y otras informaciones por cada fichero.

No podemos dedicar espacio aquí a documentar el protocolo, pero podemos
leer las páginas Info de `cvsclient' que vienen con el paquete de CVS
para más información. Comprobaremos que aunque no siempre nos dé una
respuesta, mirar el histórico del protocolo puede darnos una buena
pista.


File: cvsbook.info,  Node: Mi problema no está explicado en este capítulo,  Next: Creo que he descubierto un bug en CVS; ¿qué hago?,  Prev: Algunos comandos fallan en remoto pero no en local; ¿cómo lo depuramos?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Mi problema no está explicado en este capítulo
----------------------------------------------

Lo mejor es enviar una descripción del problema a la lista de discusión
sobre CVS, <info-cvs@gnu.org>. Los miembros están dispersos por todo el
mundo, y por tanto a todas horas suele haber alguien que nos ayudará
casi de inmediato. Para apuntarse a la lista hay que enviar un mensaje
a <info-cvs-request@gnu.org>. Se agradecerá que nosotros también
ayudemos a resolver problemas a los demás.


File: cvsbook.info,  Node: Creo que he descubierto un bug en CVS; ¿qué hago?,  Next: He añadido una característica a CVS; ¿a quién la envío?,  Prev: Mi problema no está explicado en este capítulo,  Up: Algunos Problemas de la Vida Real (con Soluciones)

Creo que he descubierto un bug en CVS; ¿qué hago?
-------------------------------------------------

CVS no es perfecto ... si hemos intentado consultar el manual o
preguntar por ahí y aun creemos que es un bug, podemos hacer lo
siguiente:

Hay que enviar una descripción lo más completa posible del error a
<bug-cvs@gnu.org>. A esta lista también podemos suscribirnos
escribiendo a <bug-cvs-request@gnu.org>. Hay que incluir en nuestra
consulta los números de versión (cliente y servidor) y el modo de
reproducir el error.

Si hubiéramos escrito un parche para corregir el error, incluyámoslo y
mencionémoslo en la línea del asunto del mensaje. Los desarrolladores lo
agradecerán infinitamente.

(En el manual de Cederqvist, en el nodo `BUGS', encontraremos más
detalles sobre cómo seguir estos procedimientos. También hay información
en el fichero HACKING de la distribución del código fuente).


File: cvsbook.info,  Node: He añadido una característica a CVS; ¿a quién la envío?,  Next: ¿Como puedo mantenerme informado de las novedades en CVS?,  Prev: Creo que he descubierto un bug en CVS; ¿qué hago?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

He añadido una característica a CVS; ¿a quién la envío?
-------------------------------------------------------

Al igual que con los errores, enviaremos el parche a <bug-cvs@gnu.org>.
Antes tenemos que asegurarnos de que hemos leído el mencionado fichero
HACKING.


File: cvsbook.info,  Node: ¿Como puedo mantenerme informado de las novedades en CVS?,  Prev: He añadido una característica a CVS; ¿a quién la envío?,  Up: Algunos Problemas de la Vida Real (con Soluciones)

¿Como puedo mantenerme informado de las novedades en CVS?
---------------------------------------------------------

Las técnicas de resolución de problemas y los errores conocidos
descritos en este capítulo son para la versión de CVS 1.10.7
(aproximadamente). Pero el mundo CVS se mueve rápidamente. Mientras que
escribía los últimos capítulos, el mantenimiento de CVS pasó de Cyclic
Software a SourceGear Inc (`http://www.sourcegear.com'), quienes habían
comprado Cyclic. SourceGear ha anunciado públicamente su intención de
participar activamente en el equipo de desarrolladores de CVS y ha
recibido la aprobación de la gente de Cyclic, quienes eran más o menos
los que lo lideraban hasta ahora (la dirección `http://www.cyclic.com'
seguirá funcionando, sin embargo, de manera que todas las URL dadas
aquí aún valen).

SourceGear está, en este preciso momento, ocupada organizando y puliendo
varios parches que estaban circulando por ahí, con la intención de
incorporar los que puedan a CVS. Algunos parches probablemente
corregirán errores vistos aquí, y otros añadirán nuevas opciones a los
usuarios.

La mejor forma de mantenerse informado de la evolución es leer el
fichero NEWS de la distribución de CVS, vigilando además las listas de
correo y buscando cambios en el manual de Cederqvist y en la versión en
línea, en inglés, de este libro (`http://cvsbook.red-bean.com').

