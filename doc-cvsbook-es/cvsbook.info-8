This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: Usando expansión de palabras,  Next: Salir del limbo (Cómo trabajar con derivaciones y sobrevivir),  Prev: Anotaciones y ramificaciones,  Up: CVS avanzado

Usando expansión de palabras
============================

Podría recordar una breve mención de `keyword expansion' en *Note Una
introduccion a CVS::. Estas palabras especiales de RCS están rodeadas
por el signo del dolar, que CVS busca en el texto del fichero y las
sustituye por información de revisión. Por ejemplo si un fichero
contiene

     $Author: jfs $

entonces cuando se actualize ese fichero a cualquier revisión, CVS lo
sustituirá por el nombre de usuario de la persona que realizó la
entrega de esa revisión:

     $Author: jfs $

CVS es también consciente de las palabras que han sido sustituidas por
lo que estas se pueden actualizar cuando sea apropiado.

Aunque estas palabras no ofrecen información que no puediera ser
obtenida mediante otros medios, dan a las personas una forma cómoda de
ver los hechos de revisión incluidos en el texto mismo, en vez de tener
que invocar alguna orden rara de CVS.

He aquí otros ejemplos de sustitución de palabras:

     $Date: 2002/12/05 19:10:27 $       ==>  date of last commit, expands to ==>
     $Date: 2002/12/05 19:10:27 $
     
     $Id: chapter-6.texi,v 1.4 2002/12/05 19:10:27 jfs Exp $         ==>  filename, revision, date, and author; expands to ==>
     $Id: chapter-6.texi,v 1.4 2002/12/05 19:10:27 jfs Exp $
     
     $Revision: 1.4 $   ==>  exactly what you think it is, expands to ==>
     $Revision: 1.4 $
     
     $Source: /home/cvs/lucas/doc-cvsbook-es/chapter-6.texi,v $     ==> path to corresponding repository file, expands to ==>
     $Source: /home/cvs/lucas/doc-cvsbook-es/chapter-6.texi,v $
     
     $Log: chapter-6.texi,v $
     Revision 1.4  2002/12/05 19:10:27  jfs
     Ahora el documento compila incluyendo los acentos en castellano, he seguido
     los consejos de
     http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
     Sin embargo sería conveniente revisar por qué los nombres de nodo que se
     referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
     
     Revision 1.3  2002/12/03 13:04:59  carlosgarcia
     Traduccion de main, introduction e index
     
     Revision 1.2  2002/11/27 16:26:56  carlosgarcia
     Realizados arreglos para compilación
     
     Revision 1.1  2000/09/16 12:07:53  jjamor
     Traduccion del capitulo 6 insertada en la B.de trabajo
             ==>  accumulating log messages for the file, expands to ==>
     $Log: chapter-6.texi,v $
     Revision 1.4  2002/12/05 19:10:27  jfs
     Ahora el documento compila incluyendo los acentos en castellano, he seguido
     los consejos de
     http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
     Sin embargo sería conveniente revisar por qué los nombres de nodo que se
     referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
     
     Revision 1.3  2002/12/03 13:04:59  carlosgarcia
     Traduccion de main, introduction e index
     
     Revision 1.2  2002/11/27 16:26:56  carlosgarcia
     Realizados arreglos para compilación
     
     Revision 1.1  2000/09/16 12:07:53  jjamor
     Traduccion del capitulo 6 insertada en la B.de trabajo
     
     Revision 1.2  1999/07/26 06:47:52  jrandom
     ...and this is the second log message.
     
     Revision 1.1  1999/07/26 06:39:46  jrandom
     This is the first log message...

La palabra $Log: chapter-6.texi,v $ La palabra Revision 1.4  2002/12/05
19:10:27  jfs La palabra Ahora el documento compila incluyendo los
acentos en castellano, he seguido La palabra los consejos de La palabra
http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
La palabra Sin embargo sería conveniente revisar por qué los nombres de
nodo que se La palabra referencian no pueden estar con ISO-latin1...
¿problema de TexInfo?  La palabra La palabra Revision 1.3  2002/12/03
13:04:59  carlosgarcia La palabra Traduccion de main, introduction e
index La palabra La palabra Revision 1.2  2002/11/27 16:26:56
carlosgarcia La palabra Realizados arreglos para compilación La palabra
La palabra Revision 1.1  2000/09/16 12:07:53  jjamor La palabra
Traduccion del capitulo 6 insertada en la B.de trabajo La palabra es la
única que se exande varias lineas. A diferencia de las otras no
reemplaza la antigua sustitución con una nueva, sino que inserta la
última sustitución más una línea en blanco justo después de la palabra
especial (las previas sustituciones quedan más abajo).  Además
cualquier texto entre el principio de línea y el $Log es usada como un
prefijo para las sustituciones (esto se hace para asegurar que los
mensajes log quedan comentados en el código del programa).  Por
ejemplo, si usted pone esto dentro de un fichero

     // $Log: chapter-6.texi,v $
     // Revision 1.4  2002/12/05 19:10:27  jfs
     // Ahora el documento compila incluyendo los acentos en castellano, he seguido
     // los consejos de
     // http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
     // Sin embargo sería conveniente revisar por qué los nombres de nodo que se
     // referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
     //
     // Revision 1.3  2002/12/03 13:04:59  carlosgarcia
     // Traduccion de main, introduction e index
     //
     // Revision 1.2  2002/11/27 16:26:56  carlosgarcia
     // Realizados arreglos para compilación
     //
     // Revision 1.1  2000/09/16 12:07:53  jjamor
     // Traduccion del capitulo 6 insertada en la B.de trabajo
     //

se sustituirá por esto en la primera entrega:

     // $Log: chapter-6.texi,v $
     // Revision 1.4  2002/12/05 19:10:27  jfs
     // Ahora el documento compila incluyendo los acentos en castellano, he seguido
     // los consejos de
     // http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
     // Sin embargo sería conveniente revisar por qué los nombres de nodo que se
     // referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
     //
     // Revision 1.3  2002/12/03 13:04:59  carlosgarcia
     // Traduccion de main, introduction e index
     //
     // Revision 1.2  2002/11/27 16:26:56  carlosgarcia
     // Realizados arreglos para compilación
     //
     // Revision 1.1  2000/09/16 12:07:53  jjamor
     // Traduccion del capitulo 6 insertada en la B.de trabajo
     //
     // Revision 1.14  1999/07/26 07:03:20  jrandom
     // this is the first log message...
     //

a esto en la segunda:

     // $Log: chapter-6.texi,v $
     // Revision 1.4  2002/12/05 19:10:27  jfs
     // Ahora el documento compila incluyendo los acentos en castellano, he seguido
     // los consejos de
     // http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
     // Sin embargo sería conveniente revisar por qué los nombres de nodo que se
     // referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
     //
     // Revision 1.3  2002/12/03 13:04:59  carlosgarcia
     // Traduccion de main, introduction e index
     //
     // Revision 1.2  2002/11/27 16:26:56  carlosgarcia
     // Realizados arreglos para compilación
     //
     // Revision 1.1  2000/09/16 12:07:53  jjamor
     // Traduccion del capitulo 6 insertada en la B.de trabajo
     //
     // Revision 1.15  1999/07/26 07:04:40  jrandom
     // ...and this is the second log message...
     //
     // Revision 1.14  1999/07/26 07:03:20  jrandom
     // this is the first log message...
     //

y así sucesivamente:

     // $Log: chapter-6.texi,v $
     // Revision 1.4  2002/12/05 19:10:27  jfs
     // Ahora el documento compila incluyendo los acentos en castellano, he seguido
     // los consejos de
     // http://www.geocities.com/sl_edu_colombia/soluciones/vladimir/linux_esp.html
     // Sin embargo sería conveniente revisar por qué los nombres de nodo que se
     // referencian no pueden estar con ISO-latin1... ¿problema de TexInfo?
     //
     // Revision 1.3  2002/12/03 13:04:59  carlosgarcia
     // Traduccion de main, introduction e index
     //
     // Revision 1.2  2002/11/27 16:26:56  carlosgarcia
     // Realizados arreglos para compilación
     //
     // Revision 1.1  2000/09/16 12:07:53  jjamor
     // Traduccion del capitulo 6 insertada en la B.de trabajo
     //
     // Revision 1.16  1999/07/26 07:05:34  jrandom
     // ...and this is the third!
     //
     // Revision 1.15  1999/07/26 07:04:40  jrandom
     // ...and this is the second log message...
     //
     // Revision 1.14  1999/07/26 07:03:20  jrandom
     // this is the first log message...
     //

Podría no querer mantener el historial completo en el fichero todo el
tiempo; si es así siempre puede quitar las antiguas secciones cuando
sea muy grande. Es más conveniente que tener que ejecutar `cvs log', y
podría ser útil en proyectos donde la gente debe leer constantemente
los mensajes logs.

Una técnica más común puede ser incluir $Revision: 1.4 $ en un fichero y
usarlo como número de versión para el programa. Esto puede funcionar si
el proyecto consiste de un fichero o se llevan a cabo muchas entregas
finales (releases) y al menos se garantize que uno de los ficheros se
ha modificado entre cada entrega. Incluso se pueden usar estas palabras
de expansión como un valor en el código de un programa:

     VERSION = "$Revision: 1.4 $";

CVS sustituye esa palabra como cualquier otra; no tiene en cuenta la
semántica del lenguaje de programación ni asume que las dobles comillas
protegen la cadena de algún modo.

Una lista completa de palabras de sustitución (hay algunas más poco
usuales) se encuentra en *Note Referencia de CVS::


File: cvsbook.info,  Node: Salir del limbo (Cómo trabajar con derivaciones y sobrevivir),  Next: Vigilando fuentes de terceras partes (Derivaciones comerciales),  Prev: Usando expansión de palabras,  Up: CVS avanzado

Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)
=============================================================

Las derivaciones o ramificaciones son una de las más importantes y más
fácilmente mal usadas características del CVS. Aislar los cambios
arriesgados o perturbadores en una línea de desarrollo separada hasta
que se haya estabilizado puede ser inmensamente beneficioso. Sin
embargo, si no se usa apropiadamente puede llevar un proyecto a la
confusión y al caos, cuando la gente no pierde la cuento sobre qué
cambios se han fusionado y cuando se realizaron.

* Menu:

* Algunos principios para trabajar con derivaciones::
* Fusionar repetidamente con la rama principal::
* La Aproximación de la Cola de Milano -- Fusionar dentro y fuera de la rama principal::
* La Aproximación del Pez Volador -- Una forma más simple de hacerlo::
* Derivaciones y expansión de palabras -- Enemigos naturales::


File: cvsbook.info,  Node: Algunos principios para trabajar con derivaciones,  Next: Fusionar repetidamente con la rama principal,  Up: Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)

Algunos principios para trabajar con derivaciones
-------------------------------------------------

Para trabajar exitosamente con derivaciones, su grupo de desarrollo
debería seguir estos principios:

   * Minimizar el número de derivaciones activas cada vez. Cuantas más
     derivaciones se esten desarrrollando al mismo tiempo habrá más
     posibilidad de que existan conflictos cuando se fusionen con la
     rama principal. En términos prácticos, la forma de conseguir esto
     es fusionar tan frecuentemente como pueda (cada vez que una
     derivación está en un punto estable) y volver al desarrollo de la
     rama principal cuando esto sea viable. Minimizando la cantidad de
     desarrollo en paralelo es posible estar al tanto de lo que pasa en
     cada rama y la posibilidad de conflictos se reduce.

     Esto no significa minimizar el número absoluto de derivaciones de
     un proyecto sino el número de ellos en las que se trabajo en un
     momentod dado.

   * Minimizar la complejidad - es decir la profundidad - del esquema
     de sus derivaciones. Hay circunstancias en que es apropiado tener
     derivaciones de derivaciones pero son muy raras (usted podría no
     encontrar una situación como ésta durante toda su vida como
     programador).  El que CVS permita técnicamente que se puedan tener
     distintos niveles de derivaciones anidadas, y que se pueda
     fusionar unas con otras, no quiere decir que usted quiera hacerlo.
     En la mayoría de las situaciones lo mejor es tener las
     derivaciones sobre la rama principal y fusionar de la derivación
     al tronco y vuelta a empezar.

   * Use consistentemente etiquetas para marcar todas los eventos de
     fusión y ramificación. Idealmente el significado de cada etiqueta
     y su relación con otras ramificaciones y etiquetas debería quedar
     claro por su nombre.  (Esto quedará más claro cuando veamos los
     ejemllos.)

Con estos principios en la cabeza veamos un típico escenario de
desarrollo con una ramificación. Tendremos jrandom en la rama principal
y qsmith en la derivación. Pero tenga en cuento que podría haber
múltiples desarrolladores en ambos sitios. El desarrollo normal en cada
línea puede involucrar cualquier número de personas; sin embargo el
etiquetado y fusión es mejor hacerlos por una persano en cada lado como
verá.


File: cvsbook.info,  Node: Fusionar repetidamente con la rama principal,  Next: La Aproximación de la Cola de Milano -- Fusionar dentro y fuera de la rama principal,  Prev: Algunos principios para trabajar con derivaciones,  Up: Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)

Fusionar repetidamente con la rama principal
--------------------------------------------

Supongamos que qsmith necesita hacer desarrollo en una derivación para
no desestabilizar la rama principal que comparte con jrandom. El primer
paso es crear una rama nueva. Observe como primero qsmith crea una
etiqueta normal (no-rama) en ese punto de la rama principal y después
crea la derivación:

     paste$ pwd
     /home/qsmith/myproj
     paste$ cvs tag Root-of-Exotic_Greetings
     cvs tag: Tagging .
     T README.txt
     T foo.gif
     T hello.c
     cvs tag: Tagging a-subdir
     T a-subdir/whatever.c
     cvs tag: Tagging a-subdir/subsubdir
     T a-subdir/subsubdir/fish.c
     cvs tag: Tagging b-subdir
     T b-subdir/random.c
     paste$ cvs tag -b Exotic_Greetings-branch
     cvs tag: Tagging .
     T README.txt
     T foo.gif
     T hello.c
     cvs tag: Tagging a-subdir
     T a-subdir/whatever.c
     cvs tag: Tagging a-subdir/subsubdir
     T a-subdir/subsubdir/fish.c
     cvs tag: Tagging b-subdir
     T b-subdir/random.c
     paste$

Etiquetar primero la rama principal podría servir para obtener algún
día la rama principal en el momento de que la derivación fue creada.
Si tuviese que hacer eso debería haber un modo de referirse a esa
instantánea de la rama principal sin referirse a la derivación. No
puede usar la etiqueta de la derivación ya que lo que obtendría es esa
derivación no las revisiones que forman la raiz del tronco. El único
modo de hacer esto sería hacer una etiqueta de las revisiones de las
que sale la derivación. (Alguna gente que esta regla tan fielmente que
consideré listarla como "principio número 4 de ramificación: Crear
siempre una etiqueta no-derivación en la posición de la derivación."
Sin embargo en algunos sitios no se usa y parece que lo hacen bien por
lo que es una cuestión de gusto.)  De ahora en adelante me referiré a
esta etiqueta no-derivación como "etiqueta del punto de derivación".

Observe que me he adherido a una convención de nombres: La etiqueta del
punto de derivación empieza con `Root-of-' (Raiz-de-), y después el
nombre, que usará subrayado en vez de guión para separar las palabras.
Cuando la derivación es creada su etiqueta acabará con el sufijo
`-branch' (rama) que le indicará con sólo mirar el nombre que es una
derivación. (La etiqueta del punto de derivación
`Root-of-Exotic_Greetings' no incluye el sufijo `-branch' porque no es
una derivación.) No tiene que usar esta convención en particular pero
desde luego es aconsejable usar alguna.

Por supuesto, he sido extra pedante. En pequeños proyectos donde cada
uno sabe quién está haciendo qué y se pueden arreglar fácilmente las
confusiones estas convenciones no tienen que ser usadas. El que use la
etiqueta del punto de derivación o una estricta convención de nombres
para sus etiquetas dependerá de la complejidad del proyecto y su esquema
de derivaciones. (No olvide que siempre puede volver atrás más tarde
para actualizar viejas etiquetas y usar una nueva convención; obtenga
la versión de la vieja etiqueta, añada la nueva etiqueta y borre después
la antigua.)

Ahora qsmith puede empezar a trabajar con la derivación:

     paste$ cvs update -r Exotic_Greetings-branch
     cvs update: Updating .
     cvs update: Updating a-subdir
     cvs update: Updating a-subdir/subsubdir
     cvs update: Updating b-subdir
     paste$

Hace algunos cambios a un par de ficheros y los entrega en la
derivación:

     paste$ emacs README.txt a-subdir/whatever.c b-subdir/random.c
     ...
     paste$ cvs ci -m "print greeting backwards, etc"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in README.txt;
     /usr/local/newrepos/myproj/README.txt,v  <--  README.txt
     new revision: 1.14.2.1; previous revision: 1.14
     done
     Checking in a-subdir/whatever.c;
     /usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c
     new revision: 1.3.2.1; previous revision: 1.3
     done
     Checking in b-subdir/random.c;
     /usr/local/newrepos/myproj/b-subdir/random.c,v  <--  random.c
     new revision: 1.1.1.1.2.1; previous revision: 1.1.1.1
     done
     paste$

Mientras tanto jrandom sigue trabajando en el tronco. Ella modifica dos
o tres ficheros que qsmith tocó. Para ponerlo más dificil haremos sus
cambios creen conflictos con el trabajo de qsmith:

     floss$ emacs README.txt whatever.c
      ...
     floss$ cvs ci -m "some very stable changes indeed"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in README.txt;
     /usr/local/newrepos/myproj/README.txt,v  <--  README.txt
     new revision: 1.15; previous revision: 1.14
     done
     Checking in a-subdir/whatever.c;
     /usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c
     new revision: 1.4; previous revision: 1.3
     done
     floss$

El conflicto no es aparente todavía ya que ninguno de los
desarrolladores ha intentado hacer la fusión de la derivación con el
tronco. Ahora jrandom hace la fusión:

     floss$ cvs update -j Exotic_Greetings-branch
     cvs update: Updating .
     RCS file: /usr/local/newrepos/myproj/README.txt,v
     retrieving revision 1.14
     retrieving revision 1.14.2.1
     Merging differences between 1.14 and 1.14.2.1 into README.txt
     rcsmerge: warning: conflicts during merge
     cvs update: Updating a-subdir
     RCS file: /usr/local/newrepos/myproj/a-subdir/whatever.c,v
     retrieving revision 1.3
     retrieving revision 1.3.2.1
     Merging differences between 1.3 and 1.3.2.1 into whatever.c
     rcsmerge: warning: conflicts during merge
     cvs update: Updating a-subdir/subsubdir
     cvs update: Updating b-subdir
     RCS file: /usr/local/newrepos/myproj/b-subdir/random.c,v
     retrieving revision 1.1.1.1
     retrieving revision 1.1.1.1.2.1
     Merging differences between 1.1.1.1 and 1.1.1.1.2.1 into random.c
     floss$ cvs update
     cvs update: Updating .
     C README.txt
     cvs update: Updating a-subdir
     C a-subdir/whatever.c
     cvs update: Updating a-subdir/subsubdir
     cvs update: Updating b-subdir
     M b-subdir/random.c
     floss$

Dos de los ficheros tienen conflictos. No importa, con su saber hacer
jarandom resuelve los conflictos, entrega y etiqueta el tronco
indicando una fusión con éxito.

     floss$ emacs README.txt a-subdir/whatever.c
      ...
     floss$ cvs ci -m "merged from Exotic_Greetings-branch (conflicts resolved)"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in README.txt;
     /usr/local/newrepos/myproj/README.txt,v  <--  README.txt
     new revision: 1.16; previous revision: 1.15
     done
     Checking in a-subdir/whatever.c;
     /usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c
     new revision: 1.5; previous revision: 1.4
     done
     Checking in b-subdir/random.c;
     /usr/local/newrepos/myproj/b-subdir/random.c,v  <--  random.c
     new revision: 1.2; previous revision: 1.1
     done
     floss$ cvs tag merged-Exotic_Greetings
     cvs tag: Tagging .
     T README.txt
     T foo.gif
     T hello.c
     cvs tag: Tagging a-subdir
     T a-subdir/whatever.c
     cvs tag: Tagging a-subdir/subsubdir
     T a-subdir/subsubdir/fish.c
     cvs tag: Tagging b-subdir
     T b-subdir/random.c
     floss$

Mientras, qsmith no necesita esperar que termine la fusión para
continuar el desarrollo si hace una etiqueta del conjunto de cambios
que jrandom fusionó (más tarde, jrandom necesitará saber el nombre de
esta etiqueta; en general las derivaciones dependen de una frecuente y
completa comunicación entre los desarrolladores):

     paste$ cvs tag Exotic_Greetings-1
     cvs tag: Tagging .
     T README.txt
     T foo.gif
     T hello.c
     cvs tag: Tagging a-subdir
     T a-subdir/whatever.c
     cvs tag: Tagging a-subdir/subsubdir
     T a-subdir/subsubdir/fish.c
     cvs tag: Tagging b-subdir
     T b-subdir/random.c
     paste$ emacs a-subdir/whatever.c
      ...
     paste$ cvs ci -m "print a randomly capitalized greeting"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in a-subdir/whatever.c;
     /usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c
     new revision: 1.3.2.2; previous revision: 1.3.2.1
     done
     paste$

Y por supuesto cuando qsmith haya hecho sus cambios tendrá que
etiquetar:

     paste$ cvs -q tag Exotic_Greetings-2
     T README.txt
     T foo.gif
     T hello.c
     T a-subdir/whatever.c
     T a-subdir/subsubdir/fish.c
     T b-subdir/random.c
     paste$

Mientras todo esto sucede jrandom hace un cambio en un fichero
distinto, uno que qsmith no ha tocado en sus ediciones:

     floss$ emacs README.txt
      ...
     floss$ cvs ci -m "Mention new Exotic Greeting features" README.txt
     Checking in README.txt;
     /usr/local/newrepos/myproj/README.txt,v  <--  README.txt
     new revision: 1.17; previous revision: 1.16
     done
     floss$

En este momento qsmith ha entregado un nuevo cambio en su derivación y
jrandom ha entregado otro cambio no conflictivo en un fichero distinto
del tronco. Observe que sucede cuando jrandom trata de fusionar desde
la derivación de nuevo:

     floss$ cvs -q update -j Exotic_Greetings-branch
     RCS file: /usr/local/newrepos/myproj/README.txt,v
     retrieving revision 1.14
     retrieving revision 1.14.2.1
     Merging differences between 1.14 and 1.14.2.1 into README.txt
     rcsmerge: warning: conflicts during merge
     RCS file: /usr/local/newrepos/myproj/a-subdir/whatever.c,v
     retrieving revision 1.3
     retrieving revision 1.3.2.2
     Merging differences between 1.3 and 1.3.2.2 into whatever.c
     rcsmerge: warning: conflicts during merge
     RCS file: /usr/local/newrepos/myproj/b-subdir/random.c,v
     retrieving revision 1.1
     retrieving revision 1.1.1.1.2.1
     Merging differences between 1.1 and 1.1.1.1.2.1 into random.c
     floss$ cvs -q update
     C README.txt
     C a-subdir/whatever.c
     floss$

¡Hay conflictos! ¿Esperaba esto?

El problema radica en el significado de fusionar. En *Note Una
introduccion a CVS:: expliqué que cuando usted ejecuta

     floss$ cvs update -j BRANCH

en una copia de trabajo, CVS fusiona en la copia de trabajo las
diferencias entre la raiz BRANCH y su estado actual. El problema con
este comportamiento es que, en esta situación, la mayoría de esos
cambios ya habían sido incorporados al tronco la primera vez que jrandom
hizo una fusión. Cuando CVS intentó fusionarlos de nuevo (sobre ellos
mismos que es como estaban) se produce naturalmente un conflicto.

Lo que jrandom realmente quería hacer era fusionar en su copia de
trabajo los cambios entre la más reciente fusión del tronco con su
estado actual.  Usted puede hacer esto usando dos -j indicadores para
actualizar, como debería recordar en *Note Una introduccion a CVS::,
siempre que sepa que revisión corresponde con cada indicador.
Afortunadamente qsmith hizó una etiqueta exactamente en el último punto
de fusión (¡hurra por planificar con antelación!), por lo que esto no
será problema. Primero veamos como jrandom puede devolver su copia de
trabajo un estado limpio, desde el que puede rehacer la fusión:

     floss$ rm README.txt a-subdir/whatever.c
     floss$ cvs -q update
     cvs update: warning: README.txt was lost
     U README.txt
     cvs update: warning: a-subdir/whatever.c was lost
     U a-subdir/whatever.c
     floss$

Ahora ella puede hacer la fusión, usando la etiqueta colocada
convenientemente por qsmith.

     floss$ cvs -q update -j Exotic_Greetings-1 -j Exotic_Greetings-branch
     RCS file: /usr/local/newrepos/myproj/a-subdir/whatever.c,v
     retrieving revision 1.3.2.1
     retrieving revision 1.3.2.2
     Merging differences between 1.3.2.1 and 1.3.2.2 into whatever.c
     floss$ cvs -q update
     M a-subdir/whatever.c
     floss$

Mucho mejor. Los cambios de qsmith han sido incorporados a whatever.c;
jrandom puede hacer una entrega y etiquetado:

     floss$ cvs -q ci -m "merged again from Exotic_Greetings (1)"
     Checking in a-subdir/whatever.c;
     /usr/local/newrepos/myproj/a-subdir/whatever.c,v  <--  whatever.c
     new revision: 1.6; previous revision: 1.5
     done
     floss$ cvs -q tag merged-Exotic_Greetings-1
     T README.txt
     T foo.gif
     T hello.c
     T a-subdir/whatever.c
     T a-subdir/subsubdir/fish.c
     T b-subdir/random.c
     floss$

Incluso si qsmith hubiese olvidado etiquetar en el punto de fusión, las
esperanzas no estaría perdidas. Si jrandom supiese aproximadamente
cuando hizo qsmith su primera entrega ella podría tratar de filtrar por
la fecha:

     floss$ cvs update -j Exotic_Greetings-branch:3pm -j Exotic_Greetings_branch

Aunque útil como último recurso, filtrar por fecha no es tan bueno
porque selecciona los cambios basandose en los recuerdos de la gnete en
vez de en designaciones que dependan del desarrollador. Si el primer
conjunto de cambios fusionados de qsmith hubiera ocurrido en varias
entregas en vez de sólo una jrandom pudiera equivocadamente elegir una
fecha u hora que tomara algunos de los cambios, pero no todos.

No es necesario que cada punto etiquetado en los cambios de qsmith sea
enviado al repositorio un una simple entrega. Ocurrió así casualmente
en el ejemplo. En la vida real, qsmith pudo haber hecho varias entregas
entre cada etiquetado. Él puede trabajar de forma aislada en su
derivación tanto como quiera. La razón de las etiquetas es registar
sucesivos puntos en la derivación donde considere que los cambios deban
ser fusionados con la rama principal. Siempre que jrandom fusione
usando dos indicadores -j y sea cuidadoso al usar las etiquetas de
ramificación de qsmith en el orden apropiado y una sóla vez por cada un
la rama principal padecer el problema de la doble fusión.

Podrían ocurrir conflictos, pero éstos serían de la inevitable clase que
requiere resolución humana; situaciones en las que tanto el tronco como
la derivación realizan cambios en la misma área de código.


File: cvsbook.info,  Node: La Aproximación de la Cola de Milano -- Fusionar dentro y fuera de la rama principal,  Next: La Aproximación del Pez Volador -- Una forma más simple de hacerlo,  Prev: Fusionar repetidamente con la rama principal,  Up: Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)

La Aproximación de la Cola de Milano - Fusionar dentro y fuera de la rama principal
-----------------------------------------------------------------------------------

Fusionar repetidamente de derivación a tronco es bueno para la gente del
tronco ya que ven todos sus cambios y los de la derivación. Sin embargo
el desarrollador de la derivación no obtiene nunca los cambios
producidos en el tronco.

Para permitir esto el desarrollador de la derivación debe realizar un
paso extra cuando tenga ganas de hacer una fusión de los cambios más
recientes del tronco y resolver los inevitables conflictos que surgan:

     paste$ cvs update -j CABEZA

La etiqueta especial reservada `CABEZA' señala el estado actual del
tronco. La orden anterior fusiona en el tronco los cambios entre la raiz
de la actual derivación (`Exotic_Greetings-branch') y la revisión más
alta de cada fichero del tronco. Por supuesto qsmith tiene que
etiquetar de nuevo después de hacer esto para que los desarrolladores
del tronco eviten accidentalmente fusionar sus propios cambios cuando
intenten conseguir los de qsmith.

De la misma manera el desarrollador de la derivación puede usar las
etiquetas de fusión del tronco como límites, permitinedo a la derivación
fusionar exactamente aquellos cambios entre la última fusión y el estado
actual del tronco (de la misma manera que el tronco fusiona). Por
ejemplo, supongamos que jrandom ha hecho algunos cambios a hello.c
después de fusionar la derivación:

     floss$ emacs hello.c
      ...
     floss$ cvs ci -m "clarify algorithm" hello.c
     Checking in hello.c;
     /usr/local/newrepos/myproj/hello.c,v  <--  hello.c
     new revision: 1.22; previous revision: 1.21
     done
     floss$

Después puede qsmith fusionar esos cambios en el tronco, entregar, y,
por supuesto, etiquetar.

     paste$ cvs -q update -j merged-Exotic_Greetings-1 -j HEAD
     RCS file: /usr/local/newrepos/myproj/hello.c,v
     retrieving revision 1.21
     retrieving revision 1.22
     Merging differences between 1.21 and 1.22 into hello.c
     paste$ cvs -q update
     M hello.c
     paste$ cvs -q ci -m "merged trunk, from merged-Exotic_Greetings-1 to HEAD"
     Checking in hello.c;
     /usr/local/newrepos/myproj/hello.c,v  <--  hello.c
     new revision: 1.21.2.1; previous revision: 1.21
     done
     paste$ cvs -q tag merged-merged-Exotic_Greetings-1
     T README.txt
     T foo.gif
     T hello.c
     T a-subdir/whatever.c
     T a-subdir/subsubdir/fish.c
     T b-subdir/random.c
     paste$

Observe que a jrandom no etiquetó después de entregar los cambios a
hello.c pero si qsmith. El principio utilizado aquí es que aunque usted
no necesita etiquetar después de hacer cualquier pequeno cambio si
debería hacerlo después de fusionar o entregar su línea de desarrollo a
un estado que permita la fusión. De este modo otras personas, quizá en
otras derivaciones tienen un punto de referencia en el cual basarse para
sus propias fusiones.


File: cvsbook.info,  Node: La Aproximación del Pez Volador -- Una forma más simple de hacerlo,  Next: Derivaciones y expansión de palabras -- Enemigos naturales,  Prev: La Aproximación de la Cola de Milano -- Fusionar dentro y fuera de la rama principal,  Up: Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)

La Aproximación del Pez Volador - Una forma más simple de hacerlo
-----------------------------------------------------------------

Hay una variante más simple, aunque un poco más limitada, que la
anterior.  En ella, los desarrolladores de la derivación se congelan o
paran mientras el tronco se fusiona, y después los desarrolladores del
tronco crean una nueva derivación, que reemplaza la anterior. Los
desarrolladores de la antigua derivación cambian a esa nueva derivación
y siguen trabajando.  Este ciclo sigue hasta uqe no hay más necesidad
de desarrollo en la derivación. Funciona así (supondremos que
jrandom@floss está en el tronco y qsmith@paste esté en la derivación
como hasta ahora):

     floss$ cvs tag -b BRANCH-1
     paste$ cvs checkout -r BRANCH-1 myproj

Tronco y derivación empiezan a funcionar y pasado un tiempo los
desarrolladores deciden que tienen que fusionar la derivación en el
tronco:

     paste$ cvs ci -m "committing all uncommitted changes"
     floss$ cvs update -j BRANCH-1

Todos los cambios de la rama se fusionan y los desarrolladores paran su
trabajo mientras que los desarrolladores del tronco resuelven cualquier
conflicto, entregan, etiquetan y crean una nueva derivación:

     floss$ cvs ci -m "merged from BRANCH-1"
     floss$ cvs tag merged-from-BRANCH-1
     floss$ cvs tag -b BRANCH-2

Ahora los desarrolladores de la derivación cambian sus copias de trabajo
a la nueva derivación sabiendo que no perderán ningún cambio no
entregado ya que estaban actualizados cuando la fusión ocurrió ya la
nueva derivación viene de un tronco que incorpora los cambios de la
nueva derivación:

     paste$ cvs update -r BRANCH-2

Y el ciclo continúa del mismo modo indefinidamente; sustituya BRANCH-2
por BRANCH-1 y BRANCH-3 por BRANCH-2.

Llamo a esta técnica "Pez Volador" porque la derivación está
constantemente emergiendo del tronco, viajando una corta distancia y
uniéndose a él después. Las ventajas de esta aproximación son que es
simple (el tronco siempre fusiona todos los cambios para una derivación
dada) y los desarrolladores no tinene que resolver conflictos (cada vez
trabajan con una nueva y limpia derivación). Las desventajas son que la
gente de la derivación debe esperar sin poder hacer nada hasta que se
haya fusionado el tronco (que puede durar un tiempo arbitrario
dependiendo de cómo haya que resolver los conflictos).  Otra pequeña
desventaja es habrá muchas derivaciones sin usar en vez de etiquetas
no_derivación. Si no le importa tener millones de pequeñas y obsoletas
derivaciones y puede anticipar claramente fusiones libres de problemas
el Pez Volador pueda ser el modo más fácil en términos mentales.


File: cvsbook.info,  Node: Derivaciones y expansión de palabras -- Enemigos naturales,  Prev: La Aproximación del Pez Volador -- Una forma más simple de hacerlo,  Up: Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)

Derivaciones y expansión de palabras - Enemigos naturales
---------------------------------------------------------

Si sus ficheros contienen palabras de expansión en RCS que se
sustituyen de forma distinta en la derivación y en el tronco casi
seguro que tendrá conflictos en las fusiones. Incluso si nada cambia
las palabras de expansión se sobrepondrán y sus sustituciones no se
podrán hacer. Por ejemplo; if README.txt contiene esto en el tronco

     $Revision: 1.4 $

y esto en la derivación

     $Revision: 1.4 $

entonces cuando sea realizada la fusión obtendrá el siguiente conflicto:

     floss$ cvs update -j Exotic_Greetings-branch
     RCS file: /usr/local/newrepos/myproj/README.txt,v
     retrieving revision 1.14
     retrieving revision 1.14.2.1
     Merging differences between 1.14 and 1.14.2.1 into README.txt
     rcsmerge: warning: conflicts during merge
     floss$ cat README.txt
      ...
     <<<<<<< README.txt
     key $Revision: 1.4 $
     =======
     key $Revision: 1.4 $
     >>>>>>> 1.14.2.1
      ...
     floss$

Para evitar esto, usted puede temporalmente desabilitar la expansión de
palabras pasando la opción -kk (No sé que significa; ¿"kill keywords"
(mata palabras) quizá?) cuando haga la fusión:

     floss$ cvs update -kk -j Exotic_Greetings-branch
     RCS file: /usr/local/newrepos/myproj/README.txt,v
     retrieving revision 1.14
     retrieving revision 1.14.2.1
     Merging differences between 1.14 and 1.14.2.1 into README.txt
     floss$ cat README.txt
      ...
     $Revision: 1.4 $
      ...
     floss$

Tiene que tener cuidado con una cosa; si usa -kk, invalida cualquier
otro modo de expansión de palabras que pueda haber establecido para ese
fichero. Específicamente esto es un problema para los ficheros binarios
que normalmente usan -kb (que suprime todas las palabras de expansión y
conversiones de fin de línea). Por lo tanto si tiene ficheros binarios
en una derivación no use -kk. Trate los conflictos manualmente.


File: cvsbook.info,  Node: Vigilando fuentes de terceras partes (Derivaciones comerciales),  Next: Exportar para distribución pública,  Prev: Salir del limbo (Cómo trabajar con derivaciones y sobrevivir),  Up: CVS avanzado

Vigilando fuentes de terceras partes (Derivaciones comerciales)
===============================================================

De vez en cuando un sitio pudiera hacer un cambio local al código de un
programa obtenido del exterior. Si la fuente exterior no incorpora los
cambios locales (y habría muchas razones legítimas para no hacerlo), el
sitio tiene que mantener sus cambios en cada actualización del software.

CVS puede ayudar en esta tarea a través de una característica conocida
como "derivaciones comerciales". De hecho, derivaciones comerciales
está detrás de los ahora misteriosos dos finales argumentos de la orden
`cvs import'; la etiqueta comercial y la de entrega final que vimos en
*Note Una introduccion a CVS::.

He aquí como funciona. La importación inicial is como cualquier otra
importación de un proyecto en CVS (excepto que tendrá que elegir la
etiqueta comercial con un poco de cuidado):

     floss$ pwd
     /home/jrandom/theirproj-1.0
     floss$ cvs import -m "Import of TheirProj 1.0" theirproj Them THEIRPROJ_1_0
     N theirproj/INSTALL
     N theirproj/README
     N theirproj/src/main.c
     N theirproj/src/parse.c
     N theirproj/src/digest.c
     N theirproj/doc/random.c
     N theirproj/doc/manual.txt
     
     No conflicts created by this import
     
     floss$

Después debe obtener una copia de trabajo, hacer sus modificaciones
locales y entregar:

     floss$ cvs -q co theirproj
     U theirproj/INSTALL
     U theirproj/README
     U theirproj/doc/manual.txt
     U theirproj/doc/random.c
     U theirproj/src/digest.c
     U theirproj/src/main.c
     U theirproj/src/parse.c
     floss$ cd theirproj
     floss$ emacs src/main.c src/digest.c
      ...
     floss$ cvs -q update
     M src/digest.c
     M src/main.c
     floss$ cvs -q ci -m "changed digestion algorithm; added comment to main"
     Checking in src/digest.c;
     /usr/local/newrepos/theirproj/src/digest.c,v  <--  digest.c
     new revision: 1.2; previous revision: 1.1
     done
     Checking in src/main.c;
     /usr/local/newrepos/theirproj/src/main.c,v  <--  main.c
     new revision: 1.2; previous revision: 1.1
     done
     floss$

Un año más tarde la siguiente versión del programa llega de Ellos, S.A.,
y ustede debe incorporar sus cambios locales a ella. Los cambios de
ellos y los suyos se sobreponen ligeramente. Ellos han añadido un nuevo
fichero, modificado un par de ficheros que usted no tocó y otros dos
que usted si modificó.

Primero tiene que hacer otra importación para obtener las nuevas
fuentes.  Casi todo estaba como en la importación inicial; usted está
importando el mismo proyecto del repositorio y de la misma derivación
comercial. La única diferencia es en la etiqueta de entrega final:

     floss$ pwd
     /home/jrandom/theirproj-2.0
     floss$ cvs -q import -m "Import of TheirProj 2.0" theirproj Them THEIRPROJ_2_0
     U theirproj/INSTALL
     N theirproj/TODO
     U theirproj/README
     cvs import: Importing /usr/local/newrepos/theirproj/src
     C theirproj/src/main.c
     U theirproj/src/parse.c
     C theirproj/src/digest.c
     cvs import: Importing /usr/local/newrepos/theirproj/doc
     U theirproj/doc/random.c
     U theirproj/doc/manual.txt
     
     2 conflicts created by this import.
     Use the following command to help the merge:
     
            cvs checkout -jThem:yesterday -jThem theirproj
     
     floss$

Dios mío; No hemos visto que CVS sea tan útil. Nos está diciendo que
orden ejecutar para fusionar los cambios. Y casi está bien. En realidad
el comando funciona (asumiendo que sustituye `yesterday' (ayer) por un
intervalo de tiempo que incluya la primera primera importación pero no
la segunda). Yo prefiero hacerlo mediante etiquetas de entrega final:

     floss$ cvs checkout -j THEIRPROJ_1_0 -j THEIRPROJ_2_0 theirproj
     cvs checkout: Updating theirproj
     U theirproj/INSTALL
     U theirproj/README
     U theirproj/TODO
     cvs checkout: Updating theirproj/doc
     U theirproj/doc/manual.txt
     U theirproj/doc/random.c
     cvs checkout: Updating theirproj/src
     U theirproj/src/digest.c
     RCS file: /usr/local/newrepos/theirproj/src/digest.c,v
     retrieving revision 1.1.1.1
     retrieving revision 1.1.1.2
     Merging differences between 1.1.1.1 and 1.1.1.2 into digest.c
     rcsmerge: warning: conflicts during merge
     U theirproj/src/main.c
     RCS file: /usr/local/newrepos/theirproj/src/main.c,v
     retrieving revision 1.1.1.1
     retrieving revision 1.1.1.2
     Merging differences between 1.1.1.1 and 1.1.1.2 into main.c
     U theirproj/src/parse.c
     floss$

Observe como la importación nos indica que hay dos conflictos pero la
fusión parece ver sólo uno. Esto es porque la idea de conflicto en CVS
es un poco diferente que en las otras ocasiones. Básicamente la
importación informa de conflictos cuando usted y el distribuidor
modifican un fichero entre la última importación y esta. Sin embargo,
cuando se fusiona o actualiza la definición de conflicto es la usual,
cambios que se sobreponen. Cambios que no se sobreponen son fusionados
de la forma normal y el fichero se marca como modificado.

Un `diff' verifica que sólo uno de los ficheros tiene conflictos:

     floss$ cvs -q update
     C src/digest.c
     M src/main.c
     floss$ cvs diff -c
     Index: src/digest.c
     ===================================================================
     RCS file: /usr/local/newrepos/theirproj/src/digest.c,v
     retrieving revision 1.2
     diff -c -r1.2 digest.c
     *** src/digest.c        1999/07/26 08:02:18     1.2
     -- src/digest.c        1999/07/26 08:16:15
     ***************
     *** 3,7 ****
     -- 3,11 ----
      void
      digest ()
      {
     + <<<<<<< digest.c
        printf ("gurgle, slorp\n");
     + =======
     +   printf ("mild gurgle\n");
     + >>>>>>> 1.1.1.2
      }
     Index: src/main.c
     ===================================================================
     RCS file: /usr/local/newrepos/theirproj/src/main.c,v
     retrieving revision 1.2
     diff -c -r1.2 main.c
     *** src/main.c  1999/07/26 08:02:18     1.2
     -- src/main.c  1999/07/26 08:16:15
     ***************
     *** 7,9 ****
     -- 7,11 ----
      {
        printf ("Goodbye, world!\n");
      }
     +
     + /* I, the vendor, added this comment for no good reason. */
     floss$

A partir de aquí deberá resolver los conflictos como cualquier otra
fusión:

     floss$ emacs  src/digest.c  src/main.c
      ...
     floss$ cvs -q update
     M src/digest.c
     M src/main.c
     floss$ cvs diff src/digest.c
     cvs diff src/digest.c
     Index: src/digest.c
     ===================================================================
     RCS file: /usr/local/newrepos/theirproj/src/digest.c,v
     retrieving revision 1.2
     diff -r1.2 digest.c
     6c6
     <   printf ("gurgle, slorp\n");
     --
     >   printf ("mild gurgle, slorp\n");
     floss$

Entones entregue los cambios

     floss$ cvs -q ci -m "Resolved conflicts with import of 2.0"
     Checking in src/digest.c;
     /usr/local/newrepos/theirproj/src/digest.c,v  <--  digest.c
     new revision: 1.3; previous revision: 1.2
     done
     Checking in src/main.c;
     /usr/local/newrepos/theirproj/src/main.c,v  <--  main.c
     new revision: 1.3; previous revision: 1.2
     done
     floss$

y espere la próxima versión del distribuidor. (Por supuesto tendrá que
comprobar que sus antiguas modificaciones todavía funcionan).


File: cvsbook.info,  Node: Exportar para distribución pública,  Next: El humilde gurú,  Prev: Vigilando fuentes de terceras partes (Derivaciones comerciales),  Up: CVS avanzado

Exportar para distribución pública
==================================

CVS es un buen mecanismo de distribución para desarrolladores, pero la
mayoría de usuarios obtendrán el software a través de un paquete
descargable. Este paquete normalmente no es una copia de trabajo de CVS;
es un árbol de código que puede ser fácilmente configurado y compilado
en el sistema del usuario.

Sin embargo, CVS ofrece un mecanismo que ayuda a crear ese paquete, la
orden `cvs export' (Exportar). "Exportar" un proyecto es como obtener
una copia de trabajo del proyecto, excepto que se obtiene el directorio
completo del proyecto _sin_ los subdirectorios administrativos. O sea,
que no obtiene una copia de trabajo sino el código fuente completo que
no sabe nado sobre dónde vino o que versiones de CVS tienen sus
ficheros. Así la copia exportada es como lo que el público ve cuando
descarga y desempaqueta un distribución. Asumiendo que el proyecto está
organizado para que sea directamente compilable desde la copia de
trabajo (y así es como debería estar), entonces todavía será compilable
en la copia exportada.

La orden `export' funciona igual que `checkout', excepto que requiere
una etiqueta o fecha. Por ejemplo, aquí hemos etiquetado el proyecto
con un nombre para el lanzamiento final y hemos exportado basándonos en
eso:

     floss$ pwd
     /home/jrandom/myproj
     floss$ cvs -q tag R_1_0
     T README.txt
     T hello.c
     T a-subdir/whatever.c
     T a-subdir/subsubdir/fish.c
     T b-subdir/random.c
     floss$ cd ..
     floss$ cvs -d /usr/local/newrepos -q export -r R_1_0 -d myproj-1.0 myproj
     U myproj-1.0/README.txt
     U myproj-1.0/hello.c
     U myproj-1.0/a-subdir/whatever.c
     U myproj-1.0/a-subdir/subsubdir/fish.c
     U myproj-1.0/b-subdir/random.c
     floss$ cd myproj-1.0
     floss$ ls
     README.txt  a-subdir  b-subdir  hello.c

Observe que como la `export' no es llamada desde una copia de trabajo
ha sido necesario usar la opción global `-d' para decirle a CVS qué
repositorio usar. En este ejemolo en particular, además, exportamos a un
directorio explícitamente nombrado (`myproj-1.0') en vez del directorio
por defecto con el nombre del proyecto (`myproy', porque ya había una
copia con ese nombre presente. Esta situación no es infrecuente.

Después de crear la copia mediante export, como en el ejemplo anterior,
lo que sigue es suficiente para completar la entrega final si el
proyecto es sencillo:

     floss$ tar cf myproj-1.0.tar myproj-1.0
     floss$ gzip --best myproj-1.0.tar
     floss$ ls
     myproj/   myproj-1.0/   myproj-1.0.tar.gz
     floss$ rm -rf myproj-1.0
     floss$ mv myproj-1.0.tar.gz /home/ftp/pub/myproj/

Ejecutar todas estas órdenes a mano es raro. Lo normal es que
`cvs export' sea llamada desde una rutina que maneje todos los aspectos
de la entrega final y el proceso de empaquetado. Debido a que hay
varias entregas de prueba antes del lanzamiento final es deseable que
los procedimientos para crear un paquete se automatizen.


File: cvsbook.info,  Node: El humilde gurú,  Prev: Exportar para distribución pública,  Up: CVS avanzado

El humilde gurú
===============

Si usted ha leido y comprendido e incluso mejor, ha experimentado con
todo lo de este capítulo, puede asegurar que no le quedan muchas más
cosas en CVS por aprender; al menos hasta que alguien añada una nueva e
importante característica a CVS. Todo lo que necesita saber para usar
CVS en un gran proyecto ha sido presentado.

Antes de que esto se le suba a la cabeza permítame insistir en la
sugerencia, hecha ya en el capítulo 4, de que se suscriba a la lista de
correo <info-cvs@gnu.org>. A pesar de una proporción de ruido común a
la mayoría de listas de correo en Internet, lo bueno que le llega
merece la pena esperarlo. He estado suscrito durante el tiempo que
estuve escribiendo este capítulo y estaría sorprendido de la cantidad de
importantes de detalles que aprendí sobre el comportamiento de CVS
leyendo los correos de otras personas. Si va a usar CVS seriamente y
especialmente si usted es un administrador de CVS en un grupo de
desarrolladores se puede beneficiar del conocimiento compartido entre
todos los demás usuarios serios que hay por ahí.

