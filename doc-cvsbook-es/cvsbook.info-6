This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: El directorio administrativo CVSROOT/,  Next: Correos de envío de cambios,  Prev: Qué ocurre cuando elimina un fichero,  Up: Administracion del Repositorio

El directorio administrativo CVSROOT/
=====================================

Los ficheros de nuevorepos/CVSROOT/ no son parte de ningún proyecto,
sino que se usan para controlar el comportamiento de CVS en el
repositorio.  La mejor forma de editar esos ficheros es obtener una
copia de trabajo de CVSROOT con "checkout", igual que para un proyecto
normal:

     floss$ cvs co CVSROOT
     cvs checkout: Updating CVSROOT
     U CVSROOT/checkoutlist
     U CVSROOT/commitinfo
     U CVSROOT/config
     U CVSROOT/cvswrappers
     U CVSROOT/editinfo
     U CVSROOT/loginfo
     U CVSROOT/modules
     U CVSROOT/notify
     U CVSROOT/rcsinfo
     U CVSROOT/taginfo
     U CVSROOT/verifymsg
     floss$

Miraremos los ficheros en order aproximado de importancia.  Fíjese en
que cada uno de los ficheros viene con un comentario explicativo al
comienzo (el convenio para comentarios es el mismo para todos ellos: un
signo `#' al principio de la línea indica un comentario, y CVS ignora
estas líneas cuando procesa los ficheros).  Recuerde que cualquier
cambio que haga a los ficheros de administración de la copia de trabajo
obtenida no afectará al comportamiento de CVS hasta que envíe los
cambios.

Si usted es extremadamente consciente de la seguridad, puede que quiera
configurar los permisos de fichero en CVSROOT para que sean diferentes
de los permisos en cualquier parte del repositorio, para tener bien
controlado quién puede enviar cambios a CVSROOT.  Como verá un poco más
adelante, el ser capaz de modificar los ficheros de CVSROOT básicamente
le da a cualquier usuario CVS - incluso a los remotos - la capacidad de
ejecutar cualquier orden en la máquina del repositorio.

* Menu:

* El Fichero config::
* El Fichero modules::
* Los Ficheros commitinfo y loginfo y rcsinfo::
* Los Ficheros verifymsg y rcsinfo::
* El Fichero taginfo::
* El Fichero cvswrappers::
* El Fichero editinfo::
* El Fichero notify::
* El Fichero checkoutlist::


File: cvsbook.info,  Node: El Fichero config,  Next: El Fichero modules,  Up: El directorio administrativo CVSROOT/

El Fichero config
-----------------

El fichero "config" le permite configurar ciertos parámetros de
comportamiento global.  Sigue un formato muy estricto

     PARÁMETRO=VALOR
     (etc)

sin permitirse espacios adicionales.  Por ejemplo, aquí hay un posible
fichero config:

     SystemAuth=yes
     TopLevelAdmin=no
     PreservePermissions=no

(Una entrada ausente equivaldría a `no'.)

El parámetro `SystemAuth' controla si CVS debería mirar en el fichero
de sistema passwd si falla al encontrar un determinado nombre de
usuario en el fichero CVSROOT/passwd.  Las distribuciones de CVS vienen
con él puesto a `no' para ser conservadoras en cuanto a la seguridad
del sistema.

`TopLevelAdmin' le dice a CVS si hacer un directorio CVS/ hermano
cuando obtiene una copia de trabajo.  Este directorio CVS/ podría no
estar dentro de la copia de trabajo, sino junto a ella.  Sería
conveniente habilitarlo si usted tiende (y los usuarios del repositorio
tienden) a obtener copias de muchos proyectos diferentes en el mismo
repositorio.  De lo contrario debería dejarlo desactivado, ya que puede
ser desconcertante ver que aparece un directorio CVS/ adicional donde
no lo espera.

`PreservePermissions' controla si se conservan los permisos de fichero
y otra metainformación en la historia de revisiones.  Ésta es una
característica algo oscura que seguramente no valga la pena describir
en detalle.  Si está interesado vea el nodo `Special Files' en el
Cederqvist ("nodo" es una palabra de Texinfo para una posición
particular en un documento Info.  Para ir a un nodo mientras se lee
Info, teclee `g' seguido del nombre del nodo, desde cualquier parte del
documento).

`LockDir' también es una característica usada raramente.  En
circunstancias especiales, querrá decirle a CVS que cree sus ficheros de
bloqueo en algún sitio distinto de los subdirectorios del proyecto,
para evitar problemas de permisos.  Estos ficheros de bloqueo impiden
que CVS tropiece consigo mismo al realizar múltiples operaciones en el
mismo directorio del repositorio a la vez.  En general, nunca tendrá
que preocuparse por ello, pero a veces puede que los usuarios tengan
problemas actualizando u obteniendo copias de trabajo desde un
directorio del repositorio porque son incapaces de crear un fichero de
bloqueo (CVS necesita crear un fichero de bloqueo, incluso en
operaciones de sólo lectura, para evitar situaciones en las que podría
acabar leyendo mientras otra invocación de CVS está escribiendo).  El
remedio habitual para esto es cambiar los permisos del repositorio,
pero cuando esto no es factible, el parámetro LockDir puede resultar
práctico.

No hay más parámetros por el momento, pero puede que en versiones
futuras de CVS se añadan otros nuevos; debería comprobar siempre el
Cederqvist o el propio fichero config de la distribución para ver los
cambios.


File: cvsbook.info,  Node: El Fichero modules,  Next: Los Ficheros commitinfo y loginfo y rcsinfo,  Prev: El Fichero config,  Up: El directorio administrativo CVSROOT/

El Fichero modules
------------------

En modules puede definir aliases y grupos alternativos de proyectos en
el repositorio.  La línea de module más básica es de la forma:

     NOMBRE_MÓDULO   DIRECTORIO_EN_REPOSITORIO

por ejemplo,

     mp    miproyecto
     asub  miproyecto/a-subdir

(Las rutas dadas a la derecha son relativas al directorio raíz del
repositorio.)  Esto les da a los desarrolladores un nombre alternativo
con el que obtener una copia de un proyecto o parte de un proyecto:

     floss$ cvs co mp
     cvs checkout: Updating mp
     U mp/README.txt
     U mp/foo.jpg
     U mp/hello.c
     cvs checkout: Updating mp/a-subdir
     U mp/a-subdir/loquesea.c
     cvs checkout: Updating mp/a-subdir/subsubdir
     U mp/a-subdir/subsubdir/fish.c
     cvs checkout: Updating mp/b-subdir
     U mp/b-subdir/random.c

o

     floss$ cvs -d /usr/local/nuevorepos/ co asub
     cvs checkout: Updating asub
     U asub/loquesea.c
     cvs checkout: Updating asub/subsubdir
     U asub/subsubdir/fish.c

Note cómo en ambos casos el nombre del módulo pasó a ser el nombre del
directorio creado para la copia de trabajo.  En el caso de asub, ni
siquiera se preocupó del directorio intermedio miproyecto/, sino que en
lugar de ello creó un asub/ en un nivel superior, aunque venía de
miproyecto/a-subdir en el repositorio.  Las actualizaciones, envíos de
cambios y todos las órdenes CVS funcionarán normalmente en esas copias
de trabajo - lo único raro que tienen son sus nombres.

Poniendo nombres de ficheros después del nombre de directorio podrá
definir un módulo consistente sólo en algunos de los ficheros de un
directorio del repositorio dado. Por ejemplo

     readme  miproyecto  README.txt

y

     no-readme  miproyecto  hello.c  foo.jpg

permitirían las siguientes obtenciones de copia respectivamente:

     floss$ cvs -q co readme
     U readme/README.txt
     floss$ cvs -q co no-readme
     U no-readme/hello.c
     U no-readme/foo.jpg
     floss$

Puede definir un módulo que incluya múltiples directorios de repositorio
usando la opción -a (para `alias'), pero fíjese en que se investigarán
los directorios bajo sus nombres originales.  Por ejemplo, esta línea

     dosproyectos  -a  miproyecto  tuproyecto

le permitiría hacer esto (asumiendo que tanto miproyecto/ como
tuproyecto/ están en el repositorio):

     floss$ cvs co dosproyectos
     U miproyecto/README.txt
     U miproyecto/foo.jpg
     U miproyecto/hello.c
     U miproyecto/a-subdir/loquesea.c
     U miproyecto/a-subdir/subsubdir/fish.c
     U miproyecto/b-subdir/random.c
     U tuproyecto/README
     U tuproyecto/foo.c
     U tuproyecto/un-subdir/fichero1.c
     U tuproyecto/un-subdir/fichero2.c
     U tuproyecto/un-subdir/otro-subdir/bla.c

El nombre `dosproyectos' es un recurso conveniente para meterse en los
dos proyectos, pero no afecta a los nombres de las copias de trabajo.
(Por cierto, no hay necesidad de que los módulos alias se refieran a
múltiples directorios; podríamos haber omitido dosproyectos, en cuyo
caso aún se habría obtenido una copia de miproyecto bajo el nombre
`miproyecto'.)

Los módulos pueden incluso referirse a otros módulos, poniéndoles como
prefijo un signo &:

     mp    miproyecto
     asub  miproyecto/a-subdir
     dosproyectos -a miproyecto tuproyecto
     dp  &dosproyectos

Hacer un checkout de `dp' tendría exactamente el mismo resultado que el
de `dosproyectos'.

Hay algunos otros trucos que puede hacer con módulos, la mayoría de
ellos más infrecuentes que los que se acaban de presentar.  Vea el nodo
modules en el Cederqvist para obtener información sobre ellos.


File: cvsbook.info,  Node: Los Ficheros commitinfo y loginfo y rcsinfo,  Next: Los Ficheros verifymsg y rcsinfo,  Prev: El Fichero modules,  Up: El directorio administrativo CVSROOT/

Los Ficheros commitinfo y loginfo y rcsinfo
-------------------------------------------

La mayoría de los demás ficheros de administración proporcionan "puntos
de comtrol" ("hooks", N. del T.) programáticos en varias partes del
proceso de envío de cambios (por ejemplo, la capacidad de validar
informes de cambios o estados de fichero antes de permitir el envío, o
la capacidad de notificar a un grupo de desarrolladores cada vez que se
haga un envío en cierto directorio del repositorio).

Por lo general, los ficheros comparten una sintaxis común.  Cada línea
es de la forma:

     EXPRESIÓN_REGULAR    PROGRAMA_A_EJECUTAR

La expresión regular se probará con el directorio en el que se está
haciendo el envío (con el nombre de directorio relativo al nivel más
alto del repositorio).  Si coincide se ejecutará el programa designado.
Al programa se le pasarán los nombres de cada uno de los ficheros del
envío; puede hacer lo que le parezca con esos nombres, incluso abrir
los ficheros y examinar sus contenidos.  Si el programa devuelve un
estado de salida distinto de cero, se impide que se haga el envío.

Las ("expresiones regulares" son un sistema para describir de forma
concisa clases de cadenas.  Si no está familiarizado con las
expresiones regulares, puede hacerlo con el siguiente resumen: `foo'
coincidiría con todos los ficheros con nombres conteniendo `foo'; y
`foo.*bar' coincidiría con todos los ficheros con nombres conteniendo
`foo', seguido de cualquier número de caracteres, y seguido por la
cadena `bar'.  Es por ello que las subcadenas normales coinciden
consigo mismas, pero `.' y `*' son especiales.  `.' coincide con
cualquier caracter, y `*' quiere decir "coincide con cualquier número
de veces, incluyendo cero, del caracter precedente".  Los signos `^' y
`$' indican "encuentra al principio y final de la cadena",
respectivamente; por tanto, `^foo.*bar.*baz$' encontraría las cadenas
que comenzaran con `foo', que contuvieran `bar' en medio, y que
acabaran con `baz'.  Esto es todo lo que vamos a profundizar; este
resumen es una pequeña parte muy abreviada de la sintaxis completa de
las expresiones regulares.)

El fichero "commitinfo" está para puntos de control genéricos que quiera
ejecutar en todos los envíos.  Aquí hay algunas líneas commitinfo de
ejemplo:

     ^a-subdir*     /usr/local/bin/comprobar-asubdir.sh
     ou             /usr/local/bin/validar-proyecto.pl

Así que cualquier envío en miproyecto/a-subdir/ coincidiría con la
primera línea, por lo que se ejecutaría el guión comprobar-asubdir.sh.
Un envío en cualquier proyecto cuyo nombre (nombre real de directorio
del repositorio, no necesariamente nombre del módulo) contenga la
cadena `ou' ejecutaría el guión validar-proyecto.pl, a menos que el
envío ya haya coincidido con la línea a-subdir anterior.

En lugar de una expresión regular se puede usar la palabra `DEFAULT' o
`ALL'.  La línea DEFAULT (o la primera línea DEFAULT si hay más de una)
se ejecutará si no coincide ninguna expresión regular, y cada una de
las líneas ALL se ejecutará además de todas las líneas que puedan
coincidir.

Los nombres de ficheros que se pasan al programa no se refieren a
ficheros RCS - hacen referencia a ficheros normales, cuyos contenidos
son exactamente los mismos que los de la copia de trabajo de la que se
están enviando cambios.  El único aspecto inusual es que CVS los tiene
guardados temporalmente dentro del repositorio, así que estarán
disponibles para los programas que se estén ejecutando en la máquina en
la que está el repositorio.

El fichero "loginfo" es similar a commitinfo, excepto en que en lugar
de actuar en los contenidos de los ficheros, actúa en los informes de
cambios.  El lado izquierdo del fichero loginfo contiene expresiones
regulares, quizá incluyendo líneas DEFAULT y ALL.  El programa invocado
a la derecha recibe el informe de cambios en su entrada estándar; puede
hacer lo que quiera con esa entrada.

El programa de la derecha también puede admitir un número arbitrario de
argumentos de línea de órdenes.  Uno de esos argumentos puede ser un
código especial `%', a expandir por CVS en tiempo de ejecución como
sigue:

     %s    ------>      nombre(s) de fichero(s) afectados por el envío de cambios
     %V    ------>      número(s) de revisión antes del envío de cambios
     %v    ------>      número(s) de revisión después del envío de cambios

La expansión empieza siempre con el subdirectorio del repositorio
(relativo al nivel superior del repositorio), seguido de la información
del fichero.  Por ejemplo, si los ficheros afectados por el envío de
cambios fueran foo, bar y baz, todos en `miproyecto/a-subdir', `%s' se
expandiría en:

     miproyecto/a-subdir  foo  bar  baz

mientras que `%V' se expandiría para mostrar los números de revisión
antiguos:

     miproyecto/a-subdir  1.7  1.134  1.12

y `%v' los números de revisión nuevos:

     miproyecto/a-subdir  1.8  1.135  1.13

Puede combinar expresiones con `%' delimitándolas con llaves siguiendo
al signo `%' - esto las expandirá en series de sublistas separadas por
comas, cada una conteniendo la información correspondiente a un fichero
del envío.  Por ejemplo, `%{sv}' se expandiría en

     miproyecto/a-subdir  foo,1.8  bar,1.135  baz,1.13

y `%{sVv}' se expandiría en

     miproyecto/a-subdir  foo,1.7,1.8  bar,1.134,1.135  baz,1.12,1.13

(Puede que tenga que mirar con cuidado para distinguir las comas de los
puntos decimales en estos ejemplos.)

Aquí hay un fichero loginfo de ejemplo:

     ^miproyecto$   /usr/local/nuevorepos/CVSROOT/log.pl \
        -m miproyecto-devel@foobar.com %s
     ou             /usr/local/bin/ou-notify.pl  %{sv}
     DEFAULT        /usr/local/bin/default-notify.pl  %{sVv}

En la primera línea, cualquier envío de cambios en el subdirectorio
miproyecto del repositorio invoca `log.pl', pasándole una dirección de
correo electrónico (a la que `log.pl' enviará un correo con el informe
de cambios), seguido del repositorio, seguido de todos los ficheros del
envío.

En la segunda línea, cualquier envío de cambios en un subdirectorio del
repositorio que contenga la cadena `ou' invocará el guión (imaginario)
`notificar-ou.pl', pasándole el repositorio seguido de los nombres de
los ficheros y de los nuevos números de revisión de los ficheros del
envío.

La tercera línea invoca el guión (también imaginario)
`notificar-defecto.pl' para cualquier envío que no coincida con ninguna
de las dos línes anteriores, pasándole toda la información posible
(ruta al repositorio, nombres de fichero, revisiones antiguas y
revisiones nuevas).


File: cvsbook.info,  Node: Los Ficheros verifymsg y rcsinfo,  Next: El Fichero taginfo,  Prev: Los Ficheros commitinfo y loginfo y rcsinfo,  Up: El directorio administrativo CVSROOT/

Los Ficheros verifymsg y rcsinfo
--------------------------------

A veces puede que solamente quiera un programa que verifique que los
informes de cambios se ajustan a un cierto estándar y que detenga el
envío si no se cumple ese estándar.  Esto puede conseguirse usando
`verifymsg', posiblemente con algo de ayuda de `rcsinfo'.

El fichero "verifymsg" es la combinación habitual de expresiones
regulares y programas.  El programa recibe el informe de cambios por la
entrada estándar; es de suponer que realizará ciertas comprobaciones
para verificar que el informe de cambios cumple ciertos criterios, y
finalmente sale con estado cero o distinto de cero.  En este último
caso, el envío fallará.

Mientras tanto, el lado izquierdo de rcsinfo tiene las expresiones
regulares habituales, pero el lado derecho señala a ficheros de
plantilla en vez de a programas.  Un fichero de plantilla podría ser
algo como esto

     Condición:
     Arreglar:
     Comentarios:

o alguna otra colección de campos que se supone que un desarrollador
debe rellenar para formar un informe de cambios válido.  La plantilla
no es muy útil si todo el mundo hace envíos de cambios usando la opción
-m explícitamente, pero muchos desarrolladores prefieren no hacerlo.
En lugar de ello, ejecutan

     floss$ cvs commit

y esperan que CVS lance automáticamente un editor de texto (como se
especifica en la variable de entorno EDITOR).  Ahí escriben un informe
de cambios, guardan el fichero y se salen del editor, después de lo
cual CVS continúa con el envío.

En ese escenario, se insertaría una plantilla rcsinfo en el editor antes
de que el usuario comience a escribir, de forma que se mostrarían los
campos junto con un recordatorio para rellenarlos.  Entonces, cuando el
usuario haga un envío de cambios, se invocará el programa apropiado en
`verifymsg'.  Presumiblemente comprobará que el informe sigue ese
formato, y su estado de salida reflejará los resultados de su
investigación (con cero indicando éxito).

Como ayuda a los programas de verificación, la ruta a la plantilla del
fichero rcsinfo se añade como último argumento en la línea de órdenes
de `verifymsg'; de esa forma el programa puede basar su proceso de
verificación en la propia plantilla si se desea.

Observe que cuando alguien obtiene una copia de trabajo en una máquina
remota, el fichero de plantilla rcsinfo correspondiente se envía al
cliente también (se almacena en el subdirectorio CVS/ de la copia de
trabajo).  Sin embargo esto significa que si se cambia el fichero
rcsinfo del servidor después de esto, el cliente no verá los cambios
sin volver a obtener una copia del proyecto (con actualizar simplemente
no funcionará).

Fíjese también en que en el fichero verifymsg no se admite la palabra
clave ALL (aunque DEFAULT sigue valiendo).  Esto es para hacer más
sencillo saltarse guiones de verificación por defecto y aplicar otros
específicos para los subdirectorios.


File: cvsbook.info,  Node: El Fichero taginfo,  Next: El Fichero cvswrappers,  Prev: Los Ficheros verifymsg y rcsinfo,  Up: El directorio administrativo CVSROOT/

El fichero taginfo
------------------

Lo que loginfo hace con los informes de cambios, taginfo lo hace con las
marcas.  El lado izquierdo de taginfo está formado por expresiones
regulares como siempre, y al lado derecho hay programas.  A cada
programa se le pasan automáticamente argumentos cuando se invoca una
"CVS tag", en este orden:

     arg 1:          nombre de marca
     arg 2:          operación ("añadir" => tag, "mover" => tag -F, "borrar" => \
        tag -d)
     arg 3:          repositorio
     arg 4, 5, etc:  revisión del fichero [revisión del fichero ...]

Si el programa devuelve un resultado distinto de cero, la marca se
aborta.

No hemos cubierto la opción -F para marcas antes de ahora, pero es
exactamente lo que implica lo de arriba: una forma de mover una marca de
una revisión a otra.  Por ejemplo, si se añade la marca `Funciona_Bien'
a la Revisión 1.7 de un fichero y quiere añadirla en su lugar a la
Revisión 1.11, haría esto

     cvs tag -r 1.11 -F Funciona_Bien foo.c

que elimina la marca de 1.7, o dondequiera que estuviera anteriormente
en ese fichero, y la pone en 1.11.


File: cvsbook.info,  Node: El Fichero cvswrappers,  Next: El Fichero editinfo,  Prev: El Fichero taginfo,  Up: El directorio administrativo CVSROOT/

El Fichero cvswrappers
----------------------

El fichero de nombre redundante cvswrappers le da una forma de
especificar que ciertos ficheros deberían tratarse como binarios,
basado en sus nombres de fichero.  CVS no asume que todos los ficheros
.jpg sean imágenes JPG, por ejemplo, así que no usa automáticamente -kb
cuando añade ficheros JPG.  No obstante, algunos proyectos encontrarían
muy útil simplemente designar todos los ficheros JPG como binarios.
Ésta es la línea de cvswrappers para hacerlo:

     *.jpg -k 'b'

La `b' está separada y entre comillas porque no es el único modo de
expansión de palabras clave RCS posible; también podría especificarse
`o', que indica que no se expandan palabras clave con el signo `$',
sino hacer conversión de nueva línea.  Sin embargo, `b' es el parámetro
más frecuente.

Hay algunos otros modos que se pueden especificar desde el fichero
wrappers, pero se utilizan en situaciones tan raras que posiblemente no
valga la pena documentarlos aquí (es decir: el autor nunca ha tenido
que usarlos).  Vea el nodo `Wrappers' en el Cederqvist si siente
curiosidad.


File: cvsbook.info,  Node: El Fichero editinfo,  Next: El Fichero notify,  Prev: El Fichero cvswrappers,  Up: El directorio administrativo CVSROOT/

El Fichero editinfo
-------------------

Este fichero está obsoleto, pese a que sigue estando incluido en las
distribuciones.  Ignórelo.


File: cvsbook.info,  Node: El Fichero notify,  Next: El Fichero checkoutlist,  Prev: El Fichero editinfo,  Up: El directorio administrativo CVSROOT/

El Fichero notify
-----------------

Este fichero se usa junto con las características de `alarmas' de CVS,
que se describen en *Note CVS avanzado::.  Nada de ello tendrá sentido
hasta que comprenda qué son las alarmas (son una característica útil
pero no esencial), así que vea *Note CVS avanzado:: para obtener
detalles sobre este fichero y sobre las alarmas.


File: cvsbook.info,  Node: El Fichero checkoutlist,  Prev: El Fichero notify,  Up: El directorio administrativo CVSROOT/

El Fichero checkoutlist
-----------------------

Si mira en CVSROOT/, verá qué copias de trabajo de los ficheros existen,
junto a sus ficheros de revisión RCS:

     floss$ ls /usr/local/nuevorepos/CVSROOT
     checkoutlist     config,v       history     notify     taginfo
     checkoutlist,v   cvswrappers    loginfo     notify,v   taginfo,v
     commitinfo       cvswrappers,v  loginfo,v   passwd     verifymsg
     commitinfo,v     editinfo       modules     rcsinfo    verifymsg,v
     config           editinfo,v     modules,v   rcsinfo,v
     
     floss$

CVS presta sólo atención a las versiones de trabajo, no a los ficheros
RCS, cuando está buscando una guía sobre cómo comportarse.  Por tanto,
siempre que haga un envío de cambios de su copia de trabajo de CVSROOT/
(de la que podría obtenerse incluso, después de todo, una copia de
trabajo desde otra máquina distinta), CVS actualiza automáticamente
todos los ficheros cambiados en el propio repositorio.  Sabrá que esto
ocurre porque CVS mostrará un mensaje al final de estos envíos:

     floss$ cvs ci -m "añadidos módulos mp y asub" modules
     Checking in modules;
     /usr/local/nuevorepos/CVSROOT/modules,v  <--  modules
     new revision: 1.2; previous revision: 1.1
     done
     cvs commit: Rebuilding administrative file database

CVS se entera automáticamente de lo que pasa con los ficheros estándar
de administración, y los reconstruirá en CVSROOT/ cuando sea necesario.
Si decide poner ficheros personalizados en CVSROOT/ (como programas o
ficheros de plantilla rcsinfo), tendrá que decirle explícitamente a CVS
que los trate del mismo modo.

Éste es el propósito del fichero checkoutlist.  Tiene un formato
distinto al de la mayoría de los ficheros que hemos visto hasta ahora

     NOMBRE_FICHERO     MENSAJE_DE_ERROR_SI_NO_PUEDE_OBTENERSE_COPIA_DEL_FICHERO

por ejemplo,

     log.pl           imposible obtener copia de / actualizar log.pl en CVSROOT
     
     bugfix.tmpl      imposible obtener copia de / actualizar bugfix.tmpl en CVSROOT

Tradicionalmente algunos ficheros de CVSROOT no se someten a control de
revisión.  Uno de ellos es el fichero "history", que mantiene un
registro en vivo de todas las acciones en el repositorio para usarse
con las órdenes `cvshistory' (que lista actividades de marcas,
obtenciones de copias y actualizaciones para un fichero o un directorio
del proyecto dado). A propósito, si simplemente elimina el fichero
`history' CVS detendrá servicialmente ese registro.

Nota: a veces el fichero history es la causa de problemas con los
permisos, y la forma más fácil de resolverlos es o eliminarlo o hacerlo
modificable por todo el mundo.

Otro fichero de administración `no sujeto a revisión' es passwd, dado
que obtener una copia suya por la red comprometería las contraseñas
(aunque estén cifradas).  Tendrá que decidir basándose en su propia
situación de seguridad si quiere añadir passwd a checkoutlist o no; por
defecto no está.

Dos notas finales sobre el directorio CVSROOT/: Es posible, si comete un
error lo bastante grande, que envíe cambios de un fichero
administrativo que esté estropeado de tal forma que impida que se haga
cualquier otro envío.  Si hace esto, ¡por supuesto que no será capaz de
enviar una versión corregida del fichero administrativo!. La solución
es ir y editar a mano la copia de trabajo del repositorio del fichero
administrativo para corregir el problema; puede que el repositorio
entero esté inaccesible hasta que haga esto.

Además, en aras de la seguridad, asegúrese de que en el directorio
CVSROOT/ sólo pueden escribir usuarios en quienes confía (con
`confianza' quiero decir que confíe tanto en sus intenciones como en su
capacidad para no poner en peligro sus contraseñas).  Los ficheros
`*info' le dan a la gente la capacidad de invocar programas en general,
así que cualquiera que pueda hacer envíos o editar ficheros en el
directorio CVSROOT/ puede en la práctica ejecutar cualquier orden del
sistema.  Esto es algo que siempre debe tener en mente.


File: cvsbook.info,  Node: Correos de envío de cambios,  Next: Averiguando más,  Prev: El directorio administrativo CVSROOT/,  Up: Administracion del Repositorio

Correos de envío de cambios
===========================

Con el fichero loginfo es como se configuran los correos de envío de
cambios - correos automáticos que se envían a todos los que trabajan en
un proyecto siempre que se realiza un envío de cambios.  (Puede que no
parezca intuitivo que esto se haga en loginfo en vez de en commitinfo,
pero la razón para ello es que se quiere incluir el informe de cambios
en el correo).  El programa para hacer el envío - `contrib/log.pl' en
la distribución fuente de CVS - puede instalarse en cualquier parte del
sistema.  Yo lo pongo en el subdirectorio CVSROOT/ del repositorio,
pero es cuestión de gustos.

Puede que necesite editar ligeramente `log.pl' para conseguir que
funcione en su sistema, posiblemente cambiando la primera línea para
que señale a su intérprete Perl, y quizá cambiando la línea

     $mailcmd = "| Mail -s 'Actualización CVS: $modulepath'";

para que llame a su gestor de correo favorito, que puede llamarse `Mail'
o no.  Una vez que lo haya configurado a su gusto, podrá añadir líneas
como estas a su loginfo:

     listerizer CVSROOT/log.pl %s -f CVSROOT/commitlog -m listerizer@red-bean.com
     RoadMail   CVSROOT/log.pl %s -f CVSROOT/commitlog -m roadmail@red-bean.com
     bk/*score  CVSROOT/log.pl %s -f CVSROOT/commitlog -m \
                                             bkscore-devel@red-bean.com

El `%s' se expande a los nombres de los ficheros afectados por el envío
de cambios; la opción -f para `log.pl' requiere un nombre de fichero al
que el informe de cambios se añadirá (de forma que CVSROOT/commitlog
será un fichero siempre creciente de informes de cambios); y el
modificador -m admite una dirección de correo electrónico, a la que
`log.pl' enviará un mensaje sobre el envío de cambios.  La dirección es
generalmente una lista de correo, pero puede especificar la opción -m
tantas veces como sean necesarias en una línea de órdenes para log.pl.


File: cvsbook.info,  Node: Averiguando más,  Prev: Correos de envío de cambios,  Up: Administracion del Repositorio

Averiguando más
===============

Aunque este capítulo trata de dar una introducción a la instalación y
administración de CVS, me he dejado cosas que o bien se usan muy
raramente como para que valga la pena mencionarlas o bien ya están bien
documentadas en el manual Cederqvist.  La última categoría incluye la
puesta a punto de los otros métodos de acceso remoto: RSH/SSH, kserver
(Kerberos 4) y GSSAPI (que incluye Kerberos 5 entre otras cosas).
Debería notarse que no hay que hacer nada especial para las conexiones
con RSH/SSH, aparte de asegurarse de que el usuario en cuestión puede
entrar en la máquina del repositorio usando RSH o SSH.  Si pueden y CVS
está instalado tanto en el cliente como en el servidor, y tienen los
permisos adecuados para usar el repositorio directamente desde la
máquina servidora, deberían poder acceder al repositorio remotamente
por medio del método :ext:.

Las descripciones de algunas características especializadas de CVS se
han dejado para capítulos posteriores, para que puedan introducirse en
contextos en los que su utilidad es evidente.  Pueden encontrarse
consejos generales de solución de problemas de CVS en *Note Problemas y
Soluciones::.  Aunque no es necesario leerse el manual Cederqvist
entero, debería familiarizarse con él; será una herramienta de
referencia de valor incalculable.  Si por alguna razón no tiene Info en
su máquina y no quiere imprimir el manual, puede hojearlo en línea en
`http://durak.org/cvswebsites/doc/' o
`http://www.loria.fr/~molli/cvs/doc/cvs_toc.html'.


File: cvsbook.info,  Node: CVS avanzado,  Next: Problemas y Soluciones,  Prev: Administracion del Repositorio,  Up: Top

CVS avanzado
************

Ahora que hemos cubierto los conceptos básicos sobre el uso de CVS y la
administración del repositorio, miraremos cómo CVS puede ser incorporado
dentro del proceso de desarrollo. El ciclo de funcionamiento de CVS -
obtener (_checkout_), actualizar (_update_ entregar (_commit_),
actualizar, entregar, y así sucesivamente - fué mostrado en los
ejemplos *Note Una introduccion a CVS::. Este capítulo amplía este ciclo
y muestra como CVS puede ser usado para ayudar a los desarrolladores a
comunicarse, dar resúmenes del la actividad y la historia del proyecto,
fusionar diferentes ramas de desarrollo y ejecutar tareas frecuentes
automáticamente. Algunas de las técnicas explicadas introducen nuevas
órdenes, pero muchas simplemente indican otra forma mejorada de usar
órdenes que ya se han visto.

* Menu:

* Alarmas (CVS como telefono)::
* Mensajes log y correos electrónicos a la entrega::
* Cambiar un mensaje log después de una entrega::
* Deshacerse de una copia de trabajo::
* Historial -- Un resumen de la actividad del repositorio::
* Anotaciones -- Sumario detallado de la actividad del proyecto::
* Anotaciones y ramificaciones::
* Usando expansión de palabras::
* Salir del limbo (Cómo trabajar con derivaciones y sobrevivir)::
* Vigilando fuentes de terceras partes (Derivaciones comerciales)::
* Exportar para distribución pública::
* El humilde gurú::


File: cvsbook.info,  Node: Alarmas (CVS como telefono),  Next: Mensajes log y correos electrónicos a la entrega,  Up: CVS avanzado

Alarma (CVS como telefono)
==========================

Un beneficio importante de usar CVS en un proyecto es que puede
funcionar tanto como un dispositivo de comunicación como para almacenar
información sobreel proyecto. Esta sección se centra en cómo se puede
usar CVS para que los participantes estén informados de lo que pasa en
el projector.  Como en otros aspectos de CVS, estas características
fomentan la cooperación. Peros los participantes tienen que querer
expresamente que se les informe; si la gente elige no usar estas
carácteristicas de comunicación no hay nada que CVS puede hacer.

* Menu:

* Cómo funcionan las alarmas::
* Habilitar alarmas en el repositorio::
* Usando alarmas durante el desarrollo::
* Cómo acabar una sesión de edición::
* Controlar qué acciones son vigiladas::
* Encontrar quién vigila qué::
* Recomendar a la gente usar alarmas::
* Cómo aparecen las alarmas en el repositorio::


File: cvsbook.info,  Node: Cómo funcionan las alarmas,  Next: Habilitar alarmas en el repositorio,  Up: Alarmas (CVS como telefono)

Cómo funcionan las alarmas
--------------------------

En su comportamiento por defecto CVS trata cada copia de trabajo como
una caja independiente. Nadie sabe lo que usted está haciendo hasta que
entrega sus cambios. Así mismo usted no sabe lo que los demás están
haciendo en las suyas; excepto a través de los métodos normales de
comunicación, por ejemplo pegando una voz en la oficina: -¡Oye, voy a
trabajar en el fichero.c ahora. Decidme si alguién está trabajando en
él para no tener conflictos!

Este método informal funciona en proyectos donde la gente sabe más o
menos quién es responsable de qué. Sin embargo, es más dificil cuando
hay un gran número de desarrolladores activos en todas las partes del
código base y quieren evitarse los  conflictos. En estos casos,
frecuentemente se pasa al área de responsabilidad de otro compañero y
no se puede estar gritando en la oficina ya que el lugar de trabajo es
geográficamente disperso.

Una característica de CVS llamada `alarma' proporciona un modo de
avisarse entre ellos quién está trabajando en que fichero en un momento
dado. Si alguien establece una alarma en un fichero puede ser advertido
cuando otro desarrollador empieze a trabajar es ese fichero.  La
advertencia se envía normalmente por medio de correo electrónico pero
es posible usar otros métodos.

Para usar alarmas, hay que modificar uno ó dos ficheros del área de
admistración del repositorio, y los desarrolladores tienen que hacer un
paso extra en el ciclo ususal de obtención/actualización/entrega. Los
cambios en el repositorio son bastante simples: Necesita editar el
fichero `CVSROOT/notify' para que CVS sepa que advertencias debe
realizar. También hay que añadir algunas líneas al fichero
`CVSROOT/users', que aporta direcciones externas de correo electrónico.

En la copia de trabajo los desarrolladores tienen que decir al CVS qué
ficheros debe vigilar para que CVS informe cuando alguién va a editar
alguno de esos ficheros. Además uno tiene que decirle a CVS cuando
empieza o termina de editar un fichero para que CVS a su vez lo indique
a otros desarrolladores que podrían estar vigilando. Las siguientes
órdenes son usadas para estos pasos extra.

   * cvs watch

   * cvs edit

   * cvs unedit

El patrón de la orden `watch' se diferencia de otras órdenes comunes en
que utiliza subórdenes, como por ejemplo `cvs watch add...',
`cvs watch remove...', y así.

En el siguiente ejemplo vamos a ver cómo se establecen las alarmas en el
repositorio y cómo se usan desde el área del desarrollador. Los dos
usuarios de ejemplo, jrandom y qsmith, tienen su propia copia de trabajo
que puede estar en diferentes máquinas. Seguimos asumiendo que la
variable de entorno $CVSROOT está asignada y por ello no tenemos que
pasar la opción -d <REPOS> a ningún comando CVS.


File: cvsbook.info,  Node: Habilitar alarmas en el repositorio,  Next: Usando alarmas durante el desarrollo,  Prev: Cómo funcionan las alarmas,  Up: Alarmas (CVS como telefono)

Habilitar alarmas en el repositorio
-----------------------------------

Primero se debe activar la notificación mediante correo electrónico
editando el fichero CVSROOT/notify. Uno de los dos desarrolladores debe
hacer esto o el administrador del repositorio si los desarrolladores no
tienen permiso para cambiar los ficheros administrativos del
repositorio.  En cualquier caso la primera cosa es obtener el área
administrativa y editar el fichero notify:

     floss$ cvs -q co CVSROOT
     U CVSROOT/checkoutlist
     U CVSROOT/commitinfo
     U CVSROOT/config
     U CVSROOT/cvswrappers
     U CVSROOT/editinfo
     U CVSROOT/loginfo
     U CVSROOT/modules
     U CVSROOT/notify
     U CVSROOT/rcsinfo
     U CVSROOT/taginfo
     U CVSROOT/verifymsg
     floss$ cd CVSROOT
     floss$ emacs notify
     ...

Cuando se edita el fichero notify por primera vez nos encontramos con
algo como esto:

     # Versión en castellano
     # El fichero 'notify' especifica donde van se envían las notificaciones
     # procedentes de alarmas establecidas mediante "cvs watch add" ó "cvs
     # edit". La primera entrada de una línea es una expresión regular que se
     # compara con el directorio donde el cambio se está haciendo relativo a
     # $CVSROOT. Si coincide el resto de la línea es un programa filtro que
     # debería contener una ocurrencia %s que indica el usuario a notificar, e
     # informcación de su entrada de datos estándar.
     #
     # "ALL" o "DEFAULT" puede ser usada en lugar de la expresión regular.
     #
     # Por ejemplo:
     # ALL mail %s -s "notificación de CVS"

En realidad todo lo que hay que hacer es descomentar la última línea
quitando el carácter `#'. Aunque `notify' proporciana la misma
flexibilidad que otros ficheros administrativos a través de las
expresiones regulares normalmente no se va usar. La única razón de
tener múltiples lineas, cada una con un expresión regular para cada
parte del repositorio es si se van usar otros métodos de notificación
distintos para cada proyecto. Normalmente la mayoría de los proyectos
usan correo electrónico ya que es un buen método de notificación.

Para especificar la notificación mediante correo electrónico, la línea

     ALL mail %s -s "notificación de CVS"

debería funcionar en cualquier Unix estándar. Éste comando hace que las
notificaciones o avisos sean enviadas mediante correo electrónico con
la línea de `subject' `notificación de CVS' (La expresión se compara
contra cualquier directorio). Cuando se haya descomentado la línea hay
que entregar el fichero notify para que el repositoria sea consciente
del cambio:

     floss$ cvs ci -m "establecido notificación por alarma"
     cvs commit: Examining .
     Checking in notify;
     /usr/local/newrepos/CVSROOT/notify,v  <--  notify
     new revision: 1.2; previous revision: 1.1
     done
     cvs commit: Rebuilding administrative file database
     floss$

Editar este fichero es todo lo que hay que hacer para establecer alarmas
en el repositorio. Sin embargo si hay desarrolladores trabajando en
máquinas remotas es necesario editar el fichero `CVSROOT/users'
también. La función de este fichero es indicar a CVS a qué direcciones
de correo enviar las notificaciones para los usuarios remotos.  El
formato de cada línea del fichero users sería:

     CVS_USERNAME:EMAIL_ADDRESS

Por ejemplo,

     qsmith:quentinsmith@farawayplace.com

El nombre de usuario al principio de la línea corresponde a un usuario
de CVS del fichero `CVSROOT/password' (si está presente y el método de
acceso por servidor está siendo usado), o el usuario del servidor
ejecutando CVS. Siguiendo los dos puntos viene la dirección de correo
de ese usuario a la que el CVS enviará las notificaciones.

Desgraciadamente en el momento de la escritura de este documeto el
fichero users no existe en la distribución estándar de CVS. Debido a que
es un fichero administrativo no sólo se debe crearlo, añadirlo `cvs add
...' y entregarlo `commit ...' de la forma usual sino que hay que
añadirlo al fichero `CVSROOT/checkoutlist' para que una copia sea
mantenida en el repositorio.

Lo siguiente es una sesión de ejemplo:

     floss$ emacs checkoutlist
       ... (añade la línea para el fichero users) ...
     floss$ emacs users
       ... (añade la línea para el usuario qsmith) ...
     floss$ cvs add users
     floss$ cvs ci -m "añade users a checkoutlist, qsmith a users"
     cvs commit: Examining .
     Checking in checkoutlist;
     /usr/local/newrepos/CVSROOT/checkoutlist,v  <--  checkoutlist
     new revision: 1.2; previous revision: 1.1
     done
     Checking in users;
     /usr/local/newrepos/CVSROOT/users,v  <--  users
     new revision: 1.2; previous revision: 1.1
     done
     cvs commit: Rebuilding administrative file database
     floss$

Es posible usar direcciones de correo de formato expandido en
`CVSROOT/usres', pero hay que tener cuidado en poner todos los espacios
en blanco entre comillas. Veamos el siguiente ejemplo

     qsmith:"Quentin Q. Smith <quentinsmith@farawayplace.com>"

o

     qsmith:'Quentin Q. Smith <quentinsmith@farawayplace.com>'

Sin embargo, esto no funcionará:

     qsmith:"Quentin Q. Smith" <quentinsmith@farawayplace.com>

Si hay dudas debería probar ejecutando la orden del fichero notify
directamente reemplazando `%s' en

     mail %s -s "CVS notification"

por lo que sigue después de los dos puntos en el fichero users.  Si
funciona desde el prompt debería hacerlo también en el fichero de
usuarios.

Cuando está terminado el fichero checkout debería aparecer como:

     # El fichero 'checkoutlist' se usa para soportar ficheros adicionales de
     # control de versión administrativos de $CVSROOT/CVSROOT, como plantillas.
     #
     # La primera entrada de una línea es un nombre de fichero que será obtenido
     # del correspondiente RCS fichero del directorio $CVSROOT/CVSROOT.
     # El resto de la línea será el mensaje de error que aparecerá si el fichero
     # no se puede obtener.
     #
     # Formato del fichero:
     #
     #       [<espacio en blaco>]<nombre del fichero><espcio en blanco>
     <mensaje de error><find de línea>
     #
     # líneas de comentario enmpiezan con '#'
     
     users   No ha sido posible obtener `users' file in CVSROOT.

Ya hemos visto como se prepara el repositorio para las alarmas. Pasemos
ahora a lo que los desarrolladores tienen que hacer en sus copias de
trabajo.


File: cvsbook.info,  Node: Usando alarmas durante el desarrollo,  Next: Cómo acabar una sesión de edición,  Prev: Habilitar alarmas en el repositorio,  Up: Alarmas (CVS como telefono)

Usando alarmas durante el desarrollo
------------------------------------

Primero, un programador obtiene una copia de trabajo y se añade a la
lista de vigilantes para alguno de los ficheros del projecto:

     floss$ whoami
     jrandom
     floss$ cvs -q co myproj
     U myproj/README.txt
     U myproj/foo.gif
     U myproj/hello.c
     U myproj/a-subdir/whatever.c
     U myproj/a-subdir/subsubdir/fish.c
     U myproj/b-subdir/random.c
     floss$ cd myproj
     floss$ cvs watch add hello.c
     floss$

La última orden, `cvs watch add hello.c', indica a CVS que nofifique a
jramdom si alguien empieza a trabajar en hello.c. O sea que añade
jrandom a la lista de alarma de hello.c. Para que CVS pueda notificar
tan pronto como sea posible que un fichero se va a editar el usuario
tiene que indicárselo a CVS mediante la orden `cvs edit' y el nombre
del fichero.  CVS no tiene otro modo de saber cuando alguien empieza a
trabajar en un fichero. Una ver que se ha obtenido una copia, CVS no es
normalmente invocado hasta la siguiente actualización o entrega, la
cual sucede después de que el fichero se haya editado:

     paste$ whoami
     qsmith
     paste$ cvs -q co myproj
     U myproj/README.txt
     U myproj/foo.gif
     U myproj/hello.c
     U myproj/a-subdir/whatever.c
     U myproj/a-subdir/subsubdir/fish.c
     U myproj/b-subdir/random.c
     paste$ cd myproj
     paste$ cvs edit hello.c
     paste$ emacs hello.c
     ...

Cuando qsmith ejecuta `cvs edit hello.c', CVS mira en la lista de
alarma de hello.c, ve que jrandom está en ella, y envia un correo a
jrandom diciendole que qsmith ha empezado a editar el fichero. El
fichero incluso parece haber llegado del mismo qsmith:

     From: qsmith
     Subject: CVS notification
     To: jrandom
     Date: Sat, 17 Jul 1999 22:14:43 -0500
     
     myproj hello.c
     --
     Triggered edit watch on /usr/local/newrepos/myproj
     By qsmith
     
     Además cada vez que qsmith (o cualquiera) entrega una nueva revisión de
     hello.c, jrandon recivirá otro correo electrónico:
     
     
     myproj hello.c
     --
     Triggered commit watch on /usr/local/newrepos/myproj
     By qsmith

Después de recibir estos correos, jrandom podría querer actualizar su
copia de hello.c para ver qué cambios qsmith ha hecho o quizás quisiera
enviar un correo a qsmith para saber porqué está trabajando en ese
fichero.  Nada fuerza a qsmith a recordar hacer un `cvs edit'. Si lo
hizo fué porque quizá querría hacerselo saber a jrandom. De cualquier
forma, incluso si se olvida hacer un `cvs edit' al hacer una entrega se
disparará la notificación. La razón de `cvs edit' es que los advierte a
los vigilantes antes de que empizes a trabajar en el fichero y éstos se
pueden poner en contacto contigo para resolver el conflicto, antes de
que hayas desperdiciado el tiempo.

CVS asume que cualquiera que hace un `cvs edit' quiere ser añadido a la
lista de alarma de ese fichero, al menos temporalmente, en caso de que
algún otro también lo edite. Cuando qsmith ejecuta `cvs edit', se
convierte en un vigilante de hello.c. Él y jrandom recivirían un
notificación si una tercera persona ejecutase `cvs edit' en ese fichero
(ó lo entregara).

Sin embargo, CVS también asume que la persona que está editando el
fichero quiere estar en la lista mientras está trabajando en él. Esos
usuarios serán borrados de la lista cuando hayan hecho su edición del
fichero. Si quieren ser vigilantes permanenetes deberán ejecutar `cvs
watch add'.  CVS asume por defecto que alguién ha terminado la edición
cuando él ó ella hace una entrega del fichero.

Cualquiera que está en la lista de vigilancia de un fichero por haber
ejecutado `cvs edit' en ese fichero es conocido como "temporary
watcher" y es eliminado de la lista cuando entrege un cambio en el
fichero.  Si quiere editarlo de nuevo tendría que volver a ejecutar
`cvs edit'.

La suposición de que la primera entrega acaba la sesión de edición es
sólamente una buena predicción, ya que CVS no sabe cuantas entregas la
persona necesitará para hacer sus cambios. La predicción es buena para
"one-off" cambios - cambios donde hay que arreglar un pequeño error en
un fichero y entregarlo. Para ediciones más prolongadas que requieren
varias entregas sería bueno que el usuarios se añadiera permanentemente
a la lista de vigilantes.

     paste$ cvs watch add hello.c
     paste$ cvs edit hello.c
     paste$ emacs hello.c
     ...
     paste$ cvs commit -m "escrito hola en sánscrito"

Incluso después de una entraga, qsmith quedará como vigilante de hello.c
ya que ejecutó `watch add' sobre él. (A propósito, qsmith no recibirá
notificaciones sobre sus propios cambios; sólo los demás. CVS es lo
suficientemente listo para no advertirte sobre tus propias acciones.)


File: cvsbook.info,  Node: Cómo acabar una sesión de edición,  Next: Controlar qué acciones son vigiladas,  Prev: Usando alarmas durante el desarrollo,  Up: Alarmas (CVS como telefono)

Cómo acabar una sesión de edición
---------------------------------

Si no quieres hacer una entrega sino acabar tu sesión de edición
explicitamente, se puede hacer ejecutando `cvs unedit':

     paste$ cvs unedit hello.c

Dese cuenta de que además de notificar a los demás vigilantes que ha
terminado esta orden ofrece la posibilidad de deshacer todos los cambios
que haya hecho en el fichero.

     paste$ cvs unedit hello.c
     hello.c has been modified; revert changes? y
     paste$

Si usted contesta `y', CVS deshará todos los cambios y notificará a
todos los vigilantes que no seguirá editando el fichero. Si responde
`n', CVS mantiene sus cambios  y seguirá registrado como uno de los
editores del fichero. Por lo tanto no habrá nofificación; de hecho es
como si no hubiera ejecutado `cvs unedit'. Esta posibilidad es un poco
tremenda, pero fácil de entender: si declara al mundo que ha terminado
su sesión de edición cualquier cambio que no haya entregado antes es
porque no tenía intención de guardarlos. Al menos así es como lo ve
CVS. No es necesario decir que tenga cuidado.

