@c ---------------------------------------------------------------------
@node Una introduccion a CVS
@unnumbered Una introduccion a CVS
@cindex overview
@cindex tutorial

@comment Este capítulo ha sido traducido por
@comment Javier Fernández-Sanguino Peña <jfs@@computer.org>
@comment y revisado por David Rey <david@@saug.org> .
@comment -
@comment Se ceden todos los derechos bajo la licencia de documentación de 
@comment la GNU (fdl) que se puede encontrar en http://www.gnu.org/

@quotation
@cartouche
@emph{No puedo imaginarme programar sin él.. ¡sería como saltar
en paracaídas sin un paracaídas!}

@center @emph{--Brian Fitzpatrick hablando de CVS}
@end cartouche
@end quotation

Este capítulo presenta los fundamentos en los que se basa CVS,
ofreciendo a continuación un recorrido detallado por el uso
cotidiano de CVS. Los conceptos se presentan de forma secuencial,
así que si es Ud. un novato en CVS, la mejor manera de leer este
capítulo será empezar por el principio e ir leyéndolo paso a paso,
sin saltarse nada.




@menu
* Conceptos Básicos::            Cómo pensar en CVS.
* Un día con CVS::               Una sesión de ejemplo.
* Otros comandos útiles de CVS:: Cosas de mayor o menor utilidad.
* Ramas::                        Separar el desarrollo en corrientes paralelas.
@end menu

@c ------------------------------------------------------------------
@node Conceptos Básicos
@section Conceptos Básicos

Si nunca ha usado antes CVS (o ningún otro sistema de control de
versiones), es fácil desconcertarse con algunas de las suposiciones
que éste hace. Lo que parece causar más confusión inicialmente sobre
CVS, es que se usa para dos cosas que aparentemente no guardan relación
alguna: guardar registros, y al mismo tiempo hacer posible la colaboración.
Sin embargo, se da el caso de que estas dos funciones están estrechamente
relacionadas.

Se hizo necesario guardar registros porque las personas querían comparar
el estado actual de un programa con el estado en el que encontraba en
un momento dado en el pasado. Por ejemplo, en el transcurso normal de la
implantación de una nueva función, un desarrollador puede llevar el
programa a un estado en el que resulta inutilizable, estado que
posiblemente perdurará hasta que la implantación de la nueva función
esté casi hecha. Por desgracia, se da la casualidad de que éste suele
ser precisamente el momento en el que alguien informa de un fallo en
la última versión distribuida al público; para solucionar el problema
(que podría estar también presente en la versión actual de las fuentes),
el programa ha de volver de nuevo a un estado utilizable.

Restaurar un estado determinado es tarea fácil si el historial del código
fuente se mantiene bajo CVS. El desarrollador puede simplemente decir:
"Dame el programa tal como estaba hace tres semanas", o quizás, "Dame
el programa en el estado en el que se encontraba en el momento de hacer
nuestra última distribución pública".  Si nunca ha disfrutado de este
cómodo acceso a "fotografías" históricas, posiblemente se sorprenda de
la rapidez con la que llegará a depender de él. En mi caso, personalmente
ahora siempre uso control de revisiones en mis proyectos de programación,
puesto que es algo que me ha salvado en multitud de ocasiones.

Para comprender cómo está ésto relacionado con la colaboración, deberemos
observar con más detalle el mecanismo ofrecido por CVS para ayudar a muchas
personas a trabajar en un mismo proyecto. Pero, antes de que lleguemos ahí,
echemos un vistazo al mecanismo que CVS *no* proporciona (o que, por lo
menos, no fomenta): el bloqueo de ficheros. Si ha usado algún otro sistema
de control de versiones, quizás esté familiarizado con el modelo de
desarrollo bloquear-modificar-desbloquear, en el que un desarrollador
obtiene primero un acceso exclusivo de escritura (un bloqueo) sobre el
fichero que va a editar, hace los cambios, y a continuación elimina el
bloqueo para permitir que otros desarrolladores puedan acceder al fichero.
Si alguien tiene un bloqueo establecido sobre un fichero, esa persona
deberá "liberarlo" para que usted pueda bloquear el fichero y comenzar
a hacer sus cambios (en algunas implantaciones usted podría "robarle" el
bloqueo, pero con frecuencia esto viene a ser una desagradable sorpresa
para la otra persona, ¡y en ningún caso una práctica aconsejable!).

Este sistema es factible cuando los desarrolladores se conocen, saben
quién se propone hacer qué en un momento dado, y pueden comunicarse
con los demás rápidamente en caso de que alguien no pueda trabajar
por tener limitado su acceso. Sin embargo, si el grupo de desarrolladores
se hace demasiado grande o no es posible una comunicación fluida entre
ellos, gestionar cuestiones de bloqueo de ficheros comenzará a restar
tiempo al desarrollo del código, para convertirse en un problema constante
que puede ser contraproducente para el normal discurrir del proyecto.

CVS propone una solución intermedia: en lugar de obligar a los
desarrolladores a coordinarse entre sí para evitar conflictos, CVS
les permite editar el código de forma simultánea, asume la tarea de
integrar todos los cambios, y guarda un registro de todos los conflictos
que vayan surgiendo. El proceso utiliza el modelo copiar-modificar-fusionar,
que viene a funcionar de la forma siguiente:

@enumerate

@item
El desarrollador A solicita a CVS una copia de trabajo, esto es,
un árbol de directorios que contiene los ficheros que conforman el
proyecto. Esta operación es también conocida como "obtener una copia"
(comando "checkout"), y es como tomar un libro prestado de una biblioteca.

@item
El desarrollador A edita libremente su copia de trabajo. Al mismo
tiempo, otros desarrolladores pueden estar atareados con sus propias
copias de trabajo. Puesto que todas son copias separadas, no hay
interferencias: es como si todos los desarrolladores tuvieran su
propia copia del mismo libro, y todos estuvieran trabajando anotando
comentarios en los márgenes o reescribiendo determinadas páginas de
forma independiente.

@item
El desarrollador A termina sus cambios y los envía (comando "commit")
a CVS junto con un informe de cambios, que es un comentario que explica
la naturaleza y propósito de los cambios que ha realizado. Esto es el
equivalente a informar a la biblioteca de los cambios que ha hecho al
libro y el porqué de los mismos. Entonces, la biblioteca incorpora
estos cambios a la "copia maestra", donde se guardan de forma
permanente.

@item
Mientras tanto, y también por medio de CVS, otros desarrolladores
pueden consultar a la biblioteca para ver si la copia maestra ha
cambiado recientemente, en cuyo caso CVS actualizará automáticamente
sus copias de trabajo personales. (Esta parte es mágica y maravillosa,
y espero que sepa apreciarla. ¡Imagine lo diferente que sería el mundo
si los libros de verdad funcionasen de esta forma!)


@end enumerate

Por lo que concierne a CVS, todos los desarrolladores de un proyecto son
iguales. La decisión de cuándo actualizar o cuándo enviar al almacén es
un tema de preferencias personales o de política establecida entre los
miembros que participan en el proyecto. Una de las estrategias más
comunes para proyectos de programación es la de siempre actualizar
antes de empezar a trabajar en un cambio importante, y enviar los
cambios sólo cuando éstos hayan sido finalizados y probados, a fin
de que la copia principal se mantenga en todo momento en un estado
"ejecutable".

Quizás se esté preguntando lo que ocurre cuando los desarrolladores A y B,
cada uno trabajando en su copia de trabajo personal, hacen distintos
cambios al mismo trozo de texto y después ambos envían sus cambios.
Esto se conoce como @dfn{conflicto}, y CVS se percata del mismo en
cuanto el desarrollador B intenta enviar sus cambios: en lugar de
permitir que el desarrollador B proceda, CVS anuncia que ha descubierto
un conflicto y coloca marcadores de conflicto (marcas de texto fácilmente
reconocibles) en el lugar de su copia local donde se ha descubierto el
conflicto. En ese lugar se mostrarán ambos paquetes de cambios,
convenientemente ordenados para hacer fácil su comparación. El
desarrollador B deberá entonces solucionar el problema y enviar
una nueva revisión con el conflicto resuelto. Quizás los dos
desarrolladores deban hablar entre ellos para solucionar el problema;
CVS sólo avisa a los desarrolladores de que hay un conflicto, dejando
bajo su responsabilidad la tarea de resolverlo.

¿Y qué hay de la copia maestra?  En terminología oficial de CVS, se la
conoce como "repositorio" del proyecto, y es simplemente un árbol
de ficheros guardado en un servidor central. Sin entrar en mucho detalle
sobre su estructura (pero lea @ref{Administracion del Repositorio}), veamos
lo que el repositorio debe hacer para cumplir con los requisitos del
ciclo copiar-enviar-actualizar. Considere el siguiente caso:

@enumerate

@item
Dos desarrolladores, A y B, obtienen una copia de trabajo de un proyecto
al mismo tiempo. El proyecto se encuentra en su punto de partida: nadie
ha hecho todavía cambio alguno, así que todos los ficheros están todavía
en su estado original e impoluto.

@item
El desarrollador A empieza de inmediato a trabajar, y pronto envía su
primer paquete de cambios.

@item
Mientras tanto, el desarrollador B está viendo la televisión.

@item
El desarrollador A, trabajando como si el mundo se acabase al día
siguiente, envía su segundo paquete de cambios. En este momento, el
historial del repositorio contiene los ficheros originales, seguidos
por el primer paquete de cambios introducidos por A, que a su vez
han ido seguidos por estos últimos cambios.

@item
Mientras tanto, el desarrollador B está jugando a su videojuego favorito.


@item
De pronto, el desarrollador C se une al proyecto y obtiene su copia de
trabajo del repositorio. La copia del desarrollador C refleja los dos
primeros paquetes de cambios de A, puesto que ya estaban en el repositorio
cuando C obtuvo su copia.

@item
El desarrollador A, que ha estado programando como un poseso, completa
y envía su tercer paquete de cambios.

@item
Por último, e ignorando la actividad frenética habida recientemente,
B decide que es hora de empezar a trabajar. No se molesta en actualizar
su copia; simplemente comienza a editar ficheros, algunos de los cuales
pueden ser ficheros en los que A ha estado trabajando. Un poco más tarde,
el desarrollador B envía sus primeros cambios.

@end enumerate

Llegados a este punto, pueden suceder dos cosas. Si ninguno de los
ficheros editados por B han sido editados por A, el envío tiene éxito.
Sin embargo, si CVS percibe que algunos de los ficheros de B están
pasados de fecha con respecto a las últimas copias disponibles en el
repositorio, y todos esos ficheros han sido también cambiados por B en su
copia de trabajo, CVS informa a B de que debe hacer una actualización
antes de enviar estos ficheros.

Cuando el desarrollador B efectúa la actualización, CVS reune todos los
cambios realizados por A en la copia local de los ficheros de B. Parte
del trabajo de A puede entrar en conflicto con los cambios no enviados
por B, mientras que otros pueden no hacerlo. Aquellas partes que no lo
hacen son simplemente aplicadas en las copias de B, sin más, pero los
cambios que supongan un conflicto deberán ser resueltos por B para poder
ser enviados.

Si el desarrollador C efectúa ahora una actualización, recibirá del
repositorio algunos cambios nuevos, que serán aquéllos pertenecientes
al tercer envío de A, y los pertenecientes al primero @emph{con éxito} de B
(que en realidad podrían proceder del segundo intento de B de enviar,
asumiendo que el primer intento de B tuviese como resultado el que B
se viera obligado a resolver algún conflicto).

Para que CVS pueda servir los cambios en la secuencia correcta a los
desarrolladores cuyas copias de trabajo puedan no estar sincronizadas
en mayor o menor grado, el repositorio necesita guardar todos los envíos
recibidos desde el comienzo del proyecto. En la práctica, el repositorio
de CVS los guarda todos en ficheros de diferencias (también llamados "diffs")
sucesivos. Así pues, incluso para una copia de trabajo muy antigua, CVS
es capaz de establecer las diferencias entre la copia de trabajo y el
estado actual del repositorio, y es por tanto capaz de actualizar la copia
de trabajo de una forma eficiente. Esto hace que los desarrolladores puedan
en cualquier momento revisar fácilmente el historial del proyecto, y
conseguir copias de trabajo tan antiguas como sea necesario.

A pesar de que, estrictamente hablando, el repositorio podría conseguir
los mismos resultados por otros medios, en la práctica guardar ficheros
de diferencias es una forma simple e intuitiva de implantar la
funcionalidad necesaria. Además, este método tiene la ventaja añadida
de que, usando apropiadamente el programa "patch", CVS puede reconstruir
cualquier estado previo del árbol de ficheros y, por tanto, llevar una
copia de trabajo de un estado a otro. Esto permite que cualquiera pueda
obtener una copia del proyecto tal y como era en un momento determinado,
a la vez que permite mostrar las diferencias, en formato diff, entre dos
estados del árbol sin afectar a la copia de trabajo de nadie.

Por lo tanto, las mismas funcionalidades que son necesarias para dar un
útil acceso al historial del proyecto también resultan útiles para
proporcionar a un grupo de desarrolladores descentralizado y descoordinado
la posibilidad de colaborar en el proyecto.

Por ahora, puede ignorar todos los detalles de cómo configurar un
repositorio, administrar el acceso a los usuarios, y navegar por formatos
de fichero específicos de CVS (los cuales se cubrirán en @ref{Administracion 
del Repositorio}); de momento, nos centraremos en cómo hacer cambios en
una copia de trabajo.

Pero antes, aquí va una rápida explicación de los términos:

@itemize

@item
@dfn{Revisión} Un cambio aplicado y registrado en el historial de un fichero o
conjunto de ficheros. Una revisión es una "instantánea" de un proyecto
que cambia constantemente.

@item
@dfn{Repositorio} La copia maestra en la que CVS guarda el historial de
revisiones al completo efectuadas en un proyecto. Cada proyecto tiene
exactamente *un* repositorio.

@item
@dfn{Copia de trabajo} La copia en la que puede de hecho hacer cambios
al proyecto. Puede haber muchas copias de trabajo de un proyecto
dado. Por regla general, cada desarrollador tiene su propia copia de
trabajo.

@item
@dfn{Obtener una copia} ("check out") Solicitar una copia de trabajo al
repositorio. Su copia de trabajo refleja el estado del proyecto en el
momento de obtenerla; cuando Ud. y otros desarrolladores hacen cambios,
deben enviarlos ("commit") y actualizarlos ("update") tanto para "publicar"
sus cambios como para ver los que han hecho los demás.

@item
@dfn{Enviar} ("commit") Enviar cambios de su copia local al repositorio central.
También conocido como @dfn{check-in}.

@item
@dfn{Informe de cambios} Un comentario que se adjunta a una revisión
cuando ésta se envía, describiendo los cambios realizados. Otros pueden
leer los informes de cambios para obtener un resumen de lo que ha estado
sucediendo en un proyecto.

@item
@dfn{Actualizar} ("update") Incorporar a su copia de trabajo los cambios que
otros han hecho y están presentes en el repositorio, y comprobar si su copia
de trabajo tiene algún cambio que no ha enviado todavía. Tenga cuidado y
no confunda esto con el envío; son operaciones complementarias. Recuerde,
lo que hace una actualización es sincronizar su copia de trabajo con la
copia presente en el repositorio.

@item
@dfn{Conflicto} La situación que se da cuando dos desarrolladores intentan
enviar cambios que han hecho al mismo pasaje de un fichero. CVS se da cuenta
de ello e informa del conflicto, pero son los desarrolladores quienes
tienen que resolverlo.

@end itemize

@c ---------------------------------------------------------------------
@node Un día con CVS
@section Un día con CVS

Esta sección describe algunas operaciones básicas de CVS, para a continuación
presentarle un ejemplo de sesión de trabajo que cubre el uso que suele
hacerse de CVS. A medida que vayamos avanzando por esta guía, empezaremos
también a ver cómo funciona CVS interiormente.

Si bien no necesita comprender todos y cada uno de los detalles de CVS
para poder utilizarlo, unos conocimientos básicos de cómo funciona le
serán de inestimable ayuda a la hora de elegir la mejor forma de conseguir
un resultado. CVS se parece más a una bicicleta que a un coche, en el
sentido de que sus mecanismos son completamente transparentes para quien
le interese examinarlos. Al igual que con una bicicleta, puede subirse
encima y empezar a pedalear inmediatamente; sin embargo, si se toma algún
tiempo para aprender cómo funciona el cambio de marchas, será capaz de
utilizarlo de forma mucho más eficaz. (En el caso de CVS, no estoy seguro
de si la transparencia fue un criterio de diseño deliberado o algo
accidental, pero parece que es una propiedad compartida con muchos otros
programas libres. Las implantaciones que son visibles desde fuera tienen
la ventaja de fomentar el que los usuarios contribuyan [a mejorar el
software], exponiéndoles desde el primer momento el funcionamiento
interno del sistema.)

@ifnottex

Cada parte del recorrido hará uso de los conocimientos presentados en las
etapas anteriores. Por tanto, si ésta es su primera vez, le recomiendo que
empiece por el principio y lea el texto de forma secuencial, sin saltarse
nada. El menú presentado abajo está pensado para ser útil para los
visitantes habituales -- no debería usarlo para acceder inmediatamente
a una sección que le resulte de particular interés a menos que esté
familiarizado con el material expuesto en las secciones anteriores.
@end ifnottex

@menu
* Convenciones empleadas en este Recorrido::
* Invocación de CVS::
* Acceder a un Repositorio::
* Comenzar un nuevo Proyecto::
* Obtener una copia de trabajo::
* Versión vs. Revisión::
* Hacer un cambio::
* Ver lo que Ud. (y otros) han hecho - comandos Update y Diff::
* CVS y argumentos implícitos::
* Enviar cambios al repositorio::
* Números de revisión::
* Detección y resolución de conflictos::
* Averiguar quién hizo qué (leyendo informes de cambios)::
* Examinar y deshacer cambios::
* El método lento de deshacer cosas::
* El método rápido de deshacer cosas::
@end menu

@c ---------------------------------------------------------------------
@node Convenciones empleadas en este Recorrido
@subsection Convenciones empleadas en este Recorrido

Este recorrido tiene lugar en un entorno UNIX. CVS también funciona en
sistemas operativos Windows y Macintosh, y Tim Endres de Ice Engineering
ha escrito incluso un cliente en Java (véase http://www.trustice.com/java/jcvs),
que puede ejecutarse en cualquier lugar donde corra Java. Sin embargo,
voy a suponer que la mayoría de los usuarios de CVS -tanto actuales
como potenciales- están seguramente trabajando en un entorno UNIX basado
en línea de comandos. Si usted no figura entre éstos, los ejemplos en el
recorrido deberían ser fáciles de adaptar a otros interfaces. Una vez
que entienda los conceptos, podrá sentarse delante de cualquier interfaz
de CVS y empezar a trabajar con él (créame, yo lo he hecho muchas veces).

Los ejemplos que se presentan en este recorrido están orientados a
personas que van a usar CVS para trabajar en proyectos de programación.
Sin embargo, el uso de CVS es aplicable a todo tipo de documentos de
texto, no sólo a código fuente.

Esta guía también asume que tiene CVS ya instalado (por omisión, está ya
presente en muchos de los sistemas libres UNIX más populares, así que puede
que lo tenga ya instalado sin saberlo) y que ya dispone de acceso a un
repositorio. Incluso si no es así, puede beneficiarse de la lectura de
esta guía. En @ref{Administracion del Repositorio}, aprenderá cómo instalar
CVS y configurar repositorios.

Suponiendo que CVS esté ya instalado, debería tomarse un momento para
encontrar el manual de CVS en línea. Se conoce familiarmente como el
"Cederqvist" (tomando el apellido de Per Cederqvist, su autor original),
viene incluido con la fuente de CVS y viene a ser por lo general la
referencia más actualizada que se encuentra disponible. Está escrito
en formato Texinfo y debería estar disponible en sistemas Unix en la
jerarquía de documentación "Info". Puede leerlo con el programa de
de comandos "info":

@example
floss$ info cvs
@end example

o bien pulsando Ctrl+H y después escribiendo "i" (o Esc+x info) dentro de
Emacs. Si ninguno de estos métodos funciona para usted, consulte a su
experto local en Unix (o mire @ref{Administracion del Repositorio} para los problemas
relacionados con la instalación). Seguramente querrá tener el Cederqvist
a mano si va a usar CVS regularmente.

@c ---------------------------------------------------------------------
@node Invocación de CVS
@subsection Invocación de CVS

CVS es un sólo programa, pero puede hacer muchas cosas diferentes:
actualizar, enviar, ramificar, diferenciar, etc.. Cuando invoque a CVS
deberá especificar qué operación desea realizar. Así pues, el formato de
invocación de CVS viene a ser:

@example
floss$ cvs comando
@end example

Por ejemplo, puede usar


@example
floss$ cvs update
floss$ cvs diff
floss$ cvs commit
@end example

etcétera. (No se moleste de momento en intentar ejecutar ninguna de estas
órdenes, puesto que no harán nada mientras no disponga de una copia de
trabajo; pronto llegaremos a ese punto.)

Tanto CVS como sus comandos pueden admitir opciones. Las opciones que
afectan al comportamiento de CVS, independientemente del comando que se
ejecute, se llaman opciones globales, mientras que las opciones que son
específicas de los comandos se llaman simplemente opciones de comando.
Las opciones globales siempre van a la izquierda del comando, mientras
que las opciones de comando van a la derecha. Así, en

@example
floss$ cvs -Q update -p
@end example

-Q es una opción global, y -p es una opción del comando. (Si siente
curiosidad, -Q significa "en silencio", es decir, esta opción eliminaría
toda salida de diagnóstico y mostraría los mensajes de error únicamente
si el comando no puede cumplir con su cometido por alguna razón; por su
parte, -p forzaría el envío de los resultados de la actualización a la
salida estándar, en lugar de hacerlo a los ficheros).

@c -----------------------------------------------------------------
@node Acceder a un Repositorio
@subsection Acceder a un Repositorio

Antes de hacer nada, deberá decirle a CVS dónde se encuentra el repositorio
al que desea acceder. Esto no es problema si ya ha obtenido una copia de
trabajo de ese repositorio, dado que cualquier copia de trabajo sabe de
qué repositorio procede, con lo cual CVS puede deducir automáticamente
el repositorio al que corresponde una copia de trabajo cualquiera. Sin
embargo, vamos a suponer que no dispone usted todavía de una copia de
trabajo, así que tiene que decirle a CVS explícitamente dónde ir. Esto
se hace con la opción global -d (de "directorio", una abreviatura
para la que hay una justificación histórica, aunque la -r de "repositorio"
hubiera sido mejor), seguido por la senda que apunta al repositorio.

Por ejemplo, asumiendo que el repositorio se encuentra en el sistema local
en /usr/local/cvs (un lugar bastante estándar),

@example
floss$ cvs -d /usr/local/cvs comando
@end example

En muchos casos, sin embargo, el repositorio estará en otra máquina, y por
tanto deberá usar la red para llegar hasta él. CVS ofrece varios métodos
de acceso; cuál de ellos será el que utilice es algo que depende
fundamentalmente de los requisitos de seguridad de la máquina en la que
se encuentra alojado el repositorio (a la que, de ahora en adelante, nos
referiremos como "el servidor"). La configuración del servidor para permitir
varios métodos de acceso remoto se comenta en @ref{Administracion del Repositorio}; aquí trataremos
sólo la parte de cliente.

Afortunadamente, todos los métodos de acceso remoto comparten una misma
sintaxis de invocación. En general, para especificar un repositorio remoto
y no uno local, lo que hará es utilizar una senda más larga. Primero debe
indicar al método de acceso, delimitado en cada lado por símbolos de dos
puntos, seguido del nombre de usuario y el nombre del servidor unidos por
el símbolo @@, otros dos puntos de separación, y, finalmente, la senda
del directorio del repositorio en el servidor.

Veamos el método de acceso @dfn{pserver}, que significa "servidor autentificado
por clave":

@example
floss$ cvs -d :pserver:jluis@@cvs.foobar.com:/usr/local/cvs login
(Logging in to jluis@@cvs.foobar.com)
CVS password: (introduzca aquí su contraseña de CVS)
floss$ 
@end example

La larga senda del repositorio que sigue a la opción -d ha ordenado a
CVS que use el método de acceso pserver, con el nombre de usuario jluis,
en el servidor cvs.foobar.com, que tiene un repositorio CVS en /usr/local/cvs.
Por cierto, no hay ninguna razón para que el nombre del servidor sea
"cvs.algun_lugar.com"; esto es simplemente una convención común, pero
podría haber sido también:

@example
floss$ cvs -d :pserver:jluis@@fish.foobar.org:/usr/local/cvs comando
@end example

El comando que se ejecutó en nuestro ejemplo fue "login", que verifica
que dispone usted de autorización para trabajar en este repositorio.
CVS le pedirá una contraseña, contactando a continuación con el servidor
para verificarla. Siguiendo la costumbre Unix, "cvs login" no devolverá
ninguna información adicional si la operación tiene éxito, aunque sí
mostrará un mensaje de error si algo sale mal (por ejemplo, si la
contraseña es incorrecta).

Sólo tiene que autentificarse una vez desde su máquina local ante un
servidor CVS. Una vez que el proceso de autentificación tiene éxito, CVS
guarda la contraseña en su directorio personal, en un fichero llamado
.cvspass. CVS consultará este fichero cada vez que se conecte al repositorio
a través del método pserver, así que sólo tiene que ejecutar "login" la
primera vez que acceda a un determinado servidor de CVS desde un sistema
cliente particular. Por supuesto, puede volver a ejecutar cvs login en
cualquier momento, si por ejemplo se hubiera cambiado la contraseña.

Observación: pserver es en este momento el único método de acceso que
requiere un proceso de autentificación inicial como éste; con el resto
de métodos de acceso puede empezar a ejecutar comandos de CVS inmediatamente.

Una vez que ha guardado la información de autentificación en su fichero
.cvspass, puede ejecutar otros comandos de CVS utilizando la misma
sintaxis en la línea de comando:

@example
floss$ cvs -d :pserver:jluis@@cvs.foobar.com:/usr/local/cvs comando
@end example

Hacer que pserver funcione en Windows puede requerir un paso adicional.
Windows carece del concepto Unix de un directorio personal, así que CVS
no sabe dónde poner el fichero .cvspass; deberá especificar para ello un
lugar concreto. Generalmente se indica la raíz de la unidad C: como el
directorio personal:

@example
C:\WINDOWS> set HOME=C: 
C:\WINDOWS> cvs -d :pserver:jluis@@cvs.foobar.com:/usr/local/cvs login 
(Logging in to jluis@@cvs.foobar.com) 
CVS password: (introduzca aquí su contraseña)
C:\WINDOWS> 
@end example

Cualquier carpeta existente en la jerarquía de ficheros resultará válida,
aunque posiblemente prefiera evitar utilizar unidades de red, dado que el
contenido de su fichero .cvspass sería entonces visible para cualquiera
que pudiese acceder a esa unidad.

Además de pserver, CVS soporta también los métodos ext -que utiliza un
programa de conexión externo. como rsh ó ssh-, kserver -para el sistema
de seguridad Kerberos versión 4-, y gserver, que usa el GSSAPI, esto es,
el API de Generic Security Services, y también las versiones 5 y posteriores
de Kerberos. Todos estos métodos son similares a pserver, si bien cada uno
presenta sus propias idiosincrasias.

De ellos, el método @code{ext} es probablemente el que más se usa
habitualmente. Si tiene la posibilidad de conectarse a un servidor
mediante rsh o ssh, puede usar el método @code{ext}. Puede probarlo de
esta forma:

@example
floss$ rsh -l jluis cvs.foobar.com 
Password:  (introduzca aquí su contraseña de usuario)
@end example

Bien, vamos a asumir que ha entrado y salido con éxito del servidor
con rsh, así que ahora está de nuevo en el sistema cliente original:

@example
floss$ CVS_RSH=rsh; export CVS_RSH
floss$ cvs -d :ext:jluis@@cvs.foobar.com:/usr/local/cvs comando
@end example

La primera línea (empleando la sintaxis del shell Bourne de Unix) da a la
variable de entorno CVS_RSH el valor rsh, que le dice a CVS que utilice el
programa rsh para conectarse. La segunda línea puede ser cualquier comando
de CVS; se le solicitará su contraseña para que CVS pueda conectarse con
el servidor.

Si está en el shell C en lugar del shell Bourne, pruebe esto:


@example
floss% setenv CVS_RSH rsh
@end example

y para Windows, pruebe esto:

@example
C:\WINDOWS> set CVS_RSH=rsh
@end example

El resto de esta guía empleará la sintaxis Bourne; adapte los ejemplos
a su entorno como necesite.


Para usar ssh (el shell seguro) en lugar de rsh, basta con que cree la
variable de entorno CVS_RSH de la forma apropiada:

@example
floss$ CVS_RSH=ssh; export CVS_RSH
@end example

No se eche a temblar por el hecho de que el nombre de la variable es
CVS_RSH y Ud. le está dando el valor ssh. Hay razones históricas para
esto (la socorrida excusa Unix para todo, lo sé...). CVS_RSH puede apuntar
al nombre de cualquier programa capaz de conectarle a un servidor remoto,
ejecutar comandos y recibir su salida. Después de rsh, ssh es posiblemente
el programa más común que cumple estos requisitos, aunque probablemente
existan otros. Tenga en cuenta que este programa no debe modificar su flujo
de información de ninguna manera. Esto deja fuera al rsh de Windows NT,
puesto que convierte (o intenta convertir) entre las convenciones de fin
de línea de DOS y Unix. En su caso, deberá conseguir algún otro rsh para
Windows, o bien utilizar un método de acceso distinto.

Los métodos gserver y kserver no se utilizan tanto como los demás y no
se cubren aquí. Son bastante parecidos a lo que aquí se ha cubierto
hasta ahora; para más información sobre ellos, lea el Cederqvist.

Si sólo utiliza un repositorio y no quiere estar constantemente tecleando
"-d repositorio", sólo tiene que crear la variable de entorno CVSROOT
(que quizás debería haber sido llamada CVSREPOS, pero ya es demasiado
tarde para eso):

@example
floss$ CVSROOT=/usr/local/cvs 
floss$ export CVSROOT 
floss$ echo $CVSROOT 
/usr/local/cvs 
floss$ 
@end example

o quizás

@example
floss$ CVSROOT=:pserver:jluis@@cvs.foobar.com:/usr/local/cvs 
floss$ export CVSROOT 
floss$ echo $CVSROOT 
:pserver:jluis@@cvs.foobar.com:/usr/local/cvs 
floss$ 
@end example

El resto de esta guía asume que ya ha creado la variable CVSROOT apuntando
a su repositorio favorito, así que los ejemplos no mostrarán la opción
-d. Si necesita acceder a muchos repositorios distintos, no debería crear
la variable CVSROOT, sino limitarse a usar "-d repositorio" para indicar
el repositorio a utilizar.

@c ---------------------------------------------------------------------
@node Comenzar un nuevo Proyecto
@subsection Comenzar un nuevo Proyecto

Si está estudiando el manejo de CVS para trabajar en un proyecto que ya
se encuentra bajo control de CVS (es decir, que se guarda en un repositorio
en alguna parte), probablemente querrá saltarse esta parte e ir directamente
a la siguiente, "Obtener una copia de trabajo". Sin embargo, si lo que desea
es tomar un código fuente ya existente y ponerlo bajo CVS, esta sección es
para usted. Fíjese en que, a pesar de todo, se asume que dispone de acceso
a un repositorio; vea @ref{Administracion del Repositorio} si necesita configurar un
repositorio.

Introducir un nuevo proyecto en un repositorio de CVS es lo que se conoce como
@dfn{importar}. El comando CVS a utilizar, como quizás ya haya adivinado, es

@example
floss$ cvs import
@end example

excepto que le hacen falta más opciones (y debe estar en el sitio
apropiado) para que el comando tenga éxito. Primero, vaya al directorio
raíz de su árbol de proyectos:

@example
floss$ cd miproyecto
floss$ ls
README.txt  a-subdir/   b-subdir/   hello.c
floss$
@end example

Este proyecto tiene dos ficheros (README.txt y hello.c) en el nivel
más alto, además de dos subdirectorios (a-subdir y b-subdir), y algunos
ficheros más (no mostrados en el ejemplo) dentro de esos subdirectorios.
Al importar un proyecto, CVS importa todo lo que hay en el árbol, empezando
por el directorio actual y yendo a continuación a todos los directorios que
haya por debajo de éste. Por tanto, debería asegurarse de que sólo los
ficheros que hay en este momento en el árbol son los que desea que formen
parte del proyecto de forma permanente. Cualquier vieja copia de seguridad,
borrador, etc., deberían ser eliminados antes.

La sintaxis general del comando de importación es

@example
floss$ cvs import -m "mensaje" miproyecto marca_suministrador marca_lanzamiento
@end example

La opción -m (de "mensaje") sirve para especificar un breve informe
que describe la importación. Éste será el primer informe de cambios
que afecta al proyecto en todo su conjunto; cada envío realizado en
el futuro tendrá su propio informe de cambios. Estos informes son obligatorios;
si no se utiliza la opción -m, CVS lanzará automáticamente un editor
(consultando previamente la variable de entorno EDITOR) para que escriba
en él el informe a utilizar. Una vez que guarde el informe en disco y
salga del editor, el proceso de importación seguirá adelante.

El siguiente argumento es el nombre del proyecto (usaremos "miproyecto").
Éste es el nombre con el cual podrá obtener copias desde el repositorio.
(Lo que realmente sucede es que se crea un directorio con ese nombre en el
repositorio; encontrará más información al respecto en @ref{Administracion del Repositorio}.)  El nombre
que elija no tiene por qué ser igual al del directorio actual, aunque
en la mayoría de los casos lo será.

Los argumentos marca_suministrador y marca_lanzamiento son información de
registro adicional para CVS. No se preocupe de ellos ahora; poco importa
lo que utilice en este momento. En @ref{CVS avanzado} podrá ver las raras ocasiones
en las que son significativos; por ahora, utilizaremos un nombre de usuario y
"start" respectivamente para estos dos argumentos.

Así pues, ya estamos listos para utilizar import:

@example
floss$ cvs import -m "importación inicial a CVS" miproyecto jluis start
N miproyecto/hello.c
N miproyecto/README.txt
cvs import: Importing /usr/local/cvs/miproyecto/a-subdir
N miproyecto/a-subdir/loquesea.c
cvs import: Importing /usr/local/cvs/miproyecto/a-subdir/subsubdir
N miproyecto/a-subdir/subsubdir/fish.c
cvs import: Importing /usr/local/cvs/miproyecto/b-subdir
N miproyecto/b-subdir/random.c

No conflicts created by this import
floss$
@end example

¡Enhorabuena! Si ha ejecutado este comando (o algo similar), ya ha hecho por
fin algo que afecta al repositorio.

Observando la salida del comando import, se dará cuenta de que CVS precede
cada nombre de fichero con una letra, en este caso la "N" para indicar que
se trata de un nuevo fichero. El uso de una letra a la izquierda para indicar
el estado de un fichero es algo común en la salida de los comandos de CVS,
tal como veremos más adelante también con los comandos "update" y "checkout".

Llegados a este punto, podría pensar que, puesto que ha importado el proyecto,
puede empezar a trabajar en el árbol inmediatamente. Éste, sin embargo, no es
el caso: el árbol de directorios actual no es todavía una copia de trabajo de
CVS. Fue el origen para el comando de importación, cierto, pero no por éso se
ha convertido por arte de magia en una copia de trabajo de CVS: para obtener
una copia en la que poder trabajar, deberá tomarla del repositorio.

Pero antes, sin embargo, quizás quiera archivar el árbol de directorios
actual. El motivo es que, una vez que las fuentes están en CVS, no querrá
liarse y editar por error copias que no están bajo control de versión
(puesto que esos cambios no se convertirán en parte del historial del
proyecto). De ahora en adelante querrá hacer todas las ediciones sobre la
copia de trabajo. Por otra parte, no le interesará eliminar completamente
el árbol que ha importado, puesto que no ha verificado todavía si el
repositorio dispone realmente de todos los ficheros. Por supuesto, puede
estar un 99.999% seguro de que es así dado que el comando de importación
no devolvió ningún error, pero, ¿por qué correr riesgos? A menudo vale la
pena ser paranoico, como puede confirmarle cualquier programador. Así que
haga algo como esto:

@example
floss$ ls
README.txt  a-subdir/   b-subdir/   hello.c
floss$ cd ..
floss$ ls
miproyecto/
floss$ mv miproyecto era_miproyecto
floss$ ls
era_miproyecto/
floss$
@end example

Hecho. Ahora sigue teniendo los ficheros originales, pero están claramente
marcados como correspondientes a una versión obsoleta, así que no estarán
ahí estorbándole cuando obtenga una verdadera copia de trabajo. Ahora sí,
por fin, está listo para obtenerla.

@c ------------------------------------------------------------------
@node Obtener una copia de trabajo
@subsection Obtener una copia de trabajo

El comando para obtener un proyecto es exactamente el que cree que es:

@example
floss$ cvs checkout miproyecto
cvs checkout: Updating miproyecto 
U miproyecto/README.txt 
U miproyecto/hello.c 
cvs checkout: Updating miproyecto/a-subdir 
U miproyecto/a-subdir/loquesea.c 
cvs checkout: Updating miproyecto/a-subdir/subsubdir 
U miproyecto/a-subdir/subsubdir/fish.c 
cvs checkout: Updating miproyecto/b-subdir 
U miproyecto/b-subdir/random.c

floss$ ls 
miproyecto/      era_miproyecto/ 
floss$ cd miproyecto 
floss$ ls 
CVS/        README.txt  a-subdir/   b-subdir/   hello.c 
floss$ 
@end example

Guau... ¡su primera copia de trabajo! Su contenido es exactamente el
mismo que el que ha importado, con el añadido de un subdirectorio
llamado "CVS". Ahí es donde CVS guarda la información de control de
versiones. De hecho, cada directorio presente en el proyecto tiene un
subdirectorio CVS:

@example
floss$ ls a-subdir
CVS/        subsubdir/  loquesea.c 
floss$ ls a-subdir/subsubdir/ 
CVS/    fish.c 
floss$ ls b-subdir
CVS/      random.c
@end example

El hecho de que CVS guarde la información de revisiones en subdirectorios
llamados CVS conlleva que su proyecto no puede tener nunca subdirectorios
propios llamados CVS. En la práctica, nunca he oído que esto supusiese un
problema.

Antes de editar ningún fichero, echemos una ojeada a la caja negra:

@example
floss$ cd CVS 
floss$ ls 
Entries     Repository  Root 
floss$ cat Root 
/usr/local/cvs 
floss$ cat Repository 
miproyecto 
floss$ 
@end example

Nada misterioso por aquí. El fichero Root apunta al repositorio, y el fichero
Repository apunta a un proyecto dentro del repositorio. Si esto le parece un
poco confuso, permítame que se lo explique.

Hay una confusión muy extendida sobre la terminología empleada en CVS,
y es que la palabra "repositorio" se utiliza para hacer referencia a dos
cosas distintas. A veces, se utiliza para aludir al directorio raíz del
repositorio (por ejemplo, /usr/local/cvs), que puede contener muchos
proyectos; esto es a lo que se refiere el fichero Root. Pero, otras veces,
se refiere a un subdirectorio particular específico de un proyecto dentro
de la raíz de un repositorio (por ejemplo /usr/local/cvs/miproyecto,
/usr/local/cvs/tuproyecto, o /usr/local/cvs/fish). El fichero "Repository"
dentro de un subdirectorio CVS toma el segundo significado.

En este libro, "repositorio" generalmente significa "raíz", es decir, el
repositorio situado en el nivel más alto, si bien, ocasionalmente, se
usará para hacer referencia a un subdirectorio específico de un proyecto.
Si el sentido que se le intenta dar no queda claro dentro del contexto,
habrá texto que lo clarifique. Tenga en cuenta que el fichero "Repository"
puede a veces contener la senda absoluta al nombre del proyecto en lugar
de una senda relativa. Esto hace un tanto redundante al fichero Root:

@example
floss$ cd CVS 
floss$ cat Root 
:pserver:jluis@@cvs.foobar.com:/usr/local/cvs 
floss$ cat Repository 
/usr/local/cvs/miproyecto 
floss$ 
@end example

El fichero "Entries" contiene información sobre cada uno de los ficheros
que forman parte del proyecto. Cada línea se corresponde con un fichero,
y sólo hay líneas para ficheros o subdirectorios en el directorio padre
inmediato. Éste es el fichero CVS/Entries del directorio raíz de miproyecto:

@example
floss$ cat Entries 
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999// 
/hello.c/1.1.1.1/Sun Apr 18 18:18:22 1999// 
D/a-subdir//// 
D/b-subdir////
@end example

El formato de cada línea es


@example
/nombre de fichero/número de revisión/fecha de última modificación//
@end example

y las líneas de directorios vienen precedidas de la letra "D". En realidad,
CVS no guarda un historial de los cambios realizados en los directorios,
así que los campos de número de revisión y fecha están vacíos.

Las marcas de fecha guardan la fecha y hora de la última actualización
(en horario universal, no local) de los ficheros presentes en la copia de
trabajo. De esta forma, CVS puede saber fácilmente si un fichero ha sido
modificado desde la última obtención de copia de trabajo, actualización
o envío. Si la fecha registrada por el sistema de ficheros difiere de la
fecha anotada en el fichero CVS/Entries, CVS sabe (sin ni siquiera tener que
consultar el repositorio) que el fichero ha sido probablemente modificado.

Si examina los ficheros CVS/* en uno de los subdirectorios

@example
floss$ cd a-subdir/CVS 
floss$ cat Root 
/usr/local/cvs 
floss$ cat Repository 
miproyecto/a-subdir 
floss$ cat Entries 
/loquesea.c/1.1.1.1/Sun Apr 18 18:18:22 1999// 
D/subsubdir//// 
floss$ 
@end example

verá que el repositorio raíz no ha cambiado, pero el fichero "Repository"
indica la situación de este subdirectorio dentro del proyecto, y el
fichero "Entries" contiene líneas distintas.

Inmediatamente después de hacer una importación, el número de revisión
de cada fichero en el proyecto se muestra como 1.1.1.1. Este número
inicial de revisión es un caso un poco especial, así que no lo veremos
en detalle aún; echaremos un vistazo más de cerca a los números de
revisión una vez que hayamos hecho algunos cambios.

@c ------------------------------------------------------------------
@node Versión vs. Revisión
@subsection Versión vs. Revisión

El número interno de revisión que CVS guarda para cada fichero no tiene
nada que ver con el número de versión del producto del que los ficheros
forman parte. Por ejemplo, puede tener un proyecto formado por tres ficheros,
cuyos números internos de revisión a 3 de mayo de 1999 eran 1.2, 1.7 y 2.48.
Ese mismo día, empaqueta una nueva distribución del programa y la distribuye
como ChachiSoft Versión 3. Esto es una decisión puramente de marketing y no
afecta para nada a las revisiones de CVS. Los números de revisión de CVS
son invisibles para sus clientes (a menos que les dé acceso al repositorio);
el único número visible al público es el "3" de Versión 3. Por lo que respecta
a CVS, podría haberlo llamado Versión 1729 si lo desease; el número de versión
(o de distribución) no tiene nada que ver con el seguimiento interno de
cambios que realiza CVS.

Para evitar confusiones, emplearé la palabra "revisión" para referirme
solamente a los números de revisión interna de los ficheros controlados
por CVS. A pesar de ello, me tomaré la libertad de llamar a CVS un
"sistema de control de versiones", puesto que "sistema de control de
revisiones" suena demasiado pedante.

@c -------------------------------------------------------------------
@node Hacer un cambio
@subsection Hacer un cambio

El proyecto, tal y como está en estos momentos, no hace mucho. Aquí están
los contenidos de hello.c:

@example
floss$ cat hello.c 
#include <stdio.h>

void 
main () 
@{
   printf ("¡Hola, mundo!\n"); 
@}
@end example

Ea, vamos a realizar nuestro primer cambio al proyecto desde que lo
importamos; vamos a añadir la línea
  
@example
printf ("¡Adiós, mundo!\n");
@end example

justo después de "¡Hola, mundo!". Llame a su editor favorito y haga el
cambio:

@example
floss$ emacs hello.c
  ... 
@end example

Éste ha sido un cambio relativamente sencillo, en el que es poco posible
que olvide lo que hizo. Pero en un proyecto más amplio, y más complejo,
es muy posible que se ponga a editar un fichero, sea interrumpido por otra
cosa, y, cuando vuelva varios días más tarde, sea incapaz de recordar
exactamente lo que hizo, o incluso si cambió algo en absoluto. Lo cual nos
trae a nuestra primera situación "CVS salva su vida": comparar su copia de
trabajo con la que se encuentra en el repositorio.

@c -----------------------------------------------------------------
@node Ver lo que Ud. (y otros) han hecho - comandos Update y Diff
@subsection Ver lo que Ud. (y otros) han hecho - comandos Update y Diff

Hasta ahora nos hemos referido a la "actualización" como una forma de
traer a su copia de trabajo los cambios que se han realizado en el
repositorio, es decir, como una manera de obtener los cambios hechos
por otras personas. Sin embargo, la actualización es un proceso algo
más complejo que esto, puesto que compara el estado global de su copia
de trabajo con el estado del proyecto que se encuentra en el repositorio.
Incluso si nada ha cambiado en el repositorio desde que se obtuvo la
copia, puede que algo en la copia de trabajo sí lo haya hecho, y
"update" también le mostrará esto:

@example
floss$ cvs update 
cvs update: Updating . 
M hello.c 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir
@end example

La "M" al lado de hello.c significa que el fichero ha sido modificado
desde que se obtuvo la copia, y que las modificaciones no se han enviado
aún al repositorio.

A veces, todo lo que necesita es simplemente saber qué ficheros ha
editado. Sin embargo, si desea echar un vistazo más de cerca a los
cambios, puede solicitar un informe detallado en formato diff. El
comando diff compara los ficheros que puedan haberse modificado en
la copia de trabajo con sus homónimos en el repositorio, mostrando
a continuación cualquier posible diferencia:


@example
floss$ cvs diff 
cvs diff: Diffing . 
Index: hello.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.1.1.1 
diff -r1.1.1.1 hello.c 
6a7 
>   printf ("¡Adiós, mundo!\n"); 
cvs diff: Diffing a-subdir 
cvs diff: Diffing a-subdir/subsubdir 
cvs diff: Diffing b-subdir
@end example

Aunque un poco liosa, esta información es útil, si bien todavía hay un
montón de ruido ahí. Para empezar, puede ignorar la mayor parte de las
líneas del comienzo, dado que sólo hacen referencia al nombre del fichero
del repositorio e indican el número de la última revisión enviada al mismo.
Son datos útiles en otras circunstancias (las veremos en detalle más
adelante), pero no las necesita cuando sólo quiere hacerse una idea de
los cambios que se han hecho en la copia de trabajo.

Una molestia más seria a la hora de leer el diff es que CVS anuncia su
entrada en escena a medida que va entrando en cada directorio durante la
actualización. Esto puede ser útil durante largas actualizaciones en
grandes proyectos, puesto que le da una idea del tiempo que va a necesitar
el comando, pero ahora mismo lo único que hace es molestarle mientras
intenta interpretar lo que está leyendo. Así pues, digámosle a CVS que
no diga nada sobre su trabajo, con la opción global -Q (de "Que te
calles", obviamente):

@example
floss$ cvs -Q diff 
Index: hello.c 
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.1.1.1 
diff -r1.1.1.1 hello.c 
6a7 
>   printf ("¡Adiós, mundo!\n");
@end example

Mejor - al menos, parte del ruido ha desaparecido. Sin embargo, el diff
es aún difícil de leer. Le está diciendo que en la línea 6 se añadió una
línea nueva (que se convirtió en la línea 7) cuyo contenido es:

@example
printf ("¡Adiós, mundo!\n");
@end example

El signo ">" que precede a la línea en el diff le dice que esta línea está
presente en la nueva versión del fichero, pero no en la antigua.

Sin embargo, el formato podría ser aún más legible. Muchas personas
encuentran el formato "de contexto" de diff más fácil de leer, porque
muestra menos líneas de contexto delimitando los cambios. Los diffs de
contexto pueden generarse pasando a diff la opción -c:

@example
floss$ cvs -Q diff -c 
Index: hello.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.1.1.1 
diff -c -r1.1.1.1 hello.c 
*** hello.c     1999/04/18 18:18:22     1.1.1.1 
--- hello.c     1999/04/19 02:17:07 
*************** 
*** 4,7 **** 
---4,8 -- 
  main () 
  @{
    printf ("¡Hola, mundo!\n"); 
+   printf ("¡Adiós, mundo!\n"); 
  @}
@end example

¡Esto sí está claro! Incluso si no está acostumbrado a leer diffs de
contexto, un vistazo a esta información mostrará de forma bastante
obvia lo que ha sucedido: se añadió una nueva línea (el + en la primera
columna significa que se ha añadido una línea) entre la línea que
imprime "¡Hola, mundo!" y la llave final.

No es necesario que seamos capaces de interpretar perfectamente los diffs
de contexto (esto es trabajo para el programa "patch"), pero le será útil
tomarse un tiempo para adquirir al menos una cierta familiaridad con el
formato. Las primeras dos líneas (después del rollo del comienzo) son

@example
*** hello.c     1999/04/18 18:18:22     1.1.1.1 
--- hello.c     1999/04/19 02:17:07
@end example

y le dicen qué se está comparando con qué. En este caso, la revisión
1.1.1.1 de hello.c se está comparando con una versión modificada del
mismo fichero (motivo por el cual no aparece número alguno de revisión
en la segunda línea, porque los cambios de la copia de trabajo no se
han enviado todavía al repositorio). Las líneas de asteriscos y guiones
identifican secciones situadas más adelante en el fichero de diferencias.
Más adelante, una línea de asteriscos seguida de una franja de valores
precede a una sección del fichero original. Después, una línea de guiones,
con una franja de números de línea nuevos y potencialmente distintos,
precede a una sección del fichero modificado. Estas secciones están
organizadas por pares: por un lado la parte del fichero antiguo, y por
otro lado la parte del fichero nuevo.

Nuestro fichero de diferencias tiene uno de estos pares:


@example
*************** 
*** 4,7 **** 
--- 4,8 -- 
  main () 
  @{ 
    printf ("¡Hola, mundo!\n"); 
+   printf ("¡Adiós, mundo!\n"); 
  @}
@end example

La primera sección del par está vacía, lo que significa que no se ha
eliminado nada del fichero original. La segunda sección indica que, en
el lugar correspondiente del nuevo fichero, se ha añadido una nueva
línea, que aparece marcada con un signo "+". (Cuando el diff cita partes
de ficheros, se reserva las primeras dos columnas a la izquierda para códigos
especiales, como el "+", así que el trozo entero aparenta estar justificado
a la izquierda con dos espacios. Esta justificación extra desaparece, por
supuesto, cuando se aplica el fichero de diferencias.)

La franja de números de líneas muestra el alcance del par de diferencias,
incluyendo líneas de contexto. En el fichero original, el par estaba en las
líneas 4 a la 7; en el nuevo fichero, son las líneas 4 a la 8 debido a la
nueva línea que se ha añadido. Fíjese en que el fichero de diferencias no
necesita enseñar ninguna cosa del fichero original puesto que no se ha
eliminado nada; sólo nos ha mostrado la franja afectada y ha continuación
ha saltado a la segunda sección del par de diferencias.

Aquí hay otro diff de contexto, procedente esta vez de un proyecto real mío:

@example
floss$ cvs -Q diff -c 
Index: cvs2cl.pl 
=================================================================== 
RCS file: /usr/local/cvs/kfogel/code/cvs2cl/cvs2cl.pl,v 
retrieving revision 1.76 
diff -c -r1.76 cvs2cl.pl 
*** cvs2cl.pl   1999/04/13 22:29:44     1.76 
--- cvs2cl.pl   1999/04/19 05:41:37 
*************** 
*** 212,218 **** 
          # can contain uppercase and lowercase letters, digits, '-', 
          # and '_'. However, it's not our place to enforce that, so 
          # we'll allow anything CVS hands us to be a tag: 
!         /^\s([^:]+): ([0-9.]+)$/;
          push (@@@{$symbolic_names@{$2@}@}, $1);
        @}
      @}
-- 212,218 --
          # can contain uppercase and lowercase letters, digits, '-',
          # and '_'. However, it's not our place to enforce that, so
          # we'll allow anything CVS hands us to be a tag:
!         /^\s([^:]+): ([\d.]+)$/;
          push (@@@{$symbolic_names@{$2@}@}, $1);
        @}
      @}
@end example

El signo de exclamación indica que la línea marcada difiere del fichero
antiguo al nuevo. Dado que no hay ningún signo "+" o "-", sabemos que el
número total de líneas del fichero sigue siendo el mismo.

Éstas son otras diferencias de contexto del mismo proyecto, esta vez un poco
más complejas:

@example
floss$ cvs -Q diff -c 
Index: cvs2cl.pl 
=================================================================== 
RCS file: /usr/local/cvs/kfogel/code/cvs2cl/cvs2cl.pl,v 
retrieving revision 1.76 
diff -c -r1.76 cvs2cl.pl 
*** cvs2cl.pl   1999/04/13 22:29:44     1.76 
--- cvs2cl.pl   1999/04/19 05:58:51 
*************** 
*** 207,217 **** 
@}
        else    # we're looking at a tag name, so parse & store it
        @{
-         # According to the Cederqvist manual, in node "Tags", "Tag
-         # names must start with an uppercase or lowercase letter and
-         # can contain uppercase and lowercase letters, digits, '-',
-         # and '_'. However, it's not our place to enforce that, so
-         # we'll allow anything CVS hands us to be a tag:
          /^\s([^:]+): ([0-9.]+)$/;
          push (@@@{$symbolic_names@{$2@}@}, $1);
        @}
- 207,212 --
***************
*** 223,228 ****
--- 218,225 --
      if (/^revision (\d\.[0-9.]+)$/) @{
        $revision = "$1";
      @}
+ 
+     # Esta línea ha sido añadida, lo admito, sólo para este ejemplo de diff.
  
      # If have file name but not time and author, and see date or
      # author, then grab them:
@end example

Este fichero diff tiene dos pares de diferencias. En el primero se han
eliminado cinco líneas (estas líneas se muestran sólo en la primera
sección del par, y la cuenta de líneas de la segunda sección indica que
tiene menos líneas).  Una línea continua de asteriscos hace las veces de
delimitador entre pares, y en el segundo par vemos que se han añadido dos
líneas: una línea en blanco y un comentario inútil. Observe cómo los números
de línea compensan el efecto del par anterior. En el fichero original, la
franja del segundo par iba desde 223 hasta 228; en el nuevo fichero,
dado que la eliminación tuvo lugar en el primer par, la franja de líneas
abarca desde la 218 hasta la 225.

Enhorabuena, en este momento tiene posiblemente toda la experiencia que
necesita para poder interpretar ficheros de diferencias.

@c --------------------------------------------------------------------
@node CVS y argumentos implícitos
@subsection CVS y argumentos implícitos

En cada uno de los comandos de CVS explicados hasta el momento, quizás
se haya dado cuenta de que no hemos indicado fichero alguno en la línea
de comando. Por ejemplo, hemos utilizado

@example
floss$ cvs diff
@end example

en lugar de

@example
floss$ cvs diff hello.c
@end example

y

@example
floss$ cvs update
@end example

en lugar de 

@example
floss$ cvs update hello.c
@end example

El principio que dicta esto es que si usted no indica ningún nombre de
fichero, CVS actuará sobre todos los ficheros sobre los que el comando
resultaría apropiado. Esto incluye también ficheros en subdirectorios
situados por debajo del directorio actual; CVS automáticamente desciende
desde el directorio actual hasta cada subdirectorio en el árbol. Por
ejemplo, si modificó b-subdir/random.c y a-subdir/subsubdir/fish.c,
invocar una actualización podría devolver unos resultados como éstos:

@example
floss$ cvs update 
cvs update: Updating . 
M hello.c 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
M a-subdir/subsubdir/fish.c 
cvs update: Updating b-subdir 
M b-subdir/random.c 
floss$ 
@end example

o mejor aún:

@example
floss$ cvs -q update 
M hello.c 
M a-subdir/subsubdir/fish.c 
M b-subdir/random.c 
floss$ 
@end example

Nota: La opción -q es una versión "ligera" de -Q. Si se hubiera usado -Q,
el comando no habría mostrado nada en absoluto, porque las notas de
modificación son consideradas mensajes de información no esenciales.
La versión en minúsculas, -q, es menos estricta: suprime los mensajes
que posiblemente no queramos, a la vez que permite que otros mensajes,
posiblemente más útiles, sí lleguen hasta nosotros.


También puede nombrar ficheros específicos que desee actualizar:

@example
floss$ cvs update hello.c b-subdir/random.c  
M hello.c 
M b-subdir/random.c 
floss$ 
@end example

y CVS sólo examinará estos ficheros, ignorando cualquier otro.

Lo cierto es que es más habitual no limitar la actualización a
determinados ficheros, puesto que en la mayoría de los casos querrá
actualizar el árbol de directorios al completo de una sola vez. En todo
caso, recuerde que las actualizaciones que hacemos aquí a modo de ejemplo
sólo muestran que algunos ficheros se han modificado de forma local, porque
aún no se ha cambiado nada en el repositorio. Cuando otras personas están
trabajando en el mismo proyecto que usted, siempre existe la posibilidad de
que la actualización incorpore algunos cambios nuevos del repositorio en
sus ficheros locales, en cuyo caso sí puede resultarle útil indicar los
ficheros en concreto que desea actualizar.

El mismo principio puede aplicarse a otros comandos de CVS. Por ejemplo,
con diff, puede ver los cambios habidos en un fichero cada vez:

@example
floss$ cvs diff -c b-subdir/random.c  
Index: b-subdir/random.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 random.c
*** b-subdir/random.c   1999/04/18 18:18:22     1.1.1.1
--- b-subdir/random.c   1999/04/19 06:09:48
***************
*** 1 ****
! /* Un fichero en C completamente vacío. */
--- 1,8 --
! /* Imprimir un número aleatorio. */
! 
! #include <stdio.h>
! 
! void main ()
! @{
!   printf ("un número aleatorio\n");
! @}
@end example

o ver todos los cambios de una sola vez (agárrese al asiento, esto va a ser un
diff bastante grande): 

@example
floss$ cvs -Q diff -c
Index: hello.c
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 hello.c
*** hello.c     1999/04/18 18:18:22     1.1.1.1
--- hello.c     1999/04/19 02:17:07
***************
*** 4,7 ****
--- 4,8 --
  main ()
  @{
    printf ("¡Hola, mundo!\n");
+   printf ("¡Adiós, mundo!\n");
  @}
Index: a-subdir/subsubdir/fish.c
===================================================================
RCS file: /usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 fish.c
*** a-subdir/subsubdir/fish.c   1999/04/18 18:18:22     1.1.1.1
--- a-subdir/subsubdir/fish.c   1999/04/19 06:08:50
***************
*** 1 ****
! /* Un fichero en C completamente vacío. */
--- 1,8 --
! #include <stdio.h>
! 
! void main ()
! @{
!   while (1) @{
!     printf ("fish\n");
!   @}
! @}
Index: b-subdir/random.c
===================================================================
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 random.c
*** b-subdir/random.c   1999/04/18 18:18:22     1.1.1.1
--- b-subdir/random.c   1999/04/19 06:09:48
***************
*** 1 ****
! /* Un fichero en C completamente vacío. */
--- 1,8 --
! /* Imprimir un número aleatorio. */
! 
! #include <stdio.h>
! 
! void main ()
! @{
!   printf ("un número aleatorio\n");
! @}
@end example

En cualquier caso, como puede ver en estos diffs, queda claro que el proyecto
está listo para debutar. Enviemos los cambios al repositorio.

@c -------------------------------------------------------------------
@node Enviar cambios al repositorio
@subsection Enviar cambios al repositorio

El comando @dfn{commit} envía las modificaciones al repositorio. Si no indica
ningún fichero, el comando enviará todos los cambios al repositorio; sin
embargo, si así lo prefiere, puede indicarle el nombre de uno o más ficheros
concretos a enviar, en cuyo caso el resto de los ficheros serán ignorados.

Aquí enviamos un fichero nombrándolo expresamente, y otros dos por alusiones:

@example
floss$ cvs commit -m "ahora también dice adiós" hello.c
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <--  hello.c
new revision: 1.2; previous revision: 1.1
done
floss$ cvs commit -m "añadido código C"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in a-subdir/subsubdir/fish.c;
/usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v  <--  fish.c
new revision: 1.2; previous revision: 1.1
done
Checking in b-subdir/random.c;
/usr/local/cvs/miproyecto/b-subdir/random.c,v  <--  random.c
new revision: 1.2; previous revision: 1.1
done
floss$ 
@end example

Deténgase un momento a leer la salida detenidamente. La mayor parte de
lo que dice se explica por sí solo. Una cosa de la que tal vez se dé
cuenta es que los números de revisión se han incrementado (como era de
esperar), pero las revisiones originales se listan como 1.1 en
lugar de 1.1.1.1 como vimos anteriormente para el caso del fichero
Entries.

Hay una explicación para esta discrepancia, pero no es muy importante,
y tiene que ver con un significado especial que CVS da a la revisión
1.1.1.1: en la mayor parte de los casos, podemos decir simplemente que
los ficheros reciben un número de revisión 1.1 al hacer una importación,
pero, -por motivos que sólo CVS conoce- el número aparece como 1.1.1.1
en el fichero Entries hasta que el fichero es enviado al repositorio
por primera vez.

@c -----------------------------------------------------------------
@node Números de revisión
@subsection Números de revisión

Cada fichero en un proyecto tiene su propio número de revisión. Cuando
un fichero es enviado al repositorio, la última parte del número de revisión
se incrementa en una unidad. Por tanto, los diferentes ficheros que forman
parte de un proyecto pueden tener siempre números de revisión (a veces
muy) diferentes. Esto sólo significa que algunos ficheros han sido
modificados (e incorporados en el repositorio) con más frecuencia que
otros.

En este momento quizás se pregunte qué sentido tiene la parte situada a
la izquierda del punto decimal, cuando la única parte que cambia es la
situada a la derecha. Pues bien, a pesar de que CVS nunca incrementa
automáticamente el número situado a la izquierda, este número puede ser
incrementado a petición del usuario. Esto es algo que se usa en muy
contadas ocasiones, y no lo cubriremos en esta guía.

Volviendo al tema, en el proyecto de ejemplo que hemos estado usando,
acabábamos de enviar al repositorio los cambios que habíamos realizado
en tres ficheros. Cada uno de estos ficheros es ahora la revisión 1.2,
pero el resto de ficheros del proyecto son aún la revisión 1.1. Cuando
usted solicita al repositorio una copia de un proyecto, siempre obtiene
la última revisión de cada fichero allí presente. Esto es lo que el usuario
mperez vería si ahora mismo solicitase una copia de miproyecto y observase
los números de revisión del directorio raíz:

@example
paste$ cvs -q -d :pserver:mperez@@cvs.foobar.com:/usr/local/cvs co miproyecto
U miproyecto/README.txt
U miproyecto/hello.c
U miproyecto/a-subdir/loquesea.c
U miproyecto/a-subdir/subsubdir/fish.c
U miproyecto/b-subdir/random.c
paste$ cd miproyecto/CVS
paste$ cat Entries
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//
/hello.c/1.2/Mon Apr 19 06:35:15 1999//
D/a-subdir////
D/b-subdir////
paste$ 
@end example

El fichero hello.c (entre otros) se encuentra ahora en su revisión 1.2,
mientras que el fichero README.txt está aún en la revisión inicial
(1.1.1.1, también conocida como 1.1).


Si mperez añade ahora la línea

@example
printf ("entre hola y adiós\n");
@end example

a hello.c y lo envía, el número de revisión del fichero se incrementará
una vez más:

@example
paste$ cvs ci -m "añadida una nueva línea entremedias"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <--  hello.c
new revision: 1.3; previous revision: 1.2
done
paste$ 
@end example

Ahora hello.c está en la revisión 1.3, fish.c y random.c están aún en
la revisión 1.2, y los demás ficheros en la revisión 1.1.

Observe que el comando fue dado como cvs ci en lugar de cvs commit.  La
mayor parte de los comandos CVS tienen una forma abreviada, para hacer
más fácil el escribirlos. Para checkout, update y commit, las versiones
abreviadas son co, up y ci, respectivamente. Puede obtener una lista de
todas las formas abreviadas ejecutando el comando @w{@code{cvs --help-synonyms}}.

Normalmente puede ignorar el número de revisión de un fichero. En la
mayoría de los casos, estos números son simplemente anotaciones
internas que CVS gestiona automáticamente. Sin embargo, ser capaz de
encontrar y comparar números de revisión es algo muy útil cuando tiene que
obtener (o establecer diferencias respeto a) una copia antigua del fichero.

Examinar el fichero Entries no es la única forma de descubrir un número
de revisión. Puede usar también el comando status:

@example
paste$ cvs status hello.c
===================================================================
File: hello.c           Status: Up-to-date

   Working revision:    1.3     Tue Apr 20 02:34:42 1999
   Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)
@end example

el cual, cuando se invoca sin nombrar ningún fichero, muestra el estado
de todos los ficheros que conforman el proyecto:

@example
paste$ cvs status
cvs status: Examining.
===================================================================
File: README.txt        Status: Up-to-date

   Working revision:    1.1.1.1 Sun Apr 18 18:18:22 1999
   Repository revision: 1.1.1.1 /usr/local/cvs/miproyecto/README.txt,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

===================================================================
File: hello.c           Status: Up-to-date

   Working revision:    1.3     Tue Apr 20 02:34:42 1999
   Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

cvs status: Examining a-subdir
===================================================================
File: loquesea.c        Status: Up-to-date

   Working revision:    1.1.1.1 Sun Apr 18 18:18:22 1999
   Repository revision: 1.1.1.1 /usr/local/cvs/miproyecto/a-subdir/loquesea.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

cvs status: Examining a-subdir/subsubdir
===================================================================
File: fish.c            Status: Up-to-date

   Working revision:    1.2     Mon Apr 19 06:35:27 1999
   Repository revision: 1.2     /usr/local/cvs/miproyecto/
                                a-subdir/subsubdir/fish.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

cvs status: Examining b-subdir
===================================================================
File: random.c          Status: Up-to-date

   Working revision:    1.2     Mon Apr 19 06:35:27 1999
   Repository revision: 1.2     /usr/local/cvs/miproyecto/b-subdir/random.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

paste$ 
@end example

Limítese a ignorar las partes de la salida que no entienda; de hecho, éste
es por regla general un buen consejo al utilizar CVS. A menudo, el pequeño
trozo de información que está buscando vendrá acompañado de otra mucha
información que no le interesa, y que quizás ni siquiera comprenda. Esta
situación es normal; simplemente tome lo que necesite y olvídese de todo
lo demás.

En el ejemplo anterior, las partes que nos interesan son las primeras
tres líneas (sin contar la línea en blanco) de la información de estado
de cada fichero. La primera línea es la más importante, puesto que le dice
el nombre del fichero y su estado en la copia de trabajo. Todos los ficheros
están en este momento sincronizados con el repositorio, así que todos dicen
@code{Up-to-date}. Sin embargo, si random.c hubiera sido modificado y el cambio
no se hubiese enviado al repositorio, podríamos encontrarnos algo como esto:

@example
===================================================================
File: random.c          Status: Locally Modified

   Working revision:    1.2     Mon Apr 19 06:35:27 1999
   Repository revision: 1.2     /usr/local/cvs/miproyecto/b-subdir/random.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)
@end example

Los números de revisión de la copia de trabajo y de la copia presente
en el repositorio le informan de si el fichero está o no sincronizado
con la copia que hay en el repositorio. Volviendo a nuestra copia de
trabajo original (la copia de jluis, que no ha visto todavía el cambio
habido en hello.c), vemos lo siguiente:

@example
floss$ cvs status hello.c
===================================================================
File: hello.c           Status: Needs Patch

   Working revision:    1.2     Mon Apr 19 02:17:07 1999
   Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

floss$ 
@end example

Esto nos dice que alguien ha efectuado cambios en hello.c, elevando a
1.3 el número de revisión de la copia que hay en el repositorio, y
que esta copia de trabajo está aún en la revisión 1.2. La línea
"Status: Needs Patch" significa que la siguiente actualización traerá
los cambios del repositorio y los aplicará a la copia de trabajo del
fichero.

Supongamos por un momento que ignoramos completamente el cambio que mperez
ha hecho a hello.c, así que no utilizamos status ni update, sino que
simplemente procedemos a editar nuestro fichero local, realizando un
cambio ligeramente distinto en el mismo punto del fichero. Esto nos
lleva a nuestro primer conflicto.

@c --------------------------------------------------------------------
@node Detección y resolución de conflictos
@subsection Detección y resolución de conflictos

Detectar un conflicto es bastante sencillo. Al invocar una actualización,
CVS le dice, bien a las claras, que existe un conflicto. Pero primero,
creemos el conflicto en sí: editemos el fichero hello.c para insertar
la línea

@example
printf ("este cambio generará un conflicto\n");
@end example

exactamente donde mperez introdujo esto:

@example
printf ("entre hola y adiós\n");
@end example

En este momento, el estado de nuestra copia de hello.c es


@example
floss$ cvs status hello.c
===================================================================
File: hello.c           Status: Needs Merge

   Working revision:    1.2     Mon Apr 19 02:17:07 1999
   Repository revision: 1.3     /usr/local/cvs/miproyecto/hello.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none)

floss$ 
@end example

lo que significa que ha habido cambios tanto en la copia del repositorio
como en nuestra copia de trabajo, y que estos cambios necesitan ser
fusionados (CVS no es aún consciente de que los cambios entrarán en
conflicto, porque aún no hemos intentado hacer una actualización).
Cuando hagamos una actualización, veremos esto:

@example
floss$ cvs update hello.c
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.2
retrieving revision 1.3
Merging differences between 1.2 and 1.3 into hello.c
rcsmerge: warning: conflicts during merge
cvs update: conflicts found in hello.c
C hello.c
floss$ 
@end example

La última línea es la clave. La "C" situada a la izquierda del nombre del
fichero indica que los cambios han sido fusionados [en nuestra copia de
trabajo], pero que entran en conflicto. El contenido de hello.c muestra
ahora ambos cambios:

@example
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
<<<<<<< hello.c
  printf ("este cambio generará un conflicto\n");
=======
  printf ("entre hola y adiós\n");
>>>>>>> 1.3
  printf ("¡Adiós, mundo!\n");
@}
@end example

Los conflictos siempre se muestran delimitados por marcadores de
conflicto, en el siguiente formato:

@example
<<<<<<< (nombre de fichero)
  (cambios en la copia de trabajo, todavía no enviados al repositorio)
  blah blah blah
=======
  (cambios procedentes del repositorio)
  blah blah blah
  etc.
>>>>>>> (último número de revisión en el repositorio)
@end example

El fichero Entries también muestra que el fichero se encuentra en este
momento en un estado intermedio:

@example
floss$ cat CVS/Entries
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//
D/a-subdir////
D/b-subdir////
/hello.c/1.3/Result of merge+Tue Apr 20 03:59:09 1999//
floss$ 
@end example

La manera de resolver el conflicto es editar el fichero de forma que
tenga el texto que resulte apropiado, eliminando de paso los marcadores
de conflicto, y después enviarlo al repositorio. Esto no significa
necesariamente elegir entre uno o otro cambio; podría decidir que ninguno
de los dos cambios es satisfactorio y reescribir la sección donde aparece
el conflicto, o incluso el fichero al completo. En este caso, vamos a
favorecer el primero de los cambios, pero con una puntuación y uso de
las mayúsculas ligeramente distintos de los empleados por mperez:

@example
floss$ emacs hello.c
  (editamos el fichero...)
floss$ cat hello.c
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("ENTRE HOLA Y ADIÓS.\n");
  printf ("¡Adiós, mundo!\n");
@}
floss$ cvs ci -m "alterada la línea del medio"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c
new revision: 1.4; previous revision: 1.3
done
floss$ 
@end example

@c -------------------------------------------------------------------
@node Averiguar quién hizo qué (leyendo informes de cambios)
@subsection Averiguar quién hizo qué (leyendo informes de cambios)

A estas alturas, el proyecto ha pasado ya por varios cambios. Si está
intentado hacerse una idea de lo sucedido hasta el momento, no querrá
necesariamente examinar con detalle cada fichero de diferencias. Examinar
los informes de cambios sería lo ideal, y puede hacerlo con el comando log:

@example
floss$ cvs log   
(páginas y páginas de salida omitidas)
@end example

La salida del comando tiende a ser bastante detallada. Veamos los informes
de cambios para un único fichero:

@example
floss$ cvs log hello.c
RCS file: /usr/local/cvs/miproyecto/hello.c,v
Working file: hello.c
head: 1.4
branch:
locks: strict
access list:
symbolic names:
        start: 1.1.1.1
        jluis: 1.1.1
keyword substitution: kv
total revisions: 5;     selected revisions: 5
description:
--------------
revision 1.4
date: 1999/04/20 04:14:37;  author: jluis;  state: Exp;  lines: +1 -1
alterada la línea del medio
--------------
revision 1.3
date: 1999/04/20 02:30:05;  author: mperez;  state: Exp;  lines: +1 -0
añadida una nueva línea entremedias
--------------
revision 1.2
date: 1999/04/19 06:35:15;  author: jluis;  state: Exp;  lines: +1 -0
ahora también dice adiós
--------------
revision 1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;
branches:  1.1.1;
Revisión inicial
--------------
revision 1.1.1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;  lines: +0 -0
Importación inicial en CVS
=========================================================================
floss$ 
@end example

Como es habitual, hay mucha información al comienzo que puede simplemente
ignorar. La parte que nos interesa viene después de cada línea de guiones,
en un formato que se explica por sí solo.

Cuando se envían muchos ficheros a la vez al repositorio, todos tienen un
mismo informe de cambios, algo que puede ser útil para seguir los cambios.
Por ejemplo, ¿recuerda cuando enviamos fish.c y random.c a la vez? Se hizo
de esta forma:

@example
floss$ cvs commit -m "añadido código C"
Checking in a-subdir/subsubdir/fish.c;
/usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v  <-  fish.c
new revision: 1.2; previous revision: 1.1
done
Checking in b-subdir/random.c;
/usr/local/cvs/miproyecto/b-subdir/random.c,v  <-  random.c
new revision: 1.2; previous revision: 1.1
done
floss$ 
@end example

El resultado de esta operación fue el envío de ambos ficheros con un
mismo informe de cambios: "añadido código C". Se da el caso de que ambos
ficheros empezaban en la revisión 1.1 y pasaron a la 1.2, pero esto es sólo
una coincidencia; si random.c estuviera en la revisión 1.29, habría pasado
a la 1.30 tras concluir este envío, y la revisión 1.30 tendría el mismo
informe de cambios que la revisión 1.2 de fish.c.

Al utilizar cvs log con estos ficheros, verá el informe que ambos comparten:


@example
floss$ cvs log a-subdir/subsubdir/fish.c b-subdir/random.c

RCS file: /usr/local/cvs/miproyecto/a-subdir/subsubdir/fish.c,v
Working file: a-subdir/subsubdir/fish.c
head: 1.2
branch:
locks: strict
access list:
symbolic names:
        start: 1.1.1.1
        jluis: 1.1.1
keyword substitution: kv
total revisions: 3;     selected revisions: 3
description:
--------------
revision 1.2
date: 1999/04/19 06:35:27;  author: jluis;  state: Exp;  lines: +8 -1
añadido código C
--------------
revision 1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;
branches:  1.1.1;
Revisión inicial
--------------
revision 1.1.1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;  lines: +0 -0
Importación inicial en CVS
=========================================================================
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
Working file: b-subdir/random.c
head: 1.2
branch:
locks: strict
access list:
symbolic names:
        start: 1.1.1.1
        jluis: 1.1.1
keyword substitution: kv
total revisions: 3;     selected revisions: 3
description:
--------------
revision 1.2
date: 1999/04/19 06:35:27;  author: jluis;  state: Exp;  lines: +8 -1
añadido código C
--------------
revision 1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;
branches:  1.1.1;
Revisión inicial
--------------
revision 1.1.1.1
date: 1999/04/18 18:18:22;  author: jluis;  state: Exp;  lines: +0 -0
Importación inicial en CVS
=========================================================================
floss$ 
@end example

Por esta información sabrá que las dos revisiones fueron parte del mismo
envío (el hecho de que las fechas de las dos revisiones sean las mismas,
o muy próximas entre sí, es una prueba más).

Examinar los informes de cambios es una buena forma de hacerse rápidamente
una idea de lo que ha estado sucediendo en un proyecto o de saber lo
que pasó con un fichero específico en un momento determinado. Existen
también muchas herramientas libres diseñadas para convertir la salida
bruta de cvs log a formatos más concisos y legibles (por ejemplo, al
estilo ChangeLog de GNU); no cubriremos estas herramientas en esta guía,
pero serán presentadas en @ref{Herramientas de terceros}.

@c -------------------------------------------------------------------
@node Examinar y deshacer cambios
@subsection Examinar y deshacer cambios

Supongamos que, mientras estamos leyendo los informes de cambios, mperez
se percata de que jluis hizo el cambio más reciente a hello.c:

@example
revision 1.4 
date: 1999/04/20 04:14:37;  author: jluis;  state: Exp;  lines: +1 -1 
alterada la línea del medio
@end example

y se pregunta qué hizo jluis exactamente. En términos formales, la
pregunta que se hace mperez es, "¿Cuál es la diferencia entre mi revisión
(1.3) de hello.c, y la revisión de jluis que vino a continuación (1.4)?"
La forma de averiguarlo es utilizar el comando diff, pero esta vez comparando
las dos últimas revisiones utilizando la opción de comando -r para especificar
ambos números:

@example
paste$ cvs diff -c -r 1.3 -r 1.4 hello.c
Index: hello.c
===========================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -c -r1.3 -r1.4
*** hello.c     1999/04/20 02:30:05     1.3
--- hello.c     1999/04/20 04:14:37     1.4
***************
*** 4,9 ****
  main ()
  @{
    printf ("¡Hola, mundo!\n");
!   printf ("entre hola y adiós\n");
    printf ("¡Adiós, mundo!\n");
  @}
--- 4,9 --
  main ()
  @{
    printf ("¡Hola, mundo!\n");
!   printf ("ENTRE HOLA Y ADIÓS.\n");
    printf ("¡Adiós, mundo!\n");
  @}
paste$
@end example

El cambio es bastante obvio, visto de esta forma. Dado que los números
de revisión se dan en orden cronológico (por lo general, una buena idea),
el comando los muestra de forma ordenada. Si sólo se da un número de
revisión, CVS utiliza como segundo número la revisión actual del fichero
presente en la copia de trabajo.

Cuando mperez ve estos cambios, decide al momento que le gusta más su
forma de hacer las cosas, así que decide "deshacerlo", esto es, ir una
revisión atrás.

Sin embargo, esto no significa que desee perder su revisión 1.4. Si bien
en un sentido estrictamente técnico es probablemente posible conseguir
este efecto en CVS, raramente existe razón alguna para hacerlo. Es mucho
más deseable guardar la revisión 1.4 en el historial y hacer una nueva
revisión 1.5 idéntica a la 1.3: de esta forma, la operación de deshacer
se convierte en parte del historial del fichero.

La única pregunta es, ¿cómo puede usted obtener el contenido de la revisión
1.3 y ponerlo en la 1.5?

En este caso en particular, dado que el cambio es muy sencillo, mperez
puede seguramente limitarse a editar el fichero a mano para hacerlo
idéntico a la revisión 1.3, y entonces enviarlo al repositorio. Sin
embargo, si los cambios son más complejos (como suele ocurrir en un
proyecto real), intentar recrear a mano la revisión antigua será
irremediablemente algo donde se producirán errores. Por tanto, vamos
a hacer que mperez utilice CVS para obtener y reenviar el contenido de
la antigua revisión.

Hay dos formas igualmente buenas de conseguir esto: la lenta y dolorosa,
y la rápida y vistosa. Vamos a examinar primero la lenta y dolorosa.

@c ---------------------------------------------------------------------
@node El método lento de deshacer cosas
@subsection El método lento de deshacer cosas

Este método utiliza la combinación de opciones -p y -r al hacer la
actualización. La opción -p envía el contenido de la revisión indicada a
la salida estándar.

De por sí, no es que esto sea algo terriblemente útil, dado que el
contenido del fichero desaparecerá rápidamente por la  ventana, dejando
intacta la copia de trabajo. Sin embargo, redirigiendo la salida estándar
al fichero, el fichero terminará recibiendo el contenido de la antigua
revisión. Sería lo mismo que haber editado el fichero a mano para
llevarlo a ese estado.

Primero, sin embargo, mperez necesita ponerse al día respecto al
repositorio:

@example
paste$ cvs update
cvs update: Updating .
U hello.c
cvs update: Updating a-subdir
cvs update: Updating a-subdir/subsubdir
cvs update: Updating b-subdir
paste$ cat hello.c
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("ENTRE HOLA Y ADIÓS.\n");
  printf ("¡Adiós, mundo!\n");
@}
paste$ 
@end example

Lo siguiente que hace es emplear la opción -p al invocar la actualización,
para asegurarse de que la revisión 1.3 es justo la que quiere:

@example
paste$ cvs update -p -r 1.3 hello.c
===================================================================
Checking out hello.c
RCS:  /usr/local/cvs/miproyecto/hello.c,v
VERS: 1.3
***************
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("entre hola y adiós\n");
  printf ("¡Adiós, mundo!\n");
@}
@end example

Ooops, hay algunas líneas inútiles al comienzo. En realidad estas líneas
no se envían a la salida estándar sino al flujo de error estándar, así que
son inofensivas. Aún así, estas líneas hacen más difícil interpretar la
información, y pueden ser suprimidas con -Q:

@example
paste$ cvs -Q update -p -r 1.3 hello.c
#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("entre hola y adiós\n");
  printf ("¡Adiós, mundo!\n");
@}
paste$ 
@end example

Ahí estamos - esto es exactamente lo que mperez quería obtener. El
siguiente paso es poner ese contenido en el fichero de la copia de
trabajo, usando una redirección Unix (que es lo que hace el signo ">"):

@example
paste$ cvs -Q update -p -r 1.3 hello.c > hello.c
paste$ cvs update
cvs update: Updating .
M hello.c
cvs update: Updating a-subdir
cvs update: Updating a-subdir/subsubdir
cvs update: Updating b-subdir
paste$ 
@end example

Al hacer ahora la actualización, el fichero aparece como modificado, lo
cual tiene sentido dado que su contenido ha cambiado. Específicamente,
tiene el mismo contenido que la antigua revisión 1.3 (no es que CVS se
dé cuenta de que es idéntica a la revisión antigua, tan sólo se da
cuenta de que se ha modificado). Si mperez quiere estar aún más seguro,
puede hacer un diff para comprobarlo:

@example
paste$ cvs -Q diff -c
Index: hello.c
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.4
diff -c -r1.4 hello.c
*** hello.c     1999/04/20 04:14:37     1.4
--- hello.c     1999/04/20 06:02:25
***************
*** 4,9 ****
  main ()
  @{
    printf ("¡Hola, mundo!\n");
!   printf ("ENTRE HOLA Y ADIÓS.\n");
    printf ("¡Adiós, mundo!\n");
  @}
--- 4,9 --
  main ()
  @{
    printf ("¡Hola, mundo!\n");
!   printf ("entre hola y adiós\n");
    printf ("Adiós, mundo!\n");
  @}
paste$ 
@end example

Sí, esto es exactamente lo que él quería: una verdadera vuelta atrás.
De hecho, es lo contrario del diff que obtuvo previamente. Satisfecho,
lo envía:

@example
paste$ cvs ci -m "devuelto al código 1.3"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c
new revision: 1.5; previous revision: 1.4
done
paste$ 
@end example

@c ---------------------------------------------------------------
@node El método rápido de deshacer cosas
@subsection El método rápido de deshacer cosas

La forma rápida y vistosa de deshacer es usar la opción -j (de "juntar")
al comando de actualización. Esta opción es similar a -r en el sentido de
que utiliza un número de revisión, y de que puede usar hasta dos -j a la
vez. CVS calcula la diferencia entre las dos revisiones nombradas y
aplica esta diferencia como un parche al fichero en cuestión (con lo
cual, será de vital importancia el orden en el que indique estas
revisiones al comando).

Así pues, asumiendo que la copia de mperez está al día, puede hacer
simplemente lo siguiente:

@example
paste$ cvs update -j 1.4 -j 1.3 hello.c
RCS file: /usr/local/cvs/miproyecto/hello.c,v
retrieving revision 1.4
retrieving revision 1.3
Merging differences between 1.4 and 1.3 into hello.c
paste$ cvs update
cvs update: Updating .
M hello.c
cvs update: Updating a-subdir
cvs update: Updating a-subdir/subsubdir
cvs update: Updating b-subdir
paste$ cvs ci -m "devuelto al código 1.3" hello.c
Checking in hello.c;
/usr/local/cvs/miproyecto/hello.c,v  <--  hello.c
new revision: 1.5; previous revision: 1.4
done
paste$ 
@end example

Cuando sólo es necesario deshacer los cambios habidos en un único fichero,
no hay realmente mucha diferencia entre el método lento y el rápido. Más
adelante, veremos como el método rápido es mucho mejor para deshacer
múltiples ficheros al mismo tiempo. De momento, utilice simplemente el
método que le resulte más cómodo.

@c -------------------------------------------------------------------
@heading Deshacer no es un sustituto para la comunicación

Con toda probabilidad, lo que mperez hizo en nuestro ejemplo fue bastante
desconsiderado por su parte. Al trabajar en un proyecto real con otras
personas, si se considera que alguien ha hecho un cambio poco deseable,
lo primero que debería hacerse es discutir el tema con esa persona. Quizás
haya una buena razón detrás del cambio, o puede que esa persona no lo
haya meditado lo suficiente antes de incorporarlo al repositorio. Sea
como fuere, no hay motivo alguno para precipitarse a deshacerlo. CVS
guarda un registro completo de todo lo que va sucediendo, así que siempre
puede deshacer los cambios hasta una revisión previa después de consultar
con la persona que hizo esos cambios.

Si es Ud. el responsable máximo de un proyecto y tiene una fecha límite
para entregarlo, o si considera que tiene todo el derecho -y la necesidad-
de deshacer inmediatamente el cambio sin más dilación, entonces adelante,
pero lo siguiente que debería hacer es contactar con el autor de los
cambios que ha deshecho, explicándole sus motivos y qué hay que hacer
para volver a enviar el cambio.

@c -------------------------------------------------------------------
@node Otros comandos útiles de CVS
@section Otros comandos útiles de CVS

Llegados a este punto, ya debería sentirse relativamente cómodo con el
uso básico de CVS. Dejaré por tanto mi tono narrativo y docente para
presentar algunos comandos más que resultan útiles, esta vez de forma
más breve:

@menu
* Añadir ficheros::
* Añadir directorios::
* CVS y ficheros binarios::
* Eliminar ficheros::
* Eliminar directorios::
* Renombrar ficheros y directorios::
* Evitar la fatiga de las opciones::
* Obtener instantáneas (fechas y marcas)::
* Formatos de fecha permitidos::
* Marcar un momento en el tiempo (marcas)::
@end menu

@c ------------------------------------------------------------------
@node Añadir ficheros
@subsection Añadir ficheros

Añadir un fichero es un proceso de dos pasos: primero debe ejecutar
el comando add ("añadir") sobre él, y después enviarlo. El fichero no
aparecerá en el repositorio hasta que se haya realizado el envío:

@example
floss$ cvs add nuevofichero.c
cvs add: scheduling file 'nuevofichero.c' for addition
cvs add: use 'cvs commit' to add this file permanently
floss$ cvs ci -m "añadido nuevofichero.c" nuevofichero.c 
RCS file: /usr/local/cvs/miproyecto/nuevofichero.c,v
done
Checking in nuevofichero.c;
/usr/local/cvs/miproyecto/nuevofichero.c,v  <-  nuevofichero.c
initial revision: 1.1
done
floss$ 
@end example

@c ------------------------------------------------------------------
@node Añadir directorios
@subsection Añadir directorios

A diferencia del añadido de ficheros, el añadido de directorios es un
proceso de un sólo paso; no es necesario emplear "commit" a continuación:

@example
floss$ mkdir c-subdir 
floss$ cvs add c-subdir
Directory /usr/local/cvs/miproyecto/c-subdir added to the repository 
floss$ 
@end example

Si examina lo que hay dentro del nuevo directorio en la copia de trabajo,
verá que el comando "add" ha añadido automáticamente un subdirectorio
"CVS":

@example
floss$ ls c-subdir 
CVS/ 
floss$ ls c-subdir/CVS 
Entries     Repository  Root 
floss$ 
@end example

Ahora puede añadir ficheros (o nuevos directorios) al directorio que ha
creado, como con cualquier otro directorio de su copia de trabajo.

@c ---------------------------------------------------------------------
@node CVS y ficheros binarios
@subsection CVS y ficheros binarios

Hasta ahora he decidido omitir el secretillo que esconde CVS, que es el
hecho de que no se le dan muy bien los ficheros binarios (bueno, hay
algún que otro secretillo más, pero éste es desde luego el más vergonzante
de todos). No es que CVS no soporte el uso de binarios; en realidad lo
hace, pero no sin algunos dolores de cabeza.

Todos los ficheros en los que hemos estado trabajando hasta ahora han sido
simples ficheros de texto. CVS tiene algunos trucos especiales para los
ficheros de texto: por ejemplo, cuando está trabajando entre un repositorio
de Unix y una copia de trabajo instalada en un sistema Windows o Macintosh,
convierte los finales de línea de la forma apropiada para cada plataforma.
Por ejemplo, la convención en Unix es usar simplemente un salto de línea
(LF), mientras que Windows espera una secuencia de retorno de carro y salto
de línea (CR+LF) al final de cada línea. Así, los ficheros en una copia de
trabajo bajo Windows tendrán terminaciones CR+LF, mientras que una copia de
trabajo del mismo proyecto instalada en una máquina Unix tendrá
terminaciones LF (el repositorio en sí siempre utiliza el formato LF).

Otro truco es que CVS detecta en los ficheros de texto la presencia de
cadenas especiales, conocidas como cadenas de texto de palabras clave RCS,
y las sustituye con la información de la revisión y otras cosas útiles.
Por ejemplo, si su fichero contiene esta cadena:
   
@example
$Revision$
@end example

CVS la expandirá en cada envío para poner en su lugar el número de revisión.
Por ejemplo, esta cadena podría convertirse en
   
@example
$Revision: 1.3 $
@end example

CVS mantiene esta cadena al día en el fichero a medida que éste va
evolucionando. Estas palabras clave se documentan en @ref{CVS avanzado} y
@ref{Herramientas de terceros}.

Esta expansión de cadenas de texto es algo muy útil en los ficheros de
texto, ya que permite ver los números de revisión y otra información
sobre un fichero mientras lo está editando. Ahora bien, ¿qué pasa si el
fichero es una imagen JPG? ¿o un programa ejecutable compilado? En estos
casos, CVS podría dañar seriamente los ficheros si se pusiera a expandir
cada palabra clave que fuese encontrando. Es más, en un fichero binario
estas cadenas podrían aparecer por pura coincidencia.

Por lo tanto, cuando añada un fichero binario, debe decirle a CVS que
desactive tanto la expansión de palabras clave como la conversión de
finales de línea. Para ello, utilice -kb:

@example
floss$ cvs add -kb fichero
floss$ cvs ci -m "añadido esto y lo otro" fichero
  (etcétera)
@end example

Por otra parte, en ciertas ocasiones (como es el caso de ficheros de texto
donde posiblemente aparezca alguna referencia a este tipo de palabras
clave), posiblemente desee desactivar solamente la expansión de palabras
clave. Esto se hace con -ko:

@example
floss$ cvs add -ko fichero
floss$ cvs ci -m "añadido esto y lo otro" fichero
  (etcétera)
@end example

(De hecho, este mismo capítulo que está leyendo es un ejemplo de este tipo
de casos, merced al ejemplo de @w{@code{$Revision$}} mostrado aquí.)

Tenga en cuenta que no tiene sentido utilizar @w{@code{cvs diff}} sobre dos
revisiones de un fichero binario. Diff utiliza un algoritmo basado en
texto que sólo puede discernir si dos ficheros binarios son distintos,
pero no la forma en que difieren. Futuras versiones de CVS podrían llegar
a ofrecer alguna manera de presentar diferencias entre ficheros binarios.

@c ----------------------------------------------------------------------
@node Eliminar ficheros
@subsection Eliminar ficheros

Eliminar un fichero es similar a añadir uno, con la salvedad de que debe
dar un paso adicional: tendrá que eliminar antes el fichero de su copia de
trabajo.

@example
floss$ rm nuevofichero.c
floss$ cvs remove nuevofichero.c
cvs remove: scheduling 'nuevofichero.c' for removal
cvs remove: use 'cvs commit' to remove this file permanently
floss$ cvs ci -m "eliminado nuevofichero.c" nuevofichero.c
Removing nuevofichero.c;
/usr/local/cvs/miproyecto/nuevofichero.c,v  <-  nuevofichero.c
new revision: delete; previous revision: 1.1
done
floss$ 
@end example

Fíjese cómo en el segundo y tercer comandos nos referimos a nuevofichero.c
de forma explícita a pesar de que ya no existe en nuestra copia de trabajo.
Por supuesto, en el envío, no es estrictamente necesario que nombre el
fichero, siempre que no le importe que el envío afecte también a cualquier
otra modificación que haya podido tener lugar en la copia de trabajo.

@c --------------------------------------------------------------------
@node Eliminar directorios
@subsection Eliminar directorios

Como he dicho anteriormente, en realidad CVS no mantiene los directorios
bajo control de versión, sino que, a modo de medida de ahorro, presenta
ciertos comportamientos extraños que en la mayoría de los casos hacen
simplemente "lo que conviene". Uno de estos comportamientos extraños es
que los directorios vacíos pueden tratarse de una forma especial. Si desea
eliminar un directorio de un proyecto, primero borre todos los ficheros
que contenga

@example
floss$ cd dir
floss$ rm fichero1 fichero2 fichero3
floss$ cvs remove fichero1 fichero2 fichero3
  (salida de información omitida)
floss$ cvs ci -m "borrados todos los ficheros" fichero1 fichero2 fichero3
  (salida de información omitida)
@end example

y después ejecute "update" en el directorio anterior con la opción -P:

@example
floss$ cd .. 
floss$ cvs update -P 
  (salida de información omitida)
@end example

La opción -P le dice al comando "update" que "limpie" cualquier directorio
vacío, esto es, que los elimine de la copia de trabajo. Una vez hecho esto,
puede decirse que el directorio ha sido borrado; todos sus ficheros han
desaparecido, y el directorio en sí es historia (al menos por lo que respecta
a nuestra copia de trabajo, claro, pero sigue habiendo un directorio vacío en
el repositorio).

Una interesante contrapartida de este comportamiento es que, cuando se
hace una actualización normal, CVS no trae automáticamente a la copia de
trabajo los nuevos directorios que se hayan creado en el repositorio.
Hay un par de justificaciones variopintas para esto, ninguna de las cuales
vale la pena mencionar aquí. La explicación breve es que de vez en cuando
debería ejecutar "update" con la opción -d, ordenándole que traiga cualquier
nuevo directorio que haya sido creado en el repositorio.

@c -----------------------------------------------------------------
@node Renombrar ficheros y directorios
@subsection Renombrar ficheros y directorios

Renombrar un fichero es equivalente a crearlo con un nuevo nombre y
eliminarlo con el antiguo. En Unix, los comandos son:


@example
floss$ cp nombre_antiguo nuevo_nombre
floss$ rm nombre_antiguo
@end example

Aquí está el equivalente en CVS:

@example
floss$ mv nombre_antiguo nuevo_nombre
floss$ cvs remove nombre_antiguo
  (salida omitida)
floss$ cvs add nuevo_nombre
  (salida omitida)
floss$ cvs ci -m "renombrado nombre_antiguo como nuevo_nombre" nombre_antiguo nuevo_nombre
  (salida omitida)
floss$ 
@end example

Para ficheros, ésto es todo lo que hay que hacer. El renombramiento de
directorios tampoco varía mucho: deberá crear el nuevo directorio, añadirlo
con cvs add, mover todos los ficheros del directorio antiguo al nuevo,
eliminarlos con cvs remove del directorio antiguo, añadirlos al nuevo con
cvs add, hacer un envío con cvs commit para actualizar el repositorio, y
finalmente actualizarse con cvs update -P para que desaparezca de nuestra
copia de trabajo cualquier directorio vacío. O sea,

@example
floss$ mkdir nuevo_dir 
floss$ cvs add nuevo_dir 
floss$ mv dir_antiguo/* nuevo_dir 
mv: nuevo_dir/CVS: cannot overwrite directory 
floss$ cd dir_antiguo 
floss$ cvs rm foo.c bar.txt 
floss$ cd ../nuevo_dir 
floss$ cvs add foo.c bar.txt 
floss$ cd ..  
floss$ cvs commit -m "movidos foo.c y bar.txt de dir_antiguo a nuevo_dir"
floss$ cvs update -P
@end example

Fíjese en el mensaje de aviso recibido después de ejecutar el tercer comando.
Este aviso le comunica que no se puede copiar el subdirectorio CVS/ del
antiguo directorio al nuevo porque ya hay allí un directorio con este
nombre. Esto es correcto, porque le interesa que el directorio antiguo
mantenga de todos modos su subdirectorio CVS/.

Obviamente, mover directorios de un lado para otro puede ser un poco
engorroso. La mejor política es tratar de disponer una buena distribución
en el momento de importar el proyecto, de forma que no tenga que estar
moviendo luego directorios para aquí y para allá. Más adelante, aprenderá
un método más drástico para mover directorios, esta vez haciendo el cambio
directamente en el repositorio. Sin embargo, es mejor reservar este método
para situaciones de emergencia; siempre que sea posible, es mejor gestionar
todo con operaciones de CVS que afecten principalmente a las copias de
trabajo.

@c -------------------------------------------------------------------
@node Evitar la fatiga de las opciones
@subsection Evitar la fatiga de las opciones

La mayor parte de la gente se cansa rápidamente de estar escribiendo
continuamente las mismas opciones con cada comando. Si sabe que siempre
va a querer pasar la opción global -Q o que siempre va a usar -c con
diff, ¿por qué tendría que estar escribiéndolas una y otra vez?

Por suerte, dispone de ayuda para esto. CVS busca un fichero .cvsrc en su
directorio personal. En este fichero puede especificar las opciones que
deban aplicarse por omisión en cada invocación a CVS. Éste es un fichero
.cvsrc de ejemplo:

@example
diff -c
update -P
cvs -q
@end example

Si la primera palabra de la línea corresponde a un comando de CVS en
su forma *no* abreviada, las opciones indicadas ahí serán las que se
utilicen siempre con ese comando. Para indicar opciones globales a
emplear por omisión, deberá usar "cvs".

Empleando nuestro ejemplo de arriba, cada vez que el usuario ejecute
cvs diff, la opción -c se incluirá automáticamente.

@c -------------------------------------------------------------------
@node Obtener instantáneas (fechas y marcas) 
@subsection Obtener instantáneas (fechas y marcas) 

Volvamos al ejemplo del programa que está en un estado inoperativo en
el momento en el que recibimos un informe de fallo de un usuario. El
desarrollador necesita de repente acceder al proyecto entero en el
estado en el que se encontraba al hacer la última distribución pública,
aunque muchos ficheros posiblemente habrán cambiado desde entonces, y
el número de revisión de cada fichero seguramente será distinto en este
momento. Llevaría demasiado tiempo revisar los informes de cambios,
adivinar cuál era el número de revisión de cada fichero en el momento
de la distribución, y después ejecutar una actualización (especificando
el número de revisión con -r) para cada uno de ellos. En proyectos de
mediano o gran tamaño (de decenas a cientos de ficheros), sería casi
imposible acometer tamaña empresa.

Por todo lo cual, CVS proporciona una forma de obtener de una sola vez
revisiones antiguas de los ficheros que forman un proyecto. De hecho,
ofrece dos mecanismos: por fecha -que selecciona las revisiones basándose
en la fecha en que fueron enviadas al repositorio-, y por marca, que
obtiene una "instantánea" del proyecto marcada previamente.

Cuál de los métodos deberá utilizar es algo que depende de la situación
concreta. El método basado basado en fechas funciona pasando la opción
-D al comando "update", que es similar a -r pero en este caso tomando
como argumento fechas en lugar de números de revisión:

@example
floss$ cvs -q update -D "1999-04-19" 
U hello.c 
U a-subdir/subsubdir/fish.c 
U b-subdir/random.c 
floss$ 
@end example

Con la opción -D, "update" recupera la revisión más reciente de cada
fichero existente en la fecha dada, devolviendo si es necesario los
ficheros de la copia de trabajo al estado en el que encontes se
encontraban.

Cuando se da una fecha, puede -y generalmente, debería hacerlo- incluir
la hora exacta. Por ejemplo, el comando anterior terminó tomando del
repositorio la revisión 1.1 de todo (sólo tres ficheros cambiaron,
porque los demás están aún en la revisión 1.1). Éste es el estado de
hello.c para demostrarlo:

@example
floss$ cvs -Q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:          1.1.1.1 Sat Apr 24 22:45:03 1999 
   Repository revision:       1.1.1.1 /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Date:               99.04.19.05.00.00 
floss$ 
@end example

Pero un vistazo atrás a los informes de cambios presentados anteriormente
en este capítulo indica que la revisión 1.2 de hello.c se envió sin duda
alguna al repositorio el 19 de Abril de 1999. Así que, ¿por qué hemos
recibido ahora la revisión 1.1 en lugar de la 1.2?

El problema está en que la fecha "1999-04-19" fue interpretada como "la
medianoche en la que comenzó el día 1999-04-19", esto es, el primer
instante de ese día. Esto seguramente no es lo que quiere. El envío
de la revisión 1.2 tuvo lugar en un momento posterior de ese día.
Indicando la fecha con mayor exactitud, podemos obtener la revisión 1.2:

@example
floss$ cvs -q update -D "1999-04-19 23:59:59" 
U hello.c 
U a-subdir/subsubdir/fish.c 
U b-subdir/random.c 
floss$ cvs status hello.c 
=================================================================== 
File: hello.c                 Status: Locally Modified 
   Working revision:  1.2     Sat Apr 24 22:45:22 1999 
   Repository revision:       1.2     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                (none) 
   Sticky Date:               99.04.20.04.59.59 
   Sticky Options:    (none) 
floss$ 
@end example

Casi hemos terminado. Si observa atentamente la fecha y hora de la línea
"Sticky Date", parece indicar las 4:59:59 AM, no las 11:59 como se
indicó en el comando (más adelante veremos lo que significa "sticky").

Como habrá adivinado, la discrepancia se debe a la diferencia entre la
hora local y la hora Universal Coordinada (también conocida como la hora
del meridiano de Greenwich). El repositorio guarda siempre las fechas en
Tiempo Universal, pero en su lado cliente CVS suele asumir la hora local
del sistema. En el caso de -D, esto es un poco desafortunado, porque
posiblemente le interese más comparar respecto a la hora recogida en el
repositorio que preocuparse por lo que el sistema local opina de qué
hora es. Puede evitar este problema especificando la zona GMT en el
comando:

@example
floss$ cvs -q update -D "1999-04-19 23:59:59 GMT" 
U hello.c 
floss$ cvs -q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.2     Sun Apr 25 22:38:53 1999 
   Repository revision:       1.2     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                (none) 
   Sticky Date:               99.04.19.23.59.59 
   Sticky Options:    (none) 
floss$ 
@end example

¡Ajá! Esto ha hecho que la copia de trabajo quede registrada como uno
de los últimos envíos realizados el 19 de Abril (a menos que hubiera
algún envío en el último segundo del día, que no es el caso).

¿Qué sucede ahora si ejecuta "update"?

@example
floss$ cvs update 
cvs update: Updating . 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
floss$ 
@end example

No pasa nada. Pero usted sabe que hay versiones más recientes de por
lo menos tres ficheros, luego, ¿por qué no se incorporan estos ficheros
en su copia de trabajo?

Aquí es donde "sticky" entra en juego. Actualizar (¿"desactualizar"?)
con la opción -D hace que la copia de trabajo quede fijada de forma
permanente a esa fecha o a una anterior: en terminología de CVS, la
copia de trabajo tiene "pegada" una fecha. Una vez que una copia de
trabajo ha adquirido una propiedad pegadiza, se mantiene así hasta
que se le diga lo contrario. Así pues, posteriores actualizaciones
no permitirán obtener automáticamente la revisión más reciente, sino
que estarán restringidas a la fecha pegada. El si hay algo pegado o
no a un fichero es algo que puede averiguarse ejecutando cvs status,
o bien examinando directamente el fichero CVS/Entries:

@example
floss$ cvs -q update -D "1999-04-19 23:59:59 GMT" 
U hello.c 
floss$ cat CVS/Entries 
D/a-subdir//// 
D/b-subdir//// 
D/c-subdir//// 
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//D99.04.19.23.59.59 
/hello.c/1.2/Sun Apr 25 23:07:29 1999//D99.04.19.23.59.59 
floss$ 
@end example

Si ahora usted modificase su copia de hello.c e intentase después
enviarla al repositorio,

@example
floss$ cvs update 
M hello.c 
floss$ cvs ci -m "intentando cambiar el pasado" 
cvs commit: cannot commit with sticky date for file 'hello.c' 
cvs [commit aborted]: correct above errors first! 
floss$ 
@end example

CVS no permitiría la enviar ese fichero al repositorio, puesto que
sería como permitirle volver atrás y cambiar el pasado. Lo de CVS
es gestionar historiales, así que bajo ningún concepto le permitirá
realizar semejante operación.

Esto no significa, sin embargo, que CVS no sea consciente de todas las
revisiones que se hayan enviado desde aquella fecha. Usted sigue
pudiendo comparar la fecha pegada a la copia de trabajo con otras
revisiones, incluso las futuras:

@example
floss$ cvs -q diff -c -r 1.5 hello.c 
Index: hello.c 
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5 
diff -c -r1.5 hello.c 
*** hello.c   1999/04/24 22:09:27     1.5 
--- hello.c   1999/04/25 00:08:44 
*************** 
*** 3,9 **** 
  void 
  main () 
  @{ 
    printf ("¡Hola, mundo!\n"); 
-   printf ("entre hola y adiós\n"); 
    printf ("¡Adiós, mundo!\n"); 
  @} 
--- 3,9 -- 
  void 
  main () 
  @{ 
+   /* esta línea fue añadida a una copia de trabajo "desactualizada" */ 
    printf ("¡Hola, mundo!\n"); 
    printf ("¡Adiós, mundo!\n"); 
  @} 
@end example

El diff revela que, a 19 de abril de 1999, la línea "entre hola y adiós"
no había sido añadida todavía. También muestra la modificación que hicimos
a la copia de trabajo (añadir el comentario que aparece arriba).

Puede eliminar la fecha pegadiza (o cualquier otra propiedad pegadiza)
haciendo una actualización con la opción -A ("-A" significa "reiniciar",
no me pregunte por qué), lo que pone la copia de trabajo de nuevo en
sincronía con las revisiones más recientes:

@example
floss$ cvs -q update -A 
U hello.c 
floss$ cvs status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.5     Sun Apr 25 22:50:27 1999 
   Repository revision:       1.5     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                (none) 
   Sticky Date:               (none) 
   Sticky Options:    (none) 
floss$ 
@end example

@c -------------------------------------------------------------------
@node Formatos de fecha permitidos
@subsection Formatos de fecha permitidos

CVS admite una gran variedad de formatos cuando se trata de indicar
fechas. Nunca tendrá problemas si decide utilizar el formato ISO 8601
(esto es, en la Organización Internacional de Estándares, el estándar
número 8601, consulte también http://www.saqqara.demon.co.uk/datefmt.htm),
que es el formato empleado en los ejemplos precedentes. Puede también
utilizar el formato de fecha empleado en el correo electrónico vía
Internet tal como se describe en los RFC 822 y 1123 (véase
http://www.rfc-editor.org/rfc/). Por último, puede utilizar ciertas
construcciones anglosajonas no ambiguas para especificar una fecha
relativa a la fecha actual.

Lo más probable es que nunca necesite utilizar todos los formatos
disponibles, pero aquí van algunos ejemplos para darle una idea de lo
que admite CVS:

@example
floss$ cvs update -D "19 Apr 1999" 
floss$ cvs update -D "19 Apr 1999 20:05" 
floss$ cvs update -D "19/04/1999" 
floss$ cvs update -D "3 days ago" 
floss$ cvs update -D "5 years ago" 
floss$ cvs update -D "19 Apr 1999 23:59:59 GMT" 
floss$ cvs update -D "19 Apr" 
@end example

Las comillas que delimitan las fechas están ahí para asegurar que el
shell de Unix trata la fecha como un único argumento aunque incluya
espacios en blanco. Las comillas no causarán ningún problema aunque
la fecha no contenga espacios, así que probablemente sea mejor usarlas
siempre.

@c -------------------------------------------------------------------
@node Marcar un momento en el tiempo (marcas)
@subsection Marcar un momento en el tiempo (marcas)

Pedir ficheros según una fecha concreta es útil cuando el mero paso
del tiempo es su principal preocupación. Pero normalmente lo que realmente
querrá será obtener el proyecto tal y como estaba al producirse un
determinado evento concreto: quizás el día de hacer una distribución
pública, un punto en el que el proyecto se encontraba en su momento
más estable, o la vez que se añadió o eliminó cierta característica
importante.

Intentar recordar la fecha en la que tuvo lugar un evento en concreto
o deducir la fecha a partir de los informes de cambios sería un proceso
muy tedioso. Presumiblemente, el evento, en caso de que fuese realmente
importante, se marcó como tal en el historial formal de revisiones. El
método que ofrece CVS para crear este tipo de marcas se conoce como
@dfn{marcado}.

Las marcas ("tags", N. del T.) se diferencian de los envíos corrientes
en que no registran ningún cambio particular en el texto de los ficheros,
sino más bien un cambio en la forma en que los desarrolladores contemplan
los ficheros. Lo que hace una marca es poner una etiqueta al conjunto de
revisiones representadas por la copia de trabajo de un desarrollador
(lo normal es que la copia de trabajo está completamente al día, así
que el nombre de la marca se pone a las revisiones "más recientes y
brillantes" presentes en el repositorio).

Poner una marca es tan sencillo como ésto:

@example
floss$ cvs -q tag Release-1999_05_01 
T README.txt 
T hello.c 
T a-subdir/loquesea.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
floss$ 
@end example

Este comando asocia el nombre simbólico "Release-1999_05_01" a la
instantánea representada por esta copia de trabajo. Definida formalmente,
una "instantánea" es un conjunto de ficheros del proyecto y los números
de revisión asociados con ellos. Estos números de revisión no tienen
por qué ser los mismos entre varios ficheros, y de hecho no suelen serlo.
Por ejemplo, suponiendo que la marca se hubiera puesto en el mismo
directorio "miproyecto" que hemos estado utilizando en este capítulo
y que la copia de trabajo estuviese completamente al día, el nombre
simbólico "Release-1999_05_01" se asociaría a la revisión 1.5 de hello.c,
a la revisión 1.2 de fish.c, a la revisión 1.2 de random.c, y a la revisión
1.1 de todo lo demás.

Quizás le ayude el pensar en una marca como en una senda o cadena que une
varias revisiones de ficheros del proyecto. En la Figura 2.1, una cadena
imaginaria pasa por el número de revisión marcado en cada fichero del
proyecto.


@example

     Fichero A   Fichero B   Fichero C   Fichero D   Fichero E
     ---------   ---------   ---------   ---------   ---------
     1.1         1.1         1.1         1.1         1.1
 ----1.2-.       1.2         1.2         1.2         1.2
     1.3 |       1.3         1.3         1.3         1.3
          \      1.4       .-1.4-.       1.4         1.4
           \     1.5      /  1.5  \      1.5         1.5
            \    1.6     /   1.6   |     1.6         1.6
             \   1.7    /          |     1.7         1.7
              \  1.8   /           |     1.8       .-1.8------->
               \ 1.9  /            |     1.9      /  1.9
                `1.10'             |     1.10    /   1.10
                 1.11              |     1.11    |
                                   |     1.12    |
                                   |     1.13    |
                                    \    1.14    |
                                     \   1.15   /
                                      \  1.16  /
                                       `-1.17-'

[Figura 2.1: La relación que puede haber entre una marca y determinadas
revisiones de los ficheros.]

@end example

Ahora, si estira la cadena y la observa de forma longitudinal, podrá ver
un momento específico en el historial del proyecto; concretamente, el
momento en el que se fijó la marca (Figura 2.2).

@example

     Fichero A   Fichero B   Fichero C   Fichero D   Fichero E
     ---------   ---------   ---------   ---------   ---------
                                         1.1
                                         1.2
                                         1.3
                                         1.4
                                         1.5
                                         1.6
                                         1.7
                 1.1                     1.8
                 1.2                     1.9
                 1.3                     1.10        1.1
                 1.4                     1.11        1.2
                 1.5                     1.12        1.3
                 1.6                     1.13        1.4
                 1.7         1.1         1.14        1.5
                 1.8         1.2         1.15        1.6
     1.1         1.9         1.3         1.16        1.7
 ----1.2---------1.10--------1.4---------1.17--------1.8------->
     1.3         1.11        1.5         1.17        1.9
                             1.6         1.17        1.10
 
[Figura 2.2: La misma marca vista longitudinalmente respecto al historial
de revisiones.]


@end example

A medida que sigue editando ficheros y enviando cambios, la marca *no*
se moverá de su sitio a pesar de que los números de revisión se vayan
incrementando. Permanece fija, "pegada" al número de revisión de cada
fichero al que fue asociada.

Dada su importancia como elementos descriptivos, es una pena que los
informes de cambios no puedan ser incluidos con las marcas, y que las
marcas en sí no puedan ser párrafos de texto reales. En el ejemplo
anterior, la marca indica de forma bastante obvia que el proyecto se
encontraba en un estado "publicable" en una fecha determinada. Sin
embargo, a veces querrá hacer instantáneas de un estado más complejo,
lo que puede dar lugar a nombres de marcas un tanto extraños, como:


@example
floss$ cvs tag testing-release-3_pre-19990525-public-release 
@end example

Por regla general, debería intentar mantener las marcas lo más simples
posible al tiempo que incluye toda la información necesaria sobre el
evento que está intentando registrar. En caso de duda, es mejor pecar
de demasiado descriptivos - lo agradecerá más tarde cuando sea capaz de
determinar gracias a una marca extremadamente descriptiva exactamente
qué circunstancia se registró con ella.

Posiblemente se haya dado cuenta de que no se han usado puntos ni
espacios en el nombre de las marcas. CVS es bastante estricto en lo
que atañe a nombres válidos de marcas: las reglas son que deben comenzar
con una letra y tener letras, dígitos, guiones ("-"), y signos de subrayado
("_"). No se pueden utilizar espacios, puntos, signos de dos puntos, comas
ni ningún otro símbolo.

Para obtener una instantánea haciendo referencia a una marca, deberá
usar el nombre de esta marca como si fuera un número de revisión. Hay
dos formas de obtener instantáneas: puede obtener una copia de trabajo
nueva con una determinada marca, o bien puede cambiar una copia de trabajo
ya existente por una marca. Ambos métodos tienen como resultado una copia
de trabajo en la que las revisiones de los ficheros son los asociados a
la marca dada.

La mayor parte de las veces, lo que querrá hacer es echar un vistazo al
proyecto tal como éste se encontraba en el momento de hacer la instantánea.
No necesariamente querrá hacer esto en su copia de trabajo principal, donde
posiblemente tenga cambios aún sin enviar y otras cosas importantes que
preferirá salvaguardar, así que vamos a suponer que simplemente desea
obtener una copia de trabajo por separado, con la marca. Así es cómo se
hace (¡asegúrese de invocar este comando desde cualquier otro lugar que
no sea su copia de trabajo actual o su directorio padre!):


@example
floss$ cvs checkout -r Release-1999_05_01 miproyecto 
cvs checkout: Updating miproyecto 
U miproyecto/README.txt 
U miproyecto/hello.c 
cvs checkout: Updating miproyecto/a-subdir 
U miproyecto/a-subdir/loquesea.c 
cvs checkout: Updating miproyecto/a-subdir/subsubdir 
U miproyecto/a-subdir/subsubdir/fish.c 
cvs checkout: Updating miproyecto/b-subdir 
U miproyecto/b-subdir/random.c 
cvs checkout: Updating miproyecto/c-subdir
@end example


Anteriormente hemos visto cómo se utilizaba la opción -r con el comando
"update", donde precedía a un número de revisión. En muchos aspectos, una
marca es como un número de revisión, porque, para cada fichero, cada marca
se corresponde exactamente con *un* número de revisión concreto (es ilegal,
y generalmente imposible, tener dos marcas con el mismo nombre en el mismo
proyecto). De hecho, en cualquier lugar donde pueda utilizar un número de
revisión como argumento de un comando de CVS, podrá también utilizar el
nombre de una marca, siempre y cuando esa marca se haya creado antes.
Si quiere ver las diferencias entre el estado actual de un fichero y el
estado en el que se encontraba en el momento de realizar la última
distribución pública, puede hacer esto:

@example
floss$ cvs diff -c -r Release-1999_05_01 hello.c 
@end example

Y si quiere volver atrás temporalmente a aquella revisión, puede hacer
esto:


@example
floss$ cvs update -r Release-1999_05_01 hello.c 
@end example

La posibilidad de intercambiar nombres de marcas y números de revisión
explica algunas de las estrictas reglas que definen qué nombre de marca
es válido y cuál no. Imagine por un momento que los puntos fueran legales
en los nombres de las marcas; podría tener una marca llamada "1.3" asociada
a un número real de revisión como puede ser el "1.47". Si ahora emplease
el comando

@example
floss$ cvs update -r 1.3 hello.c 
@end example

¿cómo podría CVS saber si se refiere a la marca llamada "1.3", o a la
mucho más antigua revisión 1.3 de hello.c? Es por esto por lo que existen
este tipo de restricciones en los nombres de las marcas, de forma que
siempre puedan distinguirse fácilmente de los números de revisión. Un
número de revisión tiene un punto; el nombre de una marca no. (También
hay motivos para las demás restricciones, generalmente para permitir
que los nombres de las marcas sean fáciles de interpretar para CVS.)

Como posiblemente habrá ya adivinado, el segundo método para obtener una
instantánea -esto es, pasar un directorio de trabajo ya existente a las
revisiones marcadas- también se realiza por medio de una actualización:


@example
floss$ cvs update -r Release-1999_05_01 
cvs update: Updating . 
cvs update: Updating a-subdir 
cvs update: Updating a-subdir/subsubdir 
cvs update: Updating b-subdir 
cvs update: Updating c-subdir 
floss$ 
@end example

Este comando es similar al que utilizamos para devolver hello.c al estado
en el que se encontraba en @code{Release-1999_05_01}, con la salvedad de que se
omite el nombre del fichero dado que queremos volver atrás el proyecto al
completo (si lo desea, puede hacer volver atrás solamente un sub-árbol del
proyecto, invocando este comando mientras se encuentra en ese subdirectorio
en lugar de hacerlo desde el nivel más alto, aunque muy pocas veces querrá
hacer esto).

Observe que, a juzgar por los resultados del comando, no parece que haya
cambiado ningún fichero. La copia de trabajo estaba completamente al
día cuando pusimos la marca, y no se había enviado ningún cambio desde
entonces.

Sin embargo, esto no significa que no haya habido ningún cambio en absoluto.
La copia de trabajo sabe ahora que responde a una revisión marcada. Cuando
hagamos un cambio e intentemos enviarlo al repositorio (supongamos que hemos
modificado hello.c):

@example
floss$ cvs -q update 
M hello.c 
floss$ cvs -q ci -m "intentando enviar desde una copia de trabajo marcada" 
cvs commit: sticky tag 'Release-1999_05_01' for file 'hello.c' is not a branch 
cvs [commit aborted]: correct above errors first! 
floss$ 
@end example

... CVS impide que el envío llegue a producirse (no se preocupe de momento
por lo que significa el mensaje de error - más adelante y en este mismo
capítulo trataremos el tema de las "branches", o ramas para entendernos).
Poco importa si la copia de trabajo llegó a tener una marca a través de la
obtención de una copia de trabajo ("checkout") o una simple actualización;
la cuestión es que, una vez que está marcada, CVS considera la copia de
trabajo como una instantánea estática de un momento particular de la
historia, y CVS no le permitirá cambiar la historia, o cuando menos
no se lo pondrá fácil. Si ejecuta "cvs status" o examina los ficheros
CVS/Entries, podrá ver que hay una marca pegada a cada fichero. Por
ejemplo, aquí tiene el fichero Entries del directorio raíz:


@example
floss$ cat CVS/Entries 
D/a-subdir//// 
D/b-subdir//// 
D/c-subdir//// 
/README.txt/1.1.1.1/Sun Apr 18 18:18:22 1999//TRelease-1999_05_01 
/hello.c/1.5/Tue Apr 20 07:24:10 1999//TRelease-1999_05_01 
floss$ 
@end example

Las marcas, como otras propiedades de carácter "pegadizo", pueden
eliminarse con la opción -A durante una actualización:

@example
floss$ cvs -q update -A 
M hello.c 
floss$ 
@end example

Sin embargo, la modificación de hello.c no ha desaparecido; CVS todavía
sabe que el fichero ha cambiado respecto a su homónimo en el repositorio:

@example
floss$ cvs -q diff -c hello.c 
Index: hello.c 
===================================================================
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5 
diff -c -r1.5 hello.c 
*** hello.c   1999/04/20 06:12:56     1.5 
--- hello.c   1999/05/04 20:09:17 
*************** 
*** 6,9 **** 
--- 6,10 -- 
    printf ("¡Hola, mundo!\n"); 
    printf ("entre hola y adiós\n"); 
    printf ("¡Adiós, mundo!\n"); 
+   /* un comentario en la última línea */ 
  @} 
floss$ 
@end example

Ahora que ha puesto las cosas en orden por medio de la actualización, CVS
aceptará hacer un envío:

@example
floss$ cvs ci -m "añadido un comentario al final de la función main" 
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
cvs commit: Examining c-subdir 
Checking in hello.c; 
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c 
new revision: 1.6; previous revision: 1.5 
done 
floss$ 
@end example

Por supuesto, la marca @code{Release-1999_05_01} sigue estando asociada a
la revisión 1.5. Compare el estado del fichero de como estaba antes a como
está después de eliminar la marca:


@example
floss$ cvs -q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.6     Tue May  4 20:09:17 1999 
   Repository revision:       1.6     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                (none) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$ cvs -q update -r Release-1999_05_01 
U hello.c 
floss$ cvs -q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.5     Tue May  4 20:21:12 1999 
   Repository revision:       1.5     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                Release-1999_05_01 (revision: 1.5) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$
@end example

Y ahora que vengo de decirle que CVS no le permite cambiar la historia,
le enseñaré precisamente cómo cambiarla.

@c --------------------------------------------------------------------
@node Ramas
@section Ramas

Hemos estado concibiendo CVS como un tipo de biblioteca inteligente desde
la que establecer una coordinación; sin embargo, también puede pensarse
en CVS como en una máquina del tiempo (gracias a Jim Blandy por la
analogía). Por ahora, sólo hemos visto cómo se puede revisar el pasado
con CVS, sin afectar a nada. Como todas las buenas máquinas del tiempo,
CVS también le permite ir hacia atrás en el tiempo para cambiar el pasado.
¿Y a dónde nos lleva esto? Los amantes de la ciencia-ficción conocen la
respuesta: a un universo alternativo, que discurre de forma paralela
al nuestro, pero que diverge del nuestro justo desde el punto en el que
se alteró el pasado. Una rama de CVS divide el desarrollo de un proyecto
en historias separadas, y paralelas. Los cambios efectuados en una de las
ramas no afectan a las demás.

@menu
* Conceptos básicos sobre ramas::
* Fusión de cambios desde las ramas al tronco::
* Fusiones múltiples::
* Crear una marca o rama sin una copia de trabajo::
@end menu

@c --------------------------------------------------------------------
@node Conceptos básicos sobre ramas
@subsection Conceptos básicos sobre ramas

¿Por qué son útiles las ramas?

Volvamos por un momento a la situación del desarrollador que, mientras
está trabajando en una nueva versión del programa, recibe un informe
de fallo relativo a una versión publicada anteriormente. Suponiendo que el
desarrollador corrija el problema, aún tiene que encontrar una forma de
enviar la corrección al cliente. No le servirá de nada limitarse a tomar
una copia vieja del programa, parchearla a espaldas de CVS, y enviarla
tal cual: no quedaría registro alguno de lo que ha hecho, CVS no sabría
nada de esta corrección, y más adelante, si por un casual se descubriera
un fallo en el propio parche, nadie tendría un punto desde el que comenzar
a intentar reproducir el problema.


Es incluso peor intentar solucionar el fallo en la versión actual e
inestable de las fuentes y entregar esto al cliente. Oh sí, el fallo
del que se ha dado parte quizás quedase resuelto, pero el resto del
código está a medio cocer y por lo general falto de un proceso de pruebas
pertinente. Puede darse el caso de que funcione, pero es seguro que no
está listo para llegar al gran público.

Dado que se supone que la última versión distribuida es estable (dejando
aparte este fallo), la solución ideal es ir atrás y corregir el fallo en
la antigua versión; esto es, crear un universo alternativo en el que la
última versión pública incluye la correspondiente corrección.

Y aquí es donde entran en juego las ramas. El desarrollador planta una
rama, que parte de la línea principal de desarrollo (el tronco), no
en su revisiones más recientes, sino en el punto de la última distribución
pública. Entonces el desarrollador solicita una copia de trabajo de esta
rama, realiza todos los cambios necesarios para solventar el fallo, y
los envía a esa rama, de forma que quede un registro de la corrección
del fallo. Ahora puede hacer público un parche intermedio basado en esta
rama, y enviarlo al cliente.

Su cambio no habrá afectado al código del tronco, puesto que tampoco le
interesaría hacerlo sin antes averiguar si el tronco necesita o no que se
aplique sobre él la misma corrección. En caso positivo, el desarrollador
puede fusionar los cambios realizados sobre la rama con el código presente
en el tronco. Durante el proceso de fusión, CVS calcula los cambios hechos
en la rama desde el momento en el que ésta salió del tronco hasta el extremo
de la misma (su estado más reciente), y entonces aplica estas diferencias
al proyecto, en el extremo final del tronco. La diferencia entre la raíz
de la rama y su extremo final vendría a ser, por supuesto, la corrección
que se ha realizado.

Otra buena forma de imaginar una fusión es como un caso especial del
proceso de actualización; la diferencia estriba en que, durante una fusión,
los cambios a incorporar se derivan de la comparación entre la raíz y el
extremo de la rama, en lugar de comparar la copia de trabajo con el
contenido del repositorio.

El proceso de actualización es en sí mismo similar a recibir parches
directamente de los autores, y aplicarlos a mano; de hecho, para
hacer una actualización, CVS calcula la diferencia (entendiendo como
"diferencia" el resultado que devolvería el comando diff al comparar
dos ficheros distintos) entre la copia de trabajo y el repositorio,
para a continuación aplicar la diferencia a la copia de trabajo tal
y como lo haría el programa "patch". Esto equivale a la forma en
que un desarrollador obtiene cambios del mundo exterior, aplicando
manualmente parches creados por otros.

Así pues, fusionar con el tronco la rama donde se ha hecho la corrección
es exactamente lo mismo que aceptar un parche que ha hecho otra persona
para corregir el fallo. El autor de ese parche habría generado el parche
a partir de la última versión hecha pública, de la misma forma que los
cambios en la rama lo son respecto a esa versión. Si esa parte del código
en las fuentes actuales no ha variado mucho desde la última versión pública,
la fusión tendrá éxito sin ningún problema. Ahora bien, si el código es
en este momento lo suficientemente diferente, la fusión derivará en
conflicto (en otras palabras, el parche será rechazado), y será necesario
cierto trabajo extra. Normalmente esto se resuelve examinando la parte
donde ha surgido el conflicto, haciendo manualmente los cambios necesarios,
y enviando esos cambios al repositorio. La Figura 2.3 muestra gráficamente
lo que sucede en una rama y en una fusión.


@example

            (rama donde se corrigió el error)
           .---------------->---------------.
          /                                 |
         /                                  |
        /                                   |
       /                                    |
      /                                     V (<---- lugar de la fusión)
 ====*===================================================================>
                (línea principal de desarrollo)
  

[Figura 2.3: Una rama que termina con una fusión. El tiempo transcurre
de izquierda a derecha.]

@end example

Ahora vamos a ver los pasos necesarios para llevar a cabo el procedimiento
descrito. Recuerde que no es realmente el tiempo lo que fluye de izquierda
a derecha en el diagrama, sino más bien el historial de revisiones. La
rama no se habrá hecho en el momento de la distribución, sino que es
creada más tarde, aunque enraizada en las revisiones que formaban parte
de la distribución.

En nuestro caso, supongamos que los ficheros del proyecto han pasado por
muchas revisiones desde que fueron marcados como @code{Release-1999_05_01}, y que
quizás se hayan añadido también nuevos ficheros. Al recibir el informe de fallos
relativo a la antigua distribución, lo primero que querremos hacer será crear
una rama que parta de la antigua distribución, que tuvimos el acierto de marcar
conmo @code{Release-1999_05_01}.

Una forma de hacer esto sería obtener primero una copia de trabajo basada
en dicha marca, y a continuación crear la rama volviendo a marcar con la
opción -b (de "branch", o "rama" en inglés - N. del T.):


@example
floss$ cd .. 
floss$ ls 
miproyecto/ 
floss$ cvs -q checkout -d miproyecto_antigua_dis -r Release-1999_05_01 miproyecto 
U miproyecto_antigua_dis/README.txt 
U miproyecto_antigua_dis/hello.c 
U miproyecto_antigua_dis/a-subdir/loquesea.c 
U miproyecto_antigua_dis/a-subdir/subsubdir/fish.c 
U miproyecto_antigua_dis/b-subdir/random.c 
floss$ ls 
miproyecto/      miproyecto_antigua_dis/ 
floss$ cd miproyecto_antigua_dis 
floss$ ls 
CVS/      README.txt  a-subdir/   b-subdir/   hello.c 
floss$ cvs -q tag -b Release-1999_05_01-bugfixes 
T README.txt 
T hello.c 
T a-subdir/loquesea.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
floss$ 
@end example

Observe bien el último comando. Puede parecer un tanto arbitrario el utilizar
"tag" para crear ramas, pero en realidad hay una razón para ello: el nombre
de la marca servirá como una etiqueta con la cual podremos más tarde hacer
alusión a esta rama. Las marcas en las ramas no tienen un aspecto diferente
al de las utilizadas en otra parte, y de hecho están sujetas a las mismas
limitaciones. A algunas personas les gusta incluir siempre la palabra "rama"
en el nombre de la marca (por ejemplo @code{Release-1999_05_01-ramadecorrección}) para
poder distinguir fácilmente entre marcas de rama y otros tipos de marcas. Tal
vez le interese también a usted hacer lo mismo si alguna que otra vez se
confunde y solicita la rama equivocada.

(Y ya que estamos, observe la opción -d miproyecto_antigua_dis que pasamos
al comando "checkout" en la primer comando CVS. Esto le dice a checkout que
instale la copia de trabajo en un directorio llamado miproyecto_antigua_dis,
de forma que no confundamos estos ficheros con la versión actual de
miproyecto. Tenga cuidado de no confundir este uso de la -d con la opción
global homónima, o con la opción -d del comando "update".)

Por supuesto, la simple ejecución del comando "tag" no pone la copia de
trabajo en consonancia con la rama. El hecho de marcar no afecta nunca
a la copia de trabajo; tan sólo guarda información adicional en el
repositorio para permitirle a usted recuperar en un momento posterior
las revisiones de esa copia de trabajo (como una parte estática del
historial o como una rama, según el caso).

La recuperación puede hacerse de dos formas (a estas alturas, seguramente
ya se esperaba oir esto). Puede solicitar una nueva copia de trabajo tomada
de la rama:

@example
floss$ pwd 
/home/loquesea 
floss$ cvs co -d miproyecto_rama -r Release-1999_05_01-bugfixes miproyecto 
@end example

o pasar a ella una copia de trabajo ya existente:

@example
floss$ pwd 
/home/loquesea/miproyecto 
floss$ cvs update -r Release-1999_05_01-bugfixes 
@end example

El resultado final es el mismo (bueno, el nombre del directorio raíz
de la nueva copia de trabajo puede ser distinto, pero respecto a los fines
de CVS esto no importa). Si su copia de trabajo actual tiene cambios aún
sin enviar, probablemente querrá utilizar "checkout" en lugar de "update"
para acceder a la rama; de lo contrario, CVS intentará fusionar los cambios
habidos en su copia de trabajo antes de colocarla en la rama. En este caso
podría encontrarse con algún conflicto, y aún en caso de que no fuese así,
seguiría sin tener una rama pura: esos ficheros no reflejarán realmente el
estado del programa de acuerdo con la marca designada, puesto que algunos
de ellos contendrán modificaciones hechas por usted.

Sea como fuere, vamos a suponer que de una forma o de otra usted obtiene
una copia de trabajo operativa desde la rama deseada:

@example
floss$ cvs -q status hello.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.5     Tue Apr 20 06:12:56 1999 
   Repository revision:       1.5     /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                Release-1999_05_01-bugfixes 
(branch: 1.5.2) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$ cvs -q status b-subdir/random.c 
=================================================================== 
File: random.c                Status: Up-to-date 
   Working revision:  1.2     Mon Apr 19 06:35:27 1999 
   Repository revision:       1.2 /usr/local/cvs/miproyecto/b-subdir/random.c,v 
   Sticky Tag:                Release-1999_05_01-bugfixes (branch: 1.2.2) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$ 
@end example

(El contenido de las líneas @w{@code{Sticky Tag}} se explicará en
breve.) Si modifica hello.c y random.c y envía los cambios al repositorio,

@example
floss$ cvs -q update 
M hello.c 
M b-subdir/random.c 
floss$ cvs ci -m "corregidos los viejos fallos de puntuación"
cvs commit: Examining . 
cvs commit: Examining a-subdir 
cvs commit: Examining a-subdir/subsubdir 
cvs commit: Examining b-subdir 
Checking in hello.c; 
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c 
new revision: 1.5.2.1; previous revision: 1.5 
done 
Checking in b-subdir/random.c; 
/usr/local/cvs/miproyecto/b-subdir/random.c,v  <-  random.c 
new revision: 1.2.2.1; previous revision: 1.2 
done 
floss$ 
@end example

se dará cuenta de que ocurre algo curioso con los números de revisión:

@example
floss$ cvs -q status hello.c b-subdir/random.c 
=================================================================== 
File: hello.c                 Status: Up-to-date 
   Working revision:  1.5.2.1 Wed May  5 00:13:58 1999 
   Repository revision:       1.5.2.1 /usr/local/cvs/miproyecto/hello.c,v 
   Sticky Tag:                Release-1999_05_01-bugfixes (branch: 1.5.2) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
=================================================================== 
File: random.c                Status: Up-to-date 
   Working revision:  1.2.2.1 Wed May  5 00:14:25 1999 
   Repository revision:       1.2.2.1 /usr/local/cvs/miproyecto/b-subdir/random.c,v 
   Sticky Tag:                Release-1999_05_01-bugfixes (branch: 1.2.2) 
   Sticky Date:               (none) 
   Sticky Options:            (none) 
floss$ 
@end example

¡Ahora tienen cuatro dígitos en lugar de dos!

Un vistazo más de cerca nos revela que el número de revisión de cada fichero
es simplemente el número de la rama (tal como se indica en la línea @w{@code{Sticky Tag}}),
con un dígito extra al final.

Lo que está presenciando es tan sólo una parte del funcionamiento interno
de CVS. Aunque casi siempre utilizará una rama para marcar una divergencia
que afecte a la globalidad del proyecto, en realidad CVS registra la rama
de forma individual, fichero a fichero. Este proyecto tenía cinco
ficheros en el momento de crear la rama, así que en realidad se han
creado cinco ramas, todas ellas con la misma marca: @code{Release-1999_05_01-bugfixes}.

La mayoría de la gente considera esta forma de hacer las cosas como una
implantación bastante poco elegante por parte de CVS, pero en realidad
lo que estamos viendo aquí es parte del legado de RCS: RCS no sabía cómo
agrupar ficheros en los proyectos, y a pesar de que CVS sí lo hace, sigue
utilizando código heredado de RCS para manejar las ramas.

Por regla general, usted no necesitará preocuparse demasiado por cómo CVS
registra las cosas de forma interna, pero en este caso, resulta útil
comprender la relación que existe entre números de ramas y números de
revisiones. Veamos el fichero hello.c; todo lo que estoy a punto de
decirle sobre hello.c se aplica a cualquier otro fichero presente en
la rama, cambiando los números de revisión y de rama según convenga.

En el momento del nacimiento de la rama, el fichero hello.c se encontraba
en su revisión 1.5. Cuando creamos la rama, se añadió un nuevo número al
final para así formar un número de rama (CVS elige el primer número entero
par que no sea cero y que esté libre). Por tanto, en este caso, el número
de rama terminó siendo @code{1.5.2}. El número de la rama no es en sí mismo
un número de revisión, pero sí es la raíz (es decir, el prefijo) de todos
los números de revisión para hello.c que se emplearán en esta rama.

Sin embargo, cuando ejecutamos aquel primer comando "CVS status" en una
copia de trabajo ramificada, el número de revisión de hello.c apareció
como @code{1.5} solamente, y no como @code{1.5.2.0} o algo parecido. Esto se
debe a que la revisión inicial de una rama es siempre la misma que la
revisión que el fichero tiene en el tronco, donde nació la rama. Por tanto,
CVS mostrará el número de revisión del tronco en el informe de estado
mientras el fichero sea el mismo tanto en la rama como en el tronco.

Una vez que enviamos una nueva revisión al repositorio, hello.c ya no era
igual en el tronco que en la rama: la copia que estaba en la rama había
cambiado, mientras que la copia presente en el tronco seguía igual. Es
por ello por lo que se asignó a hello.c su primer número de revisión de
rama, tal como pudimos comprobar después de hacer el envío en el informe
de estado, donde su número de revisión aparecía claramente como @code{1.5.2.1}.

Esta misma situación se aplica al fichero random.c. Su número de
revisión en el momento de crear la rama era @code{1.2}, así que su
primera rama es @code{1.2.2}, y el primer nuevo envío de random.c en
esta rama recibió el número de revisión @code{1.2.2.1}.

No existe ninguna relación numérica entre @code{1.5.2.1} y @code{1.2.2.1}.
No hay razón alguna para pensar que forman parte de la misma rama
excepto por el hecho de que ambos ficheros están marcados con
@code{Release-1999_05_01-bugfixes}, y que la marca está asociada a los
números de rama @code{1.5.2} y @code{1.2.2} en los respectivos ficheros.
Por tanto, el nombre de la marca es su único recurso en la rama para
concebirla como una entidad global. Aunque es perfectamente posible
trasladar un fichero a una rama usando directamente el número de revisión,

@example
floss$ cvs update -r 1.5.2.1 hello.c 
U hello.c 
floss$ 
@end example

casi siempre es una mala idea hacerlo, puesto que estaría mezclando la
revisión en la rama de un fichero con las revisiones fuera de rama de
otros. ¿Quién sabe qué ficheros podría perder? Es mejor usar la marca
de la rama para referirse a la rama y tratar todos los ficheros de una
sola vez, evitando referirnos a ningún fichero en concreto; de esta
forma no tiene que conocer ni preocuparse del número de revisión de
rama de ningún fichero en particular.

También es posible hacer ramas que nacen de otras ramas, hasta llegar
a niveles que podrían considerarse absurdos. Por ejemplo, si un fichero
tuviese el número de revisión @code{1.5.4.37.2.3}, el historial de sus
revisiones podría esquematizarse con algo como esto:

@example
                  1.1
                   |
                  1.2
                   |
                  1.3
                   |
                  1.4
                   |
                  1.5
                 /   \
                /     \
               /       \
           (1.5.2)   (1.5.4)         <--- (éstos son números de ramas)
             /           \
         1.5.2.1        1.5.4.1
            |              |
         1.5.2.2        1.5.4.2
            |              |
          (etc)          (...)       <--- (34 revisiones omitidas por brevedad)
                           |
                        1.5.4.37
                          /
                         /
                   (1.5.4.37.2)      <--- (esto es también un número de rama)
                       /
                      /
               1.5.4.37.2.1
                     |
               1.5.4.37.2.2
                     |
               1.5.4.37.2.3

[Figura 2.4: Un número extrañamente elevado de ramificaciones. El tiempo
transcurre hacia abajo.]


@end example

Naturalmente, sólo circunstancias muy especiales harían necesario tal
grado de ramificaciones, pero, ¿no es agradable saber que CVS llegará
todo lo lejos que usted se proponga? Las ramas anidadas se crean de la misma
forma que cualquier otra rama: obtenga una copia de trabajo de la rama
@code{N}, ejecute "cvs tag -b nombre_de_rama" sobre ella, y de esta forma
creará la rama @code{N.M} en el repositorio (donde @code{N} representa el
número de revisión de rama apropiado en cada fichero, como por ejemplo
@code{1.5.2.1}, mientras que @code{M} representa la siguiente rama
disponible al final de ese número, como por ejemplo @code{2}).

@c ----------------------------------------------------------------------
@node  Fusión de cambios desde las ramas al tronco
@subsection  Fusión de cambios desde las ramas al tronco

Ahora que hemos aplicado la corrección del fallo a la rama, sincronicemos
la copia de trabajo con la revisiones más recientes presentes en el tronco
y veamos si también allí es necesaria la corrección. Vamos a obtener la
copia de trabajo desde la rama empleando "update -A" (en este aspecto, las
marcas de rama son como cualquier otra propiedad pegadiza) y entonces ver
las diferencias respecto a la rama que acabamos de dejar:


@example
floss$ cvs -q update -d -A 
U hello.c 
U b-subdir/random.c 
floss$ cvs -q diff -c -r Release-1999_05_01-bugfixes 
Index: hello.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5.2.1 
retrieving revision 1.6 
diff -c -r1.5.2.1 -r1.6 
*** hello.c   1999/05/05 00:15:07     1.5.2.1 
--- hello.c   1999/05/04 20:19:16     1.6 
*************** 
*** 4,9 **** 
  main () 
  @{ 
    printf ("¡Hola, mundo!\n"); 
!   printf ("entre el saludo y la despedida\n"); 
    printf ("¡Adiós, mundo!\n"); 
  @} 
--- 4,10 -- 
  main () 
  @{ 
    printf ("¡Hola, mundo!\n"); 
!   printf ("entre hola y adiós\n"); 
    printf ("¡Adiós, mundo!\n"); 
+   /* un comentario en la última línea */ 
  @} 
Index: b-subdir/random.c 
=================================================================== 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2.2.1 
retrieving revision 1.2 
diff -c -r1.2.2.1 -r1.2 
*** b-subdir/random.c 1999/05/05 00:15:07     1.2.2.1 
--- b-subdir/random.c 1999/04/19 06:35:27     1.2 
*************** 
*** 4,8 **** 
  void main () 
  @{ 
!   printf ("Un número aleatorio.\n"); 
  @} 
--- 4,8 -- 
  void main () 
  @{ 
!   printf ("un número aleatorio\n"); 
  @} 
floss$ 
@end example

El comando "diff" muestra que hay una línea que difiere en la revisión
en rama de hello.c, y que la revisión del tronco de este fichero tiene
un comentario cerca del final que la revisión de la rama no tiene.
Mientras, en random.c, la revisión en la rama tiene una "U" mayúscula y
un punto, mientras que en la revisión presente en el tronco no aparece esto.

Para fusionar los cambios de una rama con la actual copia de trabajo,
haga una actualización con la opción -j (la misma j de "juntar" que
utilizamos anteriormente para revertir un fichero a una revisión más
antigua):

@example
floss$ cvs -q update -d -j Release-1999_05_01-bugfixes 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5 
retrieving revision 1.5.2.1 
Merging differences between 1.5 and 1.5.2.1 into hello.c 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2 
retrieving revision 1.2.2.1 
Merging differences between 1.2 and 1.2.2.1 into random.c 
floss$ cvs -q update 
M hello.c 
M b-subdir/random.c 
floss$ cvs -q ci -m "fusión con la rama Release-1999_05_01-bugfixes" 
Checking in hello.c; 
/usr/local/cvs/miproyecto/hello.c,v  <-  hello.c 
new revision: 1.7; previous revision: 1.6 
done 
Checking in b-subdir/random.c; 
/usr/local/cvs/miproyecto/b-subdir/random.c,v  <-  random.c 
new revision: 1.3; previous revision: 1.2 
done 
floss$ 
@end example

Este ejemplo toma los cambios habidos desde la raíz de la rama hasta su
extremo final y más reciente, y los fusiona con la copia de trabajo actual,
que a partir de ese momento mostrará esas mismas modificaciones como si
sus ficheros hubieran sido editados a mano para llevarlos a ese estado.
Los cambios son entonces aplicados al tronco, puesto que nada había cambiado
en el repositorio cuando una copia de trabajo sufrió un proceso de fusión.

Si bien en este ejemplo no se han producido conflictos, es bastante posible
(e incluso probable) que hubiera algunos en una fusión hecha en un proyecto
real, en cuyo caso estos conflictos tendrían que resolverse igual que
cualquier otro conflicto, para a continuación poder aplicar los cambios.

@c --------------------------------------------------------------------
@node Fusiones múltiples
@subsection Fusiones múltiples

A veces, una rama seguirá teniendo un desarrollo activo aún después de
que su contenido haya sido fusionado con el tronco. Por ejemplo, esto
puede suceder si se descubre un segundo fallo en la antigua distribución
pública y este fallo ha de ser corregido en la rama. Cabe la posibilidad
de que alguien no hubiese entendido la broma que hay en random.c, así
que tendría usted que añadir una línea explicándola:


@example
floss$ pwd 
/home/loquesea/miproyecto_rama 
floss$ cat b-subdir/random.c 
/* Imprimir un número aleatorio. */ 
#include <stdio.h>
void main () 
@{ 
  printf ("Un número aleatorio.\n"); 
  printf ("¿Ha entendido el chiste?\n"); 
@} 
floss$ 
@end example

y enviar el cambio. Si también es necesario fusionar esa corrección en el
tronco, podría tener la tentación de utilizar el mismo comando "update"
de antes en la copia de trabajo presente en el tronco para llevar a cabo
la "re-fusión":


@example
floss$ cvs -q update -d -j Release-1999_05_01-bugfixes 
RCS file: /usr/local/cvs/miproyecto/hello.c,v 
retrieving revision 1.5 
retrieving revision 1.5.2.1 
Merging differences between 1.5 and 1.5.2.1 into hello.c 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2 
retrieving revision 1.2.2.2 
Merging differences between 1.2 and 1.2.2.2 into random.c 
rcsmerge: warning: conflicts during merge 
floss$ 
@end example

Como puede ver, este comando no ha tenido el efecto deseado: nos
encontramos con un conflicto, a pesar de que la copia en el tronco no
había sido modificada y, por tanto, no esperábamos encontrarnos ninguno.

El problema reside en que el comando "update" se ha comportado exactamente
de la forma descrita: ha intentado tomar todos los cambios habidos desde
la raíz de la rama y su extremo final, y a continuación fusionarlos tomando
como referencia la copia de trabajo actual. El único problema está en que
algunos de estos cambios ya habían sido fusionados desde esta copia de
trabajo, de ahí que surgiese el conflicto:


@example
floss$ pwd 
/home/loquesea/miproyecto 
floss$ cat b-subdir/random.c 
/* Imprimir un número aleatorio. */ 
#include <stdio.h 
void main () 
@{ 
<<<<<<< random.c 
  printf ("Un número aleatorio.\n"); 
======= 
  printf ("Un número aleatorio.\n"); 
  printf ("¿Ha entendido el chiste?\n"); 
>>>>>>> 1.2.2.2
@} 
floss$ 
@end example

Llegados a este punto, podría intentar resolver estos conflictos a mano,
dado que no es difícil ver lo que es necesario hacer en cada fichero.
Sin embargo, es todavía mejor tomar medidas desde el principio para evitar
conflictos. Pasando dos opciones "-j" en lugar de una, obtendrá sólo los
cambios habidos desde la última vez que hizo una fusión con el extremo
final de la rama, en lugar de tener en consideración todos los cambios
habidos en ella. La primera -j le da el punto inicial de la rama, y la
la segunda es sólo el nombre de la rama, que implica su extremo final y
más reciente.

La cuestión entonces es, ¿cómo puede especificar el punto de la rama
desde el que quizo la última fusión? Una forma de hacerlo sería indicar
una fecha junto con el nombre de la marca dispuesta en la rama. CVS
ofrece para ello una sintaxis especial:


@example
floss$ cvs -q update -d -j "Release-1999_05_01-bugfixes:2 days ago" \ 
                     -j Release-1999_05_01-bugfixes 
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2.2.1 
retrieving revision 1.2.2.2 
Merging differences between 1.2.2.1 and 1.2.2.2 into random.c 
floss$ 
@end example

Si el nombre de la rama va seguido de un signo de dos puntos y a
continuación por una fecha en un formato válido para CVS, CVS
incluirá solamente los cambios habidos después de esa fecha.
De este modo, si sabe que la corrección original del fallo se
envió a la rama hace tres días, el comando precedente fusionaría
solamente la segunda corrección.

Una forma mejor de hacer esto, en este caso adelantándonos para tener
en cuenta este tipo de eventualidades, sería marcar la rama después de
implantar cada corrección (sólo una marca normal; no se trata de iniciar
una nueva rama ni nada parecido). Supongamos que después de corregir el
fallo en la rama y aplicar la corrección al repositorio, hacemos esto en
la copia de trabajo de la rama:


@example
floss$ cvs -q tag Release-1999_05_01-bugfixes-correc1 
T README.txt 
T hello.c 
T a-subdir/loquesea.c 
T a-subdir/subsubdir/fish.c 
T b-subdir/random.c 
floss$ 
@end example

De esa forma, cuando llegue el momento de fusionar el segundo cambio en el
tronco, podrá utilizar la marca que ha tenido la buena idea de colocar ahí
para delimitar la revisión anterior:

@example
floss$ cvs -q update -d -j Release-1999_05_01-bugfixes-correc1 \
                     -j Release-1999_05_01-bugfixes
RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v 
retrieving revision 1.2.2.1 
retrieving revision 1.2.2.2 
Merging differences between 1.2.2.1 and 1.2.2.2 into random.c 
floss$ 
@end example

Ni que decir tiene que este método es mucho mejor que intentar recordar
cuánto tiempo hace que hizo tal o cual modificación, pero sólo funcionará
si se acuerda de marcar la rama cada vez que la fusione con el tronco.
La lección aprendida aquí es, por tanto, ¡marcar pronto y a menudo! Es
mejor pecar de tener demasiadas marcas (siempre y cuando tengan nombres
lo suficientemente descriptivos) que de tener muy pocas. En estos últimos
ejemplos que le he dado no había ninguna necesidad de que la nueva marca
de la rama tuviese un nombre similar al de la marca de la rama en sí.
Si bien yo utilicé el nombre @code{Release-1999_05_01-bugfixes-correc1}, también
podría haber sido @code{correc1}; sin embargo, es preferible emplear el
primero, dado que contiene el nombre de la rama y por tanto no existirá
la posibilidad de que sea confundido con la marca de alguna otra rama.
(Recuerde que los nombres de las marcas son únicos dentro de los ficheros,
no dentro de las ramas. No puede tener dos marcas llamadas @code{correc1} en el
mismo fichero, aunque se refieran a revisiones que se encuentran en
diferentes ramas.)


@c ------------------------------------------------------------------
@node Crear una marca o rama sin una copia de trabajo
@subsection Crear una marca o rama sin una copia de trabajo

Como ya hemos dicho, marcar es algo que afecta al repositorio, no a la copia
de trabajo. Lo cual da pie a que nos preguntemos: ¿por qué entonces es
necesario disponer de una copia de trabajo para marcar?

Pues bien, el único fin que cumple es el de designar qué proyecto y qué
revisiones en concreto de los ficheros del proyecto se están marcando.
Si pudiera especificar el proyecto y las revisiones independientemente
de la copia de trabajo, no sería necesario disponer de ésta.

Y mire usted por dónde, hay una manera de hacer esto: el comando "rtag"
(de "repository tag", o marca de repositorio, N. del T.). Es muy similar
a "tag"; un par de ejemplos bastarán para explicar cómo se usa. Volvamos
atrás al momento en el que llegó a nuestro buzón el primer informe de
fallo y necesitábamos crear una rama que partiese de la última distribución
pública. En nuestro caso, lo que hicimos fue solicitar una copia de trabajo
con la marca de distribución y después ejecutar @w{@code{tag -b}} sobre ella:

@example
floss$ cvs tag -b Release-1999_05_01-bugfixes 
@end example

Esto creó una rama que partía de @code{Release-1999_05_01}. Sin embargo,
puesto que conocemos la marca de la distribución, podríamos haberla usado
en un comando "rtag" para indicar dónde plantar la rama exactamente, sin
ni siquera procurarnos antes una copia de trabajo:

@example
floss$ cvs rtag -b -r Release-1999_05_01 Release-1999_05_01-bugfixes miproyecto
@end example

Y éso es todo. Este comando puede darse desde cualquier lugar, sea dentro o
fuera de una copia de trabajo. Sin embargo, su variable de entorno CVSROOT
debe apuntar, por supuesto, al repositorio, o bien puede referirse a él
empleando la opción global -d. También funciona para marcas que no sean
de ramas, pero es menos útil de esta forma ya que tendrá que indicar el
número de revisión de cada fichero, uno por uno. (O puede referirse a ellos
empleando una marca, pero entonces obviamente ya tendría una marca ahí,
en cuyo caso, ¿para qué iba a querer poner una segunda marca a ese mismo
grupo de revisiones?)


Ahora ya sabe lo suficiente como para manejarse con CVS, y posiblemente lo
bastante como para empezar a trabajar con otras personas en un proyecto.
Todavía quedan algunas características de menos importancia que no se han
abordado, así como algunas opciones para los comandos ya comentados, que
también resultan útiles. Todas ellas serán presentadas donde corresponda a
lo largo de los próximos capítulos, en situaciones que le mostrarán cómo
y por qué utilizarlas. Cuando tenga alguna duda, no dude en consultar el
manual Cederqvist, un recurso indispensable para los usuarios habituales de
CVS.


