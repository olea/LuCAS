This is cvsbook.info, produced by makeinfo version 4.0b from main.texi.

START-INFO-DIR-ENTRY
* El libro de CVS: (cvsbook).           Un tutorial de CVS y referencia.
END-INFO-DIR-ENTRY

Copyright (C) 1999, 2000 Karl Fogel <kfogel@red-bean.com>

This document is free software; you can redistribute and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Este manual describe como usar y administrar CVS (Concurrent Versions
System). Es parte un trabajo mayor titulado `Desarrollo de Código
Abierto con CVS'; por favor, lea la introducción para más detalles.

Esta es la versión 1.21 de este manual.


File: cvsbook.info,  Node: Conceptos básicos sobre ramas,  Next: Fusión de cambios desde las ramas al tronco,  Up: Ramas

Conceptos básicos sobre ramas
-----------------------------

¿Por qué son útiles las ramas?

Volvamos por un momento a la situación del desarrollador que, mientras
está trabajando en una nueva versión del programa, recibe un informe de
fallo relativo a una versión publicada anteriormente. Suponiendo que el
desarrollador corrija el problema, aún tiene que encontrar una forma de
enviar la corrección al cliente. No le servirá de nada limitarse a tomar
una copia vieja del programa, parchearla a espaldas de CVS, y enviarla
tal cual: no quedaría registro alguno de lo que ha hecho, CVS no sabría
nada de esta corrección, y más adelante, si por un casual se descubriera
un fallo en el propio parche, nadie tendría un punto desde el que
comenzar a intentar reproducir el problema.

Es incluso peor intentar solucionar el fallo en la versión actual e
inestable de las fuentes y entregar esto al cliente. Oh sí, el fallo
del que se ha dado parte quizás quedase resuelto, pero el resto del
código está a medio cocer y por lo general falto de un proceso de
pruebas pertinente. Puede darse el caso de que funcione, pero es seguro
que no está listo para llegar al gran público.

Dado que se supone que la última versión distribuida es estable (dejando
aparte este fallo), la solución ideal es ir atrás y corregir el fallo en
la antigua versión; esto es, crear un universo alternativo en el que la
última versión pública incluye la correspondiente corrección.

Y aquí es donde entran en juego las ramas. El desarrollador planta una
rama, que parte de la línea principal de desarrollo (el tronco), no en
su revisiones más recientes, sino en el punto de la última distribución
pública. Entonces el desarrollador solicita una copia de trabajo de esta
rama, realiza todos los cambios necesarios para solventar el fallo, y
los envía a esa rama, de forma que quede un registro de la corrección
del fallo. Ahora puede hacer público un parche intermedio basado en esta
rama, y enviarlo al cliente.

Su cambio no habrá afectado al código del tronco, puesto que tampoco le
interesaría hacerlo sin antes averiguar si el tronco necesita o no que
se aplique sobre él la misma corrección. En caso positivo, el
desarrollador puede fusionar los cambios realizados sobre la rama con
el código presente en el tronco. Durante el proceso de fusión, CVS
calcula los cambios hechos en la rama desde el momento en el que ésta
salió del tronco hasta el extremo de la misma (su estado más reciente),
y entonces aplica estas diferencias al proyecto, en el extremo final
del tronco. La diferencia entre la raíz de la rama y su extremo final
vendría a ser, por supuesto, la corrección que se ha realizado.

Otra buena forma de imaginar una fusión es como un caso especial del
proceso de actualización; la diferencia estriba en que, durante una
fusión, los cambios a incorporar se derivan de la comparación entre la
raíz y el extremo de la rama, en lugar de comparar la copia de trabajo
con el contenido del repositorio.

El proceso de actualización es en sí mismo similar a recibir parches
directamente de los autores, y aplicarlos a mano; de hecho, para hacer
una actualización, CVS calcula la diferencia (entendiendo como
"diferencia" el resultado que devolvería el comando diff al comparar
dos ficheros distintos) entre la copia de trabajo y el repositorio,
para a continuación aplicar la diferencia a la copia de trabajo tal y
como lo haría el programa "patch". Esto equivale a la forma en que un
desarrollador obtiene cambios del mundo exterior, aplicando manualmente
parches creados por otros.

Así pues, fusionar con el tronco la rama donde se ha hecho la corrección
es exactamente lo mismo que aceptar un parche que ha hecho otra persona
para corregir el fallo. El autor de ese parche habría generado el parche
a partir de la última versión hecha pública, de la misma forma que los
cambios en la rama lo son respecto a esa versión. Si esa parte del
código en las fuentes actuales no ha variado mucho desde la última
versión pública, la fusión tendrá éxito sin ningún problema. Ahora
bien, si el código es en este momento lo suficientemente diferente, la
fusión derivará en conflicto (en otras palabras, el parche será
rechazado), y será necesario cierto trabajo extra. Normalmente esto se
resuelve examinando la parte donde ha surgido el conflicto, haciendo
manualmente los cambios necesarios, y enviando esos cambios al
repositorio. La Figura 2.3 muestra gráficamente lo que sucede en una
rama y en una fusión.


                 (rama donde se corrigió el error)
                .---------------->---------------.
               /                                 |
              /                                  |
             /                                   |
            /                                    |
           /                                     V (<---- lugar de la fusión)
      ====*===================================================================>
                     (línea principal de desarrollo)
     
     
     [Figura 2.3: Una rama que termina con una fusión. El tiempo transcurre
     de izquierda a derecha.]

Ahora vamos a ver los pasos necesarios para llevar a cabo el
procedimiento descrito. Recuerde que no es realmente el tiempo lo que
fluye de izquierda a derecha en el diagrama, sino más bien el historial
de revisiones. La rama no se habrá hecho en el momento de la
distribución, sino que es creada más tarde, aunque enraizada en las
revisiones que formaban parte de la distribución.

En nuestro caso, supongamos que los ficheros del proyecto han pasado por
muchas revisiones desde que fueron marcados como `Release-1999_05_01',
y que quizás se hayan añadido también nuevos ficheros. Al recibir el
informe de fallos relativo a la antigua distribución, lo primero que
querremos hacer será crear una rama que parta de la antigua
distribución, que tuvimos el acierto de marcar conmo
`Release-1999_05_01'.

Una forma de hacer esto sería obtener primero una copia de trabajo
basada en dicha marca, y a continuación crear la rama volviendo a
marcar con la opción -b (de "branch", o "rama" en inglés - N. del T.):

     floss$ cd ..
     floss$ ls
     miproyecto/
     floss$ cvs -q checkout -d miproyecto_antigua_dis -r Release-1999_05_01 miproyecto
     U miproyecto_antigua_dis/README.txt
     U miproyecto_antigua_dis/hello.c
     U miproyecto_antigua_dis/a-subdir/loquesea.c
     U miproyecto_antigua_dis/a-subdir/subsubdir/fish.c
     U miproyecto_antigua_dis/b-subdir/random.c
     floss$ ls
     miproyecto/      miproyecto_antigua_dis/
     floss$ cd miproyecto_antigua_dis
     floss$ ls
     CVS/      README.txt  a-subdir/   b-subdir/   hello.c
     floss$ cvs -q tag -b Release-1999_05_01-bugfixes
     T README.txt
     T hello.c
     T a-subdir/loquesea.c
     T a-subdir/subsubdir/fish.c
     T b-subdir/random.c
     floss$

Observe bien el último comando. Puede parecer un tanto arbitrario el
utilizar "tag" para crear ramas, pero en realidad hay una razón para
ello: el nombre de la marca servirá como una etiqueta con la cual
podremos más tarde hacer alusión a esta rama. Las marcas en las ramas
no tienen un aspecto diferente al de las utilizadas en otra parte, y de
hecho están sujetas a las mismas limitaciones. A algunas personas les
gusta incluir siempre la palabra "rama" en el nombre de la marca (por
ejemplo `Release-1999_05_01-ramadecorrección') para poder distinguir
fácilmente entre marcas de rama y otros tipos de marcas. Tal vez le
interese también a usted hacer lo mismo si alguna que otra vez se
confunde y solicita la rama equivocada.

(Y ya que estamos, observe la opción -d miproyecto_antigua_dis que
pasamos al comando "checkout" en la primer comando CVS. Esto le dice a
checkout que instale la copia de trabajo en un directorio llamado
miproyecto_antigua_dis, de forma que no confundamos estos ficheros con
la versión actual de miproyecto. Tenga cuidado de no confundir este uso
de la -d con la opción global homónima, o con la opción -d del comando
"update".)

Por supuesto, la simple ejecución del comando "tag" no pone la copia de
trabajo en consonancia con la rama. El hecho de marcar no afecta nunca
a la copia de trabajo; tan sólo guarda información adicional en el
repositorio para permitirle a usted recuperar en un momento posterior
las revisiones de esa copia de trabajo (como una parte estática del
historial o como una rama, según el caso).

La recuperación puede hacerse de dos formas (a estas alturas,
seguramente ya se esperaba oir esto). Puede solicitar una nueva copia
de trabajo tomada de la rama:

     floss$ pwd
     /home/loquesea
     floss$ cvs co -d miproyecto_rama -r Release-1999_05_01-bugfixes miproyecto

o pasar a ella una copia de trabajo ya existente:

     floss$ pwd
     /home/loquesea/miproyecto
     floss$ cvs update -r Release-1999_05_01-bugfixes

El resultado final es el mismo (bueno, el nombre del directorio raíz de
la nueva copia de trabajo puede ser distinto, pero respecto a los fines
de CVS esto no importa). Si su copia de trabajo actual tiene cambios aún
sin enviar, probablemente querrá utilizar "checkout" en lugar de
"update" para acceder a la rama; de lo contrario, CVS intentará
fusionar los cambios habidos en su copia de trabajo antes de colocarla
en la rama. En este caso podría encontrarse con algún conflicto, y aún
en caso de que no fuese así, seguiría sin tener una rama pura: esos
ficheros no reflejarán realmente el estado del programa de acuerdo con
la marca designada, puesto que algunos de ellos contendrán
modificaciones hechas por usted.

Sea como fuere, vamos a suponer que de una forma o de otra usted obtiene
una copia de trabajo operativa desde la rama deseada:

     floss$ cvs -q status hello.c
     ===================================================================
     File: hello.c                 Status: Up-to-date
        Working revision:  1.5     Tue Apr 20 06:12:56 1999
        Repository revision:       1.5     /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:                Release-1999_05_01-bugfixes
     (branch: 1.5.2)
        Sticky Date:               (none)
        Sticky Options:            (none)
     floss$ cvs -q status b-subdir/random.c
     ===================================================================
     File: random.c                Status: Up-to-date
        Working revision:  1.2     Mon Apr 19 06:35:27 1999
        Repository revision:       1.2 /usr/local/cvs/miproyecto/b-subdir/random.c,v
        Sticky Tag:                Release-1999_05_01-bugfixes (branch: 1.2.2)
        Sticky Date:               (none)
        Sticky Options:            (none)
     floss$

(El contenido de las líneas `Sticky Tag' se explicará en breve.) Si
modifica hello.c y random.c y envía los cambios al repositorio,

     floss$ cvs -q update
     M hello.c
     M b-subdir/random.c
     floss$ cvs ci -m "corregidos los viejos fallos de puntuación"
     cvs commit: Examining .
     cvs commit: Examining a-subdir
     cvs commit: Examining a-subdir/subsubdir
     cvs commit: Examining b-subdir
     Checking in hello.c;
     /usr/local/cvs/miproyecto/hello.c,v  <-  hello.c
     new revision: 1.5.2.1; previous revision: 1.5
     done
     Checking in b-subdir/random.c;
     /usr/local/cvs/miproyecto/b-subdir/random.c,v  <-  random.c
     new revision: 1.2.2.1; previous revision: 1.2
     done
     floss$

se dará cuenta de que ocurre algo curioso con los números de revisión:

     floss$ cvs -q status hello.c b-subdir/random.c
     ===================================================================
     File: hello.c                 Status: Up-to-date
        Working revision:  1.5.2.1 Wed May  5 00:13:58 1999
        Repository revision:       1.5.2.1 /usr/local/cvs/miproyecto/hello.c,v
        Sticky Tag:                Release-1999_05_01-bugfixes (branch: 1.5.2)
        Sticky Date:               (none)
        Sticky Options:            (none)
     ===================================================================
     File: random.c                Status: Up-to-date
        Working revision:  1.2.2.1 Wed May  5 00:14:25 1999
        Repository revision:       1.2.2.1 /usr/local/cvs/miproyecto/b-subdir/random.c,v
        Sticky Tag:                Release-1999_05_01-bugfixes (branch: 1.2.2)
        Sticky Date:               (none)
        Sticky Options:            (none)
     floss$

¡Ahora tienen cuatro dígitos en lugar de dos!

Un vistazo más de cerca nos revela que el número de revisión de cada
fichero es simplemente el número de la rama (tal como se indica en la
línea `Sticky Tag'), con un dígito extra al final.

Lo que está presenciando es tan sólo una parte del funcionamiento
interno de CVS. Aunque casi siempre utilizará una rama para marcar una
divergencia que afecte a la globalidad del proyecto, en realidad CVS
registra la rama de forma individual, fichero a fichero. Este proyecto
tenía cinco ficheros en el momento de crear la rama, así que en
realidad se han creado cinco ramas, todas ellas con la misma marca:
`Release-1999_05_01-bugfixes'.

La mayoría de la gente considera esta forma de hacer las cosas como una
implantación bastante poco elegante por parte de CVS, pero en realidad
lo que estamos viendo aquí es parte del legado de RCS: RCS no sabía cómo
agrupar ficheros en los proyectos, y a pesar de que CVS sí lo hace,
sigue utilizando código heredado de RCS para manejar las ramas.

Por regla general, usted no necesitará preocuparse demasiado por cómo
CVS registra las cosas de forma interna, pero en este caso, resulta útil
comprender la relación que existe entre números de ramas y números de
revisiones. Veamos el fichero hello.c; todo lo que estoy a punto de
decirle sobre hello.c se aplica a cualquier otro fichero presente en la
rama, cambiando los números de revisión y de rama según convenga.

En el momento del nacimiento de la rama, el fichero hello.c se
encontraba en su revisión 1.5. Cuando creamos la rama, se añadió un
nuevo número al final para así formar un número de rama (CVS elige el
primer número entero par que no sea cero y que esté libre). Por tanto,
en este caso, el número de rama terminó siendo `1.5.2'. El número de la
rama no es en sí mismo un número de revisión, pero sí es la raíz (es
decir, el prefijo) de todos los números de revisión para hello.c que se
emplearán en esta rama.

Sin embargo, cuando ejecutamos aquel primer comando "CVS status" en una
copia de trabajo ramificada, el número de revisión de hello.c apareció
como `1.5' solamente, y no como `1.5.2.0' o algo parecido. Esto se debe
a que la revisión inicial de una rama es siempre la misma que la
revisión que el fichero tiene en el tronco, donde nació la rama. Por
tanto, CVS mostrará el número de revisión del tronco en el informe de
estado mientras el fichero sea el mismo tanto en la rama como en el
tronco.

Una vez que enviamos una nueva revisión al repositorio, hello.c ya no
era igual en el tronco que en la rama: la copia que estaba en la rama
había cambiado, mientras que la copia presente en el tronco seguía
igual. Es por ello por lo que se asignó a hello.c su primer número de
revisión de rama, tal como pudimos comprobar después de hacer el envío
en el informe de estado, donde su número de revisión aparecía
claramente como `1.5.2.1'.

Esta misma situación se aplica al fichero random.c. Su número de
revisión en el momento de crear la rama era `1.2', así que su primera
rama es `1.2.2', y el primer nuevo envío de random.c en esta rama
recibió el número de revisión `1.2.2.1'.

No existe ninguna relación numérica entre `1.5.2.1' y `1.2.2.1'.  No
hay razón alguna para pensar que forman parte de la misma rama excepto
por el hecho de que ambos ficheros están marcados con
`Release-1999_05_01-bugfixes', y que la marca está asociada a los
números de rama `1.5.2' y `1.2.2' en los respectivos ficheros.  Por
tanto, el nombre de la marca es su único recurso en la rama para
concebirla como una entidad global. Aunque es perfectamente posible
trasladar un fichero a una rama usando directamente el número de
revisión,

     floss$ cvs update -r 1.5.2.1 hello.c
     U hello.c
     floss$

casi siempre es una mala idea hacerlo, puesto que estaría mezclando la
revisión en la rama de un fichero con las revisiones fuera de rama de
otros. ¿Quién sabe qué ficheros podría perder? Es mejor usar la marca
de la rama para referirse a la rama y tratar todos los ficheros de una
sola vez, evitando referirnos a ningún fichero en concreto; de esta
forma no tiene que conocer ni preocuparse del número de revisión de
rama de ningún fichero en particular.

También es posible hacer ramas que nacen de otras ramas, hasta llegar a
niveles que podrían considerarse absurdos. Por ejemplo, si un fichero
tuviese el número de revisión `1.5.4.37.2.3', el historial de sus
revisiones podría esquematizarse con algo como esto:

                       1.1
                        |
                       1.2
                        |
                       1.3
                        |
                       1.4
                        |
                       1.5
                      /   \
                     /     \
                    /       \
                (1.5.2)   (1.5.4)         <--- (éstos son números de ramas)
                  /           \
              1.5.2.1        1.5.4.1
                 |              |
              1.5.2.2        1.5.4.2
                 |              |
               (etc)          (...)       <--- (34 revisiones omitidas por brevedad)
                                |
                             1.5.4.37
                               /
                              /
                        (1.5.4.37.2)      <--- (esto es también un número de rama)
                            /
                           /
                    1.5.4.37.2.1
                          |
                    1.5.4.37.2.2
                          |
                    1.5.4.37.2.3
     
     [Figura 2.4: Un número extrañamente elevado de ramificaciones. El tiempo
     transcurre hacia abajo.]

Naturalmente, sólo circunstancias muy especiales harían necesario tal
grado de ramificaciones, pero, ¿no es agradable saber que CVS llegará
todo lo lejos que usted se proponga? Las ramas anidadas se crean de la
misma forma que cualquier otra rama: obtenga una copia de trabajo de la
rama `N', ejecute "cvs tag -b nombre_de_rama" sobre ella, y de esta
forma creará la rama `N.M' en el repositorio (donde `N' representa el
número de revisión de rama apropiado en cada fichero, como por ejemplo
`1.5.2.1', mientras que `M' representa la siguiente rama disponible al
final de ese número, como por ejemplo `2').


File: cvsbook.info,  Node: Fusión de cambios desde las ramas al tronco,  Next: Fusiones múltiples,  Prev: Conceptos básicos sobre ramas,  Up: Ramas

Fusión de cambios desde las ramas al tronco
-------------------------------------------

Ahora que hemos aplicado la corrección del fallo a la rama,
sincronicemos la copia de trabajo con la revisiones más recientes
presentes en el tronco y veamos si también allí es necesaria la
corrección. Vamos a obtener la copia de trabajo desde la rama empleando
"update -A" (en este aspecto, las marcas de rama son como cualquier
otra propiedad pegadiza) y entonces ver las diferencias respecto a la
rama que acabamos de dejar:

     floss$ cvs -q update -d -A
     U hello.c
     U b-subdir/random.c
     floss$ cvs -q diff -c -r Release-1999_05_01-bugfixes
     Index: hello.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.5.2.1
     retrieving revision 1.6
     diff -c -r1.5.2.1 -r1.6
     *** hello.c   1999/05/05 00:15:07     1.5.2.1
     --- hello.c   1999/05/04 20:19:16     1.6
     ***************
     *** 4,9 ****
       main ()
       {
         printf ("¡Hola, mundo!\n");
     !   printf ("entre el saludo y la despedida\n");
         printf ("¡Adiós, mundo!\n");
       }
     --- 4,10 --
       main ()
       {
         printf ("¡Hola, mundo!\n");
     !   printf ("entre hola y adiós\n");
         printf ("¡Adiós, mundo!\n");
     +   /* un comentario en la última línea */
       }
     Index: b-subdir/random.c
     ===================================================================
     RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
     retrieving revision 1.2.2.1
     retrieving revision 1.2
     diff -c -r1.2.2.1 -r1.2
     *** b-subdir/random.c 1999/05/05 00:15:07     1.2.2.1
     --- b-subdir/random.c 1999/04/19 06:35:27     1.2
     ***************
     *** 4,8 ****
       void main ()
       {
     !   printf ("Un número aleatorio.\n");
       }
     --- 4,8 --
       void main ()
       {
     !   printf ("un número aleatorio\n");
       }
     floss$

El comando "diff" muestra que hay una línea que difiere en la revisión
en rama de hello.c, y que la revisión del tronco de este fichero tiene
un comentario cerca del final que la revisión de la rama no tiene.
Mientras, en random.c, la revisión en la rama tiene una "U" mayúscula y
un punto, mientras que en la revisión presente en el tronco no aparece
esto.

Para fusionar los cambios de una rama con la actual copia de trabajo,
haga una actualización con la opción -j (la misma j de "juntar" que
utilizamos anteriormente para revertir un fichero a una revisión más
antigua):

     floss$ cvs -q update -d -j Release-1999_05_01-bugfixes
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.5
     retrieving revision 1.5.2.1
     Merging differences between 1.5 and 1.5.2.1 into hello.c
     RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
     retrieving revision 1.2
     retrieving revision 1.2.2.1
     Merging differences between 1.2 and 1.2.2.1 into random.c
     floss$ cvs -q update
     M hello.c
     M b-subdir/random.c
     floss$ cvs -q ci -m "fusión con la rama Release-1999_05_01-bugfixes"
     Checking in hello.c;
     /usr/local/cvs/miproyecto/hello.c,v  <-  hello.c
     new revision: 1.7; previous revision: 1.6
     done
     Checking in b-subdir/random.c;
     /usr/local/cvs/miproyecto/b-subdir/random.c,v  <-  random.c
     new revision: 1.3; previous revision: 1.2
     done
     floss$

Este ejemplo toma los cambios habidos desde la raíz de la rama hasta su
extremo final y más reciente, y los fusiona con la copia de trabajo
actual, que a partir de ese momento mostrará esas mismas modificaciones
como si sus ficheros hubieran sido editados a mano para llevarlos a ese
estado.  Los cambios son entonces aplicados al tronco, puesto que nada
había cambiado en el repositorio cuando una copia de trabajo sufrió un
proceso de fusión.

Si bien en este ejemplo no se han producido conflictos, es bastante
posible (e incluso probable) que hubiera algunos en una fusión hecha en
un proyecto real, en cuyo caso estos conflictos tendrían que resolverse
igual que cualquier otro conflicto, para a continuación poder aplicar
los cambios.


File: cvsbook.info,  Node: Fusiones múltiples,  Next: Crear una marca o rama sin una copia de trabajo,  Prev: Fusión de cambios desde las ramas al tronco,  Up: Ramas

Fusiones múltiples
------------------

A veces, una rama seguirá teniendo un desarrollo activo aún después de
que su contenido haya sido fusionado con el tronco. Por ejemplo, esto
puede suceder si se descubre un segundo fallo en la antigua distribución
pública y este fallo ha de ser corregido en la rama. Cabe la posibilidad
de que alguien no hubiese entendido la broma que hay en random.c, así
que tendría usted que añadir una línea explicándola:

     floss$ pwd
     /home/loquesea/miproyecto_rama
     floss$ cat b-subdir/random.c
     /* Imprimir un número aleatorio. */
     #include <stdio.h>
     void main ()
     {
       printf ("Un número aleatorio.\n");
       printf ("¿Ha entendido el chiste?\n");
     }
     floss$

y enviar el cambio. Si también es necesario fusionar esa corrección en
el tronco, podría tener la tentación de utilizar el mismo comando
"update" de antes en la copia de trabajo presente en el tronco para
llevar a cabo la "re-fusión":

     floss$ cvs -q update -d -j Release-1999_05_01-bugfixes
     RCS file: /usr/local/cvs/miproyecto/hello.c,v
     retrieving revision 1.5
     retrieving revision 1.5.2.1
     Merging differences between 1.5 and 1.5.2.1 into hello.c
     RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
     retrieving revision 1.2
     retrieving revision 1.2.2.2
     Merging differences between 1.2 and 1.2.2.2 into random.c
     rcsmerge: warning: conflicts during merge
     floss$

Como puede ver, este comando no ha tenido el efecto deseado: nos
encontramos con un conflicto, a pesar de que la copia en el tronco no
había sido modificada y, por tanto, no esperábamos encontrarnos ninguno.

El problema reside en que el comando "update" se ha comportado
exactamente de la forma descrita: ha intentado tomar todos los cambios
habidos desde la raíz de la rama y su extremo final, y a continuación
fusionarlos tomando como referencia la copia de trabajo actual. El
único problema está en que algunos de estos cambios ya habían sido
fusionados desde esta copia de trabajo, de ahí que surgiese el
conflicto:

     floss$ pwd
     /home/loquesea/miproyecto
     floss$ cat b-subdir/random.c
     /* Imprimir un número aleatorio. */
     #include <stdio.h
     void main ()
     {
     <<<<<<< random.c
       printf ("Un número aleatorio.\n");
     =======
       printf ("Un número aleatorio.\n");
       printf ("¿Ha entendido el chiste?\n");
     >>>>>>> 1.2.2.2
     }
     floss$

Llegados a este punto, podría intentar resolver estos conflictos a mano,
dado que no es difícil ver lo que es necesario hacer en cada fichero.
Sin embargo, es todavía mejor tomar medidas desde el principio para
evitar conflictos. Pasando dos opciones "-j" en lugar de una, obtendrá
sólo los cambios habidos desde la última vez que hizo una fusión con el
extremo final de la rama, en lugar de tener en consideración todos los
cambios habidos en ella. La primera -j le da el punto inicial de la
rama, y la la segunda es sólo el nombre de la rama, que implica su
extremo final y más reciente.

La cuestión entonces es, ¿cómo puede especificar el punto de la rama
desde el que quizo la última fusión? Una forma de hacerlo sería indicar
una fecha junto con el nombre de la marca dispuesta en la rama. CVS
ofrece para ello una sintaxis especial:

     floss$ cvs -q update -d -j "Release-1999_05_01-bugfixes:2 days ago" \
                          -j Release-1999_05_01-bugfixes
     RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
     retrieving revision 1.2.2.1
     retrieving revision 1.2.2.2
     Merging differences between 1.2.2.1 and 1.2.2.2 into random.c
     floss$

Si el nombre de la rama va seguido de un signo de dos puntos y a
continuación por una fecha en un formato válido para CVS, CVS incluirá
solamente los cambios habidos después de esa fecha.  De este modo, si
sabe que la corrección original del fallo se envió a la rama hace tres
días, el comando precedente fusionaría solamente la segunda corrección.

Una forma mejor de hacer esto, en este caso adelantándonos para tener
en cuenta este tipo de eventualidades, sería marcar la rama después de
implantar cada corrección (sólo una marca normal; no se trata de iniciar
una nueva rama ni nada parecido). Supongamos que después de corregir el
fallo en la rama y aplicar la corrección al repositorio, hacemos esto en
la copia de trabajo de la rama:

     floss$ cvs -q tag Release-1999_05_01-bugfixes-correc1
     T README.txt
     T hello.c
     T a-subdir/loquesea.c
     T a-subdir/subsubdir/fish.c
     T b-subdir/random.c
     floss$

De esa forma, cuando llegue el momento de fusionar el segundo cambio en
el tronco, podrá utilizar la marca que ha tenido la buena idea de
colocar ahí para delimitar la revisión anterior:

     floss$ cvs -q update -d -j Release-1999_05_01-bugfixes-correc1 \
                          -j Release-1999_05_01-bugfixes
     RCS file: /usr/local/cvs/miproyecto/b-subdir/random.c,v
     retrieving revision 1.2.2.1
     retrieving revision 1.2.2.2
     Merging differences between 1.2.2.1 and 1.2.2.2 into random.c
     floss$

Ni que decir tiene que este método es mucho mejor que intentar recordar
cuánto tiempo hace que hizo tal o cual modificación, pero sólo
funcionará si se acuerda de marcar la rama cada vez que la fusione con
el tronco.  La lección aprendida aquí es, por tanto, ¡marcar pronto y a
menudo! Es mejor pecar de tener demasiadas marcas (siempre y cuando
tengan nombres lo suficientemente descriptivos) que de tener muy pocas.
En estos últimos ejemplos que le he dado no había ninguna necesidad de
que la nueva marca de la rama tuviese un nombre similar al de la marca
de la rama en sí.  Si bien yo utilicé el nombre
`Release-1999_05_01-bugfixes-correc1', también podría haber sido
`correc1'; sin embargo, es preferible emplear el primero, dado que
contiene el nombre de la rama y por tanto no existirá la posibilidad de
que sea confundido con la marca de alguna otra rama.  (Recuerde que los
nombres de las marcas son únicos dentro de los ficheros, no dentro de
las ramas. No puede tener dos marcas llamadas `correc1' en el mismo
fichero, aunque se refieran a revisiones que se encuentran en
diferentes ramas.)


File: cvsbook.info,  Node: Crear una marca o rama sin una copia de trabajo,  Prev: Fusiones múltiples,  Up: Ramas

Crear una marca o rama sin una copia de trabajo
-----------------------------------------------

Como ya hemos dicho, marcar es algo que afecta al repositorio, no a la
copia de trabajo. Lo cual da pie a que nos preguntemos: ¿por qué
entonces es necesario disponer de una copia de trabajo para marcar?

Pues bien, el único fin que cumple es el de designar qué proyecto y qué
revisiones en concreto de los ficheros del proyecto se están marcando.
Si pudiera especificar el proyecto y las revisiones independientemente
de la copia de trabajo, no sería necesario disponer de ésta.

Y mire usted por dónde, hay una manera de hacer esto: el comando "rtag"
(de "repository tag", o marca de repositorio, N. del T.). Es muy similar
a "tag"; un par de ejemplos bastarán para explicar cómo se usa. Volvamos
atrás al momento en el que llegó a nuestro buzón el primer informe de
fallo y necesitábamos crear una rama que partiese de la última
distribución pública. En nuestro caso, lo que hicimos fue solicitar una
copia de trabajo con la marca de distribución y después ejecutar
`tag -b' sobre ella:

     floss$ cvs tag -b Release-1999_05_01-bugfixes

Esto creó una rama que partía de `Release-1999_05_01'. Sin embargo,
puesto que conocemos la marca de la distribución, podríamos haberla
usado en un comando "rtag" para indicar dónde plantar la rama
exactamente, sin ni siquera procurarnos antes una copia de trabajo:

     floss$ cvs rtag -b -r Release-1999_05_01 Release-1999_05_01-bugfixes miproyecto

Y éso es todo. Este comando puede darse desde cualquier lugar, sea
dentro o fuera de una copia de trabajo. Sin embargo, su variable de
entorno CVSROOT debe apuntar, por supuesto, al repositorio, o bien
puede referirse a él empleando la opción global -d. También funciona
para marcas que no sean de ramas, pero es menos útil de esta forma ya
que tendrá que indicar el número de revisión de cada fichero, uno por
uno. (O puede referirse a ellos empleando una marca, pero entonces
obviamente ya tendría una marca ahí, en cuyo caso, ¿para qué iba a
querer poner una segunda marca a ese mismo grupo de revisiones?)

Ahora ya sabe lo suficiente como para manejarse con CVS, y posiblemente
lo bastante como para empezar a trabajar con otras personas en un
proyecto.  Todavía quedan algunas características de menos importancia
que no se han abordado, así como algunas opciones para los comandos ya
comentados, que también resultan útiles. Todas ellas serán presentadas
donde corresponda a lo largo de los próximos capítulos, en situaciones
que le mostrarán cómo y por qué utilizarlas. Cuando tenga alguna duda,
no dude en consultar el manual Cederqvist, un recurso indispensable
para los usuarios habituales de CVS.


File: cvsbook.info,  Node: Administracion del Repositorio,  Next: CVS avanzado,  Prev: Una introduccion a CVS,  Up: Top

Administracion del Repositorio
******************************

En *Note Una introduccion a CVS::, usted ha aprendido bastante de CVS
para usarlo de forma eficaz como participante de un proyecto.  Sin
embargo, si va a ser administrador de un proyecto, necesitará conocer
cómo instalar CVS y administrar repositorios.  En este capítulo
descorreremos la cortina y observaremos en detalle cómo se estructura
el repositorio, y cómo lo utiliza CVS.  Aprenderá los pasos más
importantes por los que pasa CVS durante las actualizaciones y envíos
("commits"), y cómo puede modificar su comportamiento.  Comprendiendo
cómo trabaja CVS, será también capaz de encontrar las causas de los
problemas, y resolverlos de forma mantenible.

Esto puede parecer muy complicado, pero recuerde que CVS ya ha probado
ser bastante duradero, y seguramente seguirá usándose durante muchos
años más.  Lo que aprenda ahora le será de utilidad durante mucho
tiempo.  CVS también tiende a hacerse más indispensable cuanto más lo
use.  Si va a depender tanto de algo (y hágame caso, así será),
realmente vale la pena que llegue a conocerlo.

Con esto en mente, vamos a comenzar por el principio: poniendo CVS en su
sistema.

* Menu:

* Consiguiendo e instalando CVS::                 Poniendo CVS en su sistema.
* Anatomia de una distribucion CVS::              Qué hay en la distribución CVS.
* Iniciando un repositorio::                      Poniendo a punto un repositorio.
* El servidor de autentificacion de contrasen~as:: Un método de acceso remoto.
* Acceso anonimo::                                Garantizando acceso al público.
* Estructura del repositorio::                    Cómo se organiza el repositorio.
* Formato RCS::                                   Cómo funciona el almacenamiento en el repositorio.
* Qué ocurre cuando elimina un fichero::          CVS reserva un ático para los ficheros antiguos.
* El directorio administrativo CVSROOT/::         Ficheros de configuración del servidor en tiempo de ejecución.
* Correos de envío de cambios::                   Fijando envíos automáticos de notificaciones.
* Averiguando más::                               Otras fuentes de información.


File: cvsbook.info,  Node: Consiguiendo e instalando CVS,  Next: Anatomia de una distribucion CVS,  Up: Administracion del Repositorio

Consiguiendo e instalando CVS
=============================

En muchos casos, no tendrá que salir a buscar CVS, porque ya estará en
su sistema.  Si posee una de las distribuciones principales de Linux o
FreeBSD, seguramente está instalado en /usr/bin o alguna otra
localización probable.  Si no, los usuarios de Red Hat Linux pueden
encontrar por lo general un RPM ("Red Hat Package", o Paquete de Red
Hat) con la última versión de CVS (o casi la última) en sus
distribuciones.  Y los usuarios de Debian pueden instalar el último
paquete Debian con estas órdenes:

     floss$ apt-get update
     floss$ apt-get install cvs

Si CVS no está ya en su máquina, probablemente tendrá que compilarlo a
partir del código fuente.  Si no es un usuario de Unix, seguramente
encuentre más fácil conseguir un binario precompilado para su sistema
operativo (más adelante se detalla este aspecto).  Afortunadamente, CVS
está totalmente "autoconfigurado" - es decir, utiliza el mecanismo de
autoconfiguración de GNU, con lo que la compilación a partir de las
fuentes es sorprendentemente sencilla.

* Menu:

* Consiguiendo y compilando CVS bajo Unix::
* Consiguiendo e instalando CVS bajo Windows::
* Consiguiendo e instalando CVS en un Macintosh::
* Limitaciones de las versiones Windows y Macintosh::


File: cvsbook.info,  Node: Consiguiendo y compilando CVS bajo Unix,  Next: Consiguiendo e instalando CVS bajo Windows,  Up: Consiguiendo e instalando CVS

Consiguiendo y compilando CVS bajo Unix
---------------------------------------

En el momento de escribir esto, existen dos sitios principales de los
que se puede descargar CVS.  Uno es el servidor FTP de la Fundación
para el Software Libre, `ftp://ftp.gnu.org/gnu/cvs/', que ofrece CVS
como herramienta oficial GNU.  El otro es el sitio de descarga de
Cyclic Software.  Cyclic Software es, si no el "administrador" de CVS,
sí el "administrador de los administradores", proporcionando un
servidor de repositorio y acceso para descargar a usuarios y
desarrolladores.  Distribuyen versiones desde
`http://download.cyclic.com/pub/'.

Cualquiera de los dos sitios es bueno.  En el siguiente ejemplo, uso el
sitio de Cyclic Software.  Si dirige su cliente FTP (seguramente su
navegador Web) hacia allí, verá una lista de directorios, algo como
esto:

     Index of /pub
         cvs-1.10.5/            18-Feb-99 21:36      -
         cvs-1.10.6/            17-May-99 10:34      -
         cvs-1.10/              09-Dec-98 17:26      -
         macintosh/             23-Feb-99 00:53      -
         os2/                   09-Dec-98 17:26      -
         packages/              09-Dec-98 17:26      -
         rcs/                   09-Dec-98 17:26      -
         tkcvs/                 09-Dec-98 17:26      -
         training/              09-Dec-98 17:26      -
         unix/                  09-Dec-98 17:26      -
         vms/                   09-Dec-98 17:26      -

Preste atención a los directorios que empiezan por "cvs-" (puede ignorar
la mayoría de los demás).  Hay tres directorios de este tipo, lo que
significa que se enfrenta a una elección: Descargar la versión llamada
"estable", o ir a por una versión intermedia más reciente (pero menos
probada).  Las versiones estables tienen sólo un punto decimal, como en
"cvs-1.10", mientras que las versiones intermedias tienen incrementos
de versión menores añadidos al final, como en "1.10.5".

El sitio de GNU sólo ofrece las versiones principales, no las
intermedias, así que no verá todas las anteriores si consigue CVS desde
aquí.  En general, las versiones intermedias han sido bastante seguras,
y a veces resuelven problemas encontrados en las versiones principales.
La mejor política es ir a por la versión intermedia más alta, pero si
encuentra cualquier problema con ella, prepárese para bajar a la
versión anterior, tantas veces como sea necesario.  La versión más alta
listada en el ejemplo anterior es cvs-1.10.6.  Entrando en ese
directorio, veremos esto:

     Index of /pub/cvs-1.10.6
         cvs-1.10.6.tar.gz      17-May-99 08:44   2.2M

Esto es - el código fuente completo de CVS.  Descárguelo a su máquina y
estará preparado para compilar.  En este punto, si ya esta familiarizado
con el proceso de compilación estándar para herramientas GNU, sabrá qué
hacer y probablemente no necesite leer nada desde aquí a la sección
*Note Anatomia de una distribucion CVS::.  Por otra parte, si no está
seguro de cómo continuar, siga leyendo....

Los siguientes ejemplos e instrucciones de compilación asumen que posee
una distribución estándar de Unix.  Cualquiera de las versiones libres
de Unix (por ejemplo, FreeBSD o Linux) debería funcionar sin problemas,
como debería ocurrir en las principales versiones comerciales de Unix
(como SunOS/Solaris, AIX, HP-UX, o Ultrix).  Incluso si estas
instrucciones no funcionan para usted exactamente como están escritas,
no renuncie a la esperanza.  Aunque cubrir los detalles de compilar en
cada sistema operativo está fuera de los objetivos de este libro, daré
indicaciones de otras fuentes de ayuda más adelante en este capítulo.

De todas formas, para seguir adelante con la compilación, primero
descomprima el fichero tar usando GNU unzip y tar (si no los tiene
instalados en su sistema, puede conseguir gunzip de
`ftp://ftp.gnu.org/gnu/gzip/' y la versión GNU de tar de
`ftp://ftp.gnu.org/gnu/tar/'):

     floss$ gunzip cvs-1.10.6.tar.gz
     floss$ tar xvf cvs-1.10.6.tar

Verá muchos nombres de fichero volando por su pantalla.

Ahora tendrá un nuevo directorio en su máquina - cvs-1.10.6 -, que
contendrá el código fuente de CVS.  Entre al directorio y configure CVS
para su sistema, usando el guión "configure" proporcionado:

     floss$ cd cvs-1.10.6
     floss$  ./configure
     creating cache ./config.cache
     checking for gcc... gcc
     checking whether we are using GNU C... yes
     checking whether gcc accepts -g... yes
     checking how to run the C preprocessor... gcc -E
       (etc)

Cuando la orden "configure" finalice, el árbol fuente sabrá todo lo que
necesita saber para compilarse en su máquina.  El siguiente paso
consiste en escribir:

     floss$ make

Verá muchas líneas de salida en su pantalla, después escriba:

     floss$ make install

Verá aún más líneas de salida volando; cuando haya acabado del todo, CVS
estará instalado en su sistema.  (Seguramente necesitará hacer este
último paso como superusuario.)

Por defecto, el ejecutable de CVS acabará siendo `/usr/local/bin/cvs'.
Esto asume que usted tiene un programa "make" decente instalado en su
sistema (de nuevo, si no tiene uno, consiga el "make" del proyecto GNU
en `ftp://ftp.gnu.org/gnu/make/').

Si quiere que CVS se instale en una ruta distinta de /usr/local/bin,
debería cambiar la forma en que ejecuta el paso inicial de
configuración.  Por ejemplo,

     floss$ ./configure --prefix=/usr

da lugar a que CVS esté instalado como /usr/bin/cvs (siempre acaba en
PREFIX/bin/cvs).  El prefijo por defecto es /usr/local, que está bien
para la mayoría de las instalaciones.

Nota Para Usuarios Experimentados: Aunque las versiones antiguas de CVS
consistían en más que un mero ejecutable puesto que dependían de tener
instalado RCS también, este no ha sido el caso desde la Versión 1.10.
Por ello, no necesita preocuparse por ninguna librería o ejecutable
aparte de cvs mismo.

Si solamente pretende usar CVS para acceder a repositorios remotos, lo
anterior es todo lo que necesita hacer.  Si además planea servir un
repositorio desde su sistema, serán necesarios algunos pasos adicionales
que se explican más adelante en este capítulo.


File: cvsbook.info,  Node: Consiguiendo e instalando CVS bajo Windows,  Next: Consiguiendo e instalando CVS en un Macintosh,  Prev: Consiguiendo y compilando CVS bajo Unix,  Up: Consiguiendo e instalando CVS

Consiguiendo e instalando CVS bajo Windows
------------------------------------------

A menos que sea realmente fanático respecto a tener el código fuente de
su ejecutable, no necesitará compilar CVS a partir de las fuentes en su
caja Windows.  Al contrario que en Unix, probablemente las herramientas
necesarias para compilar no existan en su sistema, por lo que una
compilación implicaría primero conseguir estas herramientas.  Dado que
eso está fuera de los objetivos de este libro, simplemente daré unas
instrucciones para conseguir un binario de CVS precompilado.

Antes de nada hay que notar que las distribuciones binarias de CVS para
Windows generalmente se hacen sólo para las versiones principales de
CVS - no para las intermedias - y no se encuentran en el sitio FTP de
GNU.  Así que necesitará ir al sitio de descarga de Cyclic Software,
donde en el directorio de la versión principal,
`http://download.cyclic.com/pub/cvs-1.10/', verá un subdirectorio
adicional

     Index of /pub/cvs-1.10
         cvs-1.10.tar.gz        14-Aug-98 09:35   2.4M
         windows/

dentro del cual hay un fichero ZIP:

     Index of /pub/cvs-1.10/windows
         cvs-1.10-win.zip       14-Aug-98 10:10   589k

Este fichero ZIP contiene una distribución binaria de CVS.  Descárguela
y descomprima este fichero ZIP:

     floss$ unzip cvs-1.10-win.zip
     
     Archive:  cvs-1.10-win.zip
       inflating: cvs.html
       inflating: cvs.exe
       inflating: README
       inflating: FAQ
       inflating: NEWS
       inflating: patch.exe
       inflating: win32gnu.dll

El fichero README contiene instrucciones detalladas.  Para la mayoría de
las instalaciones, pueden resumirse como sigue: Ponga todos los
ficheros EXE y DLL en un directorio incluido en su PATH.  Además, si va
a usar el método pserver para acceder a un repositorio remoto, quizá
necesite añadir lo siguiente a su fichero `C:\AUTOEXEC.BAT' y reiniciar:

     set HOME=C:

Esto le dice a CVS dónde almacenar el fichero .cvspass.

Actualmente CVS bajo Windows no puede servir repositorios a máquinas
remotas; puede ser un cliente (conectándose a repositorios remotos), y
operar en modo local (usando un repositorio en la misma máquina).  Por
lo general, este libro asume que CVS bajo Windows funciona como cliente.
Sin embargo, no debería ser demasiado difícil poner a punto un
repositorio local bajo Windows después de leer las instrucciones
orientadas a Unix del resto de este capítulo.

Si sólo accede a repositorios remotos, puede que ni siquiera necesite
ejecutar CVS.  Existe una utilidad llamada WinCvs que implementa sólo la
parte cliente de CVS.  Se distribuye por separado de CVS pero, como CVS,
está disponible libremente bajo la Licencia Pública General (GPL) de
GNU.  Hay más información disponible en `http://www.wincvs.org'.


File: cvsbook.info,  Node: Consiguiendo e instalando CVS en un Macintosh,  Next: Limitaciones de las versiones Windows y Macintosh,  Prev: Consiguiendo e instalando CVS bajo Windows,  Up: Consiguiendo e instalando CVS

Consiguiendo e instalando CVS en un Macintosh
---------------------------------------------

CVS está disponible para Macintosh, pero no como parte de la
distribución principal.  De momento, hay realmente disponibles tres
clientes CVS para Macintosh por separado:

   * MacCvs - `http://www.wincvs.org'

   * MacCVSClient - `http://www.glink.net.hk/~jb/MacCVSClient'       o
     `http://www.cyclic.com/maccvsclient/'

   * MacCVS Pro - `http://www.maccvs.org'

Francamente, no sé cuál es el mejor.  Pruébelos todos, no necesariamente
en el orden dado, y vea cuál le gusta.  MacCVS Pro parece tener un
desarrollo activo.  MacCvs aparentemente es un proyecto compañero de
WinCVS y comparte página web con él. (En el momento de escribir esto, un
aviso en la página de WinCVS afirma: "El desarrolo de MacCvs se
reanudará pronto.", ignoro lo que signifique esto.)


File: cvsbook.info,  Node: Limitaciones de las versiones Windows y Macintosh,  Prev: Consiguiendo e instalando CVS en un Macintosh,  Up: Consiguiendo e instalando CVS

Limitaciones de las versiones Windows y Macintosh
-------------------------------------------------

Las distribuciones de CVS para Windows y Macintosh están por lo general
limitadas en funcionalidad.  Todas pueden actuar como clientes, en el
sentido de que pueden contactar con un servidor de repositorio para
obtener una copia válida, enviar cambios, actualizar, etc.  Pero no
pueden servir repositorios por ellas mismas.  Si la configura
correctamente, la versión de Windows podrá usar un repositorio en un
disco local, pero aún no podrá servir proyectos desde ese repositorio a
otras máquinas.  En general, si desea tener un repositorio CVS
accesible por red, deberá ejecutar el servidor CVS en una máquina Unix.


File: cvsbook.info,  Node: Anatomia de una distribucion CVS,  Next: Iniciando un repositorio,  Prev: Consiguiendo e instalando CVS,  Up: Administracion del Repositorio

Anatomia de una distribucion CVS
================================

Las instrucciones anteriores están diseñadas para ponerle en marcha
rápidamente, pero hay mucho más dentro de una distribución de fuentes de
CVS que simplemente el código.  Aquí tiene un repaso rápido al árbol
fuente, de forma que sepa qué partes son recursos útiles y cuáles
pueden ignorarse.

* Menu:

* Ficheros informativos::           NEWS, BUGS, FAQ, etc.
* Subdirectorios::                  Cómo está organizada la distribución.
* El manual Cederqvist::            El Manual En Línea De CVS.
* Otras fuentes de información::    Dónde más encontrar ayuda.

