# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2001-02-09 01:25+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-xml2pot; charset=utf-8\n"
"Content-Transfer-Encoding: ENCODING\n"

#: index.docbook:7
#, no-c-format
msgid "The Linux System Administrator's Guide"
msgstr ""

#: index.docbook:8
#, no-c-format
msgid "Version 0.8"
msgstr ""

#: index.docbook:10
#, no-c-format
msgid "<firstname>Lars</firstname> <surname>Wirzenius</surname> <affiliation> <address> <email>liw@iki.fi</email> </address> </affiliation>"
msgstr ""

#: index.docbook:19
#, no-c-format
msgid "<firstname>Joanna</firstname> <surname>Oja</surname> <affiliation> <address> <email>viu@iki.fi</email> </address> </affiliation>"
msgstr ""

#: index.docbook:28
#, no-c-format
msgid "<firstname>Stephen</firstname> <surname>Stafford</surname> <affiliation> <address> <email>stephen@clothcat.demon.co.uk</email> </address> </affiliation>"
msgstr ""

#: index.docbook:37
#, no-c-format
msgid "<firstname>Alex</firstname> <surname>Weeks</surname> <affiliation> <address> <email>weeks_alex@yahoo.com.NOSPAM</email> </address> </affiliation>"
msgstr ""

#: index.docbook:49
#, no-c-format
msgid "An introduction to system administration of a Linux system for novices."
msgstr ""

#: index.docbook:54
#, no-c-format
msgid "Copyright 1993--1998 Lars Wirzenius."
msgstr ""

#: index.docbook:55
#, no-c-format
msgid "Copyright 1998--2001 Joanna Oja."
msgstr ""

#: index.docbook:56
#, no-c-format
msgid "Copyright 2001--2003 Stephen Stafford."
msgstr ""

#: index.docbook:57
#, no-c-format
msgid "Copyright 2003--Present Stephen Stafford &amp; Alex Weeks."
msgstr ""

#: index.docbook:59
#, no-c-format
msgid "Trademarks are owned by their owners."
msgstr ""

#: index.docbook:61
#, no-c-format
msgid "Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.1; with no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the license is included in the section entitled \"GNU Free Documentation License\"."
msgstr ""

#: index.docbook:74
#, no-c-format
msgid "Source and pre-formatted versions available"
msgstr ""

#: index.docbook:75
#, no-c-format
msgid "The source code and other machine readable formats of this book can be found on the Internet via anonymous FTP at the Linux Documentation Project home page <ulink url=\"http://www.tldp.org/\">http://www.tldp.org/</ulink>, or at the home page of this book at <ulink url=\"http://www.taylexson.org/sag//\">http://www.taylexson.org/sag/</ulink>. Available are at least HTML and PDF formats."
msgstr ""

#: index.docbook:86
#, no-c-format
msgid "Introduction"
msgstr ""

#: index.docbook:87
#, no-c-format
msgid "In the beginning, the file was without form, and void; and emptiness was upon the face of the bits. And the Fingers of the Author moved upon the face of the keyboard. And the Author said, Let there be words, and there were words."
msgstr ""

#: index.docbook:93
#, no-c-format
msgid "The Linux System Administrator's Guide, describes the system administration aspects of using Linux. It is intended for people who know next to nothing about system administration (those saying <quote>what is it?</quote>), but who have already mastered at least the basics of normal usage. This manual doesn't tell you how to install Linux; that is described in the Installation and Getting Started document. See below for more information about Linux manuals."
msgstr ""

#: index.docbook:102
#, no-c-format
msgid "System administration covers all the things that you have to do to keep a computer system in usable order. It includes things like backing up files (and restoring them if necessary), installing new programs, creating accounts for users (and deleting them when no longer needed), making certain that the filesystem is not corrupted, and so on. If a computer were, say, a house, system administration would be called maintenance, and would include cleaning, fixing broken windows, and other such things."
msgstr ""

#: index.docbook:112
#, no-c-format
msgid "The structure of this manual is such that many of the chapters should be usable independently, so if you need information about backups, for example, you can read just that chapter. However, this manual is first and foremost a tutorial and can be read sequentially or as a whole."
msgstr ""

#: index.docbook:118
#, no-c-format
msgid "This manual is not intended to be used completely independently. Plenty of the rest of the Linux documentation is also important for system administrators. After all, a system administrator is just a user with special privileges and duties. Very useful resources are the manual pages, which should always be consulted when you are not familiar with a command. If you do not know which command you need, then the <command>apropos</command> command can be used. Consult its manual page for more details."
msgstr ""

#: index.docbook:127
#, no-c-format
msgid "While this manual is targeted at Linux, a general principle has been that it should be useful with other UNIX based operating systems as well. Unfortunately, since there is so much variance between different versions of UNIX in general, and in system administration in particular, there is little hope to cover all variants. Even covering all possibilities for Linux is difficult, due to the nature of its development."
msgstr ""

#: index.docbook:135
#, no-c-format
msgid "There is no one official Linux distribution, so different people have different setups and many people have a setup they have built up themselves. This book is not targeted at any one distribution. Distributions can and do vary considerably. When possible, differences have been noted and alternatives given."
msgstr ""

#: index.docbook:142
#, no-c-format
msgid "In trying to describe how things work, rather than just listing <quote>five easy steps</quote> for each task, there is much information here that is not necessary for everyone, but those parts are marked as such and can be skipped if you use a preconfigured system. Reading everything will, naturally, increase your understanding of the system and should make using and administering it more productive."
msgstr ""

#: index.docbook:142
#, no-c-format
msgid "Understanding is the key to success with Linux. This book could just provide recipes, but what would you do when confronted by a problem this book had no recipe for? If the book can provide understanding then recipes are not required, they will be self evident"
msgstr ""

#: index.docbook:158
#, no-c-format
msgid "Like all other Linux related development, the work to write this manual was done on a volunteer basis: I did it because I thought it might be fun and because I felt it should be done. However, like all volunteer work, there is a limit to how much time, knowledge and experience people have. This means that the manual is not necessarily as good as it would be if a wizard had been paid handsomely to write it and had spent millennia to perfect it. Be warned."
msgstr ""

#: index.docbook:167
#, no-c-format
msgid "One particular point where corners have been cut is that many things that are already well documented in other freely available manuals are not always covered here. This applies especially to program specific documentation, such as all the details of using <command>mkfs</command>. Only the purpose of the program and as much of its usage as is necessary for the purposes of this manual is described. For further information, consult these other manuals. Usually, all of the referred to documentation is part of the full Linux documentation set."
msgstr ""

#: index.docbook:180
#, no-c-format
msgid "About This Book"
msgstr ""

#: index.docbook:182
#, no-c-format
msgid "Acknowledgments"
msgstr ""

#: index.docbook:183
#, no-c-format
msgid "Joanna's acknowledgments"
msgstr ""

#: index.docbook:185
#, no-c-format
msgid "Lars has tried to make this manual as good as possible and I would like, as a current maintainer, to keep up the good work. I would really like to hear from you if you have any ideas on how to make it better. Bad language, factual errors, ideas for new areas to cover, rewritten sections, information about how various UNIX versions do things, I am interested in all of it. My contact information is available via the World Wide Web at <ulink url=\"http://www.iki.fi/viu/\"> http://www.iki.fi/viu/</ulink>."
msgstr ""

#: index.docbook:196
#, no-c-format
msgid "Many people have helped me with this book, directly or indirectly. I would like to especially thank Matt Welsh for inspiration and LDP leadership, Andy Oram for getting me to work again with much-valued feedback, Olaf Kirch for showing me that it can be done, and Adam Richter at Yggdrasil and others for showing me that other people can find it interesting as well."
msgstr ""

#: index.docbook:203
#, no-c-format
msgid "Stephen Tweedie, H. Peter Anvin, Remy Card, Theodore Ts'o, and Stephen Tweedie have let me borrow their work (and thus make the book look thicker and much more impressive): a comparison between the xia and ext2 filesystems, the device list and a description of the ext2 filesystem. These aren't part of the book any more. I am most grateful for this, and very apologetic for the earlier versions that sometimes lacked proper attribution."
msgstr ""

#: index.docbook:212
#, no-c-format
msgid "In addition, I would like to thank Mark Komarinski for sending his material in 1993 and the many system administration columns in Linux Journal. They are quite informative and inspirational."
msgstr ""

#: index.docbook:217
#, no-c-format
msgid "Many useful comments have been sent by a large number of people. My miniature black hole of an archive doesn't let me find all their names, but some of them are, in alphabetical order: Paul Caprioli, Ales Cepek, Marie-France Declerfayt, Dave Dobson, Olaf Flebbe, Helmut Geyer, Larry Greenfield and his father, Stephen Harris, Jyrki Havia, Jim Haynes, York Lam, Timothy Andrew Lister, Jim Lynch, Michael J. Micek, Jacob Navia, Dan Poirier, Daniel Quinlan, Jouni K Sepp&auml;nen, Philippe Steindl, G.B. Stotte. My apologies to anyone I have forgotten."
msgstr ""

#: index.docbook:228
#, no-c-format
msgid "Stephen's acknowledgments"
msgstr ""

#: index.docbook:229
#, no-c-format
msgid "I would like to thank Lars and Joanna for their hard work on the guide."
msgstr ""

#: index.docbook:232
#, no-c-format
msgid "In a guide like this one there are likely to be at least some minor inaccuracies. And there are almost certainly going to be sections that become out of date from time to time. If you notice any of this then please let me know by sending me an email to: <email>bagpuss@debian.org</email>. I will take virtually any form of input (diffs, just plain text, html, whatever), I am in no way above allowing others to help me maintain such a large text as this :)"
msgstr ""

#: index.docbook:241
#, no-c-format
msgid "Many thanks to Helen Topping Shaw for getting the red pen out and making the text far better than it would otherwise have been. Also thanks are due just for being wonderful."
msgstr ""

#: index.docbook:245
#, no-c-format
msgid "The current web home of the guide is <ulink url=\"http://people.debian.org/~bagpuss\"> http://people.debian.org/~bagpuss </ulink>"
msgstr ""

#: index.docbook:251
#, no-c-format
msgid "Alex's Acknowledgments"
msgstr ""

#: index.docbook:252
#, no-c-format
msgid "I would like to thank Lars, Joanna, and Stephen for all the great work that they have done on this document over the years. I only hope that my contribution will be worthy of continuing the work they started."
msgstr ""

#: index.docbook:257
#, no-c-format
msgid "There have been many people who have helped me on my journey through the \"Windows-Free\" world, the person I feel I need to thank the most is my first true UN*X mentor, Mike Velasco. Back in a time before SCO became a \"dirty word\", Mike helped me on the path of tar's, cpio's, and many, many man pages. Thanks Mike! You are the 'Sofa King'."
msgstr ""

#: index.docbook:266
#, no-c-format
msgid "Typographical Conventions"
msgstr ""

#: index.docbook:268
#, no-c-format
msgid "Throughout this book, I have tried to use uniform typographical conventions. Hopefully they aid readability. If you can suggest any improvements please contact me."
msgstr ""

#: index.docbook:272
#, no-c-format
msgid "Filenames are expressed as: <filename>/usr/share/doc/foo</filename>."
msgstr ""

#: index.docbook:275
#, no-c-format
msgid "Command names are expressed as: <command>fsck</command>"
msgstr ""

#: index.docbook:277
#, no-c-format
msgid "Email addresses are expressed as: <email>stephen@clothcat.demon.co.uk</email>"
msgstr ""

#: index.docbook:280
#, no-c-format
msgid "URLs are expressed as: <ulink url=\"http://www.tldp.org\">http://www.tldp.org</ulink>"
msgstr ""

#: index.docbook:284
#, no-c-format
msgid "I will add to this section as things come up whilst editing. If you notice anything that should be added then please let me know."
msgstr ""

#: index.docbook:291
#, no-c-format
msgid "Overview of a Linux System"
msgstr ""

#: index.docbook:293
#, no-c-format
msgid "<quote>God saw everything that he had made, and saw that it was very good. </quote> -- Bible King James Version. Genesis 1:31"
msgstr ""

#: index.docbook:297
#, no-c-format
msgid "This chapter gives an overview of a Linux system. First, the major services provided by the operating system are described. Then, the programs that implement these services are described with a considerable lack of detail. The purpose of this chapter is to give an understanding of the system as a whole, so that each part is described in detail elsewhere."
msgstr ""

#: index.docbook:305
#, no-c-format
msgid "Various parts of an operating system"
msgstr ""

#: index.docbook:307
#, no-c-format
msgid "A UNIX operating system consists of a <glossterm>kernel</glossterm> and some <glossterm>system programs</glossterm>. There are also some <glossterm>application programs</glossterm> for doing work. The kernel is the heart of the operating system. <footnote><para>In fact, it is often mistakenly considered to be the operating system itself, but it is not. An operating system provides many more services than a plain kernel.</para></footnote> It keeps track of files on the disk, starts programs and runs them concurrently, assigns memory and other resources to various processes, receives packets from and sends packets to the network, and so on. The kernel does very little by itself, but it provides tools with which all services can be built. It also prevents anyone from accessing the hardware directly, forcing everyone to use the tools it provides. <footnote><para>I always think of this as a form of encapsulation which may help those of you with an object oriented programming background to visualize it better.</para></footnote> This way the kernel provides some protection for users from each other. The tools provided by the kernel are used via <glossterm>system calls</glossterm>. See manual page section 2 for more information on these."
msgstr ""

#: index.docbook:333
#, no-c-format
msgid "The system programs use the tools provided by the kernel to implement the various services required from an operating system. System programs, and all other programs, run `on top of the kernel', in what is called the <glossterm>user mode</glossterm>. The difference between system and application programs is one of intent: applications are intended for getting useful things done (or for playing, if it happens to be a game), whereas system programs are needed to get the system working. A word processor is an application; <command>mount</command> is a system program. The difference is often somewhat blurry, however, and is important only to compulsive categorizers."
msgstr ""

#: index.docbook:345
#, no-c-format
msgid "An operating system can also contain compilers and their corresponding libraries (GCC and the C library in particular under Linux), although not all programming languages need be part of the operating system. Documentation, and sometimes even games, can also be part of it. Traditionally, the operating system has been defined by the contents of the installation tape or disks; with Linux it is not as clear since it is spread all over the FTP sites of the world."
msgstr ""

#: index.docbook:357
#, no-c-format
msgid "Important parts of the kernel"
msgstr ""

#: index.docbook:359
#, no-c-format
msgid "The Linux kernel consists of several important parts: process management, memory management, hardware device drivers, filesystem drivers, network management, and various other bits and pieces. <xref linkend=\"kerneloverview\"/> shows some of them."
msgstr ""

#: index.docbook:366
#, no-c-format
msgid "Some of the more important parts of the Linux kernel"
msgstr ""

#: index.docbook:370
#, no-c-format
msgid "Probably the most important parts of the kernel (nothing else works without them) are memory management and process management. Memory management takes care of assigning memory areas and swap space areas to processes, parts of the kernel, and for the buffer cache. Process management creates processes, and implements multitasking by switching the active process on the processor."
msgstr ""

#: index.docbook:378
#, no-c-format
msgid "At the lowest level, the kernel contains a hardware device driver for each kind of hardware it supports. Since the world is full of different kinds of hardware, the number of hardware device drivers is large. There are often many otherwise similar pieces of hardware that differ in how they are controlled by software. The similarities make it possible to have general classes of drivers that support similar operations; each member of the class has the same interface to the rest of the kernel but differs in what it needs to do to implement them. For example, all disk drivers look alike to the rest of the kernel, i.e., they all have operations like `initialize the drive', `read sector N', and `write sector N'."
msgstr ""

#: index.docbook:391
#, no-c-format
msgid "Some software services provided by the kernel itself have similar properties, and can therefore be abstracted into classes. For example, the various network protocols have been abstracted into one programming interface, the BSD socket library. Another example is the <glossterm>virtual filesystem</glossterm> (VFS) layer that abstracts the filesystem operations away from their implementation. Each filesystem type provides an implementation of each filesystem operation. When some entity tries to use a filesystem, the request goes via the VFS, which routes the request to the proper filesystem driver."
msgstr ""

#: index.docbook:405
#, no-c-format
msgid "Major services in a UNIX system"
msgstr ""

#: index.docbook:407
#, no-c-format
msgid "This section describes some of the more important UNIX services, but without much detail. They are described more thoroughly in later chapters."
msgstr ""

#: index.docbook:412 index.docbook:4743
#, no-c-format
msgid "init"
msgstr ""

#: index.docbook:414
#, no-c-format
msgid "The single most important service in a UNIX system is provided by <command>init</command>. <command>init</command> is started as the first process of every UNIX system, as the last thing the kernel does when it boots. When <command>init</command> starts, it continues the boot process by doing various startup chores (checking and mounting filesystems, starting daemons, etc)."
msgstr ""

#: index.docbook:422
#, no-c-format
msgid "The exact list of things that <command>init</command> does depends on which flavor it is; there are several to choose from. <command>init</command> usually provides the concept of <glossterm>single user mode</glossterm>, in which no one can log in and root uses a shell at the console; the usual mode is called <glossterm>multiuser mode</glossterm>. Some flavors generalize this as <glossterm>run levels</glossterm>; single and multiuser modes are considered to be two run levels, and there can be additional ones as well, for example, to run X on the console."
msgstr ""

#: index.docbook:433
#, no-c-format
msgid "Linux allows for up to 10 <glossterm>runlevels</glossterm>, 0-9, but usually only some of these are defined by default. Runlevel 0 is defined as <quote>system halt</quote>. Runlevel 1 is defined as <quote>single user mode</quote>. Runlevel 6 is defined as <quote>system reboot</quote>. Other runlevels are dependent on how your particular distribution has defined them, and they vary significantly between distributions. Looking at the contents of <filename>/etc/inittab</filename> usually will give some hint what the predefined runlevels are and what they have been defined as."
msgstr ""

#: index.docbook:444
#, no-c-format
msgid "In normal operation, <command>init</command> makes sure <command>getty</command> is working (to allow users to log in), and to adopt orphan processes (processes whose parent has died; in UNIX <emphasis>all</emphasis> processes <emphasis>must</emphasis> be in a single tree, so orphans must be adopted)."
msgstr ""

#: index.docbook:450
#, no-c-format
msgid "When the system is shut down, it is <command>init</command> that is in charge of killing all other processes, unmounting all filesystems and stopping the processor, along with anything else it has been configured to do."
msgstr ""

#: index.docbook:458
#, no-c-format
msgid "Logins from terminals"
msgstr ""

#: index.docbook:460
#, no-c-format
msgid "Logins from terminals (via serial lines) and the console (when not running X) are provided by the <command>getty</command> program. <command>init</command> starts a separate instance of <command>getty</command> for each terminal upon which logins are to be allowed. <command>getty</command> reads the username and runs the <command>login</command> program, which reads the password. If the username and password are correct, <command>login</command> runs the shell. When the shell terminates, i.e., the user logs out, or when <command>login</command> terminated because the username and password didn't match, <command>init</command> notices this and starts a new instance of <command>getty</command>. The kernel has no notion of logins, this is all handled by the <glossterm>system programs</glossterm>."
msgstr ""

#: index.docbook:477
#, no-c-format
msgid "Syslog"
msgstr ""

#: index.docbook:479
#, no-c-format
msgid "The kernel and many <glossterm>system programs</glossterm> produce error, warning, and other messages. It is often important that these messages can be viewed later, even much later, so they should be written to a file. The program doing this is <command>syslog</command>. It can be configured to sort the messages to different files according to writer or degree of importance. For example, kernel messages are often directed to a separate file from the others, since kernel messages are often more important and need to be read regularly to spot problems."
msgstr ""

#: index.docbook:493
#, no-c-format
msgid "Periodic command execution: <command>cron</command> and <command>at</command>"
msgstr ""

#: index.docbook:496
#, no-c-format
msgid "Both users and system administrators often need to run commands periodically. For example, the system administrator might want to run a command to clean the directories with temporary files (<filename>/tmp</filename> and <filename>/var/tmp</filename>) from old files, to keep the disks from filling up, since not all programs clean up after themselves correctly."
msgstr ""

#: index.docbook:504
#, no-c-format
msgid "The <command>cron</command> service is set up to do this. Each user can have a <filename>crontab</filename> file, where she lists the commands she wishes to execute and the times they should be executed. The <command>cron</command> daemon takes care of starting the commands when specified."
msgstr ""

#: index.docbook:510
#, no-c-format
msgid "The <command>at</command> service is similar to <command>cron</command>, but it is once only: the command is executed at the given time, but it is not repeated."
msgstr ""

#: index.docbook:514
#, no-c-format
msgid "See the manual pages cron(1), crontab(1), crontab(5), at(1) and atd(8) for more in depth information."
msgstr ""

#: index.docbook:519
#, no-c-format
msgid "Graphical user interface"
msgstr ""

#: index.docbook:521
#, no-c-format
msgid "UNIX and Linux don't incorporate the user interface into the kernel; instead, they let it be implemented by user level programs. This applies for both text mode and graphical environments."
msgstr ""

#: index.docbook:526
#, no-c-format
msgid "This arrangement makes the system more flexible, but has the disadvantage that it is simple to implement a different user interface for each program, making the system harder to learn."
msgstr ""

#: index.docbook:531
#, no-c-format
msgid "The graphical environment primarily used with Linux is called the X Window System (X for short). X also does not implement a user interface; it only implements a window system, i.e., tools with which a graphical user interface can be implemented. Some popular window managers are: fvwm, icewm, blackbox and windowmaker. There are also two popular desktop managers, KDE and Gnome."
msgstr ""

#: index.docbook:542
#, no-c-format
msgid "Networking"
msgstr ""

#: index.docbook:544
#, no-c-format
msgid "Networking is the act of connecting two or more computers so that they can communicate with each other. The actual methods of connecting and communicating are slightly complicated, but the end result is very useful."
msgstr ""

#: index.docbook:549
#, no-c-format
msgid "UNIX operating systems have many networking features. Most basic services (filesystems, printing, backups, etc) can be done over the network. This can make system administration easier, since it allows centralized administration, while still reaping in the benefits of microcomputing and distributed computing, such as lower costs and better fault tolerance."
msgstr ""

#: index.docbook:556
#, no-c-format
msgid "However, this book merely glances at networking; see the <citetitle>Linux Network Administrators' Guide</citetitle> <ulink url=\"http://www.tldp.org/LDP/nag2/index.html\"> http://www.tldp.org/LDP/nag2/index.html</ulink> for more information, including a basic description of how networks operate."
msgstr ""

#: index.docbook:566
#, no-c-format
msgid "Network logins"
msgstr ""

#: index.docbook:568
#, no-c-format
msgid "Network logins work a little differently than normal logins. There is a separate physical serial line for each terminal via which it is possible to log in. For each person logging in via the network, there is a separate virtual network connection, and there can be any number of these. <footnote><para>Well, at least there can be many. Network bandwidth still being a scarce resource, there is still some practical upper limit to the number of concurrent logins via one network connection. </para></footnote> It is therefore not possible to run a separate <command>getty</command> for each possible virtual connection. There are also several different ways to log in via a network, <command>telnet</command> and <command>rlogin</command> being the major ones in TCP/IP networks."
msgstr ""

#: index.docbook:568
#, no-c-format
msgid "These days many Linux system administrators consider <command>telnet</command> and <command>rlogin </command> to be insecure and prefer <command>ssh </command>, the <quote>secure shell</quote>, which encrypts traffic going over the network, thereby making it far less likely that the malicious can <quote>sniff</quote> your connection and gain sensitive data like usernames and passwords. It is highly recommended you use <command>ssh</command> rather than <command>telnet</command> or <command>rlogin</command>."
msgstr ""

#: index.docbook:596
#, no-c-format
msgid "Network logins have, instead of a herd of <command>getty</command>s, a single daemon per way of logging in (<command>telnet</command> and <command>rlogin</command> have separate daemons) that listens for all incoming login attempts. When it notices one, it starts a new instance of itself to handle that single attempt; the original instance continues to listen for other attempts. The new instance works similarly to <command>getty</command>."
msgstr ""

#: index.docbook:608
#, no-c-format
msgid "Network file systems"
msgstr ""

#: index.docbook:609
#, no-c-format
msgid "One of the more useful things that can be done with networking services is sharing files via a <glossterm>network file system</glossterm>. The one usually used is called the Network File System, or NFS, developed by Sun."
msgstr ""

#: index.docbook:614
#, no-c-format
msgid "With a network file system any file operations done by a program on one machine are sent over the network to another computer. This fools the program to think that all the files on the other computer are actually on the computer the program is running on. This makes information sharing extremely simple, since it requires no modifications to programs."
msgstr ""

#: index.docbook:621
#, no-c-format
msgid "Another popular way of sharing files is Samba <ulink url=\"http://www.samba.org\">http://www.samba.org</ulink>. This protocol allows the sharing of files with MS Windows machines (via Network Neighbourhood). It also allows the sharing of printers across machines."
msgstr ""

#: index.docbook:629
#, no-c-format
msgid "Mail"
msgstr ""

#: index.docbook:630
#, no-c-format
msgid "Electronic mail is the most popularly used method for communicating via computer. An electronic letter is stored in a file using a special format, and special mail programs are used to send and read the letters."
msgstr ""

#: index.docbook:635
#, no-c-format
msgid "Each user has an <glossterm>incoming mailbox</glossterm> (a file in the special format), where all new mail is stored. When someone sends mail, the mail program locates the receiver's mailbox and appends the letter to the mailbox file. If the receiver's mailbox is in another machine, the letter is sent to the other machine, which delivers it to the mailbox as it best sees fit."
msgstr ""

#: index.docbook:643
#, no-c-format
msgid "The mail system consists of many programs. The delivery of mail to local or remote mailboxes is done by one program (the <glossterm>mail transfer agent</glossterm> (MTA), e.g., <command>sendmail</command> or <command>smail</command>), while the programs users use are many and varied (<glossterm>mail user agent</glossterm> (MUA), e.g., <command>pine</command>, <command>mutt</command> or <command>elm</command>). The mailboxes are usually stored in <filename>/var/spool/mail</filename>."
msgstr ""

#: index.docbook:656
#, no-c-format
msgid "Printing"
msgstr ""

#: index.docbook:657
#, no-c-format
msgid "Only one person can use a printer at one time, but it is uneconomical not to share printers between users. The printer is therefore managed by software that implements a <glossterm>print queue</glossterm>: all print jobs are put into a queue and whenever the printer is done with one job, the next one is sent to it automatically. This relieves the users from organizing the print queue and fighting over control of the printer."
msgstr ""

#: index.docbook:657
#, no-c-format
msgid "Instead, they form a new queue <emphasis>at</emphasis> the printer, waiting for their printouts, since no one ever seems to be able to get the queue software to know exactly when anyone's printout is really finished. This is a great boost to intra-office social relations."
msgstr ""

#: index.docbook:672
#, no-c-format
msgid "The print queue software also <glossterm>spools</glossterm> the printouts on disk, i.e., the text is kept in a file while the job is in the queue. This allows an application program to spit out the print jobs quickly to the print queue software; the application does not have to wait until the job is actually printed to continue. This is really convenient, since it allows one to print out one version, and not have to wait for it to be printed before one can make a completely revised new version."
msgstr ""

#: index.docbook:685
#, no-c-format
msgid "The filesystem layout"
msgstr ""

#: index.docbook:686
#, no-c-format
msgid "The filesystem is divided into many parts; usually along the lines of a root filesystem with <filename>/bin</filename>, <filename>/lib</filename>, <filename>/etc</filename>, <filename>/dev</filename>, and a few others; a <filename>/usr</filename> filesystem with programs and unchanging data; a <filename>/var</filename> filesystem with changing data (such as log files); and a <filename>/home</filename> filesystem for everyone's personal files. Depending on the hardware configuration and the decisions of the system administrator, the division can be different; it can even be all in one filesystem."
msgstr ""

#: index.docbook:698
#, no-c-format
msgid "describes the filesystem layout in some little detail; the Filesystem Hierarchy Standard covers it in somewhat more detail."
msgstr ""

#: index.docbook:698
#, no-c-format
msgid "http://www.pathname.com/fhs/"
msgstr ""

#: index.docbook:710
#, no-c-format
msgid "Overview of the Directory Tree"
msgstr ""

#: index.docbook:712
#, no-c-format
msgid "<quote> Two days later, there was Pooh, sitting on his branch, dangling his legs, and there, beside him, were four pots of honey...</quote> (A.A. Milne)"
msgstr ""

#: index.docbook:716
#, no-c-format
msgid "This chapter describes the important parts of a standard Linux directory tree, based on the Filesystem Hierarchy Standard. It outlines the normal way of breaking the directory tree into separate filesystems with different purposes and gives the motivation behind this particular split. Not all Linux distributions follow this standard slavishly, but it is generic enough to give you an overview."
msgstr ""

#: index.docbook:725
#, no-c-format
msgid "Background"
msgstr ""

#: index.docbook:727
#, no-c-format
msgid "This chapter is loosely based on the <citetitle>Filesystems Hierarchy Standard</citetitle> (FHS) <footnote><para><ulink url=\"hhtp://www.pathname.com/fhs/\"> http://www.pathname.com/fhs/</ulink></para></footnote> version 2.1, which attempts to set a standard for how the directory tree in a Linux <footnote><para>Or any Unix like system. For example the BSD derivatives.</para></footnote> system is organized. Such a standard has the advantage that it will be easier to write or port software for Linux, and to administer Linux machines, since everything should be in standardized places. There is no authority behind the standard that forces anyone to comply with it, but it has gained the support of many Linux distributions. It is not a good idea to break with the FHS without very compelling reasons. The FHS attempts to follow Unix tradition and current trends, making Linux systems familiar to those with experience with other Unix systems, and vice versa."
msgstr ""

#: index.docbook:747
#, no-c-format
msgid "This chapter is not as detailed as the FHS. A system administrator should also read the full FHS for a complete understanding."
msgstr ""

#: index.docbook:751
#, no-c-format
msgid "This chapter does not explain all files in detail. The intention is not to describe every file, but to give an overview of the system from a filesystem point of view. Further information on each file is available elsewhere in this manual or in the Linux manual pages."
msgstr ""

#: index.docbook:757
#, no-c-format
msgid "The full directory tree is intended to be breakable into smaller parts, each capable of being on its own disk or partition, to accommodate to disk size limits and to ease backup and other system administration tasks. The major parts are the root (<filename>/</filename>), <filename>/usr</filename>, <filename>/var</filename>, and <filename>/home</filename> filesystems (see <xref linkend=\"fstree\"/>). Each part has a different purpose. The directory tree has been designed so that it works well in a network of Linux machines which may share some parts of the filesystems over a read-only device (e.g., a CD-ROM), or over the network with NFS."
msgstr ""

#: index.docbook:769
#, no-c-format
msgid "Parts of a Unix directory tree. Dashed lines indicate partition limits."
msgstr ""

#: index.docbook:774
#, no-c-format
msgid "The roles of the different parts of the directory tree are described below."
msgstr ""

#: index.docbook:774
#, no-c-format
msgid "The root filesystem is specific for each machine (it is generally stored on a local disk, although it could be a ramdisk or network drive as well) and contains the files that are necessary for booting the system up, and to bring it up to such a state that the other filesystems may be mounted. The contents of the root filesystem will therefore be sufficient for the single user state. It will also contain tools for fixing a broken system, and for recovering lost files from backups."
msgstr ""

#: index.docbook:774
#, no-c-format
msgid "The <filename>/usr</filename> filesystem contains all commands, libraries, manual pages, and other unchanging files needed during normal operation. No files in <filename>/usr</filename> should be specific for any given machine, nor should they be modified during normal use. This allows the files to be shared over the network, which can be cost-effective since it saves disk space (there can easily be hundreds of megabytes, increasingly multiple gigabytes in <filename>/usr</filename>). It can make administration easier (only the master <filename>/usr</filename> needs to be changed when updating an application, not each machine separately) to have /usr network mounted. Even if the filesystem is on a local disk, it could be mounted read-only, to lessen the chance of filesystem corruption during a crash."
msgstr ""

#: index.docbook:774
#, no-c-format
msgid "The <filename>/var</filename> filesystem contains files that change, such as spool directories (for mail, news, printers, etc), log files, formatted manual pages, and temporary files. Traditionally everything in <filename>/var</filename> has been somewhere below <filename>/usr</filename>, but that made it impossible to mount <filename>/usr</filename> read-only."
msgstr ""

#: index.docbook:774
#, no-c-format
msgid "The <filename>/home</filename> filesystem contains the users' home directories, i.e., all the real data on the system. Separating home directories to their own directory tree or filesystem makes backups easier; the other parts often do not have to be backed up, or at least not as often as they seldom change. A big <filename>/home</filename> might have to be broken across several filesystems, which requires adding an extra naming level below <filename>/home</filename>, for example <filename>/home/students</filename> and <filename>/home/staff</filename>."
msgstr ""

#: index.docbook:829
#, no-c-format
msgid "Although the different parts have been called filesystems above, there is no requirement that they actually be on separate filesystems. They could easily be kept in a single one if the system is a small single-user system and the user wants to keep things simple. The directory tree might also be divided into filesystems differently, depending on how large the disks are, and how space is allocated for various purposes. The important part, though, is that all the standard <emphasis>names</emphasis> work; even if, say, <filename>/var</filename> and <filename>/usr</filename> are actually on the same partition, the names <filename>/usr/lib/libc.a</filename> and <filename>/var/log/messages</filename> must work, for example by moving files below <filename>/var</filename> into <filename>/usr/var</filename>, and making <filename>/var</filename> a symlink to <filename>/usr/var</filename>."
msgstr ""

#: index.docbook:846
#, no-c-format
msgid "The Unix filesystem structure groups files according to purpose, i.e., all commands are in one place, all data files in another, documentation in a third, and so on. An alternative would be to group files files according to the program they belong to, i.e., all Emacs files would be in one directory, all TeX in another, and so on. The problem with the latter approach is that it makes it difficult to share files (the program directory often contains both static and sharable and changing and non-sharable files), and sometimes to even find the files (e.g., manual pages in a huge number of places, and making the manual page programs find all of them is a maintenance nightmare)."
msgstr ""

#: index.docbook:862
#, no-c-format
msgid "The root filesystem"
msgstr ""

#: index.docbook:864
#, no-c-format
msgid "The root filesystem should generally be small, since it contains very critical files and a small, infrequently modified filesystem has a better chance of not getting corrupted. A corrupted root filesystem will generally mean that the system becomes unbootable except with special measures (e.g., from a floppy), so you don't want to risk it."
msgstr ""

#: index.docbook:871
#, no-c-format
msgid "The root directory generally doesn't contain any files, except perhaps the standard boot image for the system, usually called <filename>/vmlinuz</filename>. All other files are in subdirectories in the root filesystems: <glosslist> <glossentry> <glossterm><filename>/bin</filename></glossterm> <glossdef><para>Commands needed during bootup that might be used by normal users (probably after bootup).</para></glossdef></glossentry> <glossentry> <glossterm><filename>/sbin</filename></glossterm> <glossdef><para>Like <filename>/bin</filename>, but the commands are not intended for normal users, although they may use them if necessary and allowed. <filename>/sbin</filename> is not usually in the default path of normal users, but will be in root's default path.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc</filename></glossterm> <glossdef><para>Configuration files specific to the machine.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/root</filename></glossterm> <glossdef><para>The home directory for user root. This is usually not accessible to other users on the system</para></glossdef></glossentry> <glossentry> <glossterm><filename>/lib</filename></glossterm> <glossdef><para>Shared libraries needed by the programs on the root filesystem.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/lib/modules</filename></glossterm> <glossdef><para>Loadable kernel modules, especially those that are needed to boot the system when recovering from disasters (e.g., network and filesystem drivers).</para></glossdef></glossentry> <glossentry> <glossterm><filename>/dev</filename></glossterm> <glossdef><para>Device files. Some of the more commonly used device files are examined in <xref linkend=\"device-list\"/> </para></glossdef></glossentry> <glossentry> <glossterm><filename>/tmp</filename></glossterm> <glossdef><para>Temporary files. Programs running after bootup should use <filename>/var/tmp</filename>, not <filename>/tmp</filename>, since the former is probably on a disk with more space. Often /tmp will be a symbolic link to /var/tmp.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/boot</filename></glossterm> <glossdef><para>Files used by the bootstrap loader, e.g., LILO. Kernel images are often kept here instead of in the root directory. If there are many kernel images, the directory can easily grow rather big, and it might be better to keep it in a separate filesystem. Another reason would be to make sure the kernel images are within the first 1024 cylinders of an IDE disk. <footnote><para>This 1024 cylinder limit is no longer true in most cases. With modern BIOSes and later versions of LILO (the LInux LOader) the 1024 cylinder limit can be passed with logical block addressing (LBA). See the <command>lilo</command> manual page for more details.</para></footnote> </para></glossdef></glossentry> <glossentry> <glossterm><filename>/mnt</filename></glossterm> <glossdef><para>Mount point for temporary mounts by the system administrator. Programs aren't supposed to mount on <filename>/mnt</filename> automatically. <filename>/mnt</filename> might be divided into subdirectories (e.g., <filename>/mnt/dosa</filename> might be the floppy drive using an MS-DOS filesystem, and <filename>/mnt/exta</filename> might be the same with an ext2 filesystem).</para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc</filename>, <filename>/usr</filename>, <filename>/var</filename>, <filename>/home</filename></glossterm> <glossdef><para>Mount points for the other filesystems. <footnote><para>Although <filename>/proc</filename> does not reside on any disk in reality. See the section about <filename>/proc</filename> later in the chapter.</para></footnote> </para></glossdef></glossentry> </glosslist>"
msgstr ""

#: index.docbook:989
#, no-c-format
msgid "The <filename>/etc</filename> directory"
msgstr ""

#: index.docbook:991
#, no-c-format
msgid "The <filename>/etc</filename> directory contains a lot of files. Some of them are described below. For others, you should determine which program they belong to and read the manual page for that program. Many networking configuration files are in <filename>/etc</filename> as well, and are described in the <citetitle>Networking Administrators' Guide</citetitle>. <glosslist> <glossentry> <glossterm><filename>/etc/rc</filename> or <filename>/etc/rc.d</filename> or <filename>/etc/rc?.d</filename></glossterm> <glossdef><para>Scripts or directories of scripts to run at startup or when changing the run level. See <xref linkend=\"init\"/> for further information. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/passwd</filename></glossterm> <glossdef><para>The user database, with fields giving the username, real name, home directory, encrypted password, and other information about each user. The format is documented in the <command>passwd</command> manual page. The encrypted passwords are much more commonly found in the <filename>/etc/shadow</filename> these days. This means that almost everything about the user <emphasis>except</emphasis> the password is stored in the <filename>passwd</filename> file. History and convention make a name change undesirable. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/fdprm</filename></glossterm> <glossdef><para>Floppy disk parameter table. Describes what different floppy disk formats look like. Used by <command>setfdprm</command>. See the <command>setfdprm</command> manual page for more information. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/fstab</filename></glossterm> <glossdef><para>Lists the filesystems mounted automatically at startup by the <command>mount -a</command> command (in <filename>/etc/rc</filename> or equivalent startup file). Under Linux, also contains information about swap areas used automatically by <command>swapon -a</command>. See <xref linkend=\"mount-and-umount\"/> and the <command>mount</command> manual page for more information. Also <filename>fstab</filename> usually has its own manual page in section 5. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/group</filename></glossterm> <glossdef><para>Similar to <filename>/etc/passwd</filename>, but describes groups instead of users. See the <filename>group</filename> manual page in section 5 for more information. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/inittab</filename></glossterm> <glossdef><para>Configuration file for <command>init</command>. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/issue</filename></glossterm> <glossdef><para>Output by <command>getty</command> before the login prompt. Usually contains a short description or welcoming message to the system. The contents are up to the system administrator. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/magic</filename></glossterm> <glossdef><para>The configuration file for <command>file</command>. Contains the descriptions of various file formats based on which <command>file</command> guesses the type of the file. See the <filename>magic</filename> and <command>file</command> manual pages for more information. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/motd</filename></glossterm> <glossdef><para>The message of the day, automatically output after a successful login. Contents are up to the system administrator. Often used for getting information to every user, such as warnings about planned downtimes. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/mtab</filename></glossterm> <glossdef><para>List of currently mounted filesystems. Initially set up by the bootup scripts, and updated automatically by the <command>mount</command> command. Used when a list of mounted filesystems is needed, e.g., by the <command>df</command> command. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/shadow</filename></glossterm> <glossdef><para>Shadow password file on systems with shadow password software installed. Shadow passwords move the encrypted password from <filename>/etc/passwd</filename> into <filename>/etc/shadow</filename>; the latter is not readable by anyone except root. This makes it harder to crack passwords. If your distribution gives you a choice (many do) of whether or not to use shadow passwords then you are highly recommended to do so.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/login.defs</filename></glossterm> <glossdef><para>Configuration file for the <command>login</command> command. The <filename>login.defs</filename> file usually has a manual page in section 5. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/printcap</filename></glossterm> <glossdef><para>Like <filename>/etc/termcap</filename>, but intended for printers. However it uses different syntax. The <filename>printcap</filename> has a manual page in section 5. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/profile</filename>, <filename>/etc/csh.login</filename>, <filename>/etc/csh.cshrc</filename></glossterm> <glossdef><para>Files executed at login or startup time by the Bourne or C shells. These allow the system administrator to set global defaults for all users. See the manual pages for the respective shells. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/securetty</filename></glossterm> <glossdef><para>Identifies secure terminals, i.e., the terminals from which root is allowed to log in. Typically only the virtual consoles are listed, so that it becomes impossible (or at least harder) to gain superuser privileges by breaking into a system over a modem or a network. Do not allow root logins over a network. Prefer to log in as an unprivileged user and use <command>su</command> or <command>sudo</command> to gain root privileges.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/shells</filename></glossterm> <glossdef><para>Lists trusted shells. The <command>chsh</command> command allows users to change their login shell only to shells listed in this file. <command>ftpd</command>, the server process that provides FTP services for a machine, will check that the user's shell is listed in <filename>/etc/shells</filename> and will not let people log in unless the shell is listed there. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/etc/termcap</filename></glossterm> <glossdef><para>The terminal capability database. Describes by what <quote>escape sequences</quote> various terminals can be controlled. Programs are written so that instead of directly outputting an escape sequence that only works on a particular brand of terminal, they look up the correct sequence to do whatever it is they want to do in <filename>/etc/termcap</filename>. As a result most programs work with most kinds of terminals. See the <filename>termcap</filename>, curs_termcap, and <filename>terminfo</filename> manual pages for more information. </para></glossdef></glossentry> </glosslist>"
msgstr ""

#: index.docbook:1177
#, no-c-format
msgid "The <filename>/dev</filename> directory"
msgstr ""

#: index.docbook:1179
#, no-c-format
msgid "The <filename>/dev</filename> directory contains the special device files for all the devices. The device files are named using special conventions; these are described in <xref linkend=\"device-list\"/>. The device files are created during installation, and later with the <command>/dev/MAKEDEV</command> script. The <command>/dev/MAKEDEV.local</command> is a script written by the system administrator that creates local-only device files or links (i.e. those that are not part of the standard <command>MAKEDEV</command>, such as device files for some non-standard device driver)."
msgstr ""

#: index.docbook:1193
#, no-c-format
msgid "The <filename>/usr</filename> filesystem"
msgstr ""

#: index.docbook:1195
#, no-c-format
msgid "The <filename>/usr</filename> filesystem is often large, since all programs are installed there. All files in <filename>/usr</filename> usually come from a Linux distribution; locally installed programs and other stuff goes below <filename>/usr/local</filename>. This makes it possible to update the system from a new version of the distribution, or even a completely new distribution, without having to install all programs again. Some of the subdirectories of <filename>/usr</filename> are listed below (some of the less important directories have been dropped; see the FSSTND for more information). <glosslist> <glossentry> <glossterm><filename>/usr/X11R6</filename></glossterm> <glossdef><para>The X Window System, all files. To simplify the development and installation of X, the X files have not been integrated into the rest of the system. There is a directory tree below <filename>/usr/X11R6</filename> similar to that below <filename>/usr</filename> itself. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/usr/bin</filename></glossterm> <glossdef><para>Almost all user commands. Some commands are in <filename>/bin</filename> or in <filename>/usr/local/bin</filename>. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/usr/sbin</filename></glossterm> <glossdef><para>System administration commands that are not needed on the root filesystem, e.g., most server programs. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/usr/share/man</filename>, <filename>/usr/share/info</filename>, <filename>/usr/share/doc</filename></glossterm> <glossdef><para>Manual pages, GNU Info documents, and miscellaneous other documentation files, respectively. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/usr/include</filename></glossterm> <glossdef><para>Header files for the C programming language. This should actually be below <filename>/usr/lib</filename> for consistency, but the tradition is overwhelmingly in support for this name. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/usr/lib</filename></glossterm> <glossdef><para>Unchanging data files for programs and subsystems, including some site-wide configuration files. The name <filename>lib</filename> comes from library; originally libraries of programming subroutines were stored in <filename>/usr/lib</filename>. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/usr/local</filename></glossterm> <glossdef><para>The place for locally installed software and other files. Distributions may not install anything in here. It is reserved solely for the use of the local administrator. This way he can be absolutely certain that no updates or upgrades to his distribution will overwrite any extra software he has installed locally.</para></glossdef></glossentry> </glosslist>"
msgstr ""

#: index.docbook:1276
#, no-c-format
msgid "The <filename>/var</filename> filesystem"
msgstr ""

#: index.docbook:1278
#, no-c-format
msgid "The <filename>/var</filename> contains data that is changed when the system is running normally. It is specific for each system, i.e., not shared over the network with other computers. <glosslist> <glossentry> <glossterm><filename>/var/cache/man</filename></glossterm> <glossdef><para>A cache for man pages that are formatted on demand. The source for manual pages is usually stored in <filename>/usr/share/man/man?/</filename> (where ? is the manual section. See the manual page for <command>man</command> in section 7); some manual pages might come with a pre-formatted version, which might be stored in <filename>/usr/share/man/cat*</filename>. Other manual pages need to be formatted when they are first viewed; the formatted version is then stored in <filename>/var/cache/man</filename> so that the next person to view the same page won't have to wait for it to be formatted. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/var/games</filename></glossterm> <glossdef><para>Any variable data belonging to games in <filename>/usr</filename> should be placed here. This is in case /usr is mounted read only. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/var/lib</filename></glossterm> <glossdef><para>Files that change while the system is running normally.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/var/local</filename></glossterm> <glossdef><para>Variable data for programs that are installed in <filename>/usr/local</filename> (i.e., programs that have been installed by the system administrator). Note that even locally installed programs should use the other <filename>/var</filename> directories if they are appropriate, e.g., <filename>/var/lock</filename>.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/var/lock</filename></glossterm> <glossdef><para>Lock files. Many programs follow a convention to create a lock file in <filename>/var/lock</filename> to indicate that they are using a particular device or file. Other programs will notice the lock file and won't attempt to use the device or file.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/var/log</filename></glossterm> <glossdef><para>Log files from various programs, especially <command>login</command> (<filename>/var/log/wtmp</filename>, which logs all logins and logouts into the system) and <command>syslog</command> (<filename>/var/log/messages</filename>, where all kernel and system program message are usually stored). Files in <filename>/var/log</filename> can often grow indefinitely, and may require cleaning at regular intervals.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/var/mail</filename></glossterm> <glossdef><para>This is the FHS approved location for user mailbox files. Depending on how far your distribution has gone towards FHS compliance, these files may still be held in <filename>/var/spool/mail</filename>. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/var/run</filename></glossterm> <glossdef><para>Files that contain information about the system that is valid until the system is next booted. For example, <filename>/var/run/utmp</filename> contains information about people currently logged in.</para></glossdef></glossentry> <glossentry> <glossterm><filename>/var/spool</filename></glossterm> <glossdef><para>Directories for news, printer queues, and other queued work. Each different spool has its own subdirectory below <filename>/var/spool</filename>, e.g., the news spool is in <filename>/var/spool/news</filename>. Note that some installations which are not fully compliant with the latest version of the FHS may have user mailboxes under <filename>/var/spool/mail</filename>. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/var/tmp</filename></glossterm> <glossdef><para>Temporary files that are large or that need to exist for a longer time than what is allowed for <filename>/tmp</filename>. (Although the system administrator might not allow very old files in <filename>/var/tmp</filename> either.)</para></glossdef></glossentry> </glosslist>"
msgstr ""

#: index.docbook:1390
#, no-c-format
msgid "The <filename>/proc</filename> filesystem"
msgstr ""

#: index.docbook:1392
#, no-c-format
msgid "The <filename>/proc</filename> filesystem contains a illusionary filesystem. It does not exist on a disk. Instead, the kernel creates it in memory. It is used to provide information about the system (originally about processes, hence the name). Some of the more important files and directories are explained below. The <filename>/proc</filename> filesystem is described in more detail in the <filename>proc</filename> manual page. <glosslist> <glossentry> <glossterm><filename>/proc/1</filename></glossterm> <glossdef><para>A directory with information about process number 1. Each process has a directory below <filename>/proc</filename> with the name being its process identification number. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/cpuinfo</filename></glossterm> <glossdef><para>Information about the processor, such as its type, make, model, and performance. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/devices</filename></glossterm> <glossdef><para>List of device drivers configured into the currently running kernel. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/dma</filename></glossterm> <glossdef><para>Shows which DMA channels are being used at the moment. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/filesystems</filename></glossterm> <glossdef><para>Filesystems configured into the kernel. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/interrupts</filename></glossterm> <glossdef><para>Shows which interrupts are in use, and how many of each there have been. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/ioports</filename></glossterm> <glossdef><para>Which I/O ports are in use at the moment. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/kcore</filename></glossterm> <glossdef><para>An image of the physical memory of the system. This is exactly the same size as your physical memory, but does not really take up that much memory; it is generated on the fly as programs access it. (Remember: unless you copy it elsewhere, nothing under <filename>/proc</filename> takes up any disk space at all.) </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/kmsg</filename></glossterm> <glossdef><para>Messages output by the kernel. These are also routed to <command>syslog</command>. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/ksyms</filename></glossterm> <glossdef><para>Symbol table for the kernel. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/loadavg</filename></glossterm> <glossdef><para>The `load average' of the system; three meaningless indicators of how much work the system has to do at the moment. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/meminfo</filename></glossterm> <glossdef><para>Information about memory usage, both physical and swap. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/modules</filename></glossterm> <glossdef><para>Which kernel modules are loaded at the moment. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/net</filename></glossterm> <glossdef><para>Status information about network protocols. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/self</filename></glossterm> <glossdef><para>A symbolic link to the process directory of the program that is looking at <filename>/proc</filename>. When two processes look at <filename>/proc</filename>, they get different links. This is mainly a convenience to make it easier for programs to get at their process directory. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/stat</filename></glossterm> <glossdef><para>Various statistics about the system, such as the number of page faults since the system was booted. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/uptime</filename></glossterm> <glossdef><para>The time the system has been up. </para></glossdef></glossentry> <glossentry> <glossterm><filename>/proc/version</filename></glossterm> <glossdef><para>The kernel version. </para></glossdef></glossentry> </glosslist>"
msgstr ""

#: index.docbook:1511
#, no-c-format
msgid "Note that while the above files tend to be easily readable text files, they can sometimes be formatted in a way that is not easily digestible. There are many commands that do little more than read the above files and format them for easier understanding. For example, the <command>free</command> program reads <filename>/proc/meminfo</filename> and converts the amounts given in bytes to kilobytes (and adds a little more information, as well)."
msgstr ""

#: index.docbook:1525
#, no-c-format
msgid "Device Files"
msgstr ""

#: index.docbook:1527
#, no-c-format
msgid "This chapter gives an overview of what a device file is, and how to create one. It also lists some of the more common device files. The canonical list of device files is <filename>/usr/src/linux/Documentation/devices.txt</filename> if you have the Linux kernel source code installed on your system. The devices listed here are correct as of kernel version 2.2.17."
msgstr ""

#: index.docbook:1535
#, no-c-format
msgid "The <command>MAKEDEV</command> Script"
msgstr ""

#: index.docbook:1537
#, no-c-format
msgid "Most device files will already be created and will be there ready to use after you install your Linux system. If by some chance you need to create one which is not provided then you should first try to use the <command>MAKEDEV</command> script. This script is usually located in <filename>/dev/MAKEDEV</filename> but might also have a copy (or a symbolic link) in <filename>/sbin/MAKEDEV</filename>. If it turns out not to be in your path then you will need to specify the path to it explicitly."
msgstr ""

#: index.docbook:1547
#, no-c-format
msgid ""
      "In general the command is used as: <screen>\n"
      "	<prompt>#</prompt> <userinput>/dev/MAKEDEV -v ttyS0</userinput>\n"
      "	<computeroutput>create ttyS0   c 4 64 root:dialout 0660</computeroutput>\n"
      "	</screen> This will create the device file <filename>/dev/ttyS0</filename> with major node 4 and minor node 64 as a character device with access permissions 0660 with owner root and group dialout."
msgstr ""

#: index.docbook:1558
#, no-c-format
msgid "<filename>ttyS0</filename> is a serial port. The major and minor node numbers are numbers understood by the kernel. The kernel refers to hardware devices as numbers, this would be very difficult for us to remember, so we use filenames. Access permissions of 0660 means read and write permission for the owner (root in this case) and read and write permission for members of the group (dialout in this case) with no access for anyone else."
msgstr ""

#: index.docbook:1568
#, no-c-format
msgid "The <command>mknod</command> command"
msgstr ""

#: index.docbook:1570
#, no-c-format
msgid "<command>MAKEDEV</command> is the preferred way of creating device files which are not present. However sometimes the <command>MAKEDEV</command> script will not know about the device file you wish to create. This is where the <command>mknod</command> command comes in. In order to use <command>mknod</command> you need to know the major and minor node numbers for the device you wish to create. The <filename>devices.txt</filename> file in the kernel source documentation is the canonical source of this information."
msgstr ""

#: index.docbook:1580
#, no-c-format
msgid ""
      "To take an example, let us suppose that our version of the <command>MAKEDEV</command> script does not know how to create the <filename>/dev/ttyS0</filename> device file. We need to use <command>mknod</command> to create it. We know from looking at the <filename>devices.txt</filename> file that it should be a character device with major number 4 and minor number 64. So we now know all we need to create the file. <screen>\n"
      "	<prompt>#</prompt> <userinput>mknod /dev/ttyS0 c 4 64</userinput>\n"
      "	<prompt>#</prompt> <userinput>chown root.dialout /dev/ttyS0</userinput>\n"
      "	<prompt>#</prompt> <userinput>chmod 0644 /dev/ttyS0</userinput>\n"
      "	<prompt>#</prompt> <userinput>ls -l /dev/ttyS0</userinput>\n"
      "<computeroutput>crw-rw----   1 root dialout    4,   64 Oct 23 18:23 /dev/ttyS0</computeroutput> \n"
      "	</screen> As you can see, many more steps are required to create the file. In this example you can see the process required however. It is unlikely in the extreme that the ttyS0 file would not be provided by the <command>MAKEDEV</command> script, but it suffices to illustrate the point."
msgstr ""

#: index.docbook:1604
#, no-c-format
msgid "Device List"
msgstr ""

#: index.docbook:1606
#, no-c-format
msgid "This list which follows is by no means exhaustive or as detailed as it could be. Many of these device files will need support compiled into your kernel for the hardware. Read the kernel documentation to find details of any particular device."
msgstr ""

#: index.docbook:1611
#, no-c-format
msgid "If you think there are other devices which should be included here but aren't then let me know. I will try to include them in the next revision."
msgstr ""

#: index.docbook:1615
#, no-c-format
msgid "/dev/dsp"
msgstr ""

#: index.docbook:1615
#, no-c-format
msgid "Digital Signal Processor. Basically this forms the interface between software which produces sound and your soundcard. It is a character device on major node 14 and minor 3."
msgstr ""

#: index.docbook:1623
#, no-c-format
msgid "/dev/fd0"
msgstr ""

#: index.docbook:1623
#, no-c-format
msgid "The first floppy drive. If you are lucky enough to have several drives then they will be numbered sequentially. It is a character device on major node 2 and minor 0."
msgstr ""

#: index.docbook:1631
#, no-c-format
msgid "/dev/fb0"
msgstr ""

#: index.docbook:1631
#, no-c-format
msgid "The first framebuffer device. A framebuffer is an abstraction layer between software and graphics hardware. This means that applications do not need to know about what kind of hardware you have but merely how to communicate with the framebuffer driver's API (Application Programming Interface) which is well defined and standardised. The framebuffer is a character device and is on major node 29 and minor 0."
msgstr ""

#: index.docbook:1643
#, no-c-format
msgid "/dev/hda"
msgstr ""

#: index.docbook:1643
#, no-c-format
msgid "<filename>/dev/hda</filename> is the master IDE drive on the primary IDE controller. <filename>/dev/hdb</filename> is the slave drive on the primary controller. <filename>/dev/hdc</filename> and <filename>/dev/hdd</filename> are the master and slave devices on the secondary controller respectively. Each disk is divided into partitions. Partitions 1-4 are primary partitions and partitions 5 and above are logical partitions inside extended partitions. Therefore the device file which references each partition is made up of several parts. For example <filename>/dev/hdc9</filename> references partition 9 (a logical partition inside an extended partition type) on the master IDE drive on the secondary IDE controller. The major and minor node numbers are somewhat complex. For the first IDE controller all partitions are block devices on major node 3. The master drive <filename>hda</filename> is at minor 0 and the slave drive <filename>hdb</filename> is at minor 64. For each partition inside the drive add the partition number to the minor node number for the drive. For example <filename>/dev/hdb5</filename> is major 3, minor 69 (64 + 5 = 69). Drives on the secondary interface are handled the same way, but with major node 22."
msgstr ""

#: index.docbook:1669
#, no-c-format
msgid "/dev/ht0"
msgstr ""

#: index.docbook:1669
#, no-c-format
msgid "The first IDE tape drive. Subsequent drives are numbered <filename>ht1</filename> etc. They are character devices on major node 37 and start at minor node 0 for <filename>ht0</filename> 1 for <filename>ht1</filename> etc."
msgstr ""

#: index.docbook:1678
#, no-c-format
msgid "/dev/js0"
msgstr ""

#: index.docbook:1678
#, no-c-format
msgid "The first analogue joystick. Subsequent joysticks are numbered <filename>js1</filename>, <filename>js2</filename> etc. Digital joysticks are called <filename>djs0</filename>, <filename>djs1</filename> and so on. They are character devices on major node 15. The analogue joysticks start at minor node 0 and go up to 127 (more than enough for even the most fanatic gamer). Digital joysticks start at minor node 128."
msgstr ""

#: index.docbook:1690
#, no-c-format
msgid "/dev/lp0"
msgstr ""

#: index.docbook:1690
#, no-c-format
msgid "The first parallel printer device. Subsequent printers are numbered <filename>lp1</filename>, <filename>lp2</filename> etc. They are character devices on major mode 6 and minor nodes starting at 0 and numbered sequentially."
msgstr ""

#: index.docbook:1699
#, no-c-format
msgid "/dev/loop0"
msgstr ""

#: index.docbook:1699
#, no-c-format
msgid "The first loopback device. Loopback devices are used for mounting filesystems which are not located on other block devices such as disks. For example if you wish to mount an iso9660 CD ROM image without burning it to CD then you need to use a loopback device to do so. This is usually transparent to the user and is handled by the <command>mount</command> command. Refer to the manual pages for <command>mount</command> and <command>losetup</command>. The loopback devices are block devices on major node 7 and with minor nodes starting at 0 and numbered sequentially."
msgstr ""

#: index.docbook:1713
#, no-c-format
msgid "/dev/md0"
msgstr ""

#: index.docbook:1713
#, no-c-format
msgid "First metadisk group. Metadisks are related to RAID (Redundant Array of Independent Disks) devices. Please refer to the various RAID HOWTOs at the LDP for more details. Metadisk devices are block devices on major node 9 with minor nodes starting at 0 and numbered sequentially."
msgstr ""

#: index.docbook:1723
#, no-c-format
msgid "/dev/mixer"
msgstr ""

#: index.docbook:1723
#, no-c-format
msgid "This is part of the OSS (Open Sound System) driver. Refer to the OSS documentation at <ulink url=\"http://www.opensound.com\">http://www.opensound.com</ulink> for more details. It is a character device on major node 14, minor node 0."
msgstr ""

#: index.docbook:1732
#, no-c-format
msgid "/dev/null"
msgstr ""

#: index.docbook:1732
#, no-c-format
msgid "The bit bucket. A black hole where you can send data for it never to be seen again. Anything sent to <filename>/dev/null</filename> will disappear. This can be useful if, for example, you wish to run a command but not have any feedback appear on the terminal. It is a character device on major node 1 and minor node 3."
msgstr ""

#: index.docbook:1742
#, no-c-format
msgid "/dev/psaux"
msgstr ""

#: index.docbook:1742
#, no-c-format
msgid "The PS/2 mouse port. This is a character device on major node 10, minor node 1."
msgstr ""

#: index.docbook:1748
#, no-c-format
msgid "/dev/pda"
msgstr ""

#: index.docbook:1748
#, no-c-format
msgid "Parallel port IDE disks. These are named similarly to disks on the internal IDE controllers (<filename>/dev/hd*</filename>). They are block devices on major node 45. Minor nodes need slightly more explanation here. The first device is <filename>/dev/pda</filename> and it is on minor node 0. Partitions on this device are found by adding the partition number to the minor number for the device. Each device is limited to 15 partitions each rather than 63 (the limit for internal IDE disks). <filename>/dev/pdb</filename> minor nodes start at 16, <filename>/dev/pdc</filename> at 32 and <filename>/dev/pdd</filename> at 48. So for example the minor node number for <filename>/dev/pdc6</filename> would be 38 (32 + 6 = 38). This scheme limits you to 4 parallel disks of 15 partitions each."
msgstr ""

#: index.docbook:1766
#, no-c-format
msgid "/dev/pcd0"
msgstr ""

#: index.docbook:1766
#, no-c-format
msgid "Parallel port CD ROM drives. These are numbered from 0 onwards. All are block devices on major node 46. <filename>/dev/pcd0</filename> is on minor node 0 with subsequent drives being on minor nodes 1, 2, 3 etc."
msgstr ""

#: index.docbook:1776
#, no-c-format
msgid "/dev/pt0"
msgstr ""

#: index.docbook:1776
#, no-c-format
msgid "Parallel port tape devices. Tapes do not have partitions so these are just numbered sequentially. They are character devices on major node 96. The minor node numbers start from 0 for <filename>/dev/pt0</filename>, 1 for <filename>/dev/pt1</filename>, and so on."
msgstr ""

#: index.docbook:1785
#, no-c-format
msgid "/dev/parport0"
msgstr ""

#: index.docbook:1785
#, no-c-format
msgid "The raw parallel ports. Most devices which are attached to parallel ports have their own drivers. This is a device to access the port directly. It is a character device on major node 99 with minor node 0. Subsequent devices after the first are numbered sequentially incrementing the minor node."
msgstr ""

#: index.docbook:1795
#, no-c-format
msgid "<filename>/dev/random</filename> or <filename>/dev/urandom</filename>"
msgstr ""

#: index.docbook:1795
#, no-c-format
msgid "These are kernel random number generators. <filename>/dev/random</filename> is a non-deterministic generator which means that the value of the next number cannot be guessed from the preceding ones. It uses the entropy of the system hardware to generate numbers. When it has no more entropy to use then it must wait until it has collected more before it will allow any more numbers to be read from it. <filename>/dev/urandom</filename> works similarly. Initially it also uses the entropy of the system hardware, but when there is no more entropy to use it will continue to return numbers using a pseudo random number generating formula. This is considered to be less secure for vital purposes such as cryptographic key pair generation. If security is your overriding concern then use <filename>/dev/random</filename>, if speed is more important then <filename>/dev/urandom</filename> works fine. They are character devices on major node 1 with minor nodes 8 for <filename>/dev/random</filename> and 9 for <filename>/dev/urandom</filename>."
msgstr ""

#: index.docbook:1817
#, no-c-format
msgid "/dev/zero"
msgstr ""

#: index.docbook:1817
#, no-c-format
msgid "This is a simple way of getting many 0s. Every time you read from this device it will return 0. This can be useful sometimes, for example when you want a file of fixed length but don't really care what it contains. It is a character device on major node 1 and minor node 5."
msgstr ""

#: index.docbook:1832
#, no-c-format
msgid "Using Disks and Other Storage Media"
msgstr ""

#: index.docbook:1834
#, no-c-format
msgid "On a clear disk you can seek forever."
msgstr ""

#: index.docbook:1869
#, no-c-format
msgid "When you install or upgrade your system, you need to do a fair amount of work on your disks. You have to make filesystems on your disks so that files can be stored on them and reserve space for the different parts of your system."
msgstr ""

#: index.docbook:1874
#, no-c-format
msgid "This chapter explains all these initial activities. Usually, once you get your system set up, you won't have to go through the work again, except for using floppies. You'll need to come back to this chapter if you add a new disk or want to fine-tune your disk usage."
msgstr ""

#: index.docbook:1879
#, no-c-format
msgid "The basic tasks in administering disks are: <itemizedlist> <listitem><para> Format your disk. This does various things to prepare it for use, such as checking for bad sectors. (Formatting is nowadays not necessary for most hard disks.)</para></listitem> <listitem><para> Partition a hard disk, if you want to use it for several activities that aren't supposed to interfere with one another. One reason for partitioning is to store different operating systems on the same disk. Another reason is to keep user files separate from system files, which simplifies back-ups and helps protect the system files from corruption. </para></listitem> <listitem><para> Make a filesystem (of a suitable type) on each disk or partition. The disk means nothing to Linux until you make a filesystem; then files can be created and accessed on it. </para></listitem> <listitem><para> Mount different filesystems to form a single tree structure, either automatically, or manually as needed. (Manually mounted filesystems usually need to be unmounted manually as well.) </para></listitem> </itemizedlist> <xref linkend=\"memory-management\"/> contains information about virtual memory and disk caching, of which you also need to be aware when using disks."
msgstr ""

#: index.docbook:1916
#, no-c-format
msgid "Two kinds of devices"
msgstr ""

#: index.docbook:1918
#, no-c-format
msgid ""
      "UNIX, and therefore Linux, recognizes two different kinds of device: random-access block devices (such as disks), and character devices (such as tapes and serial lines), some of which may be serial, and some random-access. Each supported device is represented in the filesystem as a <glossterm>device file</glossterm>. When you read or write a device file, the data comes from or goes to the device it represents. This way no special programs (and no special application programming methodology, such as catching interrupts or polling a serial port) are necessary to access devices; for example, to send a file to the printer, one could just say <screen>\n"
      "<prompt>$</prompt> <userinput>cat filename &gt; /dev/lp1</userinput>\n"
      "<prompt>$</prompt>\n"
      "</screen> and the contents of the file are printed (the file must, of course, be in a form that the printer understands). However, since it is not a good idea to have several people cat their files to the printer at the same time, one usually uses a special program to send the files to be printed (usually <command>lpr</command>). This program makes sure that only one file is being printed at a time, and will automatically send files to the printer as soon as it finishes with the previous file. Something similar is needed for most devices. In fact, one seldom needs to worry about device files at all."
msgstr ""

#: index.docbook:1946
#, no-c-format
msgid ""
      "Since devices show up as files in the filesystem (in the <filename>/dev</filename> directory), it is easy to see just what device files exist, using <command>ls</command> or another suitable command. In the output of <command>ls -l</command>, the first column contains the type of the file and its permissions. For example, inspecting a serial device might give <screen>\n"
      "<prompt>$</prompt> <userinput>ls -l /dev/ttyS0</userinput>\n"
      "<computeroutput>crw-rw-r--    1 root     dialout    4,  64 Aug 19 18:56 /dev/ttyS0</computeroutput>\n"
      "<prompt>$</prompt>\n"
      "</screen> The first character in the first column, i.e., `<literal>c</literal>' in <literal>crw-rw-rw-</literal> above, tells an informed user the type of the file, in this case a character device. For ordinary files, the first character is `<literal>-</literal>', for directories it is `<literal>d</literal>', and for block devices `<literal>b</literal>'; see the <command>ls</command> man page for further information."
msgstr ""

#: index.docbook:1968
#, no-c-format
msgid "Note that usually all device files exist even though the device itself might be not be installed. So just because you have a file <filename>/dev/sda</filename>, it doesn't mean that you really do have an SCSI hard disk. Having all the device files makes the installation programs simpler, and makes it easier to add new hardware (there is no need to find out the correct parameters for and create the device files for the new device)."
msgstr ""

#: index.docbook:1979
#, no-c-format
msgid "Hard disks"
msgstr ""

#: index.docbook:1981
#, no-c-format
msgid "This subsection introduces terminology related to hard disks. If you already know the terms and concepts, you can skip this subsection."
msgstr ""

#: index.docbook:1985
#, no-c-format
msgid "See <xref linkend=\"hd-schematic\"/> for a schematic picture of the important parts in a hard disk. A hard disk consists of one or more circular <glossterm>platters</glossterm>, <footnote><para>The platters are made of a hard substance, e.g., aluminum, which gives the hard disk its name.</para></footnote> of which either or both <glossterm>surfaces</glossterm> are coated with a magnetic substance used for recording the data. For each surface, there is a <glossterm>read-write head</glossterm> that examines or alters the recorded data. The platters rotate on a common axis; typical rotation speed is 5400 or 7200 rotations per minute, although high-performance hard disks have higher speeds and older disks may have lower speeds. The heads move along the radius of the platters; this movement combined with the rotation of the platters allows the head to access all parts of the surfaces."
msgstr ""

#: index.docbook:2003
#, no-c-format
msgid "The processor (CPU) and the actual disk communicate through a <glossterm>disk controller</glossterm>. This relieves the rest of the computer from knowing how to use the drive, since the controllers for different types of disks can be made to use the same interface towards the rest of the computer. Therefore, the computer can say just <quote>hey disk, give me what I want</quote>, instead of a long and complex series of electric signals to move the head to the proper location and waiting for the correct position to come under the head and doing all the other unpleasant stuff necessary. (In reality, the interface to the controller is still complex, but much less so than it would otherwise be.) The controller may also do other things, such as caching, or automatic bad sector replacement."
msgstr ""

#: index.docbook:2017
#, no-c-format
msgid "The above is usually all one needs to understand about the hardware. There are also other things, such as the motor that rotates the platters and moves the heads, and the electronics that control the operation of the mechanical parts, but they are mostly not relevant for understanding the working principles of a hard disk."
msgstr ""

#: index.docbook:2024
#, no-c-format
msgid "The surfaces are usually divided into concentric rings, called <glossterm>tracks</glossterm>, and these in turn are divided into <glossterm>sectors</glossterm>. This division is used to specify locations on the hard disk and to allocate disk space to files. To find a given place on the hard disk, one might say <quote>surface 3, track 5, sector 7</quote>. Usually the number of sectors is the same for all tracks, but some hard disks put more sectors in outer tracks (all sectors are of the same physical size, so more of them fit in the longer outer tracks). Typically, a sector will hold 512 bytes of data. The disk itself can't handle smaller amounts of data than one sector."
msgstr ""

#: index.docbook:2037
#, no-c-format
msgid "A schematic picture of a hard disk."
msgstr ""

#: index.docbook:2041
#, no-c-format
msgid "Each surface is divided into tracks (and sectors) in the same way. This means that when the head for one surface is on a track, the heads for the other surfaces are also on the corresponding tracks. All the corresponding tracks taken together are called a <glossterm>cylinder</glossterm>. It takes time to move the heads from one track (cylinder) to another, so by placing the data that is often accessed together (say, a file) so that it is within one cylinder, it is not necessary to move the heads to read all of it. This improves performance. It is not always possible to place files like this; files that are stored in several places on the disk are called <glossterm>fragmented</glossterm>."
msgstr ""

#: index.docbook:2054
#, no-c-format
msgid "The number of surfaces (or heads, which is the same thing), cylinders, and sectors vary a lot; the specification of the number of each is called the <glossterm>geometry</glossterm> of a hard disk. The geometry is usually stored in a special, battery-powered memory location called the <glossterm>CMOS RAM</glossterm>, from where the operating system can fetch it during bootup or driver initialization."
msgstr ""

#: index.docbook:2062
#, no-c-format
msgid "Unfortunately, the BIOS <footnote><para>The BIOS is some built-in software stored on ROM chips. It takes care, among other things, of the initial stages of booting.</para></footnote> has a design limitation, which makes it impossible to specify a track number that is larger than 1024 in the CMOS RAM, which is too little for a large hard disk. To overcome this, the hard disk controller lies about the geometry, and <glossterm>translates the addresses</glossterm> given by the computer into something that fits reality. For example, a hard disk might have 8 heads, 2048 tracks, and 35 sectors per track. <footnote><para>The numbers are completely imaginary.</para></footnote> Its controller could lie to the computer and claim that it has 16 heads, 1024 tracks, and 35 sectors per track, thus not exceeding the limit on tracks, and translates the address that the computer gives it by halving the head number, and doubling the track number. The mathematics can be more complicated in reality, because the numbers are not as nice as here (but again, the details are not relevant for understanding the principle). This translation distorts the operating system's view of how the disk is organized, thus making it impractical to use the all-data-on-one-cylinder trick to boost performance."
msgstr ""

#: index.docbook:2090
#, no-c-format
msgid "The translation is only a problem for IDE disks. SCSI disks use a sequential sector number (i.e., the controller translates a sequential sector number to a head, cylinder, and sector triplet), and a completely different method for the CPU to talk with the controller, so they are insulated from the problem. Note, however, that the computer might not know the real geometry of an SCSI disk either."
msgstr ""

#: index.docbook:2098
#, no-c-format
msgid "Since Linux often will not know the real geometry of a disk, its filesystems don't even try to keep files within a single cylinder. Instead, it tries to assign sequentially numbered sectors to files, which almost always gives similar performance. The issue is further complicated by on-controller caches, and automatic prefetches done by the controller."
msgstr ""

#: index.docbook:2105
#, no-c-format
msgid "Each hard disk is represented by a separate device file. There can (usually) be only two or four IDE hard disks. These are known as <filename>/dev/hda</filename>, <filename>/dev/hdb</filename>, <filename>/dev/hdc</filename>, and <filename>/dev/hdd</filename>, respectively. SCSI hard disks are known as <filename>/dev/sda</filename>, <filename>/dev/sdb</filename>, and so on. Similar naming conventions exist for other hard disk types; see <xref linkend=\"device-list\"/> for more information. Note that the device files for the hard disks give access to the entire disk, with no regard to partitions (which will be discussed below), and it's easy to mess up the partitions or the data in them if you aren't careful. The disks' device files are usually used only to get access to the master boot record (which will also be discussed below)."
msgstr ""

#: index.docbook:2123
#, no-c-format
msgid "Floppies"
msgstr ""

#: index.docbook:2125
#, no-c-format
msgid "A floppy disk consists of a flexible membrane covered on one or both sides with similar magnetic substance as a hard disk. The floppy disk itself doesn't have a read-write head, that is included in the drive. A floppy corresponds to one platter in a hard disk, but is removable and one drive can be used to access different floppies, and the same floppy can be read by many drives, whereas the hard disk is one indivisible unit."
msgstr ""

#: index.docbook:2133
#, no-c-format
msgid "Like a hard disk, a floppy is divided into tracks and sectors (and the two corresponding tracks on either side of a floppy form a cylinder), but there are many fewer of them than on a hard disk."
msgstr ""

#: index.docbook:2138
#, no-c-format
msgid "A floppy drive can usually use several different types of disks; for example, a 3.5 inch drive can use both 720 kB and 1.44 MB disks. Since the drive has to operate a bit differently and the operating system must know how big the disk is, there are many device files for floppy drives, one per combination of drive and disk type. Therefore, <filename>/dev/fd0H1440</filename> is the first floppy drive (fd0), which must be a 3.5 inch drive, using a 3.5 inch, high density disk (H) of size 1440 kB (1440), i.e., a normal 3.5 inch HD floppy."
msgstr ""

#: index.docbook:2149
#, no-c-format
msgid "The names for floppy drives are complex, however, and Linux therefore has a special floppy device type that automatically detects the type of the disk in the drive. It works by trying to read the first sector of a newly inserted floppy using different floppy types until it finds the correct one. This naturally requires that the floppy is formatted first. The automatic devices are called <filename>/dev/fd0</filename>, <filename>/dev/fd1</filename>, and so on."
msgstr ""

#: index.docbook:2158
#, no-c-format
msgid "The parameters the automatic device uses to access a disk can also be set using the program <command>setfdprm</command>. This can be useful if you need to use disks that do not follow any usual floppy sizes, e.g., if they have an unusual number of sectors, or if the autodetecting for some reason fails and the proper device file is missing."
msgstr ""

#: index.docbook:2165
#, no-c-format
msgid "Linux can handle many nonstandard floppy disk formats in addition to all the standard ones. Some of these require using special formatting programs. We'll skip these disk types for now, but in the mean time you can examine the <filename>/etc/fdprm</filename> file. It specifies the settings that <command>setfdprm</command> recognizes."
msgstr ""

#: index.docbook:2172
#, no-c-format
msgid "The operating system must know when a disk has been changed in a floppy drive, for example, in order to avoid using cached data from the previous disk. Unfortunately, the signal line that is used for this is sometimes broken, and worse, this won't always be noticeable when using the drive from within MS-DOS. If you are experiencing weird problems using floppies, this might be the reason. The only way to correct it is to repair the floppy drive."
msgstr ""

#: index.docbook:2183
#, no-c-format
msgid "CD-ROMs"
msgstr ""

#: index.docbook:2185
#, no-c-format
msgid "A CD-ROM drive uses an optically read, plastic coated disk. The information is recorded on the surface of the disk <footnote><para>That is, the surface inside the disk, on the metal disk inside the plastic coating.</para></footnote> in small `holes' aligned along a spiral from the center to the edge. The drive directs a laser beam along the spiral to read the disk. When the laser hits a hole, the laser is reflected in one way; when it hits smooth surface, it is reflected in another way. This makes it easy to code bits, and therefore information. The rest is easy, mere mechanics."
msgstr ""

#: index.docbook:2198
#, no-c-format
msgid "CD-ROM drives are slow compared to hard disks. Whereas a typical hard disk will have an average seek time less than 15 milliseconds, a fast CD-ROM drive can use tenths of a second for seeks. The actual data transfer rate is fairly high at hundreds of kilobytes per second. The slowness means that CD-ROM drives are not as pleasant to use as hard disks (some Linux distributions provide `live' filesystems on CD-ROMs, making it unnecessary to copy the files to the hard disk, making installation easier and saving a lot of hard disk space), although it is still possible. For installing new software, CD-ROMs are very good, since maximum speed is not essential during installation."
msgstr ""

#: index.docbook:2210
#, no-c-format
msgid "There are several ways to arrange data on a CD-ROM. The most popular one is specified by the international standard ISO 9660. This standard specifies a very minimal filesystem, which is even more crude than the one MS-DOS uses. On the other hand, it is so minimal that every operating system should be able to map it to its native system."
msgstr ""

#: index.docbook:2217
#, no-c-format
msgid "For normal UNIX use, the ISO 9660 filesystem is not usable, so an extension to the standard has been developed, called the Rock Ridge extension. Rock Ridge allows longer filenames, symbolic links, and a lot of other goodies, making a CD-ROM look more or less like any contemporary UNIX filesystem. Even better, a Rock Ridge filesystem is still a valid ISO 9660 filesystem, making it usable by non-UNIX systems as well. Linux supports both ISO 9660 and the Rock Ridge extensions; the extensions are recognized and used automatically."
msgstr ""

#: index.docbook:2227
#, no-c-format
msgid "The filesystem is only half the battle, however. Most CD-ROMs contain data that requires a special program to access, and most of these programs do not run under Linux (except, possibly, under dosemu, the Linux MS-DOS emulator, or wine, the Windows emulator. <footnote><para>Ironically perhaps, wine actually stands for <quote>Wine Is Not an Emulator</quote>. Wine, more strictly, is an API (Application Program Interface) replacement. Please see the wine documentation at <ulink url=\"http://www.winehq.com\">http://www.winehq.com</ulink> for more information.</para></footnote> There is also VMWare, a commercial product which emulates an entire x86 machine in software <footnote><para>See the VMWare website, <ulink url=\"http://www.vmware.com\">http://www.vmware.com</ulink> for more information.</para></footnote>) ."
msgstr ""

#: index.docbook:2248
#, no-c-format
msgid "A CD-ROM drive is accessed via the corresponding device file. There are several ways to connect a CD-ROM drive to the computer: via SCSI, via a sound card, or via EIDE. The hardware hacking needed to do this is outside the scope of this book, but the type of connection decides the device file."
msgstr ""

#: index.docbook:2257
#, no-c-format
msgid "Tapes"
msgstr ""

#: index.docbook:2259
#, no-c-format
msgid "A tape drive uses a tape, similar <footnote><para>But completely different, of course.</para></footnote> to cassettes used for music. A tape is serial in nature, which means that in order to get to any given part of it, you first have to go through all the parts in between. A disk can be accessed randomly, i.e., you can jump directly to any place on the disk. The serial access of tapes makes them slow."
msgstr ""

#: index.docbook:2270
#, no-c-format
msgid "On the other hand, tapes are relatively cheap to make, since they do not need to be fast. They can also easily be made quite long, and can therefore contain a large amount of data. This makes tapes very suitable for things like archiving and backups, which do not require large speeds, but benefit from low costs and large storage capacities."
msgstr ""

#: index.docbook:2280
#, no-c-format
msgid "Formatting"
msgstr ""

#: index.docbook:2282
#, no-c-format
msgid "<glossterm>Formatting</glossterm> is the process of writing marks on the magnetic media that are used to mark tracks and sectors. Before a disk is formatted, its magnetic surface is a complete mess of magnetic signals. When it is formatted, some order is brought into the chaos by essentially drawing lines where the tracks go, and where they are divided into sectors. The actual details are not quite exactly like this, but that is irrelevant. What is important is that a disk cannot be used unless it has been formatted."
msgstr ""

#: index.docbook:2291
#, no-c-format
msgid "The terminology is a bit confusing here: in MS-DOS and MS Windows, the word formatting is used to cover also the process of creating a filesystem (which will be discussed below). There, the two processes are often combined, especially for floppies. When the distinction needs to be made, the real formatting is called <glossterm>low-level formatting</glossterm>, while making the filesystem is called <glossterm>high-level formatting</glossterm>. In UNIX circles, the two are called formatting and making a filesystem, so that's what is used in this book as well."
msgstr ""

#: index.docbook:2301
#, no-c-format
msgid "For IDE and some SCSI disks the formatting is actually done at the factory and doesn't need to be repeated; hence most people rarely need to worry about it. In fact, formatting a hard disk can cause it to work less well, for example because a disk might need to be formatted in some very special way to allow automatic bad sector replacement to work."
msgstr ""

#: index.docbook:2308
#, no-c-format
msgid "Disks that need to be or can be formatted often require a special program anyway, because the interface to the formatting logic inside the drive is different from drive to drive. The formatting program is often either on the controller BIOS, or is supplied as an MS-DOS program; neither of these can easily be used from within Linux."
msgstr ""

#: index.docbook:2315
#, no-c-format
msgid "During formatting one might encounter bad spots on the disk, called <glossterm>bad blocks</glossterm> or <glossterm>bad sectors</glossterm>. These are sometimes handled by the drive itself, but even then, if more of them develop, something needs to be done to avoid using those parts of the disk. The logic to do this is built into the filesystem; how to add the information into the filesystem is described below. Alternatively, one might create a small partition that covers just the bad part of the disk; this approach might be a good idea if the bad spot is very large, since filesystems can sometimes have trouble with very large bad areas."
msgstr ""

#: index.docbook:2326
#, no-c-format
msgid ""
      "Floppies are formatted with <command>fdformat</command>. The floppy device file to use is given as the parameter. For example, the following command would format a high density, 3.5 inch floppy in the first floppy drive: <screen>\n"
      "	<prompt>$</prompt> <userinput>fdformat /dev/fd0H1440</userinput>\n"
      "	<computeroutput>Double-sided, 80 tracks, 18 sec/track. Total capacity \n"
      "	1440 kB.</computeroutput>\n"
      "	<computeroutput>Formatting ... done</computeroutput>\n"
      "	<computeroutput>Verifying ... done</computeroutput>\n"
      "	<prompt>$</prompt>\n"
      "	</screen> Note that if you want to use an autodetecting device (e.g., <filename>/dev/fd0</filename>), you <emphasis>must</emphasis> set the parameters of the device with <command>setfdprm</command> first. To achieve the same effect as above, one would have to do the following: <screen>\n"
      "	<prompt>$</prompt> <userinput>setfdprm /dev/fd0 1440/1440</userinput>\n"
      "	<prompt>$</prompt> <userinput>fdformat /dev/fd0</userinput>\n"
      "	<computeroutput>Double-sided, 80 tracks, 18 sec/track. Total capacity \n"
      "	1440 kB.</computeroutput>\n"
      "	<computeroutput>Formatting ... done</computeroutput>\n"
      "	<computeroutput>Verifying ... done</computeroutput>\n"
      "	<prompt>$</prompt>\n"
      "	</screen> It is usually more convenient to choose the correct device file that matches the type of the floppy. Note that it is unwise to format floppies to contain more information than what they are designed for."
msgstr ""

#: index.docbook:2361
#, no-c-format
msgid ""
      "<command>fdformat</command> will also validate the floppy, i.e., check it for bad blocks. It will try a bad block several times (you can usually hear this, the drive noise changes dramatically). If the floppy is only marginally bad (due to dirt on the read/write head, some errors are false signals), <command>fdformat</command> won't complain, but a real error will abort the validation process. The kernel will print log messages for each I/O error it finds; these will go to the console or, if <command>syslog</command> is being used, to the file <filename>/usr/log/messages</filename>. <command>fdformat</command> itself won't tell where the error is (one usually doesn't care, floppies are cheap enough that a bad one is automatically thrown away). <screen>\n"
      "	<prompt>$</prompt> <userinput>fdformat /dev/fd0H1440</userinput>\n"
      "	<computeroutput>Double-sided, 80 tracks, 18 sec/track. Total capacity \n"
      "	1440 kB.</computeroutput>\n"
      "	<computeroutput>Formatting ... done</computeroutput>\n"
      "	<computeroutput>Verifying ... read: Unknown error</computeroutput>\n"
      "	<prompt>$</prompt>\n"
      "	</screen> The <command>badblocks</command> command can be used to search any disk or partition for bad blocks (including a floppy). It does not format the disk, so it can be used to check even existing filesystems. The example below checks a 3.5 inch floppy with two bad blocks. <screen>\n"
      "	<prompt>$</prompt> <userinput>badblocks /dev/fd0H1440 1440</userinput>\n"
      "	<computeroutput>718</computeroutput>\n"
      "	<computeroutput>719</computeroutput>\n"
      "	<prompt>$</prompt>\n"
      "	</screen> <command>badblocks</command> outputs the block numbers of the bad blocks it finds. Most filesystems can avoid such bad blocks. They maintain a list of known bad blocks, which is initialised when the filesystem is made, and can be modified later. The initial search for bad blocks can be done by the <command>mkfs</command> command (which initializes the filesystem), but later checks should be done with <command>badblocks</command> and the new blocks should be added with <command>fsck</command>. We'll describe <command>mkfs</command> and <command>fsck</command> later."
msgstr ""

#: index.docbook:2408
#, no-c-format
msgid "Many modern disks automatically notice bad blocks, and attempt to fix them by using a special, reserved good block instead. This is invisible to the operating system. This feature should be documented in the disk's manual, if you're curious if it is happening. Even such disks can fail, if the number of bad blocks grows too large, although chances are that by then the disk will be so rotten as to be unusable."
msgstr ""

#: index.docbook:2419
#, no-c-format
msgid "Partitions"
msgstr ""

#: index.docbook:2421
#, no-c-format
msgid "A hard disk can be divided into several <glossterm>partitions</glossterm>. Each partition functions as if it were a separate hard disk. The idea is that if you have one hard disk, and want to have, say, two operating systems on it, you can divide the disk into two partitions. Each operating system uses its partition as it wishes and doesn't touch the other ones. This way the two operating systems can co-exist peacefully on the same hard disk. Without partitions one would have to buy a hard disk for each operating system."
msgstr ""

#: index.docbook:2431
#, no-c-format
msgid "Floppies are not usually partitioned. There is no technical reason against this, but since they're so small, partitions would be useful only very rarely. CD-ROMs are usually also not partitioned, since it's easier to use them as one big disk, and there is seldom a need to have several operating systems on one."
msgstr ""

#: index.docbook:2438
#, no-c-format
msgid "The MBR, boot sectors and partition table"
msgstr ""

#: index.docbook:2440
#, no-c-format
msgid "The information about how a hard disk has been partitioned is stored in its first sector (that is, the first sector of the first track on the first disk surface). The first sector is the <glossterm>master boot record</glossterm> (MBR) of the disk; this is the sector that the BIOS reads in and starts when the machine is first booted. The master boot record contains a small program that reads the partition table, checks which partition is active (that is, marked bootable), and reads the first sector of that partition, the partition's <glossterm>boot sector</glossterm> (the MBR is also a boot sector, but it has a special status and therefore a special name). This boot sector contains another small program that reads the first part of the operating system stored on that partition (assuming it is bootable), and then starts it."
msgstr ""

#: index.docbook:2454
#, no-c-format
msgid "The partitioning scheme is not built into the hardware, or even into the BIOS. It is only a convention that many operating systems follow. Not all operating systems do follow it, but they are the exceptions. Some operating systems support partitions, but they occupy one partition on the hard disk, and use their internal partitioning method within that partition. The latter type exists peacefully with other operating systems (including Linux), and does not require any special measures, but an operating system that doesn't support partitions cannot co-exist on the same disk with any other operating system."
msgstr ""

#: index.docbook:2465
#, no-c-format
msgid "As a safety precaution, it is a good idea to write down the partition table on a piece of paper, so that if it ever corrupts you don't have to lose all your files. (A bad partition table can be fixed with <command>fdisk</command>). The relevant information is given by the <command>fdisk -l</command> command:"
msgstr ""

#: index.docbook:2465
#, no-c-format
msgid ""
      "<prompt>$</prompt> <userinput>fdisk -l /dev/hda</userinput>\n"
      "	<computeroutput></computeroutput>\n"
      "	<computeroutput>Disk /dev/hda: 15 heads, 57 sectors, 790 cylinders</computeroutput>\n"
      "	<computeroutput>Units = cylinders of 855 * 512 bytes</computeroutput>\n"
      "	<computeroutput></computeroutput>\n"
      "	<computeroutput>   Device Boot  Begin   Start     End  Blocks   Id  System</computeroutput>\n"
      "	<computeroutput>/dev/hda1           1       1      24   10231+  82  Linux swap</computeroutput>\n"
      "	<computeroutput>/dev/hda2          25      25      48   10260   83  Linux native</computeroutput>\n"
      "	<computeroutput>/dev/hda3          49      49     408  153900   83  Linux native</computeroutput>\n"
      "	<computeroutput>/dev/hda4         409     409     790  163305    5  Extended</computeroutput>\n"
      "	<computeroutput>/dev/hda5         409     409     744  143611+  83  Linux native</computeroutput>\n"
      "	<computeroutput>/dev/hda6         745     745     790   19636+  83  Linux native</computeroutput>\n"
      "	<prompt>$</prompt>"
msgstr ""

#: index.docbook:2490
#, no-c-format
msgid "Extended and logical partitions"
msgstr ""

#: index.docbook:2492
#, no-c-format
msgid "The original partitioning scheme for PC hard disks allowed only four partitions. This quickly turned out to be too little in real life, partly because some people want more than four operating systems (Linux, MS-DOS, OS/2, Minix, FreeBSD, NetBSD, or Windows/NT, to name a few), but primarily because sometimes it is a good idea to have several partitions for one operating system. For example, swap space is usually best put in its own partition for Linux instead of in the main Linux partition for reasons of speed (see below)."
msgstr ""

#: index.docbook:2501
#, no-c-format
msgid "To overcome this design problem, <glossterm>extended partitions</glossterm> were invented. This trick allows partitioning a <glossterm>primary partition</glossterm> into sub-partitions. The primary partition thus subdivided is the <glossterm>extended partition</glossterm>; the sub-partitions are <glossterm>logical partitions</glossterm>. They behave like primary partitions, but are created differently. There is no speed difference between them."
msgstr ""

#: index.docbook:2510
#, no-c-format
msgid "The partition structure of a hard disk might look like that in <xref linkend=\"hard-disk-layout\"/>. The disk is divided into three primary partitions, the second of which is divided into two logical partitions. Part of the disk is not partitioned at all. The disk as a whole and each primary partition has a boot sector."
msgstr ""

#: index.docbook:2517
#, no-c-format
msgid "A sample hard disk partitioning."
msgstr ""

#: index.docbook:2524
#, no-c-format
msgid "Partition types"
msgstr ""

#: index.docbook:2526
#, no-c-format
msgid "The partition tables (the one in the MBR, and the ones for extended partitions) contain one byte per partition that identifies the type of that partition. This attempts to identify the operating system that uses the partition, or what it uses it for. The purpose is to make it possible to avoid having two operating systems accidentally using the same partition. However, in reality, operating systems do not really care about the partition type byte; e.g., Linux doesn't care at all what it is. Worse, some of them use it incorrectly; e.g., at least some versions of DR-DOS ignore the most significant bit of the byte, while others don't."
msgstr ""

#: index.docbook:2537
#, no-c-format
msgid "There is no standardization agency to specify what each byte value means, but some commonly accepted ones are included in in <xref linkend=\"partition-ids\"/>. A more complete list is available in the Linux <command>fdisk</command> program."
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Partition types (from the Linux <command>fdisk</command> program)."
msgstr ""

#: index.docbook:2542 index.docbook:4945 index.docbook:6195
#, no-c-format
msgid "<entry>0</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Empty"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>40</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Venix 80286"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>94</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Amoeba BBT"
msgstr ""

#: index.docbook:2542 index.docbook:4945 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195
#, no-c-format
msgid "<entry>1</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "DOS 12-bit FAT"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>51</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Novell?"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>a5</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "BSD/386"
msgstr ""

#: index.docbook:2542 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195
#, no-c-format
msgid "<entry>2</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "XENIX root"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>52</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Microport"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>b7</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "BSDI fs"
msgstr ""

#: index.docbook:2542 index.docbook:6195 index.docbook:6195
#, no-c-format
msgid "<entry>3</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "XENIX usr"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>63</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "GNU HURD"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>b8</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "BSDI swap"
msgstr ""

#: index.docbook:2542 index.docbook:6195 index.docbook:6195
#, no-c-format
msgid "<entry>4</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "DOS 16-bit FAT &lt;32M"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>64</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Novell"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>c7</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Syrinx"
msgstr ""

#: index.docbook:2542 index.docbook:6195 index.docbook:6195
#, no-c-format
msgid "<entry>5</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Extended"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>75</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "PC/IX"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>db</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "CP/M"
msgstr ""

#: index.docbook:2542 index.docbook:4945 index.docbook:6195 index.docbook:6195
#, no-c-format
msgid "<entry>6</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "DOS 16-bit &gt;=32M"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>80</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Old MINIX"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>e1</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "DOS access"
msgstr ""

#: index.docbook:2542 index.docbook:6195 index.docbook:6195
#, no-c-format
msgid "<entry>7</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "OS/2 HPFS"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>81</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Linux/MINIX"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>e3</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "DOS R/O"
msgstr ""

#: index.docbook:2542 index.docbook:6195 index.docbook:6195
#, no-c-format
msgid "<entry>8</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>AIX</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>82</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Linux swap"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>f2</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "DOS secondary"
msgstr ""

#: index.docbook:2542 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195 index.docbook:6195
#, no-c-format
msgid "<entry>9</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "AIX bootable"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>83</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Linux native"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>ff</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>BBT</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>a</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "OS/2 Boot Manager"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "<entry>93</entry>"
msgstr ""

#: index.docbook:2542
#, no-c-format
msgid "Amoeba"
msgstr ""

#: index.docbook:2542 index.docbook:2542
#, no-c-format
msgid "<entry></entry>"
msgstr ""

#: index.docbook:2621
#, no-c-format
msgid "Partitioning a hard disk"
msgstr ""

#: index.docbook:2623
#, no-c-format
msgid "There are many programs for creating and removing partitions. Most operating systems have their own, and it can be a good idea to use each operating system's own, just in case it does something unusual that the others can't. Many of the programs are called <command>fdisk</command>, including the Linux one, or variations thereof. Details on using the Linux <command>fdisk</command> are given on its man page. The <command>cfdisk</command> command is similar to <command>fdisk</command>, but has a nicer (full screen) user interface."
msgstr ""

#: index.docbook:2634
#, no-c-format
msgid "When using IDE disks, the boot partition (the partition with the bootable kernel image files) must be completely within the first 1024 cylinders. This is because the disk is used via the BIOS during boot (before the system goes into protected mode), and BIOS can't handle more than 1024 cylinders. It is sometimes possible to use a boot partition that is only partly within the first 1024 cylinders. This works as long as all the files that are read with the BIOS are within the first 1024 cylinders. Since this is difficult to arrange, it is <emphasis>a very bad idea</emphasis> to do it; you never know when a kernel update or disk defragmentation will result in an unbootable system. Therefore, make sure your boot partition is completely within the first 1024 cylinders <footnote><para>This may no longer be true with newer versions of LILO that support LBA (Logical Block Addressing). Consult the documentation for your distribution to see if it has a version of LILO where LBA is supported.</para></footnote> ."
msgstr ""

#: index.docbook:2655
#, no-c-format
msgid "Some newer versions of the BIOS and IDE disks can, in fact, handle disks with more than 1024 cylinders. If you have such a system, you can forget about the problem; if you aren't quite sure of it, put it within the first 1024 cylinders."
msgstr ""

#: index.docbook:2660
#, no-c-format
msgid "Each partition should have an even number of sectors, since the Linux filesystems use a 1 kilobyte block size, i.e., two sectors. An odd number of sectors will result in the last sector being unused. This won't result in any problems, but it is ugly, and some versions of <command>fdisk</command> will warn about it."
msgstr ""

#: index.docbook:2666
#, no-c-format
msgid "Changing a partition's size usually requires first backing up everything you want to save from that partition (preferably the whole disk, just in case), deleting the partition, creating new partition, then restoring everything to the new partition. If the partition is growing, you may need to adjust the sizes (and backup and restore) of the adjoining partitions as well."
msgstr ""

#: index.docbook:2673
#, no-c-format
msgid "Since changing partition sizes is painful, it is preferable to get the partitions right the first time, or have an effective and easy to use backup system. If you're installing from a media that does not require much human intervention (say, from CD-ROM, as opposed to floppies), it is often easy to play with different configuration at first. Since you don't already have data to back up, it is not so painful to modify partition sizes several times."
msgstr ""

#: index.docbook:2681
#, no-c-format
msgid "There is a program for MS-DOS, called <command>fips</command> <footnote><para>The <command>fips</command> program is included in most Linux distributions. The commercial partition manager <quote>Partition Magic</quote> also has a similar facility but with a nicer interface. Please do remember that partitioning is dangerous. Make <emphasis>sure</emphasis> you have a recent backup of any important data before you try changing partition sizes <quote>on the fly</quote>. The GNU program <command>parted</command> can resize other types of partitions as well as MS-DOS, but sometimes in a limited manner. Consult the <command>parted</command> documentation before using it, better safe than sorry. </para></footnote> , which resizes an MS-DOS partition without requiring the backup and restore, but for other filesystems it is still necessary."
msgstr ""

#: index.docbook:2704
#, no-c-format
msgid "Device files and partitions"
msgstr ""

#: index.docbook:2706
#, no-c-format
msgid "Each partition and extended partition has its own device file. The naming convention for these files is that a partition's number is appended after the name of the whole disk, with the convention that 1-4 are primary partitions (regardless of how many primary partitions there are) and number greater than 5 are logical partitions (regardless of within which primary partition they reside). For example, <filename>/dev/hda1</filename> is the first primary partition on the first IDE hard disk, and <filename>/dev/sdb7</filename> is the third extended partition on the second SCSI hard disk."
msgstr ""

#: index.docbook:2722
#, no-c-format
msgid "Filesystems"
msgstr ""

#: index.docbook:2725
#, no-c-format
msgid "What are filesystems?"
msgstr ""

#: index.docbook:2727
#, no-c-format
msgid "A <glossterm>filesystem</glossterm> is the methods and data structures that an operating system uses to keep track of files on a disk or partition; that is, the way the files are organized on the disk. The word is also used to refer to a partition or disk that is used to store the files or the type of the filesystem. Thus, one might say <quote>I have two filesystems</quote> meaning one has two partitions on which one stores files, or that one is using the <quote>extended filesystem</quote>, meaning the type of the filesystem."
msgstr ""

#: index.docbook:2736
#, no-c-format
msgid "The difference between a disk or partition and the filesystem it contains is important. A few programs (including, reasonably enough, programs that create filesystems) operate directly on the raw sectors of a disk or partition; if there is an existing file system there it will be destroyed or seriously corrupted. Most programs operate on a filesystem, and therefore won't work on a partition that doesn't contain one (or that contains one of the wrong type)."
msgstr ""

#: index.docbook:2745
#, no-c-format
msgid "Before a partition or disk can be used as a filesystem, it needs to be initialized, and the bookkeeping data structures need to be written to the disk. This process is called <glossterm>making a filesystem</glossterm>."
msgstr ""

#: index.docbook:2750
#, no-c-format
msgid "Most UNIX filesystem types have a similar general structure, although the exact details vary quite a bit. The central concepts are <glossterm>superblock</glossterm>, <glossterm>inode</glossterm>, <glossterm>data block</glossterm>, <glossterm>directory block</glossterm>, and <glossterm>indirection block</glossterm>. The superblock contains information about the filesystem as a whole, such as its size (the exact information here depends on the filesystem). An inode contains all information about a file, except its name. The name is stored in the directory, together with the number of the inode. A directory entry consists of a filename and the number of the inode which represents the file. The inode contains the numbers of several data blocks, which are used to store the data in the file. There is space only for a few data block numbers in the inode, however, and if more are needed, more space for pointers to the data blocks is allocated dynamically. These dynamically allocated blocks are indirect blocks; the name indicates that in order to find the data block, one has to find its number in the indirect block first."
msgstr ""

#: index.docbook:2769
#, no-c-format
msgid "UNIX filesystems usually allow one to create a <glossterm>hole</glossterm> in a file (this is done with the <function>lseek()</function> system call; check the manual page), which means that the filesystem just pretends that at a particular place in the file there is just zero bytes, but no actual disk sectors are reserved for that place in the file (this means that the file will use a bit less disk space). This happens especially often for small binaries, Linux shared libraries, some databases, and a few other special cases. (Holes are implemented by storing a special value as the address of the data block in the indirect block or inode. This special address means that no data block is allocated for that part of the file, ergo, there is a hole in the file.)"
msgstr ""

#: index.docbook:2786
#, no-c-format
msgid "Filesystems galore"
msgstr ""

#: index.docbook:2788
#, no-c-format
msgid "Linux supports several types of filesystems. As of this writing the most important ones are: <glosslist> <glossentry> <glossterm>minix</glossterm> <glossdef><para>The oldest, presumed to be the most reliable, but quite limited in features (some time stamps are missing, at most 30 character filenames) and restricted in capabilities (at most 64 MB per filesystem). </para></glossdef></glossentry> <glossentry> <glossterm>xia</glossterm> <glossdef><para>A modified version of the minix filesystem that lifts the limits on the filenames and filesystem sizes, but does not otherwise introduce new features. It is not very popular, but is reported to work very well. </para></glossdef></glossentry> <glossentry> <glossterm>ext3</glossterm> <glossdef><para>The ext3 filesystem has all the features of the ext2 filesystem. The difference is, journaling has been added. This improves performance and recovery time in case of a system crash. This has become more popular than ext2. </para></glossdef></glossentry> <glossentry> <glossterm>ext2</glossterm> <glossdef><para>The most featureful of the native Linux filesystems. It is designed to be easily upwards compatible, so that new versions of the filesystem code do not require re-making the existing filesystems.</para></glossdef> </glossentry> <glossentry> <glossterm>ext</glossterm> <glossdef><para>An older version of ext2 that wasn't upwards compatible. It is hardly ever used in new installations any more, and most people have converted to ext2. </para></glossdef></glossentry> <glossentry> <glossterm>reiserfs</glossterm> <glossdef><para>A more robust filesystem. Journalling is used which makes data loss less likely. Journalling is a mechanism whereby a record is kept of transaction which are to be performed, or which have been performed. This allows the filesystem to reconstruct itself fairly easily after damage caused by, for example, improper shutdowns.</para></glossdef></glossentry> </glosslist>"
msgstr ""

#: index.docbook:2843
#, no-c-format
msgid "In addition, support for several foreign filesystems exists, to make it easier to exchange files with other operating systems. These foreign filesystems work just like native ones, except that they may be lacking in some usual UNIX features, or have curious limitations, or other oddities. <glosslist> <glossentry> <glossterm>msdos</glossterm> <glossdef><para>Compatibility with MS-DOS (and OS/2 and Windows NT) FAT filesystems.</para></glossdef></glossentry> <glossentry> <glossterm>umsdos</glossterm> <glossdef><para>Extends the msdos filesystem driver under Linux to get long filenames, owners, permissions, links, and device files. This allows a normal msdos filesystem to be used as if it were a Linux one, thus removing the need for a separate partition for Linux.</para></glossdef></glossentry> <glossentry> <glossterm>vfat</glossterm> <glossdef><para>This is an extension of the FAT filesystem known as FAT32. It supports larger disk sizes than FAT. Most MS Windows disks are vfat.</para></glossdef> </glossentry> <glossentry> <glossterm>iso9660</glossterm> <glossdef><para>The standard CD-ROM filesystem; the popular Rock Ridge extension to the CD-ROM standard that allows longer file names is supported automatically. </para></glossdef></glossentry> <glossentry> <glossterm>nfs</glossterm> <glossdef><para>A networked filesystem that allows sharing a filesystem between many computers to allow easy access to the files from all of them.</para></glossdef></glossentry> <glossentry> <glossterm>smbfs</glossterm> <glossdef><para>A networks filesystem which allows sharing of a filesystem with an MS Windows computer. It is compatible with the Windows file sharing protocols. </para></glossdef></glossentry> <glossentry> <glossterm>hpfs</glossterm> <glossdef><para>The OS/2 filesystem. </para></glossdef></glossentry> <glossentry> <glossterm>sysv</glossterm> <glossdef><para>SystemV/386, Coherent, and Xenix filesystems. </para></glossdef></glossentry> </glosslist>"
msgstr ""

#: index.docbook:2904
#, no-c-format
msgid "The choice of filesystem to use depends on the situation. If compatibility or other reasons make one of the non-native filesystems necessary, then that one must be used. If one can choose freely, then it is probably wisest to use ext3, since it has all the features of ext2, and is a journaled filesystem."
msgstr ""

#: index.docbook:2910
#, no-c-format
msgid ""
      "There is also the proc filesystem, usually accessible as the <filename>/proc</filename> directory, which is not really a filesystem at all, even though it looks like one. The proc filesystem makes it easy to access certain kernel data structures, such as the process list (hence the name). It makes these data structures look like a filesystem, and that filesystem can be manipulated with all the usual file tools. For example, to get a listing of all processes one might use the command <screen>\n"
      "<prompt>$</prompt> <userinput>ls -l /proc</userinput>\n"
      "<computeroutput>total 0\n"
      "dr-xr-xr-x   4 root     root            0 Jan 31 20:37 1\n"
      "dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 63\n"
      "dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 94\n"
      "dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 95\n"
      "dr-xr-xr-x   4 root     users           0 Jan 31 20:37 98\n"
      "dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 99\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 devices\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 dma\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 filesystems\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 interrupts\n"
      "-r--------   1 root     root      8654848 Jan 31 20:37 kcore\n"
      "-r--r--r--   1 root     root            0 Jan 31 11:50 kmsg\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 ksyms\n"
      "-r--r--r--   1 root     root            0 Jan 31 11:51 loadavg\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 meminfo\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 modules\n"
      "dr-xr-xr-x   2 root     root            0 Jan 31 20:37 net\n"
      "dr-xr-xr-x   4 root     root            0 Jan 31 20:37 self\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 stat\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 uptime\n"
      "-r--r--r--   1 root     root            0 Jan 31 20:37 \n"
      "version</computeroutput>\n"
      "<prompt>$</prompt>\n"
      "</screen> (There will be a few extra files that don't correspond to processes, though. The above example has been shortened.)"
msgstr ""

#: index.docbook:2950
#, no-c-format
msgid "Note that even though it is called a filesystem, no part of the proc filesystem touches any disk. It exists only in the kernel's imagination. Whenever anyone tries to look at any part of the proc filesystem, the kernel makes it look as if the part existed somewhere, even though it doesn't. So, even though there is a multi-megabyte <filename>/proc/kcore</filename> file, it doesn't take any disk space."
msgstr ""

#: index.docbook:2959
#, no-c-format
msgid "Which filesystem should be used?"
msgstr ""

#: index.docbook:2961
#, no-c-format
msgid "There is usually little point in using many different filesystems. Currently, ext3 is the most popular filesystem, because it is a journaled filesystem. Currently it is probably the wisest choice. Reiserfs is another popular choice because it to is journaled. Depending on the overhead for bookkeeping structures, speed, (perceived) reliability, compatibility, and various other reasons, it may be advisable to use another file system. This needs to be decided on a case-by-case basis."
msgstr ""

#: index.docbook:2970
#, no-c-format
msgid "A filesystem that uses journaling is also called a journaled filesystem. A journaled filesystem maintains a log, or journal, of what has happened on a filesystem. In the event of a system crash, or if your 2 year old son hits the power button like mine loves to do, a journaled filesystem is designed to use the filesystem's logs to recreate unsaved and lost data. This makes data loss much less likely and will likely become a standard feature in Linux filesystems. However, do not get a false sense of security from this. Like everything else, errors can arise. Always make sure to back up your data in the event of an emergency."
msgstr ""

#: index.docbook:2985
#, no-c-format
msgid "Creating a filesystem"
msgstr ""

#: index.docbook:2987
#, no-c-format
msgid "Filesystems are created, i.e., initialized, with the <command>mkfs</command> command. There is actually a separate program for each filesystem type. <command>mkfs</command> is just a front end that runs the appropriate program depending on the desired filesystem type. The type is selected with the <option>-t fstype</option> option."
msgstr ""

#: index.docbook:2994
#, no-c-format
msgid "The programs called by <command>mkfs</command> have slightly different command line interfaces. The common and most important options are summarized below; see the manual pages for more. <glosslist> <glossentry> <glossterm><option>-t fstype</option></glossterm> <glossdef><para> Select the type of the filesystem. </para></glossdef></glossentry> <glossentry> <glossterm><option>-c</option></glossterm> <glossdef><para> Search for bad blocks and initialize the bad block list accordingly. </para></glossdef></glossentry> <glossentry> <glossterm>-l filename</glossterm> <glossdef><para> Read the initial bad block list from the name file. </para></glossdef></glossentry> </glosslist>"
msgstr ""

#: index.docbook:3020
#, no-c-format
msgid ""
      "To create an ext2 filesystem on a floppy, one would give the following commands: <screen>\n"
      "<prompt>$</prompt> <userinput>fdformat -n /dev/fd0H1440</userinput>\n"
      "<computeroutput>Double-sided, 80 tracks, 18 sec/track. Total capacity \n"
      "1440 kB.\n"
      "Formatting ... done</computeroutput>\n"
      "<prompt>$</prompt> <userinput>badblocks /dev/fd0H1440 1440 $>$ \n"
      "bad-blocks</userinput>\n"
      "<prompt>$</prompt> <userinput>mkfs -t ext2 -l bad-blocks \n"
      "/dev/fd0H1440</userinput>\n"
      "<computeroutput>mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10\n"
      "360 inodes, 1440 blocks\n"
      "72 blocks (5.00%) reserved for the super user\n"
      "First data block=1\n"
      "Block size=1024 (log=0)\n"
      "Fragment size=1024 (log=0)\n"
      "1 block group\n"
      "8192 blocks per group, 8192 fragments per group\n"
      "360 inodes per group\n"
      "\n"
      "Writing inode tables: done\n"
      "Writing superblocks and filesystem accounting information: \n"
      "done</computeroutput>\n"
      "<prompt>$</prompt>\n"
      "</screen> First, the floppy was formatted (the <option>-n</option> option prevents validation, i.e., bad block checking). Then bad blocks were searched with <command>badblocks</command>, with the output redirected to a file, <filename>bad-blocks</filename>. Finally, the filesystem was created, with the bad block list initialized by whatever <command>badblocks</command> found."
msgstr ""

#: index.docbook:3055
#, no-c-format
msgid ""
      "The <option>-c</option> option could have been used with <command>mkfs</command> instead of <command>badblocks</command> and a separate file. The example below does that. <screen>\n"
      "<prompt>$</prompt> <userinput>mkfs -t ext2 -c \n"
      "/dev/fd0H1440</userinput>\n"
      "<computeroutput>mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10\n"
      "360 inodes, 1440 blocks\n"
      "72 blocks (5.00%) reserved for the super user\n"
      "First data block=1\n"
      "Block size=1024 (log=0)\n"
      "Fragment size=1024 (log=0)\n"
      "1 block group\n"
      "8192 blocks per group, 8192 fragments per group\n"
      "360 inodes per group\n"
      "\n"
      "Checking for bad blocks (read-only test): done\n"
      "Writing inode tables: done\n"
      "Writing superblocks and filesystem accounting information: \n"
      "done</computeroutput>\n"
      "<prompt>$</prompt>\n"
      "</screen> The <option>-c</option> option is more convenient than a separate use of <command>badblocks</command>, but <command>badblocks</command> is necessary for checking after the filesystem has been created."
msgstr ""

#: index.docbook:3084
#, no-c-format
msgid "The process to prepare filesystems on hard disks or partitions is the same as for floppies, except that the formatting isn't needed."
msgstr ""

#: index.docbook:3091
#, no-c-format
msgid "Mounting and unmounting"
msgstr ""

#: index.docbook:3093
#, no-c-format
msgid "Before one can use a filesystem, it has to be <glossterm>mounted</glossterm>. The operating system then does various bookkeeping things to make sure that everything works. Since all files in UNIX are in a single directory tree, the mount operation will make it look like the contents of the new filesystem are the contents of an existing subdirectory in some already mounted filesystem."
msgstr ""

#: index.docbook:3101
#, no-c-format
msgid "For example, <xref linkend=\"hd-mount-root\"/> shows three separate filesystems, each with their own root directory. When the last two filesystems are mounted below <filename>/home</filename> and <filename>/usr</filename>, respectively, on the first filesystem, we can get a single directory tree, as in <xref linkend=\"hd-mount-all\"/>."
msgstr ""

#: index.docbook:3109
#, no-c-format
msgid "Three separate filesystems."
msgstr ""

#: index.docbook:3114
#, no-c-format
msgid "<filename>/home</filename> and <filename>/usr</filename> have been mounted."
msgstr ""

#: index.docbook:3120
#, no-c-format
msgid ""
      "The mounts could be done as in the following example: <screen>\n"
      "<prompt>$</prompt> <userinput>mount /dev/hda2 /home</userinput>\n"
      "<prompt>$</prompt> <userinput>mount /dev/hda3 /usr</userinput>\n"
      "<prompt>$</prompt>\n"
      "</screen> The <command>mount</command> command takes two arguments. The first one is the device file corresponding to the disk or partition containing the filesystem. The second one is the directory below which it will be mounted. After these commands the contents of the two filesystems look just like the contents of the <filename>/home</filename> and <filename>/usr</filename> directories, respectively. One would then say that <quote><filename>/dev/hda2</filename> <glossterm>is mounted on</glossterm> <filename>/home</filename></quote>, and similarly for <filename>/usr</filename>. To look at either filesystem, one would look at the contents of the directory on which it has been mounted, just as if it were any other directory. Note the difference between the device file, <filename>/dev/hda2</filename>, and the mounted-on directory, <filename>/home</filename>. The device file gives access to the raw contents of the disk, the mounted-on directory gives access to the files on the disk. The mounted-on directory is called the <glossterm>mount point</glossterm>."
msgstr ""

#: index.docbook:3146
#, no-c-format
msgid "Linux supports many filesystem types. <command>mount</command> tries to guess the type of the filesystem. You can also use the <option>-t fstype</option> option to specify the type directly; this is sometimes necessary, since the heuristics <command>mount</command> uses do not always work. For example, to mount an MS-DOS floppy, you could use the following command:"
msgstr ""

#: index.docbook:3146
#, no-c-format
msgid ""
      "<prompt>$</prompt> <userinput>mount -t msdos /dev/fd0 \n"
      "	/floppy</userinput>\n"
      "	<prompt>$</prompt>"
msgstr ""

#: index.docbook:3161
#, no-c-format
msgid "The mounted-on directory need not be empty, although it must exist. Any files in it, however, will be inaccessible by name while the filesystem is mounted. (Any files that have already been opened will still be accessible. Files that have hard links from other directories can be accessed using those names.) There is no harm done with this, and it can even be useful. For instance, some people like to have <filename>/tmp</filename> and <filename>/var/tmp</filename> synonymous, and make <filename>/tmp</filename> be a symbolic link to <filename>/var/tmp</filename>. When the system is booted, before the <filename>/var</filename> filesystem is mounted, a <filename>/var/tmp</filename> directory residing on the root filesystem is used instead. When <filename>/var</filename> is mounted, it will make the <filename>/var/tmp</filename> directory on the root filesystem inaccessible. If <filename>/var/tmp</filename> didn't exist on the root filesystem, it would be impossible to use temporary files before mounting <filename>/var</filename>."
msgstr ""

#: index.docbook:3180
#, no-c-format
msgid "If you don't intend to write anything to the filesystem, use the <option>-r</option> switch for <command>mount</command> to do a <glossterm>read-only mount</glossterm>. This will make the kernel stop any attempts at writing to the filesystem, and will also stop the kernel from updating file access times in the inodes. Read-only mounts are necessary for unwritable media, e.g., CD-ROMs."
msgstr ""

#: index.docbook:3187
#, no-c-format
msgid "The alert reader has already noticed a slight logistical problem. How is the first filesystem (called the <glossterm>root filesystem</glossterm>, because it contains the root directory) mounted, since it obviously can't be mounted on another filesystem? Well, the answer is that it is done by magic. <footnote><para>For more information, see the kernel source or the Kernel Hackers' Guide.</para></footnote> The root filesystem is magically mounted at boot time, and one can rely on it to always be mounted. If the root filesystem can't be mounted, the system does not boot. The name of the filesystem that is magically mounted as root is either compiled into the kernel, or set using LILO or <command>rdev</command>."
msgstr ""

#: index.docbook:3203
#, no-c-format
msgid "The root filesystem is usually first mounted read-only. The startup scripts will then run <command>fsck</command> to verify its validity, and if there are no problems, they will <glossterm>re-mount</glossterm> it so that writes will also be allowed. <command>fsck</command> must not be run on a mounted filesystem, since any changes to the filesystem while <command>fsck</command> is running <emphasis>will</emphasis> cause trouble. Since the root filesystem is mounted read-only while it is being checked, <command>fsck</command> can fix any problems without worry, since the remount operation will flush any metadata that the filesystem keeps in memory."
msgstr ""

#: index.docbook:3215
#, no-c-format
msgid "On many systems there are other filesystems that should also be mounted automatically at boot time. These are specified in the <filename>/etc/fstab</filename> file; see the fstab man page for details on the format. The details of exactly when the extra filesystems are mounted depend on many factors, and can be configured by each administrator if need be; see <xref linkend=\"boots-and-shutdowns\"/>."
msgstr ""

#: index.docbook:3223
#, no-c-format
msgid "When a filesystem no longer needs to be mounted, it can be unmounted with <command>umount</command>. <footnote><para>It should of course be <command>unmount</command>, but the n mysteriously disappeared in the 70s, and hasn't been seen since. Please return it to Bell Labs, NJ, if you find it.</para></footnote> <command>umount</command> takes one argument: either the device file or the mount point. For example, to unmount the directories of the previous example, one could use the commands"
msgstr ""

#: index.docbook:3223
#, no-c-format
msgid ""
      "<prompt>$</prompt> <userinput>umount /dev/hda2</userinput>\n"
      "<prompt>$</prompt> <userinput>umount /usr</userinput>\n"
      "<prompt>$</prompt>"
msgstr ""

#: index.docbook:3243
#, no-c-format
msgid "See the man page for further instructions on how to use the command. It is imperative that you always unmount a mounted floppy. <emphasis>Don't just pop the floppy out of the drive!</emphasis> Because of disk caching, the data is not necessarily written to the floppy until you unmount it, so removing the floppy from the drive too early might cause the contents to become garbled. If you only read from the floppy, this is not very likely, but if you write, even accidentally, the result may be catastrophic."
msgstr ""

#: index.docbook:3253
#, no-c-format
msgid ""
      "Mounting and unmounting requires super user privileges, i.e., only root can do it. The reason for this is that if any user can mount a floppy on any directory, then it is rather easy to create a floppy with, say, a Trojan horse disguised as <filename>/bin/sh</filename>, or any other often used program. However, it is often necessary to allow users to use floppies, and there are several ways to do this: <itemizedlist> <listitem><para>Give the users the root password. This is obviously bad security, but is the easiest solution. It works well if there is no need for security anyway, which is the case on many non-networked, personal systems.</para></listitem> <listitem><para>Use a program such as <command>sudo</command> to allow users to use mount. This is still bad security, but doesn't directly give super user privileges to everyone. <footnote><para>It requires several seconds of hard thinking on the users' behalf. Furthermore <command>sudo</command> can be configured to only allow users to execute certain commands. See the sudo(8), sudoers(5), and visudo(8) manual pages. </para></footnote> </para></listitem> <listitem><para>Make the users use <command>mtools</command>, a package for manipulating MS-DOS filesystems, without mounting them. This works well if MS-DOS floppies are all that is needed, but is rather awkward otherwise. </para></listitem> <listitem><para>List the floppy devices and their allowable mount points together with the suitable options in <filename>/etc/fstab</filename>.</para></listitem> </itemizedlist> The last alternative can be implemented by adding a line like the following to the <filename>/etc/fstab</filename> file: <screen>\n"
      "	/dev/fd0            /floppy      msdos   user,noauto      0     0\n"
      "	</screen> The columns are: device file to mount, directory to mount on, filesystem type, options, backup frequency (used by <command>dump</command>), and <command>fsck</command> pass number (to specify the order in which filesystems should be checked upon boot; 0 means no check)."
msgstr ""

#: index.docbook:3306
#, no-c-format
msgid ""
      "The <option>noauto</option> option stops this mount to be done automatically when the system is started (i.e., it stops <command>mount -a</command> from mounting it). The <option>user</option> option allows any user to mount the filesystem, and, because of security reasons, disallows execution of programs (normal or setuid) and interpretation of device files from the mounted filesystem. After this, any user can mount a floppy with an msdos filesystem with the following command: <screen>\n"
      "	<prompt>$</prompt> <userinput>mount /floppy</userinput>\n"
      "	<prompt>$</prompt>\n"
      "	</screen> The floppy can (and needs to, of course) be unmounted with the corresponding <command>umount</command> command."
msgstr ""

#: index.docbook:3323
#, no-c-format
msgid ""
      "If you want to provide access to several types of floppies, you need to give several mount points. The settings can be different for each mount point. For example, to give access to both MS-DOS and ext2 floppies, you could have the following to lines in <filename>/etc/fstab</filename>: <screen>\n"
      "	/dev/fd0    /dosfloppy    msdos   user,noauto  0  0\n"
      "	/dev/fd0    /ext2floppy   ext2    user,noauto  0  0\n"
      "	</screen> For MS-DOS filesystems (not just floppies), you probably want to restrict access to it by using the <option>uid</option>, <option>gid</option>, and <option>umask</option> filesystem options, described in detail on the <command>mount</command> manual page. If you aren't careful, mounting an MS-DOS filesystem gives everyone at least read access to the files in it, which is not a good idea."
msgstr ""

#: index.docbook:3345
#, no-c-format
msgid "Checking filesystem integrity with <command>fsck</command>"
msgstr ""

#: index.docbook:3348
#, no-c-format
msgid "Filesystems are complex creatures, and as such, they tend to be somewhat error-prone. A filesystem's correctness and validity can be checked using the <command>fsck</command> command. It can be instructed to repair any minor problems it finds, and to alert the user if there any unrepairable problems. Fortunately, the code to implement filesystems is debugged quite effectively, so there are seldom any problems at all, and they are usually caused by power failures, failing hardware, or operator errors; for example, by not shutting down the system properly."
msgstr ""

#: index.docbook:3358
#, no-c-format
msgid "Most systems are setup to run <command>fsck</command> automatically at boot time, so that any errors are detected (and hopefully corrected) before the system is used. Use of a corrupted filesystem tends to make things worse: if the data structures are messed up, using the filesystem will probably mess them up even more, resulting in more data loss. However, <command>fsck</command> can take a while to run on big filesystems, and since errors almost never occur if the system has been shut down properly, a couple of tricks are used to avoid doing the checks in such cases. The first is that if the file <filename>/etc/fastboot</filename> exists, no checks are made. The second is that the ext2 filesystem has a special marker in its superblock that tells whether the filesystem was unmounted properly after the previous mount. This allows <command>e2fsck</command> (the version of <command>fsck</command> for the ext2 filesystem) to avoid checking the filesystem if the flag indicates that the unmount was done (the assumption being that a proper unmount indicates no problems). Whether the <filename>/etc/fastboot</filename> trick works on your system depends on your startup scripts, but the ext2 trick works every time you use <command>e2fsck</command>. It has to be explicitly bypassed with an option to <command>e2fsck</command> to be avoided. (See the <command>e2fsck</command> man page for details on how.)"
msgstr ""

#: index.docbook:3382
#, no-c-format
msgid "The automatic checking only works for the filesystems that are mounted automatically at boot time. Use <command>fsck</command> manually to check other filesystems, e.g., floppies."
msgstr ""

#: index.docbook:3387
#, no-c-format
msgid "If <command>fsck</command> finds unrepairable problems, you need either in-depth knowledge of how filesystems work in general, and the type of the corrupt filesystem in particular, or good backups. The latter is easy (although sometimes tedious) to arrange, the former can sometimes be arranged via a friend, the Linux newsgroups and mailing lists, or some other source of support, if you don't have the know-how yourself. I'd like to tell you more about it, but my lack of education and experience in this regard hinders me. The <command>debugfs</command> program by Theodore Ts'o should be useful."
msgstr ""

#: index.docbook:3398
#, no-c-format
msgid "<command>fsck</command> must only be run on unmounted filesystems, never on mounted filesystems (with the exception of the read-only root during startup). This is because it accesses the raw disk, and can therefore modify the filesystem without the operating system realizing it. There <emphasis>will</emphasis> be trouble, if the operating system is confused."
msgstr ""

#: index.docbook:3408
#, no-c-format
msgid "Checking for disk errors with <command>badblocks</command>"
msgstr ""

#: index.docbook:3410
#, no-c-format
msgid ""
      "It can be a good idea to periodically check for bad blocks. This is done with the <command>badblocks</command> command. It outputs a list of the numbers of all bad blocks it can find. This list can be fed to <command>fsck</command> to be recorded in the filesystem data structures so that the operating system won't try to use the bad blocks for storing data. The following example will show how this could be done. <screen>\n"
      "	<prompt>$</prompt> <userinput>badblocks /dev/fd0H1440 1440 &gt; \n"
      "	bad-blocks</userinput>\n"
      "	<prompt>$</prompt> <userinput>fsck -t ext2 -l bad-blocks \n"
      "	/dev/fd0H1440</userinput>\n"
      "	<computeroutput>Parallelizing fsck version 0.5a (5-Apr-94)\n"
      "	e2fsck 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10\n"
      "	Pass 1: Checking inodes, blocks, and sizes\n"
      "	Pass 2: Checking directory structure\n"
      "	Pass 3: Checking directory connectivity\n"
      "	Pass 4: Check reference counts.\n"
      "	Pass 5: Checking group summary information.\n"
      "	\n"
      "	/dev/fd0H1440: ***** FILE SYSTEM WAS MODIFIED *****\n"
      "	/dev/fd0H1440: 11/360 files, 63/1440 blocks</computeroutput>\n"
      "	<prompt>$</prompt>\n"
      "	</screen> If badblocks reports a block that was already used, <command>e2fsck</command> will try to move the block to another place. If the block was really bad, not just marginal, the contents of the file may be corrupted."
msgstr ""

#: index.docbook:3444
#, no-c-format
msgid "Fighting fragmentation"
msgstr ""

#: index.docbook:3446
#, no-c-format
msgid "When a file is written to disk, it can't always be written in consecutive blocks. A file that is not stored in consecutive blocks is <glossterm>fragmented</glossterm>. It takes longer to read a fragmented file, since the disk's read-write head will have to move more. It is desirable to avoid fragmentation, although it is less of a problem in a system with a good buffer cache with read-ahead."
msgstr ""

#: index.docbook:3454
#, no-c-format
msgid "The ext2 filesystem attempts to keep fragmentation at a minimum, by keeping all blocks in a file close together, even if they can't be stored in consecutive sectors. Ext2 effectively always allocates the free block that is nearest to other blocks in a file. For ext2, it is therefore seldom necessary to worry about fragmentation. There is a program for defragmenting an ext2 filesystem called, strangely enough, <command>defrag</command> <footnote><para> <ulink url=\"http://www.go.dlr.de/linux/src/defrag-0.73.tar.gz\"> http://www.go.dlr.de/linux/src/defrag-0.73.tar.gz</ulink> </para></footnote> ."
msgstr ""

#: index.docbook:3468
#, no-c-format
msgid "There are many MS-DOS defragmentation programs that move blocks around in the filesystem to remove fragmentation. For other filesystems, defragmentation must be done by backing up the filesystem, re-creating it, and restoring the files from backups. Backing up a filesystem before defragmenting is a good idea for all filesystems, since many things can go wrong during the defragmentation."
msgstr ""

#: index.docbook:3479
#, no-c-format
msgid "Other tools for all filesystems"
msgstr ""

#: index.docbook:3481
#, no-c-format
msgid "Some other tools are also useful for managing filesystems. <command>df</command> shows the free disk space on one or more filesystems; <command>du</command> shows how much disk space a directory and all its files contain. These can be used to hunt down disk space wasters. Both have manual pages which detail the (many) options which can be used."
msgstr ""

#: index.docbook:3488
#, no-c-format
msgid "<command>sync</command> forces all unwritten blocks in the buffer cache (see <xref linkend=\"buffer-cache\"/>) to be written to disk. It is seldom necessary to do this by hand; the daemon process <command>update</command> does this automatically. It can be useful in catastrophes, for example if <command>update</command> or its helper process <command>bdflush</command> dies, or if you must turn off power <emphasis>now</emphasis> and can't wait for <command>update</command> to run. Again, there are manual pages. The <command>man</command> is your very best friend in linux. Its cousin <command>apropos</command> is also very useful when you don't know what the name of the command you want is."
msgstr ""

#: index.docbook:3505
#, no-c-format
msgid "Other tools for the ext2/ext3 filesystem"
msgstr ""

#: index.docbook:3507
#, no-c-format
msgid "In addition to the filesystem creator (<command>mke2fs</command>) and checker (<command>e2fsck</command>) accessible directly or via the filesystem type independent front ends, the ext2 filesystem has some additional tools that can be useful."
msgstr ""

#: index.docbook:3513
#, no-c-format
msgid "<command>tune2fs</command> adjusts filesystem parameters. Some of the more interesting parameters are: <itemizedlist> <listitem><para> A maximal mount count. <command>e2fsck</command> enforces a check when filesystem has been mounted too many times, even if the clean flag is set. For a system that is used for developing or testing the system, it might be a good idea to reduce this limit. </para></listitem> <listitem><para> A maximal time between checks. <command>e2fsck</command> can also enforce a maximal time between two checks, even if the clean flag is set, and the filesystem hasn't been mounted very often. This can be disabled, however. </para></listitem> <listitem><para> Number of blocks reserved for root. Ext2 reserves some blocks for root so that if the filesystem fills up, it is still possible to do system administration without having to delete anything. The reserved amount is by default 5 percent, which on most disks isn't enough to be wasteful. However, for floppies there is no point in reserving any blocks. </para></listitem> </itemizedlist> See the <command>tune2fs</command> manual page for more information."
msgstr ""

#: index.docbook:3546
#, no-c-format
msgid "<command>dumpe2fs</command> shows information about an ext2 filesystem, mostly from the superblock. <xref linkend=\"dumpe2fs-output\"/> shows a sample output. Some of the information in the output is technical and requires understanding of how the filesystem works (see appendix XXX ext2fspaper), but much of it is readily understandable even for layadmins."
msgstr ""

#: index.docbook:3554
#, no-c-format
msgid "Sample output from <command>dumpe2fs</command>"
msgstr ""

#: index.docbook:3556
#, no-c-format
msgid ""
      "dumpe2fs 0.5b, 11-Mar-95 for EXT2 FS 0.5a, 94/10/23\n"
      "Filesystem magic number:  0xEF53\n"
      "Filesystem state:         clean\n"
      "Errors behavior:          Continue\n"
      "Inode count:              360\n"
      "Block count:              1440\n"
      "Reserved block count:     72\n"
      "Free blocks:              1133\n"
      "Free inodes:              326\n"
      "First block:              1\n"
      "Block size:               1024\n"
      "Fragment size:            1024\n"
      "Blocks per group:         8192\n"
      "Fragments per group:      8192\n"
      "Inodes per group:         360\n"
      "Last mount time:          Tue Aug  8 01:52:52 1995\n"
      "Last write time:          Tue Aug  8 01:53:28 1995\n"
      "Mount count:              3\n"
      "Maximum mount count:      20\n"
      "Last checked:             Tue Aug  8 01:06:31 1995\n"
      "Check interval:           0\n"
      "Reserved blocks uid:      0 (user root)\n"
      "Reserved blocks gid:      0 (group root)\n"
      "\n"
      "Group 0:\n"
      "  Block bitmap at 3, Inode bitmap at 4, Inode table at 5\n"
      "  1133 free blocks, 326 free inodes, 2 directories\n"
      "  Free blocks: 307-1439\n"
      "  Free inodes: 35-360"
msgstr ""

#: index.docbook:3589
#, no-c-format
msgid "<command>debugfs</command> is a filesystem debugger. It allows direct access to the filesystem data structures stored on disk and can thus be used to repair a disk that is so broken that <command>fsck</command> can't fix it automatically. It has also been known to be used to recover deleted files. However, <command>debugfs</command> very much requires that you understand what you're doing; a failure to understand can destroy all your data."
msgstr ""

#: index.docbook:3598
#, no-c-format
msgid "<command>dump</command> and <command>restore</command> can be used to back up an ext2 filesystem. They are ext2 specific versions of the traditional UNIX backup tools. See <xref linkend=\"backups\"/> for more information on backups."
msgstr ""

#: index.docbook:3608
#, no-c-format
msgid "Disks without filesystems"
msgstr ""

#: index.docbook:3610
#, no-c-format
msgid "Not all disks or partitions are used as filesystems. A swap partition, for example, will not have a filesystem on it. Many floppies are used in a tape-drive emulating fashion, so that a <command>tar</command> (tape archive) or other file is written directly on the raw disk, without a filesystem. Linux boot floppies don't contain a filesystem, only the raw kernel."
msgstr ""

#: index.docbook:3618
#, no-c-format
msgid "Avoiding a filesystem has the advantage of making more of the disk usable, since a filesystem always has some bookkeeping overhead. It also makes the disks more easily compatible with other systems: for example, the <command>tar</command> file format is the same on all systems, while filesystems are different on most systems. You will quickly get used to disks without filesystems if you need them. Bootable Linux floppies also do not necessarily have a filesystem, although they may."
msgstr ""

#: index.docbook:3627
#, no-c-format
msgid ""
      "One reason to use raw disks is to make image copies of them. For instance, if the disk contains a partially damaged filesystem, it is a good idea to make an exact copy of it before trying to fix it, since then you can start again if your fixing breaks things even more. One way to do this is to use <command>dd</command>: <screen>\n"
      "	<prompt>$</prompt> <userinput>dd if=/dev/fd0H1440 \n"
      "	of=floppy-image</userinput>\n"
      "	<computeroutput>2880+0 records in\n"
      "	2880+0 records out</computeroutput>\n"
      "	<prompt>$</prompt> <userinput>dd if=floppy-image \n"
      "	of=/dev/fd0H1440</userinput>\n"
      "	<computeroutput>2880+0 records in\n"
      "	2880+0 records out</computeroutput>\n"
      "	<prompt>$</prompt>\n"
      "	</screen> The first <command>dd</command> makes an exact image of the floppy to the file <filename>floppy-image</filename>, the second one writes the image to the floppy. (The user has presumably switched the floppy before the second command. Otherwise the command pair is of doubtful usefulness.)"
msgstr ""

#: index.docbook:3654
#, no-c-format
msgid "Allocating disk space"
msgstr ""

#: index.docbook:3657
#, no-c-format
msgid "Partitioning schemes"
msgstr ""

#: index.docbook:3659
#, no-c-format
msgid "It is not easy to partition a disk in the best possible way. Worse, there is no universally correct way to do it; there are too many factors involved."
msgstr ""

#: index.docbook:3663
#, no-c-format
msgid "The traditional way is to have a (relatively) small root filesystem, which contains <filename>/bin</filename>, <filename>/etc</filename>, <filename>/dev</filename>, <filename>/lib</filename>, <filename>/tmp</filename>, and other stuff that is needed to get the system up and running. This way, the root filesystem (in its own partition or on its own disk) is all that is needed to bring up the system. The reasoning is that if the root filesystem is small and is not heavily used, it is less likely to become corrupt when the system crashes, and you will therefore find it easier to fix any problems caused by the crash. Then you create separate partitions or use separate disks for the directory tree below <filename>/usr</filename>, the users' home directories (often under <filename>/home</filename>), and the swap space. Separating the home directories (with the users' files) in their own partition makes backups easier, since it is usually not necessary to backup programs (which reside below <filename>/usr</filename>). In a networked environment it is also possible to share <filename>/usr</filename> among several machines (e.g., by using NFS), thereby reducing the total disk space required by several tens or hundreds of megabytes times the number of machines."
msgstr ""

#: index.docbook:3685
#, no-c-format
msgid "The problem with having many partitions is that it splits the total amount of free disk space into many small pieces. Nowadays, when disks and (hopefully) operating systems are more reliable, many people prefer to have just one partition that holds all their files. On the other hand, it can be less painful to back up (and restore) a small partition."
msgstr ""

#: index.docbook:3704
#, no-c-format
msgid "For a small hard disk (assuming you don't do kernel development), the best way to go is probably to have just one partition. For large hard disks, it is probably better to have a few large partitions, just in case something does go wrong. (Note that `small' and `large' are used in a relative sense here; your needs for disk space decide what the threshold is.)"
msgstr ""

#: index.docbook:3712
#, no-c-format
msgid "If you have several disks, you might wish to have the root filesystem (including <filename>/usr</filename>) on one, and the users' home directories on another."
msgstr ""

#: index.docbook:3716
#, no-c-format
msgid "It is a good idea to be prepared to experiment a bit with different partitioning schemes (over time, not just while first installing the system). This is a bit of work, since it essentially requires you to install the system from scratch several times <footnote><para> This is not actually true, it is possible to move partitions and mountpoints without reinstalling, but it is (currently) beyond the scope of this book to explain how. It is on the TODO list to write a section on this. If you have experience and knowledge in this area then perhaps you could write it for me and save me the bother? :) </para></footnote> , but it is the only way to be sure you do it right."
msgstr ""

#: index.docbook:3734
#, no-c-format
msgid "Space requirements"
msgstr ""

#: index.docbook:3736
#, no-c-format
msgid "The Linux distribution you install will give some indication of how much disk space you need for various configurations. Programs installed separately may also do the same. This will help you plan your disk space usage, but you should prepare for the future and reserve some extra space for things you will notice later that you need."
msgstr ""

#: index.docbook:3743
#, no-c-format
msgid "The amount you need for user files depends on what your users wish to do. Most people seem to need as much space for their files as possible, but the amount they will live happily with varies a lot. Some people do only light text processing and will survive nicely with a few megabytes, others do heavy image processing and will need gigabytes."
msgstr ""

#: index.docbook:3750
#, no-c-format
msgid "By the way, when comparing file sizes given in kilobytes or megabytes and disk space given in megabytes, it can be important to know that the two units can be different. Some disk manufacturers like to pretend that a kilobyte is 1000 bytes and a megabyte is 1000 kilobytes, while all the rest of the computing world uses 1024 for both factors. Therefore, my 345 MB hard disk was really a 330 MB hard disk."
msgstr ""

#: index.docbook:3758
#, no-c-format
msgid "Swap space allocation is discussed in <xref linkend=\"swap-allocation\"/>."
msgstr ""

#: index.docbook:3764
#, no-c-format
msgid "Examples of hard disk allocation"
msgstr ""

#: index.docbook:3766
#, no-c-format
msgid "I used to have a 109 MB hard disk. Now I am using a 330 MB hard disk. I'll explain how and why I partitioned those disks."
msgstr ""

#: index.docbook:3770
#, no-c-format
msgid "The 109 MB disk I partitioned in a lot of ways, when my needs and the operating systems I used changed; I'll explain two typical scenarios. First, I used to run MS-DOS together with Linux. For that, I needed about 20 MB of hard disk, or just enough to have MS-DOS, a C compiler, an editor, a few other utilities, the program I was working on, and enough free disk space to not feel claustrophobic. For Linux, I had a 10 MB swap partition, and the rest, or 79 MB, was a single partition with all the files I had under Linux. I experimented with having separate root, <filename>/usr</filename>, and <filename>/home</filename> partitions, but there was never enough free disk space in one piece to do much interesting."
msgstr ""

#: index.docbook:3783
#, no-c-format
msgid "When I didn't need MS-DOS anymore, I repartitioned the disk so that I had a 12 MB swap partition, and again had the rest as a single filesystem."
msgstr ""

#: index.docbook:3787
#, no-c-format
msgid "The 330 MB disk is partitioned into several partitions, like this: <informaltable> <tgroup cols=\"2\"> <tbody> <row> <entry>5 MB</entry> <entry>root filesystem</entry> </row> <row> <entry> 10 MB</entry> <entry>swap partition</entry> </row> <row> <entry>180 MB</entry> <entry><filename>/usr</filename> filesystem</entry> </row> <row> <entry>120 MB</entry> <entry><filename>/home</filename> filesystem</entry> </row> <row> <entry> 15 MB</entry> <entry>scratch partition</entry> </row> </tbody> </tgroup> </informaltable> The scratch partition is for playing around with things that require their own partition, e.g., trying different Linux distributions, or comparing speeds of filesystems. When not needed for anything else, it is used as swap space (I like to have a lot of open windows)."
msgstr ""

#: index.docbook:3787
#, no-c-format
msgid "This section is somewhat out of date. Most people these days have disks that stretch into the multiple Gigabytes. It is still quite scalable (just multiply by some factor to make it fit your hardware) for the moment though, updating it to take account of larger disks is planned."
msgstr ""

#: index.docbook:3822
#, no-c-format
msgid "Adding more disk space for Linux"
msgstr ""

#: index.docbook:3824
#, no-c-format
msgid "Adding more disk space for Linux is easy, at least after the hardware has been properly installed (the hardware installation is outside the scope of this book). You format it if necessary, then create the partitions and filesystem as described above, and add the proper lines to <filename>/etc/fstab</filename> so that it is mounted automatically."
msgstr ""

#: index.docbook:3834
#, no-c-format
msgid "Tips for saving disk space"
msgstr ""

#: index.docbook:3836
#, no-c-format
msgid "The best tip for saving disk space is to avoid installing unnecessary programs. Most Linux distributions have an option to install only part of the packages they contain, and by analyzing your needs you might notice that you don't need most of them. This will help save a lot of disk space, since many programs are quite large. Even if you do need a particular package or program, you might not need all of it. For example, some on-line documentation might be unnecessary, as might some of the Elisp files for GNU Emacs, some of the fonts for X11, or some of the libraries for programming."
msgstr ""

#: index.docbook:3847
#, no-c-format
msgid "If you cannot uninstall packages, you might look into compression. Compression programs such as <command>gzip</command> or <command>zip</command> will compress (and uncompress) individual files or groups of files. The <command>gzexe</command> system will compress and uncompress programs invisibly to the user (unused programs are compressed, then uncompressed as they are used). The experimental DouBle system will compress all files in a filesystem, invisibly to the programs that use them. (If you are familiar with products such as Stacker for MS-DOS or DriveSpace for Windows, the principle is the same.)"
msgstr ""

#: index.docbook:3866
#, no-c-format
msgid "Memory Management"
msgstr ""

#: index.docbook:3868
#, no-c-format
msgid "<quote>Minnet, jag har tappat mitt minne, &auml;r jag svensk eller finne, kommer inte ih&aring;g...</quote> (Bosse &ouml;sterberg)"
msgstr ""

#: index.docbook:3872
#, no-c-format
msgid "A Swedish drinking song, (rough) translation: <quote>Memory, I have lost my memory. Am I Swedish or Finnish? I can't remember</quote>"
msgstr ""

#: index.docbook:3877
#, no-c-format
msgid "This section describes the Linux memory management features, i.e., virtual memory and the disk buffer cache. The purpose and workings and the things the system administrator needs to take into consideration are described."
msgstr ""

#: index.docbook:3883
#, no-c-format
msgid "What is virtual memory?"
msgstr ""

#: index.docbook:3885
#, no-c-format
msgid "Linux supports <glossterm>virtual memory</glossterm>, that is, using a disk as an extension of RAM so that the effective size of usable memory grows correspondingly. The kernel will write the contents of a currently unused block of memory to the hard disk so that the memory can be used for another purpose. When the original contents are needed again, they are read back into memory. This is all made completely transparent to the user; programs running under Linux only see the larger amount of memory available and don't notice that parts of them reside on the disk from time to time. Of course, reading and writing the hard disk is slower (on the order of a thousand times slower) than using real memory, so the programs don't run as fast. The part of the hard disk that is used as virtual memory is called the <glossterm>swap space</glossterm>."
msgstr ""

#: index.docbook:3900
#, no-c-format
msgid "Linux can use either a normal file in the filesystem or a separate partition for swap space. A swap partition is faster, but it is easier to change the size of a swap file (there's no need to repartition the whole hard disk, and possibly install everything from scratch). When you know how much swap space you need, you should go for a swap partition, but if you are uncertain, you can use a swap file first, use the system for a while so that you can get a feel for how much swap you need, and then make a swap partition when you're confident about its size."
msgstr ""

#: index.docbook:3911
#, no-c-format
msgid "You should also know that Linux allows one to use several swap partitions and/or swap files at the same time. This means that if you only occasionally need an unusual amount of swap space, you can set up an extra swap file at such times, instead of keeping the whole amount allocated all the time."
msgstr ""

#: index.docbook:3917
#, no-c-format
msgid "A note on operating system terminology: computer science usually distinguishes between swapping (writing the whole process out to swap space) and paging (writing only fixed size parts, usually a few kilobytes, at a time). Paging is usually more efficient, and that's what Linux does, but traditional Linux terminology talks about swapping anyway."
msgstr ""

#: index.docbook:3917
#, no-c-format
msgid "Thus quite needlessly annoying a number of computer scientists greatly."
msgstr ""

#: index.docbook:3932
#, no-c-format
msgid "Creating a swap space"
msgstr ""

#: index.docbook:3934
#, no-c-format
msgid "A swap file is an ordinary file; it is in no way special to the kernel. The only thing that matters to the kernel is that it has no holes, and that it is prepared for use with <command>mkswap</command>. It must reside on a local disk, however; it can't reside in a filesystem that has been mounted over NFS due to implementation reasons."
msgstr ""

#: index.docbook:3941
#, no-c-format
msgid "The bit about holes is important. The swap file reserves the disk space so that the kernel can quickly swap out a page without having to go through all the things that are necessary when allocating a disk sector to a file. The kernel merely uses any sectors that have already been allocated to the file. Because a hole in a file means that there are no disk sectors allocated (for that place in the file), it is not good for the kernel to try to use them."
msgstr ""

#: index.docbook:3950
#, no-c-format
msgid ""
      "One good way to create the swap file without holes is through the following command: <screen>\n"
      "	<prompt>$</prompt> <userinput>dd if=/dev/zero of=/extra-swap bs=1024 \n"
      "	count=1024</userinput>\n"
      "	<computeroutput>1024+0 records in\n"
      "	1024+0 records out</computeroutput>\n"
      "	<prompt>$</prompt>\n"
      "	</screen> where <filename>/extra-swap</filename> is the name of the swap file and the size of is given after the <literal>count=</literal>. It is best for the size to be a multiple of 4, because the kernel writes out <glossterm>memory pages</glossterm>, which are 4 kilobytes in size. If the size is not a multiple of 4, the last couple of kilobytes may be unused."
msgstr ""

#: index.docbook:3968
#, no-c-format
msgid "A swap partition is also not special in any way. You create it just like any other partition; the only difference is that it is used as a raw partition, that is, it will not contain any filesystem at all. It is a good idea to mark swap partitions as type 82 (Linux swap); this will the make partition listings clearer, even though it is not strictly necessary to the kernel."
msgstr ""

#: index.docbook:3976
#, no-c-format
msgid ""
      "After you have created a swap file or a swap partition, you need to write a signature to its beginning; this contains some administrative information and is used by the kernel. The command to do this is <command>mkswap</command>, used like this: <screen>\n"
      "	<prompt>$</prompt> <userinput>mkswap /extra-swap 1024</userinput>\n"
      "	<computeroutput>Setting up swapspace, size = 1044480 \n"
      "	bytes</computeroutput>\n"
      "	<prompt>$</prompt>\n"
      "	</screen> Note that the swap space is still not in use yet: it exists, but the kernel does not use it to provide virtual memory."
msgstr ""

#: index.docbook:3991
#, no-c-format
msgid "You should be very careful when using <command>mkswap</command>, since it does not check that the file or partition isn't used for anything else. <emphasis>You can easily overwrite important files and partitions with <command>mkswap</command>!</emphasis> Fortunately, you should only need to use <command>mkswap</command> when you install your system."
msgstr ""

#: index.docbook:3999
#, no-c-format
msgid "The Linux memory manager limits the size of each swap space to about 127 MB (for various technical reasons, the actual limit is (4096-10) * 8 * 4096 = 133890048$ bytes, or 127.6875 megabytes). You can, however, use up to 8 swap spaces simultaneously, for a total of almost 1 GB."
msgstr ""

#: index.docbook:3999
#, no-c-format
msgid "A gigabyte here, a gigabyte there, pretty soon we start talking about real memory."
msgstr ""

#: index.docbook:4009
#, no-c-format
msgid "This is actually no longer true, this section is slated for a rewrite Real Soon Now (tm). With newer kernels and versions of the <command>mkswap</command> command the actual limit depends on architecture. For i386 and compatibles it is 2Gigabytes, other architectures vary. Consult the mkswap(8) manual page for more details."
msgstr ""

#: index.docbook:4019
#, no-c-format
msgid "Using a swap space"
msgstr ""

#: index.docbook:4021
#, no-c-format
msgid ""
      "An initialized swap space is taken into use with <command>swapon</command>. This command tells the kernel that the swap space can be used. The path to the swap space is given as the argument, so to start swapping on a temporary swap file one might use the following command. <screen>\n"
      "<prompt>$</prompt> <userinput>swapon /extra-swap</userinput>\n"
      "<prompt>$</prompt>\n"
      "</screen> Swap spaces can be used automatically by listing them in the <filename>/etc/fstab</filename> file. <screen>\n"
      "/dev/hda8        none        swap        sw     0     0\n"
      "/swapfile        none        swap        sw     0     0\n"
      "</screen> The startup scripts will run the command <command>swapon -a</command>, which will start swapping on all the swap spaces listed in <command>/etc/fstab</command>. Therefore, the <command>swapon</command> command is usually used only when extra swap is needed."
msgstr ""

#: index.docbook:4046
#, no-c-format
msgid ""
      "You can monitor the use of swap spaces with <command>free</command>. It will tell the total amount of swap space used. <screen>\n"
      "<prompt>$</prompt> <userinput>free</userinput>\n"
      "<computeroutput>             total       used       free     shared   \n"
      " buffers\n"
      "Mem:         15152      14896        256      12404       2528\n"
      "-/+ buffers:            12368       2784\n"
      "Swap:        32452       6684      25768</computeroutput>\n"
      "<prompt>$</prompt>\n"
      "</screen> The first line of output (<literal>Mem:</literal>) shows the physical memory. The total column does not show the physical memory used by the kernel, which is usually about a megabyte. The used column shows the amount of memory used (the second line does not count buffers). The free column shows completely unused memory. The shared column shows the amount of memory shared by several processes; the more, the merrier. The buffers column shows the current size of the disk buffer cache."
msgstr ""

#: index.docbook:4069
#, no-c-format
msgid "That last line (<literal>Swap:</literal>) shows similar information for the swap spaces. If this line is all zeroes, your swap space is not activated."
msgstr ""

#: index.docbook:4073
#, no-c-format
msgid "The same information is available via <command>top</command>, or using the proc filesystem in file <filename>/proc/meminfo</filename>. It is currently difficult to get information on the use of a specific swap space."
msgstr ""

#: index.docbook:4078
#, no-c-format
msgid "A swap space can be removed from use with <command>swapoff</command>. It is usually not necessary to do it, except for temporary swap spaces. Any pages in use in the swap space are swapped in first; if there is not sufficient physical memory to hold them, they will then be swapped out (to some other swap space). If there is not enough virtual memory to hold all of the pages Linux will start to thrash; after a long while it should recover, but meanwhile the system is unusable. You should check (e.g., with <command>free</command>) that there is enough free memory before removing a swap space from use."
msgstr ""

#: index.docbook:4089
#, no-c-format
msgid "All the swap spaces that are used automatically with <command>swapon -a</command> can be removed from use with <command>swapoff -a</command>; it looks at the file <filename>/etc/fstab</filename> to find what to remove. Any manually used swap spaces will remain in use."
msgstr ""

#: index.docbook:4095
#, no-c-format
msgid "Sometimes a lot of swap space can be in use even though there is a lot of free physical memory. This can happen for instance if at one point there is need to swap, but later a big process that occupied much of the physical memory terminates and frees the memory. The swapped-out data is not automatically swapped in until it is needed, so the physical memory may remain free for a long time. There is no need to worry about this, but it can be comforting to know what is happening."
msgstr ""

#: index.docbook:4107
#, no-c-format
msgid "Sharing swap spaces with other operating systems"
msgstr ""

#: index.docbook:4109
#, no-c-format
msgid "Virtual memory is built into many operating systems. Since they each need it only when they are running, i.e., never at the same time, the swap spaces of all but the currently running one are being wasted. It would be more efficient for them to share a single swap space. This is possible, but can require a bit of hacking. The Tips-HOWTO contains some advice on how to implement this."
msgstr ""

#: index.docbook:4120
#, no-c-format
msgid "Allocating swap space"
msgstr ""

#: index.docbook:4122
#, no-c-format
msgid "Some people will tell you that you should allocate twice as much swap space as you have physical memory, but this is a bogus rule. Here's how to do it properly:"
msgstr ""

#: index.docbook:4122
#, no-c-format
msgid "Estimate your total memory needs. This is the largest amount of memory you'll probably need at a time, that is the sum of the memory requirements of all the programs you want to run at the same time. This can be done by running at the same time all the programs you are likely to ever be running at the same time."
msgstr ""

#: index.docbook:4122
#, no-c-format
msgid "For instance, if you want to run X, you should allocate about 8 MB for it, gcc wants several megabytes (some files need an unusually large amount, up to tens of megabytes, but usually about four should do), and so on. The kernel will use about a megabyte by itself, and the usual shells and other small utilities perhaps a few hundred kilobytes (say a megabyte together). There is no need to try to be exact, rough estimates are fine, but you might want to be on the pessimistic side."
msgstr ""

#: index.docbook:4122
#, no-c-format
msgid "Remember that if there are going to be several people using the system at the same time, they are all going to consume memory. However, if two people run the same program at the same time, the total memory consumption is usually not double, since code pages and shared libraries exist only once."
msgstr ""

#: index.docbook:4122
#, no-c-format
msgid "The <command>free</command> and <command>ps</command> commands are useful for estimating the memory needs."
msgstr ""

#: index.docbook:4122
#, no-c-format
msgid "Add some security to the estimate in step 1. This is because estimates of program sizes will probably be wrong, because you'll probably forget some programs you want to run, and to make certain that you have some extra space just in case. A couple of megabytes should be fine. (It is better to allocate too much than too little swap space, but there's no need to over-do it and allocate the whole disk, since unused swap space is wasted space; see later about adding more swap.) Also, since it is nicer to deal with even numbers, you can round the value up to the next full megabyte."
msgstr ""

#: index.docbook:4122
#, no-c-format
msgid "Based on the computations above, you know how much memory you'll be needing in total. So, in order to allocate swap space, you just need to subtract the size of your physical memory from the total memory needed, and you know how much swap space you need. (On some versions of UNIX, you need to allocate space for an image of the physical memory as well, so the amount computed in step 2 is what you need and you shouldn't do the subtraction.)"
msgstr ""

#: index.docbook:4122
#, no-c-format
msgid "If your calculated swap space is very much larger than your physical memory (more than a couple times larger), you should probably invest in more physical memory, otherwise performance will be too low."
msgstr ""

#: index.docbook:4197
#, no-c-format
msgid "It's a good idea to have at least some swap space, even if your calculations indicate that you need none. Linux uses swap space somewhat aggressively, so that as much physical memory as possible can be kept free. Linux will swap out memory pages that have not been used, even if the memory is not yet needed for anything. This avoids waiting for swapping when it is needed: the swapping can be done earlier, when the disk is otherwise idle."
msgstr ""

#: index.docbook:4206
#, no-c-format
msgid "Swap space can be divided among several disks. This can sometimes improve performance, depending on the relative speeds of the disks and the access patterns of the disks. You might want to experiment with a few schemes, but be aware that doing the experiments properly is quite difficult. You should not believe claims that any one scheme is superior to any other, since it won't always be true."
msgstr ""

#: index.docbook:4219
#, no-c-format
msgid "The buffer cache"
msgstr ""

#: index.docbook:4221
#, no-c-format
msgid "Reading from a disk <footnote><para>Except a RAM disk, for obvious reasons.</para></footnote> is very slow compared to accessing (real) memory. In addition, it is common to read the same part of a disk several times during relatively short periods of time. For example, one might first read an e-mail message, then read the letter into an editor when replying to it, then make the mail program read it again when copying it to a folder. Or, consider how often the command <command>ls</command> might be run on a system with many users. By reading the information from disk only once and then keeping it in memory until no longer needed, one can speed up all but the first read. This is called <glossterm>disk buffering</glossterm>, and the memory used for the purpose is called the <glossterm>buffer cache</glossterm>."
msgstr ""

#: index.docbook:4239
#, no-c-format
msgid "Since memory is, unfortunately, a finite, nay, scarce resource, the buffer cache usually cannot be big enough (it can't hold all the data one ever wants to use). When the cache fills up, the data that has been unused for the longest time is discarded and the memory thus freed is used for the new data."
msgstr ""

#: index.docbook:4246
#, no-c-format
msgid "Disk buffering works for writes as well. On the one hand, data that is written is often soon read again (e.g., a source code file is saved to a file, then read by the compiler), so putting data that is written in the cache is a good idea. On the other hand, by only putting the data into the cache, not writing it to disk at once, the program that writes runs quicker. The writes can then be done in the background, without slowing down the other programs."
msgstr ""

#: index.docbook:4255
#, no-c-format
msgid "Most operating systems have buffer caches (although they might be called something else), but not all of them work according to the above principles. Some are <glossterm>write-through</glossterm>: the data is written to disk at once (it is kept in the cache as well, of course). The cache is called <glossterm>write-back</glossterm> if the writes are done at a later time. Write-back is more efficient than write-through, but also a bit more prone to errors: if the machine crashes, or the power is cut at a bad moment, or the floppy is removed from the disk drive before the data in the cache waiting to be written gets written, the changes in the cache are usually lost. This might even mean that the filesystem (if there is one) is not in full working order, perhaps because the unwritten data held important changes to the bookkeeping information."
msgstr ""

#: index.docbook:4270
#, no-c-format
msgid "Because of this, you should never turn off the power without using a proper shutdown procedure (see <xref linkend=\"boots-and-shutdowns\"/>), or remove a floppy from the disk drive until it has been unmounted (if it was mounted) or after whatever program is using it has signaled that it is finished and the floppy drive light doesn't shine anymore. The <command>sync</command> command <glossterm>flushes</glossterm> the buffer, i.e., forces all unwritten data to be written to disk, and can be used when one wants to be sure that everything is safely written. In traditional UNIX systems, there is a program called <command>update</command> running in the background which does a <command>sync</command> every 30 seconds, so it is usually not necessary to use <command>sync</command>. Linux has an additional daemon, <command>bdflush</command>, which does a more imperfect sync more frequently to avoid the sudden freeze due to heavy disk I/O that <command>sync</command> sometimes causes."
msgstr ""

#: index.docbook:4288
#, no-c-format
msgid "Under Linux, <command>bdflush</command> is started by <command>update</command>. There is usually no reason to worry about it, but if <command>bdflush</command> happens to die for some reason, the kernel will warn about this, and you should start it by hand (<command>/sbin/update</command>)."
msgstr ""

#: index.docbook:4294
#, no-c-format
msgid "The cache does not actually buffer files, but blocks, which are the smallest units of disk I/O (under Linux, they are usually 1 kB). This way, also directories, super blocks, other filesystem bookkeeping data, and non-filesystem disks are cached."
msgstr ""

#: index.docbook:4299
#, no-c-format
msgid "The effectiveness of a cache is primarily decided by its size. A small cache is next to useless: it will hold so little data that all cached data is flushed from the cache before it is reused. The critical size depends on how much data is read and written, and how often the same data is accessed. The only way to know is to experiment."
msgstr ""

#: index.docbook:4306
#, no-c-format
msgid "If the cache is of a fixed size, it is not very good to have it too big, either, because that might make the free memory too small and cause swapping (which is also slow). To make the most efficient use of real memory, Linux automatically uses all free RAM for buffer cache, but also automatically makes the cache smaller when programs need more memory."
msgstr ""

#: index.docbook:4313
#, no-c-format
msgid "Under Linux, you do not need to do anything to make use of the cache, it happens completely automatically. Except for following the proper procedures for shutdown and removing floppies, you do not need to worry about it."
msgstr ""

#: index.docbook:4321
#, no-c-format
msgid "Boots And Shutdowns"
msgstr ""

#: index.docbook:4323
#, no-c-format
msgid ""
      "Start me up\n"
      "Ah... you've got to... you've got to\n"
      "Never, never never stop\n"
      "Start it up\n"
      "Ah... start it up, never, never, never\n"
      " You make a grown man cry,\n"
      "  you make a grown man cry\n"
      "(Rolling Stones)"
msgstr ""

#: index.docbook:4334
#, no-c-format
msgid "This section explains what goes on when a Linux system is brought up and taken down, and how it should be done properly. If proper procedures are not followed, files might be corrupted or lost."
msgstr ""

#: index.docbook:4340
#, no-c-format
msgid "An overview of boots and shutdowns"
msgstr ""

#: index.docbook:4342
#, no-c-format
msgid "The act of turning on a computer system and causing its operating system to be loaded <footnote><para>On early computers, it wasn't enough to merely turn on the computer, you had to manually load the operating system as well. These new-fangled thing-a-ma-jigs do it all by themselves.</para></footnote> is called <glossterm>booting</glossterm>. The name comes from an image of the computer pulling itself up from its bootstraps, but the act itself slightly more realistic."
msgstr ""

#: index.docbook:4354
#, no-c-format
msgid "During bootstrapping, the computer first loads a small piece of code called the <glossterm>bootstrap loader</glossterm>, which in turn loads and starts the operating system. The bootstrap loader is usually stored in a fixed location on a hard disk or a floppy. The reason for this two step process is that the operating system is big and complicated, but the first piece of code that the computer loads must be very small (a few hundred bytes), to avoid making the firmware unnecessarily complicated."
msgstr ""

#: index.docbook:4364
#, no-c-format
msgid "Different computers do the bootstrapping differently. For PCs, the computer (its BIOS) reads in the first sector (called the <glossterm>boot sector</glossterm>) of a floppy or hard disk. The bootstrap loader is contained within this sector. It loads the operating system from elsewhere on the disk (or from some other place)."
msgstr ""

#: index.docbook:4371
#, no-c-format
msgid "After Linux has been loaded, it initializes the hardware and device drivers, and then runs <command>init</command>. <command>init</command> starts other processes to allow users to log in, and do things. The details of this part will be discussed below."
msgstr ""

#: index.docbook:4377
#, no-c-format
msgid "In order to shut down a Linux system, first all processes are told to terminate (this makes them close any files and do other necessary things to keep things tidy), then filesystems and swap areas are unmounted, and finally a message is printed to the console that the power can be turned off. If the proper procedure is not followed, terrible things can and will happen; most importantly, the filesystem buffer cache might not be flushed, which means that all data in it is lost and the filesystem on disk is inconsistent, and therefore possibly unusable."
msgstr ""

#: index.docbook:4391
#, no-c-format
msgid "The boot process in closer look"
msgstr ""

#: index.docbook:4393
#, no-c-format
msgid "You can boot Linux either from a floppy or from the hard disk. The installation section in the Installation and Getting Started guide (XXX citation) tells you how to install Linux so you can boot it the way you want to."
msgstr ""

#: index.docbook:4399
#, no-c-format
msgid "When a PC is booted, the BIOS will do various tests to check that everything looks all right, <footnote><para>This is called the <glossterm>power on self test</glossterm>, or <glossterm>POST</glossterm> for short.</para></footnote> and will then start the actual booting. It will choose a disk drive (typically the first floppy drive, if there is a floppy inserted, otherwise the first hard disk, if one is installed in the computer; the order might be configurable, however) and will then read its very first sector. This is called the <glossterm>boot sector</glossterm>; for a hard disk, it is also called the <glossterm>master boot record</glossterm>, since a hard disk can contain several partitions, each with their own boot sectors."
msgstr ""

#: index.docbook:4416
#, no-c-format
msgid "The boot sector contains a small program (small enough to fit into one sector) whose responsibility is to read the actual operating system from the disk and start it. When booting Linux from a floppy disk, the boot sector contains code that just reads the first few hundred blocks (depending on the actual kernel size, of course) to a predetermined place in memory. On a Linux boot floppy, there is no filesystem, the kernel is just stored in consecutive sectors, since this simplifies the boot process. It is possible, however, to boot from a floppy with a filesystem, by using LILO, the LInux LOader."
msgstr ""

#: index.docbook:4427
#, no-c-format
msgid "When booting from the hard disk, the code in the master boot record will examine the partition table (also in the master boot record), identify the active partition (the partition that is marked to be bootable), read the boot sector from that partition, and then start the code in that boot sector. The code in the partition's boot sector does what a floppy disk's boot sector does: it will read in the kernel from the partition and start it. The details vary, however, since it is generally not useful to have a separate partition for just the kernel image, so the code in the partition's boot sector can't just read the disk in sequential order, it has to find the sectors wherever the filesystem has put them. There are several ways around this problem, but the most common way is to use LILO. (The details about how to do this are irrelevant for this discussion, however; see the LILO documentation for more information; it is most thorough.)"
msgstr ""

#: index.docbook:4444
#, no-c-format
msgid "When booting with LILO, it will normally go right ahead and read in and boot the default kernel. It is also possible to configure LILO to be able to boot one of several kernels, or even other operating systems than Linux, and it is possible for the user to choose which kernel or operating system is to be booted at boot time. LILO can be configured so that if one holds down the <keycap>alt</keycap>, <keycap>shift</keycap>, or <keycap>ctrl</keycap> key at boot time (when LILO is loaded), LILO will ask what is to be booted and not boot the default right away. Alternatively, LILO can be configured so that it will always ask, with an optional timeout that will cause the default kernel to be booted."
msgstr ""

#: index.docbook:4457
#, no-c-format
msgid "With LILO, it is also possible to give a <glossterm>kernel command line argument</glossterm>, after the name of the kernel or operating system."
msgstr ""

#: index.docbook:4461
#, no-c-format
msgid "Booting from floppy and from hard disk have both their advantages, but generally booting from the hard disk is nicer, since it avoids the hassle of playing around with floppies. It is also faster. However, it can be more troublesome to install the system to boot from the hard disk, so many people will first boot from floppy, then, when the system is otherwise installed and working well, will install LILO and start booting from the hard disk."
msgstr ""

#: index.docbook:4470
#, no-c-format
msgid "After the Linux kernel has been read into the memory, by whatever means, and is started for real, roughly the following things happen:"
msgstr ""

#: index.docbook:4470
#, no-c-format
msgid "The Linux kernel is installed compressed, so it will first uncompress itself. The beginning of the kernel image contains a small program that does this."
msgstr ""

#: index.docbook:4470
#, no-c-format
msgid "If you have a super-VGA card that Linux recognizes and that has some special text modes (such as 100 columns by 40 rows), Linux asks you which mode you want to use. During the kernel compilation, it is possible to preset a video mode, so that this is never asked. This can also be done with LILO or <command>rdev</command>."
msgstr ""

#: index.docbook:4470
#, no-c-format
msgid ""
      "After this, the kernel checks what other hardware there is (hard disks, floppies, network adapters, etc), and configures some of its device drivers appropriately; while it does this, it outputs messages about its findings. For example, when I boot, I it looks like this: <screen>\n"
      "<computeroutput>\n"
      "LILO boot:\n"
      "Loading linux.\n"
      "Console: colour EGA+ 80x25, 8 virtual consoles\n"
      "Serial driver version 3.94 with no serial options enabled\n"
      "tty00 at 0x03f8 (irq = 4) is a 16450\n"
      "tty01 at 0x02f8 (irq = 3) is a 16450\n"
      "lp_init: lp1 exists (0), using polling driver\n"
      "Memory: 7332k/8192k available (300k kernel code, 384k reserved, 176k \n"
      "data)\n"
      "Floppy drive(s): fd0 is 1.44M, fd1 is 1.2M\n"
      "Loopback device init\n"
      "Warning WD8013 board not found at i/o = 280.\n"
      "Math coprocessor using irq13 error reporting.\n"
      "Partition check:\n"
      "  hda: hda1 hda2 hda3\n"
      "VFS: Mounted root (ext filesystem).\n"
      "Linux version 0.99.pl9-1 (root@haven) 05/01/93 14:12:20\n"
      "</computeroutput>\n"
      "</screen> The exact texts are different on different systems, depending on the hardware, the version of Linux being used, and how it has been configured."
msgstr ""

#: index.docbook:4470
#, no-c-format
msgid "Then the kernel will try to mount the root filesystem. The place is configurable at compilation time, or any time with <command>rdev</command> or LILO. The filesystem type is detected automatically. If the mounting of the root filesystem fails, for example because you didn't remember to include the corresponding filesystem driver in the kernel, the kernel panics and halts the system (there isn't much it can do, anyway)."
msgstr ""

#: index.docbook:4470
#, no-c-format
msgid "The root filesystem is usually mounted read-only (this can be set in the same way as the place). This makes it possible to check the filesystem while it is mounted; it is not a good idea to check a filesystem that is mounted read-write."
msgstr ""

#: index.docbook:4470
#, no-c-format
msgid "After this, the kernel starts the program <command>init</command> (located in <filename>/sbin/init</filename>) in the background (this will always become process number 1). <command>init</command> does various startup chores. The exact things it does depends on how it is configured; see <xref linkend=\"init\"/> for more information (not yet written). It will at least start some essential background daemons."
msgstr ""

#: index.docbook:4470
#, no-c-format
msgid "<command>init</command> then switches to multi-user mode, and starts a <command>getty</command> for virtual consoles and serial lines. <command>getty</command> is the program which lets people log in via virtual consoles and serial terminals. <command>init</command> may also start some other programs, depending on how it is configured."
msgstr ""

#: index.docbook:4470
#, no-c-format
msgid "After this, the boot is complete, and the system is up and running normally."
msgstr ""

#: index.docbook:4565
#, no-c-format
msgid "More about shutdowns"
msgstr ""

#: index.docbook:4567
#, no-c-format
msgid "It is important to follow the correct procedures when you shut down a Linux system. If you fail do so, your filesystems probably will become trashed and the files probably will become scrambled. This is because Linux has a disk cache that won't write things to disk at once, but only at intervals. This greatly improves performance but also means that if you just turn off the power at a whim the cache may hold a lot of data and that what is on the disk may not be a fully working filesystem (because only some things have been written to the disk)."
msgstr ""

#: index.docbook:4577
#, no-c-format
msgid "Another reason against just flipping the power switch is that in a multi-tasking system there can be lots of things going on in the background, and shutting the power can be quite disastrous. By using the proper shutdown sequence, you ensure that all background processes can save their data."
msgstr ""

#: index.docbook:4583
#, no-c-format
msgid "The command for properly shutting down a Linux system is <command>shutdown</command>. It is usually used in one of two ways."
msgstr ""

#: index.docbook:4587
#, no-c-format
msgid "If you are running a system where you are the only user, the usual way of using <command>shutdown</command> is to quit all running programs, log out on all virtual consoles, log in as root on one of them (or stay logged in as root if you already are, but you should change to root's home directory or the root directory, to avoid problems with unmounting), then give the command <command>shutdown -h now</command> (substitute <literal>now</literal> with a plus sign and a number in minutes if you want a delay, though you usually don't on a single user system)."
msgstr ""

#: index.docbook:4598
#, no-c-format
msgid ""
      "Alternatively, if your system has many users, use the command <command>shutdown -h +time message</command>, where <literal>time</literal> is the time in minutes until the system is halted, and <literal>message</literal> is a short explanation of why the system is shutting down. <screen>\n"
      "<prompt>#</prompt> <userinput>shutdown -h +10 'We will install a new \n"
      "disk.  System should\n"
      "> be back on-line in three hours.'</userinput>\n"
      "<prompt>#</prompt>\n"
      "</screen> This will warn everybody that the system will shut down in ten minutes, and that they'd better get lost or lose data. The warning is printed to every terminal on which someone is logged in, including all <command>xterm</command>s: <screen>\n"
      "<computeroutput>\n"
      "Broadcast message from root (ttyp0) Wed Aug  2 01:03:25 1995...\n"
      "\n"
      "We will install a new disk.  System should\n"
      "be back on-line in three hours.\n"
      "The system is going DOWN for system halt in 10 minutes !!\n"
      "</computeroutput>\n"
      "</screen> The warning is automatically repeated a few times before the boot, with shorter and shorter intervals as the time runs out."
msgstr ""

#: index.docbook:4631
#, no-c-format
msgid "When the real shutting down starts after any delays, all filesystems (except the root one) are unmounted, user processes (if anybody is still logged in) are killed, daemons are shut down, all filesystem are unmounted, and generally everything settles down. When that is done, <command>init</command> prints out a message that you can power down the machine. Then, and only then, should you move your fingers towards the power switch."
msgstr ""

#: index.docbook:4639
#, no-c-format
msgid "Sometimes, although rarely on any good system, it is impossible to shut down properly. For instance, if the kernel panics and crashes and burns and generally misbehaves, it might be completely impossible to give any new commands, hence shutting down properly is somewhat difficult, and just about everything you can do is hope that nothing has been too severely damaged and turn off the power. If the troubles are a bit less severe (say, somebody hit your keyboard with an axe), and the kernel and the <command>update</command> program still run normally, it is probably a good idea to wait a couple of minutes to give <command>update</command> a chance to flush the buffer cache, and only cut the power after that."
msgstr ""

#: index.docbook:4652
#, no-c-format
msgid "Some people like to shut down using the command <command>sync</command> <footnote><para><command>sync</command> flushes the buffer cache. </para></footnote> three times, waiting for the disk I/O to stop, then turn off the power. If there are no running programs, this is about equivalent to using <command>shutdown</command>. However, it does not unmount any filesystems and this can lead to problems with the ext2fs <quote>clean filesystem</quote> flag. The triple-sync method is <emphasis>not recommended</emphasis>."
msgstr ""

#: index.docbook:4665
#, no-c-format
msgid "(In case you're wondering: the reason for three syncs is that in the early days of UNIX, when the commands were typed separately, that usually gave sufficient time for most disk I/O to be finished.)"
msgstr ""

#: index.docbook:4674
#, no-c-format
msgid "Rebooting"
msgstr ""

#: index.docbook:4676
#, no-c-format
msgid "Rebooting means booting the system again. This can be accomplished by first shutting it down completely, turning power off, and then turning it back on. A simpler way is to ask <command>shutdown</command> to reboot the system, instead of merely halting it. This is accomplished by using the <option>-r</option> option to <command>shutdown</command>, for example, by giving the command <command>shutdown -r now</command>."
msgstr ""

#: index.docbook:4685
#, no-c-format
msgid "Most Linux systems run <command>shutdown -r now</command> when ctrl-alt-del is pressed on the keyboard. This reboots the system. The action on ctrl-alt-del is configurable, however, and it might be better to allow for some delay before the reboot on a multiuser machine. Systems that are physically accessible to anyone might even be configured to do nothing when ctrl-alt-del is pressed."
msgstr ""

#: index.docbook:4696
#, no-c-format
msgid "Single user mode"
msgstr ""

#: index.docbook:4698
#, no-c-format
msgid "The <command>shutdown</command> command can also be used to bring the system down to single user mode, in which no one can log in, but root can use the console. This is useful for system administration tasks that can't be done while the system is running normally."
msgstr ""

#: index.docbook:4707
#, no-c-format
msgid "Emergency boot floppies"
msgstr ""

#: index.docbook:4709
#, no-c-format
msgid "It is not always possible to boot a computer from the hard disk. For example, if you make a mistake in configuring LILO, you might make your system unbootable. For these situations, you need an alternative way of booting that will always work (as long as the hardware works). For typical PCs, this means booting from the floppy drive."
msgstr ""

#: index.docbook:4717
#, no-c-format
msgid "Most Linux distributions allow one to create an <glossterm>emergency boot floppy</glossterm> during installation. It is a good idea to do this. However, some such boot disks contain only the kernel, and assume you will be using the programs on the distribution's installation disks to fix whatever problem you have. Sometimes those programs aren't enough; for example, you might have to restore some files from backups made with software not on the installation disks."
msgstr ""

#: index.docbook:4726
#, no-c-format
msgid "Thus, it might be necessary to create a custom root floppy as well. The <citetitle>Bootdisk HOWTO</citetitle> by Graham Chapman (XXX citation) contains instructions for doing this. You must, of course, remember to keep your emergency boot and root floppies up to date."
msgstr ""

#: index.docbook:4732
#, no-c-format
msgid "You can't use the floppy drive you use to mount the root floppy for anything else. This can be inconvenient if you only have one floppy drive. However, if you have enough memory, you can configure your boot floppy to load the root disk to a ramdisk (the boot floppy's kernel needs to be specially configured for this). Once the root floppy has been loaded into the ramdisk, the floppy drive is free to mount other disks."
msgstr ""

#: index.docbook:4745
#, no-c-format
msgid "<quote>Uuno on numero yksi</quote> (Slogan for a series of Finnish movies.)"
msgstr ""

#: index.docbook:4752
#, no-c-format
msgid "This chapter describes the <command>init</command> process, which is the first user level process started by the kernel. <command>init</command> has many important duties, such as starting <command>getty</command> (so that users can log in), implementing run levels, and taking care of orphaned processes. This chapter explains how <command>init</command> is configured and how you can make use of the different run levels."
msgstr ""

#: index.docbook:4761
#, no-c-format
msgid "<command>init</command> comes first"
msgstr ""

#: index.docbook:4763
#, no-c-format
msgid "<command>init</command> is one of those programs that are absolutely essential to the operation of a Linux system, but that you still can mostly ignore. A good Linux distribution will come with a configuration for <command>init</command> that will work for most systems, and on these systems there is nothing you need to do about <command>init</command>. Usually, you only need to worry about <command>init</command> if you hook up serial terminals, dial-in (not dial-out) modems, or if you want to change the default run level."
msgstr ""

#: index.docbook:4773
#, no-c-format
msgid "When the kernel has started itself (has been loaded into memory, has started running, and has initialized all device drivers and data structures and such), it finishes its own part of the boot process by starting a user level program, <command>init</command>. Thus, <command>init</command> is always the first process (its process number is always 1)."
msgstr ""

#: index.docbook:4780
#, no-c-format
msgid "The kernel looks for <command>init</command> in a few locations that have been historically used for it, but the proper location for it (on a Linux system) is <filename>/sbin/init</filename>. If the kernel can't find <command>init</command>, it tries to run <filename>/bin/sh</filename>, and if that also fails, the startup of the system fails."
msgstr ""

#: index.docbook:4788
#, no-c-format
msgid "When <command>init</command> starts, it finishes the boot process by doing a number of administrative tasks, such as checking filesystems, cleaning up <filename>/tmp</filename>, starting various services, and starting a <command>getty</command> for each terminal and virtual console where users should be able to log in (see <xref linkend=\"log-in-and-out\"/>)."
msgstr ""

#: index.docbook:4795
#, no-c-format
msgid "After the system is properly up, <command>init</command> restarts <command>getty</command> for each terminal after a user has logged out (so that the next user can log in). <command>init</command> also adopts orphan processes: when a process starts a child process and dies before its child, the child immediately becomes a child of <command>init</command>. This is important for various technical reasons, but it is good to know it, since it makes it easier to understand process lists and process tree graphs. <footnote><para><command>init</command> itself is not allowed to die. You can't kill <command>init</command> even with SIGKILL. </para></footnote> There are a few variants of <command>init</command> available. Most Linux distributions use <command>sysvinit</command> (written by Miquel van Smoorenburg), which is based on the System V <command>init</command> design. The BSD versions of Unix have a different <command>init</command>. The primary difference is run levels: System V has them, BSD does not (at least traditionally). This difference is not essential. We'll look at <command>sysvinit</command> only."
msgstr ""

#: index.docbook:4822
#, no-c-format
msgid "Configuring <command>init</command> to start <command>getty</command>: the <filename>/etc/inittab</filename> file"
msgstr ""

#: index.docbook:4826
#, no-c-format
msgid "When it starts up, <command>init</command> reads the <filename>/etc/inittab</filename> configuration file. While the system is running, it will re-read it, if sent the HUP signal; <footnote><para>Using the command <command>kill -HUP 1</command> as root, for example </para></footnote> this feature makes it unnecessary to boot the system to make changes to the <command>init</command> configuration take effect."
msgstr ""

#: index.docbook:4838
#, no-c-format
msgid ""
      "The <filename>/etc/inittab</filename> file is a bit complicated. We'll start with the simple case of configuring <command>getty</command> lines. Lines in <filename>/etc/inittab</filename> consist of four colon-delimited fields: <screen>\n"
      "id:runlevels:action:process\n"
      "</screen> The fields are described below. In addition, <filename>/etc/inittab</filename> can contain empty lines, and lines that begin with a number sign (`<literal>#</literal>'); these are both ignored. <glosslist> <glossentry><glossterm>id</glossterm> <glossdef><para> This identifies the line in the file. For <command>getty</command> lines, it specifies the terminal it runs on (the characters after <filename>/dev/tty</filename> in the device file name). For other lines, it doesn't matter (except for length restrictions), but it should be unique. </para></glossdef></glossentry> <glossentry><glossterm>runlevels</glossterm> <glossdef><para> The run levels the line should be considered for. The run levels are given as single digits, without delimiters. (Run levels are described in the next section.) </para></glossdef></glossentry> <glossentry><glossterm>action</glossterm> <glossdef><para> What action should be taken by the line, e.g., <literal>respawn</literal> to run the command in the next field again, when it exits, or <literal>once</literal> to run it just once. </para></glossdef></glossentry> <glossentry><glossterm>process</glossterm> <glossdef><para> The command to run. </para></glossdef></glossentry> </glosslist> To start a <command>getty</command> on the first virtual terminal (<filename>/dev/tty1</filename>), in all the normal multi-user run levels (2-5), one would write the following line: <screen>\n"
      "1:2345:respawn:/sbin/getty 9600 tty1\n"
      "</screen> The first field says that this is the line for <filename>/dev/tty1</filename>. The second field says that it applies to run levels 2, 3, 4, and 5. The third field means that the command should be run again, after it exits (so that one can log in, log out, and then log in again). The last field is the command that runs <command>getty</command> on the first virtual terminal."
msgstr ""

#: index.docbook:4838
#, no-c-format
msgid "Different versions of <command>getty</command> are run differently. Consult your manual page, and make sure it is the correct manual page."
msgstr ""

#: index.docbook:4909
#, no-c-format
msgid "If you wanted to add terminals or dial-in modem lines to a system, you'd add more lines to <filename>/etc/inittab</filename>, one for each terminal or dial-in line. For more details, see the manual pages <command>init</command>, <filename>inittab</filename>, and <command>getty</command>."
msgstr ""

#: index.docbook:4915
#, no-c-format
msgid "If a command fails when it starts, and <command>init</command> is configured to <literal>restart</literal> it, it will use a lot of system resources: <command>init</command> starts it, it fails, <command>init</command> starts it, it fails, <command>init</command> starts it, it fails, and so on, ad infinitum. To prevent this, <command>init</command> will keep track of how often it restarts a command, and if the frequency grows to high, it will delay for five minutes before restarting again."
msgstr ""

#: index.docbook:4929
#, no-c-format
msgid "Run levels"
msgstr ""

#: index.docbook:4931
#, no-c-format
msgid "A <glossterm>run level</glossterm> is a state of <command>init</command> and the whole system that defines what system services are operating. Run levels are identified by numbers, see <xref linkend=\"run-levels\"/>. There is no consensus of how to use the user defined run levels (2 through 5). Some system administrators use run levels to define which subsystems are working, e.g., whether X is running, whether the network is operational, and so on. Others have all subsystems always running or start and stop them individually, without changing run levels, since run levels are too coarse for controlling their systems. You need to decide for yourself, but it might be easiest to follow the way your Linux distribution does things."
msgstr ""

#: index.docbook:4945
#, no-c-format
msgid "Run level numbers"
msgstr ""

#: index.docbook:4945
#, no-c-format
msgid "Halt the system."
msgstr ""

#: index.docbook:4945
#, no-c-format
msgid "Single-user mode (for special administration)."
msgstr ""

#: index.docbook:4945
#, no-c-format
msgid "<entry>2-5</entry>"
msgstr ""

#: index.docbook:4945
#, no-c-format
msgid "Normal operation (user defined)."
msgstr ""

#: index.docbook:4945
#, no-c-format
msgid "Reboot."
msgstr ""

#: index.docbook:4959
#, no-c-format
msgid ""
      "Run levels are configured in <filename>/etc/inittab</filename> by lines like the following: <screen>\n"
      "l2:2:wait:/etc/init.d/rc 2\n"
      "</screen> The first field is an arbitrary label, the second one means that this applies for run level 2. The third field means that <command>init</command> should run the command in the fourth field once, when the run level is entered, and that <command>init</command> should wait for it to complete. The <filename>/etc/init.d/rc</filename> command runs whatever commands are necessary to start and stop services to enter run level 2."
msgstr ""

#: index.docbook:4976
#, no-c-format
msgid "The command in the fourth field does all the hard work of setting up a run level. It starts services that aren't already running, and stops services that shouldn't be running in the new run level any more. Exactly what the command is, and how run levels are configured, depends on the Linux distribution."
msgstr ""

#: index.docbook:4982
#, no-c-format
msgid ""
      "When <command>init</command> starts, it looks for a line in <filename>/etc/inittab</filename> that specifies the default run level: <screen>\n"
      "id:2:initdefault:\n"
      "</screen> You can ask <command>init</command> to go to a non-default run level at startup by giving the kernel a command line argument of <literal>single</literal> or <literal>emergency</literal>. Kernel command line arguments can be given via LILO, for example. This allows you to choose the single user mode (run level 1)."
msgstr ""

#: index.docbook:4996
#, no-c-format
msgid "While the system is running, the <command>telinit</command> command can change the run level. When the run level is changed, <command>init</command> runs the relevant command from <filename>/etc/inittab</filename>."
msgstr ""

#: index.docbook:5004
#, no-c-format
msgid "Special configuration in <filename>/etc/inittab</filename>"
msgstr ""

#: index.docbook:5007
#, no-c-format
msgid "The <filename>/etc/inittab</filename> has some special features that allow <command>init</command> to react to special circumstances. These special features are marked by special keywords in the third field. Some examples: <glosslist> <glossentry><glossterm><literal>powerwait</literal></glossterm> <glossdef><para> Allows <command>init</command> to shut the system down, when the power fails. This assumes the use of a UPS, and software that watches the UPS and informs <command>init</command> that the power is off. </para></glossdef></glossentry> <glossentry><glossterm><literal>ctrlaltdel</literal></glossterm> <glossdef><para> Allows <command>init</command> to reboot the system, when the user presses ctrl-alt-del on the console keyboard. Note that the system administrator can configure the reaction to ctrl-alt-del to be something else instead, e.g., to be ignored, if the system is in a public location. (Or to start <command>nethack</command>.) </para></glossdef></glossentry> <glossentry><glossterm><literal>sysinit</literal></glossterm> <glossdef><para> Command to be run when the system is booted. This command usually cleans up <filename>/tmp</filename>, for example. </para></glossdef></glossentry> </glosslist> The list above is not exhaustive. See your <filename>inittab</filename> manual page for all possibilities, and for details on how to use the above ones."
msgstr ""

#: index.docbook:5047
#, no-c-format
msgid "Booting in single user mode"
msgstr ""

#: index.docbook:5049
#, no-c-format
msgid "An important run level is <glossterm>single user mode</glossterm> (run level 1), in which only the system administrator is using the machine and as few system services, including logins, as possible are running. Single user mode is necessary for a few administrative tasks, <footnote><para>It probably shouldn't be used for playing <command>nethack</command>.</para></footnote> such as running <command>fsck</command> on a <filename>/usr</filename> partition, since this requires that the partition be unmounted, and that can't happen, unless just about all system services are killed."
msgstr ""

#: index.docbook:5064
#, no-c-format
msgid "A running system can be taken to single user mode by using <command>telinit</command> to request run level 1. At bootup, it can be entered by giving the word <literal>single</literal> or <literal>emergency</literal> on the kernel command line: the kernel gives the command line to <command>init</command> as well, and <command>init</command> understands from that word that it shouldn't use the default run level. (The kernel command line is entered in a way that depends on how you boot the system.)"
msgstr ""

#: index.docbook:5073
#, no-c-format
msgid "Booting into single user mode is sometimes necessary so that one can run <command>fsck</command> by hand, before anything mounts or otherwise touches a broken <filename>/usr</filename> partition (any activity on a broken filesystem is likely to break it more, so <command>fsck</command> should be run as soon as possible)."
msgstr ""

#: index.docbook:5080
#, no-c-format
msgid "The bootup scripts <command>init</command> runs will automatically enter single user mode, if the automatic <command>fsck</command> at bootup fails. This is an attempt to prevent the system from using a filesystem that is so broken that <command>fsck</command> can't fix it automatically. Such breakage is relatively rare, and usually involves a broken hard disk or an experimental kernel release, but it's good to be prepared."
msgstr ""

#: index.docbook:5088
#, no-c-format
msgid "As a security measure, a properly configured system will ask for the root password before starting the shell in single user mode. Otherwise, it would be simple to just enter a suitable line to LILO to get in as root. (This will break if <filename>/etc/passwd</filename> has been broken by filesystem problems, of course, and in that case you'd better have a boot floppy handy.)"
msgstr ""

#: index.docbook:5099
#, no-c-format
msgid "Logging In And Out"
msgstr ""

#: index.docbook:5101
#, no-c-format
msgid "<quote>I don't care to belong to a club that accepts people like me as a member.</quote> (Groucho Marx)"
msgstr ""

#: index.docbook:5105
#, no-c-format
msgid "This section describes what happens when a user logs in or out. The various interactions of background processes, log files, configuration files, and so on are described in some detail."
msgstr ""

#: index.docbook:5113
#, no-c-format
msgid "Logins via terminals"
msgstr ""

#: index.docbook:5115
#, no-c-format
msgid "shows how logins happen via terminals. First, <command>init</command> makes sure there is a <command>getty</command> program for the terminal connection (or console). <command>getty</command> listens at the terminal and waits for the user to notify that he is ready to login in (this usually means that the user must type something). When it notices a user, <command>getty</command> outputs a welcome message (stored in <filename>/etc/issue</filename>), and prompts for the username, and finally runs the <command>login</command> program. <command>login</command> gets the username as a parameter, and prompts the user for the password. If these match, <command>login</command> starts the shell configured for the user; else it just exits and terminates the process (perhaps after giving the user another chance at entering the username and password). <command>init</command> notices that the process terminated, and starts a new <command>getty</command> for the terminal."
msgstr ""

#: index.docbook:5135
#, no-c-format
msgid "Logins via terminals: the interaction of <command>init</command>, <command>getty</command>, <command>login</command>, and the shell."
msgstr ""

#: index.docbook:5142
#, no-c-format
msgid "Note that the only new process is the one created by <command>init</command> (using the <function>fork</function> system call); <command>getty</command> and <command>login</command> only replace the program running in the process (using the <function>exec</function> system call)."
msgstr ""

#: index.docbook:5149
#, no-c-format
msgid "A separate program, for noticing the user, is needed for serial lines, since it can be (and traditionally was) complicated to notice when a terminal becomes active. <command>getty</command> also adapts to the speed and other settings of the connection, which is important especially for dial-in connections, where these parameters may change from call to call."
msgstr ""

#: index.docbook:5157
#, no-c-format
msgid "There are several versions of <command>getty</command> and <command>init</command> in use, all with their good and bad points. It is a good idea to learn about the versions on your system, and also about the other versions (you could use the Linux Software Map to search them). If you don't have dial-ins, you probably don't have to worry about <command>getty</command>, but <command>init</command> is still important."
msgstr ""

#: index.docbook:5168
#, no-c-format
msgid "Logins via the network"
msgstr ""

#: index.docbook:5170
#, no-c-format
msgid "Two computers in the same network are usually linked via a single physical cable. When they communicate over the network, the programs in each computer that take part in the communication are linked via a <glossterm>virtual connection</glossterm>, a sort of imaginary cable. As far as the programs at either end of the virtual connection are concerned, they have a monopoly on their own cable. However, since the cable is not real, only imaginary, the operating systems of both computers can have several virtual connections share the same physical cable. This way, using just a single cable, several programs can communicate without having to know of or care about the other communications. It is even possible to have several computers use the same cable; the virtual connections exist between two computers, and the other computers ignore those connections that they don't take part in."
msgstr ""

#: index.docbook:5185
#, no-c-format
msgid "That's a complicated and over-abstracted description of the reality. It might, however, be good enough to understand the important reason why network logins are somewhat different from normal logins. The virtual connections are established when there are two programs on different computers that wish to communicate. Since it is in principle possible to login from any computer in a network to any other computer, there is a huge number of potential virtual communications. Because of this, it is not practical to start a <command>getty</command> for each potential login."
msgstr ""

#: index.docbook:5196
#, no-c-format
msgid "There is a single process inetd (corresponding to <command>getty</command>) that handles all network logins. When it notices an incoming network login (i.e., it notices that it gets a new virtual connection to some other computer), it starts a new process to handle that single login. The original process remains and continues to listen for new logins."
msgstr ""

#: index.docbook:5203
#, no-c-format
msgid "To make things a bit more complicated, there is more than one communication protocol for network logins. The two most important ones are <command>telnet</command> and <command>rlogin</command>. In addition to logins, there are many other virtual connections that may be made (for FTP, Gopher, HTTP, and other network services). It would be ineffective to have a separate process listening for a particular type of connection, so instead there is only one listener that can recognize the type of the connection and can start the correct type of program to provide the service. This single listener is called <command>inetd</command>; see the <citetitle>Linux Network Administrators' Guide</citetitle> for more information."
msgstr ""

#: index.docbook:5220
#, no-c-format
msgid "What <command>login</command> does"
msgstr ""

#: index.docbook:5222
#, no-c-format
msgid "The <command>login</command> program takes care of authenticating the user (making sure that the username and password match), and of setting up an initial environment for the user by setting permissions for the serial line and starting the shell."
msgstr ""

#: index.docbook:5228
#, no-c-format
msgid "Part of the initial setup is outputting the contents of the file <filename>/etc/motd</filename> (short for message of the day) and checking for electronic mail. These can be disabled by creating a file called <filename>.hushlogin</filename> in the user's home directory."
msgstr ""

#: index.docbook:5234
#, no-c-format
msgid "If the file <filename>/etc/nologin</filename> exists, logins are disabled. That file is typically created by <command>shutdown</command> and relatives. <command>login</command> checks for this file, and will refuse to accept a login if it exists. If it does exist, <command>login</command> outputs its contents to the terminal before it quits."
msgstr ""

#: index.docbook:5242
#, no-c-format
msgid "<command>login</command> logs all failed login attempts in a system log file (via <command>syslog</command>). It also logs all logins by root. Both of these can be useful when tracking down intruders."
msgstr ""

#: index.docbook:5247
#, no-c-format
msgid "Currently logged in people are listed in <filename>/var/run/utmp</filename>. This file is valid only until the system is next rebooted or shut down; it is cleared when the system is booted. It lists each user and the terminal (or network connection) he is using, along with some other useful information. The <command>who</command>, <command>w</command>, and other similar commands look in <filename>utmp</filename> to see who are logged in."
msgstr ""

#: index.docbook:5256
#, no-c-format
msgid "All successful logins are recorded into <filename>/var/log/wtmp</filename>. This file will grow without limit, so it must be cleaned regularly, for example by having a weekly <command>cron</command> job to clear it. <footnote><para>Good Linux distributions do this out of the box.</para></footnote> The <command>last</command> command browses <filename>wtmp</filename>."
msgstr ""

#: index.docbook:5267
#, no-c-format
msgid "Both <filename>utmp</filename> and <filename>wtmp</filename> are in a binary format (see the <filename>utmp</filename> manual page); it is unfortunately not convenient to examine them without special programs."
msgstr ""

#: index.docbook:5275
#, no-c-format
msgid "X and xdm"
msgstr ""

#: index.docbook:5277
#, no-c-format
msgid "XXX X implements logins via xdm; also: xterm -ls"
msgstr ""

#: index.docbook:5282
#, no-c-format
msgid "Access control"
msgstr ""

#: index.docbook:5284
#, no-c-format
msgid "The user database is traditionally contained in the <filename>/etc/passwd</filename> file. Some systems use <glossterm>shadow passwords</glossterm>, and have moved the passwords to <command>/etc/shadow</command>. Sites with many computers that share the accounts use NIS or some other method to store the user database; they might also automatically copy the database from one central location to all other computers."
msgstr ""

#: index.docbook:5293
#, no-c-format
msgid "The user database contains not only the passwords, but also some additional information about the users, such as their real names, home directories, and login shells. This other information needs to be public, so that anyone can read it. Therefore the password is stored encrypted. This does have the drawback that anyone with access to the encrypted password can use various cryptographic methods to guess it, without trying to actually log into the computer. Shadow passwords try to avoid this by moving the password into another file, which only root can read (the password is still stored encrypted). However, installing shadow passwords later onto a system that did not support them can be difficult."
msgstr ""

#: index.docbook:5306
#, no-c-format
msgid "With or without passwords, it is important to make sure that all passwords in a system are good, i.e., not easily guessed. The <command>crack</command> program can be used to crack passwords; any password it can find is by definition not a good one. While <command>crack</command> can be run by intruders, it can also be run by the system administrator to avoid bad passwords. Good passwords can also be enforced by the <command>passwd</command> program; this is in fact more effective in CPU cycles, since cracking passwords requires quite a lot of computation."
msgstr ""

#: index.docbook:5317
#, no-c-format
msgid "The user group database is kept in <filename>/etc/group</filename>; for systems with shadow passwords, there can be a <filename>/etc/shadow.group</filename>."
msgstr ""

#: index.docbook:5322
#, no-c-format
msgid "root usually can't login via most terminals or the network, only via terminals listed in the <filename>/etc/securetty</filename> file. This makes it necessary to get physical access to one of these terminals. It is, however, possible to log in via any terminal as any other user, and use the <command>su</command> command to become root."
msgstr ""

#: index.docbook:5332
#, no-c-format
msgid "Shell startup"
msgstr ""

#: index.docbook:5334
#, no-c-format
msgid "When an interactive login shell starts, it automatically executes one or more pre-defined files. Different shells execute different files; see the documentation of each shell for further information."
msgstr ""

#: index.docbook:5339
#, no-c-format
msgid "Most shells first run some global file, for example, the Bourne shell (<command>/bin/sh</command>) and its derivatives execute <filename>/etc/profile</filename>; in addition, they execute <filename>.profile</filename> in the user's home directory. <filename>/etc/profile</filename> allows the system administrator to have set up a common user environment, especially by setting the <envar>PATH</envar> to include local command directories in addition to the normal ones. On the other hand, <filename>.profile</filename> allows the user to customize the environment to his own tastes by overriding, if necessary, the default environment."
msgstr ""

#: index.docbook:5355
#, no-c-format
msgid "Managing user accounts"
msgstr ""

#: index.docbook:5357
#, no-c-format
msgid "<quote>The similarities of sysadmins and drug dealers: both measure stuff in Ks, and both have users.</quote> (Old, tired computer joke.)"
msgstr ""

#: index.docbook:5361
#, no-c-format
msgid "This chapter explains how to create new user accounts, how to modify the properties of those accounts, and how to remove the accounts. Different Linux systems have different tools for doing this."
msgstr ""

#: index.docbook:5367
#, no-c-format
msgid "What's an account?"
msgstr ""

#: index.docbook:5369
#, no-c-format
msgid "When a computer is used by many people it is usually necessary to differentiate between the users, for example, so that their private files can be kept private. This is important even if the computer can only be used by a single person at a time, as with most microcomputers. <footnote><para>It might be quite embarrassing if my sister could read my love letters.</para></footnote> Thus, each user is given a unique username, and that name is used to log in."
msgstr ""

#: index.docbook:5381
#, no-c-format
msgid "There's more to a user than just a name, however. An <glossterm>account</glossterm> is all the files, resources, and information belonging to one user. The term hints at banks, and in a commercial system each account usually has some money attached to it, and that money vanishes at different speeds depending on how much the user stresses the system. For example, disk space might have a price per megabyte and day, and processing time might have a price per second."
msgstr ""

#: index.docbook:5393
#, no-c-format
msgid "Creating a user"
msgstr ""

#: index.docbook:5395
#, no-c-format
msgid "The Linux kernel itself treats users are mere numbers. Each user is identified by a unique integer, the <glossterm>user id</glossterm> or <glossterm>uid</glossterm>, because numbers are faster and easier for a computer to process than textual names. A separate database outside the kernel assigns a textual name, the <glossterm>username</glossterm>, to each user id. The database contains additional information as well."
msgstr ""

#: index.docbook:5403
#, no-c-format
msgid "To create a user, you need to add information about the user to the user database, and create a home directory for him. It may also be necessary to educate the user, and set up a suitable initial environment for him."
msgstr ""

#: index.docbook:5408
#, no-c-format
msgid "Most Linux distributions come with a program for creating accounts. There are several such programs available. Two command line alternatives are <command>adduser</command> and <command>useradd</command>; there may be a GUI tool as well. Whatever the program, the result is that there is little if any manual work to be done. Even if the details are many and intricate, these programs make everything seem trivial. However, <xref linkend=\"manual-adduser\"/> describes how to do it by hand."
msgstr ""

#: index.docbook:5419
#, no-c-format
msgid "<filename>/etc/passwd</filename> and other informative files"
msgstr ""

#: index.docbook:5422
#, no-c-format
msgid "The basic user database in a Unix system is the text file, <filename>/etc/passwd</filename> (called the <glossterm>password file</glossterm>), which lists all valid usernames and their associated information. The file has one line per username, and is divided into seven colon-delimited fields: <itemizedlist> <listitem><para>Username.</para></listitem> <listitem><para>Password, in an encrypted form.</para></listitem> <listitem><para>Numeric user id.</para></listitem> <listitem><para>Numeric group id.</para></listitem> <listitem><para>Full name or other description of account.</para></listitem> <listitem><para>Home directory.</para></listitem> <listitem><para>Login shell (program to run at login).</para></listitem> </itemizedlist> The format is explained in more detail on the <filename>passwd</filename> manual page."
msgstr ""

#: index.docbook:5445
#, no-c-format
msgid "Any user on the system may read the password file, so that they can, for example, learn the name of another user. This means that the password (the second field) is also available to everyone. The password file encrypts the password, so in theory there is no problem. However, the encryption is breakable, especially if the password is weak (e.g., it is short or it can be found in a dictionary). Therefore it is not a good idea to have the password in the password file."
msgstr ""

#: index.docbook:5454
#, no-c-format
msgid "Many Linux systems have <glossterm>shadow passwords</glossterm>. This is an alternative way of storing the password: the encrypted password is stored in a separate file, <filename>/etc/shadow</filename>, which only root can read. The <filename>/etc/passwd</filename> file only contains a special marker in the second field. Any program that needs to verify a user is setuid, and can therefore access the shadow password file. Normal programs, which only use the other fields in the password file, can't get at the password."
msgstr ""

#: index.docbook:5454
#, no-c-format
msgid "Yes, this means that the password file has all the information about a user <emphasis>except</emphasis> his password. The wonder of development."
msgstr ""

#: index.docbook:5477
#, no-c-format
msgid "Picking numeric user and group ids"
msgstr ""

#: index.docbook:5479
#, no-c-format
msgid "On most systems it doesn't matter what the numeric user and group ids are, but if you use the Network filesystem (NFS), you need to have the same uid and gid on all systems. This is because NFS also identifies users with the numeric uids. If you aren't using NFS, you can let your account creation tool pick them automatically."
msgstr ""

#: index.docbook:5486
#, no-c-format
msgid "If you are using NFS, you'll have to be invent a mechanism for synchronizing account information. One alternative is to the NIS system (see XXX network-admin-guide)."
msgstr ""

#: index.docbook:5490
#, no-c-format
msgid "However, you should try to avoid re-using numeric uids (and textual usernames), because the new owner of the uid (or username) may get access to the old owner's files (or mail, or whatever)."
msgstr ""

#: index.docbook:5506
#, no-c-format
msgid "Initial environment: <filename>/etc/skel</filename>"
msgstr ""

#: index.docbook:5508
#, no-c-format
msgid "When the home directory for a new user is created, it is initialized with files from the <filename>/etc/skel</filename> directory. The system administrator can create files in <filename>/etc/skel</filename> that will provide a nice default environment for users. For example, he might create a <filename>/etc/skel/.profile</filename> that sets the EDITOR environment variable to some editor that is friendly towards new users."
msgstr ""

#: index.docbook:5517
#, no-c-format
msgid "However, it is usually best to try to keep <filename>/etc/skel</filename> as small as possible, since it will be next to impossible to update existing users' files. For example, if the name of the friendly editor changes, all existing users would have to edit their <filename>.profile</filename>. The system administrator could try to do it automatically, with a script, but that is almost certain going to break someone's file."
msgstr ""

#: index.docbook:5526
#, no-c-format
msgid "Whenever possible, it is better to put global configuration into global files, such as <filename>/etc/profile</filename>. This way it is possible to update it without breaking users' own setups."
msgstr ""

#: index.docbook:5534
#, no-c-format
msgid "Creating a user by hand"
msgstr ""

#: index.docbook:5536
#, no-c-format
msgid "To create a new account manually, follow these steps:"
msgstr ""

#: index.docbook:5536
#, no-c-format
msgid "Edit <filename>/etc/passwd</filename> with <command>vipw</command> and add a new line for the new account. Be careful with the syntax. <emphasis>Do not edit directly with an editor!</emphasis> <command>vipw</command> locks the file, so that other commands won't try to update it at the same time. You should make the password field be `<literal>*</literal>', so that it is impossible to log in."
msgstr ""

#: index.docbook:5536
#, no-c-format
msgid "Similarly, edit <filename>/etc/group</filename> with <command>vigr</command>, if you need to create a new group as well."
msgstr ""

#: index.docbook:5536
#, no-c-format
msgid "Create the home directory of the user with <command>mkdir</command>."
msgstr ""

#: index.docbook:5536
#, no-c-format
msgid "Copy the files from <filename>/etc/skel</filename> to the new home directory."
msgstr ""

#: index.docbook:5536
#, no-c-format
msgid "Fix ownerships and permissions with <command>chown</command> and <command>chmod</command>. The <option>-R</option> option is most useful. The correct permissions vary a little from one site to another, but usually the following commands do the right thing:"
msgstr ""

#: index.docbook:5536
#, no-c-format
msgid ""
      "cd /home/newusername\n"
      "chown -R username.group .\n"
      "chmod -R go=u,go-w .\n"
      "chmod go= ."
msgstr ""

#: index.docbook:5536
#, no-c-format
msgid "Set the password with <command>passwd</command>."
msgstr ""

#: index.docbook:5581
#, no-c-format
msgid "After you set the password in the last step, the account will work. You shouldn't set it until everything else has been done, otherwise the user may inadvertently log in while you're still copying the files."
msgstr ""

#: index.docbook:5586
#, no-c-format
msgid "It is sometimes necessary to create dummy accounts <footnote><para>Surreal users?</para></footnote> that are not used by people. For example, to set up an anonymous FTP server (so that anyone can download files from it, without having to get an account first), you need to create an account called ftp. In such cases, it is usually not necessary to set the password (last step above). Indeed, it is better not to, so that no-one can use the account, unless they first become root, since root can become any user."
msgstr ""

#: index.docbook:5616
#, no-c-format
msgid "Changing user properties"
msgstr ""

#: index.docbook:5618
#, no-c-format
msgid "There are a few commands for changing various properties of an account (i.e., the relevant field in <filename>/etc/passwd</filename>): <glosslist> <glossentry><glossterm><command>chfn</command></glossterm> <glossdef><para> Change the full name field. </para></glossdef></glossentry> <glossentry><glossterm><command>chsh</command></glossterm> <glossdef><para> Change the login shell. </para></glossdef></glossentry> <glossentry><glossterm><command>passwd</command></glossterm> <glossdef><para>Change the password. </para></glossdef></glossentry> </glosslist> The super-user may use these commands to change the properties of any account. Normal users can only change the properties of their own account. It may sometimes be necessary to disable these commands (with <command>chmod</command>) for normal users, for example in an environment with many novice users."
msgstr ""

#: index.docbook:5641
#, no-c-format
msgid "Other tasks need to be done by hand. For example, to change the username, you need to edit <filename>/etc/passwd</filename> directly (with <command>vipw</command>, remember). Likewise, to add or remove the user to more groups, you need to edit <filename>/etc/group</filename> (with <command>vigr</command>). Such tasks tend to be rare, however, and should be done with caution: for example, if you change the username, e-mail will no longer reach the user, unless you also create a mail alias."
msgstr ""

#: index.docbook:5641
#, no-c-format
msgid "The user's name might change due to marriage, for example, and he might want to have his username reflect his new name."
msgstr ""

#: index.docbook:5663
#, no-c-format
msgid "Removing a user"
msgstr ""

#: index.docbook:5665
#, no-c-format
msgid "To remove a user, you first remove all his files, mailboxes, mail aliases, print jobs, <command>cron</command> and <command>at</command> jobs, and all other references to the user. Then you remove the relevant lines from <filename>/etc/passwd</filename> and <filename>/etc/group</filename> (remember to remove the username from all groups it's been added to). It may be a good idea to first disable the account (see below), before you start removing stuff, to prevent the user from using the account while it is being removed."
msgstr ""

#: index.docbook:5676
#, no-c-format
msgid ""
      "Remember that users may have files outside their home directory. The <command>find</command> command can find them: <screen>\n"
      "find / -user username\n"
      "</screen> However, note that the above command will take a <emphasis>long</emphasis> time, if you have large disks. If you mount network disks, you need to be careful so that you won't trash the network or the server."
msgstr ""

#: index.docbook:5689
#, no-c-format
msgid "Some Linux distributions come with special commands to do this; look for <command>deluser</command> or <command>userdel</command>. However, it is easy to do it by hand as well, and the commands might not do everything."
msgstr ""

#: index.docbook:5697
#, no-c-format
msgid "Disabling a user temporarily"
msgstr ""

#: index.docbook:5699
#, no-c-format
msgid "It is sometimes necessary to temporarily disable an account, without removing it. For example, the user might not have paid his fees, or the system administrator may suspect that a cracker has got the password of that account."
msgstr ""

#: index.docbook:5704
#, no-c-format
msgid "The best way to disable an account is to change its shell into a special program that just prints a message. This way, whoever tries to log into the account, will fail, and will know why. The message can tell the user to contact the system administrator so that any problems may be dealt with."
msgstr ""

#: index.docbook:5710
#, no-c-format
msgid "It would also be possible to change the username or password to something else, but then the user won't know what is going on. Confused users mean more work."
msgstr ""

#: index.docbook:5710
#, no-c-format
msgid "But they can be <emphasis>so</emphasis> fun, if you're a BOFH."
msgstr ""

#: index.docbook:5721
#, no-c-format
msgid ""
      "A simple way to create the special programs is to write `tail scripts': <screen>\n"
      "#!/usr/bin/tail +2\n"
      "This account has been closed due to a security breach.\n"
      "Please call 555-1234 and wait for the men in black to arrive.\n"
      "</screen> The first two characters (`<literal>#!</literal>') tell the kernel that the rest of the line is a command that needs to be run to interpret this file. The <command>tail</command> command in this case outputs everything except the first line to the standard output."
msgstr ""

#: index.docbook:5736
#, no-c-format
msgid ""
      "If user billg is suspected of a security breach, the system administrator would do something like this: <screen>\n"
      "<prompt>#</prompt> <userinput>chsh -s \n"
      "/usr/local/lib/no-login/security billg</userinput>\n"
      "<prompt>#</prompt> <userinput>su - tester</userinput>\n"
      "This account has been closed due to a security breach.\n"
      "Please call 555-1234 and wait for the men in black to arrive.\n"
      "<prompt>#</prompt>\n"
      "</screen> The purpose of the <command>su</command> is to test that the change worked, of course."
msgstr ""

#: index.docbook:5752
#, no-c-format
msgid "Tail scripts should be kept in a separate directory, so that their names don't interfere with normal user commands."
msgstr ""

#: index.docbook:5768
#, no-c-format
msgid "Backups"
msgstr ""

#: index.docbook:5770
#, no-c-format
msgid ""
      "Hardware is indeterministically reliable. \n"
      "Software is deterministically unreliable.\n"
      "People are indeterministically unreliable.\n"
      "Nature is deterministically reliable."
msgstr ""

#: index.docbook:5777
#, no-c-format
msgid "This chapter explains about why, how, and when to make backups, and how to restore things from backups."
msgstr ""

#: index.docbook:5781
#, no-c-format
msgid "On the importance of being backed up"
msgstr ""

#: index.docbook:5783
#, no-c-format
msgid "Your data is valuable. It will cost you time and effort re-create it, and that costs money or at least personal grief and tears; sometimes it can't even be re-created, e.g., if it is the results of some experiments. Since it is an investment, you should protect it and take steps to avoid losing it."
msgstr ""

#: index.docbook:5789
#, no-c-format
msgid "There are basically four reasons why you might lose data: hardware failures, software bugs, human action, or natural disasters. <footnote><para>The fifth reason is <quote>something else</quote>.</para></footnote> Although modern hardware tends to be quite reliable, it can still break seemingly spontaneously. The most critical piece of hardware for storing data is the hard disk, which relies on tiny magnetic fields remaining intact in a world filled with electromagnetic noise. Modern software doesn't even tend to be reliable; a rock solid program is an exception, not a rule. Humans are quite unreliable, they will either make a mistake, or they will be malicious and destroy data on purpose. Nature might not be evil, but it can wreak havoc even when being good. All in all, it is a small miracle that anything works at all."
msgstr ""

#: index.docbook:5807
#, no-c-format
msgid "Backups are a way to protect the investment in data. By having several copies of the data, it does not matter as much if one is destroyed (the cost is only that of the restoration of the lost data from the backup)."
msgstr ""

#: index.docbook:5812
#, no-c-format
msgid "It is important to do backups properly. Like everything else that is related to the physical world, backups will fail sooner or later. Part of doing backups well is to make sure they work; you don't want to notice that your backups didn't work. <footnote><para>Don't laugh. This has happened to several people.</para></footnote> Adding insult to injury, you might have a bad crash just as you're making the backup; if you have only one backup medium, it might destroyed as well, leaving you with the smoking ashes of hard work. <footnote><para>Been there, done that...</para></footnote> Or you might notice, when trying to restore, that you forgot to back up something important, like the user database on a 15000 user site. Best of all, all your backups might be working perfectly, but the last known tape drive reading the kind of tapes you used was the one that now has a bucketful of water in it."
msgstr ""

#: index.docbook:5834
#, no-c-format
msgid "When it comes to backups, paranoia is in the job description."
msgstr ""

#: index.docbook:5840
#, no-c-format
msgid "Selecting the backup medium"
msgstr ""

#: index.docbook:5842
#, no-c-format
msgid "The most important decision regarding backups is the choice of backup medium. You need to consider cost, reliability, speed, availability, and usability."
msgstr ""

#: index.docbook:5846
#, no-c-format
msgid "Cost is important, since you should preferably have several times more backup storage than what you need for the data. A cheap medium is usually a must."
msgstr ""

#: index.docbook:5850
#, no-c-format
msgid "Reliability is extremely important, since a broken backup can make a grown man cry. A backup medium must be able to hold data without corruption for years. The way you use the medium affects it reliability as a backup medium. A hard disk is typically very reliable, but as a backup medium it is not very reliable, if it is in the same computer as the disk you are backing up."
msgstr ""

#: index.docbook:5858
#, no-c-format
msgid "Speed is usually not very important, if backups can be done without interaction. It doesn't matter if a backup takes two hours, as long as it needs no supervision. On the other hand, if the backup can't be done when the computer would otherwise be idle, then speed is an issue."
msgstr ""

#: index.docbook:5864
#, no-c-format
msgid "Availability is obviously necessary, since you can't use a backup medium if it doesn't exist. Less obvious is the need for the medium to be available even in the future, and on computers other than your own. Otherwise you may not be able to restore your backups after a disaster."
msgstr ""

#: index.docbook:5870
#, no-c-format
msgid "Usability is a large factor in how often backups are made. The easier it is to make backups, the better. A backup medium mustn't be hard or boring to use."
msgstr ""

#: index.docbook:5874
#, no-c-format
msgid "The typical alternatives are floppies and tapes. Floppies are very cheap, fairly reliable, not very fast, very available, but not very usable for large amounts of data. Tapes are cheap to somewhat expensive, fairly reliable, fairly fast, quite available, and, depending on the size of the tape, quite comfortable."
msgstr ""

#: index.docbook:5881
#, no-c-format
msgid "There are other alternatives. They are usually not very good on availability, but if that is not a problem, they can be better in other ways. For example, magneto-optical disks can have good sides of both floppies (they're random access, making restoration of a single file quick) and tapes (contain a lot of data)."
msgstr ""

#: index.docbook:5891
#, no-c-format
msgid "Selecting the backup tool"
msgstr ""

#: index.docbook:5893
#, no-c-format
msgid "There are many tools that can be used to make backups. The traditional UNIX tools used for backups are <command>tar</command>, <command>cpio</command>, and <command>dump</command>. In addition, there are large number of third party packages (both freeware and commercial) that can be used. The choice of backup medium can affect the choice of tool."
msgstr ""

#: index.docbook:5901
#, no-c-format
msgid "<command>tar</command> and <command>cpio</command> are similar, and mostly equivalent from a backup point of view. Both are capable of storing files on tapes, and retrieving files from them. Both are capable of using almost any media, since the kernel device drivers take care of the low level device handling and the devices all tend to look alike to user level programs. Some UNIX versions of <command>tar</command> and <command>cpio</command> may have problems with unusual files (symbolic links, device files, files with very long pathnames, and so on), but the Linux versions should handle all files correctly."
msgstr ""

#: index.docbook:5913
#, no-c-format
msgid "<command>dump</command> is different in that it reads the filesystem directly and not via the filesystem. It is also written specifically for backups; <command>tar</command> and <command>cpio</command> are really for archiving files, although they work for backups as well."
msgstr ""

#: index.docbook:5919
#, no-c-format
msgid "Reading the filesystem directly has some advantages. It makes it possible to back files up without affecting their time stamps; for <command>tar</command> and <command>cpio</command>, you would have to mount the filesystem read-only first. Directly reading the filesystem is also more effective, if everything needs to be backed up, since it can be done with much less disk head movement. The major disadvantage is that it makes the backup program specific to one filesystem type; the Linux <command>dump</command> program understands the ext2 filesystem only."
msgstr ""

#: index.docbook:5930
#, no-c-format
msgid "<command>dump</command> also directly supports backup levels (which we'll be discussing below); with <command>tar</command> and <command>cpio</command> this has to be implemented with other tools."
msgstr ""

#: index.docbook:5935
#, no-c-format
msgid "A comparison of the third party backup tools is beyond the scope of this book. The Linux Software Map lists many of the freeware ones."
msgstr ""

#: index.docbook:5942
#, no-c-format
msgid "Simple backups"
msgstr ""

#: index.docbook:5944
#, no-c-format
msgid "A simple backup scheme is to back up everything once, then back up everything that has been modified since the previous backup. The first backup is called a <glossterm>full backup</glossterm>, the subsequent ones are <glossterm>incremental backups</glossterm>. A full backup is often more laborious than incremental ones, since there is more data to write to the tape and a full backup might not fit onto one tape (or floppy). Restoring from incremental backups can be many times more work than from a full one. Restoration can be optimized so that you always back up everything since the previous full backup; this way, backups are a bit more work, but there should never be a need to restore more than a full backup and an incremental backup."
msgstr ""

#: index.docbook:5958
#, no-c-format
msgid "If you want to make backups every day and have six tapes, you could use tape 1 for the first full backup (say, on a Friday), and tapes 2 to 5 for the incremental backups (Monday through Thursday). Then you make a new full backup on tape 6 (second Friday), and start doing incremental ones with tapes 2 to 5 again. You don't want to overwrite tape 1 until you've got a new full backup, lest something happens while you're making the full backup. After you've made a full backup to tape 6, you want to keep tape 1 somewhere else, so that when your other backup tapes are destroyed in the fire, you still have at least something left. When you need to make the next full backup, you fetch tape 1 and leave tape 6 in its place."
msgstr ""

#: index.docbook:5971
#, no-c-format
msgid "If you have more than six tapes, you can use the extra ones for full backups. Each time you make a full backup, you use the oldest tape. This way you can have full backups from several previous weeks, which is good if you want to find an old, now deleted file, or an old version of a file."
msgstr ""

#: index.docbook:5978
#, no-c-format
msgid "Making backups with <command>tar</command>"
msgstr ""

#: index.docbook:5980
#, no-c-format
msgid ""
      "A full backup can easily be made with <command>tar</command>: <screen>\n"
      "<prompt>#</prompt> <userinput>tar --create --file /dev/ftape \n"
      "/usr/src</userinput>\n"
      "<computeroutput>tar: Removing leading / from absolute path names in \n"
      "the archive</computeroutput>\n"
      "<prompt>#</prompt>\n"
      "</screen> The example above uses the GNU version of <command>tar</command> and its long option names. The traditional version of <command>tar</command> only understands single character options. The GNU version can also handle backups that don't fit on one tape or floppy, and also very long paths; not all traditional versions can do these things. (Linux only uses GNU <command>tar</command>.)"
msgstr ""

#: index.docbook:5999
#, no-c-format
msgid ""
      "If your backup doesn't fit on one tape, you need to use the <option>--multi-volume</option> (<option>-M</option>) option: <screen>\n"
      "<prompt>#</prompt> <userinput>tar -cMf /dev/fd0H1440 \n"
      "/usr/src</userinput>\n"
      "<computeroutput>tar: Removing leading / from absolute path names in \n"
      "the archive\n"
      "Prepare volume #2 for /dev/fd0H1440 and hit return:</computeroutput>\n"
      "<prompt>#</prompt>\n"
      "</screen> Note that you should format the floppies before you begin the backup, or else use another window or virtual terminal and do it when <command>tar</command> asks for a new floppy."
msgstr ""

#: index.docbook:6015
#, no-c-format
msgid ""
      "After you've made a backup, you should check that it is OK, using the <option>--compare</option> (<option>-d</option>) option: <screen>\n"
      "<prompt>#</prompt> <userinput>tar --compare --verbose -f \n"
      "/dev/ftape</userinput>\n"
      "<computeroutput>usr/src/\n"
      "usr/src/linux\n"
      "usr/src/linux-1.2.10-includes/\n"
      "....</computeroutput>\n"
      "<prompt>#</prompt>\n"
      "</screen> Failing to check a backup means that you will not notice that your backups aren't working until after you've lost the original data."
msgstr ""

#: index.docbook:6032
#, no-c-format
msgid ""
      "An incremental backup can be done with <command>tar</command> using the <option>--newer</option> (<option>-N</option>) option: <screen>\n"
      "<prompt>#</prompt> <userinput>tar --create --newer '8 Sep 1995' \n"
      "--file /dev/ftape /usr/src \n"
      "--verbose</userinput>\n"
      "<computeroutput>tar: Removing leading / from absolute path names in \n"
      "the archive\n"
      "usr/src/\n"
      "usr/src/linux-1.2.10-includes/\n"
      "usr/src/linux-1.2.10-includes/include/\n"
      "usr/src/linux-1.2.10-includes/include/linux/\n"
      "usr/src/linux-1.2.10-includes/include/linux/modules/\n"
      "usr/src/linux-1.2.10-includes/include/asm-generic/\n"
      "usr/src/linux-1.2.10-includes/include/asm-i386/\n"
      "usr/src/linux-1.2.10-includes/include/asm-mips/\n"
      "usr/src/linux-1.2.10-includes/include/asm-alpha/\n"
      "usr/src/linux-1.2.10-includes/include/asm-m68k/\n"
      "usr/src/linux-1.2.10-includes/include/asm-sparc/\n"
      "usr/src/patch-1.2.11.gz</computeroutput>\n"
      "<prompt>#</prompt>\n"
      "</screen> Unfortunately, <command>tar</command> can't notice when a file's inode information has changed, for example, that its permission bits have been changed, or when its name has been changed. This can be worked around using <command>find</command> and comparing current filesystem state with lists of files that have been previously backed up. Scripts and programs for doing this can be found on Linux ftp sites."
msgstr ""

#: index.docbook:6068
#, no-c-format
msgid "Restoring files with <command>tar</command>"
msgstr ""

#: index.docbook:6070
#, no-c-format
msgid ""
      "The <option>--extract</option> (<option>-x</option>) option for <command>tar</command> extracts files: <screen>\n"
      "<prompt>#</prompt> <userinput>tar --extract --same-permissions \n"
      "--verbose --file \n"
      "/dev/fd0H1440</userinput>\n"
      "<computeroutput>usr/src/\n"
      "usr/src/linux\n"
      "usr/src/linux-1.2.10-includes/\n"
      "usr/src/linux-1.2.10-includes/include/\n"
      "usr/src/linux-1.2.10-includes/include/linux/\n"
      "usr/src/linux-1.2.10-includes/include/linux/hdreg.h\n"
      "usr/src/linux-1.2.10-includes/include/linux/kernel.h\n"
      "...</computeroutput>\n"
      "<prompt>#</prompt>\n"
      "</screen> You also extract only specific files or directories (which includes all their files and subdirectories) by naming on the command line: <screen>\n"
      "<prompt>#</prompt> <userinput>tar xpvf /dev/fd0H1440 \n"
      "usr/src/linux-1.2.10-includes/include/linux/hdreg.h</userinput>\n"
      "<computeroutput>usr/src/linux-1.2.10-includes/include/linux/hdreg.h</computeroutput>\n"
      "<prompt>#</prompt>\n"
      "</screen> Use the <option>--list</option> (<option>-t</option>) option, if you just want to see what files are on a backup volume: <screen>\n"
      "<prompt>#</prompt> <userinput>tar --list --file \n"
      "/dev/fd0H1440</userinput>\n"
      "<computeroutput>usr/src/\n"
      "usr/src/linux\n"
      "usr/src/linux-1.2.10-includes/\n"
      "usr/src/linux-1.2.10-includes/include/\n"
      "usr/src/linux-1.2.10-includes/include/linux/\n"
      "usr/src/linux-1.2.10-includes/include/linux/hdreg.h\n"
      "usr/src/linux-1.2.10-includes/include/linux/kernel.h\n"
      "...</computeroutput>\n"
      "<prompt>#</prompt>\n"
      "</screen> Note that <command>tar</command> always reads the backup volume sequentially, so for large volumes it is rather slow. It is not possible, however, to use random access database techniques when using a tape drive or some other sequential medium."
msgstr ""

#: index.docbook:6121
#, no-c-format
msgid "<command>tar</command> doesn't handle deleted files properly. If you need to restore a filesystem from a full and an incremental backup, and you have deleted a file between the two backups, it will exist again after you have done the restore. This can be a big problem, if the file has sensitive data that should no longer be available."
msgstr ""

#: index.docbook:6133
#, no-c-format
msgid "Multilevel backups"
msgstr ""

#: index.docbook:6135
#, no-c-format
msgid "The simple backup method outlined in the previous section is often quite adequate for personal use or small sites. For more heavy duty use, multilevel backups are more appropriate."
msgstr ""

#: index.docbook:6139
#, no-c-format
msgid "The simple method has two backup levels: full and incremental backups. This can be generalized to any number of levels. A full backup would be level 0, and the different levels of incremental backups levels 1, 2, 3, etc. At each incremental backup level you back up everything that has changed since the previous backup at the same or a previous level."
msgstr ""

#: index.docbook:6146
#, no-c-format
msgid "The purpose for doing this is that it allows a longer <glossterm>backup history</glossterm> cheaply. In the example in the previous section, the backup history went back to the previous full backup. This could be extended by having more tapes, but only a week per new tape, which might be too expensive. A longer backup history is useful, since deleted or corrupted files are often not noticed for a long time. Even a version of a file that is not very up to date is better than no file at all."
msgstr ""

#: index.docbook:6155
#, no-c-format
msgid "With multiple levels the backup history can be extended more cheaply. For example, if we buy ten tapes, we could use tapes 1 and 2 for monthly backups (first Friday each month), tapes 3 to 6 for weekly backups (other Fridays; note that there can be five Fridays in one month, so we need four more tapes), and tapes 7 to 10 for daily backups (Monday to Thursday). With only four more tapes, we've been able to extend the backup history from two weeks (after all daily tapes have been used) to two months. It is true that we can't restore every version of each file during those two months, but what we can restore is often good enough."
msgstr ""

#: index.docbook:6167
#, no-c-format
msgid "shows which backup level is used each day, and which backups can be restored from at the end of the month."
msgstr ""

#: index.docbook:6172
#, no-c-format
msgid "A sample multilevel backup schedule."
msgstr ""

#: index.docbook:6176
#, no-c-format
msgid "Backup levels can also be used to keep filesystem restoration time to a minimum. If you have many incremental backups with monotonously growing level numbers, you need to restore all of them if you need to rebuild the whole filesystem. Instead you can use level numbers that aren't monotonous, and keep down the number of backups to restore."
msgstr ""

#: index.docbook:6183
#, no-c-format
msgid "To minimize the number of tapes needed to restore, you could use a smaller level for each incremental tape. However, then the time to make the backups increases (each backup copies everything since the previous full backup). A better scheme is suggested by the <command>dump</command> manual page and described by the table XX (efficient-backup-levels). Use the following succession of backup levels: 3, 2, 5, 4, 7, 6, 9, 8, 9, etc. This keeps both the backup and restore times low. The most you have to backup is two day's worth of work. The number of tapes for a restore depends on how long you keep between full backups, but it is less than in the simple schemes."
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "Efficient backup scheme using many backup levels"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "Tape"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "Level"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "Backup (days)"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "Restore tapes"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "<entry>n/a</entry>"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 3"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2, 4"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2, 5"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2, 5, 6"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2, 5, 7"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2, 5, 7, 8"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2, 5, 7, 9"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "<entry>10</entry>"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2, 5, 7, 9, 10"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "<entry>11</entry>"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2, 5, 7, 9, 10, 11"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "<entry>...</entry>"
msgstr ""

#: index.docbook:6195
#, no-c-format
msgid "1, 2, 5, 7, 9, 10, 11, ..."
msgstr ""

#: index.docbook:6234
#, no-c-format
msgid "A fancy scheme can reduce the amount of labor needed, but it does mean there are more things to keep track of. You must decide if it is worth it."
msgstr ""

#: index.docbook:6238
#, no-c-format
msgid "<command>dump</command> has built-in support for backup levels. For <command>tar</command> and <command>cpio</command> it must be implemented with shell scripts."
msgstr ""

#: index.docbook:6245
#, no-c-format
msgid "What to back up"
msgstr ""

#: index.docbook:6247
#, no-c-format
msgid "You want to back up as much as possible. The major exception is software that can be easily reinstalled, <footnote><para>You get to decide what's easy. Some people consider installing from dozens of floppies easy.</para></footnote> but even they may have configuration files that it is important to back up, lest you need to do all the work to configure them all over again. Another major exception is the <filename>/proc</filename> filesystem; since that only contains data that the kernel always generates automatically, it is never a good idea to back it up. Especially the <filename>/proc/kcore</filename> file is unnecessary, since it is just an image of your current physical memory; it's pretty large as well."
msgstr ""

#: index.docbook:6264
#, no-c-format
msgid "Gray areas include the news spool, log files, and many other things in <filename>/var</filename>. You must decide what you consider important."
msgstr ""

#: index.docbook:6268
#, no-c-format
msgid "The obvious things to back up are user files (<filename>/home</filename>) and system configuration files (<filename>/etc</filename>, but possibly other things scattered all over the filesystem)."
msgstr ""

#: index.docbook:6276
#, no-c-format
msgid "Compressed backups"
msgstr ""

#: index.docbook:6278
#, no-c-format
msgid "Backups take a lot of space, which can cost quite a lot of money. To reduce the space needed, the backups can be compressed. There are several ways of doing this. Some programs have support for for compression built in; for example, the <option>--gzip</option> (<option>-z</option>) option for GNU <command>tar</command> pipes the whole backup through the <command>gzip</command> compression program, before writing it to the backup medium."
msgstr ""

#: index.docbook:6287
#, no-c-format
msgid "Unfortunately, compressed backups can cause trouble. Due to the nature of how compression works, if a single bit is wrong, all the rest of the compressed data will be unusable. Some backup programs have some built in error correction, but no method can handle a large number of errors. This means that if the backup is compressed the way GNU <command>tar</command> does it, with the whole output compressed as a unit, a single error makes all the rest of the backup lost. Backups must be reliable, and this method of compression is not a good idea."
msgstr ""

#: index.docbook:6297
#, no-c-format
msgid "An alternative way is to compress each file separately. This still means that the one file is lost, but all other files are unharmed. The lost file would have been corrupted anyway, so this situation is not much worse than not using compression at all. The <command>afio</command> program (a variant of <command>cpio</command>) can do this."
msgstr ""

#: index.docbook:6304
#, no-c-format
msgid "Compression takes some time, which may make the backup program unable to write data fast enough for a tape drive. <footnote><para>If a tape drive doesn't data fast enough, it has to stop; this makes backups even slower, and can be bad for the tape and the drive.</para></footnote> This can be avoided by buffering the output (either internally, if the backup program if smart enough, or by using another program), but even that might not work well enough. This should only be a problem on slow computers."
msgstr ""

#: index.docbook:6322
#, no-c-format
msgid "Keeping Time"
msgstr ""

#: index.docbook:6324
#, no-c-format
msgid "<quote>Time is an illusion. Lunchtime double so.</quote> (Douglas Adams.)"
msgstr ""

#: index.docbook:6327
#, no-c-format
msgid "This chapter explains how a Linux system keeps time, and what you need to do to avoid causing trouble. Usually, you don't need to do anything about time, but it is good to understand it."
msgstr ""

#: index.docbook:6332
#, no-c-format
msgid "The concept of localtime"
msgstr ""

#: index.docbook:6334
#, no-c-format
msgid "Time measurement is based on mostly regular natural phenomena, such as alternating light and dark periods caused by the rotation of the planet. The total time taken by two successive periods is constant, but the lengths of the light and dark period vary. One simple constant is noon."
msgstr ""

#: index.docbook:6340
#, no-c-format
msgid "Noon is the time of the day when the Sun is at its highest position. Since the Earth is round, <footnote><para>According to recent research.</para></footnote> noon happens at different times in different places. This leads to the concept of <glossterm>local time</glossterm>. Humans measure time in many units, most of which are tied to natural phenomena like noon. As long as you stay in the same place, it doesn't matter that local times differ."
msgstr ""

#: index.docbook:6352
#, no-c-format
msgid "As soon as you need to communicate with distant places, you'll notice the need for a common time. In modern times, most of the places in the world communicate with most other places in the world, so a global standard for measuring time has been defined. This time is called <glossterm>universal time</glossterm> (UT or UTC, formerly known as Greenwich Mean Time or GMT, since it used to be local time in Greenwich, England). When people with different local times need to communicate, they can express times in universal time, so that there is no confusion about when things should happen."
msgstr ""

#: index.docbook:6363
#, no-c-format
msgid "Each local time is called a time zone. While geography would allow all places that have noon at the same time have the same time zone, politics makes it difficult. For various reasons, many countries use <glossterm>daylight savings time</glossterm>, that is, they move their clocks to have more natural light while they work, and then move the clocks back during winter. Other countries do not do this. Those that do, do not agree when the clocks should be moved, and they change the rules from year to year. This makes time zone conversions definitely non-trivial."
msgstr ""

#: index.docbook:6374
#, no-c-format
msgid "Time zones are best named by the location or by telling the difference between local and universal time. In the US and some other countries, the local time zones have a name and a three letter abbreviation. The abbreviations are not unique, however, and should not be used unless the country is also named. It is better to talk about the local time in, say, Helsinki, than about East European time, since not all countries in Eastern Europe follow the same rules."
msgstr ""

#: index.docbook:6383
#, no-c-format
msgid "Linux has a time zone package that knows about all existing time zones, and that can easily be updated when the rules change. All the system administrator needs to do is to select the appropriate time zone. Also, each user can set his own time zone; this is important since many people work with computers in different countries over the Internet. When the rules for daylight savings time change in your local time zone, make sure you'll upgrade at least that part of your Linux system. Other than setting the system time zone and upgrading the time zone data files, there is little need to bother about time."
msgstr ""

#: index.docbook:6398
#, no-c-format
msgid "The hardware and software clocks"
msgstr ""

#: index.docbook:6400
#, no-c-format
msgid "A personal computer has a battery driven hardware clock. The battery ensures that the clock will work even if the rest of the computer is without electricity. The hardware clock can be set from the BIOS setup screen or from whatever operating system is running."
msgstr ""

#: index.docbook:6406
#, no-c-format
msgid "The Linux kernel keeps track of time independently from the hardware clock. During the boot, Linux sets its own clock to the same time as the hardware clock. After this, both clocks run independently. Linux maintains its own clock because looking at the hardware is slow and complicated."
msgstr ""

#: index.docbook:6412
#, no-c-format
msgid "The kernel clock always shows universal time. This way, the kernel does not need to know about time zones at all. The simplicity results in higher reliability and makes it easier to update the time zone information. Each process handles time zone conversions itself (using standard tools that are part of the time zone package)."
msgstr ""

#: index.docbook:6419
#, no-c-format
msgid "The hardware clock can be in local time or in universal time. It is usually better to have it in universal time, because then you don't need to change the hardware clock when daylight savings time begins or ends (UTC does not have DST). Unfortunately, some PC operating systems, including MS-DOS, Windows, and OS/2, assume the hardware clock shows local time. Linux can handle either, but if the hardware clock shows local time, then it must be modified when daylight savings time begins or ends (otherwise it wouldn't show local time)."
msgstr ""

#: index.docbook:6432
#, no-c-format
msgid "Showing and setting time"
msgstr ""

#: index.docbook:6434
#, no-c-format
msgid "In Linux, the system time zone is determined by the symbolic link <filename>/etc/localtime</filename>. This link points to a time zone data file that describes the local time zone. The time zone data files are located at either <filename>/usr/lib/zoneinfo</filename> or <filename>/usr/share/zoneinfo</filename> depending on what distribution of Linux you use."
msgstr ""

#: index.docbook:6442
#, no-c-format
msgid "For example, on a SuSE system located in New Jersey the <filename>/etc/localtime</filename> link would point to <filename>/usr/share/zoneinfo/US/Eastern</filename>. On a Debian system the <filename>/etc/localtime</filename> link would point to <filename>/usr/lib/zoneinfo/US/Eastern</filename>."
msgstr ""

#: index.docbook:6448
#, no-c-format
msgid "If you fail to find the <filename>zoneinfo</filename> directory in either the <filename>/usr/lib</filename> or <filename>/usr/share</filename> directories, either do a <command>find /usr -print | grep zoneinfo</command> or consult your distribution's documentation."
msgstr ""

#: index.docbook:6455
#, no-c-format
msgid "What happens when you have a users located in a different timezone? A user can change his private time zone by setting the TZ environment variable. If it is unset, the system time zone is assumed. The syntax of the TZ variable is described in the <function>tzset</function> manual page."
msgstr ""

#: index.docbook:6461
#, no-c-format
msgid ""
      "The <command>date</command> command shows the current date and time. <footnote><para>Beware of the <command>time</command> command, which does not show the current time.</para></footnote> For example: <screen>\n"
      "<prompt>$</prompt> <userinput>date</userinput>\n"
      "<computeroutput>Sun Jul 14 21:53:41 EET DST 1996</computeroutput>\n"
      "<prompt>$</prompt>\n"
      "</screen> That time is Sunday, 14th of July, 1996, at about ten before ten at the evening, in the time zone called <quote>EET DST</quote> (which might be East European Daylight Savings Time). <command>date</command> can also show the universal time: <screen>\n"
      "<prompt>$</prompt> <userinput>date -u</userinput>\n"
      "<computeroutput>Sun Jul 14 18:53:42 UTC 1996</computeroutput>\n"
      "<prompt>$</prompt>\n"
      "</screen> <command>date</command> is also used to set the kernel's software clock: <screen>\n"
      "<prompt>#</prompt> <userinput>date 07142157</userinput>\n"
      "<computeroutput>Sun Jul 14 21:57:00 EET DST 1996</computeroutput>\n"
      "<prompt>#</prompt> <userinput>date</userinput>\n"
      "<computeroutput>Sun Jul 14 21:57:02 EET DST 1996</computeroutput>\n"
      "<prompt>#</prompt>\n"
      "</screen> See the <command>date</command> manual page for more details; the syntax is a bit arcane. Only root can set the time. While each user can have his own time zone, the clock is the same for everyone."
msgstr ""

#: index.docbook:6503
#, no-c-format
msgid "<command>date</command> only shows or sets the software clock. The <command>clock</command> commands synchronizes the hardware and software clocks. It is used when the system boots, to read the hardware clock and set the software clock. If you need to set both clocks, you first set the software clock with <command>date</command>, and then the hardware clock with <command>clock -w</command>."
msgstr ""

#: index.docbook:6511
#, no-c-format
msgid "The <option>-u</option> option to <command>clock</command> tells it that the hardware clock is in universal time. You <emphasis>must</emphasis> use the <option>-u</option> option correctly. If you don't, your computer will be quite confused about what the time is."
msgstr ""

#: index.docbook:6517
#, no-c-format
msgid "The clocks should be changed with care. Many parts of a Unix system require the clocks to work correctly. For example, the <command>cron</command> daemon runs commands periodically. If you change the clock, it can be confused of whether it needs to run the commands or not. On one early Unix system, someone set the clock twenty years into the future, and <command>cron</command> wanted to run all the periodic commands for twenty years all at once. Current versions of <command>cron</command> can handle this correctly, but you should still be careful. Big jumps or backward jumps are more dangerous than smaller or forward ones."
msgstr ""

#: index.docbook:6532
#, no-c-format
msgid "When the clock is wrong"
msgstr ""

#: index.docbook:6534
#, no-c-format
msgid "The Linux software clock is not always accurate. It is kept running by a periodic <glossterm>timer interrupt</glossterm> generated by PC hardware. If the system has too many processes running, it may take too long to service the timer interrupt, and the software clock starts slipping behind. The hardware clock runs independently and is usually more accurate. If you boot your computer often (as is the case for most systems that aren't servers), it will usually keep fairly accurate time."
msgstr ""

#: index.docbook:6543
#, no-c-format
msgid "If you need to adjust the hardware clock, it is usually simplest to reboot, go into the BIOS setup screen, and do it from there. This avoids all trouble that changing system time might cause. If doing it via BIOS is not an option, set the new time with <command>date</command> and <command>clock</command> (in that order), but be prepared to reboot, if some part of the system starts acting funny."
msgstr ""

#: index.docbook:6551
#, no-c-format
msgid "Another method would be to use either <command>hwclock -w</command> or <command>hwclock --systohc</command> to sync the hardware clock to the software clock. If you want to sync your software clock to your hardware clock then you would use <command>hwclock -s</command> or <command>hwclock --hctosys</command>. For more information on this command read <command>man hwclock</command>."
msgstr ""

#: index.docbook:6574
#, no-c-format
msgid "NTP - Network Time Protocol"
msgstr ""

#: index.docbook:6576
#, no-c-format
msgid "A networked computer (even if just over a modem) can check its own clock automatically by comparing it to the time on another computer known to keep accurate time. Network Time Protocol (or NTP) does exactly that. It is a method of verifying and correcting your computer's time by synchronizing it with a another system. With NTP your system's time can be maintained to within milliseconds of Coordinated Universal Time."
msgstr ""

#: index.docbook:6576
#, no-c-format
msgid "Visit <ulink url=\"http://www.time.gov/about.html/\"> http://www.time.gov/about.html</ulink> for more info."
msgstr ""

#: index.docbook:6589
#, no-c-format
msgid "For more casual Linux users, this is just a nice luxury. At my home all our clocks are set based upon what my Linux system says the time is. For larger organizations this \"luxury\" can become essential. Being able to search log files for events based upon time can make life a lot easier and take a lot of the \"guess work\" out of debugging."
msgstr ""

#: index.docbook:6598
#, no-c-format
msgid "Another example of how important NTP can be is with a SAN. Some SAN's require NTP be configured and running properly to allow for proper synchronization over filesystem usage, and proper timestamp control. Some SANs (and some applications) can become confused when dealing with files that have timestamps that are in the future."
msgstr ""

#: index.docbook:6606
#, no-c-format
msgid "Most Linux distributions come with a NTP package of some kind, either a .deb or .rpm package. You can use that to install NTP, or you can download the source files from <ulink url=\"http://www.ntp.org/downloads.html\"> http://www.ntp.org/downloads.html</ulink> and compile it yourself. Either way, the basic configuration is the same."
msgstr ""

#: index.docbook:6614
#, no-c-format
msgid "Basic NTP configuration"
msgstr ""

#: index.docbook:6615
#, no-c-format
msgid "The NTP program is configured using either the <filename>/etc/ntp.conf </filename> or <filename>/etc/xntp.conf</filename> file depending on what distribution of Linux you have. I won't go into too much detail on how to configure NTP. Instead I'll just cover the basics."
msgstr ""

#: index.docbook:6621
#, no-c-format
msgid "An example of a basic ntp.conf file would look like:"
msgstr ""

#: index.docbook:6621
#, no-c-format
msgid ""
      "# --- GENERAL CONFIGURATION ---\n"
      "server  aaa.bbb.ccc.ddd\n"
      "server  127.127.1.0\n"
      "fudge   127.127.1.0 stratum 10\n"
      "\n"
      "# Drift file.\n"
      "\n"
      "driftfile /etc/ntp/drift"
msgstr ""

#: index.docbook:6636
#, no-c-format
msgid "The most basic ntp.conf file will simply list 2 servers, one that it wishes to synchronize with, and a pseudo IP address for itself (in this case 127.127.1.0). The pseudo IP is used in case of network problems or if the remote NTP server goes down. NTP will synchronize against itself until the it can start synchronizing with the remote server again. It is recommended that you list at least 2 remote servers that you can synchronize against. One will act as a primary server and the other as a backup."
msgstr ""

#: index.docbook:6645
#, no-c-format
msgid "You should also list a location for a drift file. Over time NTP will \"learn\" the system clock's error rate and automatically adjust for it."
msgstr ""

#: index.docbook:6649
#, no-c-format
msgid ""
      "The restrict option can be used to provide better control and security over what NTP can do, and who can effect it. For example: <screen>\n"
      "<computeroutput># Prohibit general access to this service.\n"
      "restrict default ignore\n"
      "\n"
      "# Permit systems on this network to synchronize with this\n"
      "# time service. But not modify our time.\n"
      "restrict aaa.bbb.ccc.ddd nomodify\n"
      "\n"
      "# Allow the following unrestricted access to ntpd\n"
      "\n"
      "restrict aaa.bbb.ccc.ddd\n"
      "restrict 127.0.0.1\n"
      "</computeroutput>\n"
      "</screen> It is advised that you wait until you have NTP working properly before adding the restrict option. You can accidental restrict yourself from synchronizing and waste time debugging why."
msgstr ""

#: index.docbook:6672
#, no-c-format
msgid "NTP slowly corrects your systems time. Be patient! A simple test is to change your system clock by 10 minutes before you go to bed and then check it when you get up. The time should be correct."
msgstr ""

#: index.docbook:6679
#, no-c-format
msgid "NTP Toolkit"
msgstr ""

#: index.docbook:6680
#, no-c-format
msgid "There are a number of utilities available to check if NTP is doing it's job. The <command>ntpq -p</command> command will print out your system's current time status."
msgstr ""

#: index.docbook:6680
#, no-c-format
msgid ""
      "<prompt>#</prompt> <userinput>ntpq -p</userinput>\n"
      "<computeroutput>     remote           refid      st t when poll reach   delay   offset  jitter\n"
      "==============================================================================\n"
      "*cudns.cit.corne ntp0.usno.navy.  2 u  832 1024  377   43.208    0.361   2.646\n"
      " LOCAL(0)        LOCAL(0)        10 l   13   64  377    0.000    0.000   0.008\n"
      "</computeroutput>"
msgstr ""

#: index.docbook:6694
#, no-c-format
msgid "The <command>ntpdc -c loopinfo</command> will display how far off the system time is in seconds, based upon the last time the remote server was contacted."
msgstr ""

#: index.docbook:6694
#, no-c-format
msgid ""
      "<prompt>#</prompt> <userinput>ntpdc -c loopinfo</userinput>\n"
      "<computeroutput>offset:               -0.004479 s\n"
      "frequency:            133.625 ppm\n"
      "poll adjust:          30\n"
      "watchdog timer:       404 s\n"
      "</computeroutput>"
msgstr ""

#: index.docbook:6708
#, no-c-format
msgid "<command>ntpdc -c kerninfo</command> will display the current remaining correction."
msgstr ""

#: index.docbook:6708
#, no-c-format
msgid ""
      "<prompt>#</prompt> <userinput>ntpdc -c kerninfo</userinput>\n"
      "<computeroutput>pll offset:           -0.003917 s\n"
      "pll frequency:        133.625 ppm\n"
      "maximum error:        0.391414 s\n"
      "estimated error:      0.003676 s\n"
      "status:               0001  pll\n"
      "pll time constant:    6\n"
      "precision:            1e-06 s\n"
      "frequency tolerance:  512 ppm\n"
      "pps frequency:        0.000 ppm\n"
      "pps stability:        512.000 ppm\n"
      "pps jitter:           0.0002 s\n"
      "calibration interval: 4 s\n"
      "calibration cycles:   0\n"
      "jitter exceeded:      0\n"
      "stability exceeded:   0\n"
      "calibration errors:   0\n"
      "</computeroutput>"
msgstr ""

#: index.docbook:6733
#, no-c-format
msgid "A slightly more different version of <command>ntpdc -c kerninfo</command> is <command>ntptime</command>"
msgstr ""

#: index.docbook:6733
#, no-c-format
msgid ""
      "<prompt>#</prompt> <userinput>ntptime</userinput>\n"
      "<computeroutput>ntp_gettime() returns code 0 (OK)\n"
      "  time c35e2cc7.879ba000  Thu, Nov 13 2003 11:16:07.529, (.529718),\n"
      "  maximum error 425206 us, estimated error 3676 us\n"
      "ntp_adjtime() returns code 0 (OK)\n"
      "  modes 0x0 (),\n"
      "  offset -3854.000 us, frequency 133.625 ppm, interval 4 s,\n"
      "  maximum error 425206 us, estimated error 3676 us,\n"
      "  status 0x1 (PLL),\n"
      "  time constant 6, precision 1.000 us, tolerance 512 ppm,\n"
      "  pps frequency 0.000 ppm, stability 512.000 ppm, jitter 200.000 us,\n"
      "  intervals 0, jitter exceeded 0, stability exceeded 0, errors 0.\n"
      "</computeroutput>"
msgstr ""

#: index.docbook:6752
#, no-c-format
msgid "Yet another way to see how well NTP is working is with the <command>ntpdate -d</command> command. This will contact an NTP server and determine the time difference but not change your system's time."
msgstr ""

#: index.docbook:6752
#, no-c-format
msgid ""
      "<prompt>#</prompt> <userinput>ntpdate -d 132.236.56.250</userinput>\n"
      "<computeroutput>13 Nov 14:43:17 ntpdate[29631]: ntpdate 4.1.1c-rc1@1.836 Thu Feb 13 12:17:20 EST 2003 (1)\n"
      "transmit(132.236.56.250)\n"
      "receive(132.236.56.250)\n"
      "transmit(132.236.56.250)\n"
      "receive(132.236.56.250)\n"
      "transmit(132.236.56.250)\n"
      "receive(132.236.56.250)\n"
      "transmit(132.236.56.250)\n"
      "receive(132.236.56.250)\n"
      "transmit(132.236.56.250)\n"
      "server 132.236.56.250, port 123\n"
      "stratum 2, precision -17, leap 00, trust 000\n"
      "refid [192.5.41.209], delay 0.06372, dispersion 0.00044\n"
      "transmitted 4, in filter 4\n"
      "reference time:    c35e5998.4a46cfc8  Thu, Nov 13 2003 14:27:20.290\n"
      "originate timestamp: c35e5d55.d69a6f82  Thu, Nov 13 2003 14:43:17.838\n"
      "transmit timestamp:  c35e5d55.d16fc9bc  Thu, Nov 13 2003 14:43:17.818\n"
      "filter delay:  0.06522  0.06372  0.06442  0.06442\n"
      "         0.00000  0.00000  0.00000  0.00000\n"
      "filter offset: 0.000036 0.001020 0.000527 0.000684\n"
      "         0.000000 0.000000 0.000000 0.000000\n"
      "delay 0.06372, dispersion 0.00044\n"
      "offset 0.001020\n"
      "\n"
      "13 Nov 14:43:17 ntpdate[29631]: adjust time server 132.236.56.250 offset 0.001020 sec\n"
      "</computeroutput>"
msgstr ""

#: index.docbook:6788
#, no-c-format
msgid "If you want actually watch the system synchronize you can use <command>ntptrace</command>."
msgstr ""

#: index.docbook:6788
#, no-c-format
msgid ""
      "<prompt>#</prompt> <userinput>ntptrace 132.236.56.250</userinput>\n"
      "<computeroutput>cudns.cit.cornell.edu: stratum 2, offset -0.003278, synch distance 0.02779\n"
      "dtc-truetime.ntp.aol.com: stratum 1, offset -0.014363, synch distance 0.00000, refid 'ACTS'</computeroutput>"
msgstr ""

#: index.docbook:6804
#, no-c-format
msgid "If you need your system time synchronized immediately you can use the <command>ntpdate remote-servername</command> to force a synchronization. No waiting!"
msgstr ""

#: index.docbook:6804
#, no-c-format
msgid ""
      "<prompt>#</prompt> <userinput>ntpdate 132.236.56.250</userinput>\n"
      "13 Nov 14:56:28 ntpdate[29676]: adjust time server 132.236.56.250 offset -0.003151 sec\n"
      "<computeroutput></computeroutput>"
msgstr ""

#: index.docbook:6818
#, no-c-format
msgid "Some known NTP servers"
msgstr ""

#: index.docbook:6819
#, no-c-format
msgid "A list of public NTP servers can be obtained from: <ulink url=\"http://www.eecis.udel.edu/~mills/ntp/servers.html/\"> http://www.eecis.udel.edu/~mills/ntp/servers.html</ulink>. Please read the usage information on the page prior so using a server. Not all servers have the available bandwidth to allow a large number of systems syncronizing against them. Therefore it is a good idea to contact a system's administrator prior to using his/her server for NTP services."
msgstr ""

#: index.docbook:6830
#, no-c-format
msgid "NTP Links"
msgstr ""

#: index.docbook:6831
#, no-c-format
msgid "More detailed information on NTP can be obtained from the NTP homepage:<ulink url=\"http://www.ntp.org/\">http://www.ntp.org</ulink>."
msgstr ""

#: index.docbook:6835
#, no-c-format
msgid "Or from <ulink url=\"http://www.ntp.org/ntpfaq/NTP-a-faq.htm\"> http://www.ntp.org/ntpfaq/NTP-a-faq.htm</ulink>"
msgstr ""

#: index.docbook:6870
#, no-c-format
msgid "Finding Help"
msgstr ""

#: index.docbook:6872
#, no-c-format
msgid "<quote>Help me if you can I'm feeling down. And I do appreciate you being 'round.</quote> - The Beatles"
msgstr ""

#: index.docbook:6877
#, no-c-format
msgid "Newsgroups and Mailing Lists"
msgstr ""

#: index.docbook:6878
#, no-c-format
msgid "This guide cannot teach you everything about Linux. There just isn't enough space. It is almost inevitable that at some point you will find something you need to do, that isn't covered in this (or any other) document at the LDP."
msgstr ""

#: index.docbook:6885
#, no-c-format
msgid "One of the nicest things about Linux is the large number of forums devoted to it. There are forums relating to almost all facets of Linux ranging from newbie FAQs to in depth kernel development issues. To receive the most from them, there are a few things you can do."
msgstr ""

#: index.docbook:6894
#, no-c-format
msgid "Finding The Right Forum"
msgstr ""

#: index.docbook:6895
#, no-c-format
msgid "The first thing to do is to find an appropriate forum. There are many newsgroups and mailing lists devoted to Linux, so try to find and use the one which most closely matches your question. For example, there isn't much point in you asking a question about sendmail in a forum devoted to Linux kernel development. At best the people there will think you are stupid and you will get few responses, at worst you may receive lots of highly insulting replies (flames). A quick look through the newsgroups available finds comp.mail.sendmail, which looks like an appropriate place to ask a sendmail question. Your news client probably has a list of the newsgroups available to you, but if not then a full list of newsgroups is available at <ulink url=\"http://groups.google.com/groups?group=*\"> http://groups.google.com/groups?group=*</ulink>."
msgstr ""

#: index.docbook:6913
#, no-c-format
msgid "Before You Post"
msgstr ""

#: index.docbook:6914
#, no-c-format
msgid "Now that you have found your appropriate forum, you may think you are ready to post your question. Stop. You aren't ready yet. Have you already looked for the answer yourself? There are a huge number of HOWTOs and FAQs available, if any of them relate to the thing you are having a problem with then <emphasis>read them first</emphasis>. Even if they don't contain the answer to your problem, what they will do is give you a better understanding of the subject area, and that understanding will allow you to ask a more informed and sensible question. There are also archives of newsgroups and mailing lists and it is entirely possible that your question has been asked and answered previously. <ulink url=\"http://www.google.com\">http://www.google.com</ulink> or a similar search engine should be something you try <emphasis>before</emphasis> posting a question."
msgstr ""

#: index.docbook:6932
#, no-c-format
msgid "Writing Your Post"
msgstr ""

#: index.docbook:6933
#, no-c-format
msgid "Okay, you have found your appropriate forum, you have read the relevant HOWTOs and FAQs, you have searched the web, but you still have not found the answer you need. Now you can start writing your post. It is always a good idea to make it clear that you already have read up on the subject by saying something like <quote>I have read the Winmodem-HOWTO and the PPP FAQ, but neither contained what I was looking for, searching for `Winmodem Linux PPP Setup' on google didn't return anything of use either</quote>. This shows you to be someone who is willing to make an effort rather than a lazy idiot who requires spoonfeeding. The former is likely to receive help if anyone knows the answer, the latter is likely to meet with either stony silence or outright derision."
msgstr ""

#: index.docbook:6946
#, no-c-format
msgid "Write in clear, grammatical and correctly spelt English. This is incredibly important. It marks you as a precise and considered thinker. There are no such words as <quote>u</quote> or <quote>b4.</quote> Try to make yourself look like an educated and intelligent person rather than an idiot. It will help. I promise."
msgstr ""

#: index.docbook:6952
#, no-c-format
msgid "Similarly do not type in all capitals LIKE THIS. That is considered shouting and looks very rude."
msgstr ""

#: index.docbook:6955
#, no-c-format
msgid "Provide clear details stating what the problem is and what you have already tried to do to fix it. A question like <quote>My linux has stopped working, what can I do?</quote> is totally useless. Where has it stopped working? In what way has it stopped working? You need to be as precise as possible. There are limits however. Try not to include irrelevant information either. If you are having problems with your mail client it is unlikely that a dump of your kernel boot log (<command>dmesg</command>) would be of help."
msgstr ""

#: index.docbook:6964
#, no-c-format
msgid "Don't ask for replies by private email. The point of most Linux forums is that everybody can learn something from each other. Asking for private replies simply removes value from the newsgroup or mailing list."
msgstr ""

#: index.docbook:6971
#, no-c-format
msgid "Formatting Your Post"
msgstr ""

#: index.docbook:6972
#, no-c-format
msgid "Do not post in HTML. Many Linux users have mail clients which can't easily read HTML email. Whilst with some effort, they <emphasis>can</emphasis> read HTML email, they usually don't. If you send them HTML mail it often gets deleted unread. Send plain text emails, they will reach a wider audience that way."
msgstr ""

#: index.docbook:6980
#, no-c-format
msgid "Follow Up"
msgstr ""

#: index.docbook:6981
#, no-c-format
msgid "After your problem has been solved, post a short followup explaining what the problem was and how you solved it. People will appreciate this as it not only gives a sense of closure about the problem but also helps the next time someone has a similar question. When they look at the archives of the newsgroup or mailing list, they will see you had the same problem, the discussion that followed your question and your final solution."
msgstr ""

#: index.docbook:6991
#, no-c-format
msgid "More Information"
msgstr ""

#: index.docbook:6992
#, no-c-format
msgid "This short guide is simply a paraphrase and summary of the excellent (and more detailed) document <quote>How To Ask Questions The Smart Way</quote> by Eric S Raymond. <ulink url=\"http://www.tuxedo.org/~esr/faqs/smart-questions.html\"> http://www.tuxedo.org/~esr/faqs/smart-questions.html</ulink>. It is recommend that you read it before you post anything. It will help you formulate your question to maximise your chances of getting the answer you are looking for."
msgstr ""

#: index.docbook:7004
#, no-c-format
msgid "<title>IRC</title>"
msgstr ""

#: index.docbook:7005
#, no-c-format
msgid "IRC (Internet Relay Chat) is not covered in the Eric Raymond document, but IRC can also be an excellent way of finding the answers you need. However it does require some practice in asking questions in the right way. Most IRC networks have busy #linux channels and if the answer to your question is contained in the manpages, or in the HOWTOs then expect to be told to go read them. The rule about typing in clear and grammatical English still applies."
msgstr ""

#: index.docbook:7013
#, no-c-format
msgid "Most of what has been said about newsgroups and mailing lists is still relevant for IRC, with a the following additions"
msgstr ""

#: index.docbook:7017
#, no-c-format
msgid "Colours"
msgstr ""

#: index.docbook:7018
#, no-c-format
msgid "Do not use colours, bold, underline or strange (non ASCII) characters. This breaks some older terminals and is just plain ugly to look at. If you arrive in a channel and start spewing colour or bold then expect to be kicked out."
msgstr ""

#: index.docbook:7024
#, no-c-format
msgid "Be Polite"
msgstr ""

#: index.docbook:7025
#, no-c-format
msgid "Remember you are not entitled to an answer. If you ask the question in the right way then you will probably get one, but you have no right to get one. The people in Linux IRC channels are all there on their own time, nobody is paying them, especially not you."
msgstr ""

#: index.docbook:7030
#, no-c-format
msgid "Be polite. Treat others as you would like to be treated. If you think people are not being polite to you then don't start calling them names or getting annoyed, become even politer. This makes them look foolish rather than dragging you down to their level."
msgstr ""

#: index.docbook:7035
#, no-c-format
msgid "Don't go slapping anyone with large trouts. Would you believe this has been done before once or twice? And that we it wasn't funny the first time?"
msgstr ""

#: index.docbook:7040
#, no-c-format
msgid "Type Properly, in English"
msgstr ""

#: index.docbook:7041
#, no-c-format
msgid "Most #linux channels are English channels. Speak English whilst in them. Most of the larger IRC networks also have #linux channel in other languages, for example the French language channel might be called #linuxfr, the Spanish one might be #linuxes or #linuxlatino. If you can't find the right channel then asking in the main #linux channel (preferably in English) should help you find the one you are looking for."
msgstr ""

#: index.docbook:7049
#, no-c-format
msgid "Do not type like a <quote>1337 H4X0R d00d!!!</quote>. Even if other people are. It looks silly and thereby makes you look silly. At best you will only look like an idiot, at worst you will be derided then kicked out."
msgstr ""

#: index.docbook:7055
#, no-c-format
msgid "Port scanning"
msgstr ""

#: index.docbook:7056
#, no-c-format
msgid "Never <emphasis>ever</emphasis> ask anyone to port scan you, or try to <quote>hack</quote> you. This is inviolable. There is no way of knowing that you are who you say you are, or that the IP that you are connected from belongs to you. Don't put people in the position where they have to say no to a request like this."
msgstr ""

#: index.docbook:7062
#, no-c-format
msgid "<emphasis>Don't ever port scan anyone</emphasis>, even if they ask you to. You have no way to tell that they are who they say they are or that the IP they are connected from is their own IP. In some jurisdictions port scanning may be illegal and it is certainly against the Terms of Service of most ISPs. Most people log TCP connections, they will notice they are being scanned. Most people <emphasis>will</emphasis> report you to your ISP for this (it is trivial to find out who that is)."
msgstr ""

#: index.docbook:7072
#, no-c-format
msgid "Keep it in the Channel"
msgstr ""

#: index.docbook:7073
#, no-c-format
msgid "Don't /msg anyone unless they ask you to. It diminishes the usefulness of the channel and some people just prefer that you not do it."
msgstr ""

#: index.docbook:7078
#, no-c-format
msgid "Stay On Topic"
msgstr ""

#: index.docbook:7079
#, no-c-format
msgid "Stay on topic. The channel is a <quote>Linux</quote> channel, not a <quote>What Uncle Bob Got Up To Last Weekend</quote> channel. Even if you see other people being off topic, this does not mean that you should be. They are probably channel regulars and different conventions apply to them."
msgstr ""

#: index.docbook:7086
#, no-c-format
msgid "CTCPs"
msgstr ""

#: index.docbook:7087
#, no-c-format
msgid "If you are thinking of mass CTCP <footnote><para>If you are not familiar with IRC, CTCP stands for Client To Client Protocol. It is a method whereby you can find out things about other peoples' clients. See the documentation for your IRC client for more details</para></footnote> pinging the channel or CTCP version or CTCP anything, then think again. It is liable to get you kicked out very quickly."
msgstr ""

#: index.docbook:7098
#, no-c-format
msgid "Hacking, Cracking, Phreaking, Warezing"
msgstr ""

#: index.docbook:7099
#, no-c-format
msgid "Don't ask about exploits, unless you are looking for a further way to be unceremoniously kicked out."
msgstr ""

#: index.docbook:7102
#, no-c-format
msgid "Don't be in hacker/cracker/phreaker/warezer channels whilst in a #linux channel. For some reason the people in charge of #linux channels seem to hate people who like causing destruction to people's machines or who like to steal software. Can't imagine why."
msgstr ""

#: index.docbook:7108
#, no-c-format
msgid "Round Up"
msgstr ""

#: index.docbook:7109
#, no-c-format
msgid "Apologies if that seems like a lot of DON'Ts, and very few DOs. The DOs were already pretty much covered in the section on newsgroups and mailing lists."
msgstr ""

#: index.docbook:7113
#, no-c-format
msgid "Probably the best thing you can do is to go into a #linux channel, sit there and watch, getting the feel for a half hour before you say anything. This can help you to recognise the correct tone you should be using."
msgstr ""

#: index.docbook:7120
#, no-c-format
msgid "Further Reading"
msgstr ""

#: index.docbook:7121
#, no-c-format
msgid "There are excellent FAQs about how to get the most of IRC #linux channels. Most #linux channels have an FAQ and/or set or channel rules. How to find this will usually be in the channel topic (which you can see at any time using the <command>/topic</command> command. Make sure you read the rules if there are any and follow them. One fairly generic set of rules and advice is the <quote>Undernet #linux FAQ</quote> which can be found at <ulink url=\"http://linuxfaq.quartz.net.nz\">http://linuxfaq.quartz.net.nz </ulink>."
msgstr ""

#: index.docbook:7134
#, no-c-format
msgid "GNU Free Documentation License"
msgstr ""

#: index.docbook:7142
#, no-c-format
msgid "Version 1.1, March 2000"
msgstr ""

#: index.docbook:7145
#, no-c-format
msgid "Copyright (C) 2000 Free Software Foundation, Inc. 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed."
msgstr ""

#: index.docbook:7152
#, no-c-format
msgid "PREAMBLE"
msgstr ""

#: index.docbook:7154
#, no-c-format
msgid "The purpose of this License is to make a manual, textbook, or other written document \"free\" in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others."
msgstr ""

#: index.docbook:7163
#, no-c-format
msgid "This License is a kind of \"copyleft\", which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software."
msgstr ""

#: index.docbook:7168
#, no-c-format
msgid "We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference."
msgstr ""

#: index.docbook:7179
#, no-c-format
msgid "APPLICABILITY AND DEFINITIONS"
msgstr ""

#: index.docbook:7181
#, no-c-format
msgid "This License applies to any manual or other work that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. The \"Document\", below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as \"you\"."
msgstr ""

#: index.docbook:7187
#, no-c-format
msgid "A \"Modified Version\" of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language."
msgstr ""

#: index.docbook:7192
#, no-c-format
msgid "A \"Secondary Section\" is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document's overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (For example, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them."
msgstr ""

#: index.docbook:7204
#, no-c-format
msgid "The \"Invariant Sections\" are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License."
msgstr ""

#: index.docbook:7209
#, no-c-format
msgid "The \"Cover Texts\" are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License."
msgstr ""

#: index.docbook:7214
#, no-c-format
msgid "A \"Transparent\" copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, whose contents can be viewed and edited directly and straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup has been designed to thwart or discourage subsequent modification by readers is not Transparent. A copy that is not \"Transparent\" is called \"Opaque\"."
msgstr ""

#: index.docbook:7227
#, no-c-format
msgid "Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML designed for human modification. Opaque formats include PostScript, PDF, proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML produced by some word processors for output purposes only."
msgstr ""

#: index.docbook:7237
#, no-c-format
msgid "The \"Title Page\" means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, \"Title Page\" means the text near the most prominent appearance of the work's title, preceding the beginning of the body of the text."
msgstr ""

#: index.docbook:7247
#, no-c-format
msgid "VERBATIM COPYING"
msgstr ""

#: index.docbook:7249
#, no-c-format
msgid "You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3."
msgstr ""

#: index.docbook:7260
#, no-c-format
msgid "You may also lend copies, under the same conditions stated above, and you may publicly display copies."
msgstr ""

#: index.docbook:7265
#, no-c-format
msgid "COPYING IN QUANTITY"
msgstr ""

#: index.docbook:7267
#, no-c-format
msgid "If you publish printed copies of the Document numbering more than 100, and the Document's license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects."
msgstr ""

#: index.docbook:7280
#, no-c-format
msgid "If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages."
msgstr ""

#: index.docbook:7285
#, no-c-format
msgid "If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a publicly-accessible computer-network location containing a complete Transparent copy of the Document, free of added material, which the general network-using public has access to download anonymously at no charge using public-standard network protocols. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public."
msgstr ""

#: index.docbook:7300
#, no-c-format
msgid "It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document."
msgstr ""

#: index.docbook:7307
#, no-c-format
msgid "MODIFICATIONS"
msgstr ""

#: index.docbook:7309
#, no-c-format
msgid "You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:"
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has less than five)."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "State on the Title page the name of the publisher of the Modified Version, as the publisher."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Preserve all the copyright notices of the Document."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Add an appropriate copyright notice for your modifications adjacent to the other copyright notices."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document's license notice."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Include an unaltered copy of this License."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Preserve the section entitled \"History\", and its title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section entitled \"History\" in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the \"History\" section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "In any section entitled \"Acknowledgements\" or \"Dedications\", preserve the section's title, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Delete any section entitled \"Endorsements\". Such a section may not be included in the Modified Version."
msgstr ""

#: index.docbook:7317
#, no-c-format
msgid "Do not retitle any existing section as \"Endorsements\" or to conflict in title with any Invariant Section."
msgstr ""

#: index.docbook:7407
#, no-c-format
msgid "If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version's license notice. These titles must be distinct from any other section titles."
msgstr ""

#: index.docbook:7415
#, no-c-format
msgid "You may add a section entitled \"Endorsements\", provided it contains nothing but endorsements of your Modified Version by various parties--for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard."
msgstr ""

#: index.docbook:7421
#, no-c-format
msgid "You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one."
msgstr ""

#: index.docbook:7432
#, no-c-format
msgid "The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version."
msgstr ""

#: index.docbook:7438
#, no-c-format
msgid "COMBINING DOCUMENTS"
msgstr ""

#: index.docbook:7440
#, no-c-format
msgid "You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice."
msgstr ""

#: index.docbook:7447
#, no-c-format
msgid "The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work."
msgstr ""

#: index.docbook:7457
#, no-c-format
msgid "In the combination, you must combine any sections entitled \"History\" in the various original documents, forming one section entitled \"History\"; likewise combine any sections entitled \"Acknowledgements\", and any sections entitled \"Dedications\". You must delete all sections entitled \"Endorsements.\""
msgstr ""

#: index.docbook:7465
#, no-c-format
msgid "COLLECTIONS OF DOCUMENTS"
msgstr ""

#: index.docbook:7467
#, no-c-format
msgid "You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects."
msgstr ""

#: index.docbook:7474
#, no-c-format
msgid "You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document."
msgstr ""

#: index.docbook:7482
#, no-c-format
msgid "AGGREGATION WITH INDEPENDENT WORKS"
msgstr ""

#: index.docbook:7484
#, no-c-format
msgid "A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, does not as a whole count as a Modified Version of the Document, provided no compilation copyright is claimed for the compilation. Such a compilation is called an \"aggregate\", and this License does not apply to the other self-contained works thus compiled with the Document, on account of their being thus compiled, if they are not themselves derivative works of the Document."
msgstr ""

#: index.docbook:7494
#, no-c-format
msgid "If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one quarter of the entire aggregate, the Document's Cover Texts may be placed on covers that surround only the Document within the aggregate. Otherwise they must appear on covers around the whole aggregate."
msgstr ""

#: index.docbook:7503
#, no-c-format
msgid "TRANSLATION"
msgstr ""

#: index.docbook:7505
#, no-c-format
msgid "Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License provided that you also include the original English version of this License. In case of a disagreement between the translation and the original English version of this License, the original English version will prevail."
msgstr ""

#: index.docbook:7519
#, no-c-format
msgid "TERMINATION"
msgstr ""

#: index.docbook:7521
#, no-c-format
msgid "You may not copy, modify, sublicense, or distribute the Document except as expressly provided for under this License. Any other attempt to copy, modify, sublicense or distribute the Document is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance."
msgstr ""

#: index.docbook:7532
#, no-c-format
msgid "FUTURE REVISIONS OF THIS LICENSE"
msgstr ""

#: index.docbook:7534
#, no-c-format
msgid "The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See <ulink url=\"http://www.gnu.org/copyleft/\">http://www.gnu.org/copyleft/</ulink>."
msgstr ""

#: index.docbook:7542
#, no-c-format
msgid "Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation."
msgstr ""

#: index.docbook:7554
#, no-c-format
msgid "How to use this License for your documents"
msgstr ""

#: index.docbook:7556
#, no-c-format
msgid "To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:"
msgstr ""

#: index.docbook:7560
#, no-c-format
msgid "Copyright (c) YEAR YOUR NAME. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.1 or any later version published by the Free Software Foundation; with the Invariant Sections being LIST THEIR TITLES, with the Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST. A copy of the license is included in the section entitled \"GNU Free Documentation License\"."
msgstr ""

#: index.docbook:7574
#, no-c-format
msgid "If you have no Invariant Sections, write \"with no Invariant Sections\" instead of saying which ones are invariant. If you have no Front-Cover Texts, write \"no Front-Cover Texts\" instead of \"Front-Cover Texts being LIST\"; likewise for Back-Cover Texts."
msgstr ""

#: index.docbook:7580
#, no-c-format
msgid "If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software."
msgstr ""

#: index.docbook:7592
#, no-c-format
msgid "Glossary (DRAFT, but not for long hopefully)"
msgstr ""

#: index.docbook:7594
#, no-c-format
msgid "<quote>The Librarian of the Unseen University had unilaterally decided to aid comprehension by producing an Orang-utan/Human Dictionary. He'd been working on it for three months. It wasn't easy. He'd got as far as `Oook.'</quote> (Terry Pratchett, <quote>Men At Arms</quote>)"
msgstr ""

#: index.docbook:7601
#, no-c-format
msgid "This is a short list of word definitions for concepts relating to Linux and system administration."
msgstr ""

#: index.docbook:7604
#, no-c-format
msgid "CMOS RAM"
msgstr ""

#: index.docbook:7604
#, no-c-format
msgid "CMOS stands for \"Complementary Metal Oxide Semiconductor\". It is a complex technology, but put very simply it is a type of transistor which maintains its state even if there is no power flowing, so it provides a sort of static RAM. ie RAM which does not lose what it was storing when the power is switched off."
msgstr ""

#: index.docbook:7616
#, no-c-format
msgid "account"
msgstr ""

#: index.docbook:7616
#, no-c-format
msgid "A Unix system gives users <glossterm>accounts</glossterm>. It gives them a username and a password with which to log on to the account. A home directory in which to store files is usually provided, and permissions to access hardware and software. These things taken as a whole are an <glossterm>account</glossterm>."
msgstr ""

#: index.docbook:7627
#, no-c-format
msgid "application program"
msgstr ""

#: index.docbook:7627
#, no-c-format
msgid "Software that does something useful. The results of using an application program is what the computer was bought for. See also system program, operating system."
msgstr ""

#: index.docbook:7636
#, no-c-format
msgid "bad block"
msgstr ""

#: index.docbook:7636
#, no-c-format
msgid "A block (usually one sector on a disk) that cannot reliably hold data."
msgstr ""

#: index.docbook:7644
#, no-c-format
msgid "bad sector"
msgstr ""

#: index.docbook:7644
#, no-c-format
msgid "Similar to <glossterm>bad block</glossterm> but more precise in the case where a block and a sector may be of differing sizes."
msgstr ""

#: index.docbook:7652
#, no-c-format
msgid "boot sector"
msgstr ""

#: index.docbook:7652
#, no-c-format
msgid "Usually the first sector on any given partition. It contains a very short program (on the order of a few hundred bytes) which will load and start running the operating system proper."
msgstr ""

#: index.docbook:7661
#, no-c-format
msgid "booting"
msgstr ""

#: index.docbook:7661
#, no-c-format
msgid "Everything that happens between the time the computer is switched on and it is ready to accept commands/input from the user is known as <glossterm>booting</glossterm>."
msgstr ""

#: index.docbook:7670
#, no-c-format
msgid "bootstrap loader"
msgstr ""

#: index.docbook:7670
#, no-c-format
msgid "A very small program (usually residing in ROM) which reads a fixed location on a disk (eg. the <glossterm>MBR</glossterm>) and passes control over to it. The data residing on that fixed location is, in general, slightly bigger and more sophisticated, and it then takes responsibility for loading the actual operating system and passing control to it."
msgstr ""

#: index.docbook:7682
#, no-c-format
msgid "cylinder"
msgstr ""

#: index.docbook:7682
#, no-c-format
msgid "The set of <glossterm>tracks</glossterm> on a multi-headed disk that may be accessed without head movement. In other words the tracks which are the same distance from the spindle about which the disk <glossterm>platters</glossterm> rotate. Placing data that is more likely to be accessed at the same time on the same cylinder can reduce the access time significantly as moving the read-write heads is slow compared to the speed with which the disks rotate."
msgstr ""

#: index.docbook:7696
#, no-c-format
msgid "daemon"
msgstr ""

#: index.docbook:7696
#, no-c-format
msgid "A process lurking in the background, usually unnoticed, until something triggers it into action. For example, the <command>update</command> daemon wakes up every thirty seconds or so to flush the buffer cache, and the <command>sendmail</command> daemon awakes whenever someone sends mail."
msgstr ""

#: index.docbook:7709
#, no-c-format
msgid "daylight savings time"
msgstr ""

#: index.docbook:7709
#, no-c-format
msgid "A time of the year during which clocks are set forward one hour. Widely used around the world in summer so that evenings have more daylight than they would otherwise."
msgstr ""

#: index.docbook:7718
#, no-c-format
msgid "disk controller"
msgstr ""

#: index.docbook:7718
#, no-c-format
msgid "A hardware circuit which translates instructions about disk access from the operating system to the physical disk. This provides a layer of abstraction that means that an operating system does not need to know how to talk to the many different types of disks, but only needs to know about the (comparatively low) number of types of disk controller. Common disk controller types are IDE and SCSI."
msgstr ""

#: index.docbook:7730
#, no-c-format
msgid "file system"
msgstr ""

#: index.docbook:7730
#, no-c-format
msgid "The methods and data structures that an operating system uses to keep track of files on a disk or partition; the way the files are organised on the disk. Also used about a partition or disk that is used to store the files or the type of the filesystem."
msgstr ""

#: index.docbook:7741
#, no-c-format
msgid "emergency boot floppy"
msgstr ""

#: index.docbook:7741
#, no-c-format
msgid "A floppy disk which can be used to boot the system even if the hard disk has suffered damage on its filesystem. Most linux distributions offer to make one of these during installation, this is highly recommended. If your Linux distribution does not offer this facility then read the Boot floppy HOWTO, available at the LDP (**Find URL to cite**)."
msgstr ""

#: index.docbook:7753
#, no-c-format
msgid "filesystem"
msgstr ""

#: index.docbook:7753
#, no-c-format
msgid "A term which is used for two purposes and which can have two subtly different meanings. It is either the collection of files and directories on a drive (whether hard drive, floppy, Cd-ROM, etc). Or it is the markers put onto the disk media which the OS uses to decide where to write files to (inodes, blocks, superblocks etc). The actual meaning can almost always be inferred from context."
msgstr ""

#: index.docbook:7766
#, no-c-format
msgid "formatting"
msgstr ""

#: index.docbook:7766
#, no-c-format
msgid "Strictly, formatting is organising and marking the surface of a disk into <glossterm>tracks</glossterm>, <glossterm>sectors </glossterm>, and <glossterm>cylinders</glossterm>. It is also sometimes (incorrectly) a term used to signify the action of writing a <glossterm>filesystem</glossterm> to a disk (especially in the MS Windows/MS DOS world)."
msgstr ""

#: index.docbook:7778
#, no-c-format
msgid "fragmented"
msgstr ""

#: index.docbook:7778
#, no-c-format
msgid "When a file is not written to a disk in contiguous <glossterm> blocks</glossterm>. If there is not enough free space to write a full file to a disk in one continuous stream of <glossterm> blocks</glossterm> then the file gets split up between two or more parts of the disk surface. This is known as <glossterm> fragmenting</glossterm> and can make the time for loading a file longer as the disk has to seek for the rest of the file."
msgstr ""

#: index.docbook:7791
#, no-c-format
msgid "full backup"
msgstr ""

#: index.docbook:7791
#, no-c-format
msgid "Taking a copy of the whole filesystem to a backup media (eg tape, floppy, or CD)."
msgstr ""

#: index.docbook:7799
#, no-c-format
msgid "geometry"
msgstr ""

#: index.docbook:7799
#, no-c-format
msgid "How many cylinders, sectors per cylinder and heads a disk drive has."
msgstr ""

#: index.docbook:7807
#, no-c-format
msgid "high level formatting"
msgstr ""

#: index.docbook:7807
#, no-c-format
msgid "An incorrect term for writing a filesystem to a disk. Often used in the MS Windows and MS DOS world."
msgstr ""

#: index.docbook:7815
#, no-c-format
msgid "incremental backups"
msgstr ""

#: index.docbook:7815
#, no-c-format
msgid "A backup of what has changed in a filesystem since the last <glossterm>full backup</glossterm>. <glossterm>Incremental backups</glossterm> if used sensibly as part of a backup regime, can save a lot of time and effort in maintaining a backup of data."
msgstr ""

#: index.docbook:7825
#, no-c-format
msgid "inode"
msgstr ""

#: index.docbook:7825
#, no-c-format
msgid "A data structure holding information about files in a Unix file system. There is an inode for each file and a file is uniquely identified by the file system on which it resides and its inode number on that system. Each inode contains the following information: the device where the inode resides, locking information, mode and type of file, the number of links to the file, the owner's user and group ids, the number of bytes in the file, access and modification times, the time the inode itself was last modified and the addresses of the file's blocks on disk. A Unix directory is an association between file leafnames and inode numbers. A file's inode number can be found using the \"-i\" switch to ls."
msgstr ""

#: index.docbook:7843
#, no-c-format
msgid "kernel"
msgstr ""

#: index.docbook:7843
#, no-c-format
msgid "Part of an operating system that implements the interaction with hardware and the sharing of resources. See also system program."
msgstr ""

#: index.docbook:7851
#, no-c-format
msgid "local time"
msgstr ""

#: index.docbook:7851
#, no-c-format
msgid "The official time in a local region (adjusted for location around the Earth); established by law or custom."
msgstr ""

#: index.docbook:7859
#, no-c-format
msgid "logical partition"
msgstr ""

#: index.docbook:7859
#, no-c-format
msgid "A partition inside an <glossterm>extended partition</glossterm>, which is <quote>logical</quote> in that it does not exist in reality, but only inside the logical structure of the software."
msgstr ""

#: index.docbook:7868
#, no-c-format
msgid "low level formatting"
msgstr ""

#: index.docbook:7868
#, no-c-format
msgid "Synonymous with <glossterm>formatting</glossterm> and used in the MS DOS world so differentiate from creating a filesystem which is also known as formatting sometimes."
msgstr ""

#: index.docbook:7877
#, no-c-format
msgid "mail transfer agent"
msgstr ""

#: index.docbook:7877
#, no-c-format
msgid "(MTA) The program responsible for delivering e-mail messages. Upon receiving a message from a <glossterm>mail user agent </glossterm> or another MTA it stores it temporarily locally and analyses the recipients and either delivers it (local addressee) or forwards it to another MTA. In either case it may edit and/or add to the message headers. A widely used MTA for Unix is sendmail."
msgstr ""

#: index.docbook:7890
#, no-c-format
msgid "mail user agent"
msgstr ""

#: index.docbook:7890
#, no-c-format
msgid "(MUA) The program that allows the user to compose and read electronic mail messages. The MUA provides the interface between the user and the <glossterm>mail transfer agent </glossterm>. Outgoing mail is eventually handed over to an MTA for delivery while the incoming messages are picked up from where the MTA left it (although MUAs running on single-user machines may pick up mail using POP). Examples of MUAs are pine, elm and mutt."
msgstr ""

#: index.docbook:7904
#, no-c-format
msgid "master boot record"
msgstr ""

#: index.docbook:7904
#, no-c-format
msgid "(MBR) The first logical sector on a disk, this is (usually) where the BIOS looks to load a small program that will boot the computer."
msgstr ""

#: index.docbook:7913
#, no-c-format
msgid "network file system"
msgstr ""

#: index.docbook:7913
#, no-c-format
msgid "(NFS) A protocol developed by Sun Microsystems, and defined in RFC 1094 (FIND URL), which allows a computer to access files over a network as if they were on its local disks."
msgstr ""

#: index.docbook:7922
#, no-c-format
msgid "operating system"
msgstr ""

#: index.docbook:7922
#, no-c-format
msgid "Software that shares a computer system's resources (processor, memory, disk space, network bandwidth, and so on) between users and the application programs they run. Controls access to the system to provide security. See also kernel, system program, application program."
msgstr ""

#: index.docbook:7933
#, no-c-format
msgid "partition"
msgstr ""

#: index.docbook:7933
#, no-c-format
msgid "A logical section of a disk. Each partition normally has its own file system. Unix tends to treat partitions as though they were separate physical entities."
msgstr ""

#: index.docbook:7942
#, no-c-format
msgid "password file"
msgstr ""

#: index.docbook:7942
#, no-c-format
msgid "A file that holds usernames and information about their accounts like their password. On Unix systems this file is usually <filename>/etc/passwd</filename>. On most modern Linux systems the <filename>/etc/passwd</filename> file does not actually hold password data. That tends to be held in a different file <filename> /etc/shadow</filename> for security reasons. See manual pages passwd(5) and shadow(5) for more information."
msgstr ""

#: index.docbook:7955
#, no-c-format
msgid "platters"
msgstr ""

#: index.docbook:7955
#, no-c-format
msgid "A physical disk inside a hard drive. Usually a hard drive is made up of multiple physical disks stacked up on top of each other. One individual disk is known as a <glossterm>platter </glossterm>."
msgstr ""

#: index.docbook:7965
#, no-c-format
msgid "power on self test"
msgstr ""

#: index.docbook:7965
#, no-c-format
msgid "(POST) A series of diagnostic tests which are run when a computer is powered on. Typically this might include testing the memory, testing that the hardware configuration is the same as the last saved configuration, checking that any floppy drives, or hard drives which are known about by the BIOS are installed and working."
msgstr ""

#: index.docbook:7976
#, no-c-format
msgid "print queue"
msgstr ""

#: index.docbook:7976
#, no-c-format
msgid "A file (or set of files) which the print <glossterm>daemon </glossterm> uses so that applications which wish to use the printer do not have to wait until the print job they have sent is finished before they can continue. It also allows multiple users to share a printer."
msgstr ""

#: index.docbook:7987
#, no-c-format
msgid "read-write head"
msgstr ""

#: index.docbook:7987
#, no-c-format
msgid "A tiny electromagnetic coil and metal pole used to write and read magnetic patterns on a disk. These coils move laterally against the rotary motion on the <glossterm>platters</glossterm>."
msgstr ""

#: index.docbook:7996
#, no-c-format
msgid "root filesystem"
msgstr ""

#: index.docbook:7996
#, no-c-format
msgid "The parent of all the other filesystems mounted in a Unix filesystem tree. Mounted as / it might have other filesystems mounted on it (/usr for example). If the root filesystem cannot be mounted then the <glossterm>kernel</glossterm> will panic and the system will not be able to continue <glossterm>booting</glossterm>"
msgstr ""

#: index.docbook:8008
#, no-c-format
msgid "run level"
msgstr ""

#: index.docbook:8008
#, no-c-format
msgid "Linux has up to 10 runlevels (0-9) available (of which usually only the first 7 are defined). Each runlevel may start a different set of services, giving multiple different configurations in the same system. Runlevel 0 is defined as <quote>system halt</quote>, runlevel 1 is defined as <quote><glossterm>single user mode</glossterm></quote>, and runlevel 6 is defined as <quote>reboot system</quote>. The remaining runlevels can, theoretically, be defined by the system administrator in any way. However most distributions provide some other predefined runlevels. For example, runlevel 2 might be defined as <quote>multi-user console</quote>, and runlevel 5 as <quote>multi-user X-Window system</quote>. These definitions vary considerably from distribution to distribution, so please check the documentation for your own distribution."
msgstr ""

#: index.docbook:8026
#, no-c-format
msgid "sectors"
msgstr ""

#: index.docbook:8026
#, no-c-format
msgid "The minimum <glossterm>track</glossterm> length that can be allocated to store data. This is usually (but not always) 512 bytes."
msgstr ""

#: index.docbook:8035
#, no-c-format
msgid "shadow passwords"
msgstr ""

#: index.docbook:8035
#, no-c-format
msgid "Because the <glossterm>password file</glossterm> on Unix systems often needs to be world readable it usually does not actually contain the encrypted passwords for users' accounts. Instead a shadow file is employed (which is not world readable) which holds the encrypted passwords for users' accounts."
msgstr ""

#: index.docbook:8047
#, no-c-format
msgid "single user mode"
msgstr ""

#: index.docbook:8047
#, no-c-format
msgid "Usually runlevel 1. A runlevel where logins are not allowed except by the root account. Used either for system repairs (if the filesystem is partially damaged it may still be possible to boot into runlevel 1 and repair it), or for moving filesystems around between partitions. These are just two examples. Any task that requires a system where only one person can write to a disk at a time is a candidate for requiring runlevel 1."
msgstr ""

#: index.docbook:8060
#, no-c-format
msgid "spool"
msgstr ""

#: index.docbook:8060
#, no-c-format
msgid "To send a file (or other data) to a queue. Generally used in conjunction with printers, but might also be used for other things (mail for example). The term is reported to be an acronym for <quote>Simultaneous Peripheral Operation On-Line</quote>, but according to the <ulink url=\"http://www.tuxedo.org/~esr/jargon\">Jargon File </ulink> it may have been a backronym (something made up later for effect)."
msgstr ""

#: index.docbook:8073
#, no-c-format
msgid "system call"
msgstr ""

#: index.docbook:8073
#, no-c-format
msgid "The services provided by the kernel to application programs, and the way in which they are invoked. See section 2 of the manual pages."
msgstr ""

#: index.docbook:8082
#, no-c-format
msgid "swap space"
msgstr ""

#: index.docbook:8082
#, no-c-format
msgid "Space on a disk in which the system can write portions of memory to. Usually this is a dedicated partition, but it may also be a swapfile."
msgstr ""

#: index.docbook:8091
#, no-c-format
msgid "system program"
msgstr ""

#: index.docbook:8091
#, no-c-format
msgid "Programs that implement high level functionality of an operating system, i.e., things that aren't directly dependent on the hardware. May sometimes require special privileges to run (e.g., for delivering electronic mail), but often just commonly thought of as part of the system (e.g., a compiler). See also application program, kernel, operating system."
msgstr ""

#: index.docbook:8103
#, no-c-format
msgid "track"
msgstr ""

#: index.docbook:8103
#, no-c-format
msgid "The part of a disk <glossterm>platter</glossterm> which passes under one <glossterm>read-write head</glossterm> while the head is stationary but the disk is spinning. Each track is divided into <glossterm>sectors</glossterm>, and a vertical collection of tracks is a <glossterm>cylinder</glossterm>"
msgstr ""

