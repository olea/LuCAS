3.0 Vista general de un sistema GNU/Linux

"Dios observó todo lo que había hecho, y vió que esto era muy bueno" -- 
Versión de la Biblia del Rey James. Génesis 1:31

En este capítulo se proporciona una vista general de un sistema GNU/Linux. 
Primeramente serán descriptos los servicios principales del sistema operativo. 
Luego, se explica, con una falta considerable de detalle, los programas que 
implementan dichos servicios. El propósito de este capítulo es dar una 
explicación del sistema como un todo, de manera tal que cada parte se 
encuentre especificada en detalle en capítulos posteriores.



3.1 Varias partes de un sistema operativo

Un sistema operativo UNIX consiste de un kernel y de algunos programas del 
sistema. Existen también algunos programas de aplicación para trabajar. El 
kernel es le corazón del sistema operativo. Sigue con atención a 
los archivos sobre el disco, inicia programas y los ejecuta concurrentemente, 
asigna memoria y otros recursos a los procesos, recibe y envía paquetes desde 
y hacia la red, etc. El kernel hace muy poco por si solo, en realidad otorga 
herramientas con las cuales todos los servicios pueden ser construídos. Además 
evita que se acceda al hardware directamente, forzando a todos a utilizar las 
herramientas provistas. Esta manera de trabajar del kernel otorga cierta 
protección a los usuarios entre sí. Las herramientas provistas por el kernel 
son utilizadas a través de llamadas al sistema (system calls). Vea las páginas 
de manual de la sección 2 para más información sobre este tema.

Los programas del sistema utilizan las herramientas provistas por el kernel 
para implementar varios servicios requeridos en un sistema operativo. Los 
programas del sistema y todos los demás programas, se ejecutan 'por encima del 
kernel', en lo que se denomina modo usuario. La diferencia entre los programas 
de aplicación y los del sistema es su finalidad: las aplicaciones tienen el 
propósito de realizar tareas útiles a los usuarios (o para jugar, si se 
tratata de un juego), mientras que los programas del sistema son necesarios 
para que el sistema funcione. Un procesador de textos es una aplicación; mount 
es un porgrama del sistema. La diferencia a menudo es confusa, y de cualquier 
manera, es solo importante en categorizaciones compulsivas.

Un sistema operativo también puede contener compiladores y sus 
correspondientes librerías (GCC y la librería de C en particular para 
GNU/Linux), aunque no todos los compiladores de todos los lenguajes de 
programación necesitan ser parte del sistema operativo. También puede haber 
documentación, y en algunas ocaciones juegos. Tradicionalmente, el sistema 
operativo está definido por el contenido de los discos o cintas de 
instalación; con GNU/Linux esta definición no puede aplicarse, debido a que se 
encuentra extendido sobre distintos sitios FTP del mundo.


3.2 Partes importantes del kernel

El kernel de un sistema GNU/Linux consiste de varias partes importantes: un 
administrador de procesos, un administrador de memoria, varios controladores 
para dispositivos de hardware, controladores de sistemas de archivos, un 
administrador de red, y varias otras piezas y bits.

Probablemente las partes más importantes del kernel (nada trabajaría sin 
ellas) son el administrador de memoria y el administrador de procesos. El 
administrador de memoria se encarga de asignar áreas de memoria y áreas de 
espacio de swap a procesos, partes del kernel, y al buffer caché. El 
administrador de procesos se encarga de crear procesos, e implementar 
multitarea intercambiando los procesos activos en el procesador.

A más bajo nivel, el kernel contiene un controlador de dispositivo de 
hardaware para cada tipo de hardware que este soporte. Debido a que el mundo 
se encuentra lleno de diferentes tipos de hardware, el número de controladores 
de dispositivos de hardware es grande. Existen frecuentemente, muchas piezas 
similares de hardware que difierren en como ellas son controladas por 
software. La similaridad hace posible tener clases generales de controladores 
que soportan operaciones similares; cada miembro de la clase tiene la misma 
interfase para el resto del kernel pero difieren en como estas necesitan ser 
implementadas. Por ejemplo, todas las unidades de disco se parecen para el 
resto del kernel, i.e., todas tienen operaciones como "iniciar la unidad", 
"leer el sector n", y "escribir en el sector n".

Algunos servicios de software provistos por el kernel tienen propiedades 
similares, y pueden de esta manera ser abstraídas dentro de clases. Por 
ejemplo, varios protocolos de red fueron abstraídos dentro de una interfase de 
programación, la librería de socket BSD. Otro ejemplo es la capa del sistema 
de archivos virtual (VFS) que abstrae las operaciones de los sistemas de 
archivos de sus implementaciones. Cada tipo de sistema de archivos provee una 
implementación de cada operación. Cuando alguna entidad intenta utilizar un 
sistema de archivos, el requisito se realiza vía el VFS, el cual rutea el 
requisito al controlador del sistema de archivos correcto.


3.3 Servicios principales en un sistema UNIX

En esta sección se describe algunos de los más importantes servicios en UNIX, 
pero sin mucho detalle. Ellos serán descriptos más profundamente en capítulos 
posteriores.


3.3.1 Init

El servicio individual más importante en un sistema UNIX es provisto por 
init. Init es el primer proceso de todo sistema UNIX, es iniciado por el 
kernel, como la última acción que este realiza cuando el sistema inicia. 
Cuando init comienza su ejecución, continúa con el proceso de arranque del 
sistema, realizando varias tareas de inicio (chequear y montar sistemas de 
archivos, iniciar demonios, etc).

La lista exacta de cosas que init realiza depende en cual gusto tenga; existen 
varias para seleccionar. init usualmente provee el concepto de modo de usuario 
individual, en el cual nadie puede iniciar una sesión y root utiliza un 
intérprete de comandos en la consola; el modo usual es llamado modo 
multiusuario. Algunos gustos generalizan esto como niveles de ejecución; los 
modos individual y multiusuario son considerados dos niveles de ejecución, y 
pueden existir otros niveles adicionales, como por ejemplo, para ejecutar X en 
la consola.

GNU/Linux permite tener hasta 10 niveles de ejecución distintos, 0-9, pero 
usualmente solo algunos de estos niveles son definidos por defecto. El nivel 
de ejecución 0 es definido como "system halt" (sistema detenido). El nivel de 
ejecución 1 está definido como "single user mode" (modo de usuario 
individual). El nivel de ejecución 6 es definido como "system reboot" 
(re-inicio del sistema). Los niveles de ejecución restantes dependen en como 
tu distribución particular GNU/Linux los haya definido, y varían 
significativamente entre distribuciones. Observando el contenido del archivo 
/etc/inittab podemos darnos cuenta de los niveles de ejecución predefinidos en 
nuestro sistema y de como se encuentran definidos.

En operación normal, init se asegura de que getty se encuentre trabajando 
(para permitir que los usuarios puedan iniciar una sesión), y también se 
encarga de adoptar procesos huérfanos (procesos cuyos padres murieron; en UNIX 
todos los procesos deben estar en un árbol individual, por esta razón los 
procesos huérfanos deben ser adoptados).

Cuando el sistema se cierra, init se encarga de matar a todos los procesos 
restantes, desmontar todos los sistemas de archivos, y por último, frenar el 
procesador, junto con cualquier otra cosa, que init haya sido configurado para 
hacer.



3.3.2 Inicio de sesiones desde terminales

El inicio de sesiones desde terminales (a través de lineas seriales) y la 
consola (cuando no se está ejecutando X) son suministrados por el programa 
getty. Init inicia una instancia separada de getty por cada terminal en el que 
se esté permitido iniciar sesiones. Getty lee el nombre de usuario y ejecuta 
el programa login, el cual se encarga de leer la password. Si el nombre de 
usuario y la password son correctas, login ejecuta un intérprete de comandos. 
Cuando el intérprete de comandos finaliza, en el caso en que, por ejemplo, el 
usuario finaliza su sesión; o cuando, login finaliza, debido a que no 
concuerdan el nombre de usuario y la password, entonces init se entera de este 
suceso e inicia una nueva instancia de getty. El kernel no tiene noción sobre 
los inicio de sesiones, esto es totalmente manejado por los programas del 
sistema.


3.3.3 Syslog

El kernel y muchos programas del sistema, producen mensajes de errores, de 
advertencias y de otros tipos. La mayoría de las veces, es importante que 
puedan ser visualizados mas tarde, o tal vez mucho después, por lo que, tales 
mensajes deben ser guardados en un archivo. El programa que realiza esta tarea 
es syslog. Syslog puede ser configurado para ordenar los mensajes en 
diferentes archivos, de acuerdo a quien lo emite o al grado de importancia. 
Por ejemplo, los mensajes del kernel son frecuentemente dirigidos a un archivo 
separado de los demás, debido a que los mensajes del kernel son a menudo más 
importantes, y necesitan ser leídos regularmente para detectar problemas.



3.3.4 Ejecución de comandos periódicos: cron y at

Los administradores de sistemas y los usuarios, frecuentemente necesitan 
ejecutar comandos periódicamente. Como ejemplo, suponga que el administrador 
del sistema desea ejecutar un comando que elimine los archivos más antiguos de 
los directorios con archivos temporales (/tmp y /var/tmp); para evitar así, 
que el disco se llene; debido a que, no todos los programas, eliminan 
correctamente los archivos temporales que ellos mismos generan.

El servicio cron se configura para que realice la tarea anterior. Cada usuario 
tiene un archivo crontab, en donde se listan los conmandos que desea ejecutar 
y la fecha y hora que estos deben ser iniciados. El demonio cron se encarga 
con precisión, de iniciar cada comando, a la fecha y hora adecuada de acuerdo 
a lo especificado en cada archivo crontab.

El servicio at es similar a cron, pero este es únicamente de una sola vez: el 
comando es ejecutado a la hora especificada, pero esta ejecución no vuelve a 
repetirse.

Vea las páginas de manual de cron(1), crontab(5), at(1) y atd(8) para 
conocer más información en profundidad.


3.3.5 Interfase de usuario gráfico

UNIX y GNU/Linux no incorporan la interfase de usuario dentro del kernel; en 
su lugar, esta es implementada por programas a nivel de usuario. Esto se 
aplica tanto para ambientes gráficos como al modo texto.

Esta disposición hace que el sistema sea más flexible, pero tiene la 
desventaja, de que al ser simple implementar una interfase de usuario 
diferente para cada programa, hace al sistema difícil de aprender.

El ambiente gráfico principalmente utilizado con GNU/Linux se llama Sistema de 
Ventanas X (X para abreviar). X no implementa una interfase de usuario; solo 
implementa el sistema de ventanas, i.e., las herramientas con las cuales una 
interfase de usuario gráfica puede ser implementada. Algunos administradores 
de ventanas populares son: fvwm, icewm, blackbox y windowmaker. Existen 
también dos populares administradores de escritorios: KDE y Gnome.


3.3.6 Redes

Una red es el hecho de conectar dos o mas computadoras para que cada una pueda 
comunicarse con cualquier otra. Los métodos actuales de conexión y 
comunicación son significantemente complicados, pero el resultado final es 
muy útil.

Los sistemas operativos UNIX tienen muchas características de redes. Los 
principales servicios básicos (sistemas de archivos, impresión, copias de 
seguridad, etc) pueden ser realizados a través de la red. Utilizar estas 
características puede ayudar a que la administración del sistema sea mas 
fácil, debido a que permiten tener una administración centralizada, mientras 
aprovechamos los beneficios de la microcomputación y la computación 
distribuída, tales como costos bajos y mejor tolerancia a fallas.

De cualquier modo, este libro simplemente hecha un vistazo a la teoría de 
redes; vea La Guía  De Administración De Redes Con Linux para más información, 
incluyendo una descripción básica de como operan las redes.



3.3.7 Inicio de sesiones a través de la red

Los inicios de sesiones a través de la red trabajan de un modo un poco 
diferente con respecto al inicio de sesiones normales. Existe una linea serial 
física separada para cada terminal, a través de las cuales, es posible iniciar 
sesiones. Por cada persona iniciando una sesión a través de la red, existe una 
conexión de red virtual, y estas pueden ser de cualquier número (en cantidad). 
Por lo tanto, no es posible ejecutar a getty por separado por cada conexión 
virtual posible. Existen también, varias maneras diferentes para iniciar una 
sesión a través de la red, las principales en redes TCP/IP son telnet y rlogin 
[1] .

Los inicios de sesión a través de la red, tienen, en vez de una cantidad 
enorme de gettys, un demonio individual por tipo de inicio de sesión (telnet y 
rlogin tienen demonios separados), que se encuentran atentos (Listen) a todos 
los intentos de inicio se sesión entrantes. Cuando el demonio se notifica de 
un intento de inicio de sesión, inicia una nueva instancia de si mismo para 
atender el pedido individual; la instancia original continúa escuchando por 
otros intentos. La nueva instancia trabaja de manera similar a getty.

[1] N.d.T.: ssh es la manera segura, debido a la utilización de comunicación 
encriptada, de iniciar sesiones remotas actualmente.
3.3.8 Sistemas de archivos de red (NFS)

Una de las tareas más útiles que puede realizarse con los servicios de 
red, es compartir archivos a través de un sistema de archivos de red. El 
modelo cliente-servidor más utilizado para compartir archivos se llama Sistema 
de Archivos de Red (Network File System), o NFS, desarrollado por Sun 
Microsystems.

Con un sistema de archivos de red, cualquier operación sobre un archivo 
realizado por un programa en una máquina, es enviada a través de la red a otra 
computadora. Se "engaña" al programa, haciéndole creer que todos los archivos 
en la otra computadora se encuentran actualmente en la computadora en donde el 
programa se esté ejecutando. Con esta manera de trabajar, compartir 
información es extremadamente simple, ya que no se requiere modificaciones en 
el programa.

Otra manera popular de compartir archivos es a través de Samba 
(http://www.samba.org). Este protocolo (el SMB) permite compartir archivos con 
máquinas MS Windows (a través de redes Vecinas [Neighbourhood]). También es 
posible compartir impresoras con estas máquinas.


3.3.9 Correo

El correo electrónico es usualmente el método más popular para comunicarse a 
través de las computadoras. Una carta electrónica es almacenada en un archivo 
utilizando un formato especial, y programas de correos especiales son 
utilizados para enviar y leer las cartas.

Cada usuario tiene un buzón de correo entrante (un archivo con formato 
especial), en donde todos los correos nuevos son almacenados. Cuando alguien 
envía correos, el programa de correo localiza el buzón de correo receptor y 
agrega la carta al archivo de buzón de correo entrante. Si el buzón de correo 
receptor se encuentra en otra máquina, la carta es enviada a la otra máquina, 
la cual lleva la carta al buzón de correo como mejor crea conveniente.

El sistema de correo consiste de muchos programas. El transporte del correo a 
buzones de correo local o remoto es realizado por un programa (el agente de 
transporte de correo o MTA, sendmail y smail son dos ejemplos de estos), 
mientras que existen un sinnúmero de programas muy variados que los usuarios 
utlizan para leer y escribir correos (agentes de usuario de correo o MUA, pine 
y elm son ejemplos de estos). Los archivos de buzones de correo están 
usualmente ubicados en /var/spool/mail.


3.3.10 Imprimiendo

Solo una persona puede utilizar la impresora en un momento dado, pero no sería 
económico no compartir impresoras entre los usuarios. La impresora es por lo 
tanto administrada por software que implementan una cola de impresión: todas 
los trabajos de impresión son colocados dentro de una cola, y una vez que la 
impresora termina de imprimir una tarea, el próximo trabajo es enviado a la 
impresora automáticamente. Esto alivia al usuario de la organización de la 
cola de impresión y de luchar por el control de la impresora.

El software de cola de impresión también coloca (spools) los trabajos de 
impresión en disco, por ejemplo, el texto a imprimir es mantenido en un 
archivo, mientras que el trabajo se encuentre en la cola. Esto permite a los 
programas de aplicación entregar las tarea a imprimir rápidamente al 
software que administra la cola de impresión; así, las aplicaciones no tienen 
que esperar a que la tarea (job) esté actualmente impresa para poder continuar 
su ejecución. Esta manera de proceder es realmente conveniente, ya que permite 
enviar a imprimir una versión de un trabajo, y no tener que esperar a que esta 
sea impresa, antes de que pueda hacerse una versión nueva completamente 
revisada.


3.3.11 La distribución del sistema de archivos

El sistema de archivos está dividido en muchas partes; usualmente a través de 
las líneas de un sistema de archivos raíz con /bin, /lib, /etc, /dev, y 
algunos otros pocos directorios; un sistema de archivos /usr con programas y 
datos que no tendrán cambios; un sistema de archivos /var con datos que pueden 
cambiar (tales como los archivos de log); y un sistema de archivos /home para 
todos los archivos personales. Dependiendo de la configuración del hardware y 
de las decisiones del administrador del sistema, la división puede llegar a 
ser diferente; a pesar de esto, y a que la división es aconsejable, es también 
posible distribuir todos los archivos en un solo sistema de archivos.

En el Capítulo 4 se describe la distribución del sistema de archivos con 
algunos detalles; el Linux Filesystem Standart cubre esta distribución con más 
detalle.


