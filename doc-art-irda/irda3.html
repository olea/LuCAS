<html>
<head>
<title>Infrarrojos en Linux II: Linux-IRDA </title>
</head>

<body>
<!-- titulo del articulo -->
<h1>Linux-IRDA II: manejo de dispositivos infrarrojos</h1>
Autor: <i><b>Juan Antonio Martínez Castaño</b></i><br>
E-mail: <a href="mailto:jantonio@dit.upm.es">
<i><b>jantonio@dit.upm.es</b></i></a><br>
Web: <a href="http://www.dit.upm.es/~jantonio">
<i><b>http://www.dit.upm.es/~jantonio</b></i></a><br>
<hr>

<h3>Copyright</h3>
Este artículo es Copyright 2000 de Juan Antonio Martínez Castaño y se 
distribuye bajo las siguientes condiciones:
<ul>
<li> Su distribución mediante medios electrónicos es libre, siempre y
cuando se conserve el texto íntegro y en su formato HTML original, haciendo
especial mención a la conservación del mensaje de copyright
<li> El autor y dueño del copyright cede los derechos de publicación impresa
a Prensa Técnica S.L., autorizando a ésta a realizar las modificaciones al
texto que considere oportunas para su publicación
<li> La distribución o copia, total o parcial, en cualquier medio impreso por 
parte ajena a Prensa Técnica S.L. Está expresamente prohibida
<li> Ningún particular podrá poner este fichero en un servidor Web de acceso
público sin el consentimiento expreso del autor y de Prensa Técnica S.L.
</ul>

<hr>
<a name="#indice">
<h3>Indice</h3>
</a>
<ul>
<li> <a href="#entradilla">Entradilla</a>
<li> <a href="#introduccion">Introducción</a>
<li> <a href="#serial">Emulación de terminales</a>
<li> <a href="#ppp">Conexión a Internet</a>
<li> <a href="#lpt">Conexión a dispositivos de impresión</a>
<li> <a href="#lan">Emulación de Red Local</a>
<li> <a href="#obex">Transferencias con dispositivos móviles</a>
<li> <a href="#conclusiones">Resumen. Conclusiones</a>
<li> <a href="#referencias">Referencias</a>
</ul>
<hr>
<a name="entradilla">
<h3>Entradilla</h3>
</a>
<p> 
Como última entrega de la serie dedicada a los dispositivos Infrarrojos, 
describimos en éste artículo las diversas aplicaciones y utilidades de alto 
nivel de que dispone linux para manejo de dispositivos IrDA
</p>
<hr>
<a name="introduccion">
<h3>Introducción</h3>
</a>
<p>
	En anteriores entregas de esta serie dedicada al uso y configuración
de dispositivos infrarrojos, hemos visto cómo configurar nuestro sistema para que sea capaz de identificar y configurar los diversos dispositivos, desde mandos a distancia hasta los basados en el protocolo IrDA. En esta tercera y última entrega de la serie, procederemos a explicar cómo utilizar estos dispositivos y el software de que se dispone
</p>
<p>
	Aquellos lectores que hayan echado un vistazo al <i>IR-Howto</i>, podrán comprobar que dicho manual está realmente desfasado. Ni los dispositivos ni su funcionamiento coinciden con los de las versiones del núcleo actuales. Muchos de estos dispositivos tenían versión cliente y servidor, como el caso del soporte del protocolo IrLPT o el de IrLAN. La versión 2.2.14 y posteriores del núcleo unifican muchos de estos módulos, de manera que el usuario no tiene que preocuparse de cómo iniciar la conexión. 
</p>

<p>
<table border>
<tr><th>
<!-- texto del bocata -->
Desgraciadamente el Infrarrojos-Como está muy desfasado
</th></tr>
</table>
</p>
<p>
	Del mismo modo, el soporte de conexiones en modo socket de los puertos
IrDA no está descrito en ningún manual. El autor ha tenido que dedicar horas de
ingeniería inversa en los fuentes del núcleo y de las aplicaciones para identificar su funcionamiento. <br>
	Hace un mes ha sido editada una nueva revisión del IR-HOWTO. Esta edición, si bien corrige y actualiza bastantes errores, no está suficientemente actualizada. En este artículo se mencionarán las diferencias.<br>
	A menos que se especifique lo contrario, las opciones, ficheros e instrucciones citadas se aplican a la distribución RedHat 6.1 con núcleo 2.2.14 con el parche descrito en el número anterior. Se asume que el lector ha leído éste y que tiene el núcleo y ficheros de configuración correctamente establecidos
</p>
<p>
	Se ha dividido el artículo en diversos apartados, de menor a mayor nivel de complejidad. El lector interesado puede saltar directamente al tema correspondiente, si bien se recomienda una lectura completa antes de proceder a las pruebas.
</p>
<p>
	Del mismo modo, se ha obviado la descripción del modo FIR del protocolo:
muchos dispositivos no disponen de dicho modo, no se soportan todos los dispositivos, y su uso está restringido al funcionamiento con impresoras y en red local
</p>
<hr>

<a name="serial">
<h3>Emulación de terminales</h3>
</a>
<p>
	El primer paso, y el más sencillo es comprobar que el puerto IrDA es capaz de emular un puerto serie. El método más simple es el de poner dos equipos linux en conexión infrarroja. Comprobaremos mediante el examen del fichero 
<i>/proc/net/irda/discovery</i> que ambos equipos se conectan y reconocen
mutuamente. 
</p>

<p>
<table border>
<tr><th>
<!-- texto del bocata -->
El paso más sencillo es la comunicación entre equipos mediante la emulación de puerto serie
</th></tr>
</table>
</p>
<p>
	Acto seguido invocaremos el programa "minicom", y ajustaremos los parámetros de velocidad y de puerto, seleccionando </i>/dev/ircomm0</i> como interfaz de comunicaciones. Lo que se teclee en cada terminal deberá ser visto en el terminal opuesto, y viceversa. En caso de que esto no ocurra, verificaremos que el módulo <b>ircomm</b> e <b>ircomm-tty</i> estén cargados. En caso negativo, verificar la conexión y la configuración. Cuando éste dispositivo se carga correctamente, aparece en el <i>proc filesystem</i> la entrada 
<i>/proc/net/irda/ircom</i>
</p>
<p>
	El siguiente paso obvio consiste en hacer que el sistema sea capaz de lanzar un "login" sobre el terminal conectado al puerto IrDA. Para ello no tenemos sino que editar el fichero <i>/etc/inittab</i> tal y como ilustra el listado 1.
Una vez editado, procedemos a releer el fichero de configuración del proceso
init mediante el comando <i>"init q"</i>. El sistema nos responderá con el
familiar prompt de login.
</p>

<p>
<table border>
<tr><td>
<!-- texto del listado entre los -pre- -->
<pre>

# inittab       This file describes how the INIT process should set up
# the system in a certain run-level.

# Author:       Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
# Modified for RHS Linux by Marc Ewing and Donnie Barnes


# Default runlevel. The runlevels used by RHS are:
# 0 - halt (Do NOT set initdefault to this)
# 1 - Single user mode
# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)
# 3 - Full multiuser mode
# 4 - unused
# 5 - X11
# 6 - reboot (Do NOT set initdefault to this)

id:5:initdefault:  

# System initialization.
si::sysinit:/etc/rc.d/rc.sysinit

l0:0:wait:/etc/rc.d/rc 0
l1:1:wait:/etc/rc.d/rc 1
l2:2:wait:/etc/rc.d/rc 2
l3:3:wait:/etc/rc.d/rc 3
l4:4:wait:/etc/rc.d/rc 4
l5:5:wait:/etc/rc.d/rc 5
l6:6:wait:/etc/rc.d/rc 6

# Things to run in every runlevel.
ud::once:/sbin/update

# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -r now

# When our UPS tells us power has failed, assume we have a few minutes
# of power left.  Schedule a shutdown for 2 minutes from now.
# This does, of course, assume you have powerd installed and your
# UPS connected and working correctly.
pf::powerfail:/sbin/shutdown -f -h +2 "Power Failure; System Shutting Down"

# If power was restored before the shutdown kicked in, cancel it.
pr:12345:powerokwait:/sbin/shutdown -c "Power Restored; Shutdown Cancelled"


# Run gettys in standard runlevels
1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6

# spawn a login shell into irda device
T1:2345:respawn:/sbin/mgetty -r ircomm0

# Run xdm in runlevel 5
# xdm is now a separate service
x:5:respawn:/etc/X11/prefdm -nodaemon
</pre>
</td></tr>
<tr><th>Listado 1: Fichero de configuración /etc/inittab</th></tr>
</table>
</p>
<p>
	En caso de problemas es casi seguro que el conflicto se deba a una errónea negociación del protocolo ( La versión probada no era capaz de manejar la línea DSR ) o bien en el desajuste de velocidades de cada puerto.
</p>

<hr>
<a name="ppp">
<h3>Conexión a Internet</h3>
</a>
<p>
	Los lectores del número anterior de Linux Actual recordarán que el 
protocolo IrCOMM es, junto con el IrLPT el único que el estandard IrDA obliga
a que toda implementación incorpore. Por ello, en muchos casos la conexión vía
emulación de puerto serie será la única opción que nos permita la comunicación
con otros equipos. Este caso es sensiblemente cierto cuando deseamos interactuar con sistemas Windows 9X.
</p>

<p>
<table border>
<tr><th>
<!-- texto del bocata -->
Para la conexión mediante <i>pppd</i> será preciso ajustar los timeouts
</th></tr>
</table>
</p>
<p>
	En estos casos se suelen utilizar programas del tipo "laplink" para efectuar las transferencias de ficheros. 
</p>
<p>
	Una alternativa es la utilización del protocolo PPP para emular una red local a través del puerto serie. En otros artículos de Linux Actual se ha explicado cómo establecer conexiones a través de PPP, tanto en modo cliente como en modo servidor, por lo que no nos extenderemos al respecto. Simplemente indicar que en función del núcleo y de la versión de <i>pppd</i> puede ser necesario establecer en el fichero /etc/ppp/ppp.options la opción -rtscts
</p>
<p>
	Muchos teléfonos móviles poseen emulación de modem incorporada, no siendo necesario para su conexión a internet más que el cable adaptador. A su vez, los teléfonos de gama alta soportan conexión por puerto de infrarrojos. Este es el caso del Nokia 9110, Siemens S25 o Motorola TimePort ( Estos son los modelos que el autor ha testeado. Para una lista completa consultar la página web citada en las referencias). Desde estos teléfonos móviles y mediante el puerto de infrarrojos, es perfectamente posible efectuar conexiones a la Red de Redes.
</p>
<p>
	No obstante, no debemos olvidar que debido a la naturaleza intrínseca del sistema GSM no se pueden obtener velocidades de transferencia superiores a 9600 baudios. A este respecto, es preciso hacer constar que para hacer llamadas de datos desde móvil no es preciso contratar un nuevo número, sino sólo en el caso de querer <i>recibir</i> llamadas de datos provenientes de un teléfono fijo. Este es un típico caso de publicidad confusa -cuando no engañosa-
</p>
<p>
	En cualquier caso y debido a la lentitud del sistema, es posible que en el periodo de negociación del PPP se pierda el enlace debido a fallos de <i>timeout</i>. El lector deberá hacer pruebas y ajustar el valor de timeout al que  juzgue más conveniente.
</p>
<p>
	Por último, para los usuarios de MoviStar, informar de que telefónica posee dos números de teléfono para acceso a InterNet desde móvil: el 550 para llamadas a infovía con proveedor propio, y el 551 para navegación web (login y password "infovia" ). A ambas se aplica la tarifa estandard de llamada de móvil a móvil en la franja horaria correspondiente
</p>
<hr>

<a name="lpt">
<h3>Conexión con dispositivos de impresión</h3>
</a>
<p>
	Leyendo el IR-HOWTO encontramos que el funcionamiento del soporte IrLPT en linux está basado en tres módulos: irlpt.o para gestión, irlpt_server.o para servidor de impresión (simulación de impresora) e irlpt_client.o para el cliente
<br>
En los nuevos núcleos, esto ya no es así: Linux agrupa ahora todas las funcionalidades de IrCOMM e IrLPT en un único módulo. De hecho la única diferencia entre los dispositivos es el <i>minor number</i> asignado al dispositivo. La razón es muy sencilla: los dos protocolos son prácticamente idénticos, difiriendo nada más que en la forma de gestionar las líneas de datos auxiliares. Salvo en la creación de dispositivos especiales, todas las descripciones del manejo de impresoras en el IR-HOWTO son válidas. Resumimos los pasos:
<ul>
<li> En el cliente, esto es, el que solicita los servicios de impresión, basta con asignar en el fichero <i>/etc/printcap</i> como dispositivo de salida el descriptor /dev/irlpt0, que ha sido creado siguiendo las instrucciones descritas en el número anterior
<li> En el servidor, que es quien acepta los trabajos de impresión, basta con poner el siguiente bucle a la escucha en el dispositivo de infrarrojos:
  <pre>
  #/bin/sh
  #
  while (true)
  do
  cat /dev/irlpt0 | lpr
  done  
  </pre> 
</ul>
</p>

<p>
<table border>
<tr><th>
<!-- texto del bocata -->
El núcleo 2.2.14 integra en uno solo los protocolos IrCOMM e IrLPT
</th></tr>
</table>
</p>
<p>
El uso de IrDA como simulador de impresoras, permite hacer creer al resto de 
los sistemas de que se dispone de una impresora de estas características, y redirigir convenientemente los diversos trabajos de impresión que en ésta se originen.
</p>
<hr>

<a name="lan">
<h3>Emulación de red Local</h3>
</a>
<p>
	Otro punto importante en el que difiere el HOWTO de las últimas implementaciones IrDA del núcleo es el tema de la gestión de red local: El manual describe una conexión punto a punto, basada en un módulo servidor y otro cliente, cada uno ejecutandose en una máquina. La nueva implementación permite no sólo la conexión punto a punto, sino también la multipunto, pudiendo establecer diversas combinaciones. No obstante, la experiencia del autor indica que es preferible usar un enlace punto a punto.
</p>

<p>
<table border>
<tr><th>
<!-- texto del bocata -->
Linux-IrDA puede manejar tanto redes multipunto como punto-a-punto
</th></tr>
</table>
</p>
<p>
	De lo descrito anteriormente, se deduce que los módulos <i>irlan_server</i> e <i>irlan_client</i>, ya no existen. En su lugar, un único módulo <i>irlan</i> gestiona todo lo relacionado con la red
</p>
<p>
	Para la conexión multipunto, no es necesario sino asignarle al dispositivo <i>irda0</i> una dirección IP y una máscara de red. No obstante, esta configuración da bastantes problemas de compatibilidad. Por ello, en el código fuente del núcleo se recomienda usar conexiones punto-punto múltiples. Para hacerlo basta con incluir el módulo <i>irlan</i> en el fichero <i>/etc/irda/drivers</i>, tal y como se indica en el listado 2

<p>
<table border>
<tr><td>
<!-- texto del listado entre los -pre- -->
<pre>

#! /bin/sh
#
# drivers
#
# Initialize and shutdown IrDA device drivers.
#
# This script should be invoked with two arguments.  The first is the
# action to be taken, either "start", "stop", or "restart".
#

action=$1
device=$2

case "${action:?}" in
'start')
	irattach /dev/ttyS1          # The second serial port is an IrDA port
	# irattach /dev/ttyS0 -d actisys+ # Attach an ActiSys 220L+ dongle to the first serial port
	# irattach /dev/ttyS0 -d tekram
	# insmod pc87108             # If your machine as a pc87108 FIR chipset
	# modprobe uircc             # Sharp UIRCC chipset
	
	# start irda lan manager
	modprobe irlan
    ;;
'stop')
	killall irattach             # ... or something. Currently not used
    ;;
'restart')
	/sbin/ifconfig ${device:?} down up
    ;;
esac
</pre>
</td></tr>
<tr><th>Listado 2: Fichero de configuración IrDA con soporte de IrLAN </th></tr>
</table>
</p>
	Cada vez que un nuevo interfaz de red IrDA es detectado por el puerto de infrarrojos, se crea al vuelo un dispositivo <b>irlanX</b>, donde X varía de 0 a 15 ( recordemos que IrDA soporta hasta 16 dispositivos interconectados ). 
<br>
A su vez, el demonio <i>irmanager</i> detecta la nueva conexión y realiza una llamada al comando <i>/etc/irda/network</i> pasando como parámetro el nombre del dispositivo detectado. Recordemos que cada dispositivo de conexión irlanX es del tipo punto-a-punto.
</p>
<p>
	En el listado 3 se encuentra el contenido que debe tener el fichero /etc/irda/network para ser compatible con la distribución RedHat 6.1. Otras distribuciones deberán modificar y personalizar dicho script

<p>
<table border>
<tr><td>
<!-- texto del listado entre los -pre- -->
<pre>

#! /bin/sh
#
# network
#
# Initialize or shutdown IrLAN ethernet device drivers
#
# This script should be invoked with two arguments.  The first is the
# action to be taken, either "start", "stop", or "restart".  The
# second is the network interface name.

action=$1
device=$2

cd /etc/sysconfig/network-scripts

case "${action:?}" in
'start')
	/sbin/ifup ${device}
    ;;
'stop')
	/sbin/ifdown ${device}
    ;;
'restart')
    /sbin/ifconfig ${device:?} down up
    ;;
esac
</pre>
</td></tr>
<tr><th>Listado 3: Fichero /etc/irda/network</th></tr>
</table>
</p>
	Evidentemente, en el directorio <i>/etc/sysconfig/network-scripts</i>, debe existir el correspondiente fichero <i>ifcfg-irlanX</i> con los datos de configuracion del interfaz. 
</p>
<p>
	Nada impide que el puerto de red utilice DHCP para la configuración. Es más: desde el núcleo 2.2.14, la emulación de red sobre dispositivos IrDA es programable mediante sockets, y cumple con todos los requerimientos que una red local necesita. Unicamente hacer constar, que -salvo que se utilice el modo FIR- la velocidad de transferencia será ligeramente menor que la velocidad teórica a la que esté ajustado el dispositivo IrDA.<br>
	No obstante, y debido a que IrDA está en constante evolución, es recomendable no intentar mezclar conexiones y funcionalidades: En ocasiones los diversos servicios IrDA colisionan entre sí, lo que puede llegar en casos extremos ( al autor le ocurrió al interconexionar por infrarrojos 6 dispositivos ) a bloquear el sistema.
</p>

<p>
<table border>
<tr><th>
<!-- texto del bocata -->
Linux incorpora la posibilidad de añadir a IrLAN protocolos de compresión de datos
</th></tr>
</table>
</p>
<p>
	Una característica específica de Linux y la emulación de red es la posibilidad de incluír un protocolo de compresión de datos en línea, sin más que cargar el módulo irda_deflate.o. No obstante, y como hemos dicho, dicha opción sólo es soportada por Linux
</p>
<p>
	Otra característica de la emulación de red es la forma en que Linux gestiona los sockets IrDA. A las ya habituales familias AF_INET y AF_UNIX, el núcleo Linux añade la AF_IRDA. A su vez, en lugar de puertos de conexión, tenemos
<i>servicios</i>, entre los que se incluyen los ya citados, junto con OBEX, 
el protocolo de intercambio estándard de IrDA
</p>
<hr>

<a name="obex">
<h3>Transferencias de datos con dispositivos móviles</h3>
</a>
<p>
	Todo lo descrito hasta ahora nos permite utilizar el puerto IrDA a un nivel bajo: puertos serie, impresoras, interfaces de red.... falta algo en el protocolo, y no es sino la posibilidad de añadir una capa de abstracción que permita olvidarse del mecanismo subyacente a la comunicación y centrar el problema en los datos en sí
</p>
<p>
	OBEX ( OBject EXange Protocol ) es un mecanismo por el que diversos 
sistemas pueden compartir datos entre sí. Al igual que en sus protocolos hermanos de red, como el HTTP, está basado en la declaración de mimetypes y una sintaxis tipo XML para la definición de los datos. El lector recordará que en el número anterior de Linux Actual se dijo que OBEX no formaba parte del núcleo Linux, sino que se realizaba mediante bibliotecas. Si bien esto es cierto, las últimas revisiones del núcleo incorporan cambios para el manejo del protocolo. El más espectacular es la inclusión de los sockets tipo AF_IRDA para su manejo mediante la
biblioteca estandard de manejo de red local
</p>
<p>
	OBEX es utilizado por la mayor parte de dispositivos palmtop y teléfonos móviles, para la transmisión de ficheros, tarjetas de visita, entradas de agenda y calendario, etc. No obstante nunca se diseño pensando en la comunicación con móviles, sino que para este cometido se diseñó un protocolo especial, denominado IrMC ( Infrared for Mobile Communication ). No obstante, ante las ventajas evidentes de interoperabilidad, IrMC sólo ha tenido reflejo en algunos teléfonos móviles de Nokia, como el 5110 y el 6110. Todos los demás han dejado IrMC para 
utilizar IrOBEX en su lugar.
</p>

<p>
<table border>
<tr><th>
<!-- texto del bocata -->
IrOBEX es el estandard de facto de intercambio de objetos entre equipos portátiles
</th></tr>
</table>
</p>
<p>
	El Manual de la descripción del protocolo es bastante complejo, pues
sigue la estructura típica de una descripción de un DTD de XML. Vamos a estudiar los casos más frecuentes de tipos de datos que son utilizados en las comunicaciones entre portátiles y teléfonos móviles o palmtops
<ul>
<li> El primero es el Objeto <i>VCARD</i>, o tarjeta de visita. Muchos de los lectores empiezan a ver signaturas en el correo electrónico como las que indica el listado 4. Este listado ilustra la estructura típica de un objeto VCARD y su 
sintaxis

<p>
<table border>
<tr><td>
<!-- texto del listado entre los -pre- -->
<pre>
begin:vcard
	version:2.1
	n:Martínez Castaño;Juan Antonio
	tel;fax:913367366
	tel;home:911234567
	tel;work:913367366x416
	x-mozilla-html:FALSE
	org:ETSI Telecomunicación;DIT
	email;internet:jantonio@dit.upm.es
	title:Maestro de Laboratorio
	adr;quoted-printable:;;ETSI Telecomunicaci=F3n=0D=0ACiudad Universitaria;Madrid;Madrid;28040;Spain
	x-mozilla-cpt:;0
	fn:Juan Antonio Martínez
end:vcard
</pre>
</td></tr>
<tr><th>Listado 4: Ejemplo de objeto VCARD </th></tr>
</table>
</p>

<li> Del mismo modo existe una definición de objeto para agenda y calendario,
denominado VCAL. En la documentación incluída en el CD se incluye una definición
completa del protocolo OBEX

<li> Existe la posibilidad de transmitir además ficheros de cualquier tipo, 
incluyendo gráficos, sonidos, etc

<li> OBEX no es solo un protocolo de intercambio de ficheros: el nuevo núcleo de Linux permiten programar aplicaciones que manejen obex como si de sockets se tratara. Existe una librería <i>libobex</i> que contiene todas las primitivas necesarias
</ul>
</p>

<p>
<table border>
<tr><th>
<!-- texto del bocata -->
La especificación de objetos OBEX recuerda mucho al protocolo XML
</th></tr>
</table>
</p>
<p>
	En las referencias se cita página principal del proyecto IrOBEX. En
sus subdirectorios encontraremos las referencias a dos trabajos sobre este
protocolo. ( recuerdese, que IrOBEX no está implementado como demonio o como
módulo del núcleo, sino que es una aplicación autónoma
<ul>
<li> La primera implementación constituye las Bibliotecas OBEX y las utilidades
de modo texto. Destaca por su sencillez el programa <i>irobex_palm3</i>, que si
bien en un principio fué diseñado para comunicaciones estandard con las Palm
Pilot, es actualmente el programa de líneas de comandos más utilizado para realizar transferencias OBEX
<li> El segundo es una interfaz gráfica, escrita en Python y GTK para el manejo de envio y recepción de datos OBEX desde la interfaz gráfica. Se le denomina
<i>PyOBEX</i>. La figura ilustra la apariencia del programa
</ul>
</p>
<p>
	El CD-Rom incluye las últimas versiones de irobex y pyobex. En función
de la versión del núcleo es posible que sea preciso retocar alguno de los
fuentes proporcionados. En particular, será preciso disponer de una versión
actualizada de Pyton, que soporte conexiones mediante sockets IrDA. En caso de
no disponer de dicha versión, en la página web citada en las referencias se dispone del código fuente de python, convenientemente parcheado.
</p><p>
Una última salvedad: El programa pyobex está compilado con GTK, y en su fichero de configuración por defecto, presupone que el usuario utiliza GNOME como escritorio... aunque es posible reconfigurarlo para los usuarios de KDE. Como siempre, remitimos a la documentación sobre los programas
</p>
<hr>

<a name="conclusiones">
<h3>Conclusiones</h3>
</a>
	Como el lector habrá podido deducir Linux-IrDA es un proyecto actualmente en fase de reelaboración. Esta serie de artículos han intentado incluír los
aspectos más relevantes de la versión actual del núcleo Linux. Los trabajos
actuales pasan por los siguientes puntos:
<ul>
<li> Conseguir la compatibilidad plena y simultaneidad de protocolos. Actualmente algunos protocolos no funcionan concurrentemente, como pueda ser el caso de la emulación de red y de terminal. En otros hay problemas de compatibilidad hacia
atrás, como en el caso del protocolo de impresión. Linux-IrDA es uno de los proyectos estrella del nuevo núcleo 2.4
<li> Eliminar los problemas de concurrencia entre conexiones. Todo aquel que conecte entre sí más de dos dispositivos similares a la vez observará problemas, de comunicación, especialmente en el manejo del emulador de puerto serie y en las transferencias OBEX. No olvidemos que el estandard define que deben poder conectarse hasta 16 equipos simultaneamente....
<li> Implementación completa del protocolo. Esto incluye el protocolo IrMC, y la especificación completa del interfaz de sockets
<li> finalización de los programas que constituyen el interfaz de usuario, especialmente el caso de PyOBEX
</ul>
<p>
	No obstante, sólo la lectura de este artículo hace ver hasta al más renuente, que la implementación IrDA de Linux va muy por delante de la de otros sistemas, que la red local multipunto y el Socket API son palabras desconocidas en otros entornos donde -a duras penas- sólo funciona la emulación de terminal
</p>

<p>
<table border>
<tr><th>
<!-- texto del bocata -->
Linux-IrDA constituye la implementación más completa de este protocolo
</th></tr>
</table>
</p>
<p>
	Para empezar a experimentar, lo mejor es una pareja PalmPilot + ordenador portátil con IrDA. Existen suficientes herramientas -y muy probadas- para ambas plataformas. La conexión sin hilos entre ordenador de sobremesa, portatil, agenda y teléfono móvil, actuando de forma conjunta a las órdenes del "Maestro Tux" es un espectáculo digno de verse
</p>
<hr>

<a name="referencias">
<h3>Referencias</h3>
</a>
<ul>
<li> Desgraciadamente el InfraRed-HOWTO está muy atrasado, y no contempla las
últimas actualizaciones e implementaciones. No obstante continúa siendo la
principal fuente de referencia sobre la instalación y configuración. En este
artículo se describen las principales diferencias, especialmente en lo que a
los nombres y descriptores de dispositivos se refiere
<li> La página oficial del proyecto Linux-IrDA es:<br>
<a href="http://www.cs.uit.no/linux-irda">http://www.cs.uit.no/linux-irda</a>
En ella, el lector encontrará información actualizada sobre el proyecto, lista
de dispositivos soportados y nivel de compatibilidad, así como diversos enlaces
listas de correo y documentación
<li> La página oficial sobre IrDA es:<br>
<a href="http://www.irda.org">http://www.irda.org</a>. Allí encontrará el lector datos sobre el protocolo, detalles técnicos, lista de participantes en el
consorcio, etc...
<li> El proyecto Open-OBEX tiene su propia página:
<a href="www.ravioli.pasta.cs.uit.no/open-obex">www.ravioli.pasta.cs.uit.no/open-obex</a>. Allí encontrará el lector datos sobre el estado del arte, y diversos
programas de intercambio de datos a través de este protocolo
<li> En el CD-Rom que se acompaña con la revista se incluyen todos los programas
aquí detallados, así como una copia de la página web del proyecto Linux-IrDA
</ul>
<hr>
</body>
</html>
