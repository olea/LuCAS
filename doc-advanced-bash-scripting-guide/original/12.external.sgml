  <chapter id="external">
      <title>External Filters, Programs and Commands</title>

      <para>Standard UNIX commands make shell scripts more versatile. The
	power of scripts comes from coupling system commands and shell
	directives with simple programming constructs.</para>

      <sect1 id="basic">
        <title>Basic Commands</title>

      <variablelist id="basiccommands">
        <title><anchor id="basiccommands1">Command Listing</title>

	<varlistentry>
	  <term><anchor id="lsref"><command>ls</command></term>
	  <indexterm>
	    <primary>ls</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ls</secondary>
	  </indexterm>
	  <listitem>
	    <para>The basic file <quote>list</quote> command. It is all too easy
	      to underestimate the power of this humble command. For
	      example, using the <option>-R</option>, recursive option,
	      <command>ls</command> provides a tree-like listing of
	      a directory structure. Other interesting options are
	      <option>-S</option>, sort listing by file size,
	      <option>-t</option>, sort by file modification time, and
	      <option>-i</option>, show file inodes (see <xref
	      linkend="idelete">).</para>

	    <example id="ex40">
	      <title>Using <command>ls</command> to create a table of contents
		for burning a <abbrev>CDR</abbrev> disk</title>
	      <programlisting>&ex40;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="catref"><command>cat</command></term>
	  <term><command>tac</command></term>
	  <indexterm>
	    <primary>cat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cat</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tac</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>cat</command>, an acronym for
	    <wordasword>concatenate</wordasword>,
	      lists a file to <filename>stdout</filename>. When
	      combined with redirection (<token>></token> or
	      <token>>></token>), it is commonly used to concatenate
	      files.

	        <programlisting>cat filename cat file.1 file.2 file.3 &gt; file.123</programlisting>

              The <option>-n</option>
	      option to <command>cat</command> inserts consecutive
	      numbers before all lines of the target file(s). The
	      <option>-b</option> option numbers only the non-blank
	      lines. The <option>-v</option> option echoes nonprintable
	      characters, using <token>^</token> notation.</para>

            <para>See also <xref linkend="lnum"> and <xref linkend="rot13">.</para>

	    <para><command>tac</command>, is the inverse of
	      <wordasword>cat</wordasword>, listing a file backwards from its end.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>rev</command></term>
	  <indexterm>
	    <primary>rev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rev</secondary>
	  </indexterm>
	  <listitem>
	    <para>reverses each line of a file, and outputs to
	      <filename>stdout</filename>.  This is not the same effect
	      as <command>tac</command>, as it preserves the order of
	      the lines, but flips each one around.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>cat file1.txt</userinput>
<computeroutput>This is line 1.
 This is line 2.</computeroutput>


<prompt>bash$ </prompt><userinput>tac file1.txt</userinput>
<computeroutput>This is line 2.
 This is line 1.</computeroutput>


<prompt>bash$ </prompt><userinput>rev file1.txt</userinput>
<computeroutput>.1 enil si sihT
 .2 enil si sihT</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cp</command></term>
	  <indexterm>
	    <primary>cp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cp</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the file copy command. <userinput>cp file1
	      file2</userinput> copies <filename>file1</filename>
	      to <filename>file2</filename>, overwriting
	      <filename>file2</filename> if it already exists (see <xref
	      linkend="ex42">).</para>

	     <tip><para>Particularly useful are the <option>-a</option>
	       archive flag (for copying an entire directory tree)
	       and the <option>-r</option> and <option>-R</option>
	       recursive flags.</para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mv</command></term>
	  <listitem>
	    <para>This is the file <emphasis>move</emphasis> command. It
	      is equivalent to a combination of <command>cp</command>
	      and <command>rm</command>. It may be used to move multiple
	      files to a directory, or even to rename a directory. For
	      some examples of using <command>mv</command> in a script,
	      see <xref linkend="rfe"> and <xref linkend="rn">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rm</command></term>
	  <indexterm>
	    <primary>rm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rm</secondary>
	  </indexterm>
	  <listitem>
	    <para>Delete (remove) a file or files. The <option>-f</option>
	      forces removal of even readonly files.</para> 

	    <warning><para>When used with the recursive flag
	      <option>-r</option>, this command removes files all the way
	      down the directory tree.</para></warning>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rmdir</command></term>
	  <indexterm>
	    <primary>rmdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rmdir</secondary>
	  </indexterm>
	  <listitem>
	    <para>Remove directory. The directory must be empty of
	      all files, including <anchor id="dotfilesref"> invisible
	      <quote>dotfiles</quote>,

		<footnote><para>These are files whose names begin with
		  a dot, such as <filename>~/.Xdefaults</filename>. Such
		  filenames do not show up in a normal
		  <command>ls</command> listing, and they cannot
		  be deleted by an accidental <command>rm -rf
		  *</command>. Dotfiles are generally used as
		  setup and configuration files in a user's home
		  directory.</para></footnote>

	      for this command to succeed.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mkdir</command></term>
	  <indexterm>
	    <primary>mkdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkdir</secondary>
	  </indexterm>
	  <listitem>
	    <para>Make directory, creates a new directory.
	      <userinput>mkdir -p project/programs/December</userinput>
	      creates the named directory. The
	      <replaceable>-p</replaceable> option automatically creates
	      any necessary parent directories.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="chmodref"><command>chmod</command></term>
	  <indexterm>
	    <primary>chmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chmod</secondary>
	  </indexterm>
	  <listitem>

	    <para>Changes the attributes of an existing file (see <xref
	      linkend="ex44">).</para>

	    <para><programlisting>chmod +x filename
# Makes "filename" executable for all users.

chmod u+s filename
# Sets "suid" bit on "filename" permissions.
# An ordinary user may execute "filename" with same privileges as the file's owner.
# (This does not apply to shell scripts.)</programlisting></para>

	    <para><programlisting>chmod 644 filename
# Makes "filename" readable/writable to owner, readable to
# others
# (octal mode).</programlisting></para>

	    <para><programlisting>chmod 1777 directory-name
# Gives everyone read, write, and execute permission in directory,
# however also sets the "sticky bit".
# This means that only the owner of the directory,
# owner of the file, and, of course, root
# can delete any particular file in that directory.</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chattr</command></term>
	  <indexterm>
	    <primary>chattr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chattr</secondary>
	  </indexterm>
	  <listitem>
	    <para>Change file attributes. This has the same effect
	      as <command>chmod</command> above, but with a
	      different invocation syntax, and it works only on an
	      <emphasis>ext2</emphasis> filesystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ln</command></term>
	  <listitem>

	    <para>Creates links to pre-existings files. Most often used
	      with the <option>-s</option>, symbolic or
	      <quote>soft</quote> link flag. This permits referencing
	      the linked file by more than one name and is a superior
	      alternative to aliasing (see <xref linkend="ex18">).</para>

	      <para><userinput>ln -s oldfile newfile</userinput>
		links the previously existing
		<filename>oldfile</filename> to the newly created link,
		<filename>newfile</filename>.</para>

	  </listitem>
	</varlistentry>

      </variablelist>

        </sect1> <!-- End Basic Commands -->


      <sect1 id="moreadv">
        <title>Complex Commands</title>

      <variablelist id="cclisting">
        <title><anchor id="cclisting1">Command Listing</title>

	<varlistentry>
	  <term><anchor id="findref"><command>find</command></term>
	  <indexterm>
	    <primary>find</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>find</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>{}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>\;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\;</secondary>
	  </indexterm>

	  <listitem>
	    <para>-exec <replaceable>COMMAND</replaceable> \;</para>
	    <para>Carries out <replaceable>COMMAND</replaceable> on
	      each file that <command>find</command> scores a hit
	      on.  <replaceable>COMMAND</replaceable> terminates
	      with <token>\;</token> (the <token>;</token>
	      is escaped to make certain the shell passes it to
	      <command>find</command> literally, which concludes the
	      command sequence). If <replaceable>COMMAND</replaceable>
	      contains <token>{}</token>, then <command>find</command>
	      substitutes the full path name of the selected file.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>find ~/ -name '*.txt'</userinput>
<computeroutput>/home/bozo/.kde/share/apps/karm/karmdata.txt
 /home/bozo/misc/irmeyc.txt
 /home/bozo/test-scripts/1.txt</computeroutput>
	      </screen>
	  </para>

	  <para>
	  <programlisting>find /home/bozo/projects -mtime 1
# Lists all files in /home/bozo/projects directory tree
# that were modified within the last day.</programlisting>
          </para>



	    <para><programlisting>find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

# Finds all IP addresses (xxx.xxx.xxx.xxx) in /etc directory files.
# There a few extraneous hits - how can they be filtered out?

# Perhaps by:

find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \
 | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
# [:digit:] is one of the character classes
# introduced with the POSIX 1003.2 standard. 

# Thanks, S.C. 
</programlisting></para>


            <caution><para>The <option>-exec</option> option to
	      <command>find</command> should not be confused with the <link
	      linkend="execref">exec</link> shell builtin.</para></caution>

	    <example id="ex57">
	      <title><command>Badname</command>, eliminate file names
		in current directory containing bad characters and <link
		linkend="whitespaceref">whitespace</link>.</title>
	      <programlisting>&ex57;</programlisting>
	    </example>

	    <example id="idelete">
	      <title>Deleting a file by its <emphasis>inode</emphasis>
	        number</title>
	      <programlisting>&idelete;</programlisting>
	    </example>

	    <para>See <xref linkend="ex48">, <xref linkend="ex58">,
	      and <xref linkend="findstring"> for scripts using
	      <command>find</command>. Its manpage provides more detail
	      on this complex and powerful command.</para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>xargs</command></term>
	  <indexterm>
	    <primary>xargs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>xargs</secondary>
	  </indexterm>
	  <listitem>
	    <para>A filter for feeding arguments to a command, and also a tool for
	      assembling the commands themselves. It breaks a data
	      stream into small enough chunks for filters and commands
	      to process.  Consider it as a powerful replacement
	      for backquotes.  In situations where backquotes fail
	      with a <errorname>too many arguments</errorname>
	      error, substituting <command>xargs</command> often
	      works. Normally, <command>xargs</command> reads from
	      <filename>stdin</filename> or from a pipe, but it can also
	      be given the output of a file.</para>
            
	    <para>The default command for <command>xargs</command> is
	      <link linkend="echoref">echo</link>.</para>

	    <para><userinput>ls | xargs -p -l gzip</userinput> <link
	      linkend="gzipref">gzips</link> every file in current
	      directory, one at a time, prompting before each
	      operation.</para>

	    <tip>
	    <para>An interesting <command>xargs</command>
	      option is <option>-n <replaceable>NN</replaceable></option>,
	      which limits to <replaceable>NN</replaceable> the number
	      of arguments passed.</para>
	    <para><userinput>ls | xargs -n 8 echo</userinput> lists the files in the
	      current directory in <literal>8</literal> columns.</para>
	    </tip>  
	      
	      
	    <tip>
	    <para>Another useful option is
	      <option>-0</option>, in combination with <command>find
	      -print0</command> or <command>grep -lZ</command>. This
	      allows handling arguments containing whitespace or
	      quotes.</para>
	      
	    <para>
	    <userinput>find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f</userinput>
	    </para>
	    
	    <para>
	    <userinput>grep -rliwZ GUI / | xargs -0 rm -f</userinput>
	    </para>

	    <para>Either of the above will remove any file containing <quote>GUI</quote>.
	      <emphasis>(Thanks, S.C.)</emphasis></para>
	    </tip>




	    <example id="ex41">
	      <title>Logfile using <command>xargs</command> to monitor system log</title>
	      <programlisting>&ex41;</programlisting>
	    </example>	    

	    <example id="ex42">
	      <title><command>copydir</command>, copying files in current
		directory to another, using <command>xargs</command></title>
	      <programlisting>&ex42;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="exprref"><userinput>expr</userinput></term>
	  <indexterm>
	    <primary>expr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expr</secondary>
	  </indexterm>
	  <listitem>
	    <para>All-purpose expression evaluator:
	      Concatenates and evaluates the arguments according
	      to the operation given (arguments must be separated
	      by spaces). Operations may be arithmetic, comparison,
	      string, or logical.</para>

	    <variablelist>
	      <varlistentry>
		<term><userinput>expr 3 + 5</userinput></term>
		<listitem>
		  <para>returns <literal>8</literal></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>expr 5 % 3</userinput></term>
		<listitem>
		  <para>returns 2</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>y=`expr $y + 1`</userinput></term>
		<listitem>
		  <para>Increment a variable, with the same effect
		    as <userinput>let y=y+1</userinput> and
		    <userinput>y=$(($y+1))</userinput> This is an
		    example of <link linkend="arithexpref">arithmetic
		    expansion</link>.</para>

		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><anchor id="expextrsub"><userinput>z=`expr substr
		$string $position $length`</userinput></term>
		<listitem>
		  <para>Extract substring of $length characters, starting
		    at $position.</para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <example id="ex45">
	      <title>Using <command>expr</command></title>
	      <programlisting>&ex45;</programlisting>
	    </example>	    
	    
	    <important>
	    <para>The <link linkend="nullref">:</link> operator
	      can substitute for <command>match</command>. For example,
	      <userinput>b=`expr $a : [0-9]*`</userinput> is the
	      exact equivalent of <userinput>b=`expr match $a
	      [0-9]*`</userinput> in the above listing.</para>
	    <para><programlisting>&ex45a;</programlisting></para>
	      </important>

	  </listitem>
	</varlistentry>

       </variablelist>

      <para><link linkend="perlref">Perl</link> and
	<link linkend="sedref">sed</link> have far superior string
	parsing facilities.  A short <command>Perl</command> or
	<command>sed</command> <quote>subroutine</quote> within a script
	(see <xref linkend="wrapper">) is an attractive alternative to
	using <command>expr</command>.</para>

      <para>See <xref linkend="String-Manipulation"> for more on string
        operations.</para>


	</sect1> <!-- End Complex Commands -->



      <sect1 id="timedate">
        <title>Time / Date Commands</title>

       <variablelist id="tdlisting">
         <title><anchor id="tdlisting1">Command Listing</title>

	<varlistentry>
	  <term><anchor id="dateref"><command>date</command></term>
	  <indexterm>
	    <primary>date</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>date</secondary>
	  </indexterm>
	  <listitem>
	    <para>Simply invoked, <command>date</command> prints the date and
	      time to <filename>stdout</filename>. Where this command gets
	      interesting is in its formatting and parsing options.</para>

	    <example id="ex51">
	      <title>Using <command>date</command></title>
	      <programlisting>&ex51;</programlisting>
	    </example>	    	   

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>zdump</command></term>
	  <indexterm>
	    <primary>zdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>time zone dump</secondary>
	  </indexterm>
	  <listitem>
	    <para>Echoes the time in a specified time zone.</para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>zdump EST</userinput>
<computeroutput>EST  Tue Sep 18 22:09:22 2001 EST</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="timref"><command>time</command></term>
	  <indexterm>
	    <primary>time</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>time</secondary>
	  </indexterm>
	  <listitem>

	    <para>Outputs very verbose timing statistics for executing a command.</para>

	    <para><userinput>time ls -l /</userinput> gives something like this:
<screen><computeroutput>0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k
 0inputs+0outputs (149major+27minor)pagefaults 0swaps</computeroutput></screen>
	  </para>

	  <para>See also the very similar <link
	    linkend="timesref">times</link> command in the previous
	    section.</para>

	  <note><para>As of <link linkend="bash2ref">version 2.0</link>
	    of Bash, <command>time</command> became a shell reserved word,
	    with slightly altered behavior in a pipeline.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="touchref"><command>touch</command></term>
	  <indexterm>
	    <primary>touch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>touch</secondary>
	  </indexterm>
	  <listitem>

	    <para>Utility for updating access/modification times of a
	      file to current system time or other specified time,
	      but also useful for creating a new file. The command
	      <userinput>touch zzz</userinput> will create a new file
	      of zero length, named <filename>zzz</filename>, assuming
	      that <filename>zzz</filename> did not previously exist.
	      Time-stamping empty files in this way is useful for
	      storing date information, for example in keeping track of
	      modification times on a project.
	      </para>

	    <para>The <command>touch</command> command is equivalent to
	      <userinput>: &gt;&gt; newfile</userinput> (for ordinary
	      files).</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="atref"><command>at</command></term>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>crond</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>crond</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>at</command> job control command executes
	      a given set of commands at a specified time. Superficially,
	      it resembles <link linkend="cronref">crond</link>, however,
	      <command>at</command> is chiefly useful for one-time execution
	      of a command set.</para>
	  
	    <para><userinput>at 2pm January 15</userinput> prompts for a set of
	      commands to execute at that time. These commands should be
	      shell-script compatible, since, for all practical
	      purposes, the user is typing in an executable shell
	      script a line at a time.	Input terminates with a <link
	      linkend="ctldref">Ctl-D</link>.</para>

	    <para>Using either the <option>-f</option> option or input
	      redirection (<token><</token>), <command>at</command>
	      reads a command list from a file. This file is an
	      executable shell script, though it should, of course,
	      be noninteractive. Particularly clever is including the
	      <link linkend="runpartsref">run-parts</link> command in
	      the file to execute a different set of scripts.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>at 2:30 am Friday < at-jobs.list</userinput>
<computeroutput>job 2 at 2000-10-27 02:30</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>batch</command></term>
	  <indexterm>
	    <primary>batch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>batch</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>batch</command> job control command is similar to
	      <command>at</command>, but it runs a command list when the system
	      load drops below <literal>.8</literal>. Like
	      <command>at</command>, it can read commands from a file with the
	      <option>-f</option> option.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cal</command></term>
	  <indexterm>
	    <primary>cal</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cal</secondary>
	  </indexterm>
	  <listitem>
	    <para>Prints a neatly formatted monthly calendar to
	      <filename>stdout</filename>. Will do current year or a large
	      range of past and future years.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sleep</command></term>
	  <indexterm>
	    <primary>sleep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sleep</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the shell equivalent of a wait loop. It pauses for a
	      specified number of seconds, doing nothing. This can be useful for
	      timing or in processes running in the background, checking for a
	      specific event every so often (see <xref linkend="online">).
	      <programlisting>sleep 3
# Pauses 3 seconds.</programlisting>
	    </para>
	    <note><para>The <command>sleep</command> command defaults to
	      seconds, but minute, hours, or days may also be specified.
	      <programlisting>sleep 3 h
# Pauses 3 hours!</programlisting>
            </para></note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>usleep</command></term>
	  <indexterm>
	    <primary>usleep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>usleep</secondary>
	  </indexterm>
	  <listitem>
	    <para><emphasis>Microsleep</emphasis> (the <quote>u</quote>
	      may be read as the Greek <quote>mu</quote>, or micro
	      prefix). This is the same as <command>sleep</command>,
	      above, but <quote>sleeps</quote> in microsecond
	      intervals. This can be used for fine-grain timing, or for
	      polling an ongoing process at very frequent intervals.
	      <programlisting>usleep 30
# Pauses 30 microseconds.</programlisting>
	    </para>
	    <caution><para>The <command>usleep</command> command does not
	      provide particularly accurate timing, and is therefore
	      unsuitable for critical timing loops.</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>hwclock</command></term>
	  <term><command>clock</command></term>
	  <indexterm>
	    <primary>hwclock</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hwclock</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>clock</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>clock</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>hwclock</command> command accesses or
	      adjusts the machine's hardware clock. Some
	      options require root privileges. The
	      <filename>/etc/rc.d/rc.sysinit</filename> startup file
	      uses <command>hwclock</command> to set the system time
	      from the hardware clock at bootup.</para>

	    <para>The <command>clock</command> command is a synonym for
	      <command>hwclock</command>.</para>
	  </listitem>
	</varlistentry>


       </variablelist>
       
        </sect1> <!-- End Time / Date Commands -->




      <sect1 id="textproc">
        <title>Text Processing Commands</title>

       <variablelist id="tpcommandlisting">
         <title><anchor id="tpcommandlisting1">Command Listing</title>

	<varlistentry>
	  <term><anchor id="sortref"><command>sort</command></term>
	  <indexterm>
	    <primary>sort</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sort</secondary>
	  </indexterm>
	  <listitem>
	    <para>File sorter, often used as a filter in a pipe. This
	      command sorts a text stream or file forwards or backwards,
	      or according to various keys or character positions. Using
	      the <option>-m</option> option, it merges presorted input
	      files.  The <emphasis>info page</emphasis> lists its many
	      capabilities and options. See <xref linkend="findstring">
	      and <xref linkend="symlinks">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tsort</command></term>
	  <indexterm>
	    <primary>tsort</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>topological sort</secondary>
	  </indexterm>
	  <listitem>
	    <para>Topological sort, reading in pairs of
	      whitespace-separated strings and sorting according to
	      input patterns.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="diffref"><command>diff</command></term>
	  <term><command>patch</command></term>
	  <indexterm>
	    <primary>diff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>diff</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>patch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>patch</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>diff</command>: flexible file comparison
	      utility. It compares the target files line-by-line
	      sequentially.  In some applications, such as comparing
	      word dictionaries, it may be helpful to filter the
	      files through <link linkend="sortref">sort</link>
	      and <command>uniq</command> before piping them
	      to <command>diff</command>. <userinput>diff file-1
	      file-2</userinput> outputs the lines in the files that
	      differ, with carets showing which file each particular
	      line belongs to.</para>

	  <para>The <option>--side-by-side</option> option to
	    <command>diff</command> outputs each compared file, line by line,
	    in separate columns, with non-matching lines marked.</para>

          <para>There are available various fancy frontends for
	    <command>diff</command>, such as <command>spiff</command>,
	    <command>wdiff</command>, <command>xdiff</command>, and
	    <command>mgdiff</command>. </para>

	  <tip><para>The <command>diff</command> command returns an exit
	    status of 0 if the compared files are identical, and 1 if
	    they differ. This permits use of <command>diff</command>
	    in a test construct within a shell script (see
	    below).</para></tip>


	    <para>A common use for <command>diff</command> is generating
	      difference files to be used with <command>patch</command>
	      The <option>-e</option> option outputs files suitable
	      for <command>ed</command> or <command>ex</command>
	      scripts.</para>


	    <para><command>patch</command>: flexible versioning
	      utility. Given a difference file generated by
	      <command>diff</command>, <command>patch</command> can
	      upgrade a previous version of a package to a newer version.
	      It is much more convenient to distribute a relatively
	      small <quote>diff</quote> file than the entire body of a
	      newly revised package. Kernel <quote>patches</quote> have
	      become the preferred method of distributing the frequent
	      releases of the Linux kernel.</para>

	    <para><programlisting>patch -p1 &lt;patch-file
# Takes all the changes listed in 'patch-file'
# and applies them to the files referenced therein.
# This upgrades to a newer version of the package.</programlisting></para>

	    <para>Patching the kernel:</para>
            <para><programlisting>cd /usr/src
gzip -cd patchXX.gz | patch -p0
# Upgrading kernel source using 'patch'.
# From the Linux kernel docs "README",
# by anonymous author (Alan Cox?).</programlisting></para>

            <note>
	    <para>The <command>diff</command> command can also
	      recursively compare directories (for the filenames
	      present).</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>diff -r ~/notes1 ~/notes2</userinput>
<computeroutput>Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</computeroutput>
	      </screen>
	    </para>
            </note>

	    <tip><para>Use <command>zdiff</command> to compare
	      <emphasis>gzipped</emphasis> files.</para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>diff3</command></term>
	  <indexterm>
	    <primary>diff3</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>diff3</secondary>
	  </indexterm>
	  <listitem>
	    <para>An extended version of <command>diff</command> that compares
	      three files at a time. This command returns an exit value
	      of 0 upon successful execution, but unfortunately this gives
	      no information about the results of the comparison.</para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>diff3 file-1 file-2 file-3</userinput>
<computeroutput>====
 1:1c
   This is line 1 of "file-1".
 2:1c
   This is line 1 of "file-2".
 3:1c
   This is line 1 of "file-3"</computeroutput>
	      </screen>
	      </para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sdiff</command></term>
	  <indexterm>
	    <primary>sdiff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sdiff</secondary>
	  </indexterm>
	  <listitem>
	    <para>Compare and/or edit two files in order to merge
	      them into an output file. Because of its interactive nature,
	      this command would find little use in a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cmp</command></term>
	  <indexterm>
	    <primary>cmp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cmp</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>cmp</command> command is a simpler version of
	      <command>diff</command>, above. Whereas <command>diff</command>
	      reports the differences between two files,
	      <command>cmp</command> merely shows at what point they
	      differ.</para>

	  <note><para>Like <command>diff</command>, <command>cmp</command>
	    returns an exit status of 0 if the compared files are
	    identical, and 1 if they differ. This permits use in a test
	    construct within a shell script.</para></note>

	    <example id="filecomp">
	      <title>Using <command>cmp</command> to compare two files
	        within a script.</title>
	      <programlisting>&filecomp;</programlisting>
	    </example>	    	   

	    <tip><para>Use <command>zcmp</command> on
	      <emphasis>gzipped</emphasis> files.</para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>comm</command></term>
	  <indexterm>
	    <primary>comm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>comm</secondary>
	  </indexterm>
	  <listitem>
	    <para>Versatile file comparison utility. The files must be
	      sorted for this to be useful.</para>

	    <para><command>comm
		<replaceable>-options</replaceable>
		<replaceable>first-file</replaceable>
		<replaceable>second-file</replaceable></command></para>

	    <para><userinput>comm file-1 file-2</userinput> outputs three columns:
	      <itemizedlist>
		<listitem><para>column 1 = lines unique to <filename>file-1</filename></para>
		</listitem>
		
		<listitem><para>column 2 = lines unique to <filename>file-2</filename></para>
		</listitem>
		
		<listitem><para>column 3 = lines common to both.</para>
		</listitem>
	      </itemizedlist></para>
	      
	    <para>The options allow suppressing output of one or more columns.
	      <itemizedlist>
		<listitem><para><option>-1</option> suppresses column
		    <literal>1</literal></para>
		</listitem>
		<listitem><para><option>-2</option> suppresses column
		    <literal>2</literal></para>
		</listitem>
		<listitem><para><option>-3</option> suppresses column
		    <literal>3</literal></para>
		</listitem>
		<listitem><para><option>-12</option> suppresses both columns
		    <literal>1</literal> and <literal>2</literal>, etc.</para>
		</listitem>
		</itemizedlist>
	    </para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="uniqref"><command>uniq</command></term>
	  <indexterm>
	    <primary>uniq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uniq</secondary>
	  </indexterm>
	  <listitem>
	    <para>This filter removes duplicate lines from a sorted
	      file. It is often seen in a pipe coupled with
	      <link linkend="sortref">sort</link>.
	      <programlisting>cat list-1 list-2 list-3 | sort | uniq > final.list
# Concatenates the list files,
# sorts them,
# removes duplicate lines,
# and finally writes the result to an output file.</programlisting></para>
 
             <para>The useful <option>-c</option> option prefixes each line of
	       the input file with the number of occurrences.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="expandref"><command>expand</command></term>
	  <term><command>unexpand</command></term>
	  <indexterm>
	    <primary>expand</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expand</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unexpand</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unexpand</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>expand</command> filter converts tabs to
	      spaces. It is often used in a pipe.</para>
	    <para>The <command>unexpand</command> filter
	      converts spaces to tabs. This reverses the effect of
	      <command>expand</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="cutref"><command>cut</command></term>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  <listitem>
	    <para>A tool for extracting fields from files. It is similar to the 
	      <userinput>print $N</userinput> command set in <link
	      linkend="awkref">awk</link>, but more limited. It may be
	      simpler to use <command>cut</command> in a script than
	      <command>awk</command>. Particularly important are the
	      <option>-d</option> (delimiter) and <option>-f</option>
	      (field specifier) options.</para>

	    <para>Using <command>cut</command> to obtain a listing of the
	      mounted filesystems: 
	      <programlisting>cat /etc/mtab | cut -d ' ' -f1,2</programlisting></para>

	    <para>Using <command>cut</command> to list the OS and kernel version:
	      <programlisting>uname -a | cut -d" " -f1,3,11,12</programlisting></para>

	    <para>Using <command>cut</command> to parse a file:
	      <programlisting># List all the users in /etc/passwd.

FILENAME=/etc/passwd

for user in $(cut -d: -f1 $FILENAME)
do
  echo $user
done

# Thanks, Oleg Philon for suggesting this.</programlisting></para>

	    <para><userinput>cut -d ' ' -f2,3 filename</userinput> is equivalent to
	      <userinput>awk -F'[ ]' '{ print $2, $3 }' filename</userinput></para>

	    <para>See also <xref linkend="base">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>colrm</command></term>
	  <indexterm>
	    <primary>colrm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>colrm</secondary>
	  </indexterm>
	  <listitem>
	    <para>Column removal filter. This removes columns (characters)
	      from a file and writes the file, lacking the range of
	      specified columns, back to <filename>stdout</filename>.
	      <userinput>colrm 2 4 &lt;filename</userinput> removes the
	      second through fourth characters from each line of the
	      text file <filename>filename</filename>.</para>
	    <warning><para>If the file contains tabs or nonprintable
	      characters, this may cause unpredictable
	      behavior. In such cases, consider using
	      <link linkend="expandref">expand</link> and
	      <command>unexpand</command> in a pipe preceding
	      <command>colrm</command>.</para></warning>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>paste</command></term>
	  <indexterm>
	    <primary>paste</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>paste</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	  <listitem>
	    <para>Tool for merging together different files into a single,
	      multi-column file.  In combination with
	      <command>cut</command>, useful for creating system log
	      files.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>join</command></term>
	  <indexterm>
	    <primary>join</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>join</secondary>
	  </indexterm>
	  <listitem>
	    <para>Consider this a special-purpose cousin of
	      <command>paste</command>. This powerful utility allows
	      merging two files in a meaningful fashion, which essentially
	      creates a simple version of a relational database.</para>

	    <para>The <command>join</command> command operates on
	      exactly two files, but pastes together only those lines
	      with a common tagged field (usually a numerical label),
	      and writes the result to <filename>stdout</filename>.
	      The files to be joined should be sorted according to the
	      tagged field for the matchups to work properly.</para>

	      <para><programlisting>File: 1.data

100 Shoes
200 Laces
300 Socks</programlisting></para>
      
              <para><programlisting>File: 2.data

100 $40.00
200 $1.00
300 $2.00</programlisting></para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>join 1.data 2.data</userinput>
<computeroutput>File: 1.data 2.data

 100 Shoes $40.00
 200 Laces $1.00
 300 Socks $2.00</computeroutput>
	      </screen>
	    </para>

	    <note><para>The tagged field appears only once in the
	      output.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>head</command></term>
	  <indexterm>
	    <primary>head</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>head</secondary>
	  </indexterm>
	  <listitem>
	    <para>lists the beginning of a file to
	      <filename>stdout</filename> (the default is
	      <literal>10</literal> lines, but this can be changed). It
	      has a number of interesting options.

	    <example id="rnd">
	      <title>Generating 10-digit random numbers</title>
	      <programlisting>&rnd;</programlisting>
	    </example>	    

	      See also <xref linkend="ex52">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tail</command></term>
	  <indexterm>
	    <primary>tail</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tail</secondary>
	  </indexterm>
	  <listitem>
	    <para>lists the end of a file to <filename>stdout</filename>
	      (the default is <literal>10</literal> lines).  Commonly used
	      to keep track of changes to a system logfile, using the
	      <option>-f</option> option, which outputs lines appended
	      to the file.</para>

	   <example id="ex12">
	     <title>Using <command>tail</command> to monitor the system log</title>
	     <programlisting>&ex12;</programlisting>
	   </example>

	      <para>See also <xref linkend="ex41">, <xref linkend="ex52"> and
		<xref linkend="online">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="grepref"><command>grep</command></term>
	  <indexterm>
	    <primary>grep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>grep</secondary>
	  </indexterm>
	  <listitem>
	    <para>A multi-purpose file search tool that uses
	      <link linkend="regexref">regular expressions</link>.
	      It was originally a command/filter in the
	      venerable <command>ed</command> line editor,
	      <userinput>g/re/p</userinput>, that is, <emphasis>global -
	      regular expression - print</emphasis>.</para>

	    <para><cmdsynopsis>
		<command>grep</command> <arg
		choice="plain"><replaceable>pattern</replaceable></arg>
		<arg choice="opt"
		rep="repeat"><replaceable>file</replaceable></arg>
	      </cmdsynopsis>Search the target file(s) for
	      occurrences of <replaceable>pattern</replaceable>, where
	      <replaceable>pattern</replaceable> may be literal text
	      or a regular expression.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>grep '[rst]ystem.$' osinfo.txt</userinput>
<computeroutput>The GPL governs the distribution of the Linux operating system.</computeroutput>
	      </screen>
	      </para>

	    <para>If no target file(s) specified, <command>grep</command>
	      works as a filter on <filename>stdout</filename>, as in
	      a <link linkend="piperef">pipe</link>.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>ps ax | grep clock</userinput>
<computeroutput>765 tty1     S      0:00 xclock
 901 pts/1    S      0:00 grep clock</computeroutput>
	      </screen>
	      </para>

	    <para>The <option>-i</option> option causes a case-insensitive
	      search.</para>

	    <para>The <option>-l</option> option lists only the files in which
	      matches were found, but not the matching lines.</para>

	    <para>The <option>-n</option> option lists the matching lines,
	      together with line numbers.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>grep -n Linux osinfo.txt</userinput>
<computeroutput>2:This is a file containing information about Linux.
 6:The GPL governs the distribution of the Linux operating system.</computeroutput>
	      </screen>
	      </para>

	    <para>The <option>-v</option> (or <option>--invert-match</option>)
	      option <emphasis>filters out</emphasis> matches.
	      <programlisting>grep pattern1 *.txt | grep -v pattern2

# Matches all lines in "*.txt" files containing "pattern1",
# but ***not*** "pattern2".	      
</programlisting></para>

	    <para>The <option>-c</option> (<option>--count</option>)
	      option gives a numerical count of matches, rather than
	      actually listing the matches.

	        <programlisting>grep -c txt *.sgml   # (number of occurrences of "txt" in "*.sgml" files)


#   grep -cz .
#            ^ dot
# means count (-c) zero-separated (-z) items matching "."
# that is, non-empty ones (containing at least 1 character).
# 
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz .     # 4
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '$'   # 5
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '^'   # 5
#
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -c '$'    # 9
# By default, newline chars (\n) separate items to match. 

# Note that the -z option is GNU "grep" specific.


# Thanks, S.C.</programlisting>
            </para>

	    <para>When invoked with more than one target file given,
	      <command>grep</command> specifies which file contains
	      matches.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>grep Linux osinfo.txt misc.txt</userinput>
<computeroutput>osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.
 misc.txt:The Linux operating system is steadily gaining in popularity.</computeroutput>
	      </screen>
	    </para>


	    <tip>
	    <para>To force <command>grep</command> to show the filename
	      when searching only one target file, simply give
	      <filename>/dev/null</filename> as the second file.</para>
	    <para>
	      <screen><prompt>bash$ </prompt><userinput>grep Linux osinfo.txt /dev/null</userinput>
<computeroutput>osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.</computeroutput>
	      </screen>
	    </para>
	    </tip>


	    <para>If there is a successful match, <command>grep</command>
	      returns an <link linkend="exitstatusref">exit status</link>
	      of 0, which makes it useful in a condition test in a
	      script, especially in combination with the <option>-q</option>
	      option to suppress output.
	        <programlisting>SUCCESS=0                      # if grep lookup succeeds
word=Linux
filename=data.file

grep -q "$word" "$filename"    # The "-q" option causes nothing to echo to stdout.

if [ $? -eq $SUCCESS ]
then
  echo "$word found in $filename"
else
  echo "$word not found in $filename"
fi</programlisting>
            </para>


	    <para><xref linkend="online"> demonstrates how to use
	      <command>grep</command> to search for a word pattern in
	      a system logfile.</para>


	    <example id="grp">
	      <title>Emulating <quote>grep</quote> in a script</title>
	      <programlisting>&grp;</programlisting>
	    </example>	    	   

	    <note>
	    <para><anchor id="egrepref"><command>egrep</command>
	      is the same as <command>grep -E</command>. This
	      uses a somewhat different, extended set of <link
	      linkend="regexref">regular expressions</link>, which can
	      make the search somewhat more flexible.</para>

	    <para><command>fgrep</command> is the same as <command>grep
	      -F</command>. It does a literal string search (no regular
	      expressions), which allegedly speeds things up a
	      bit.</para>
	      
	    <para><command>agrep</command> extends the capabilities of
	      <command>grep</command> to approximate matching. The search
	      string may differ by a specified number of characters from the
	      resulting matches. This utility is not part of the core Linux
	      distribution.</para>
	      
	      </note>
	    
	    <tip>
	    <para>To search compressed files, use
	      <command>zgrep</command>, <command>zegrep</command>,
	      or <command>zfgrep</command>. These also work
	      on non-compressed files, though slower than plain
	      <command>grep</command>, <command>egrep</command>,
	      <command>fgrep</command>.  They are handy for searching
	      through a mixed set of files, some compressed, some
	      not.</para>
	    <para>To search <link linkend="bzipref">bzipped</link>
	      files, use <command>bzgrep</command>.</para> </tip>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>look</command></term>
	  <indexterm>
	    <primary>look</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>look</secondary>
	  </indexterm>
	  <listitem>
	    <para>The command <command>look</command> works like
	      <command>grep</command>, but does a lookup on
	      a <quote>dictionary</quote>, a sorted word list.
	      By default, <command>look</command> searches for a match
	      in <filename>/usr/dict/words</filename>, but a different
	      dictionary file may be specified.</para>

	    <example id="lookup">
	      <title>Checking words in a list for validity</title>
	      <programlisting>&lookup;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>sed</command></term>
	  <term><command>awk</command></term>
	  <indexterm>
	    <primary>sed</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sed</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  <listitem>
	    <para>Scripting languages especially suited for parsing text
	      files and command output. May be embedded singly or in
	      combination in pipes and shell scripts.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command><link linkend="sedref">sed</link></command></term>
	  <listitem>
	    <para>Non-interactive <quote>stream editor</quote>, permits using
	      many <command>ex</command> commands in batch mode. It
	      finds many uses in shell scripts.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command><link linkend="awkref">awk</link></command></term>
	  <listitem>
	    <para>Programmable file extractor and formatter, good for
	      manipulating and/or extracting fields (columns) in
	      structured text files. Its syntax is similar to C.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>wc</command></term>
	  <indexterm>
	    <primary>wc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wc</secondary>
	  </indexterm>
	  <listitem>
	    <para><emphasis>wc</emphasis> gives a <quote>word count</quote> on a file or I/O stream:
	      <screen><prompt>bash $ </prompt><userinput>wc /usr/doc/sed-3.02/README</userinput>
<computeroutput>20     127     838 /usr/doc/sed-3.02/README</computeroutput>
[20 lines  127 words  838 characters]</screen></para>

	    <para><userinput>wc -w</userinput> gives only the word count.</para>
	    <para><userinput>wc -l</userinput> gives only the line count.</para>
	    <para><userinput>wc -c</userinput> gives only the character count.</para>
	    <para><userinput>wc -L</userinput> gives only the length of the longest line.</para>

            <para>Using <command>wc</command> to count how many
	    <emphasis>.txt</emphasis> files are in current working directory:
	      <programlisting>$ ls *.txt | wc -l
# Will work as long as none of the "*.txt" files have a linefeed in their name.

# Alternative ways of doing this are:
#      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
#      (shopt -s nullglob; set -- *.txt; echo $#)

# Thanks, S.C.</programlisting>
	    </para>

	    <para>Using <command>wc</command> to total up the size of all the
	      files whose names begin with letters in the range d - h
	      <screen><prompt>bash$ </prompt><userinput>wc [d-h]* | grep total | awk '{print $3}'</userinput>
<computeroutput>71832</computeroutput>
	      </screen>
	    </para>

	    <para>Using <command>wc</command> to count the instances of the
	      word <quote>Linux</quote> in the main source file for
	      this book.
	      <screen><prompt>bash$ </prompt><userinput>grep Linux abs-book.sgml | wc -l</userinput>
<computeroutput>50</computeroutput>
	      </screen>
	    </para>

	    <para>See also <xref linkend="ex52"> and <xref
	    linkend="redir4">.</para>

	    <para>Certain commands include some of the
	      functionality of <command>wc</command> as options.
	      
	    <programlisting>... | grep foo | wc -l
# This frequently used construct can be more concisely rendered.

... | grep -c foo
# Just use the "-c" (or "--count") option of grep.

# Thanks, S.C.</programlisting></para>

	  </listitem>
	</varlistentry>

	
	<varlistentry>
	  <term><anchor id="trref"><command>tr</command></term>
	  <indexterm>
	    <primary>tr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tr</secondary>
	  </indexterm>
	  <listitem>
	    <para>character translation filter.</para>
	    
	    <caution><para><link linkend="ucref">Must use quoting and/or
	      brackets</link>, as appropriate. Quotes prevent the
	      shell from reinterpreting the special characters in
	      <command>tr</command> command sequences. Brackets should be
	      quoted to prevent expansion by the shell.  </para></caution>

	    <para>Either <userinput>tr "A-Z" "*" &lt;filename</userinput>
	      or <userinput>tr A-Z \* &lt;filename</userinput> changes
	      all the uppercase letters in <filename>filename</filename>
	      to asterisks (writes to <filename>stdout</filename>).
	      On some systems this may not work, but <userinput>tr A-Z
	      '[**]'</userinput> will.</para>

	    <para>The <option>-d</option> option deletes a range of
	      characters.
	    <programlisting>tr -d 0-9 &lt;filename
# Deletes all digits from the file "filename".</programlisting></para>

              <para>The <option>--squeeze-repeats</option> (or
		<option>-s</option>) option deletes all but the
		first instance of a string of consecutive characters.
		This option is useful for removing excess <link
		linkend="whitespaceref">whitespace</link>.

	      <screen><prompt>bash$ </prompt><userinput>echo "XXXXX" | tr --squeeze-repeats 'X'</userinput>
<computeroutput>X</computeroutput></screen></para>

	    <example id="ex49">
	      <title><command>toupper</command>: Transforms a file to all uppercase.</title>
	      <programlisting>&ex49;</programlisting>
	    </example>	    


	    <example id="lowercase">
	      <title><command>lowercase</command>: Changes all filenames in working directory to lowercase.</title>
	      <programlisting>&lowercase;</programlisting>
	    </example>	    

	    <example id="du">
	      <title><command>du</command>: DOS to UNIX text file conversion.</title>
	      <programlisting>&du;</programlisting>
	    </example>	    

	    <example id="rot13">
	      <title><command>rot13</command>: rot13, ultra-weak encryption.</title>
	      <programlisting>&rot13;</programlisting>
	    </example>	    

	    <example id="cryptoquote">
	      <title>Generating <quote>Crypto-Quote</quote> Puzzles</title>
	      <programlisting>&cryptoquote;</programlisting>
	    </example>	    

	    <sidebar><title><command>tr</command> variants</title>
	    <para>
	    The <command>tr</command> utility has two historic
	    variants. The BSD version does not use brackets
	    (<userinput>tr a-z A-Z</userinput>), but the SysV one does
	    (<userinput>tr '[a-z]' '[A-Z]'</userinput>). The GNU version
	    of <command>tr</command> resembles the BSD one, so quoting
	    letter ranges within brackets is mandatory.
	    </para>
	    </sidebar>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="foldref"><command>fold</command></term>
	  <indexterm>
	    <primary>fold</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fold</secondary>
	  </indexterm>
	  <listitem>
	    <para>A filter that wraps lines of input to a specified width.
	      This is especially useful with the <option>-s</option>
	      option, which breaks lines at word spaces (see <xref
	      linkend="ex50"> and <xref linkend="mailformat">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fmt</command></term>
	  <indexterm>
	    <primary>fmt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fmt</secondary>
	  </indexterm>
	  <listitem>
	    <para>Simple-minded file formatter, used as a filter in a
	      pipe to <quote>wrap</quote> long lines of text
	      output.</para>

	    <example id="ex50">
	      <title>Formatted file listing.</title>
	      <programlisting>&ex50;</programlisting>
	    </example>	    

	    <para>See also <xref linkend="ex41">.</para>

	    <tip><para>A powerful alternative to <command>fmt</command> is
	      Kamil Toman's <command>par</command>
	      utility, available from <ulink
	      url="http://www.cs.berkeley.edu/~amc/Par/">http://www.cs.berkeley.edu/~amc/Par/</ulink>.
	      </para></tip>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>ptx</command></term>
	  <indexterm>
	    <primary>ptx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>index</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>ptx [targetfile]</command> command
	      outputs a permuted index (cross-reference list) of the
	      targetfile. This may be further filtered and formatted in a
	      pipe, if necessary.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>column</command></term>
	  <indexterm>
	    <primary>column</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>column</secondary>
	  </indexterm>
	  <listitem>
	    <para>Column formatter. This filter transforms list-type
	      text output into a <quote>pretty-printed</quote> table
	      by inserting tabs at appropriate places.</para>

	    <example id="col">
	      <title>Using <command>column</command> to format a directory
	        listing</title>
	      <programlisting>&col;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>nl</command></term>
	  <indexterm>
	    <primary>nl</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fmt</secondary>
	  </indexterm>
	  <listitem>
	    <para>Line numbering filter. <userinput>nl filename</userinput>
	    lists <filename>filename</filename> to
	    <filename>stdout</filename>, but inserts consecutive
	    numbers at the beginning of each non-blank line. If
	    <filename>filename</filename> omitted, operates on
	    <filename>stdin.</filename></para>

	    <example id="lnum">
	      <title><command>nl</command>: A self-numbering script.</title>
	      <programlisting>&lnum;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>pr</command></term>
	  <indexterm>
	    <primary>pr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pr</secondary>
	  </indexterm>
	  <listitem>
	    <para>Print formatting filter. This will paginate files
	      (or <filename>stdout</filename>) into sections suitable for
	      hard copy printing or viewing on screen.	Various options
	      permit row and column manipulation, joining lines, setting
	      margins, numbering lines, adding page headers, and merging
	      files, among other things. The <command>pr</command>
	      command combines much of the functionality of
	      <command>nl</command>, <command>paste</command>,
	      <command>fold</command>, <command>column</command>, and
	      <command>expand</command>.</para>

	   <para><userinput>pr -o 5 --width=65 fileZZZ | more</userinput>
	     gives a nice paginated listing to screen of
	     <filename>fileZZZ</filename> with margins set at 5 and
	     65.</para>

	    <para>A particularly useful option is <option>-d</option>,
	      forcing double-spacing (same effect as <command>sed
	      -G</command>).</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="gettextref"><command>gettext</command></term>
	  <indexterm>
	    <primary>gettext</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>gettext</secondary>
	  </indexterm>
	  <listitem>
	    <para>A GNU utility for <link
	      linkend="localization">localization</link> and
	      translating the text output of programs into
	      foreign languages. While primarily intended for C
	      programs, <command>gettext</command> also finds
	      use in shell scripts. See the <replaceable>info
	      page</replaceable>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>iconv</command></term>
	  <indexterm>
	    <primary>iconv</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>encoding</secondary>
	  </indexterm>
	  <listitem>
	    <para>A utility for converting file(s) to a different encoding
	      (character set). Its chief use is for localization.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>recode</command></term>
	  <indexterm>
	    <primary>recode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>encoding</secondary>
	  </indexterm>
	  <listitem>
	    <para>Consider this a fancier version of
	      <command>iconv</command>, above. This very versatile utility
	      for converting a file to a different encoding is not part
	      of the standard Linux installation.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>groff</command></term>
	  <term><command>gs</command></term>
	  <term><command>TeX</command></term>
	  <indexterm>
	    <primary>groff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>groff</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>gs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>Postscript</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>TeX</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>TeX</secondary>
	  </indexterm>
	  <listitem>

	    <para>Groff, TeX, and Postscript are text markup languages
	      used for preparing copy for printing or formatted video
	      display.</para>

	      <para><emphasis>Manpages</emphasis> use
		<command>groff</command> (see <xref linkend="manview">).
		<emphasis>Ghostscript</emphasis> (<command>gs</command>)
		is a GPL Postscript interpreter. <command>TeX</command>
		is Donald Knuth's elaborate typsetting system. It is
		often convenient to write a shell script encapsulating
		all the options and arguments passed to one of these
		markup languages.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lex</command></term>
	  <term><command>yacc</command></term>
	  <indexterm>
	    <primary>lex</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>flex</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>yacc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bison</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>lex</command> lexical analyzer produces
	      programs for pattern matching. This has been replaced
	      by the nonproprietary <command>flex</command> on Linux
	      systems.</para>
	    <para>The <command>yacc</command> utility creates a
	      parser based on a set of specifications. This has been
	      replaced by the nonproprietary <command>bison</command>
	      on Linux systems.</para>
	  </listitem>
	</varlistentry>

       </variablelist>

        </sect1> <!-- End Text Processing Commands -->


      <sect1 id="filearchiv">
        <title>File and Archiving Commands</title>

       <variablelist id="faarchiving">
         <title><anchor id="faarchiving1">Archiving</title>

	<varlistentry>
	  <term><anchor id="tarref"><command>tar</command></term>
	  <indexterm>
	    <primary>tar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tar</secondary>
	  </indexterm>
	  <listitem>

	    <para>The standard UNIX archiving utility. Originally a
	      <wordasword>Tape ARchiving</wordasword> program,
	      it has developed into a general purpose package that
	      can handle all manner of archiving with all types of
	      destination devices, ranging from tape drives to regular
	      files to even <filename>stdout</filename> (see <xref
	      linkend="ex58">). GNU tar has long since been patched to
	      accept <link linkend="gzipref">gzip</link> compression
	      options, such as <command>tar czvf archive-name.tar.gz
	      *</command>, which recursively archives and compresses all
	      files (except <link linkend="dotfilesref">dotfiles</link>)
	      in a directory tree.</para>

	    <para>Some useful <command>tar</command> options:  
	      <orderedlist>
	        <listitem><para><option>-c</option> create (a new archive)</para></listitem>
	        <listitem><para><option>--delete</option> delete (files from the archive)</para></listitem>
	        <listitem><para><option>-r</option> append (files to the archive)</para></listitem>
	        <listitem><para><option>-t</option> list (archive contents)</para></listitem>
	        <listitem><para><option>-u</option> update archive</para></listitem>
	        <listitem><para><option>-x</option> extract (files from the archive)</para></listitem>
	        <listitem><para><option>-z</option> <link linkend="gzipref">gzip</link> the archive</para></listitem>
	      </orderedlist>
	      </para>

	    <caution><para>It may be difficult to recover data from a
	      corrupted <emphasis>gzipped</emphasis> tar
	      archive. When archiving important files, make multiple
	      backups.</para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>shar</command></term>
	  <indexterm>
	    <primary>shar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>archive</secondary>
	  </indexterm>
	  <listitem>

	    <para>Shell archiving utility. The files in a shell archive
	      are concatenated without compression, and the resultant
	      archive is essentially a shell script, complete with
	      <token>#!/bin/sh</token> header, and containing all
	      the necessary unarchiving commands.  Shar archives
	      still show up in Internet newsgroups, but otherwise
	      <command>shar</command> has been pretty well replaced by
	      <command>tar</command>/<command>gzip</command>. The
	      <command>unshar</command> command unpacks
	      <command>shar</command> archives.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ar</command></term>
	  <indexterm>
	    <primary>ar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>archive</secondary>
	  </indexterm>
	  <listitem>
	    <para>Creation and manipulation utility for archives, mainly
	      used for binary object file libraries.</para>
	  </listitem>

	</varlistentry>
	<varlistentry>
	  <term><command>cpio</command></term>
	  <indexterm>
	    <primary>cpio</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cpio</secondary>
	  </indexterm>
	  <listitem>
	    <para>This specialized archiving copy command is rarely seen any more,
	      having been supplanted by
	      <command>tar</command>/<command>gzip</command>. It still
	      has its uses, such as moving a directory tree.</para>

	    <example id="ex48">
	      <title>Using <command>cpio</command> to move a directory tree</title>
	      <programlisting>&ex48;</programlisting>
	    </example>	    
	    
	    <example id="derpm">
	      <title>Unpacking an <emphasis>rpm</emphasis> archive</title>
	      <programlisting>&derpm;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="facompression">
        <title><anchor id="facompression1">Compression</title>

	<varlistentry>
	  <term><anchor id="gzipref"><command>gzip</command></term>
	  <indexterm>
	    <primary>gzip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>gzip</secondary>
	  </indexterm>
	  <listitem>

	    <para>The standard GNU/UNIX compression utility, replacing
	      the inferior and proprietary
	      <command>compress</command>. The corresponding decompression
	      command is <command>gunzip</command>, which is the equivalent of
	      <command>gzip -d</command>.</para>

	    <para>The <command>zcat</command> filter decompresses a
	      <emphasis>gzipped</emphasis> file to
	      <filename>stdout</filename>, as possible input to a pipe or
	      redirection. This is, in effect, a <command>cat</command>
	      command that works on compressed files (including files
	      processed with the older <command>compress</command>
	      utility). The <command>zcat</command> command is equivalent to
	      <command>gzip -dc</command>.</para>

	    <caution><para>On some commercial UNIX systems, <command>zcat</command>
	      is a synonym for <command>uncompress -c</command>,
	      and will not work on <emphasis>gzipped</emphasis>
	      files.</para></caution>

	      <para>See also <xref linkend="ex14">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="bzipref"><command>bzip2</command></term>
	  <indexterm>
	    <primary>bzip2</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bzip2</secondary>
	  </indexterm>
	  <listitem>
	    <para>An alternate compression utility, usually more efficient
	      than <command>gzip</command>, especially on large files. The
	      corresponding decompression command is
	      <command>bunzip2</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>compress</command></term>
	  <term><command>uncompress</command></term>
	  <indexterm>
	    <primary>compress</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>compress</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>uncompress</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uncompress</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is an older, proprietary compression
	      utility found in commercial UNIX distributions. The
	      more efficient <command>gzip</command> has largely
	      replaced it. Linux distributions generally include a
	      <command>compress</command> workalike for compatibility,
	      although <command>gunzip</command> can unarchive files
	      treated with <command>compress</command>.</para>

	    <tip><para>The <command>znew</command> command transforms
	      <emphasis>compressed</emphasis> files into
	      <emphasis>gzipped</emphasis> ones.</para></tip>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sq</command></term>
	  <indexterm>
	    <primary>sq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sq</secondary>
	  </indexterm>
	  <listitem>

	    <para>Yet another compression utility, a filter that works
	      only on sorted ASCII word lists. It uses the standard
	      invocation syntax for a filter, <command>sq < input-file >
	      output-file</command>.  Fast, but not nearly as efficient
	      as <link linkend="gzipref">gzip</link>.  The corresponding
	      uncompression filter is <command>unsq</command>, invoked
	      like <command>sq</command>.</para>

	      <tip><para>The output of <command>sq</command> may be
	        piped to <command>gzip</command> for further
		compression.</para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>zip</command></term>
	  <term><command>unzip</command></term>
	  <indexterm>
	    <primary>zip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>zip</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unzip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unzip</secondary>
	  </indexterm>
	  <listitem>
	    <para>Cross-platform file archiving and compression utility
	      compatible with DOS <emphasis>PKZIP</emphasis>.
	      <quote>Zipped</quote> archives seem to be a more
	      acceptable medium of exchange on the Internet than
	      <quote>tarballs</quote>.</para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="fainformation">
        <title><anchor id="fainformation1">File Information</title>

	<varlistentry>
	  <term><anchor id="fileref"><command>file</command></term>
	  <indexterm>
	    <primary>file</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file</secondary>
	  </indexterm>
	  <listitem>

	    <para>A utility for identifying file types. The command
	      <userinput>file file-name</userinput> will return a
	      file specification for <filename>file-name</filename>,
	      such as <computeroutput>ascii text</computeroutput> or
	      <computeroutput>data</computeroutput>. It references
	      the <link linkend="magnumref">magic numbers</link>
	      found in <filename>/usr/share/magic</filename>,
	      <filename>/etc/magic</filename>, or
	      <filename>/usr/lib/magic</filename>, depending on the
	      Linux/UNIX distribution.</para>

	    <para>The <option>-f</option> option causes
	      <command>file</command> to run in batch mode, to read from
	      a designated file a list of filenames to analyze. The
	      <option>-z</option> option, when used on a compressed
	      target file, forces an attempt to analyze the uncompressed
	      file type.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>file test.tar.gz</userinput>
<computeroutput>test.tar.gz: gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix</computeroutput>

<prompt>bash </prompt><userinput>file -z test.tar.gz</userinput>
<computeroutput>test.tar.gz: GNU tar archive (gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix)</computeroutput>
	      </screen>
	    </para>

	    <example id="stripc">
	      <title>stripping comments from C program files</title>
	      <programlisting>&stripc;</programlisting>
	    </example>	    	   

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="whichref"><command>which</command></term>
	  <indexterm>
	    <primary>which</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>which</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>which command-xxx</command> gives the full path
	      to <quote>command-xxx</quote>. This is useful for finding
	      out whether a particular command or utility is installed
	      on the system.</para>
	    <para><userinput>$bash which rm</userinput>
<screen><computeroutput>/usr/bin/rm</computeroutput></screen>
	  </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>whereis</command></term>
	  <indexterm>
	    <primary>whereis</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>whereis</secondary>
	  </indexterm>
	  <listitem>
	    <para>Similar to <command>which</command>, above,
	      <command>whereis command-xxx</command> gives the
	      full path to <quote>command-xxx</quote>, but also to its
	      <emphasis>manpage</emphasis>.</para>
	    <para><userinput>$bash whereis rm</userinput>
<screen><computeroutput>rm: /bin/rm /usr/share/man/man1/rm.1.bz2</computeroutput></screen>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="whatisref"><command>whatis</command></term>
	  <indexterm>
	    <primary>whatis</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>whatis</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>whatis filexxx</command> looks up
	      <quote>filexxx</quote> in the
	      <replaceable>whatis</replaceable> database. This is useful
	      for identifying system commands and important configuration
	      files. Consider it a simplified <command>man</command>
	      command.</para>
	    <para><userinput>$bash whatis whatis</userinput>
<screen><computeroutput>whatis               (1)  - search the whatis database for complete words</computeroutput></screen>
	  </para>
	  
      <example id="what">
	<title><command>Exploring <filename
	class="directory">/usr/X11R6/bin</filename></command></title>
	<programlisting>&what;</programlisting>
      </example>

            <para>See also <xref linkend="fileinfo">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>vdir</command></term>
	  <indexterm>
	    <primary>vdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ls</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show a detailed directory listing. The effect is similar to
	      <link linkend="lsref">ls -l</link>.</para>
	    <para>This is one of the GNU <emphasis>fileutils</emphasis>.</para>  
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>vdir</userinput>
<computeroutput>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</computeroutput>

<prompt>bash </prompt><userinput>ls -l</userinput>
<computeroutput>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="shredref"><command>shred</command></term>
	  <indexterm>
	    <primary>shred</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>secure delete</secondary>
	  </indexterm>
	  <listitem>
	    <para>Securely erase a file by overwriting it multiple times with
	      random bit patterns before deleting it. This command has
	      the same effect as <xref linkend="blotout">, but does it
	      in a more thorough and elegant manner.</para>
	    <para>This is one of the GNU <emphasis>fileutils</emphasis>.</para>  
	    <caution><para>Using <command>shred</command> on a file may
	      not prevent recovery of some or all of its contents using
	      advanced forensic technology.</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>locate</command></term>
	  <term><command>slocate</command></term>
	  <indexterm>
	    <primary>locate</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>locate</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>slocate</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>slocate</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>locate</command> command searches for files using a
	      database stored for just that purpose. The
	      <command>slocate</command> command is the secure version of
	      <command>locate</command> (which may be aliased to
	      <command>slocate</command>).</para>
	    <para><userinput>$bash locate hickson</userinput>
<screen><computeroutput>/usr/lib/xephem/catalogs/hickson.edb</computeroutput></screen></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>strings</command></term>
	  <indexterm>
	    <primary>strings</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>strings</secondary>
	  </indexterm>
	  <listitem>
	    <para>Use the <command>strings</command> command to find
	      printable strings in a binary or data file. It will list
	      sequences of printable characters found in the target
	      file. This might be handy for a quick 'n dirty examination
	      of a core dump or for looking at an unknown graphic image
	      file (<userinput>strings image-file | more</userinput> might
	      show something like <computeroutput>JFIF</computeroutput>,
	      which would identify the file as a <emphasis>jpeg</emphasis>
	      graphic). In a script, you would probably
	      parse the output of <command>strings</command>
	      with <link linkend="grepref">grep</link> or <link
	      linkend="sedref">sed</link>. See <xref linkend="bingrep">
	      and <xref linkend="findstring">.</para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="fautils">
        <title><anchor id="fautils1">Utilities</title>

	<varlistentry>
	  <term><command>basename</command></term>
	  <indexterm>
	    <primary>basename</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>basename</secondary>
	  </indexterm>
	  <listitem><para>Strips the path information from a file name, printing
	      only the file name. The construction  <userinput>basename
		$0</userinput> lets the script know its name, that is, the name it
	      was invoked by. This can be used for <quote>usage</quote> messages if, 
	      for example a script is called with missing arguments:
              <programlisting>echo "Usage: `basename $0` arg1 arg2 ... argn"</programlisting>
	    </para>

	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>dirname</command></term>
	  <indexterm>
	    <primary>dirname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirname</secondary>
	  </indexterm>
	  <listitem><para>Strips the <command>basename</command> from
	    a filename, printing only the path information.</para>
	    <note>
	      <para><command>basename</command> and <command>dirname</command>
		can operate on any arbitrary string. The argument
		does not need to refer to an existing file, or
		even be a filename for that matter (see <xref
		linkend="daysbetween">).</para>
	    </note>
	    
	    <example id="ex35">
	      <title><command>basename</command> and <command>dirname</command></title>
	      <programlisting>&ex35;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>split</command></term>
	  <indexterm>
	    <primary>split</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>split</secondary>
	  </indexterm>
	  <listitem>
	    <para>Utility for splitting a file into smaller chunks. Usually used 
	      for splitting up large files in order to back them up on floppies or
	      preparatory to e-mailing or uploading them.</para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sum</command></term>
	  <term><command>cksum</command></term>
	  <term><anchor id="md5sumref"><command>md5sum</command></term>
	  <indexterm>
	    <primary>sum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cksum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cksum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>md5sum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>md5sum</secondary>
	  </indexterm>
	  <listitem>
	    <para>These are utilities for generating checksums. A
	      <emphasis>checksum</emphasis> is a number mathematically
	      calculated from the contents of a file, for the purpose
	      of checking its integrity. A script might refer to a list
	      of checksums for security purposes, such as ensuring that
	      the contents of key system files have not been altered or
	      corrupted. The <command>md5sum</command> command is the most
	      appropriate of these in security applications.</para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="faencencr">
        <title><anchor id="faencencr1">Encoding and Encryption</title>

	<varlistentry>
	  <term><command>uuencode</command></term>
	  <indexterm>
	    <primary>uuencode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uuencode</secondary>
	  </indexterm>
	  <listitem>
	    <para>This utility encodes binary files into ASCII characters, making them
	      suitable for transmission in the body of an e-mail message or in a
	      newsgroup posting.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uudecode</command></term>
	  <indexterm>
	    <primary>uudecode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uudecode</secondary>
	  </indexterm>
	  <listitem>
	    <para>This reverses the encoding, decoding uuencoded files back into the
	      original binaries.</para>

	    <example id="ex52">
	      <title>uudecoding encoded files</title>
	      <programlisting>&ex52;</programlisting>
	    </example>	    	   

	  <tip><para>The <link linkend="foldref">fold -s</link> command
	    may be useful (possibly in a pipe) to process long uudecoded
	    text messages downloaded from Usenet newsgroups.</para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>crypt</command></term>
	  <indexterm>
	    <primary>crypt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>crypt</secondary>
	  </indexterm>
	  <listitem>
	    <para>At one time, this was the standard UNIX file encryption
	      utility.

              <footnote><para>This is a symmetric block cipher, used to
	        encrypt files on a single system or local network, as opposed
		to the <quote>public key</quote> cipher class, of which
		<command>pgp</command> is a well-known
		example.</para></footnote>

	      Politically motivated government regulations
	      prohibiting the export of encryption software resulted
	      in the disappearance of <command>crypt</command>
	      from much of the UNIX world, and it is still
	      missing from most Linux distributions. Fortunately,
	      programmers have come up with a number of decent
	      alternatives to it, among them the author's very own <ulink
	      url="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz">cruft</ulink>
	      (see <xref linkend="encryptedpw">).  </para>

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="famisc">
        <title><anchor id="famisc1">Miscellaneous</title>

	<varlistentry>
	  <term><command>make</command></term>
	  <indexterm>
	    <primary>make</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>Makefile</secondary>
	  </indexterm>
	  <listitem>
	    <para>Utility for building and compiling binary packages. 
	      This can also be used for any set of operations that is
	      triggered by incremental changes in source files.</para>
	    <para><anchor id="makefileref"></para>
	    <para>The <command>make</command> command checks a
	    <filename>Makefile</filename>, a list of file dependencies and
	      operations to be carried out.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>install</command></term>
	  <indexterm>
	    <primary>install</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>install</secondary>
	  </indexterm>
	  <listitem>
	    <para>Special purpose file copying command, similar to
	      <command>cp</command>, but capable of setting permissions
	      and attributes of the copied files. This command seems
	      tailormade for installing software packages, and as such it
	      shows up frequently in <filename>Makefiles</filename>
	      (in the <replaceable>make install :</replaceable>
	      section). It could likewise find use in installation
	      scripts.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>more</command></term>
	  <term><command>less</command></term>
	  <indexterm>
	    <primary>more</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>more</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>less</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>less</secondary>
	  </indexterm>
	  <listitem>
	    <para>Pagers that display a text file or stream to
	      <filename>stdout</filename>, one screenful at a time.
	      These may be used to filter the output of a script.</para>
	  </listitem>
	</varlistentry>
       
       </variablelist>	

	</sect1> <!-- End File and Archiving Commands -->



      <sect1 id="communications">
        <title>Communications Commands</title>

       <variablelist id="communinfo">
         <title><anchor id="communinfo1">Information and Statistics</title>

	<varlistentry>
	  <term><command>host</command></term>
	  <indexterm>
	    <primary>host</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>host</secondary>
	  </indexterm>
	  <listitem>
	    <para>Searches for information about an Internet host by name or
	      IP address, using DNS.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>vrfy</command></term>
	  <indexterm>
	    <primary>vrfy</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>vrfy</secondary>
	  </indexterm>
	  <listitem>
	    <para>Verify an Internet e-mail address.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>nslookup</command></term>
	  <indexterm>
	    <primary>nslookup</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>name server lookup</secondary>
	  </indexterm>
	  <listitem>
	    <para>Do an Internet <quote>name server lookup</quote> on a host
	      by IP address. This may be run either interactively or
	      noninteractively, i.e., from within a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>dig</command></term>
	  <indexterm>
	    <primary>dig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>domain information groper</secondary>
	  </indexterm>
	  <listitem>
	    <para>Similar to <command>nslookup</command>, do an Internet
	      <quote>name server lookup</quote> on a host.  May be run
	      either interactively or noninteractively, i.e., from within
	      a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>traceroute</command></term>
	  <indexterm>
	    <primary>traceroute</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>traceroute</secondary>
	  </indexterm>
	  <listitem>
	    <para>Trace the route taken by packets sent to a remote host. This
	      command works within a LAN, WAN, or over the
	      Internet. The remote host may be specified by an IP
	      address. The output of this command may be filtered
	      by <link linkend="grepref">grep</link> or <link
	      linkend="sedref">sed</link> in a pipe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ping</command></term>
	  <indexterm>
	    <primary>ping</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ping</secondary>
	  </indexterm>
	  <listitem>

	    <para>Broadcast an <quote>ICMP ECHO_REQUEST</quote> packet to
	      other machines, either on a local or remote network. This
	      is a diagnostic tool for testing network connections,
	      and it should be used with caution.</para>

	    <para>A successful <command>ping</command> returns an <link
	      linkend="exitstatusref">exit status</link> of
	      <errorcode>0</errorcode>. This can be tested for in a
	      script.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>ping localhost</userinput>
<computeroutput>PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.
 Warning: time of day goes back, taking countermeasures.
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec

 --- localhost.localdomain ping statistics ---
 2 packets transmitted, 2 packets received, 0% packet loss
 round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="whoisref"><command>whois</command></term>
	  <indexterm>
	    <primary>whois</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>domain name server</secondary>
	  </indexterm>
	  <listitem>
	    <para>Perform a DNS (Domain Name System) lookup.
	      The <option>-h</option> option permits specifying which
	      <emphasis>whois</emphasis> server to query. See <xref
	      linkend="ex18">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>finger</command></term>
	  <indexterm>
	    <primary>finger</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>finger</secondary>
	  </indexterm>
	  <listitem>

	    <para>Retrieve information about a particular user on
	      a network. Optionally, this command can display
	      the user's <filename>~/.plan</filename>,
	      <filename>~/.project</filename>, and
	      <filename>~/.forward</filename> files, if present.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>finger bozo</userinput>
<computeroutput>Login: bozo                             Name: Bozo Bozeman
 Directory: /home/bozo                   Shell: /bin/bash
 On since Fri Aug 31 20:13 (MST) on tty1    1 hour 38 minutes idle
 On since Fri Aug 31 20:13 (MST) on pts/0   12 seconds idle
 On since Fri Aug 31 20:13 (MST) on pts/1
 On since Fri Aug 31 20:31 (MST) on pts/2   1 hour 16 minutes idle
 No mail.
 No Plan.</computeroutput>
	      </screen>
	    </para>
	      
	    <para>Out of security considerations, many networks disable
	      <command>finger</command> and its associated daemon.
	          <footnote>
		  <para><anchor id="daemonref"></para>
		  <para>A <emphasis>daemon</emphasis> is a background
		    process not attached to a terminal session. Daemons
		    perform designated services either at specified times
		    or explicitly triggered by certain events.</para>
		  <para>The word <quote>daemon</quote> means ghost in
		    Greek, and there is certainly something mysterious,
		    almost supernatural, about the way UNIX daemons
		    silently wander about behind the scenes, carrying
		    out their appointed tasks.</para>
	          </footnote>
	      </para>
	  
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="commremote">
        <title><anchor id="commremote1">Remote Host Access</title>

	<varlistentry>
	  <term><command>sx</command></term>
	  <term><command>rx</command></term>
	  <indexterm>
	    <primary>sx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sx</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>rx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rx</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>sx</command> and <command>rx</command>
	      command set serves to transfer files to and from a remote
	      host using the <emphasis>xmodem</emphasis> protocol. These
	      are generally part of a communications package, such as
	      <command>minicom</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sz</command></term>
	  <term><command>rz</command></term>
	  <indexterm>
	    <primary>sz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sz</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>rz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rz</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>sz</command> and <command>rz</command>
	      command set serves to transfer files to and from a remote
	      host using the <emphasis>zmodem</emphasis> protocol.
	      <emphasis>Zmodem</emphasis> has certain advantages over
	      <emphasis>xmodem</emphasis>, such as greater transmission
	      rate and resumption of interrupted file transfers.
	      Like <command>sx</command> and <command>rx</command>,
	      these are generally part of a communications package.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="ftpref"><command>ftp</command></term>
	  <indexterm>
	    <primary>ftp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file transfer</secondary>
	  </indexterm>
	  <listitem>
	    <para>Utility and protocol for uploading / downloading
	      files to / from a remote host. An ftp session can be automated
	      in a script (see <xref linkend="ex72">, <xref
	      linkend="encryptedpw">, and <xref linkend="ftpget">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cu</command></term>
	  <indexterm>
	    <primary>cu</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>call up</secondary>
	  </indexterm>
	  <listitem>
	    <para><emphasis>C</emphasis>all <emphasis>U</emphasis>p
	      a remote system and connect as a simple terminal. This
	      is a sort of dumbed-down version of <link
	      linkend="telnetref">telnet</link>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uucp</command></term>
	  <indexterm>
	    <primary>uucp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uucp</secondary>
	  </indexterm>
	  <listitem>

	    <para><emphasis>UNIX to UNIX copy</emphasis>. This is a
	      communications package for transferring files between UNIX
	      servers. A shell script is an effective way to handle a
	      <command>uucp</command> command sequence.</para>

	    <para>Since the advent of the Internet and e-mail,
	      <command>uucp</command> seems to have faded into obscurity,
	      but it still exists and remains perfectly workable in
	      situations where an Internet connection is not available
	      or appropriate.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="telnetref"><command>telnet</command></term>
	  <indexterm>
	    <primary>telnet</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>telnet</secondary>
	  </indexterm>
	  <listitem>
	    <para>Utility and protocol for connecting to a remote host.</para>
	    <caution><para>The telnet protocol contains security holes and
	      should therefore probably be avoided.</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rlogin</command></term>
	  <indexterm>
	    <primary>rlogin</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote login</secondary>
	  </indexterm>
	  <listitem>
	    <para><replaceable>Remote login</replaceable>, initates a
	      session on a remote host. This command has security issues,
	      so use <link linkend="sshref">ssh</link> instead.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rsh</command></term>
	  <indexterm>
	    <primary>rsh</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote shell</secondary>
	  </indexterm>
	  <listitem>
	    <para><replaceable>Remote shell</replaceable>, executes
	      command(s) on a remote host. This has security issues,
	      so use <command>ssh</command> instead.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rcp</command></term>
	  <indexterm>
	    <primary>rcp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote copy</secondary>
	  </indexterm>
	  <listitem>
	    <para><replaceable>Remote copy</replaceable>, copies files
	      between two different networked machines.  Using
	      <command>rcp</command> and similar utilities with
	      security implications in a shell script may not be
	      advisable. Consider, instead, using <command>ssh</command>
	      or an <command>expect</command> script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="sshref"><command>ssh</command></term>
	  <indexterm>
	    <primary>ssh</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>secure shell</secondary>
	  </indexterm>
	  <listitem>
	    <para><replaceable>Secure shell</replaceable>, logs onto
	      a remote host and executes commands there. This
	      secure replacement for <command>telnet</command>,
	      <command>rlogin</command>, <command>rcp</command>, and
	      <command>rsh</command> uses identity authentication
	      and encryption. See its <emphasis>manpage</emphasis>
	      for details.</para>
	  </listitem>
	</varlistentry>
       
       </variablelist>	


      <variablelist id="commlocal">
        <title><anchor id="commlocal1">Local Network</title>

	<varlistentry>
	  <term><anchor id="writeref"><command>write</command></term>
	  <indexterm>
	    <primary>write</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>write</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is a utility for terminal-to-terminal communication.
	      It allows sending lines from your terminal (console
	      or xterm) to that of another user. The <link
	      linkend="mesgref">mesg</link> command may, of course,
	      be used to disable write access to a terminal</para>

	    <para>Since <command>write</command> is interactive, it
	      would not normally find use in a script.</para>
	  </listitem>
	</varlistentry>

       </variablelist>	


      <variablelist id="commmail">
        <title><anchor id="commmail1">Mail</title>

	<varlistentry>
	  <term><command>vacation</command></term>
	  <indexterm>
	    <primary>vacation</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mail</secondary>
	  </indexterm>
	  <listitem>
	    <para>This utility automatically replies to e-mails that
	      the intended recipient is on vacation and temporarily
	      unavailable. This runs on a network, in conjunction with
	      <command>sendmail</command>, and is not applicable to a
	      dial-up POPmail account.</para>
	  </listitem>
	</varlistentry>

       </variablelist>	

	</sect1> <!-- End Communications Commands -->



      <sect1 id="terminalccmds">
        <title>Terminal Control Commands</title>

       <variablelist id="termcommandlisting">	
         <title><anchor id="termcommandlisting1">Command Listing</title>

	<varlistentry>
	  <term><command>tput</command></term>
	  <indexterm>
	    <primary>tput</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>terminal</secondary>
	  </indexterm>
	  <listitem>

	    <para>Initialize terminal and/or fetch information about it from
	      <filename>terminfo</filename> data. Various options permit
	      certain terminal operations.  <command>tput clear</command>
	      is the equivalent of <command>clear</command>,
	      below. <command>tput reset</command> is the equivalent of
	      <command>reset</command>, below.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>tput longname</userinput>
<computeroutput>xterm terminal emulator (XFree86 4.0 Window System)</computeroutput>
	      </screen>
	    </para>

	    <para>Note that <link linkend="sttyref">stty</link> offers
	      a more powerful command set for controlling a terminal.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>reset</command></term>
	  <indexterm>
	    <primary>reset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>reset</secondary>
	  </indexterm>
	  <listitem>
	    <para>Reset terminal parameters and clear text screen. As with
	    <command>clear</command>, the cursor and prompt reappear in the
	    upper lefthand corner of the terminal.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="clearref"><command>clear</command></term>
	  <indexterm>
	    <primary>clear</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>clear</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>clear</command> command simply clears
	      the text screen at the console or in an xterm. The
	      prompt and cursor reappear at the upper lefthand corner
	      of the screen or xterm window. This command may be used
	      either at the command line or in a script. See <xref
	      linkend="ex30">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>script</command></term>
	  <indexterm>
	    <primary>script</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>script</secondary>
	  </indexterm>
	  <listitem>
	    <para>This utility records (saves to a file) all the user keystrokes at
	      the command line in a console or an xterm window. This, in effect,
	      create a record of a session.</para>
	  </listitem>
	</varlistentry>

       </variablelist>	

	</sect1> <!-- End Terminal Control Commands -->

	
      <sect1 id="mathc">
        <title>Math Commands</title>

       <variablelist id="mathcommandlisting">	
         <title><anchor id="mathcommandlisting1">Command Listing</title>

      <varlistentry>
	<term><command>factor</command></term>
	  <indexterm>
	    <primary>factor</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>factor</secondary>
	  </indexterm>
	  <listitem><para>Decompose an integer into prime factors.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>factor 27417</userinput>
<computeroutput>27417: 3 13 19 37</computeroutput>
	      </screen>
	    </para>

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor id="bcref"><command>bc</command></term>
	  <term><command>dc</command></term>
	  <indexterm>
	    <primary>bc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bc</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dc</secondary>
	  </indexterm>
	  <listitem>
	    <para>These are flexible, arbitrary precision calculation
	      utilities.</para>
	    <para><command>bc</command> has a syntax vaguely resembling C.</para>
	    <para><command>dc</command> uses RPN (<quote>Reverse Polish
	      Notation</quote>).</para>
	    <para>Of the two, <command>bc</command> seems more useful in
	       scripting. It is a fairly well-behaved UNIX utility, and may
	       therefore be used in a pipe.</para> 

	    <para>Bash can't handle floating point calculations, and
	      it lacks operators for certain important mathematical
	      functions. Fortunately, <command>bc</command> comes to
	      the rescue.</para>

	    <para>Here is a simple template for using
	      <command>bc</command> to calculate a script variable.</para>

	      <para>
              <screen>
	      <userinput>variable=$(echo "OPTIONS; OPERATIONS" | bc)</userinput>
	      </screen>
	      </para>

            <example id="monthlypmt">
              <title>Monthly Payment on a Mortgage</title>
              <programlisting>&monthlypmt;</programlisting>
            </example>

            <example id="base">
              <title>Base Conversion</title>
              <programlisting>&base;</programlisting>
            </example>

	  </listitem>
	</varlistentry>

       </variablelist>	

	</sect1> <!-- End Math Commands -->


      <sect1 id="extmisc">
        <title>Miscellaneous Commands</title>

       <variablelist id="misccommandlisting">	
         <title><anchor id="misccommandlisting1">Command Listing</title>

	<varlistentry>
	  <term><command>jot</command></term>
	  <term><command>seq</command></term>
	  <indexterm>
	    <primary>jot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>jot</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>seq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>seq</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>arguments</secondary>
	  </indexterm>
	  <listitem>
	    <para>These utilities emit a sequence of integers, with a
	      user selected increment. This can be used to advantage in
	      a <link linkend="forloopref1">for loop</link>.</para>

	    <example id="ex53">
	      <title>Using <command>seq</command> to generate loop arguments</title>
	      <programlisting>&ex53;</programlisting>
	    </example>	    	   
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="runpartsref"><command>run-parts</command></term>
	  <indexterm>
	    <primary>run-parts</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>run-parts</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>run-parts</command> command

		<footnote><para>This is actually a script adapted from
		the Debian Linux distribution.</para></footnote>
	      
	      executes all the scripts in a target directory, sequentially
	      in ASCII-sorted filename order. Of course, the scripts
	      need to have execute permission.</para>
	      
	    <para>The <link linkend="cronref">crond</link> <link
	      linkend="daemonref">daemon</link> invokes
	      <command>run-parts</command> to run the scripts in
	      the <filename class="directory">/etc/cron.*</filename>
	      directories.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>yes</command></term>
	  <indexterm>
	    <primary>yes</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>yes</secondary>
	  </indexterm>
	  <listitem>

	    <para>In its default behavior the <command>yes</command>
	      command feeds a continuous string of the character
	      <computeroutput>y</computeroutput> followed
	      by a line feed to <filename>stdout</filename>. A
	      <keycombo><keycap>control</keycap><keycap>c</keycap></keycombo>
	      terminates the run. A different output string
	      may be specified, as in <userinput>yes different
	      string</userinput>, which would continually output
	      <computeroutput>different string</computeroutput> to
	      <filename>stdout</filename>.  One might well ask the purpose
	      of this. From the command line or in a script, the output
	      of <command>yes</command> can be redirected or piped into a
	      program expecting user input. In effect, this becomes a sort
	      of poor man's version of <command>expect</command>.</para>

	    <para><userinput>yes | fsck /dev/hda1</userinput> runs
	      <command>fsck</command> non-interactively (careful!).</para>

	   <para><userinput>yes | rm -r dirname</userinput> has same effect as
	     <userinput>rm -rf dirname</userinput> (careful!).</para>

	   <warning><para>Be very cautious when piping <command>yes</command>
	     to a potentially dangerous system command, such as
	     <link linkend="fsckref">fsck</link> or
	     <link linkend="fdiskref">fdisk</link>.</para></warning>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>banner</command></term>
	  <indexterm>
	    <primary>banner</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>banner</secondary>
	  </indexterm>
	  <listitem>
	    <para>Prints arguments as a large vertical banner to
	      <filename>stdout</filename>, using an ASCII character
	      (default '#'). This may be redirected to a printer for
	      hardcopy.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>printenv</command></term>
	  <indexterm>
	    <primary>printenv</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>environment</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show all the environmental variables set for a particular
	      user.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>printenv | grep HOME</userinput>
<computeroutput>HOME=/home/bozo</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lp</command></term>
	  <indexterm>
	    <primary>lp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lpr</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>lp</command> and <command>lpr</command>
	      commands send file(s) to the print queue, to be printed as
	      hard copy.

	      <footnote><para>The <emphasis>print queue</emphasis> is
	      the group of jobs <quote>waiting in line</quote> to be
	      printed.</para></footnote>

	      These commands trace the origin of their names to the
	      line printers of another era.</para>

	      <para><prompt>bash$ </prompt><userinput>lp file1.txt</userinput>
	        or <prompt>bash </prompt><userinput>lp
		&lt;file1.txt</userinput></para>

	      <para>It is often useful to pipe the formatted output from
	        <command>pr</command> to <command>lp</command>.</para>

	      <para><prompt>bash$ </prompt><userinput>pr -options file1.txt | lp</userinput>
	        </para>

	      <para>Formatting packages, such as <command>groff</command> and
	        <emphasis>Ghostscript</emphasis> may send their output
		directly to <command>lp</command>.</para>

	      <para><prompt>bash$ </prompt><userinput>groff -Tascii file.tr | lp</userinput>
	        </para>

	      <para><prompt>bash$ </prompt><userinput>gs -options | lp file.ps</userinput>
	        </para>

	      <para>Related commands are <command>lpq</command>, for viewing
	        the print queue, and <command>lprm</command>, for removing
		jobs from the print queue.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tee</command></term>
	  <indexterm>
	    <primary>tee</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tee</secondary>
	  </indexterm>
	  <listitem>
	    <para>[UNIX borrows an idea here from the plumbing trade.]</para>
	    <para>This is a redirection operator, but with a difference. Like the
	      plumber's <emphasis>tee</emphasis>, it permits <quote>siponing
		off</quote> the output of a command 
	      or commands within a pipe, but without affecting the result. This is
	      useful for printing an ongoing process to a file or paper, perhaps to
	      keep track of it for debugging purposes.</para>
	    
	    <screen>
                   tee
                 |------> to file
                 |
  ===============|===============
  command--->----|-operator-->---> result of command(s)
  ===============================
	      </screen>


	    <para><programlisting>cat listfile* | sort | tee check.file | uniq > result.file</programlisting>
	      (The file <filename>check.file</filename> contains
	      the concatenated sorted <quote>listfiles</quote>,
	      before the duplicate lines are removed by <link
	      linkend="uniqref">uniq</link>.)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mkfifo</command></term>
	  <indexterm>
	    <primary>mkfifo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkfifo</secondary>
	  </indexterm>
	  <listitem>
	    <para><anchor id="namedpiperef">This obscure command
	      creates a <emphasis>named pipe</emphasis>, a temporary
	      <emphasis>first-in-first-out buffer</emphasis> for
	      transferring data between processes.

		<footnote><para>For an excellent overview of this
		  topic, see Andy Vaught's article, <ulink
		  url="http://www2.linuxjournal.com/lj-issues/issue41/2156.html">Introduction
		  to Named Pipes</ulink>, in the September, 1997 issue
		  of <ulink url="http://www.linuxjournal.com">Linux
		  Journal</ulink>.</para></footnote>

	      Typically, one process writes to the FIFO, and the other
	      reads from it. See <xref linkend="fifo">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>pathchk</command></term>
	  <indexterm>
	    <primary>pathchk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pathchk</secondary>
	  </indexterm>
	  <listitem>
	    <para>This command checks the validity of a filename. If the
	      filename exceeds the maximum allowable length (255
	      characters) or one or more of the directories in
	      its path is not searchable, then an error message
	      results. Unfortunately, <command>pathchk</command> does
	      not return a recognizable error code, and it is therefore
	      pretty much useless in a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="ddref"><command>dd</command></term>
	  <indexterm>
	    <primary>dd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dd</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the somewhat obscure and much feared <quote>data
	      duplicator</quote> command.  Originally a utility
	      for exchanging data on magnetic tapes between UNIX
	      minicomputers and IBM mainframes, this command still
	      has its uses.  The <command>dd</command> command simply
	      copies a file (or <filename>stdin/stdout</filename>), but
	      with conversions. Possible conversions are ASCII/EBCDIC,
	        
		<footnote><para>EBCDIC (pronounced
		  <quote>ebb-sid-ic</quote>) is an acronym for Extended
		  Binary Coded Decimal Interchange Code. This is an IBM
		  data format no longer in much use. A bizarre
		  application of the <option>conv=ebcdic</option> option
		  of <command>dd</command> is as a quick 'n easy, but
		  not very secure text file encoder.
		    <programlisting>cat $file | dd conv=swab,ebcdic > $file_encrypted
# Encode (looks like gibberish).		    
# Might as well switch bytes (swab), too, for a little extra obscurity.

cat $file_encrypted | dd conv=swab,ascii > $file_plaintext
# Decode.</programlisting>
                </para></footnote>

	      upper/lower case, swapping of byte pairs between input
	      and output, and skipping and/or truncating the head or
	      tail of the input file. A <userinput>dd --help</userinput>
	      lists the conversion and other options that this powerful
	      utility takes.</para>

	    <para><programlisting># Exercising 'dd'.

n=3
p=5
input_file=project.txt
output_file=log.txt

dd if=$input_file of=$output_file bs=1 skip=$((n-1)) count=$((p-n+1)) 2> /dev/null
# Extracts characters n to p from file $input_file.




echo -n "hello world" | dd cbs=1 conv=unblock 2> /dev/null
# Echoes "hello world" vertically.


# Thanks, S.C.</programlisting></para>


	    <para>To demonstrate just how versatile <command>dd</command> is,
	     let's use it to capture keystrokes.</para>

	    <example id="ddkeypress">
	      <title>Capturing Keystrokes</title>
	      <programlisting>&ddkeypress;</programlisting>
	    </example>	    

	    <para>The <command>dd</command> command can do random access on a
	      data stream.

	        <programlisting>echo -n . | dd bs=1 seek=4 of=file conv=notrunc
# The "conv=notrunc" option means that the output file will not be truncated.		

# Thanks, S.C.</programlisting>
            </para>


	    <para>The <command>dd</command> command can copy raw data
	      and disk images to and from devices, such as floppies and
	      tape drives (<xref linkend="copycd">). A common use is
	      creating boot floppies.
		<programlisting>dd if=kernel-image of=/dev/fd0H1440</programlisting>
	      Other applications of <command>dd</command> include
	      initializing temporary swap files (<xref linkend="ex73">)
	      and ramdisks (<xref linkend="ramdisk">). It can even do a
	      low-level copy of an entire hard drive partition, although
	      this is not necessarily recommended.</para>

	    <para>People (with presumably nothing better to do with
	      their time) are constantly thinking of interesting
	      applications of <command>dd</command>.</para>

	    <example id="blotout">
	      <title>Securely deleting a file</title>
	      <programlisting>&blotout;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="odref"><command>od</command></term>
	  <indexterm>
	    <primary>od</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>od</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>od</command>, or <emphasis>octal
	      dump</emphasis> filter converts input (or files) to octal
	      (base-8) or other bases. This is useful for viewing or
	      processing binary data files or otherwise unreadable system
	      device files, such as <filename>/dev/urandom</filename>,
	      and as a filter for binary data. See <xref
	      linkend="seedingrandom"> and <xref linkend="rnd">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>hexdump</command></term>
	  <indexterm>
	    <primary>hexdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hexadecimal</secondary>
	  </indexterm>
	  <listitem>
	    <para>Performs a hexadecimal, octal, decimal, or ASCII
	      dump of a binary file. This command is the rough equivalent
	      of <command>od</command>, above, but not nearly as
	      useful.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>m4</command></term>
	  <indexterm>
	    <primary>m4</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>macro</secondary>
	  </indexterm>
	  <listitem>
	    <para>A hidden treasure, <command>m4</command> is a
	      powerful macro processor
		 <footnote><para>A <emphasis>macro</emphasis> is a
		 symbolic constant that expands into a command string
		 or a set of operations on parameters.</para></footnote>
	      utility, virtually a complete language. In
	      fact, <command>m4</command> combines some of the
	      functionality of <link linkend="evalref">eval</link>,
	      <link linkend="trref">tr</link>, and <link
	      linkend="awkref">awk</link>.</para>

	    <example id="m4">
	      <title>Using m4</title>
	      <programlisting>&m4;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>

        </sect1> <!-- End Miscellaneous Commands -->

  </chapter> <!-- External Filters, Programs and Commands -->
