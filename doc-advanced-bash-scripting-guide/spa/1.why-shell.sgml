  <chapter id="why-scripts">
    <title>¿Por qué programar scripts?</title>
        <para>Para cualquiera que desee ser adepto a la administración de sistemas es esencial que tenga un conocimiento práctico de la programación de scripts para intérpretes de comandos, incluso si anteriormente nunca ha escrito ningún script. Tenga en cuenta que cuando una máquina GNU/Linux se inicia, ejecuta scripts dentro de <filename class="directory">/etc/rc.d</filename> para restaurar la configuración del sistema así como configurar los dispositivos. Es importante un conocimiento exhaustivo de estos scripts de inicio para analizar el comportamiento del sistema, y posiblemente modificarlo</para>
<para>No es difícil aprender a escribir scripts para intérpretes de comandos, ya que los scripts se pueden crear dentro de secciones concretas y únicamente existen un pequeño conjunto de opciones y operadores claramente específico de un determinado intérprete de comandos.

<footnote><para>Esto se denomina <link linkend="builtinref">builtins</link>, características internas del intérprete de comando.</para></footnote>
 
 para aprender. La sintaxis es simple y sencilla, parecida  a invocar cadenas de instrucciones en la línea de comandos, y únicamente hay unas pocas <quote>reglas</quote> que aprender.
La mayoría de los scripts funcionan a la primera, e incluso depurar los largos es sencillo.
<para>Un script de intérprete de comandos es un método <quote>rápido y
sucio</quote> de prototipar una aplicación compleja. Incluso consiguiendo hacer funcionar únicamente una parte de la funcionalidad del script , o incluso lentamente, a veces es útil dentro del primer estadio de un proyecto de desarrollo. De esta manera, se puede probar la estructura de la aplicación y ejecutarla, y las trampas encontradas anteriormente se codificarían en C, C++ , Java o Perl </para>
<para> Escribir scripts de intérpretes de comando atiende a la clásica filosofía de UNIX de desmenuzar el proyecto en subtareas más simples, de encadenar juntos componentes y utilidades. Algunos consideran esto mejor, o al menos más gustoso estéticamente para la aproximación a la resolución que utilizar alguno de los lenguajes de nueva generación "todo en uno" , como Perl, que intenta ser todo para todo el mundo con el coste de de forzarle a alterar su manera de pensar los procesos para adaptarse a la herramienta.</para>
<para>Cuando no hay que utilizar scripts
	     <itmizedlist>
listitem><para>Para tareas intensivas en consumo de recursos,
especialmente si la velocidad es un factor (ordenaciones, funciones
hash, etc).</para
listitem><para>Procedimientos que requieren operaciones matemáticas de mucho peso, especialmente aritmética de coma flotante, cálculos de posición arbitraria o números complejos (mejor utilice c++ o fortran) .</para>
listitem><para>Aplicaciones complejas donde la programación estructurada sea una necesidad, (necesidades de comprobación de los caracteres de las variables, prototipos de función, etc).</para
listitem><para>Aplicaciones críticas donde Vd se juegue su sustento, o el futuro de su empresa.</para>
listitem><para>En situaciones donde la seguridad sea importante y vd
necesite garantizar la integridad del sistema ante ataques intrusivos
(hacking) , vandalismo o ataques destructivos (cracking).</para>
</listitem><para>En proyectos que contengan subcomponentes que puedan interbloquearse</para>
<listitem><para>Si se requieren hacer operaciones intensivas con ficheros (el intérprete Bash está limitado al acceso lineal a los ficheros, y este es un esquema de acceso linea a linea  particularmente torpe e ineficiente.
<listitem></listitem>
<para>Si necesita listas multidimensionales.</para>
<listitem></listitem>
<para>Con estructuras de datos como listas enlazadas o árboles.</para>
  <listitem></listitem>
<para>Si necesita generar o manipular tanto imágenes como interfaces gráficos de usuario.</para>
  <listitem></listitem>
<para>Si necesita puertos o accesos a entradas y salida a través de buzones (sockets).</para>
listitem></listitem>
<para>Si necesita utilizar bibliotecas o algún interfaz con código legados </para
<listitem></listitem>
<para>En aplicaciones propietarias o de código fuente oculto (los scripts de shell son necesariamente Open Source)</para>
</listitem>
</itemizedlist></para>
<para>Si necesita aplicar  algo de lo anteriormente mencionado, piense en un lenguaje de scripts más potente como Perl, Tcl o Python, o un lenguaje de alto nivel como C, C++ o Java. Incluso entonces, cuando prototipee la aplicación como un script de shell, seguirá siendo un paso útil dentro del desarrollo.</para>
<footnote><para>Utilizaremos Bash, cuyo acrónimo significa <quote>Bourne-Again Shell</quote> un juego de palabras sobre el ahora clásico intérprete de comandos de Stephen Bourne. Bash se ha convertido en el estándar <foreignphrase>de facto</foreignphase> de la programación de scripts para shell de todos los estilos de UNIX. La mayoría de los demás intérpretes como el intérprete Korn, deriva de Bash algunas de sus características</para>
<footnote><para> Algunas de las características de <emphasis>ksh88</emphasis>, y unas pocas de la versión actualizada <emphasis>khs93</emphasis>se han mezclado dentro de Bash</para>  <footnote>
así como en el intérprete de C y sus variantes. (A destacar que la programación en el intérprete C no es recomendada debido a problemas inherentes a él, como se indica en <ulink
      url="http://www.etext.org/Quartz/computer/unix/csh.harmful.gz">news
      group posting</ulink> por Tom Christiansen en octubre de 1993).
      </para>
<para>El siguiente cursillo de programación de scripts para
intérpretes de comandos se apoya mucho en ejemplos para ilustrar características del intérprete. Los ejemplos se han probado siempre que ha sido posible y algunos de ellos pueden seguir siendo útiles en la vida cotidiana. El lector debería utilizar los ficheros reales que están en el archivo fuente <filename>something-or-other.sh</filename>),

<footnote><para>Los scripts de intérprete de comandos escritos en Bash
por usuarios se nombraran convencionalmente terminándolos con la
extensión <filename>.sh</filename>. Los scripts de sistemas como los
que se encuentran en <filename class="directory">/etc/rc.d</filename>,
no siguen este esquema.</para></footnote>
Aplíquele el permiso de ejecución <userinput>chmod u+rx nombredescript, ejecútelo para ver lo que ocurre. Puede ser que el código fuente no esté disponible, en ese caso copie y pegue desde la versión HTML, pdf o texto renderizado disponible. Tenga en cuenta que algunos de los scripts de abajo utilizan características antes de que sean explicadas, lo cual requiere que el lector las obvie temporalmente hasta su esclarecimiento.</para>
<para>A menos que se diga lo contrario, el autor del libro es el autor de los scripts que vienen a continuación.</para>
</chapter><!--- Porque programar script? -->