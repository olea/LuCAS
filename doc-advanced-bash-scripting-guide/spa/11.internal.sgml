  <chapter id="internal">
    <title>Comandos internos e integrados (builtins)</title>


      <indexterm>
	<primary>builtin</primary>
      </indexterm>


      <para><anchor id="builtinref">Un <firstterm>comando integrado</firstterm> es un comando contenido en las herramientas de BASH, litaralmente <emphasis>dentro de Bash</emphasis>.El nombre de un comando integrado puede ser el mismo que el de un comando de comando del sistema, pero Bash lo reimplemente internamente..</para>
          
	  <footnote><para>Esto puede ser por razones de despempeño (los comandos integrados se ejecutan mucho más rápido que los comandos externos, que usualmente requieren <emphasis>crear</emphasis> un proceso adicional), o porque el comando integrado necesita acceso a datos internos del shell.</para></footnote>

	Por ejemplo, el comando <command>echo</command> de bash, no es el mismo que <filename>/bin/echo</filename>, aunque su comporamiento es casi idéntico.</para>

      <para><anchor id="keywordref">Una <firstterm>Palabra Clave</firstterm> es una palabra <emphasis>reservada</emphasis>, token u operador. Las palabras clave tiene un significado especial para el interpretador de comandos. y son, asimismo, la base de la sintaxis del intepretador de comandos.	Algunos ejemplos de esto son <quote><token>for</token></quote>,	<quote><token>while</token></quote> y <quote><token>!</token></quote>, estas son palabras claves. Similar to a 	Al igual que un <emphasis>comando integrado</emphasis>, una palabra clave esta escrita dentro del mismo Bash.</para>

      <variablelist id="intio">
        <title><anchor id="intio1">I/O (Entrada/Salida)</title>

	<varlistentry>
	  <term><anchor id="echoref"><command>echo</command></term>
	  <indexterm>
	    <primary>echo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>commando</primary>
	    <secondary>echo</secondary>
	  </indexterm>
	  <listitem>
	    <para>imprime (a <filename>stdout</filename>) una expresion o variable (ver <xref linkend="ex9">). 
	      <programlisting>echo HOLA
echo $a</programlisting></para>
	    
	    <para>El comando  <command>echo</command> requiere la opcion <option>-e</option> para imprimir caracteres especiales (escapes). Ver <xref linkend="escaped">.</para>
	    <para>Normalmente, cada vez que se ejecuta, <command>echo</command> imprime una nueva línea en la terminal, pero la opción <option>-n</option> evita esto.</para>

	    <note>
	    <para><command>echo</command> puede ser usado para pasar un argumento en un pipe.</para>
	    <para><programlisting>if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
then
  echo "$VAR contains the substring sequence \"txt\""
fi</programlisting></para>  
	    </note>  

	    <note><para><command>echo</command>combinado con <link linkend="commandsubref">substitución de comandos</link> puede asignar una variable.<para> <para><userinput>a=`echo  "HELLO" | tr A-Z a-z`</userinput></para>
	      <para>Vea tambien <xref linkend="lowercase">, <xref
	      linkend="ex57">, <xref linkend="monthlypmt">, y <xref
	      linkend="base">.</para></note>


	    <caution><para>Cuidado, el <command>'comando' echo </command> borra cualquier avance de línea que <replaceable>un comando</replaceable> genere. Como <varname>$IFS</varname> contiene <token>\n</token> como componente de su lista de los caracteres de <link kinkend="whitespaceref">espacio blanco</link>, Bash segmenta la salida de <replaceable>un comando</repleaceable> a un avance de línea con argumentos a <command>echo</command> quien imprime en pantalla esos argumentos separados por espacios.</para>
	      
	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput> printf '\n\n1\n2\n3\n\n\n\n'</userinput>
<computeroutput>


 1
 2
 3



</computeroutput>
<prompt>bash $</prompt>




<prompt>bash$ </prompt><userinput>echo "`printf '\n\n1\n2\n3\n\n\n\n'`"</userinput>
<computeroutput>


 1
 2
 3
</computeroutput>
<prompt>bash $</prompt>
	      </screen>
	    </para>
	      </caution>

	    <note>
	    <para>Este comando está incorporado en el shell, y no es el mismo que <filename>/bin/bash</filename>, sin embargo su comportamiento es similar.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>type -a echo</userinput>
<computeroutput>echo is a shell builtin
 echo is /bin/echo</computeroutput>
	      </screen>
	  </para>
	    </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="printfref"><command>printf</command></term>
	  <indexterm>
	    <primary>printf</primary>
	  </indexterm>
	  <indexterm>
	    <primary>commando</primary>
	    <secondary>printf</secondary>
	  </indexterm>
	  <listitem>
	    <para>El comando <command>printf</command>, formatted print, es una versión mejorada de <command>echo</command>. Es una variación limitada de <function>printf</function> del Lenguaje C, y su sintaxis es un poco diferente.</para>
	    <cmdsynopsis>
	      <command>printf</command>
	      <arg choice=plain rep=repeat><replaceable>cadena-de-formato</replaceable></arg>
	      <arg choice=plain rep=repeat><replaceable>parametro</replaceable></arg>
	    </cmdsynopsis>

	    <para>Esta es la versión incorporada en bash de <filename>/bin/printf</filename> o <filename>/usr/bin/printf</filename>. Vea la página de manual de <command>printf</command> para más nformación.</para>

	    <caution><para>Versiones más viejas de BASH pueden no soportar <command>printf</command>.</para></caution>

	    <example id="ex47">
	      <title><command>printf</command> en acción</title>
	      <programlisting>&ex47;</programlisting>
	    </example>

	    <para>Darle formato a los mensajes de error es un uso muy útil de <command>printf</command></para>

            <para>
	        <programlisting>E_BADDIR=65

var=nonexistent_directory

error()
{
  printf "$@" >&2
  # Da formato a los parametros de posicion pasados y los redirige a stderr (salida estadnar de error).
  echo
  exit $E_BADDIR
}

cd $var || error $"Can't cd to %s." "$var"

# Thanks, S.C.</programlisting>
            </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="readref"><command>read</command></term> <indexterm>
	    <primary>read</primary>
	  </indexterm> <indexterm>
	    <primary>commando</primary> <secondary>read</secondary>
	  </indexterm> <listitem><para><quote>Lee</quote> el valor de una variable de <filename>stdin</filename>, es decir, toma la entrada del teclado de forma interactiva. La opción <option>-a</option> permite que <command>read</command> lea matrices de variables (arrays)(Ver:<xref linkend="ex67">).</para>

	    <example id="ex36">
	      <title>Asignar variables, usando <command>read</command></title>
	      <programlisting>&ex36;</programlisting>
	    </example>

	    <para>Normalmente, poniendo una <userinput>\</userinput>evita el inicio de una nueva línea mientras se escribe a <command>read</command>. la opción <option>-r</option>Causa que se interprete todo literalmente, incluso la <userinput>\</userinput>.</para>

	    <example id="readr">
	      <title>Entrada de múltiples líneas a <command>read</command></title>
	      <programlisting>&readr;</programlisting>
	    </example>

	    
	    <para>El comando <command>read</command> tiene opciones interesantes que permiten poner un <em>prompt</em>.</para>

	    <para><programlisting># Read a keypress without hitting ENTER.

read -s -n1 -p "Hit a key " keypress
echo; echo "Keypress was "\"$keypress\""."

# -s option means do not echo input.
# -n N option means accept only N characters of input.
# -p option means echo the following prompt before reading input.

# Using these options is tricky, since they need to be in the correct order.</programlisting></para>


	    <para>The <command>read</command> command may also
	      <quote>read</quote> its variable value from a file
	      <link linkend="ioredirref">redirected</link> to
	      <filename>stdin</filename>.  If the file contains
	      more than one line, only the first line is assigned
	      to the variable. If <command>read</command>
	      has more than one parameter, then each of
	      these variables gets assigned a successive <link
	      linkend="whitespaceref">whitespace-delineated</link>
	      string. Caution!</para>

	    <example id="readredir">
	      <title>Using <command>read</command> with
	        <link linkend="ioredirref">file redirection</link></title>
	      <programlisting>&readredir;</programlisting>
	    </example>

	    </listitem>
	  </varlistentry>

      </variablelist>

      <variablelist id="intfilesystem">
        <title><anchor id="intfilesystem1">Filesystem</title>

	<varlistentry>
	  <term><command>cd</command></term>
	  <indexterm>
	    <primary>cd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cd</secondary>
	  </indexterm>
	  <listitem>
	    <para>The familiar <command>cd</command> change directory
	      command finds use in scripts where execution of a command
	      requires being in a specified directory.</para>

	    <para>  
	      <programlisting>(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)</programlisting>
	      [from the <link linkend="coxex">previously cited</link>
	      example by Alan Cox]</para>

	    <para>The <option>-P</option> (physical) option to
	      <command>cd</command> causes it to ignore symbolic
	      links.</para>

	    <para><command>cd -</command> changes to <link
	    linkend="oldpwd">$OLDPWD</link>, the previous working
	    directory.</para>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><anchor id="pwd2ref"><command>pwd</command></term>
	  <indexterm>
	    <primary>pwd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pwd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <listitem><para>Print Working Directory. This gives the user's
	      (or script's) current directory (see <xref
	      linkend="ex37">). The effect is identical to
	      reading the value of the builtin variable <link
	      linkend="pwdref">$PWD</link>.</para>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><anchor id="dirsd"><command>pushd</command></term>
	<term><command>popd</command></term>
	<term><command>dirs</command></term>
	  <indexterm>
	    <primary>pushd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pushd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>popd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>popd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dirs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>bookmark</primary>
	  </indexterm>
	  <listitem><para>This command set is a mechanism for bookmarking working directories,
	      a means of moving back and forth through directories in an orderly
	      manner.  A pushdown stack is used to keep track of directory names.
	      Options allow various manipulations of the directory stack.</para>

	    <para><anchor id="pushdref"><userinput>pushd
	      dir-name</userinput> pushes the path
	      <replaceable>dir-name</replaceable> onto the directory
	      stack and simultaneously changes the current working
	      directory to <replaceable>dir-name</replaceable></para>

	    <para><anchor id="popdref"><command>popd</command> removes (pops) the top directory path
	      name off the directory stack and simultaneously changes the
	      current working directory to that directory popped from the stack.
	      </para>
	    
	    <para><command>dirs</command> lists the contents of the directory
	      stack (counterpart to <link
	      linkend="dirstackref">$DIRSTACK</link>) A successful
	      <command>pushd</command> or <command>popd</command> will
	      automatically invoke <command>dirs</command>.</para>


	    <para>Scripts that require various changes to the current
	      working directory without hard-coding the directory name
	      changes can make good use of these commands. Note that
	      the implicit <varname>$DIRSTACK</varname> array variable,
	      accessible from within a script, holds the contents of
	      the directory stack.
	    </para>

	    <example id="ex37">
	      <title>Changing the current working directory   </title>
	      <programlisting>&ex37;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="intvar">
        <title><anchor id="intvar1">Variables</title>

	<varlistentry>
	  <term><anchor id="letref"><command>let</command></term>
	  <indexterm>
	    <primary>let</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>let</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>let</command> command carries out arithmetic
	      operations on variables. In many cases, it functions as a less
	      complex version of <link linkend="exprref">expr</link>.</para>

	    <example id="ex46">
	      <title>Letting <command>let</command> do some arithmetic.</title>
	      <programlisting>&ex46;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="evalref"><command>eval</command></term>
	  <indexterm>
	    <primary>eval</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>eval</secondary>
	  </indexterm>
	  <listitem>
	    
	    <para><userinput>eval arg1 [arg2] ... [argN]</userinput></para>
	    
	    <para>Translates into commands the arguments in a list
	      (useful for code generation within a script).</para>

	    <example id="ex43">
	      <title>Showing the effect of <command>eval</command></title>
	      <programlisting>&ex43;</programlisting>
	    </example>	    

	    <example id="ex44">
	      <title>Forcing a log-off</title>
	      <programlisting>&ex44;</programlisting>
	    </example>	    

	    <example id="rot13_2">
	      <title>A version of <quote>rot13</quote></title>
	      <programlisting>&rot13_2;</programlisting>
	    </example>	    

	    <caution><para>The <command>eval</command> command can be
	      risky, and normally should be avoided when there
	      exists a reasonable alternative. An <userinput>eval
	      $COMMANDS</userinput> executes the contents of
	      <replaceable>COMMANDS</replaceable>, which may
	      contain such unpleasant surprises as <command>rm -rf
	      *</command>. Running an <command>eval</command> on
	      unfamiliar code written by persons unknown is living
	      dangerously.</para></caution>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="setref"><command>set</command></term>
	  <indexterm>
	    <primary>set</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>set</secondary>
	  </indexterm>
	  <listitem><para>The <command>set</command> command changes the value
	      of internal script variables. One use for this
	      is to toggle <link linkend="optionsref">option
	      flags</link> which help determine the behavior of the
	      script. Another application for it is to reset the <link
	      linkend="posparamref">positional parameters</link> that
	      a script sees as the result of a command (<userinput>set
	      `command`</userinput>). The script can then parse the
	      fields of the command output.</para>

	    <example id="ex34">
	      <title>Using <command>set</command> with positional
	      parameters</title> <programlisting>&ex34;</programlisting>
	    </example>

	    <para>See also <xref linkend="ex22a">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="unsetref"><command>unset</command></term>
	  <indexterm>
	    <primary>unset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unset</secondary>
	  </indexterm>
	  <listitem><para>The <command>unset</command> command deletes a
	      shell variable, effectively setting it to
	      <emphasis>null</emphasis>. Note that this command does
	      not affect positional parameters.</para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>unset PATH</userinput>

<prompt>bash$ </prompt><userinput>echo $PATH</userinput>
<computeroutput>


</computeroutput>
<prompt>bash$ </prompt></screen>
	    </para>

	    <example id="uns">
	      <title><quote>unsetting</quote> a variable</title>
	      <programlisting>&uns;</programlisting>
	    </example>

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor id="exportref"><command>export</command></term>
	  <indexterm>
	    <primary>export</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>export</secondary>
	  </indexterm>
	  <listitem><para>The <command>export</command> command makes
	      available variables to all child processes of the
	      running script or shell. Unfortunately, there is no way
	      to <command>export</command> variables back to the parent
	      process, to the process that called or invoked the script
	      or shell. One important use of <command>export</command>
	      command is in <link linkend="filesref">startup files</link>,
	      to initialize and make accessible environmental variables
	      to subsequent user processes.</para>


	  <example id="coltotaler3">
	    <title>Using <command>export</command> to pass a variable to an
	      embedded <link linkend="awkref">awk</link> script</title>
	    <programlisting>&coltotaler3;</programlisting>
	  </example>



	      <tip><para>It is possible to initialize and export
		variables in the same operation, as in <command>export
		var1=xxx</command>.</para></tip>

	    </listitem>
	  </varlistentry>
	
	<varlistentry>
	  <term><command>declare</command></term>
	  <term><command>typeset</command></term>
	  <indexterm>
	    <primary>declare</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>declare</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>typeset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>typeset</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <link linkend="declareref">declare</link> and
	      <link linkend="declareref">typeset</link> commands specify
	      and/or restrict properties of variables.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>readonly</command></term>
	  <indexterm>
	    <primary>readonly</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>readonly</secondary>
	  </indexterm>
	  <listitem><para>Same as <link linkend="declareref">declare -r</link>,
	      sets a variable as read-only, or, in effect, as a
	      constant. Attempts to change the variable fail with an
	      error message. This is the shell analog of the C language
	      <command>const</command> type qualifier.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="getoptsx"><command>getopts</command></term>
	  <indexterm>
	    <primary>getopts</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>getopts</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTIND</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTIND</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTARG</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTARG</secondary>
	  </indexterm>
	  <listitem>
	    <para>This powerful tool parses command line arguments passed to the
	      script. This is the bash analog of the <command>getopt</command>
	      library function familiar to C programmers. It permits passing and
	      concatenating multiple options

	      <footnote><para>A option is an argument that acts as a
		flag, switching script behaviors on or off. The
		argument associated with a particular option indicates
		the behavior that the option (flag) switches on or
		off.</para></footnote>

	      and associated arguments to a script (for
	      example <userinput>scriptname -abc -e
	      /usr/local</userinput>).</para>

	    <para>The <command>getopts</command> construct uses two implicit
	      variables. <varname>$OPTIND</varname> is the argument
	      pointer (<wordasword>OPTion INDex</wordasword>)
	      and <varname>$OPTARG</varname> (<wordasword>OPTion
	      ARGument</wordasword>) the (optional) argument attached
	      to an option. A colon following the option name in the
	      declaration tags that option as having an associated
	      argument.</para>

	    <para>A <command>getopts</command> construct usually comes
	      packaged in a <link linkend="whileloopref">while
	      loop</link>, which processes the options and
	      arguments one at a time, then decrements the implicit
	      <varname>$OPTIND</varname> variable to step to the
	      next.</para>

	    <note>
	      <para>
		<orderedlist>
		  <listitem>

		    <para>The arguments must be passed from the
		      command line to the script preceded by
		      a minus (<option>-</option>) or a plus
		      (<option>+</option>).  It is the prefixed
		      <option>-</option> or <option>+</option> that lets
		      <command>getopts</command> recognize command-line
		      arguments as <emphasis>options</emphasis>.
		      In fact, <command>getopts</command> will not process
		      arguments without the prefixed <option>-</option>
		      or <option>+</option>, and will terminate option
		      processing at the first argument encountered
		      lacking them.</para>

		  </listitem>
		  <listitem><para>The <command>getopts</command> template
		      differs slightly from the standard <command>while</command>
		      loop, in that it lacks condition brackets.</para>
		  </listitem>
		  <listitem>

		  <para>The <command>getopts</command>
		     construct replaces the obsolete
		     <command>getopt</command> command.</para>

		   </listitem>
		</orderedlist>
	      </para>
	    </note>

	    <para><programlisting>
while getopts ":abcde:fg" Option
# Initial declaration.
# a, b, c, d, e, f, and g are the options (flags) expected.
# The : after option 'e' shows it will have an argument passed with it.
do
  case $Option in
    a ) # Do something with variable 'a'.
    b ) # Do something with variable 'b'.
    ...
    e)  # Do something with 'e', and also with $OPTARG,
        # which is the associated argument passed with option 'e'.
    ...
    g ) # Do something with variable 'g'.
  esac
done
shift $(($OPTIND - 1))
# Move argument pointer to next.

# All this is not nearly as complicated as it looks &lt;grin&gt;.
	      </programlisting></para>

	    <example id="ex33">
	      <title>Using <command>getopts</command> to read the
	        options/arguments passed to a script</title>
	      <programlisting>&ex33;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="intscrbeh">
        <title><anchor id="intscrbeh1">Script Behavior</title>

      <varlistentry>
	<term><anchor id="sourceref"><command>source</command></term>
	<term><token>.</token> (<link linkend="dotref">dot</link> command)</term>
	  <indexterm>
	    <primary>source</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>source</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>.</secondary>
	  </indexterm>

	  <listitem><para>This command, when invoked from the command line, executes a script. Within
	      a script, a <userinput>source file-name</userinput> loads the file
	      <filename>file-name</filename>. This is the 
	      shell scripting equivalent of a C/C++ <userinput>#include</userinput>
	      directive. It is useful in situations when multiple scripts use a
	      common data file or function library.</para>

	    <example id="ex38">
	      <title><quote>Including</quote> a data file</title>
	      <programlisting>&ex38;</programlisting>
	      <para>File <filename>data-file</filename> for <xref linkend="ex38">, above.
		Must be present in same directory.</para>
	      <programlisting>&ex38bis;</programlisting>
	    </example>	    

	    </listitem>
	  </varlistentry>


	<varlistentry>
	  <term><command>exit</command></term>
	  <indexterm>
	    <primary>exit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exit</secondary>
	  </indexterm>
	  <listitem>
	    <para>Unconditionally terminates a script. The
		<command>exit</command> command may optionally take an
		integer argument, which is returned to the shell as
		the <link linkend="exitstatusref">exit status</link>
		of the script. It is a good practice to end all but the
		simplest scripts with an <userinput>exit 0</userinput>,
		indicating a successful run.</para>

	    <note><para>If a script terminates with an <command>exit</command>
	      lacking an argument, the exit status of the script is the exit
	      status of the last command executed in the script, not counting
	      the <command>exit</command>.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="execref"><command>exec</command></term>
	  <indexterm>
	    <primary>exec</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exec</secondary>
	  </indexterm>
	  <listitem>
	    <para>This	shell builtin replaces the current process with
	      a specified command.  Normally, when the shell encounters
	      a command, it forks <anchor id="forkref"> off

		 <footnote><para>When a command or the shell itself
		   initiates (or <emphasis>spawns</emphasis>) a new
		   subprocess to carry out a task, this is called
		   <emphasis>forking</emphasis>. This new process
		   is the <quote>child</quote>, and the process
		   that <emphasis>forked</emphasis> it off is the
		   <quote>parent</quote>. While the <emphasis>child
		   process</emphasis> is doing its work, the
		   <emphasis>parent process</emphasis> is still
		   running.</para></footnote>

	      a child process to actually execute the command.	Using the
	      <command>exec</command> builtin, the shell does not fork,
	      and the command exec'ed replaces the shell.  When used in
	      a script, therefore, it forces an exit from the script when
	      the <command>exec</command>'ed command terminates. For this
	      reason, if an <command>exec</command> appears in a script,
	      it would probably be the final command.</para>

	    <para>An <command>exec</command> also serves to reassign <link
	      linkend="fdref">file descriptors</link>.	<userinput>exec
	      &lt;zzz-file</userinput> replaces <filename>stdin</filename>
	      with the file <filename>zzz-file</filename> (see <xref
	      linkend="redir1">).</para>

	    <example id="ex54">
	      <title>Effects of <command>exec</command></title>
	      <programlisting>&ex54;</programlisting>
	    </example>	    	   

	    <note><para>The <option>-exec</option> option to
	      <link linkend="findref">find</link> is
	      <replaceable>not</replaceable> the same as the
	      <command>exec</command> shell builtin.</para></note>

	  </listitem>
	</varlistentry>
	

	<varlistentry>
	  <term><command>shopt</command></term>
	  <indexterm>
	    <primary>shopt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shopt</secondary>
	  </indexterm>
	  <listitem>
	    <para>This command permits changing shell options on the fly (see
	      <xref linkend="al"> and <xref linkend="unal">).  It often
	      appears in the Bash <link linkend="filesref">startup
	      files</link>, but also has its uses in scripts. Needs
	      <link linkend="bash2ref">version 2</link> or later of Bash.

	      <programlisting>shopt -s cdspell
# Allows minor misspelling directory names with 'cd'
command.</programlisting></para>

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="intcommand">
        <title><anchor id="intcommand1">Commands</title>

      <varlistentry>
	<term><anchor id="trueref"><command>true</command></term>
	  <indexterm>
	    <primary>true</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>true</secondary>
	  </indexterm>
	  <listitem><para>A command that returns a successful
	    (<returnvalue>zero</returnvalue>) <link
	    linkend="exitstatusref">exit status</link>, but does
	    nothing else.
	  </para>

	  <para><programlisting># Endless loop
while true   # alias for ":"
do
   operation-1
   operation-2
   ...
   operation-n
   # Need a way to break out of loop.
done</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>false</command></term>
	  <indexterm>
	    <primary>false</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>false</secondary>
	  </indexterm>
	  <listitem><para>A command that returns an unsuccessful <link
	  linkend="exitstatusref">exit status</link>,
	    but does nothing else.</para>

	  <para><programlisting># Null loop
while false
do
   # The following code will not execute.
   operation-1
   operation-2
   ...
   operation-n
   # Nothing happens!
done   
</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>type [cmd]</command></term>
	  <indexterm>
	    <primary>type</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>type</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>which</secondary>
	  </indexterm>
	  <listitem><para>Similar to the <link
	    linkend="whichref">which</link> external command,
	    <command>type cmd</command> gives the full pathname to
	    <quote>cmd</quote>. Unlike <command>which</command>,
	    <command>type</command> is a Bash builtin. The useful
	    <option>-a</option> option to <command>type</command>
	    accesses identifies <replaceable>keywords</replaceable>
	    and <replaceable>builtins</replaceable>, and also locates
	    system commands with identical names.</para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>type '['</userinput>
<computeroutput>[ is a shell builtin</computeroutput>
<prompt>bash$ </prompt><userinput>type -a '['</userinput>
<computeroutput>[ is a shell builtin
 [ is /usr/bin/[</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>hash [cmds]</command></term>
	  <indexterm>
	    <primary>hash</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hash</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PATH</secondary>
	  </indexterm>
	  <listitem><para>Record the path name of specified commands (in the
	      shell hash table), so the shell or script will not need to search
	      the <varname>$PATH</varname> on subsequent calls to those
              commands. When <command>hash</command> is called with no
	      arguments,  it simply lists the commands that have been hashed.
	      The <option>-r</option> option resets the hash table.</para>
	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>help</command></term>
	  <indexterm>
	    <primary>help</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary></secondary>
	  </indexterm>
	  <listitem>
	  
	  <para><command>help</command> COMMAND looks up
	    a short usage summary of the shell builtin COMMAND.  This is
	    the counterpart to <link linkend="whatisref">whatis</link>,
	    but for builtins.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>help exit</userinput>
<computeroutput>exit: exit [n]
    Exit the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <sect1>
	<title>Job Control Commands</title>


	<para>Certain of the following job control commands take a
	  <quote>job identifier</quote> as an argument. See the <link
	  linkend="jobidtable">table</link> at end of the chapter.</para>

	<variablelist id="jccommandlist">

	  <varlistentry>
	    <term><command>jobs</command></term>
	  <indexterm>
	    <primary>jobs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>jobs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>ps</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ps</secondary>
	  </indexterm>
	    <listitem>

	      <para>Lists the jobs running in the background, giving the job number.
		Not as useful as <command>ps</command>.</para>

              <note>
	      <para>It is all too easy to confuse
		<emphasis>jobs</emphasis> and
		<emphasis>processes</emphasis>.  Certain <link
		linkend="builtinref">builtins</link>, such as
		<command>kill</command>, <command>disown</command>, and
		<command>wait</command> accept either a job number or a
		process number as an argument. The <command>fg</command>,
		<command>bg</command> and <command>jobs</command>
		commands accept only a job number.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>sleep 100 &</userinput>
<computeroutput>[1] 1384</computeroutput>

<prompt>bash $ </prompt><userinput>jobs</userinput>
<computeroutput>[1]+  Running                 sleep 100 &</computeroutput></screen>
	      </para>

	      <para><quote>1</quote> is the job number (jobs are
		maintained by the current shell), and <quote>1384</quote>
		is the process number (processes are maintained by
		the system). To kill this job/process, either a <command>kill
		%1</command> or a <command>kill 1384</command> works.</para>

	      <para><emphasis>Thanks, S.C.</emphasis></para>	
               </note>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>disown</command></term>
	  <indexterm>
	    <primary>disown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>disown</secondary>
	  </indexterm>
	    <listitem>
	      <para>Remove job(s) from the shell's table of active jobs.</para>
	    </listitem>
	  </varlistentry>


	<varlistentry>
	  <term><command>fg</command></term>
	  <term><command>bg</command></term>
	  <indexterm>
	    <primary>fg</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>foreground</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>background</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bg</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>fg</command> command switches a job
	      running in the background into the foreground.  The
	      <command>bg</command> command restarts a suspended job, and
	      runs it in the background. If no job number is specified,
	      then the <command>fg</command> or <command>bg</command>
	      command acts upon the currently running job.</para>
	  </listitem>
	</varlistentry>

	  <varlistentry>
	    <term><anchor id="waitref"><command>wait</command></term>
	  <indexterm>
	    <primary>wait</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wait</secondary>
	  </indexterm>
	    <listitem>

	      <para>Stop script execution until all jobs running in
	        background have terminated, or until the job number or
	        process id specified as an option terminates. Returns the <link
	        linkend="exitstatusref">exit status</link> of waited-for
	        command.</para>

	      <para>You may use the <command>wait</command> command
		to prevent a script from exiting before a background
		job finishes executing (this would create a dreaded
		orphan process).</para>

	    <example id="ex39">
	      <title>Waiting for a process to finish before proceeding</title>
	      <programlisting>&ex39;</programlisting>
	    </example>	    

	      <para>Optionally, <command>wait</command> can take a job
		identifier as an argument, for example,
		<command>wait%1</command> or <command>wait
		$PPID</command>. See the <link linkend="jobidtable">job
		id table</link>.</para>

	      <para><anchor id="waithang"></para>
              <tip>
	      <para>Within a script, running a command in the background
		with an ampersand (&amp;) may cause the script
		to hang until <keycap>ENTER</keycap> is hit. This
		seems to occur with commands that write to
		<filename>stdout</filename>. It can be a major annoyance.
		  <programlisting>#!/bin/bash
# test.sh		  

ls -l &
echo "Done."</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>./test.sh</userinput>
<computeroutput>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
 _
</computeroutput>
               </screen>
	       </para>

              <para>Placing a <command>wait</command> after the background
                command seems to remedy this.
		  <programlisting>#!/bin/bash
# test.sh		  

ls -l &
echo "Done."
wait</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>./test.sh</userinput>
<computeroutput>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh</computeroutput>
               </screen>
	        <link linkend="ioredirref">Redirecting</link> the
                output of the command to a file or even to
		<filename>/dev/null</filename> also takes care of this
		problem.
              </para>
	      </tip>


	    </listitem>
	  </varlistentry>


	  <varlistentry>
	    <term><command>suspend</command></term>
	    <indexterm>
	      <primary>suspend</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>suspend</secondary>
	    </indexterm>
	    <listitem>
	      <para>This has a similar effect to
		<keycombo><keycap>Control</keycap><keycap>Z</keycap></keycombo>, 
		but it suspends the shell (the shell's parent process should
		resume it at an appropriate time).</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>logout</command></term>
	  <indexterm>
	    <primary>logout</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>log out</secondary>
	  </indexterm>
	    <listitem>
	      <para>Exit a login shell, optionally specifying an <link
	        linkend="exitstatusref">exit status</link>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="timesref"><command>times</command></term>
	  <indexterm>
	    <primary>times</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>times</secondary>
	  </indexterm>
	    <listitem>
	      <para>Gives statistics on the system time used in executing commands, in the
		following form:
		<screen><computeroutput>0m0.020s 0m0.020s</computeroutput></screen>
		This capability is of very limited value, since it is uncommon to
		profile and benchmark shell scripts.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="killref"><command>kill</command></term>
	  <indexterm>
	    <primary>kill</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>kill</secondary>
	    </indexterm>
	    <listitem>
	      <para>Forcibly terminate a process by sending it an
	      appropriate <emphasis>terminate</emphasis> signal (see <xref
	      linkend="killprocess">).</para>
	      
	      <note><para><userinput>kill -l</userinput> lists all the
		<link linkend="signald">signals</link>.  A <userinput>kill
		-9</userinput> is a <quote>sure kill</quote>, which will
		usually terminate a process that stubbornly refuses to
		die with a plain <command>kill</command>. Sometimes, a
		<userinput>kill -15</userinput> works. A <quote>zombie
		process</quote>, that is, a process whose <link
		linkend="forkref">parent</link> has terminated, cannot be
		killed (you can't kill something that is already dead),
		but <command>init</command> will usually clean it up
		sooner or later.</para></note>

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><command>command</command></term>
	  <indexterm>
	    <primary>command</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>command</secondary>
	  </indexterm>
	  <listitem><para>The <command>command COMMAND</command> directive
	    disables aliases and functions for the command
	    <quote>COMMAND</quote>.</para>

	    <note><para>This is one of three shell directives that
	      effect script command processing. The others are
	      <link linkend="bltref">builtin</link> and <link
	      linkend="enableref">enable</link>.</para></note>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor id="bltref"><command>builtin</command></term>
	  <indexterm>
	    <primary>builtin</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>builtin</secondary>
	  </indexterm>
	  <listitem><para>Invoking <command>builtin
	      BUILTIN_COMMAND</command> runs the command
	      <quote>BUILTIN_COMMAND</quote> as a shell <link
	      linkend="builtinref">builtin</link>, temporarily disabling
	      both functions and external system commands with the
	      same name.</para>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor id="enableref"><command>enable</command></term>
	  <indexterm>
	    <primary>enable</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>enable</secondary>
	  </indexterm>
	  <listitem>

	    <para>This either enables or disables a shell
	      builtin command. As an example, <command>enable -n
	      kill</command> disables the shell builtin <link
	      linkend="killref">kill</link>, so that when Bash
	      subsequently encounters <command>kill</command>, it invokes
	      <filename>/bin/kill</filename>.</para>
	      
	    <para><anchor id="enableref1">The <option>-a</option>
	      option to <command>enable</command> lists all the
	      shell builtins, indicating whether or not they
	      are enabled. The <option>-f filename</option>
	      option lets <command>enable</command> load a <link
	      linkend="builtinref">builtin</link> as a shared library
	      (DLL) module from a properly compiled object file.
	        <footnote>
		  <para>The C source for a number of loadable builtins is
		    typically found in the <filename
		    class="directory">/usr/share/doc/bash-?.??/functions</filename>
		    directory.</para>
		  <para>Note that the <option>-f</option> option to
		    <command>enable</command> is not portable to all
		    systems.</para>
		</footnote>.
	     </para>	

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><command>autoload</command></term>
	  <indexterm>
	    <primary>autoload</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>autoloader</secondary>
	  </indexterm>
	  <listitem>

	  <para>This is a port to Bash of the
	    <emphasis>ksh</emphasis> autoloader. With
	    <command>autoload</command> in place, a function with
	    an <quote>autoload</quote> declaration will load from an
	    external file at its first invocation.
	      <footnote><para>The same effect as
	      <command>autoload</command> can be achieved with <link
	      linkend="declareref">typeset -fu</link>.</para></footnote>
	    This saves system resources.</para>

	  <para>Note that <command>autoload</command> is not a part of the
	    core Bash installation. It needs to be loaded in with
	    <command>enable -f</command> (see above).</para>

	    </listitem>
	  </varlistentry>

	</variablelist>

      <table id="jobidtable">
	<title>Job Identifiers</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Notation</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>%N</option></entry>
	      <entry>Job number [N]</entry>
	    </row>
	    <row>
	      <entry><option>%S</option></entry>
	      <entry>Invocation (command line) of job begins with string <emphasis>S</emphasis></entry>
	    </row>
	    <row>
	      <entry><option>%?S</option></entry>
	      <entry>Invocation (command line) of job contains within it string <emphasis>S</emphasis></entry>
	    </row>
	    <row>
	      <entry><option>%%</option></entry>
	      <entry><quote>current</quote> job (last job stopped in
	      foreground or started in background)</entry>
	    </row>
	    <row>
	      <entry><option>%+</option></entry>
	      <entry><quote>current</quote> job (last job stopped in
	      foreground or started in background)</entry>
	    </row>
	    <row>
	      <entry><option>%-</option></entry>
	      <entry>Last job</entry>
	    </row>
	    <row>
	      <entry><option>$!</option></entry>
	      <entry>Last background process</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      </sect1> <!-- Job Control Commands -->

  </chapter> <!-- Internal Commands and Builtins -->
