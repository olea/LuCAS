  <chapter id="functions">
    <title>Funciones</title>

      <para><anchor id="functionref"></para>
      

      <para>Como en los <quote>verdaderos</quote> lenguajes de programación,
	Bash tiene funciones, aunque implementadas de forma limitada.
	Una función es una subrutina, un <link linkend="codeblockref">bloque
	de código</link> que implementa un conjunto de operaciones, una <quote>
	caja negra</quote> que realiza una tarea determinada. Donde aparezca código 
	repetitivo, cuando una tarea se repite únicamente con pequeñas variaciones,
	entonces piensa en usar una función.</para>


      <para><cmdsynopsis>
	  <command>función</command>
	  <arg choice="plain"><replaceable>nombre_función</replaceable></arg> 
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>comando</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
	or 
	<cmdsynopsis>
	  <arg choice="plain"><replaceable>nombre_función</replaceable></arg> 
	  <arg choice="plain">()</arg>
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>comando</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
      </para>

      <para>Esta segunda forma gustará a los programadores de C (y es más portable).</para>

      <para>Así como en C, la llave de apertura de función puede aparecer opcionalmente 
        en la segunda línea.</para>

      <para><cmdsynopsis>
	  <arg choice="plain"><replaceable>nombre_función</replaceable></arg> 
	  <arg choice="plain">()</arg><sbr>
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>comando</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
      </para>

      <para>Las funciones son llamadas, <firstterm>ejecutadas</firstterm>, simplemente invocando
      su nombre.</para>

      <example id="ex59">
	<title>Función Simple</title>
	<programlisting>&ex59;</programlisting>
      </example>

      <para>La definición de la fundión debe preceder a la primera llamada a la misma. No
      hay ningún método de <quote>declarar</quote> una función, como, por ejemplo en C.
      <programlisting># f1

# Va a devolver un mensaje de error, ya que la función "f1" no está definida aún.

# Sin embargo...

	  
f1 ()
{
  echo "Llamando a función \"f2\" desde la función \"f1\"."
  f2
}

f2 ()
{
  echo "Función \"f2\"."
}

f1  # La función "f2" no es llamada realmente hasta este punto,
    # aunque se le hace referencia antes de su definición.
    # Esto está permitido.
    
# Gracias, S.C. ???traductor???</programlisting>
      </para>

      <para>Es incluso posible anidar una función dentro de otra,
        aunque esto no es muy útil.
	  <programlisting>f1 ()
{

  f2 () # anidada
  {
    echo "Función \"f2\", dentro de \"f1\"."
  }

}  

# f2
# Devuelve un mensaje de error.

f1  # No hace nada, a que llamar a "f1" no llama automáticamente a "f2".
f2  # Ahora, está bien llamar a "f2",
    # ya que su definición se hace visible llamando a "f1".

# Gracias, S.C. ???traducción???</programlisting>
      </para>
      
      <para>Las declaraciones de funciones pueden aparecer en sitios raros, 
          incluso donde debería ir un comando.

          <programlisting>ls -l | foo() { echo "foo"; }  # Válido, pero sin utilidad.



if [ "$USER" = bozo ]
then
  bozo_greet ()   # Definición de función embebida en una construcción if/then.
  {
    echo "Hola, Bozo."
  }
fi  

bozo_greet        # Funciona unicamente para Bozo, y otros usuarios reciben un error.



# Algo como esto puede resultar útil en algunos contextos.
NO_EXIT=1   # Posibilitará la definición de la función más abajo.

[[ $NO_EXIT -eq 1 ]] && exit() { true; }     # Definición de función en una "and-list".
# Si $NO_EXIT es 1, declara "exit ()".
# Esto desabilita el "exit" interno a bash creando un alias a "true".

exit  # Invoca a la función "exit ()", no al "exit" interno de bash.

# Thanks, S.C. ???traducción???</programlisting>
      </para>


      <sect1 id="complexfunct">
        <title>Funciones Complejas y la Compleajidad de las Funciones</title>

      <para>Las funciones pueden procesar agumentos que se les envian y devolver
	un <link linkend="exitstatusref">estado de salida</link> al script
	para ser procesado posteriormente.</para>

      <programlisting>nombre_función $arg1 $arg2</programlisting>

      <para>La función se refiere al los argumentos pasados por posición (como si fueran
	<link linkend="posparamref">parametros posicionales</link>),
	como, <varname>$1</varname>, <varname>$2</varname>, y así sucesivamente.</para>

      <example id="ex60">
	<title>Función Tomando Parámetros</title>
	<programlisting>&ex60;</programlisting>
      </example>

      <important><para>El comando <link linkend="shiftref">shift</link>
        funciona con los argumentos pasados a las funciones (ver <xref
	linkend="multiplication">).</para></important>

      <note><para>En contraste con otros lenguajes de programación,
	los scripts de shell pasan normalmente sólo parámetros por valor a las funciones.

	  <footnote><para><link linkend="ivrref">Las referencias indirectas a variables
	    </link> (see <xref linkend="ex78">) proveen una forma torpe
	    de pasar punteros a variables a las funciones.

	    <programlisting>&refparams;</programlisting>
	    </para></footnote> 

	Los nombres de variables (que son de hecho punteros), sin son pasados como
	parametros a las funciones, serán tratados como cadenas de caracacteres literales
	y no pueden ser desreferenciadas. <emphasis>Las funciones interpretan sus argumentos
	literalmente.</emphasis></para></note>

      <variablelist id="exitreturn">
        <title><anchor id="exitreturn1">Exit y Return</title>

	<varlistentry>
	  <term><command>estado de salida</command></term>
	  <listitem>
	    <para>Las funciones devuelven un valor, llamado un <firstterm>estado de
	      salida</firstterm>. El estado de salida puede ser especificado
	      explicitamente por una instrucción <command>return</command>,
	      si no es el estado de salida del último comando de la función
	      (<returnvalue>0</returnvalue> si es exitoso y, un código de error
	      distinto de cero si no). Este
	      <link linkend="exitstatusref">estado de salida</link>
	      puede ser usado en el script haciendo referencia a él como
	      <link linkend="xstatvarref">$?</link>.  Este mecanismo
	      permite con efectividad a las funciones de los scripts tener un
	      <quote>valor de retorno</quote> similar al de las funciones de C.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>return</command></term>
	  <indexterm>
	    <primary>return</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>return</secondary>
	  </indexterm>
	  <listitem>
	    <para>Finaliza una función. Un comando <command>return</command>
	       <footnote><para>El comando <command>return</command> es un comando
	       <link linkend="builtinref">interno</link>.</para></footnote>
	      puede recibir opcionalmente un argumento <emphasis>entero</emphasis>,
              que devuelve al script que lo llamó como el <quote>estado de salida</quote>
	      de la función, y este estado de salida es asignado a la variable
	      <link linkend="xstatvarref">$?</link>.</para>

	    <example id="max">
	      <title>Máximo de dos números</title>
	      <programlisting>&max;</programlisting>
	    </example>

	    <tip>
	    <para>Para que una función devuelva un array o una cadena, usar una
	      variable dedicada.
	        <programlisting>cuenta_lineas_en_etc_passwd()
{
  [[ -r /etc/passwd ]] && REPLY=$(echo $(wc -l < /etc/passwd))
  # Si /etc/passwd es legible, inicializar REPLY con el número de líneas.
  # Devuelve un valor de parámetro y la información de estado.
}

if cuenta_lineas_en_etc_passwd
then
  echo "Hay $REPLY líneas en /etc/passwd."
else
  echo "No se pueden contar las líneas en /etc/passwd."
fi  

# Thanks, S.C. ???traducción???</programlisting>
	    </para>
	    </tip>




	    <example id="ex61">
	      <title>Convertir números a símbolos romanos</title>
	      <programlisting>&ex61;</programlisting>
	    </example>

	    <para>Ver también <xref linkend="isalpha">.</para>

	    <important>

	    <para>El número entero positivo más grande que puede devolver
	      una función es 256. El comando  <command>return</command> está
	      fuertemente ligado al concepto de <link linkend="exitstatusref">
	      estado de salida</link>, que adolece de esta limitación
	      particular. Afortunadamente, existen varias <link
	      linkend="rvt">soluciones</link> para las soluciones
	      que requieren el retorno de un valor entero mayor desde una
	      función.</para>


	    <example id="returntest">
	      <title>Probando valores grandes de retorno en una función</title>
	      <programlisting>&returntest;</programlisting>
	    </example>

	    <para>Como vemos, una función puede devolver un valor negativo muy grande
	      . Esto también permite el envio de un valor positivo grande,
	      usando un bit de trucado. ???traducción???</para>

	    <para>Un método alternativo para hacer esto es simplemente
	      asignar el <quote>valor de retorno</quote> a una variable global.
	        <programlisting>Return_Val=   # Variable global que almacena el 
                valor grande de retorno.


alt_return_test ()
{
  fvar=$1
  Return_Val=$fvar
  return   # Devuelve 0 (éxito).
}

alt_return_test 1
echo $?                              # 0
echo "valor de retorno = $Return_Val"    # 1

alt_return_test 256
echo "valor de retorno = $Return_Val"    # 256

alt_return_test 257
echo "valor de retorno = $Return_Val"    # 257

alt_return_test 25701
echo "valor de retorno = $Return_Val"    #25701</programlisting>
            </para>


	    <example id="max2">
	      <title>Comparación de dos enteros largos</title>
	      <programlisting>&max2;</programlisting>
	    </example>

	    <para>Véase también <xref linkend="daysbetween">.</para>

	    <para><userinput>Ejercicio:</userinput> Usando lo que
	      acabamos de aprender, extiende el <link linkend="ex61">
              ejemplo de números romanos</link> anterior para aceptar
	      entrada de tamaño arbitrario.</para>

	    </important>

	  </listitem>
	</varlistentry>
      </variablelist>


      <variablelist id="redstdinfunc">
        <title><anchor id="redstdinfunc1">Redirección</title>

	<varlistentry>
	  <term><replaceable>Redireccionar el stdin de una
	  función</replaceable></term>
	  <indexterm>
	    <primary>redirección</primary>
	    <secondary>stdin</secondary>
	  </indexterm>
	  <listitem>

	    <para>Una función es esencialmente un <link
	      linkend="codeblockref">bloque de código</link>, lo que significa
	      que <filename>stdin</filename> puede ser redireccionado (como 
              en <xref linkend="ex8">).</para>

	    <example id="realname">
	      <title>Nombre real desde username</title>
	      <programlisting>&realname;</programlisting>
	    </example>

	   <para>Existe un método alternativo, y probablemente menos confuso,
	     de redireccionar el <filename>stdin</filename> de una función.
             Esto implica redireccionar el <filename>stdin</filename> a un
             bloque de código embebido entre llaves en el interior de una 
	     función.

	       <programlisting># En lugar de:
Funcion ()
{
 ...
 } < fichero

# Prueba esto:
Funcion ()
{
  {
    ...
   } < fichero
}

# De igual manera,

Funcion ()  # Esto funciona.
{
  {
   echo $*
  } | tr a b
}

Funcion ()  # Esto no funciona.
{
  echo $*
} | tr a b   # Aquí es obligatorio un bloque de código anidado.


# Gracias, S.C. ???traducción???</programlisting>
           </para>

	  </listitem>
	</varlistentry>

      </variablelist>

      </sect1> <!-- Funciones Complejas y la Compleajidad de las Funciones  -->


      <sect1 id="localvar">
        <title>Variables Locales</title>

      <variablelist id="localref">
        <title><anchor id="localref1">¿Qué hace a una variable <quote>local</quote>?</title>

	<varlistentry>
	  <term>variables locales</term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>local</secondary>
	  </indexterm>
	  <listitem>
	    <para>Una variable declarada como <firstterm>local</firstterm>
	      es la que es visible únicamente en el <link
	      linkend="codeblockref">bloque de código</link> en el que aparece.
              Es de <quote>ámbito</quote> local. En una función,
	      una <emphasis>variable local</emphasis> tiene significado
	      únicamente en ese bloque de código.</para>

	    <example id="ex62">
	      <title>Visibilidad de una variable local</title>
	      <programlisting>&ex62;</programlisting>
	    </example>

	    <caution>
	    <para>Antes de ser llamada una función, <emphasis>todas</emphasis>
	      las variables declaradas dentro de la función son invisibles en el
	      exterior del cuerpo de la función, no sólo las declaradas como
              <emphasis>locales</emphasis> explícitamente.
	        <programlisting>#!/bin/bash

func ()
{
global_var=37    #  Unicamente visible dentro del bloque de la función
                 #+ antes de ser llamada la función. 
}                # FIN DE LA FUNCION

echo "global_var = $global_var"  # global_var =
                                 #  La función "func" no ha sido llamada aún,
                                 #+ por lo que  $global_var no es visible aquí.

func
echo "global_var = $global_var"  # global_var = 37
                                 # Ha sido establecido tras la llamada a la función.
		</programlisting>
            </para>
	    </caution>

	  </listitem>
	</varlistentry>

      </variablelist>

      <sect2 id="locvarrecur">
        <title>Las variables locales hacen posible la recursividad.</title>

	    <para>Las variable locales permiten la recursividad,

	      <footnote>
	      <para><anchor id="recursionref">
	        <link linkend="mayerref">Herbert Mayer</link>
		define <emphasis>recursividad</emphasis> como
		<quote>...expressing an algorithm by using a simpler
		version of that same algorithm... (traducido: expresar un
                algoritmo usando una versión simplificada de ese algoritmo)</quote> Una 
		función recursiva es aquella que se llama a si misma.
                </para></footnote>

	      pero esta práctica generalmente provoca mucho trabajo excesivo
	      y definitivamente <emphasis>no</emphasis> es recomendable
	      en un script de shell.

	         <footnote><para>Demasiados niveles de recursividad pueden colgar 
                 un script con un fallo de segmentación, segfault.
		   <programlisting>#!/bin/bash

funcion_recursiva ()		   
{
(( $1 < $2 )) && f $(( $1 + 1 )) $2;
#  Mientras el parámetro 1º sea menor que el 2º,
#+ incrementar el 1º y llamarse a si misma (la función).
}

funcion_recursiva 1 50000  # Llamarse a si misma 50,000 veces!
# Segfaults, por supuesto.

#  Una recursividad tan profunda puede causar incluso a un programa en C un segfault,
#+ usando toda la memoria asignada para la pila.

# Gracias, S.C. ???traducción???

exit 0  # Este script no saldrá con normalidad.</programlisting>
</para></footnote>
	      
	      </para>

	    <example id="ex63">
	      <title>Recursividad, usando una variable local</title>
	      <programlisting>&ex63;</programlisting>
	    </example>

	    <para>Ver también <xref linkend="primes"> para un ejemplo de
	      recursividad en un script. Tengase en cuenta que la recursividad
	      hace un uso intensivo de los recursos y ejecuta con lentitud,
              y es por lo que no es generalmente apropiado usarla en un script.
            </para>

      </sect2>

      </sect1> <!-- Variables Locales -->

  </chapter> <!-- Funciones -->
