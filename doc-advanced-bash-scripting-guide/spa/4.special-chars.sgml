  <chapter id="special-chars">
    <title>Caracteres especiales</title>

      <variablelist id="scharlist">
        <title><anchor id="scharlist1">Caracteres especiales
          encontrados en scripts y por ahí</title>

	<varlistentry><term><token>#</token></term>
	  <indexterm>
	    <primary>#</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>#</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>comentario</primary>
	  </indexterm>	  
	  <listitem>
	    <formalpara><title>Comentarios</title>
	      <para>Las líneas que empiezan por un  <token>#</token>
	      (<link linkend="magnumref">con la excepción de
	      <token>#!</token></link>) son comentarios.</para>
	    </formalpara>

	    <para><programlisting># Esta línea es un comentario.</programlisting></para>

	    <para>Los comentarios pueden estar al final de un comando.</para>
	    
	    <para><programlisting>echo "Le sigue un comentario." #Comentar aquí.</programlisting></para>	    

	    <para>Los comentarios pueden también pueden ir detras de
	    un <link linkend="whitespaceref">espacio en blanco</link>
	    al principio de una línea.</para>

	    <para><programlisting>	# un tabulador precede este comentario.</programlisting></para>

	    <caution><para>Un comando no puede segir a un comentario
	      en la misma línea. No hay ningún método para terminar el
	      comentario, para hacer que el <quote>código</quote>
	      empiece en la misma línea. Use una línea nueva para el
	      siguiente comando.</para></caution>

	    <note><para>Desde luego, un <token>#</token> escapado en
	    una sentencia <command>echo</command>
	    <emphasis>no</emphasis> comienza un comentario. Al igual que
	    , un <token>#</token> que aparezca en <link
	    linkend="psub2">ciertas construcciones de sustitución de
	    parámetros</link> y en <link linkend="numconstants">expresiones numéricas constantes</link>.

	    <programlisting>echo "El  # de aquí no comienza un comentario."
echo 'El  # de aquí no comienza un comentario.'
echo El  \# de aquí no comienza un comentario.
echo El # de aquí comienza un comentario.

echo ${PATH#*:}       # Sustitución de parámetros, no un comentario.
echo $(( 2#101011 ))  # Conversión de base, no un comentario.

# Thanks, S.C.</programlisting>

	  Los caracteres estándares de <link
	  linkend="quotingref">entrecomillado y escape</link> (&quot;
	  ' \) escapan el #.
	  </para></note>

	  <para>Ciertas operaciones de <link
	    linkend="psorex1">coincidencia con patrones
	    </link> también usan el <token>#</token>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry><term><token>;</token></term>
	  <indexterm>
	    <primary>;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>separador</primary>
	  </indexterm>	  
	  
	  <listitem>
	    <formalpara><title>Separador de comandos</title>
	      <para>[Punto y coma]  Permite poner dos comandos o más
	      en la misma línea.</para>
	    </formalpara>

	    <para><programlisting>echo hola; echo allí</programlisting></para>
	    
	    <para>Note que el <quote><token>;</token></quote> algunas
	      veces necesita ser <link linkend="escp">escapado</link>.</para>

	    </listitem>
	</varlistentry>

	<varlistentry><term><token>;;</token></term>
	  <indexterm>
	    <primary>;;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>caracter especial</primary>
	    <secondary>case</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>;;</primary>
	  </indexterm>	  
	  
	  <listitem>
	    <formalpara><title>Terminador en una opción <link
	      linkend="caseesac1">case</link></title>
	      <para>[Doble punto y coma]</para>
	    </formalpara>

	    <para><programlisting>case "$variable" in
abc)  echo "$variable = abc" ;;
xyz)  echo "$variable = xyz" ;;
esac</programlisting></para>

	    </listitem>
	</varlistentry>


	<varlistentry><term><token>.</token></term>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>.</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>comando punto</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>source</primary>
	  </indexterm>	  

	  <listitem>
	    <para><anchor id="dotref"></para>
	    <formalpara><title>El comando <quote>punto</quote></title>
	      <para>[punto]  Equivale a <link
		linkend="sourceref">source</link> (vea
		<xref linkend="ex38">). Esto es un <link
		linkend="builtinref">integrado</link> de bash.</para>
	    </formalpara>

	      <para><link linkend="regexdot">En un contexto diferente
	        </link>, como parte de una <link
	        linkend="regexref">expresión regular</link>, un
	        <quote>punto</quote> coincide con un caracter sencillo.</para>

              <para>En otro contexto, un punto en el nombre de archivo
                como prefijo de un archivo <quote>oculto</quote>, un
                archivo que un <command>ls</command> no mostrará normalmente.
	      <screen><prompt>bash$ </prompt><userinput>touch .hidden-file</userinput>
<prompt>bash$ </prompt><userinput>ls -l</userinput>	      
<computeroutput>total 10
 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook</computeroutput>

<prompt>bash$ </prompt><userinput>ls -al</userinput>	      
<computeroutput>total 14
 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
 drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
 -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file</computeroutput>
	      </screen>
	    </para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>"</token></term>
	  <listitem><formalpara><title><link
	  linkend="dblquo">entrecomillado parcial</link></title>
	      <para>[comilla doble]  <emphasis>"STRING"</emphasis>
		preserva  (de interpretación) la mayoría de los
	  caracteres especiales dentro de
	  <emphasis>STRING</emphasis>. Vea además
		<xref linkend="quoting">.</para>
	    </formalpara> </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>'</token></term>
	  <listitem><formalpara><title><link
	  linkend="snglquo">entrecomillado total</link></title>
	      <para>[comilla sencilla]  <emphasis>'STRING'</emphasis>
		preserva todos los caracteres especiales dentro del
		<emphasis>STRING</emphasis>. Esta es una forma más
	  fuerte de entrecomillado que usar <token>"</token>.  Vea
	  también  <xref linkend="quoting">.</para>
	    </formalpara> </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>,</token></term>
	  <listitem><formalpara><title><link
	  linkend="commaop">operador coma</link></title>
	      <para>El <command>operador coma</command> enlaza juntos
	  una serie de operaciones aritméticas. Todas se evalúan, pero
	  sólo la última se devuelve.
               <programlisting>let "t2 = ((a = 9, 15 / 3))"  #	  Establece "a" y calcula "t2".</programlisting>
	      </para> 
	    </formalpara> </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>\</token></term>
	  <listitem><formalpara><title><link linkend="escp">escape</link></title>
	      <para>[backslash]  <userinput>\X</userinput>
		<quote>escapa</quote> el carácter
	  <emphasis>X</emphasis>. Esto tiene el efecto de
	  <quote>entrecomillar</quote> <emphasis>X</emphasis>,
	  equivalente a <emphasis>'X'</emphasis>.  La <token>\</token>
	  puede usarse para entrecomillar <token>"</token> y <token>'</token>,
	  para que se expresen literalmente.</para>
	    </formalpara>
	      <para>Vea <xref linkend="quoting"> para una explicación
	        en profundidad de los caracteres escapados.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/</token></term>
	  <listitem><formalpara><title>Separador de nombres de fichero
	  y ruta</title>
	      <para>[forward slash] Separa los componentes de un
	  nombre de archivo (como en 
	        <filename>/home/bozo/projects/Makefile</filename>).</para>
	    </formalpara>
	    <para>También es el  <link
	      linkend="arops1">operador aritmético</link> de división.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>`</token></term>
	  <listitem><formalpara><title><link
	  linkend="commandsubref">sustitución de comandos</link></title>
	      <para>[backticks]  <emphasis>`comando`</emphasis> hace que
		la salida <emphasis>comando</emphasis> esté disponible
		para establecer una variable. Esto también se conoce como
		<link linkend="backquotesref">comillas hacia atrás</link> o
		comillas invertidas.</para></formalpara> </listitem>
	</varlistentry>

	<varlistentry><term><token>:</token></term>
	  <indexterm>
	    <primary>:</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>:</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>comando null</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>true</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>bucle infinito</primary>
	  </indexterm>	  

	  <listitem>
	    <para><anchor id="nullref"></para>
	    <formalpara><title>comando null</title>
	      <para>[dos puntos]  Este es el equivalente del shell de un
		<quote>NOP</quote> (<replaceable>no op</replaceable>, una
		operación hacer-nada). Puede ser considerado como un
	    sinónimopara el integrado del shell <link
	    linkend="trueref">true</link>. El comando integrado del shell 
		<quote><token>:</token></quote> es un integrado de Bash,
		y su <link linkend="exitstatusref">estado de salida </link> es <quote>true</quote>
		(<returnvalue>0</returnvalue>).</para>
	    </formalpara>

	    <para><programlisting>:
echo $?   # 0</programlisting></para>


	    <para>Bucle infinito:</para>

	    <para><programlisting>
while :
do
   operacion-1
   operacion-2
   ...
   operacion-n
done

# Lo mismo que:
#    while true
#    do
#      ...
#    done</programlisting>
	    </para>

	    <para>Placeholder in if/then test:</para>

	    <para><programlisting>
if condition
then :   # Do nothing and branch ahead
else
   take-some-action
fi</programlisting>
	    </para>

	    <para>Proporciona un  lugar donde colocar donde se espera
	      una operación binaria, vea <xref linkend="arithops"> y <link
	      linkend="defparam">parámetros predeterminados</link>.</para>

	    <para><programlisting>: ${username=`whoami`}
# ${username=`whoami`}   sin los : iniciales da un error a no ser que 
#                        que "username" sea un comando o integrado...</programlisting>
</para>

	    <para>Proporciona un lugar donde se espera que esté un
	      comando en <link linkend="heredocref">un documento aquí</link>. Vea <xref
	      linkend="anonheredoc">.</para>

	    <para>Evalúa una cadena de variables usando 
		<link linkend="paramsubref">sustitución de parámetros</link>
		(as in <xref linkend="ex6">).

	    <programlisting>: ${HOSTNAME?} ${USER?} ${MAIL?}
#Imprime un mensaje de error si una o más variables de entorno no están establecidas.</programlisting>
</para>
            
            <para><command><link linkend="exprepl1">Expansión de
	      variables / reemplazo de subcadenas</link></command>.</para>
	    
	    <para>En combinación con el <token>&gt;</token> <link
	      linkend="ioredirref">operador de redirección</link>,
	      trunca un archivo a longitud cero, sin cambiar sus
	      permisos. Si el archivo no existió previamente, lo crea.

	      <programlisting>: > data.xxx   # El archivo  "data.xxx"
	      ahora está vacío.	      

# Los mismos efectos que   cat /dev/null >data.xxx
# Sin embargo, esto no bifurca un proceso nuevo, debido a que ":" es
# un integrado.</programlisting>
              Vea además <xref linkend="ex12">.</para>

	    <para>En combinación con  <token>&gt;&gt;</token>
	      el porador de redirección, actualiza el tiempo de
	      acceso/ modificación (<userinput>: &gt;&gt; nuevo_fichero</userinput>).
	      Si el archivo no existía anteriormente, lo crea. Esto es
	      equialente a <link linkend="touchref">touch</link>.</para>

	    <note><para>Esto se aplica a los ficheros regulares, no a
	      los cauces (pipes), enlaces simbólicos (symlinks) y
	      ciertos archivos especiales.</para></note>


	    <para>Pueden ser usados para comenzar una lñínea de
	      comentario aunque no se recomienda. El usar
	      <token>#</token> para comentar desactiva la comprobación
	      de errores para el resto de la línea, así que todo
	      debería aparecer en un comentario. Sin embargo, esto no
	      es el caso con 
	      <token>:</token>.
	      <programlisting>: Este es un comentario que genera un error, ( if [ $x -eq 3] ).</programlisting>
	    </para>

	    <para>El <quote><token>:</token></quote> también sirve
	      como un separador de campos, en
	      <filename>/etc/passwd</filename>, y en la variable <link linkend="pathref">$PATH</link>.
	      <screen><prompt>bash$ </prompt><userinput>echo $PATH</userinput>
<computeroutput>/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</computeroutput></screen>
	    </para>



	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>!</token></term>
	  <indexterm>
	    <primary>!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>negación</primary>
	    <secondary>lógica</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>not</primary>
	  </indexterm>	  

	  <listitem>
	  <para><anchor id="notref"></para>
	  <formalpara><title>invierte (o niega) el sentido de un test o estado de salida</title>

	      <para>El operador <token>!</token> invierte el <link
		linkend="exitstatusref">estado de salida</link>
		del comando para el cual se aplica (vea
		<xref linkend="negcond">). También invierte el significado
		de un operador de test. Esto puede, por ejemplo, 
		cambiar el sentido de <quote>igual</quote>
		( <link linkend="equalsignref">=</link>
		) a <quote>distinto</quote> ( != ). El operador
		<token>!</token> es una palabra reservada de Bash <link
		linkend="keywordref">keyword</link>.</para>

	    </formalpara>
	      <para>En un contexto diferente, el signo <token>!</token>
	        también aparece en <link linkend="ivr2">referencias indirectas a variables</link>.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>*</token></term>
	  <indexterm>
	    <primary>*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>comodín</primary>
	    <secondary>globbing</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>expresión regular</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>comodín</title>

	      <para>[asterisco]	El carácter <token>*</token> sirve como 
		un <quote>comodín</quote> para la expasión de nombres de archivo en el
		<link linkend="globbingref">globbing</link>, así como para 
		representar cualquier número de (o cero) caracteres en una <link
		linkend="regexref">expresión regular</link>.</para>

	    </formalpara>

	      <para>Un doble asterisco, <token>**</token>, es el <link
	        linkend="exponentiationref">operador de exponenciación
	        </link>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>?</token></term>
	  <indexterm>
	    <primary>?</primary>
	  </indexterm>
	  <indexterm>
	    <primary>caracter especial</primary>
	    <secondary>?</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>comodín</primary>
	    <secondary>globbing</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>expresión regular</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>comodín (caracter único)</title>

	      <para>[interrogación] El caracter <token>?</token> sirve como un
		<quote>comodín</quote> para un sólo carácter para la expansión de nombres
		en <link linkend="globbingref">globbing</link>, así como para <link
		linkend="quexregex">representar un carácter </link> en una 
		<link linkend="extregex">expresión  regular extendida</link>.</para>

	    </formalpara>

	      <para>Dentro de una <link linkend="dblparens">construcción de 
	        dobles paréntesis</link>, el signo <token>?</token> sirve
		como un operador trinario al estilo de C. Vea  <xref
		linkend="cvars">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry><term><token>$</token></term>
	  <indexterm>
	    <primary>$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>caracter especial</primary>
	    <secondary>$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>substitución de variables</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title><link linkend="varsubn">Substitución de variables</link></title>
             <para>
	       <programlisting>var1=5
var2=23skidoo

echo $var1     # 5
echo $var2     # 23skidoo</programlisting>
	       </para>
	       </formalpara>

	       <para>En una  <link linkend="regexref">expresión regular</link>, 
	       un signo <token>$</token> <link
		 linkend="dollarsignref"> coincide con el final de una línea</link>.</para>

	  </listitem>
	</varlistentry>  

	<varlistentry><term><token>${}</token></term>
	  <indexterm>
	    <primary>${}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>${}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>substitución de parámetros</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title><link linkend="paramsubref">Substitución de parámetros</link></title>
             <para></para></formalpara>
	  </listitem>
	</varlistentry>  

	<varlistentry>
	  <term><token>$*</token></term>
	  <term><token>$@</token></term>
	  <indexterm>
	    <primary>$*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>$*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$@</primary>
	    <secondary>parámetros de posición</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>$@</primary>
	  </indexterm>	  

	  <listitem><formalpara><title><link linkend="appref">parámetros de posición</link></title>
	      <para></para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>()</token></term>

	  <listitem><formalpara><title>grupo de comandos</title>
	      <para><programlisting>(a=hello; echo $a)</programlisting></para>
	    </formalpara>

	  <important>
	  
	    <para>Un listado de comandos dentro de 
	      <replaceable>paréntesis</replaceable> inicia un <link
	      linkend="subshellsref">subshell</link>.</para>

	    <para>Las variables dentro de paréntesis, dentro del subshell, no son visibles
	      al resto del script. el proceso padre, el script, <link linkend="parvis">no puede
	      leer variables creadas en el proceso hijo </link>, el subshell.
	      <programlisting>a=123
( a=321; )	      

echo "a = $a"   # a = 123
# "a" dentro de los paréntesis actúa como una variable local.</programlisting></para>
	  </important>


	  <formalpara><title>inicialización de arrays</title>
	    <para><programlisting>Array=(element1 element2 element3)</programlisting></para>
	    </formalpara>
	  </listitem>

	</varlistentry>

	<varlistentry>
	  <indexterm>
	    <primary>{xxx,yyy,zzz..}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>{}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>expansión de llaves</primary>
	  </indexterm>	  
	  <term><token>{xxx,yyy,zzz,...}</token></term>
	  <listitem><formalpara><title>Expansión de llaves</title>
	      <para><programlisting>grep Linux file*.{txt,htm*}
# Encuentra todas las apariciones de la palabra  "Linux"
# en los ficheros "fileA.txt", "file2.txt", "fileR.html", "file-87.htm", etc.</programlisting></para>
	    </formalpara>
	  <para>Un comando puede actuar como una lista separada de ficheros especificados dentro de 
	  <replaceable>llaves</replaceable>.

	     <footnote><para>El shell hace la  <emphasis>expansión de llaves</emphasis>. El comando mismo actúa como
	     sobre el <emphasis>resultado</emphasis> de la expansión.</para></footnote>
	  
	  Expansión de nombres de archivo (<link linkend="globbingref">globbing</link>)
	  se aplica a los archivos especificados entre las llaves.</para>

	  <caution>
	    <para>No se permiten espacios entre las llaves
	    <emphasis>a no ser que</emphasis> los espacios etén entrecomillados o escapados.</para>
	    
	    <para><userinput>echo {file1,file2}\ :{\ A," B",' C'}</userinput></para>
	    <para><computeroutput>file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</computeroutput></para>

	   </caution>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>{}</token></term>
	  <indexterm>
	    <primary>{}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>caracter especial</primary>
	    <secondary>{}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>bloque de código</primary>
	  </indexterm>	  

	  <listitem>
	  <para><anchor id="codeblockref"></para>
	  <formalpara><title>Bloque de código</title>
	      <para>[llaves]	También referidosc como un
		<quote>grupo en línea</quote>, esta construcción, en efecto, crea una
		función anónima. Sin embargo, a diferencia de  <link
		linkend="functionref">function</link>, las variables en un
		bloque de código permanecen visiblers al resto del script.</para></formalpara>
	      
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>{ local a; a=123; }</userinput>
<computeroutput>bash: local: sólo puede ser usado en una función</computeroutput>
	      </screen>
	      </para>

	      <para><programlisting>a=123
{ a=321; }
echo "a = $a"   # a = 321   (value inside code block)

# Thanks, S.C.</programlisting></para>


	    <para>El bloque de código encerrado entre llaves puede tener  <link
	      linkend="ioredirref">E/S redireccionada</link> a y desde él.</para>

	    <example id="ex8">
	      <title>Bloques de código y redirección de E/S</title>
	      <programlisting>&ex8;</programlisting>
	    </example>

	    <example id="rpmcheck">
	      <title>Guardar los resultados de un bloque de código en un archivo</title>
	      <programlisting>&rpmcheck;</programlisting>
	    </example>

	    <note><para>A diferencia de un grupo de comandos entre (paréntesis),
	      como arriba un bloque de código encerrado entre {llaves} 
	      <emphasis>no</emphasis> lanzará normalmente un<link
	      linkend="subshellsref">subshell</link>.
		<footnote><para>Excepción: un bloque de código entre llaves como parte de una
		canalización (pipe) <emphasis>podría</emphasis> ser ejecutado como un
		  <link linkend="subshellsref">subshell</link>.

		<programlisting>ls | { read firstline; read secondline; }
# Error. El bloque de código entre llaves se ejecuta como un subshell,
# así que la salida de "ls" no puede pasarse a variables dentro del bloque.
echo "Primera línea es $primeralinea; segunda línea es $segundalinea"
# No funcionará.

# Gracias, S.C.</programlisting></para></footnote>

	      </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>{} \;</token></term>
	  <listitem>

	  <formalpara><title>pathname</title>
	      <para>Mayormente usado en construcciones <link linkend="findref">find</link>.
		Esto <emphasis>no</emphasis> es un 
		<link linkend="builtinref">builtin</link> del shell.</para>
	    </formalpara>

	      <note><para>El <quote><token>;</token></quote> termina
		la opción <option>-exec</option> de una secuencia de 
		comandos <command>find</command>.  Necesita ser escapado
		para protegerlo de interpretación por el shell.</para></note>

	  </listitem>
	</varlistentry>


	<varlistentry><term><token>[ ]</token></term>
	  <indexterm>
	    <primary>[]</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>[ ]</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>test</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title>test</title>
             <para></para></formalpara>
	     <para><anchor id="leftbracket"><link
	       linkend="ifthen">Testea</link> la expresión entre <command>[
	       ]</command>.  Note que <command>[</command> es parte de
	       un builtin <command>test</command> del shell (y un  sinónimo
	       para él), <emphasis>no</emphasis> un enlace al comando externo
	       <filename>/usr/bin/test</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>[[ ]]</token></term>
	  <indexterm>
	    <primary>[[]]</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>[[ ]]</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>test</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title>test</title>
             <para></para></formalpara>
	     <para>Testea la expresión entre <token>[[ ]]</token>
	       <link linkend="keywordref">palabra reservada</link> del
             shell).</para>
	     <para>Vea la discusión en la <link
	     linkend="dblbrackets">construcción [[ ... ]] </link>.</para> 
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>(( ))</token></term>
	  <indexterm>
	    <primary>(( ))</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>(( ))</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>comparación de enteros</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title>expansión de enteros</title>
             <para></para></formalpara>
	     <para>Expande y evalúa una expresión entera entre
	       <token>(( ))</token>.</para>
	     <para>Vea la discusión en la <link
	     linkend="dblparens">construcción (( ... )) </link>.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>></token> <token>>&</token> <token>>></token> <token><</token></term>
	  <indexterm>
	    <primary>></primary>
	  </indexterm>
	  <indexterm>
	    <primary>>&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>>></primary>
	  </indexterm>
	  <indexterm>
	    <primary><</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>>&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>caracter especial</primary>
	    <secondary><</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirección</primary>
	  </indexterm>	  

	  <listitem><formalpara><title><link linkend="ioredirref">redirección</link></title>
	      <para></para>
	    </formalpara>

	    <para><userinput>nombre_script >nombre_archivo</userinput>
	      redirige la salida de
	      <filename>nombre_script</filename> al archivo
	      <filename>nombre_archivo</filename>. Sobreescribiendo
	      <filename>nombre_archivo</filename> si ya existiese.</para>

	    <para><userinput>comando >&2</userinput> redirige
	      la salida del <filename>comando</filename> a
	      <filename>stderr</filename>.</para>

	    <para><userinput>nombre_script >>nombre_archivo</userinput> anexa
	    la salida de <filename>nombre_script</filename>
	    al fichero <filename>nombre_fichero</filename>. Si
	    <filename>nombre_fichero</filename> si no existiese ya, se
	    creará.</para>


	    <formalpara><title><link
	      linkend="processsubref">sustitución de procesos</link></title>
	      <para></para>
	    </formalpara>

	    <para><userinput>(comando)></userinput></para>
	    <para><userinput><(comando)</userinput></para>


	    <para><link linkend="ltref">En un contexto diferente</link>,
	      los caracteres <quote><token>&lt;</token></quote> y
	      <quote><token>&gt;</token></quote> actúan como 
	      as <link linkend="scomparison1">operadores de
	      comparaciónd de cadenas</link>.</para>

	    <para><link linkend="intlt">En otro contexto</link>,
	      los caracteres <quote><token>&lt;</token></quote> y
	      <quote><token>&gt;</token></quote> actúan como 
	       <link linkend="icomparison1">operadores de comparación
	      de enteros </link>. Vea además <xref linkend="ex45">.</para>

	  </listitem>


	</varlistentry>

	<varlistentry>
	  <term><token><<</token></term>
	  <listitem><formalpara><title>redirección usada en un<link
	    linkend="heredocref">documento aquí</link></title>
	      <para></para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|</token></term>
	  <indexterm>
	    <primary>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>pipe</primary>
	  </indexterm>
	  <indexterm><primary>canalización</primary>
          </indexterm>

	  <listitem>
	  <para><anchor id="piperef"></para>
	  <formalpara><title>pipe</title>
	      <para>Pasa la salida de un comando anterior a la entrada
	  de siguiente, o a la shell. Este es un método de encadenar
	  comandos juntos.</para>
	    </formalpara>

	    <para>
              <programlisting>echo ls -l | sh
#  Passes the output of "echo ls -l" to the shell,
#+ with the same result as a simple "ls -l".


cat *.lst | sort | uniq
# Merges and sorts all ".lst" files, then deletes duplicate lines.</programlisting>
	    </para>

	    <sidebar>
	    <para>Una canalización (pipe), como un método clasico de
	      comunicación entre procesos, envía la salida estándar,
	      <filename>stdout</filename> de un proceso a la entrada
	      estándar, <filename>stdin</filename> de otro. En un caso
	      típico, un comando como <link
	      linkend="catref">cat</link> o  <link
	      linkend="echoref">echo</link>, canaliza un flujo de
	      datos a un filtro para procesarlo.</para>
	    <para>  
	      <userinput>cat $filename | grep $search_word</userinput>
            </para>
	    </sidebar>


	    <para><anchor id="ucref">La salida de un comando o
	      comandos puede ser canalizada a un script.

	      <programlisting>#!/bin/bash
# uppercase.sh : Cambia la entrada a mayúsculas.

tr 'a-z' 'A-Z'
#  Los rangos de letras deben ser entrecomillados
#+ para prevenir la generación de nombres de archivo de nombres de
archivo de una sola letra.

exit 0</programlisting>
              Ahora, canalizaremos la salida de <command>ls
              -l</command> a este script.

	      <screen><prompt>bash$ </prompt><userinput>ls -l | ./uppercase.sh</userinput>
<computeroutput>-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE</computeroutput>
	      </screen>
	    </para>

	     <note>

	     <para>La <filename>stdout</filename> de cada proceso en
	       una canalización debe ser leída como la <filename>stdin</filename>
	       del siguiente. Si este no es el caso, el flujo de datos
	       se <emphasis>bloqueará</emphasis>, y la canalización no
	       funcionará como se espera.
	         <programlisting>cat file1 file2 | ls -l | sort
# La salida de  "cat file1 file2" desaparece.</programlisting>
             </para>

	     <para>Una canalización funciona como un <link linkend="childref">proceso
	       hijo</link>, y por lo tanto no puede alterar variables
	       del script.
	         <programlisting>variable="valor_inicial"
echo "nuevo_valor" | read variable
echo "variable = $variable"     # variable = valor_inicial</programlisting>
             </para>

	     <para>Si uno de los comandos en la canalización aborta,
	       esto termina prematuramente la ejecución de la
	       canalización. Entonces se llama una
	       <emphasis>canalización rota (broken pipe)</emphasis>,
	       esta condición envía una señal <emphasis>SIGPIPE</emphasis> <link
	       linkend="signald"></link>.</para>

	      </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>|</token></term>
	  <indexterm>
	    <primary>>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirección</primary>
	    <secondary>forzada</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>noclobber</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>forzar redirección (incluso si
		la opción  <link linkend="noclobberref">noclobber</link>
		está activa)</title>
	      <para>Esto forzará la sobreescritura de un archivo existente.</para>
	    </formalpara>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><token>&amp;</token></term>
	  <listitem><formalpara><title>Ejecución de una tarea en segundo plano</title>
	      <para>Un comando seguido por un  <token>&amp;</token>
	        se ejecutará en segundo plano.</para>
	    </formalpara>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>sleep 10 &</userinput>
<computeroutput>[1] 850</computeroutput>
<computeroutput>[1]+  Done                    sleep 10</computeroutput>
	      </screen>
	    </para>

	    <caution><para>Un comando ejecutado en segundo plano
	      dentro de un script podría hacer que el script se
	      cuelgue, esperando una pulsación de
	      tecla. Afortunadamente hay un <link
	      linkend="waithang">remedio</link> para esto.</para></caution>

	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-</token></term>
	  <indexterm>
	    <primary>-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>carácter especial</primary>
	    <secondary>-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirección</primary>
	    <secondary>desde/hacia stdin/stdout</secondary>
	  </indexterm>	  
	  <listitem><formalpara><title>redirección desde/hacia <filename>stdin</filename> o <filename>stdout</filename></title>
	    <para><anchor id="coxex">[dash]</para>
	    </formalpara>


	    <para><programlisting>(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
# Mueve el árbol de fichero completo desde un directorio a otro
# [cortesía de Alan Cox &lt;a.cox@swansea.ac.uk&gt;, con un cambio menor]

# 1) cd /source/directory    Directorio de origen, donde están los archivo a ser movidos.
# 2) &&                     "And-list": si la operación 'cd' tiene éxito, entonces ejecuta el siguiente comando.
# 3) tar cf - .              La opción 'c' del comando 'tar' crea un archivo nuevo,
#                            la opción 'f' (file), seguida por  '-' designa el archivo destino como stdout,
#                            y para hacerlo en el árbol de directorios actual ('.').
# 4) |                       Encauzado a...
# 5) ( ... )                 un subshell
# 6) cd /dest/directory      Cambiar al directorio de destino.
# 7) &&                     "And-list", como arriba
# 8) tar xpvf -              Desarchivar ('x'), preservando pertenencia y permisos de fichero ('p'),
#                            y enviar mensajes verbosos a stdout ('v'),
#                            leyendo datos desde  stdin ('f' followed by '-').
#
#                            Note que 'x' es un comando, y 'p', 'v', 'f' son opciones .
# Whew!



# Más elegante pero equivalente:
#   cd source-directory
#   tar cf - . | (cd ../target-directory; tar xzf -)
#
# cp -a /source/directory /dest     también tiene el mismo efecto.
</programlisting></para>

	    <para><programlisting>bunzip2 linux-2.4.3.tar.bz2 | tar xvf -
# --uncompress tar file--    | --then pass it to "tar"--
# Si "tar" no ha sido parcheado para manipular "bunzip2",
# se necesita hacer esto en dos pasos, usando un cauce.
# El propósito de esto es desarchivar los fuentes del núcleo "bzippeados" .
</programlisting></para>
       
          <para>Note que en este contexto el <quote>-</quote> no es un
            operador de Bash, sino una opción reconocida por ciertas utilidades
	    de UNIX que escriben en 
	    <filename>stdout</filename>, como <command>tar</command>,
	    <command>cat</command>, etc.</para>

	    <para>Donde se espere un nombre de archivo,
	      <replaceable>-</replaceable> redirige la salida a 
	      <filename>stdout</filename> (algunas veces visto con
	      <userinput>tar cf</userinput>), o acepta entrada desde
	      <filename>stdin</filename>, en vez de desde un fichero. Este
	      es un método de usar una utilidad orientada a fichero como
	      un filtro en un cauce.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>file</userinput>
<computeroutput>Uso: file [-bciknvzL] [-f namefile] [-m magicfiles] file...</computeroutput>
	      </screen>

	    Por sí mismo en la línea de comandos, <link
	      linkend="fileref">file</link> falla con un mensaje de error.
	    </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>file -</userinput>
<userinput>#!/bin/bash</userinput>
<computeroutput>standard input:              Bourne-Again shell script text executable</computeroutput>
	      </screen>
	      Esta vez, acepta entrada desde <filename>stdin</filename>
	        y la filtra.
	    </para>

	    <para>El <token>-</token> puede usarse para encauzar
	      <filename>stdout</filename> a otros comandos. Esto permite
	      cosas como <link linkend="prependref">anteponer líneas a
	      un archivo</link>.</para>

	    <para>Uso de  <link linkend="diffref">diff</link> para
	      comparar un archivo con un <emphasis>sección</emphasis>
	      de otro:</para>

<para><userinput>grep bash file1 | diff file2 -</userinput></para>	      


            <para>Finalmente, un ejemplo del mundo real del uso de 
	      <replaceable>-</replaceable> con <link
	      linkend="tarref">tar</link>.</para>

	    <example id="ex58">
	      <title>Copia de respaldo de todos loas archivos
	      cambiados en el último día</title>
	      <programlisting>&ex58;</programlisting>
	    </example>

	    <caution>
	    <para>Los nombres de archivo que empiezan por 
	      <replaceable>-</replaceable> pueden causar problemas cuando
	      se usan junto con el operador de redirección <replaceable>-</replaceable>.
	      Un script debería comprobar este caso y pasar dichos 
	      nombres de archivo como <replaceable>./-FILENAME</replaceable> o
	      <replaceable>$PWD/-FILENAME</replaceable>.</para>
	      <para>Si el valor de una variable comienza por un
	        <replaceable>-</replaceable>, esto también podría
	      crear problemas.
		<programlisting>var="-n"
echo $var		
# Tiene el efecto de "echo -n", y no saca nada.</programlisting>
              </para>
	      </caution>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>-</token></term>
	  <listitem><formalpara><title>directorio de trabajo anterior</title>
	      <para>[guión]  <command>cd -</command> cambia al
	  directorio de trabajo anterior. Esto usa la variable de entorno <link
		linkend="oldpwd">$OLDPWD</link>.</para>
	    </formalpara>
	      <caution><para>Esto no debe confundirse con el operador
		de  redirección <quote>-</quote> que se acaba de
		explicar. La interpretación del <quote>-</quote>
		depende del contexto en el que aparezca.</para></caution>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-</token></term>
	  <listitem><formalpara><title>Menos</title>
	      <para>El signo menos en una<link
	  linkend="arops1">operación aritmética
	        </link>.</para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>=</token></term>
	  <listitem><formalpara><title>Igual</title>
	      <para><link linkend="eqref">Operador de asignación</link>
	        <programlisting>a=28
echo $a   # 28</programlisting></para>
	    </formalpara>
	    <para>En un <link linkend="equalsignref">contexto diferente</link>,
	      el signo <quote><token>=</token></quote> es un operador de <link
	      linkend="scomparison1">comparación de cadenas</link>
	      .</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>+</token></term>
	  <listitem><formalpara><title>Más</title>
	      <para><link linkend="arops1">Operación aritmética
	       </link>de suma.</para>
	    </formalpara>
	    <para>En un <link linkend="plusref">contexto diferente</link>,
	      el signo <token>+</token> es un operador de <link
	      linkend="regexp">Expresion regular</link>.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>%</token></term>
	  <listitem><formalpara><title><link linkend="moduloref">módulo</link></title>
	      <para><link linkend="arops1">Operación aritmética
	        </link>módulo (resto de una división).</para>
	    </formalpara>
	    <para>En un <link linkend="pctpatref">contexto diferente</link>,
	      el signo <token>%</token> es un operador de <link
	      linkend="psub2">coincidencia con patrones</link>.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~</token></term>
	  <listitem><formalpara><title>directorio personal</title>

	      <para>[virgulilla]  Esto se corresponde con la variable interna<link
	        linkend="homedirref">$HOME</link>.

	      <emphasis>~bozo</emphasis> es el directorio personal de bozo,
		y <command>ls ~bozo</command> lista el contenido de él.
		<token>~/</token> es el directorio personal del
		usuario actual, y <command>ls ~/</command> lista el
		contenido de éste.

	      <screen><prompt>bash$ </prompt><userinput>echo ~bozo</userinput>
<computeroutput>/home/bozo</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~</userinput>
<computeroutput>/home/bozo</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~/</userinput>
<computeroutput>/home/bozo/</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~:</userinput>
<computeroutput>/home/bozo:</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~nonexistent-user</userinput>
<computeroutput>~nonexistent-user</computeroutput>
	      </screen>
	      </para>

	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~+</token></term>
	  <listitem><formalpara><title>directorio de trabajo actual</title>
	      <para>Esto se corresponde con la variable interna <link
	        linkend="pwdref">$PWD</link>.</para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~-</token></term>
	  <listitem><formalpara><title>directorio de trabajo anterior</title>
	      <para>Esto se corresponde con la variable interna <link
	        linkend="oldpwd">$OLDPWD</link> .</para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Caracteres de control</term>
	  <listitem>
	  <para><anchor id="controlcharref"></para>
	  <formalpara><title> cambian el comportamiento del teminal o 
	        pantalla de texto.</title>
	    <para>Un caracter de control es una combinación de 
	   <keycap>CONTROL</keycap>
	      + <keycap>tecla</keycap>.</para>
	    </formalpara>

	    <itemizedlist id="ctlchar">

	      <listitem>
	        <para><userinput>Ctl-C</userinput></para>
		<para>Termina una tarea en primer plano.</para>
	      </listitem>

	      <listitem>
	        <para><anchor id="ctldref"></para>
	        <para><userinput>Ctl-D</userinput></para>
		<para>Sale de una shell (similar a 
		  <link linkend="exitcommandref">exit</link>).</para>
		<para><quote>EOF</quote> (fin de fichero). Esto
	        también termina la entrada desde  <filename>stdin</filename>.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-G</userinput></para>
		<para><quote>BEL</quote> (campana).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-H</userinput></para>
		<para>Borrar atrás (Backspace).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-J</userinput></para>
		<para>Retorno de carro.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-L</userinput></para>
		<para>Formfeed (limpia la pantalla del
		terminal). Tiene el mismo efecto que el comando <link
		  linkend="clearref">clear</link>.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-M</userinput></para>
		<para>Linea nueva.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-U</userinput></para>
		<para>Borra una línea de entrada.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-Z</userinput></para>
		<para>Pausar un trabajo en primer plano.</para>
	      </listitem>

	    </itemizedlist>



	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Espacio en blanco</term>
	  <listitem>
	  <para><anchor id="whitespaceref"></para>
	  <formalpara><title>funciona como un separador, separando
	  comandos o variables.</title>
	      <para>El espacio en blanco consiste en cualquiera de los
	  caracteres espacio, tabulador, líneas en blanco, o cualquier
	  combinación de ellos. En algunos contextos, como en la
	  <link linkend="wsbad">asignación de variables</link>,
	  el espacio en blanco no está permitido, y resulta en un
	  error de sintaxis.</para>
	    </formalpara>

	  <para>Las líneas en blanco no tienen efecto en la acción de
	    un script, y sólo son útiles para separar visualmente 
	    secciones funcionales.</para>

	  <para><link linkend="ifsref">$IFS</link>, la variable
	    especial de separación de campos de entrada en ciertos
	    comandos, por omisión está asignada al espacio en blanco.</para>

	  </listitem>
	</varlistentry>


      </variablelist>

  </chapter> <!-- Special characters used in shell scripts -->
