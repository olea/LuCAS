#This file was created by <manuel> Tue May 25 20:41:44 1999
#LyX 1.0 (C) 1995-1999 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass book
\language spanish
\inputencoding default
\fontscheme default
\graphics default
\paperfontsize 10
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 1
\use_amsmath 0
\paperorientation portrait
\leftmargin 20mm
\topmargin 20mm
\rightmargin 20mm
\bottommargin 20mm
\secnumdepth 5
\tocdepth 5
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle headings

\layout Title

Teoría del Lenguaje C
\layout Standard


\begin_inset LatexCommand \tableofcontents

\end_inset 


\layout Chapter

Introducción al Lenguaje C
\layout Standard

El objetivo de este curso es enseñar el lenguaje C, o dicho de otro modo,
 enseñar a programar en lenguaje C.
\layout Description


\size giant 
Indice
\protected_separator 
de
\protected_separator 
Este
\protected_separator 
Capítulo
\layout Standard

En esta lección se va a estudiar los siguientes puntos:
\layout Standard


\series bold 
ORIGENES
\series default 
: Breve historia del lenguaje C.
\layout Standard


\series bold 
CARACTERISTICAS
\series default 
: Algunas características importantes del lenguaje.
\layout Standard


\series bold 
USO
\series default 
: Pasos para realizar un programa en este lenguaje.
\layout Standard


\series bold 
EJEMPLOS
\series default 
: Tres programas para empezar a programar en C cuanto antes.
\layout Section

Orígenes del C
\layout Standard

El lenguaje C fue inventado por Dennis Ritchie en 1972 cuando trabajaba,
 junto con Ken Thompson, en el diseño del sistema operativo UNIX.
 El lenguaje C deriva del lenguaje B de Thompson, el cual, a su vez, deriva
 del lenguaje BCPL desarrollado por Martin Richards.
 Durante muchos años el estándar de C fue la versión proporcionada con el
 sistema operativo UNIX versión 5.
 Pero pronto empezaron a surgir muchas implementaciones del C a raíz de
 la popularidad creciente de los microordenadores.
 Por este motivo, se hizo necesario definir un C estándar que está representado
 hoy por el ANSI C.
\layout Standard

En este libro se va a estudiar el C estándar.
 No obstante, si la opción turbo está activada, también se incluirá en la
 explicación la versión Turbo C de Borland International, que es uno de
 los mejores compiladores de C que existen en el mercado.
 Cuando nos referimos a Turbo C, estamos hablando indistintamente de las
 distintas versiones que existen sobre los paquetes Turbo C, Turbo C++ y
 Borland C++, puesto que en todos ellos se puede programar en C.
\layout Standard

El lenguaje C suministrado por Turbo C es, simplemente, una ampliación del
 ANSI C, sobre todo en el número de funciones de librería suministradas.
\layout Section

Características del Lenguaje C
\layout Standard

Algunas características del lenguaje C son las siguientes:
\layout Itemize

Es un lenguaje de 
\emph on 
propósito general
\emph default 
.
 Este lenguaje se ha utilizado para el desarrollo de aplicaciones tan dispares
 como: hojas de cálculos, gestores de bases de datos, compiladores, sistemas
 operativos, ...
\layout Itemize

Es un lenguaje de 
\emph on 
nivel medio
\emph default 
.
 Este lenguaje permite programar a alto nivel (pensando a nivel lógico y
 no en la máquina física) y a bajo nivel (con lo que se puede obtener la
 máxima eficiencia y un control absoluto de cuanto sucede en el interior
 del ordenador).
\layout Itemize

Es un lenguaje 
\emph on 
portátil
\emph default 
.
 Los programas escritos en C son fácilmente transportables a otros sistemas.
\layout Itemize

Es un lenguaje potente y eficiente.
 Usando C, un programador puede casi alcanzar la eficiencia del código ensamblad
or junto con la estructura del Algol o Pascal.
\layout Standard

Como desventajas habría que reseñar que es más complicado de aprender queotros
 lenguajes como Pascal o Basic y que requiere una cierta experiencia para
 poder aprovecharlo a fondo.
\layout Section

Uso del C
\layout Standard

Los pasos a seguir desde el momento que se comienza a escribir el programa
 C hasta que se ejecuta son los siguientes:
\layout Enumerate

Escribirlo en un editor.
\layout Enumerate

Compilarlo en un compilador.
\layout Enumerate

Enlazarlo en un enlazador.
\layout Enumerate

Ejecutarlo.
\layout Description

Paso
\protected_separator 
1: 
\series bold 
ESCRIBIRLO
\layout Standard

El programa se puede escribir en cualquier editor que genere ficheros de
 texto estándar, esto es, que los ficheros generados no incluyan códigos
 de control y caracteres no imprimibles.
 Estos ficheros que contienen código C se llaman ficheros fuentes.
 Los ficheros fuentes son aquellos que contienen código fuente, es decir,
 ficheros con texto que el usuario puede leer y que son utilizados como
 entrada al compilador de C.
 Los programas pequeños suelen ocupar un solo fichero fuente; pero a medida
 que el programa crece, se va haciendo necesario distribuirlo en más ficheos
 fuentes.
 
\layout Description

Paso
\protected_separator 
2: 
\series bold 
COMPILARLO 
\layout Standard

El compilador produce ficheros objetos a partir de los ficheros fuentes.
 Los ficheros objetos son los ficheros que contienen código objeto, es decir,
 ficheros con código máquina (número binarios que tiene significado para
 el microprocesador) y que son utilizados como entrada al enlazador.
 
\layout Standard

La extensión de estos ficheros es 
\family typewriter 
OBJ
\family default 
, aunque también los hay con extensión 
\family typewriter 
LIB
\family default 
.
 A estos últimos se les llama también ficheros de librería o biblioteca;
 contienen código máquina perteneciente a código compilado suministrado
 por el compilador.
\layout Description

Paso
\protected_separator 
3: 
\series bold 
ENLAZARLO
\layout Standard

El enlazador produce un fichero ejecutable a partir de los ficheros objetos.
 Los ficheros ejecutables son aquellos que contienen código máquina y se
 pueden ejecutar directamente por el sistema operativo.
 La extensión estos ficheros es 
\family typewriter 
EXE
\family default 
 o 
\family typewriter 
COM
\family default 
.
 Al proceso de enlazado también se le suele llamar el proceso de linkado.
\layout Description

Paso
\protected_separator 
4: 
\series bold 
EJECUTARLO
\layout Standard

El programa se puede ejecutar simplemente tecleando su nombre desde la línea
 de comandos del sistema operativo.
 Hoy día los compiladores de C son muy sofisticados e incluyen entornos
 integrados desde los cuales editamos, compilamos, enlazamos, y podemos
 realizar una multitud de servicios más.
 En algunos de ellos se pueden realizar los pasos de compilado, enlazado
 y ejecutado con la pulsación de una sola tecla.
 En Turbo C tenemos las siguientes teclas relacionadas con este tema:
\layout Quotation

ALT-F9: Compilar a OBJ.
\layout Quotation

F9: Hacer fichero EXE.
\layout Quotation

CTRL-F9: Ejecutar.
\layout Standard

Se puede pulsar directamente CTRL-F9 para compilar, enlazar y ejecutar.
 En programación, la experiencia es el gran maestro.
 Por ello es conveniente empezar a hacer programas en C cuanto antes.
 A continuación se van a presentar varios programas completos en C muy sencillos
 para ir familiarizóndonos en la programación de este lenguaje.
\layout Section

Ejemplos
\layout Subsection

Nuestro primer programa C 
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
main()
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Mi primer programa en C.");
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa por pantalla es:
\layout Quotation


\family typewriter 
Mi primer programa en C.
\layout Standard

Analicemos a continuación nuestro primer programa.
\layout Standard

Los programas C están compuestos de unidades de programa llamadas funciones,
 las cuales son los módulos básicos del programa.
 En este caso, el programa está compuesto por una sola función llamada 
\family typewriter 
main
\family default 
.
 Todos los programas C deben tener una función 
\family typewriter 
main
\begin_float footnote 
\layout Standard

en español significa principal
\end_float 
 pues es la primera función que se ejecuta cuando se hace funcionar el programa.
\layout Standard

Los paréntesis que siguen a 
\family typewriter 
main
\family default 
 identifican a ésta como nombre de función.
 Un método de comunicación de datos entre funciones es el uso de argumentos.
 Los argumentos son los datos que se les pasa a las funciones.
 Estos se encierran entre paréntesis; 
\family typewriter 
main
\family default 
 es una función sin argumentos, lo que se indica mediante 
\family typewriter 
()
\family default 
.
 La línea con:
\layout Quotation


\family typewriter 
printf("Mi primer programa en C.");
\layout Standard

realiza una llamada a una función denominada 
\family typewriter 
printf
\family default 
, con el argumento 
\family typewriter 
"Mi primer programa en C."
\family default 
; 
\family typewriter 
printf
\family default 
 es una función de biblioteca que realiza una escritura en la salida estándar.
 Normalmente la salida estándar es el monitor.
\layout Standard

La función 
\family typewriter 
printf
\family default 
 escribe concretamente una cadena (conocido también con los nombres de cadena
 de caracteres, constante de caracteres y string).
 Una cadena es una secuencia de caracteres.
 Cada instrucción en C termina con un punto y coma.
 La línea del 
\family typewriter 
main()
\family default 
 no va seguida de punto y coma porque no se trata de una llamada a una función
 sino de la definición de una función.
 La definición de una función especifica las instrucciones que posee dicha
 función asi como los argumentos que tiene.
\layout Standard


\family typewriter 
printf
\family default 
 es una función de librería que está definida en el fichero 
\family typewriter 
stdio.h
\family default 
 (standard input/output header).
 Las funciones de librería son aquellas suministradas por el compilador
 y que están a nuestra disposición.
 Para utilizar una función de librería es necesario incluir el correspondiente
 fichero de cabecera antes de utilizarla.
\layout Standard

Cada fichero de librería incluye muchas funciones.
 Por ejemplo, la librería 
\family typewriter 
stdio.h
\family default 
 define funciones de entrada y salida estándar.
 Pero en el fichero ejecutable de nuestro programa sólo están las funciones
 de librería que hemos utilizado.
 De esta forma el tamaño del código ejecutable se reduce al mínimo.
 La función
\layout Quotation


\family typewriter 
main()
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf ("Mi primer programa en C.");
\layout Quotation


\family typewriter 
}
\layout Standard

también se podía haber escrito así:
\layout Quotation


\family typewriter 
main(){printf("Mi primer programa en C.");}
\layout Standard

pero en este caso el código es menos legible para el usuario.
 El C es sensintivo al caso.
 Esto significa que las letras mayúsculas son distintas a las minúsculas.
 De este modo, no es lo mismo para el C 
\family typewriter 
printf
\family default 
 que 
\family typewriter 
PRINTF
\family default 
 o que 
\family typewriter 
Printf
\family default 
.
 Todas las líneas que empiezan con 
\family typewriter 
#
\family default 
 no son en realidad instrucciones del lenguaje C sino que son líneas para
 ser manipuladas por el preprocesador.
 El preprocesador realiza algunas tareas antes de empezar a actuar el compilador.
 La línea
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Standard

lo que hace es incluir la información que hay en el fichero 
\family typewriter 
stdio.h
\family default 
 en nuestro programa.
 En el fichero 
\family typewriter 
stdio.h
\family default 
 se encuentra la definición de la función 
\family typewriter 
printf
\family default 
.
 Si no se pusiera este include en nuestro programa, el compilador no sabría
 cómo es la función 
\family typewriter 
printf
\family default 
 y daría error.
 Veamos ahora un segundo ejemplo algo más complicado que el anterior.
\layout Subsection

Nuestro segundo programa C 
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
main()
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Mi segundo programa en C.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Pulsa la tecla RETURN para terminar.");
\layout Quotation


\family typewriter 

\protected_separator 
 getchar();
\layout Quotation


\family typewriter 
}
\layout Standard

La salida por pantalla de este programa es:
\layout Quotation


\family typewriter 
Mi segundo programa en C.
\layout Quotation


\family typewriter 
Pulsa la tecla RETURN para terminar.
\layout Standard

Analicemos a continuación nuestro segundo programa.
 Hay dos novedades con respecto al primer ejemplo: la primera es la aparición
 del código 
\family typewriter 

\backslash 
n
\family default 
 dentro de la cadena del primer 
\family typewriter 
printf
\family default 
.
 La segunda es la aparición de una nueva función de librería: 
\family typewriter 
getchar()
\family default 
.
 En C, todo lo que va entre comillas es una cadena.
 Ya dijimos antes que una cadena es una secuencia de caracteres.
 La secuencia 
\family typewriter 

\backslash 
n
\family default 
 es un carácter especial que denota el carácter de nueva línea.
 Al ser 
\family typewriter 

\backslash 
n
\family default 
 un carácter se puede incluir en cualquier parte de una cadena como cualquier
 otra carácter.
 En nuestro programa, si no se hubiese incluido, la salida habría sido:
\layout Quotation


\family typewriter 
Mi segundo programa en C.
 Pulsa la tecla RETURN para terminar.
\layout Standard

A continuación se van a mostrar tres programas equivalentes al del ejemplo.
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
main()
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Mi segundo programa en C.");
\layout Quotation


\family typewriter 

\protected_separator 
 printf ("
\backslash 
nPulsa la tecla RETURN para terminar.");
\layout Quotation


\family typewriter 

\protected_separator 
 getchar();
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
main()
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Mi segundo programa en C.
\backslash 
nPulsa la tecla RETURN para terminar.");
\layout Quotation


\family typewriter 

\protected_separator 
 getchar();
\layout Quotation


\family typewriter 
}
\layout Quotation


\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
main()
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Mi segundo programa en C.");
\layout Quotation


\family typewriter 

\protected_separator 
 printf("
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Pulsa la tecla RETURN para terminar.");
\layout Quotation


\family typewriter 

\protected_separator 
 getchar();
\layout Quotation


\family typewriter 
}
\layout Standard

A todos los caracteres empezados por 
\family typewriter 

\backslash 

\family default 
 se les llaman secuencias de escape.
 Las secuencias de escape son mecanismos para representar caracteres no
 imprimibles.
 Antes vimos la secuencia de escape 
\family typewriter 

\backslash 
n
\family default 
 que representaba a la nueva línea.
 Otras secuencias de escape son 
\family typewriter 

\backslash 
r
\family default 
 para el retorno de carro, 
\family typewriter 

\backslash 
t
\family default 
 para el tabulador, 
\family typewriter 

\backslash 
b
\family default 
 para retroceso, 
\family typewriter 

\backslash 
"
\family default 
 para la comilla, 
\family typewriter 

\backslash 
'
\family default 
 para el apóstrofe y 
\family typewriter 

\backslash 

\backslash 

\family default 
 para la barra diagonal invertida.
\layout Standard

Si nuestro primer programa lo ejecutamos desde un entorno integrado, en
 muchos de estos entornos, a la finalización de la ejecución de nuestro
 programa C, la frase impresa desaparece inmediatamente y se vuelve a la
 pantalla del entorno.
 Todos estos entornos poseen mecanismos para visualizar la pantalla de ejecución.
 En Turbo C, pulsando ALT-F5 se puede ver la pantalla de ejecución.
\layout Standard

Una solución alternativa es incluir la función 
\family typewriter 
getchar()
\family default 
 al final de la función 
\family typewriter 
main()
\family default 
.
 
\family typewriter 
getchar()
\family default 
 es una función que espera la pulsación de la tecla return por parte del
 usuario.
 Esta función no necesita argumentos pero los paréntesis son necesarios
 puesto que se trata de una función.
 
\family typewriter 
getchar()
\family default 
 se encuentra en la librería stdio.h, por lo tanto, siempre que utilicemos
 esta función en un programa es necesario incluir la línea:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Standard

Veamos nuestro último programa ejemplo de esta lección.
\layout Subsection

Nuestro Tercer Programa C
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
main () /* Tercer ejemplo */
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int horas, minutos;
\layout Quotation


\family typewriter 

\protected_separator 
 horas = 3;
\layout Quotation


\family typewriter 

\protected_separator 
 minutos = 60 * horas;
\layout Quotation


\family typewriter 

\protected_separator 
 printf ("Hay %d minutos en %d horas.", minutos, horas);
\layout Quotation


\family typewriter 

\protected_separator 
 getchar ();
\layout Quotation


\family typewriter 
}
\layout Standard

La salida por pantalla de este programa es:
\layout Quotation


\family typewriter 
Hay 180 minutos en 3 horas.
\layout Standard

Analicemos a continuación nuestro tercer programa.
 En C, todo aquello que vaya entre un 
\family typewriter 
/*
\family default 
 y un 
\family typewriter 
*/
\family default 
 es ignorado.
 Las secuencias 
\family typewriter 
/*
\family default 
 y 
\family typewriter 
*/
\family default 
 denotan el principio y el final de un comentario en C.
 Se deben utilizar comentarios en los programas para hacerlos más comprensibles.
 La línea:
\layout Quotation


\family typewriter 
int horas, minutos;
\layout Standard

es una sentencia de declaración.
 En este caso se declaran dos cosas:
\layout Enumerate

En algún sitio de la función se utilizarán las variables hora y minutos.
\layout Enumerate

Estas dos variables son de tipo entero (integer).
\layout Standard

El punto y coma final de la línea de declaración la identifican como una
 sentencia o instrucción C.
 También se podría haber escrito:
\layout Quotation


\family typewriter 
int horas;
\layout Quotation


\family typewriter 
int minutos;
\layout Standard

Las variables son posiciones de memoria donde el valor de su contenido puede
 variar a lo largo del programa.
 Nos la podemos imaginar como cajas donde podemos meter cualquier cosa que
 le venga bien a la caja.
 En C, todas las variables utilizadas ha de ser declaradas antes de su uso.
 Las líneas
\layout Quotation


\family typewriter 
horas = 3;
\layout Quotation


\family typewriter 
minutos = 60 * horas;
\layout Standard

son sentencias de asignación.
 La primera línea significa: dar a la variable horas el valor 3.
 La segunda línea significa: dar a la variable minutos el resultado de multiplic
ar 60 por horas.
 Nótese que las dos líneas terminan en punto y coma por ser dos sentencias
 o instrucciones.
 En la línea
\layout Quotation


\family typewriter 
int horas, minutos;
\layout Standard

se reserva espacio en memoria a las variables horas y minutos.
 En las líneas
\layout Quotation


\family typewriter 
hora = 3;
\layout Quotation


\family typewriter 
minutos = 60 * horas;
\layout Standard

se les da valor a dichas variables (al contenido de los espacios reservados).
 Posteriormente se les puede asignar a estas variables valores diferentes.
 
\family typewriter 
=
\family default 
 es el operador de asignación y 
\family typewriter 
*
\family default 
 es el operador de multiplicación.
 
\layout Standard

Otros operadores son: 
\family typewriter 
+
\family default 
 (número positivo usado como operador unario y suma usado como operador
 binario), 
\family typewriter 
-
\family default 
 (número negativo usado como operador unario y substracción usado como operador
 binario), 
\family typewriter 
/
\family default 
 (operador de división), 
\family typewriter 
%
\family default 
 (operador módulo, esto es, resto de la división de dos números enteros).
 En este momento, se mencionan estos operadores para empezar a hacer pequeños
 programas.
 En lecciones ulteriores se verán en detalle todos los operadores.
 La línea
\layout Quotation


\family typewriter 
printf("Hay %d minutos en %d horas.", minutos, horas);
\layout Standard

escribe:
\layout Quotation


\family typewriter 
Hay 180 minutos en 2 horas.
\layout Standard

Como se ve los dos 
\family typewriter 
%d
\family default 
 no se han escrito y sin embargo se ha escrito en su lugar los valores de
 las variables minutos y horas.
 El símbolo 
\family typewriter 
%
\family default 
 avisa a la función printf que se va a imprimir una variable en esta posición;
 la letra 
\family typewriter 
d
\family default 
 informa que la variable a imprimir es entera (digit).
 
\family typewriter 
printf
\family default 
 significa escritura (print) con formato (format) porque nos permite formatear
 la salida a nuestro gusto.
 La estructura de toda función C es:
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 declaración_de_variables
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 sentencias
\layout Quotation


\family typewriter 
}
\layout Standard

donde declaración_de_variables es una lista del tipo:
\layout Quotation


\family typewriter 
tipo lista_de_variables;
\layout Standard

y 
\family typewriter 
lista_de_variables
\family default 
 es uno o más nombres de variables separados por comas.
 RECUERDA: La declaración de variables ha de ir al principio de la función,
 antes de la primera sentencia ejecutable.
\layout Standard

Si no has entendido algo en los tres ejemplos vistos, no te preocupes, pues
 todo lo que hay ellos se va a estudiar en profundidad en lecciones posteriores.
 Con estos ejemplos lo que se ha pretendido es empezar a hacer programas
 completos en C desde un primer momento, intentando ofrecer una visión global
 de éste.
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 1-1
\series default 
.
 Escribe un programa que imprima tu nombre y apellidos.
\layout Itemize


\series bold 
Ejercicio 1-2
\series default 
.
 Haz un programa que convierta tu edad de años a días.
 Por el momento, no tengas en cuenta las fracciones de años y los años bisiestos.
\layout Chapter

Tipos, Operadores y Expresiones
\layout Standard

En esta lección vamos a hacer un estudio completo sobre lo tipos, operadores
 y expresiones del lenguaje C.
 Además profundizaremos un poco más en el estudio de la función printf a
 medida que vaya siendo necesario.
 A modo de introducción vamos a dar unas definiciones muy breves que serán
 ampliadas a lo largo de toda la lección:
\layout Itemize

Las variables y constantes son los objetos básicos que se manipulan en un
 programa.
\layout Itemize

Las declaraciones indican las variables que se van a utilizar y establecen
 su tipo y, quizá, su valor inicial.
\layout Itemize

Los operadores especifican lo que se va a hacer con ellas.
\layout Itemize

Las expresiones combinan variables y constantes para producir nuevos valores.
\layout Section

Datos 
\layout Standard

Los programas funcionan con datos.
 Los datos son los números y los caracteres que contienen la información
 a utilizar.
\layout Standard

Una primera división de los datos la podemos hacer en constantes y variables.
 Las constantes son datos con valores fijos que no pueden ser alterados
 por el programa.
 Las variables son datos cuyo valor se puede cambiar a lo largo del programa.
\layout Standard

Una segunda división de los datos la podemos hacer según los tipos de que
 sean.
\layout Standard

Existen cinco tipos de datos básicos en C:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 4 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 0 "" ""
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Tipo
\newline 
Descripción
\newline 
Longitud en bytes
\newline 
Rango
\series default 

\newline 

\family typewriter 
char
\family default 

\newline 
carácter
\newline 
1
\newline 
0 a 255
\newline 

\family typewriter 
int
\family default 

\newline 
entero
\newline 
2
\newline 
-32768 a 32767
\newline 

\family typewriter 
float
\family default 

\newline 
coma flotante
\newline 
4
\newline 
aproxim.
 6 dígitos de precisión
\newline 

\family typewriter 
double
\family default 

\newline 
coma flotante de doble precisión
\newline 
8
\newline 
aproxim.
 12 dígitos de precisión
\newline 

\family typewriter 
void
\family default 

\newline 
sin valor
\newline 
0
\newline 
sin valor
\layout Standard


\emph on 
NOTA IMPORTANTE
\emph default 
: La longitud en bytes, y por consiguiente, también el rango, de la tabla
 anterior, dependen de cada tipo de procesador y de cada compilador de C.
 No obstante, la información reseñada en la tabla es correcta para la mayoría
 de los ordenadores.
\layout Subsection

Tipo Carácter 
\layout Standard

En C, los caracteres se definen con apóstrofos.
 
\layout Itemize

Ejemplos válidos de constantes tipo carácter: 
\family typewriter 
'T'
\family default 
, 
\family typewriter 
'l'
\family default 
, 
\family typewriter 
'1'
\family default 
.
\layout Itemize

Ejemplos inválidos de constantes tipo carácter: 
\family typewriter 
'TT'
\family default 
, 
\family typewriter 
l
\family default 
, 
\family typewriter 
1
\family default 
.
\layout Standard


\family typewriter 
'TT'
\family default 
 es incorrecto porque hay dos caracteres entre los apóstrofos; 
\family typewriter 
l
\family default 
 es incorrecto porque el compilador lo interpreta como una variable; el
 
\family typewriter 
1
\family default 
 lo interpreta el compilador como un número y no como un carácter.
 El valor de una constante carácter es el valor numérico del carácter en
 el conjunto de caracteres del sistema.
 Por ejemplo, en el conjunto ASCII, el carácter cero, o 
\family typewriter 
'0'
\family default 
, es 48, y en EBCDIC 
\family typewriter 
'0'
\family default 
 es 240, ambos muy diferentes del valor numérico 0.
 A lo largo de este tutor se utilizará el código ASCII y no el EBCDIC a
 fin de utilizar ejemplos concretos.
 Ejemplos de asignación de este tipo de datos:
\layout Quotation


\family typewriter 
char ch1, ch2; /* declaración de las variables ch1 y ch2 */
\layout Quotation


\family typewriter 
ch1 = 'A'; /* a la variable ch1 se le asigna el valor ascii de 'A': 65 */
\layout Quotation


\family typewriter 
ch2 = 65; /*a la variable ch2 se le asigna el código ASCII 65 que es 'A'*/
\layout Standard

Las dos asignaciones anteriores son equivalentes pero es preferible la primera
 asignación porque es más portátil.
 A 
\family typewriter 
ch1
\family default 
 se le asigna en cualquier ordenador el carácter 
\family typewriter 
'A'
\family default 
.
 Sin embargo, a la variable 
\family typewriter 
ch2
\family default 
, en sistemas basados en código ASCII se le asigna el carácter 
\family typewriter 
'A'
\family default 
 (el código ASCII de 65 es 
\family typewriter 
'A'
\family default 
), y en sistemas basados en código EBCDIC se le asigna un carácter distinto
 a 
\family typewriter 
'A'
\family default 
.
 Todas las variables en C han de ser declaradas antes de poder ser usadas.
 La forma general de declaración es la siguiente:
\layout Quotation


\family typewriter 
tipo lista_variables;
\layout Standard

Aquí, tipo debe ser un tipo de datos válido de C y 
\family typewriter 
lista_variables
\family default 
 puede consistir en uno o más nombres de identificadores separados por comas.
 Las declaraciones deben estar antes de la primera sentencia ejecutable.
 Ejemplos de declaraciones:
\layout Quotation


\family typewriter 
int i, j, k;
\layout Quotation


\family typewriter 
char caracter;
\layout Standard

Los identificadores en C son los nombres usados para referenciar las variables,
 las funciones y otros objetos definidos por el usuario.
 Los nombres de los identificadores están compuestos por letras, dígitos
 y el carácter de subrayado (
\family typewriter 
_
\family default 
).
 El número de caracteres significativos de los identificadores depende del
 compilador.
 El primer carácter de un identificador ha de ser letra o el carácter de
 subrayado.
 En Turbo C, el número de caracteres significativos por defecto es 32.
 Ciertos caracteres no imprimibles se representan como constantes de carácter
 mediante secuencias de escape.
 En la siguiente tabla se muestran las secuencias de escape del ANSI C:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
14 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Código
\newline 
Significado
\series default 

\newline 

\family typewriter 

\backslash 
b
\family default 

\newline 
retroceso
\newline 

\family typewriter 

\backslash 
f
\family default 

\newline 
salto de página
\newline 

\family typewriter 

\backslash 
n
\family default 

\newline 
nueva línea
\newline 

\family typewriter 

\backslash 
r
\family default 

\newline 
retorno de carro
\newline 

\family typewriter 

\backslash 
t
\family default 

\newline 
tabulación horizontal
\newline 

\family typewriter 

\backslash 
"
\family default 

\newline 
comillas (")
\newline 

\family typewriter 

\backslash 
'
\family default 

\newline 
apóstrofo (')
\newline 

\family typewriter 

\backslash 
0
\family default 

\newline 
carácter nulo
\newline 

\backslash 

\backslash 

\newline 
barra invertida (
\backslash 
)
\newline 

\family typewriter 

\backslash 
v
\family default 

\newline 
tabulación vertical
\newline 

\family typewriter 

\backslash 
a
\family default 

\newline 
alerta (bell, campanilla)
\newline 

\family typewriter 

\backslash 
ddd
\family default 

\newline 
constante octal (ddd son tres dígitos como máximo)
\newline 

\family typewriter 

\backslash 
xddd
\family default 

\newline 
constante hexadecimal (ddd son tres dígitos como máximo)
\layout Standard

Hay otros caracteres no imprimibles que no tienen correspondencia en la
 tabla anterior.
 Estos caracteres se pueden utilizar mediante los códigos 
\backslash 
ddd, 
\backslash 
xddd o simplemente usando el número del código ASCII.
 Ejemplo de asignaciones equivalentes:
\layout Quotation


\family typewriter 
char ch1, ch2, ch3, ch4; /*declaración de cuatro variables tipo carácter*/
\layout Quotation


\family typewriter 
ch1 = '
\backslash 
n';
\protected_separator 

\protected_separator 
 /* el carácter '
\backslash 
n' es el número 13 en ASCII */
\layout Quotation


\family typewriter 
ch2 = 13;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* 13 decimal <=> 12 octal <=> A hexadecimal */
\layout Quotation


\family typewriter 
ch3 = '
\backslash 
12'; /* también sería válido: ch3 = '
\backslash 
012'; */
\layout Quotation


\family typewriter 
ch4 = '
\backslash 
xA';
\protected_separator 
 /* también sería válido: ch4 = '
\backslash 
xa'; */
\layout Standard

La notación preferida es la primera.
 Aunque para los caracteres no imprimibles que no tienen correspondencia
 en la tabla anterior, la única solución es una una de las tres últimas
 asignaciones del ejemplo.
\layout Subsection

Tipo Entero
\layout Standard

Es un número sin parte fraccionaria.
 Las constantes enteras se pueden escribir de uno de los tres modos siguientes:
\layout Itemize

En decimal: escribiendo el número sin empezar por 0 (a excepción de que
 sea el propio 0).
 Ejemplos: 1, 0, -2.
\layout Itemize

En hexadecimal: empezando el número por 0x.
 Ejemplos: 0xE, 0x1d, 0x8.
\layout Itemize

En octal: empezando el número por 0.
 Ejemplos: 02, 010.
\layout Subsection

Tipos Float y Double
\layout Standard

Las constantes de este tipo tienen parte real y parte fraccionaria.
 El tipo 
\family typewriter 
double
\family default 
 tiene doble precisión que el tipo 
\family typewriter 
float
\family default 
.
 Por lo demás, los dos tipos son iguales.
 La sintaxis correcta de las constantes de estos dos tipos es:
\layout Quotation


\family typewriter 
[signo] [dígitos] [.] [dígitos] [exponente [signo] dígitos]
\layout Standard

donde
\layout Quotation

signo es + o -;
\layout Quotation


\family typewriter 
dígitos
\family default 
 es una secuencia de dígitos;
\layout Quotation


\family typewriter 
.

\family default 
 es el punto decimal;
\layout Quotation


\family typewriter 
exponente
\family default 
 es E o e.
\layout Standard

Los elementos que están entre 
\family typewriter 
[]
\family default 
 son opcionales, pero el número no puede empezar por e o E, ya que el compilador
 lo interpretaría en este caso como un identificador y no como un número.
 Algunos ejemplos de constantes de este tipo: 1.0e9, -3E-8, -10.1.
\layout Subsection

Tipo Void
\layout Standard

Significa sin valor, sin tipo.
 Uno de los usos de 
\family typewriter 
void
\family default 
 se puede observar al comparar estos dos programas:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
#include <stdio.h>
\newline 
#include <stdio.h>
\newline 
main ()
\newline 
void main (void)
\newline 
{
\newline 
{
\newline 

\protected_separator 
 printf ("Versión 1.");
\newline 

\protected_separator 
 printf ("Versión 1.");
\newline 

\protected_separator 
 getchar ();
\protected_separator 

\newline 

\protected_separator 
 getchar ();
\newline 
}
\newline 
}
\layout Standard

Al poner 
\family typewriter 
void
\family default 
 entre los paréntesis de la definición de una función, se define a ésta
 como función que no tiene argumentos.
 No confundir con llamada a función, en cuyo caso no se puede utilizar el
 
\family typewriter 
void
\family default 
.
 Del mismo modo, al poner 
\family typewriter 
void
\family default 
 antes del nombre de la función en la definición de ésta, se está declarando
 como función que no devuelve nada.
 La segunda versión es preferible y es la que se utilizará a lo largo de
 todo el tutor.
 Programa ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int i = 1;
\layout Quotation


\family typewriter 

\protected_separator 
 char c = 'c';
\layout Quotation


\family typewriter 

\protected_separator 
 float f = 1.0;
\layout Quotation


\family typewriter 

\protected_separator 
 double d = 1e-1;
\layout Quotation


\family typewriter 

\protected_separator 
 printf("
\protected_separator 
 i = %d
\backslash 
n
\protected_separator 
 c = %c
\backslash 
n
\protected_separator 
 f = %f
\backslash 
n
\protected_separator 
 d = %lf
\backslash 
n", i, c, f, d);
\layout Quotation


\family typewriter 

\protected_separator 
 getchar ()
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa es:
\layout Quotation


\family typewriter 
i = 1
\layout Quotation


\family typewriter 
c = c
\layout Quotation


\family typewriter 
f = 1.000000
\layout Quotation


\family typewriter 
d = 0.100000
\layout Standard

Como se puede observar en el programa, se puede asignar un valor a una variable
 en el momento de la declaración.
 En la lección 1 ya se dijo que 
\family typewriter 
%d
\family default 
 indica a la función 
\family typewriter 
printf
\family default 
 el lugar en que se ha de escribir una variable de tipo entera.
 Los códigos 
\family typewriter 
%c
\family default 
, 
\family typewriter 
%f
\family default 
 y 
\family typewriter 
%lf
\family default 
 indican a la función 
\family typewriter 
printf
\family default 
 el lugar en la cadena de caracteres en la que se han de escribir variables
 de tipo 
\family typewriter 
char
\family default 
, 
\family typewriter 
float
\family default 
 y 
\family typewriter 
double
\family default 
 respectivamente.
\layout Section

Modificadores
\layout Standard

A excepción del tipo 
\family typewriter 
void
\family default 
, los tipos de datos básicos pueden tener varios modificadores precediéndolos.
 Hay modificadores de tipo y de acceso.
 
\layout Subsection

Modificadores de Tipo
\layout Standard

Un modificador de tipo se usa para alterar el significado del tipo base
 para que se ajuste más precisamente a las necesidades de cada momento.
 Modificadores de tipo:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 3 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Modificador
\newline 
Descripción
\newline 
Tipos a los se les puede aplicar el modificador
\series default 

\newline 

\family typewriter 
signed
\family default 

\newline 
con signo
\newline 

\family typewriter 
int
\family default 
, 
\family typewriter 
char
\family default 

\newline 

\family typewriter 
unsigned
\family default 

\newline 
sin signo
\newline 

\family typewriter 
int
\family default 
, 
\family typewriter 
char
\family default 

\newline 

\family typewriter 
long
\family default 

\newline 
largo
\newline 

\family typewriter 
int
\family default 
, 
\family typewriter 
char
\family default 
, 
\family typewriter 
double
\family default 

\newline 

\family typewriter 
short
\family default 

\newline 
corto
\newline 

\family typewriter 
int
\family default 
, 
\family typewriter 
char
\layout Standard

El uso de 
\family typewriter 
signed
\family default 
 con enteros es redundante aunque esté permitido, ya que la declaración
 implícita de entero asume un número con signo.
 El estándar ANSI elimina el 
\family typewriter 
long float
\family default 
 por ser equivalente al 
\family typewriter 
double
\family default 
.
 Sin embargo, como se puede observar en el último ejemplo visto, para escribir
 un 
\family typewriter 
double
\family default 
 con la función 
\family typewriter 
printf
\family default 
 es necesario utilizar el código de formato de 
\family typewriter 
printf
\family default 
: 
\family typewriter 
%lf
\family default 
; que significa: 
\family typewriter 
long float
\family default 
.
 Se puede utilizar un modificador de tipo sin tipo; en este caso, el tipo
 se asume que es 
\family typewriter 
int
\family default 
.
 La longitud (y por tanto, también el rango) de los tipos dependen del sitema
 que utilicemos; no obstante, la siguiente tabla es válida para la mayoría
 de sistemas:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
16 3 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
0 1 0 0
2 1 0 "" ""
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Tipo
\newline 
Longitud en bytes
\newline 
Rango
\series default 

\newline 

\family typewriter 
char
\family default 

\newline 
1
\newline 
Caracteres ASCII
\newline 

\family typewriter 
unsigned char
\family default 

\newline 
1
\newline 
0 a 255
\newline 

\family typewriter 
signed char
\family default 

\newline 
1
\newline 
-128 a 127
\newline 

\family typewriter 
int
\family default 

\newline 
2
\newline 
-32768 a 32767
\newline 

\family typewriter 
unsigned int
\family default 

\newline 
2
\newline 
0 a 65535
\newline 

\family typewriter 
signed int
\family default 

\newline 
2
\newline 
Igual que int
\newline 

\family typewriter 
short int
\family default 

\newline 
1
\newline 
-128 a 127
\newline 

\family typewriter 
unsigned short int
\family default 

\newline 
1
\newline 
0 a 255
\newline 

\family typewriter 
signed short int
\family default 

\newline 
1
\newline 
Igual que short int
\newline 

\family typewriter 
long int
\family default 

\newline 
4
\newline 
-2147483648 a 2147483649
\newline 

\family typewriter 
signed long int
\family default 

\newline 
4
\newline 
-2147483648 a 2147483649
\newline 

\family typewriter 
unsigned long int
\family default 

\newline 
4
\newline 
0 a 4294967296
\newline 

\family typewriter 
float
\family default 

\newline 
4
\newline 
Aproximadamente 6 dígitos de precisión
\newline 

\family typewriter 
double
\family default 

\newline 
8
\newline 
Aproximadamente 12 dígitos de precisión
\newline 

\family typewriter 
long double
\family default 

\newline 
16
\newline 
Aproximadamente 24 dígitos de precisión
\layout Subsection

Modificadores de Acceso
\layout Standard

Acabamos de hablar de los modificadores de tipos y hemos dicho que modifican
 el tipo básico.
 También hay otra clase que son los modificadores de acceso.
 Como su propio nombre indica, estos modificadores modifican el acceso a
 los tipos.
 Estos modificadores son:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
3 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Modificador
\newline 
Descripción
\series default 

\newline 

\family typewriter 
const
\family default 

\newline 
constante
\newline 

\family typewriter 
volatile
\family default 

\newline 
volátil
\layout Standard

Las variables de tipo 
\family typewriter 
const
\family default 
 son aquéllas a las que se les asigna un valor inicial y este valor no puede
 ser cambiado a lo largo del programa.
 Se utilizan para declarar constantes.
 Ejemplo de declaración de una constante:
\layout Quotation


\family typewriter 
const unsigned int hola;
\layout Standard

Las variables de tipo 
\family typewriter 
volatile
\family default 
 previenen al compilador que dicha variable puede ser cambiada por medios
 no explícitamente especificados en el programa.
 Obsérvese las siguientes setencias C:
\layout Quotation


\family typewriter 
int v;
\layout Quotation


\family typewriter 
v = 1;
\layout Quotation


\family typewriter 
v = 2;
\layout Standard

En estos casos, los compiladores suelen optimizar el código y la primera
 sentencia de asignación se desecha y no se genera código para ella ya que
 es redundante.
 Si se hubiese declarado la variable 
\family typewriter 
v
\family default 
 como 
\family typewriter 
volatile
\family default 
:
\layout Quotation


\family typewriter 
volatile v;
\layout Standard

la optimización descrita no se realizaría sobre la variable v, generándose
 código para las dos asignaciones.
\layout Standard

En C existen tipos derivados.
 Los tipos derivados son aquéllos, que como su propio nombre indica, derivan
 de los tipos básicos.
 A continuación vamos a hablar de un tipo derivado muy común en C: las cadenas
 de caracteres.
\layout Section

Cadenas de Caracteres
\layout Standard

Una cadena de caracteres (también conocido por el nombre de string) es una
 secuencia de caracteres encerrados entre comillas.
 Ejemplos de cadenas:
\layout Quotation


\family typewriter 
"El amor es como la luna: cuando no crece es que mengua."
\layout Quotation


\family typewriter 
"abc"
\layout Quotation


\family typewriter 
"a"
\layout Quotation


\family typewriter 
"
\backslash 
n a 
\backslash 
n b 
\backslash 
n c 
\backslash 
n"
\layout Standard

Las comillas no forman parte de la secuencia.
 Sirven para especificar el comienzo y final de ésta, al igual que los apóstrofo
s marcaban los caracteres individuales.
 Las cadenas son tratadas por el C como un array de caracteres.
 Un array (conocido también con el nombre de vector) es una secuencia de
 datos que se encuentran almacenados en memoria de una forma consecutiva.
 Un array de caracteres es una secuencia de caracteres.
 El array:
\layout Quotation


\family typewriter 
"abc"
\layout Standard

se almacenaría en memoria como:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset Figure size 110 29
file 1.eps
flags 9

\end_inset 


\layout Standard

El carácter 
\family typewriter 
'
\backslash 
0'
\family default 
 se llama carácter nulo, y es utilizado por el C para marcar el final de
 la cadena en memoria.
 El carácter nulo (
\family typewriter 
'
\backslash 
0'
\family default 
) no es la cifra 0 (cuyo código ASCII es 48), sino un carácter no imprimible,
 cuyo código ASCII es 0.
 Ejemplo:
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 char ch1, ch2, ch3, ch4;
\layout Quotation


\family typewriter 

\protected_separator 
 ch1 = '
\backslash 
0'; /* en memoria, ch1 tiene el valor 0 que es el valor ASCII
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 correspondiente al carácter '
\backslash 
0' */
\layout Quotation


\family typewriter 

\protected_separator 
 ch2 = 0;
\protected_separator 

\protected_separator 

\protected_separator 
 /* en memoria, ch2 tiene el valor 0 */
\layout Quotation


\family typewriter 

\protected_separator 
 ch3 = '0';
\protected_separator 
 /* en memoria, ch3 tiene el valor 48 que es el valor ASCII
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 correspondiente al carácter '0' */
\layout Quotation


\family typewriter 

\protected_separator 
 ch4 = 48;
\protected_separator 

\protected_separator 
 /* en memoria, ch4 tiene el valor 48 */
\layout Quotation


\family typewriter 
}
\layout Standard

Notad que en este programa no se ha puesto: 
\family typewriter 
#include <stdio.h>
\family default 
.
 Esto se debe a que nuestro programa no utiliza ninguna información contenida
 en dicha librería.
 En las asignaciones anteriores, a 
\family typewriter 
ch1
\family default 
 y 
\family typewriter 
ch2
\family default 
 se les asigna el carácter nulo, pero a las variables 
\family typewriter 
ch3
\family default 
 y 
\family typewriter 
ch4
\family default 
 se le asigna el carácter cero.
 Teniendo en cuenta el carácter nulo en la cadena 
\family typewriter 
"abc"
\family default 
, esta cadena es un array de tamaño 4 (tres caracteres más el carácter nulo).
 Obsérvese el siguiente programa.
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf ("
\backslash 
nInvertir en conocimientos produce siempre los mejores "
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "intereses.
\backslash 
n(%s)", "Benjamín Franklin");
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa en pantalla es la siguiente:
\layout Quotation


\family typewriter 
Invertir en conocimientos produce siempre los mejores intereses.
\layout Quotation


\family typewriter 
(Benjamín Franklin)
\layout Standard

En este ejemplo podemos observar la aparición de dos cosas nuevas: la división
 de una cadena de caracteres en varias líneas y el código de formato 
\family typewriter 
%s
\family default 
.
 El código 
\family typewriter 
%s
\family default 
 le indica a la función 
\family typewriter 
printf
\family default 
 que escriba una cadena en su lugar.
 Una cadena de caracteres se puede escribir en varias líneas de fichero
 cerrando las comillas al final de la línea y volviéndolas a abrir en la
 línea siguiente.
 Haciéndolo de este modo, el compilador lo interpreta como una sola cadena
 de caracteres escrita en varias líneas.
 En C, los finales de instrucciones no se detectan con los finales de línea
 sino con puntos y comas al final de cada instrucción.
 La sentencia:
\layout Quotation


\family typewriter 
printf("
\backslash 
nInvertir en conocimientos produce siempre los mejores "
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "intereses.
\backslash 
n(%s)", "Benjamín Franklin");
\layout Standard

también se puede escribir, por ejemplo, del siguiente modo:
\layout Quotation


\family typewriter 
printf (
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "
\backslash 
nInvertir "
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "en conocimientos produce "
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "siempre los mejores"
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 " intereses."
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "
\backslash 
n(%s)",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "Benjamín "
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "Franklin"
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 );
\layout Standard

Yo, personalmente, ¡no sé porqué!, prefiero la primera versión a la segunda.
 Conviene hacer la observación que 
\family typewriter 
'x'
\family default 
 es distinto de 
\family typewriter 
"x"
\family default 
.
 
\family typewriter 
'x'
\family default 
 es una constante carácter.
 
\family typewriter 
"x"
\family default 
 es una cadena de caracteres.
 
\family typewriter 
'x'
\family default 
 pertenece a un tipo básico (
\family typewriter 
char
\family default 
).
 
\family typewriter 
"x"
\family default 
 es de un tipo derivado (array compuesto de elementos del tipo básico 
\family typewriter 
char
\family default 
).
 
\family typewriter 
"x"
\family default 
, en realidad, contiene dos caracteres, a saber, 
\family typewriter 
'x'
\family default 
 y 
\family typewriter 
'
\backslash 
0'
\family default 
.
 El estudio de los array se estudiará en profundidad en lecciones posteriores;
 pero para comprender un poco mejor el concepto de array de caracteres,
 vamos a hablar un poco más de ellos.
 Una variable array se declara:
\layout Quotation


\family typewriter 
tipo_de_cada_elemento variable_array [numero_de_elementos_del_array];
\layout Standard

y a cada elemento del array se accede:
\layout Quotation


\family typewriter 
variable_array [numero_de_elemento];
\layout Standard

Es muy importante tener siempre en mente que al primer elemento de un array
 se accede mediante:
\layout Quotation


\family typewriter 
variable_array [0];
\layout Standard

y al segundo elemento:
\layout Quotation


\family typewriter 
variable_array [1];
\layout Standard

y así sucesivamente para el acceso al resto de los elementos del array.
 Programa ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x[2]; /* se reserva memoria para dos elementos de tipo int */
\layout Quotation


\family typewriter 

\protected_separator 
 x[0] = 10;
\layout Quotation


\family typewriter 

\protected_separator 
 x[1] = 11;
\layout Quotation


\family typewriter 

\protected_separator 
 /*el elemento x[2] no existe, mejor dicho, no se ha reservado memoria*/
 
\layout Quotation


\family typewriter 

\protected_separator 
 printf("
\backslash 
nx[0] = %d
\backslash 
nx[1] = %d
\backslash 
n", x[0], x[1]);
\layout Quotation


\family typewriter 
}
\layout Standard

Si en el programa anterior se hubiese hecho:
\layout Quotation


\family typewriter 
x [2] = 3;
\layout Standard

el compilador probablemente compilará sin problemas y no nos informará de
 ningún error.
 PERO AL EJECUTAR EL PROGRAMA, EL VALOR 3 SE ESCRIBIRA EN UNA POSICION DE
 MEMORIA NO ASIGNADA; ESTO PUEDE PRODUCIR RESULTADOS INESPERADOS; pensad
 que el valor 3 se podría escribir sobre el código del sistema operativo
 o cualquier otro programa que esté en memoria en ese momento.
 Al hacer la declaración
\layout Quotation


\family typewriter 
int x [2];
\layout Standard

estamos reservando memoria para 
\family typewriter 
x[0]
\family default 
 y 
\family typewriter 
x[1]
\family default 
, dicho de otro modo, 
\family typewriter 
int x[2]
\family default 
 reserva memoria para dos elementos.
 Repitimos: hemos hablado de los arrays lo mínimo para poder entender los
 arrays de caracteres; más adelante, en otra lección, se va hablar a fondo
 sobre los arrays.
\layout Section

Operadores 
\layout Standard

Un operador es un símbolo que realiza una determinada operación sobre sus
 operandos.
 Un operando es el dato que va a ser manipulado por el operador.
 Los operadores en C se pueden dividir en cuatro grupos:
\layout Enumerate

Operadores aritméticos.
\layout Enumerate

Operadores relacionales y lógicos.
\layout Enumerate

Operadores a nivel de bits.
\layout Enumerate

Operadores especiales.
\layout Standard

Definimos también las expresiones que contienen variables y constantes para
 producir nuevos valores.
\layout Subsection

Operadores Aritméticos
\layout Standard

Los operadores aritméticos realizan operaciones aritméticas.
 Son los siguientes:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
8 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Operador
\newline 
Acción
\series default 

\newline 

\family typewriter 
-
\family default 

\newline 
Resta, también menos monario
\newline 

\family typewriter 
+
\family default 

\newline 
Suma, también suma monaria
\newline 

\family typewriter 
*
\family default 

\newline 
Multiplicación
\newline 

\family typewriter 
/
\family default 

\newline 
División
\newline 

\family typewriter 
%
\family default 

\newline 
División en módulo
\newline 

\family typewriter 
--
\family default 

\newline 
Decremento
\newline 

\family typewriter 
++
\family default 

\newline 
Incremento
\layout Standard

Los operadores de incremento y decremento solo se pueden aplicar a variables,
 no constantes.
 El de incremento añade 1 a su operando y el de decremento resta 1.
 En otras palabras,
\layout Quotation


\family typewriter 
++x; o x++; es lo mismo que x = x + 1;
\layout Standard

y
\layout Quotation


\family typewriter 
--x; o x--; es lo mismo que x = x - 1;
\layout Standard

Los operadores de incremento y decremento pueden preceder o seguir al operando.
 Si el operador precede al operando, C lleva a cabo la operación antes de
 utilizar el valor del operando.
 Si el operador sigue al operando, C utilizará su valor antes de incrementarlo
 o decrementarlo.
 Esto se ve muy bien en los dos ejemplos siguientes:
\layout Quotation


\family typewriter 
int x, y;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int x, y;
\layout Quotation


\family typewriter 
x = 2;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 x = 2;
\layout Quotation


\family typewriter 
y = ++x;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 y = x++;
\layout Quotation


\family typewriter 
/* ahora x tiene el valor 3
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* ahora x tiene el valor 3
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 e y tiene el valor 3 */
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 e y tiene el valor 2 */
\layout Standard

La precedencia de los operadores aritméticos es la siguiente:
\layout Quotation


\family typewriter 
MAYOR
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ++
\protected_separator 
 --
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 + (más monario)
\protected_separator 
 - (menos monario)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 *
\protected_separator 
 /
\protected_separator 
 %
\layout Quotation


\family typewriter 
MENOR
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\protected_separator 
 -
\layout Standard

Los operadores del mismo nivel de precedencia son evaluados por el compilador
 de izquierda a derecha.
 Se puede alterar el orden de evaluación utilizando paréntesis.
 Ejemplo:
\layout Quotation


\family typewriter 
void main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x1, x2, x3, x4, x5, x6;
\layout Quotation


\family typewriter 

\protected_separator 
 /* Asignaciones
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */ /* Orden de asignaciones
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x1 = 2 + 3 * 4;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x1 = 14;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x2 = (2 + 3) * 4;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x2 = 20;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x3 = -4 - (-1);
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x3 = -3;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x4 = 10 / 2 % 3;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x4 = 2;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x5 = ++x3 - x4;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x3 = -2; x5 = -4;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x6 = x3++ - x4;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x6 = -4; x3 = -1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x1 = -x1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x1 = -14;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x2 = (x1 + x2) / x3;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x2 = -6;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x3 = ((x1++) + (x2++)) - x3;
\protected_separator 

\protected_separator 
 /* x3 = -19; x1 = -13; x2 = -5;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x4 = -(-(-x3));
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x4 = 19;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x5 = (x6 * x6 + x6 / x6);
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x5 = 17;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x6 = (x1++) + (++x2) - (++x6); /* x2 = -4; x6 = -3; x6 = -14; x1 = -12;
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x1++;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x1 = -11;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 --x2;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x2 = -5;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Subsection

Operadores Relacionales y Lógicos
\layout Standard

La palabra relacional se refiere a la relación entre unos valores y otros.
 La palabra lógico se refiere a las formas en que esas relaciones pueden
 conectarse entre sí.
 Los vamos a ver juntos porque ambos operadores se basan en la idea de cierto
 (true en inglés) y falso (false en inglés).
 En C, cualquier valor distinto de cero es cierto, y el valor 0 es falso.
 Las expresiones que son ciertas toman el valor de 1 y las que son falsas
 toman el valor de 0.
 Los operadores son:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
8 4 0 0 -1 -1 -1 -1
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
8 0 0 "" ""
2 0 0 "" ""
8 0 0 "" ""
8 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

Operadores relacionales
\newline 

\newline 
Operadores lógicos
\newline 

\newline 
Operador
\newline 
Acción
\newline 
Operador
\newline 
Acción
\newline 

\family typewriter 
>
\family default 

\newline 
Mayor que
\newline 

\family typewriter 
&&
\family default 

\newline 
Y
\newline 

\family typewriter 
>=
\family default 

\newline 
Mayor o igual que
\newline 

\family typewriter 
||
\family default 

\newline 
O
\newline 

\family typewriter 
<
\family default 

\newline 
Menor que
\newline 

\family typewriter 
!
\family default 

\newline 
NO
\newline 

\family typewriter 
<=
\family default 

\newline 
Menor o igual que
\newline 

\newline 

\newline 

\family typewriter 
==
\family default 

\newline 
Igual
\newline 

\newline 

\newline 

\family typewriter 
!=
\family default 

\newline 
No igual
\newline 

\newline 

\layout Standard

Tabla de verdad para los operadores lógicos:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 4 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
p q
\newline 
p && q
\newline 
p || q
\newline 
!p
\newline 
0 0
\newline 
0
\newline 
0
\newline 
1
\newline 
0 1
\newline 
0
\newline 
1
\newline 
1
\newline 
1 0
\newline 
1
\newline 
1
\newline 
0
\newline 
1 1
\newline 
0
\newline 
1
\newline 
0
\layout Standard

Precedencia de estos operadores:
\layout Quotation


\family typewriter 
MAYOR
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 !
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 >
\protected_separator 
 >=
\protected_separator 
 <
\protected_separator 
 <=
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ==
\protected_separator 
 !=
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 &&
\layout Quotation


\family typewriter 
MENOR
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ||
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x1, x2, x3, x4, x5, x6;
\layout Quotation


\family typewriter 

\protected_separator 
 /* Asignaciones
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */ /* Orden de asignaciones */
\layout Quotation


\family typewriter 

\protected_separator 
 x1 = 10 < 12;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x1 = 1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x2 = 10 > 12;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x2 = 0;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x3 = -1 && 5;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x3 = 1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x4 = 0 || x3;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x4 = 1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x5 = x1 >= x2 <= x3;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x5 = 1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x6 = x1 == x2 || x3 != x4; /* x6 = 0;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x1 = !x1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x1 = 0;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x2 = ! (!x1 || x3 <= x3);
\protected_separator 
 /* x2 = 0;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x3 = 1 && 0;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x3 = 0;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x4 = 1 || 0;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x4 = 1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x5 = !(-10);
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x5 = 0;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x6 = !!x4;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* x6 = 1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Standard

Una particularidad interesante del C es que la evaluación de una expresión
 se termina en cuanto se sabe el resultado de dicha expresión.
 Veámoslo con un ejemplo:
\layout Quotation


\family typewriter 
0 && x
\layout Quotation


\family typewriter 
1 || x
\layout Standard

En las dos expresiones anteriores NO se evalúa 
\family typewriter 
x
\family default 
 puesto que es superfluo: en la primera expresión al ser uno de los dos
 operandos 0, el otro no hace falta mirarlo; con la segunda expresión podemos
 decir lo mismo.
 Como los operadores 
\family typewriter 
&&
\family default 
 y 
\family typewriter 
||
\family default 
 se evalúan de izquiera a derecha, podemos asegurar que es el segundo operando
 (el que contiene la 
\family typewriter 
x
\family default 
) el que no se valúa.
 Si la expresión fuera: 
\family typewriter 
x && 0
\family default 
, se valuaría la 
\family typewriter 
x
\family default 
, y si ésta es cierta se evaluaría el 0, y si la 
\family typewriter 
x
\family default 
 fuera falsa, no se evaluaría el 0.
\layout Subsection

Operadores a Nivel de Bits
\layout Standard

Estos operandos realizan operaciones sobre los bits de un byte o una palabra
 (dos bytes).
 Sólo se pueden utilizar con los tipos char e int.
 Estos operadores son:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
7 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Operador
\newline 
Acción
\series default 

\newline 

\family typewriter 
&
\family default 

\newline 
Y
\newline 

\family typewriter 
|
\family default 

\newline 
O
\newline 

\family typewriter 
^
\family default 

\newline 
O exclusiva (XOR)
\newline 

\family typewriter 
~
\family default 

\newline 
Complemento a uno (NOT)
\newline 

\family typewriter 
>>
\family default 

\newline 
Desplazamiento a la derecha
\newline 

\family typewriter 
<<
\family default 

\newline 
Desplazamiento a la izquierda
\layout Standard

Las tablas de verdad de los operadores 
\family typewriter 
&
\family default 
, 
\family typewriter 
|
\family default 
 e 
\family typewriter 
^
\family default 
 son las mismas que las tablas de verdad de los operadores 
\family typewriter 
&&
\family default 
, 
\family typewriter 
||
\family default 
 y 
\family typewriter 
!
\family default 
 respectivamente; pero los operadores a nivel de bits trabajan bit a bit.
 La tabla de verdad para el XOR es:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

p q
\newline 
p ^ q
\newline 
0 0
\newline 
0
\newline 
1 0
\newline 
1
\newline 
1 1
\newline 
0
\newline 
0 1
\newline 
1
\layout Standard

Signifiquemos que los operadores relacionales y lógicos siempre producen
 un resultado que es 0 ó 1, mientras que las operaciones entre bits producen
 cualquier valor arbitrario de acuerdo con la operación específica.
 En otras palabras, las operaciones a nivel de bits pueden dar valores distintos
 de 0 ó 1, pero los operadores lógicos siempre dan 0 ó 1.
 Ejemplo:
\layout Quotation


\family typewriter 
char x, y, z1, z2;
\layout Quotation


\family typewriter 
x = 2; y = 3; z1 = 2 && 3; z2 = 2 & 3; /* z1 = 1; z2 = 2 */
\layout Standard

¿Por qué 
\family typewriter 
(2 && 3)
\family default 
 es 1 y 
\family typewriter 
(2 & 3)
\family default 
 es 2?
\layout Itemize


\family typewriter 
2&&3
\family default 
: el compilador evalúa la expresión 
\family typewriter 
1 && 1
\family default 
 que es 1.
\layout Itemize


\family typewriter 
2&3
\family default 
: el compilador evalúa 
\family typewriter 
00000010 & 00000011
\family default 
 que es 
\family typewriter 
00000010
\family default 
 (2 en decimal)
\layout Standard

Sintaxis para los operadores de desplazamiento:
\layout Itemize

expresión 
\family typewriter 
>>
\family default 
 número de bits a desplazar a la derecha
\protected_separator 
 
\layout Itemize

expresión 
\family typewriter 
<<
\family default 
 número de bits a desplazar a la izquierda
\layout Standard

Dos observaciones sobre los operadores de desplazamiento:
\layout Enumerate

Un desplazamiento no es una rotación.
 O sea, los bits que salen por un extremo no se introducen por el otro.
\layout Enumerate

Normalmente, a medida que se desplaza los bits hacia un extremo se va rellenando
 con ceros por el extremo opuesto.
 PERO NO EN TODOS LOS ORDENADORES ES ASI.
 Si queremos introducir ceros y que el programa sea portátil lo tenemos
 que hacer explícitamente con una operación and.
\layout Standard

Tabla de precedencia:
\layout Quotation


\family typewriter 
MAYOR
\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 <<
\protected_separator 
 >>
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 &
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ^
\layout Quotation


\family typewriter 
MENOR
\protected_separator 

\protected_separator 
 |
\layout Standard

Ejemplos:
\layout Quotation


\family typewriter 
void main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 char x, y;
\layout Quotation


\family typewriter 

\protected_separator 
 /* Asignaciones
\protected_separator 

\protected_separator 
 x en bits
\protected_separator 

\protected_separator 
 y en bits
\protected_separator 

\protected_separator 
 valor de x
\protected_separator 

\protected_separator 
 valor de y
\layout Quotation


\family typewriter 

\protected_separator 
 /* ------------
\protected_separator 

\protected_separator 
 ---------
\protected_separator 

\protected_separator 
 ---------
\protected_separator 

\protected_separator 
 ----------
\protected_separator 

\protected_separator 
 ---------- */
\layout Quotation


\family typewriter 

\protected_separator 
 x = 2; y = 3;
\protected_separator 
 /* 0000 0010
\protected_separator 

\protected_separator 
 0000 0011
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 2
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 3
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 y = y << 1;
\protected_separator 

\protected_separator 

\protected_separator 
 /* 0000 0010
\protected_separator 

\protected_separator 
 0000 0110
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 2
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 6
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 y = x | 9;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* 0000 0010
\protected_separator 

\protected_separator 
 0000 1011
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 2
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 11
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 y = y << 3;
\protected_separator 

\protected_separator 

\protected_separator 
 /* 0000 0010
\protected_separator 

\protected_separator 
 0101 1000
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 2
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 88
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x = x;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* 1111 1101
\protected_separator 

\protected_separator 
 0101 1000
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 -3
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 88
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x = 4 ^ 5 & 6; /* 0000 0000
\protected_separator 

\protected_separator 
 0101 1000
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 0
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 88
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Subsection

Operadores Especiales
\layout Standard

Bajo este apartado se recogen una serie de operadores no agrupables en ninguno
 de los grupos anteriores.
 Estos operadores son los siguientes:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ?
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 & *
\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 sizeof
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ,
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 .
 ->
\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 () [] 
\layout Standard

Veamos cada uno de estos operadores.
\layout Subsubsection

Operador Condicional (?).
\layout Standard

El operador 
\family typewriter 
?
\family default 
 tiene la forma general:
\layout Quotation


\family typewriter 
expresion_1
\protected_separator 
 ?
\protected_separator 
 expresion_2
\protected_separator 
 :
\protected_separator 
 expresion_3
\layout Standard

donde 
\family typewriter 
expresion_1
\family default 
, 
\family typewriter 
expresion_2
\family default 
 y 
\family typewriter 
expresion_3
\family default 
 son expresiones C.
 El operador 
\family typewriter 
?
\family default 
 actúa de la siguiente forma: Evalúa 
\family typewriter 
expresion_1
\family default 
.
 Si es cierta, evalúa 
\family typewriter 
expresion_2
\family default 
 y toma ese valor para la expresión.
 Si 
\family typewriter 
expresion_1
\family default 
 es falsa, evalúa 
\family typewriter 
expresion_3
\family default 
 y toma su valor para la expresión.
 Ejemplo:
\layout Quotation


\family typewriter 
int x, y;
\layout Quotation


\family typewriter 
x = 2 < 3 ? 4 : 5; /* a x se le asigna el valor 4: x = 4; */
\layout Quotation


\family typewriter 
y = 2 > 3 ? 4 : 5; /* a y se le asigna el valor 5: x = 5; */
\layout Quotation


\family typewriter 
x = 1 < 2 ? (4 > 3 ? 2 : 3) : 5; /* a x se le asigna el valor 2: x = 2;
\layout Subsubsection

Operadores de Dirección (&) y de Contenido (*).
\layout Standard

Estos dos operadores operan con punteros.
 Los dos son monarios.
 Un puntero es una variable que contiene una dirección de memoria.
 El significado que tiene en este caso el operador 
\family typewriter 
*
\family default 
 no tiene absolutamente nada que ver con el que tiene el operador aritmético
 
\family typewriter 
*
\family default 
.
 En el código fuente no hay confusión entre uno y otro pues el aritmético
 es binario y el de punteros es monario.
 Lo mismo ocurre con el operador 
\family typewriter 
&
\family default 
.
 En este momento no vamos a decir nada más de estos dos operadores y de
 punteros.
 Ya llegará el momento más adelante.
\layout Subsubsection

Operador sizeof.
\layout Standard

El operador sizeof es un operador monario que toma el valor de la longitud,
 en bytes, de una expresión o de un tipo; en este último caso, el tipo ha
 de estar entre paréntesis.
 Ejemplo:
\layout Quotation


\family typewriter 
double d;
\layout Quotation


\family typewriter 
int longitud_en_bytes_de_la_variable_d, longitud_en_bytes_del_tipo_char;
\layout Quotation


\family typewriter 
longitud_en_bytes_de_la_variable_d = sizeof d;
\layout Quotation


\family typewriter 
longitud_en_bytes_del_tipo_char = sizeof (char);
\layout Quotation


\family typewriter 
/* en la mayoría de los sistemas: sizeof d es 8 y sizeof (char) es 1 */
\layout Subsubsection

Operador Coma (,).
\layout Standard

La coma (
\family typewriter 
,
\family default 
) tiene dos usos muy distintos en C: 
\layout Itemize

1.
 Para representar una lista de elementos.
 Ejemplos:
\layout Quotation


\family typewriter 
int a, b, c;
\layout Quotation


\family typewriter 
printf ("%d%d%d", 1, 2, 3);
\layout Itemize

2.
 Como operador.
 
\layout Standard

Como operador, la coma encadena varias expresiones.
 Estas expresiones son evaluadas de izquierda a derecha y el valor de la
 expresión total es el valor de la expresión más a la derecha.
 Ejemplo:
\layout Quotation


\family typewriter 
int x;
\layout Quotation


\family typewriter 
x = (2, 3, 4); /* a x se le asigna el valor 4: x = 4; */
\layout Subsubsection

Operadores Punto (.) y Flecha (->).
\layout Standard

Estos dos operadores se utilizan con dos tipos compuestos: 
\family typewriter 
struct
\family default 
 (estructura) y 
\family typewriter 
union
\family default 
 (unión).
 El significado, tanto de los tipos compuestos 
\family typewriter 
struct
\family default 
 y 
\family typewriter 
union
\family default 
, como de los operadores 
\family typewriter 
.

\family default 
 y 
\family typewriter 
->
\family default 
, se estudiará en lecciones posteriores.
 Aquí se han nombrado estos dos operadores para saber que existen y para
 hacer una tabla de precedencia con todos los operadores del C un poco más
 adelante, en esta misma lección.
\layout Subsubsection

Operadores Paréntesis 
\family typewriter 
()
\family default 
 Y Corchetes 
\family typewriter 
[]
\family default 
.
\layout Standard

Los paréntesis se pueden considerar como operadores que aumentan la precedencia
 de las operaciones que contienen.
 Ejemplo:
\layout Quotation


\family typewriter 
int x = 1 - 2 * 3;
\protected_separator 

\protected_separator 
 /* a x se le asigna el valor -5: x = -5; */
\layout Quotation


\family typewriter 
int y = (1 - 2) * 3; /* a y se le asigna el valor -3: x = -3; */
\layout Standard

Los paréntesis también se usan, dentro de una expresión, para especificar
 la llamada a una función.
 Ejemplo:
\layout Quotation


\family typewriter 
printf ("La inactividad sólo apetece cuando tenemos demasiado que hacer."
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "
\backslash 
n(Noël Coward)"); getchar ();
\layout Standard

Los corchetes llevan acabo el indexamiento de arrays.
 Ya hemos hablado anteriormente un poco de ellos y se estudiará en detalle
 en otras lecciones.
 Ejemplo:
\layout Quotation


\family typewriter 
float f[3]; /* reserva memoria para tres float: f[0], f[1] y f[2] */
\layout Quotation


\family typewriter 
f[0] = 1.1; f[1] = 2.2; f[2] = 3.3; /* tres asignaciones */
\layout Section

Sentencias de Asignación
\layout Standard

Una sentencia de asignación es una sentencia C en la que se asigna un valor
 a una variable.
 La forma general de la sentencia de asignación es:
\layout Quotation


\family typewriter 
nombre_variable operador_de_asignacion expresion;
\layout Standard

donde 
\family typewriter 
operador_de_asignacion
\family default 
 es uno de los operadores siguientes:
\layout Quotation


\family typewriter 
=, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |=.
\layout Standard

Con el operador 
\family typewriter 
=
\family default 
, el significado de la asignación es dar el valor de la expresión de la
 parte derecha a la variable que se encuentra en la parte izquierda del
 operador 
\family typewriter 
=
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
int a, b, c;
\layout Quotation


\family typewriter 
a = 5;
\layout Quotation


\family typewriter 
b = 4 + a;
\layout Quotation


\family typewriter 
c = (a * b) - 1;
\layout Standard

Una sentencia de asignación es una expresión.
 El valor de esta expresión es el valor que se le asigna a la variable.
 El operador de asignación se evalúa de derecha a izquierda.
 Ejemplo:
\layout Quotation


\family typewriter 
int x, y;
\layout Quotation


\family typewriter 
x = y = 2; /* el 2 se asigna primero a la y y después a la x */
\layout Standard

Hemos dicho que el operador de asignación se evalúa de derecha a izquierda,
 así que primero se hace 
\family typewriter 
y = 2
\family default 
 y el valor de esta expresión es 2, este valor se asigna a 
\family typewriter 
x
\family default 
 y el valor de la expresión total es 2.
 También se podía haber hecho:
\layout Quotation


\family typewriter 
x = (y = 2);
\layout Standard

pero en este caso los paréntesis son innecesarios porque no cambian la precedenc
ia.
 El resto de operadores de asignación se exponen en la siguiente tabla,
 donde 
\family typewriter 
x
\family default 
 e 
\family typewriter 
y
\family default 
 son dos variables.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
11 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Sentencia de asignación
\newline 
Sentencia de asignación equivalente
\series default 

\newline 

\family typewriter 
x *= y;
\newline 
x = x * y;
\newline 
x /= y;
\newline 
x = x / y;
\newline 
x %= y;
\newline 
x = x % y;
\newline 
x += y;
\newline 
x = x + y;
\newline 
x -= y;
\newline 
x = x - y;
\newline 
x <<= y;
\newline 
x = x << y;
\newline 
x >>= y;
\newline 
x = x >> y;
\newline 
x &= y;
\newline 
x = x & y;
\newline 
x ^= y;
\newline 
x = x ^ y;
\newline 
x |= y;
\newline 
x = x | y;
\layout Section

Inicializaciones de variables
\layout Standard

La forma de inicialización es:
\layout Quotation


\family typewriter 
tipo nombre_variable = expresión;
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
float f = 3.0;
\layout Standard

También se pueden inicializar varias variables separadas por comas en una
 misma sentencia.
 Ejemplos:
\layout Quotation


\family typewriter 
int x = 1; /* declaración e inicialización de x */
\layout Quotation


\family typewriter 
char ch1 = 'a', ch2 = 'b'; /* declaración e inicialización de ch1 y ch2
 */
\layout Quotation


\family typewriter 
float f1 = 2.2, f2 = 3e3; /* declaración e inicialización de f1 y f2 */
\layout Quotation


\family typewriter 
int x, y = 3, z;/* declaración de x, y, z pero inicialización sólo de y
 */
\layout Quotation


\family typewriter 
double d = 1.1 - 2.2; /* declaración e inicialización de d */
\layout Quotation


\family typewriter 
int a = 1 + 2, b = 4, c; /* declaración de a, b, c pero esta última no se
 inicializa */
\layout Section

Conversión de Tipos
\layout Standard

La conversión de tipos se refiere a la situación en la que se mezclan variables
 de un tipo con variables de otro tipo.
 Cuando esto ocurre en una sentencia de asignación, la regla de conversión
 de tipo es muy fácil: el valor de lado derecho de la expresión se convierte
 al del lado izquierdo.
 Ejemplo:
\layout Quotation


\family typewriter 
int x = 2.3; /* 2.3 se convierte a 2 */
\layout Quotation


\family typewriter 
char ch = 500; /* los bits más significativos de 500 se pierden */
\layout Standard

El tipo que resulta de aplicar un operador con dos operandos de tipos diferentes
, es el tipo de mayor tamaño (mayor longitud en bytes).
 Ejemplo:
\layout Quotation


\family typewriter 
2 + 3.3; /* el valor de esta expresión es 5.3, o sea,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 un valor de tipo float */
\layout Standard

Es posible forzar a que una expresión sea de un tipo determinado utilizando
 una construcción denominada molde.
 La forma general de un molde es: 
\family typewriter 
(tipo) expresión
\layout Standard

El molde se puede considerar como un operador monario teniendo la misma
 precedencia que el resto de los operadores monarios.
 Ejemplos:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
4 3 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Expresión
\newline 
Valor de la expresión
\newline 
Tipo de la expresión
\series default 

\newline 

\family typewriter 
3 / 2
\family default 

\newline 

\family typewriter 
int
\family default 

\newline 

\family typewriter 
1
\family default 

\newline 

\family typewriter 
3.0 / 2
\family default 

\newline 

\family typewriter 
float
\family default 

\newline 

\family typewriter 
1.5
\family default 

\newline 

\family typewriter 
(float) 3 / 2
\family default 

\newline 

\family typewriter 
float
\family default 

\newline 

\family typewriter 
1.5
\layout Standard

En la expresión 
\family typewriter 
(float) 3 / 2
\family default 
, al ser 
\family typewriter 
(float)
\family default 
 un operador monario, tiene más prioridad que el operador binario 
\family typewriter 
/
\family default 
.
 Una constante decimal, octal o hexadecimal seguida por la letra 
\family typewriter 
l
\family default 
 o 
\family typewriter 
L
\family default 
, se interpreta como una constante 
\family typewriter 
long
\family default 
.
 Las siguientes expresiones son equivalentes:
\layout Quotation


\family typewriter 
4l
\layout Quotation


\family typewriter 
4L
\layout Quotation


\family typewriter 
(long) 4
\layout Standard

También se puede utilizar el tipo void en los moldes.
 Por ejemplo:
\layout Quotation


\family typewriter 
(2 + 3); /* expresión entera */
\layout Quotation


\family typewriter 
(void) (2 + 3); /* expresión sin ningún tipo */
\layout Section

Precedencia de Operadores
\layout Quotation


\family typewriter 
Mayor
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ()
\protected_separator 
 []
\protected_separator 
 ->
\protected_separator 
 .
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 !
\protected_separator 

\protected_separator 

\protected_separator 
 ++
\protected_separator 
 --
\protected_separator 
 -
\protected_separator 
 (tipo)
\protected_separator 
 *
\protected_separator 
 &
\protected_separator 
 sizeof
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 *
\protected_separator 
 /
\protected_separator 
 %
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 <<
\protected_separator 
 >>
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 <
\protected_separator 
 <=
\protected_separator 
 >
\protected_separator 
 >=
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ==
\protected_separator 
 !=
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 &
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ^
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 &&
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ||
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ?
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 =
\protected_separator 
 +=
\protected_separator 
 -=
\protected_separator 
 *=
\protected_separator 
 /=
\protected_separator 
 %=
\protected_separator 
 &=
\protected_separator 
 ^=
\protected_separator 
 |=
\protected_separator 
 <<=
\protected_separator 
 >>=
\layout Quotation


\family typewriter 
Menor
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ,
\layout Standard

Los operadores unarios, el condicional y los de asignación asocian de derecha
 a izquierda; los demás asocian de izquierda a derecha.
 Veamos los pasos que se siguen al evaluar algunas expresiones:
\layout Quotation

Expresión 1: 
\family typewriter 
10 < 5 && 8 >= 3
\layout Quotation

Paso 1:
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\family typewriter 
0
\protected_separator 

\protected_separator 
 && 8 >= 3
\layout Quotation

Paso 2:
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\family typewriter 
0
\protected_separator 

\protected_separator 
 &&
\protected_separator 

\protected_separator 
 1
\layout Quotation

Paso 3:
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\family typewriter 
0
\newline 

\layout Quotation

Expresión 2: 
\family typewriter 
x = (y = 3), y
\layout Quotation

Paso 1: a la variable 
\family typewriter 
y
\family default 
 se le asigna el valor 3
\layout Quotation

Paso 2: el valor de la expresión coma es 
\family typewriter 
y
\family default 
, o sea, 3
\layout Quotation

Paso 3: a la variable 
\family typewriter 
x
\family default 
 se le asigna el valor 3
\layout Quotation

Paso 4: el valor de toda la expresión es 
\family typewriter 
x
\family default 
, es decir, 3
\newline 

\layout Quotation

Expresión 3: 
\family typewriter 
1 + 2 < 3 || 4 + 5 > 2
\layout Quotation

Paso 1:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 3
\protected_separator 

\protected_separator 
 < 3 || 4 + 5 > 2
\layout Quotation

Paso 2:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 0
\protected_separator 

\protected_separator 
 || 4 + 5 > 2
\layout Quotation

Paso 3:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 0
\protected_separator 

\protected_separator 
 ||
\protected_separator 

\protected_separator 
 9
\protected_separator 

\protected_separator 
 > 2
\layout Quotation

Paso 4:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 0
\protected_separator 

\protected_separator 
 ||
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 1
\layout Quotation

Paso 5:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 1
\newline 

\layout Quotation

Expresión 4: 
\family typewriter 
(-3 < !2) >> (-3)
\layout Quotation

Paso 1:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (-3 < 0 ) >> (-3)
\layout Quotation

Paso 2:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 1
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 >> (-3)
\layout Quotation

Paso 3:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 1
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 >>
\protected_separator 

\protected_separator 
 2
\layout Quotation

Paso 4:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 0
\newline 

\layout Quotation

Expresión 5: 
\family typewriter 
2 < 3 < ((4 - 1) / !3)
\layout Quotation

Paso 1:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 1
\protected_separator 

\protected_separator 
 < ((4 - 1) / !3)
\layout Quotation

Paso 2:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 1
\protected_separator 

\protected_separator 
 < (
\protected_separator 

\protected_separator 
 3
\protected_separator 

\protected_separator 

\protected_separator 
 / !3)
\layout Quotation

Paso 3:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 1
\protected_separator 

\protected_separator 
 < (
\protected_separator 

\protected_separator 
 3
\protected_separator 

\protected_separator 

\protected_separator 
 / 0 )
\layout Quotation

Paso 4: Error: División por cero.
\newline 

\layout Quotation

Expresión 6: 
\family typewriter 
(double) (int) (!-3 / (float) 2)
\layout Quotation

Paso 1:
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\family typewriter 
(double) (int) ( 0
\protected_separator 
 / (float) 2)
\layout Quotation

Paso 2:
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\family typewriter 
(double) (int) ( 0
\protected_separator 
 / 2.0)
\layout Quotation

Paso 3:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (double) (int)
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 0.0
\layout Quotation

Paso 4:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (double)
\protected_separator 

\protected_separator 
 0
\layout Quotation

Paso 5:
\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 0.0
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 2-1
\series default 
.
 
\protected_separator 
 Dada la función
\layout Quotation


\family typewriter 
y = 1/4 x
\layout Quote

diseñar un programa que para el valor de abcisa 4.4 dé el correspondiente
 a la ordenada.
 Nota: La expresión anterior en C se escribe:
\layout Quotation


\family typewriter 
y = (1.0 / 4) * x;
\layout Quotation

o
\layout Quotation


\family typewriter 
y = (1 / 4.0) * x;
\layout Quote

ya que si se hace 1 / 4, el resultado es 0 en vez de 0.25.
 Otras dos soluciones son:
\layout Quotation


\family typewriter 
y = ((float) 1 / 4) * x;
\layout Quotation

o
\layout Quotation


\family typewriter 
y = (1 / (float) 4) * x;
\layout Itemize


\series bold 
Ejercicio 2-2
\series default 
.
 La Tierra no es una esfera; está ligeramente aplanada y por lo tanto es
 más bien un esferoide aplanado.
 La fórmula para su volumen es:
\layout Quotation

v = 4/3 _ a a b
\layout Quote

Calcúlese el volumen de la Tierra para los siguientes datos:
\layout Quotation

a = 12454,5 Km;
\layout Quotation

b = 12711.1 Km.
\layout Itemize


\series bold 
Ejercicio 2-3
\series default 
.
 La relación entre temperaturas Celsius y Farenhait está dada por:
\layout Quotation

C = 5/9 (F-32)
\layout Quote

Diseñar un programa que convierta 20 grados F en C.
\layout Chapter

Sentencias de Control de Programa
\layout Standard

En esta lección vamos a estudiar todas las sentencias que posee el C para
 cambiar el flujo del programa.
 Entre ellas están las sentencias condicionales 
\family typewriter 
if
\family default 
 y 
\family typewriter 
switch
\family default 
; las sentencias iterativas 
\family typewriter 
while
\family default 
, 
\family typewriter 
for
\family default 
 y 
\family typewriter 
do
\family default 
; y las sentencias 
\family typewriter 
break
\family default 
, 
\family typewriter 
continue
\family default 
, 
\family typewriter 
goto
\family default 
 y 
\family typewriter 
return
\family default 
; La sentencia 
\family typewriter 
return
\family default 
 sólo se menciona aquí, pues se estudiará en la lección dedicada al estudio
 de las funciones de C.
\layout Description


\size largest 
SENTENCIAS
\protected_separator 
C 
\layout Standard

Una sentencia en C puede ser:
\layout Itemize

Una sentencia simple.
\layout Quotation


\family typewriter 
printf ("Filosofía de Murphy: Sonría; mañana puede ser peor.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 y = 4 + 1; /* sentencia de asignación */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 ; /* sentencia que no hace nada */
\layout Itemize

Una sentencia compuesta.
\layout Quotation

{ /* 
\family typewriter 
sentencia compuesta formada por dos sentencias simples */
\layout Quotation


\family typewriter 

\protected_separator 
 --x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf ("Ley de Murphy: Si algo puede salir mal, saldrá mal.");
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
{ } /* sentencia que no hace nada */
\layout Standard

Las sentencias 
\family typewriter 
if
\family default 
, 
\family typewriter 
switch
\family default 
, 
\family typewriter 
while
\family default 
, 
\family typewriter 
for
\family default 
 y 
\family typewriter 
do
\family default 
 son 
\emph on 
sentencias simples
\emph default 
.
 Todas estas sentencias las veremos en esta lección.
 Una 
\emph on 
sentencia compuesta
\emph default 
 está formada por ninguna, una o varias sentencias simples delimitadas entre
 llaves.
 A las sentencias compuestas también reciben el nombre de bloques.Las sentencias
 simples son todas aquéllas que no son compuestas.
\layout Section

Sentencias de Control 
\layout Standard

La mayoría de las sentencias de control de cualquier lenguaje están basadas
 en condiciones.
 Una condición es una expresión cuya resolución da como resultado cierto
 (true) o falso (false).
 Muchos lenguajes de programación incorporan los valores true y false; en
 C cualquier valor distinto de cero es true, y el valor cero es false.
\layout Section

Sentencias Condicionales
\layout Standard

C posee dos sentencias condicionales: 
\family typewriter 
if
\family default 
 y 
\family typewriter 
switch
\family default 
.
 Además, el operador ? es una posible alternativa para 
\family typewriter 
if
\family default 
 en ciertas situaciones.
\layout Subsection

Sentencia if
\layout Description

SINTAXIS 
\layout Quotation


\family typewriter 
if (expresión)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sentencia
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
o
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
if (expresión)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sentencia_1 
\layout Quotation


\family typewriter 
else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sentencia_2 
\layout Description

DESCRIPCION 
\layout Standard

Si expresión es cierta se ejecuta la sentencia correspondiente al 
\family typewriter 
if
\family default 
.
 Si expresión es falsa se ejecuta la sentencia correspondiente al 
\family typewriter 
else
\family default 
 si lo hay.
 En la segunda sintaxis se ejecuta 
\family typewriter 
sentencia_1
\family default 
 o 
\family typewriter 
sentencia_2
\family default 
, pero nunca ambas.
\layout Description

EJEMPLOS 
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 3 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
if (contador < 50)
\newline 
if (x < y)
\newline 
if (ch == '
\backslash 
n')
\newline 

\protected_separator 

\protected_separator 
contador++;
\newline 

\protected_separator 

\protected_separator 
z = x;
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
{
\newline 

\newline 
else
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
numero_de_lineas++;
\newline 

\newline 

\protected_separator 

\protected_separator 
z = y;
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
numero_de_caracteres++;
\newline 

\newline 

\newline 

\protected_separator 

\protected_separator 

\protected_separator 
}
\layout Description

OBSERVACIONES 
\layout Itemize

1.
 Lo siguiente es incorrecto:
\layout Quotation


\family typewriter 
if (expresión)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 { 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 sentecias 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Quotation


\family typewriter 
else 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sentencia 
\layout Quote

puesto que entre el 
\family typewriter 
if
\family default 
 y el 
\family typewriter 
else
\family default 
 sólo puede haber una sentencia y aquí hay dos: 
\family typewriter 
{ }
\family default 
 y 
\family typewriter 
;.
\layout Itemize

2.
 Al ser la sentencia if una sentencia simple, la sentencias 
\family typewriter 
if
\family default 
 se pueden anidar:
\layout Quotation


\family typewriter 
/*a la variable numero_menor se le asigna la
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 variable con menor valor entre x, y, z */
\layout Quotation


\family typewriter 
if (x <= y)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if (x <= z)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 numero_menor = x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 numero_menor = z;
\layout Quotation


\family typewriter 
else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if (y <= z)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 numero_menor = y;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 numero_menor = z;
\layout Itemize

3.
 El 
\family typewriter 
else
\family default 
 siempre está asociado al 
\family typewriter 
if
\family default 
 más cercano.
 Los dos siguientes ejemplos son distintos:
\layout Quotation

/* Ejemplo 1: */
\layout Quotation


\family typewriter 
if(n > 0)
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if (a > b)
\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 z = a;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 z = b;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 
/* Ejemplo 2: */
\layout Quotation


\family typewriter 
if(n > 0)
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 if (a > b)
\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 z = a;
\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 }
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 
else
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 z = b;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Itemize

4.
 Un constructor común en programación es la escala 
\family typewriter 
if-else-if
\family default 
.
 Tiene la forma siguiente:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
9 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
if (expresión_1)
\family default 

\newline 

\family typewriter 
/* Ejemplo: numero_menor
\family default 

\newline 

\family typewriter 

\protected_separator 
sentencia_1
\family default 

\newline 

\family typewriter 
toma el valor de la variable
\family default 

\newline 

\family typewriter 
else if (expresión_2)
\family default 

\newline 

\family typewriter 
menor entre x, y, z */
\family default 

\newline 

\family typewriter 

\protected_separator 
 sentencia_2
\family default 

\newline 

\family typewriter 
if (x <= y && x <= z)
\family default 

\newline 

\family typewriter 
.
\newline 

\protected_separator 
 numero_menor = x;
\newline 
.
\newline 
else if (y <= z && y <= z)
\newline 
.
\newline 

\protected_separator 
 numero_menor = y;
\newline 
else
\family default 

\newline 

\family typewriter 
else
\family default 

\newline 

\family typewriter 

\protected_separator 
 sentencia_n
\family default 

\newline 

\family typewriter 

\protected_separator 
 numero_menor = z;
\layout Standard

Las condiciones se evalúan de arriba hacia abajo.
 Sólo se ejecuta la sentencia correspondiente a la primera expresión que
 sea cierta, si la hay.
 Si ninguna expresión es cierta, se ejecuta el else final si existe, sino
 no se ejecuta ninguna sentencia.
 
\layout Itemize

5.
 El operador 
\family typewriter 
?
\family default 
 se puede utilizar para reemplazar las sentencias 
\family typewriter 
if-else
\family default 
.
 Este operador ternario se ha visto en la lección 2.
 
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
10 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""

/* Ejemplo 1 con if-else */
\newline 
/* Ejemplo 1 con ?: */ 
\newline 
if (x <= y)
\newline 
z = x <= y ? x : y;
\newline 

\protected_separator 
 z = x;
\newline 

\newline 
else
\newline 

\newline 

\protected_separator 
 z = y;
\newline 

\newline 
/* Ejemplo 2 con if-else */
\newline 
/* Ejemplo 2 con ?: */ 
\newline 
if (n == 1)
\newline 
n == 1 ?
\newline 

\protected_separator 
 printf ("Mensaje 1");
\newline 
printf ("Mensaje 1"):
\newline 
 else
\newline 
printf ("Mensaje 2");
\newline 

\protected_separator 
 printf ("Mensaje 2");
\newline 

\layout Subsection

Sentencia switch
\layout Description

FORMA
\protected_separator 
GENERAL
\layout Quotation


\family typewriter 
switch(expresión)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 case expresión_constante_1:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 sentencias_1
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 case expresión_constante_2:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 sentencias_2
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 case expresión_constante_3:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 sentencias_3
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 .
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 .
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 .
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 default:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 sentencias_n
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Description

DESCRIPCION
\layout Standard

En muchas ocasiones es más elegante utilizar la sentencia switch que la
 escala 
\family typewriter 
if-else-if
\family default 
.
 Una expresión constante es una expresión en la que todos los operandos
 son constantes.
 El 
\family typewriter 
switch
\family default 
 evalúa expresión.
 A continuación evalúa cada una de las expresiones constantes hasta que
 encuentra una que coincida con expresión.
 Cuando la encuentra ejecuta las sentencias correspondientes a ese 
\family typewriter 
case
\family default 
.
 Si no hay ninguna expresión 
\family typewriter 
case
\family default 
 que coincida con expresión, se ejecuta las sentencias correspondientes
 al 
\family typewriter 
default
\family default 
.
\layout Description

EJEMPLO
\layout Quotation


\family typewriter 
switch(operando)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 case 1:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 x *= y;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 case 2:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 x /= y;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 case 3:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 x += y;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 case 4:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 x -= y;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 default:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf ("¡ERROR!");
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Description

OBSERVACIONES
\layout Itemize

1.
 La sentencia default es opcional.
 Si fallan todas las comprobaciones de los 
\family typewriter 
case
\family default 
 y no hay 
\family typewriter 
default
\family default 
, no se ejecuta ninguna acción en el 
\family typewriter 
switch
\family default 
.
 Incluso el 
\family typewriter 
default
\family default 
 puede ir en cualquier posición y no obligatoriamente al final.
\layout Itemize

2.
 La sentencia switch se diferencia de la escala 
\family typewriter 
if-else-if
\family default 
 en dos cosas: 
\protected_separator 
 1º) En la sentencia 
\family typewriter 
switch
\family default 
 sólo se puede comprobar la igualdad entre las expresiones constantes y
 expresión.
\protected_separator 
 2º) Las expresiones de los 
\family typewriter 
case
\family default 
 han de ser constantes.
\layout Itemize

3.
 Las sentencias 
\family typewriter 
break
\family default 
 en el 
\family typewriter 
switch
\family default 
 son opcionales.
 El break hace que se produzca una salida inmediata de la instrucción 
\family typewriter 
switch
\family default 
.
 Si no hay una sentencia 
\family typewriter 
break
\family default 
 en un 
\family typewriter 
case
\family default 
, al ejecutarse las sentencias que corresponden a ese 
\family typewriter 
case
\family default 
, también se ejecutarían las sentencias correspondientes al siguiente 
\family typewriter 
case
\family default 
 y así sucesivamente hasta encontrar un 
\family typewriter 
break
\family default 
 o llegar al final del 
\family typewriter 
switch
\family default 
.
 La sentencia 
\family typewriter 
break
\family default 
 puede ir en cualquier sitio, no forzosamente al final de las sentencias
 de los 
\family typewriter 
case
\family default 
.
\layout Quotation


\family typewriter 
case 1:
\protected_separator 
 /* Ejemplo de case sin break
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 x++;
\protected_separator 

\protected_separator 
 /* Después de ejecutarse x++, */
\layout Quotation


\family typewriter 
case 2:
\protected_separator 
 /* se ejecuta siempre y++
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 y++;
\layout Quotation


\family typewriter 

\protected_separator 
 break;
\layout Itemize

4.
 Asociado a cada case puede haber ninguna, una o varias sentencias.
\layout Quotation


\family typewriter 
case 1: /* case sin sentencias directas*/
\layout Quotation


\family typewriter 
case 2: /* case con dos sentencias */
\layout Quotation


\family typewriter 

\protected_separator 
 ++x;
\layout Quotation


\family typewriter 

\protected_separator 
 break;
\layout Quotation


\family typewriter 
case 3:
\layout Quotation


\family typewriter 

\protected_separator 
 x++;
\layout Quotation


\family typewriter 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 
 y++;/*esta sentencia nunca se ejecuta*/
\layout Quotation


\family typewriter 
case 4: /* case con tres sentencias */
\layout Quotation


\family typewriter 

\protected_separator 
 x++;
\layout Quotation


\family typewriter 

\protected_separator 
 y++;
\layout Quotation


\family typewriter 

\protected_separator 
 break;
\layout Section

Sentencias Iteractivas
\layout Standard

Los bucles o sentencias iterativas permiten que un conjunto de ins trucciones
 sea ejecutado hasta que se alcance una cierta condición.
 Las sentencias iterativas son: 
\family typewriter 
while
\family default 
, 
\family typewriter 
for
\family default 
 y 
\family typewriter 
do
\family default 
.
\layout Subsection

Sentencia while
\layout Description

SINTAXIS 
\layout Quotation


\family typewriter 
while (expresión)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sentencia
\layout Description

DESCRIPCION 
\layout Standard

Se evalúa expresión.
 Si es cierta, se ejecuta sentencia y se vuelve a evaluar expresión.
 El ciclo continúa hasta que expresión es falsa, momento en que la ejecución
 continúa con lo que está después de sentencia.
\layout Description

EJEMPLOS 
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
10 3 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
/*
\newline 
/*
\newline 
/*
\newline 
el bucle termina
\newline 
imprime los cinco pri-
\newline 
al ; del while no
\newline 
cuando encuentra
\newline 
meros números naturales
\newline 
se llega nunca ya
\newline 
un carácter dis-
\newline 
*/
\newline 
que el bucle no
\newline 
to de blanco en
\newline 
i = 1;
\newline 
nace ninguna itera-
\newline 
vector s
\newline 
while (i <= 5)
\newline 
ción.
\newline 
*/
\newline 

\protected_separator 

\protected_separator 
{
\newline 
*/
\newline 
i = 0;
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
printf ("
\backslash 
ni = %d", i);
\newline 
int condicion = 0;
\newline 
while (s[i] == ' ')
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
 i++;
\newline 
while (condicion)
\newline 

\protected_separator 

\protected_separator 
 i++;
\newline 
}
\newline 

\protected_separator 

\protected_separator 
;
\layout Subsection

Sentencia for
\layout Description

FORMA
\protected_separator 
GENERAL
\layout Quotation


\family typewriter 
for (expresión_1; expresión_2; expresión_3)
\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sentencia
\layout Description

DESCRIPCION
\layout Standard

En la sentencia 
\family typewriter 
for
\family default 
, a 
\family typewriter 
expresión_1
\family default 
 se le llama 
\emph on 
inicialización
\emph default 
, a 
\family typewriter 
expresión_2
\family default 
 se le llama 
\emph on 
condición
\emph default 
, y a 
\family typewriter 
expresión_3
\family default 
 se le llama 
\emph on 
incremento
\emph default 
.
 La forma general descrita de la sentencia for es equivalente a:
\layout Quotation


\family typewriter 
expresión_1 
\layout Quotation


\family typewriter 
while(expresión_2)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 La forma de actuar del bucle for se observa
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 sentencia
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 claramente en su equivalente del while.
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 expresión_3;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 }
\layout Standard

Las tres expresiones de la sentencia 
\family typewriter 
for
\family default 
 son opcionales, aunque los puntos y coma siempre deben aparecer.
 Si no aparece 
\family typewriter 
expresión_2
\family default 
 se asume que es 1.
\layout Description

EJEMPLOS
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
9 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
#include <stdio.h>
\newline 
#include <stdio.h>
\newline 
void main (void)
\newline 
void main (void)
\newline 
{
\newline 
{
\newline 

\protected_separator 
 printf ("Lista de los 100 primeros"
\newline 

\protected_separator 
int i, s;
\newline 

\protected_separator 

\protected_separator 
 "números naturales:
\backslash 
n");
\newline 

\protected_separator 
 for (s = 0, i = 1; i < 100; i++)
\newline 

\protected_separator 
 int x;
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
 s += i;
\newline 

\protected_separator 
 for (x = 1; x <= 100; x++)
\newline 

\protected_separator 
 printf ("La suma de los primeros "
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
 printf ("%d ", x);
\newline 

\protected_separator 

\protected_separator 
 "100 números naturales es %d.",s);
\newline 
}
\newline 
}
\layout Description

Nota: 
\family typewriter 
(s = 0, i = 1)
\family default 
 es una expresión, más concretamente, es una expresión formada por el operador
 coma, cuyo operandos son expresiones de asignación.
 
\layout Description

OBSERVACION
\layout Standard

La instrucción
\layout Quotation


\family typewriter 
for(;;)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sentencia
\layout Standard

es un bucle infinito.
 Sin embargo, aunque en este bucle no nos podamos salir por la condición
 del 
\family typewriter 
for
\family default 
, nos podemos salir por otros medio (por ejemplo, mediante la sentencia
 
\family typewriter 
break
\family default 
, que estudiaremos un poco más adelante en esta misma lección).
\layout Subsection

Sentencia do
\layout Description

SINTAXIS
\layout Quotation


\family typewriter 
do
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sentencia
\layout Quotation


\family typewriter 
while (expresión);
\layout Description

DESCRIPCION
\layout Standard

En la instrucción 
\family typewriter 
do
\family default 
, primero se ejecuta sentencia y a continuación se evalúa expresión.
 En caso de ser cierta, se ejecuta sentencia de nuevo y así sucesivamente.
 La iteración termina cuando la expresión se convierte en falsa.
\layout Description

EJEMPLO
\layout Quotation


\family typewriter 
/* imprime los 50 primeros números naturales */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int i = 1;
\layout Quotation


\family typewriter 

\protected_separator 
 do
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", i++);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 } while(i <= 50);
\layout Quotation


\family typewriter 
}
\layout Description

OBSERVACION
\layout Standard

Las llaves en el ejemplo anterior no son necesarias al tratarse de una sola
 sentencia; pero en el caso de la sentencia 
\family typewriter 
do
\family default 
, yo recomiendo que siempre pongáis las llaves para hacer el programa más
 legible (para el lector, no para el compilador).
 Obsérvese la misma instrucción sin llaves:
\layout Quotation


\family typewriter 
i = 1;
\layout Quotation


\family typewriter 
do
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d ", i++);
\layout Quotation


\family typewriter 
while(i <= 50);
\layout Standard

Cuando un lector ve la línea del 
\family typewriter 
while
\family default 
, puede pensar que se trata de la sentencia 
\family typewriter 
while
\family default 
, cuando en realidad es la sentencia 
\family typewriter 
do-while
\family default 
.
 
\layout Subsection

Sentencia break
\layout Description

SINTAXIS 
\layout Quotation


\family typewriter 
break;
\layout Description

DESCRIPCION 
\layout Standard

Esta sentencia provoca la salida inmediata de las sentencias 
\family typewriter 
switch
\family default 
, 
\family typewriter 
while
\family default 
, 
\family typewriter 
for
\family default 
 y 
\family typewriter 
do
\family default 
.
 Por lo tanto, su uso sólo es correcto dentro de un bloque de una estas
 sentencias.
\layout Description

EJEMPLO 
\layout Quotation


\family typewriter 
for(i = 0; i < 10; i++) 
\layout Quotation


\family typewriter 

\protected_separator 
 for(j = 0; j < i; j++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 if(j == 5)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Description

OBSERVACION
\layout Standard

Una sentencia 
\family typewriter 
break
\family default 
 obliga a una salida inmediata del ciclo (o 
\family typewriter 
switch
\family default 
) más interior.
 En el ejemplo anterior, la ejecución de la sentencia 
\family typewriter 
break
\family default 
 provoca una salida del bucle 
\family typewriter 
for
\family default 
 de la variable 
\family typewriter 
j
\family default 
, pero no tiene ningún efecto sobre el bucle for de la variable 
\family typewriter 
i
\family default 
.
\layout Subsection

Sentencia continue
\layout Description

SINTAXIS 
\layout Quotation


\family typewriter 
continue;
\layout Description

DESCRIPCION 
\layout Standard

La sentencia 
\family typewriter 
continue
\family default 
 funciona de una forma algo similar a 
\family typewriter 
break
\family default 
.
 En vez de forzar la terminación, 
\family typewriter 
continue
\family default 
 fuerza una nueva iteración del bucle y salta cualquier código que exista
 entre medias.
\layout Description

EJEMPLO 
\layout Quotation


\family typewriter 
/* este bucle imprime todos los números no negativos del vector vector_de_numero
s*/ 
\layout Quotation


\family typewriter 
for(i = 0; i < 100; i++)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 numero = vector_de_numeros [i];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 if(numero < 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 continue;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", vector_de_numeros [i]);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Description

OBSERVACION 
\layout Standard

En los ciclos 
\family typewriter 
while
\family default 
 y 
\family typewriter 
do-while
\family default 
, una sentencia 
\family typewriter 
continue
\family default 
 da lugar a que el control pase directamente a la evaluación de la condición
 y prosiga el proceso del bucle.
 En el caso de un 
\family typewriter 
for
\family default 
, primero se ejecuta la parte incremento del bucle, a continuación se ejecuta
 la evaluación de condición, y finalmente el bucle prosigue.
\layout Subsection

Sentencia goto
\layout Description

SINTAXIS 
\layout Quotation


\family typewriter 
goto etiqueta;
\layout Description

DESCRIPCION 
\layout Standard

El lenguaje C tiene la fatalmente seductora sentencia 
\family typewriter 
goto
\family default 
.
 La utilización de esta sentencia en un programa es una de las mejores formas
 de hacerlo ilegible y difícilmente modificable.
 La sentencia 
\family typewriter 
goto
\family default 
 provoca un salto a una etiqueta que se encuentra en la misma función.
 Una etiqueta es un identificador válido de C seguido por dos puntos.
\layout Description

EJEMPLO 
\layout Quotation

/* Pr
\family typewriter 
ograma que imprime los 100 primeros números naturales*/
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x = 1;
\layout Quotation


\family typewriter 

\protected_separator 
 bucle: /* etiqueta */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", x++);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 if(x <= 100)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 goto bucle; /* salto a etiqueta */
\layout Quotation


\family typewriter 
}
\layout Description

Consejo: No utilices las sentencias 
\family typewriter 
goto
\family default 
 y 
\family typewriter 
continue
\family default 
 a no ser que sea absolutamente necesario en un programa; lo mismo digo
 para la sentencia 
\family typewriter 
break
\family default 
 siempre que no sea en un 
\family typewriter 
switch
\family default 
 (en este caso es necesario).
 La utilización de estas sentencias disminuye la lectura de un programa,
 además de que no hacen ninguna falta ya que el C es un lenguaje muy rico
 en sentencias, operadores y funciones.
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 3-1
\series default 
.
 Diseña un programa que escriba el siguiente gráfico en pantalla, utilizando
 únicamente dos tipos de sentencias: la sentencia iterativa 
\family typewriter 
for
\family default 
 y la sentencia de escritura: 
\family typewriter 
printf ("*")
\family default 
.
\layout Quotation


\family typewriter 
*
\layout Quotation


\family typewriter 
**
\layout Quotation


\family typewriter 
***
\layout Quotation


\family typewriter 
****
\layout Quotation


\family typewriter 
*****
\layout Quotation


\family typewriter 
******
\layout Quotation


\family typewriter 
*******
\layout Quotation


\family typewriter 
********
\layout Quotation


\family typewriter 
*********
\layout Quotation


\family typewriter 
**********
\layout Quotation


\family typewriter 
*********
\layout Quotation


\family typewriter 
********
\layout Quotation


\family typewriter 
*******
\layout Quotation


\family typewriter 
******
\layout Quotation


\family typewriter 
*****
\layout Quotation


\family typewriter 
****
\layout Quotation


\family typewriter 
***
\layout Quotation


\family typewriter 
**
\layout Quotation


\family typewriter 
*
\layout Itemize


\series bold 
Ejercicio 3-2
\series default 
.
 Hacer un programa que calcule e imprima el factorial de 5.
\layout Itemize


\series bold 
Ejercicio 3-3
\series default 
.
 Hacer un programa que genere la lista de los 100 primeros números pares.Hacedlo
 de tres formas distintas: con bucle 
\family typewriter 
for
\family default 
, 
\family typewriter 
while
\family default 
 y 
\family typewriter 
do
\family default 
.
\layout Itemize


\series bold 
Ejercicio 3-4
\series default 
.
 Haz un programa que escriba todos los números menores que 50 y no divisibles
 por 3.
\layout Chapter

Algunas Funciones del Lenguaje C
\layout Standard

El objetivo de esta lección es describir algunas funciones del C.
 Las funciones que detallaremos son:
\layout Itemize

Funciones de control de programa: 
\family typewriter 
exit()
\family default 
,
\family typewriter 
 _exit()
\family default 
, 
\family typewriter 
abort()
\family default 
 y 
\family typewriter 
assert()
\family default 
.
\layout Itemize

Funciones de E/S: 
\family typewriter 
printf()
\family default 
, 
\family typewriter 
scanf()
\family default 
, 
\family typewriter 
putchar()
\family default 
, 
\family typewriter 
getchar()
\family default 
, 
\family typewriter 
puts()
\family default 
 y 
\family typewriter 
gets()
\family default 
.
\layout Itemize

Funciones de consola: 
\family typewriter 
cprintf()
\family default 
, 
\family typewriter 
cscanf()
\family default 
, 
\family typewriter 
putch()
\family default 
, 
\family typewriter 
getch()
\family default 
, 
\family typewriter 
getche()
\family default 
, 
\family typewriter 
ungetch()
\family default 
, 
\family typewriter 
cputs()
\family default 
, 
\family typewriter 
cgets()
\family default 
 y 
\family typewriter 
kbhit()
\family default 
.
\layout Itemize

Funciones de consola de Turbo C: 
\family typewriter 
lowvideo()
\family default 
, 
\family typewriter 
highvideo()
\family default 
 y 
\family typewriter 
normvideo()
\family default 
.
\layout Itemize

También veremos la constante 
\family typewriter 
EOF
\family default 
.
\layout Standard

En Turbo C se verá además dos constantes definidas en 
\family typewriter 
stdlib.h
\family default 
 (
\family typewriter 
EXIT_SUCCESS
\family default 
 y 
\family typewriter 
EXIT_FAILURE
\family default 
) y una variable definida en 
\family typewriter 
conio.h
\family default 
 (
\family typewriter 
directvideo
\family default 
).
\layout Section

Funciones de Control de Programa
\layout Standard

En la lección anterior hemos visto las sentencias de control de programa:
 
\family typewriter 
if
\family default 
, 
\family typewriter 
switch
\family default 
, 
\family typewriter 
while
\family default 
, 
\family typewriter 
for
\family default 
, 
\family typewriter 
do
\family default 
, 
\family typewriter 
break
\family default 
, 
\family typewriter 
continue
\family default 
 y 
\family typewriter 
goto
\family default 
.
 A continuación vamos a ver las funciones que pueden afectar al flujo de
 control de un programa; estas funciones son: 
\family typewriter 
exit
\family default 
, 
\family typewriter 
abort
\family default 
 y 
\family typewriter 
assert
\family default 
.
\layout Subsection

Funciones exit
\family typewriter 
()
\family default 
 y _exit
\family typewriter 
()
\layout Standard

La función 
\family typewriter 
exit
\family default 
, que se encuentra declarada en la biblioteca estándar (
\family typewriter 
stdlib.h
\family default 
), da lugar a la terminación automática de un programa.
 Al describir una función siempre hay que especificar los argumentos y el
 valor que devuelve si los hay.
 La función 
\family typewriter 
exit
\family default 
 no devuelve nada pero necesita un argumento que es recogido por el programa
 llamador (normalmente el sistema operativo).
 Por convención, el valor 0 indica terminación normal; valores distintos
 de 0 indican situaciones anormales.
 En los programas que manipulan ficheros, éstos han de abrirse, manipularse
 y cerrarse.
 Los datos de estos ficheros no se manipulan directamente sino a través
 de unos almacenamientos temporales llamados buffers.
 La función 
\family typewriter 
exit
\family default 
 cierra todos los ficheros abiertos, vacía todos los buffers de salida,
 y a continuación llama a la función 
\family typewriter 
_exit
\family default 
 para terminar el programa.
 La función 
\family typewriter 
_exit
\family default 
 provoca la terminación inmediata del programa sin realizar el vaciado de
 los buffers ni cerrar los ficheros; si se desea se la puede llamar directamente
; el argumento de 
\family typewriter 
_exit
\family default 
 es el mismo que para 
\family typewriter 
exit
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h> /* para poder utilizar la función exit () */
\layout Quotation


\family typewriter 
/* las funciones tarjeta_color () y jugar () han de estar definidas en algún
 lado */
\layout Quotation


\family typewriter 
void main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 /* tarjeta_color () es una función que devuelve 0 (falso) si la tarjeta
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 del sistema no es color y 1 (cierto) si lo es */
\layout Quotation


\family typewriter 

\protected_separator 
 if(tarjeta_color ())
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 exit (1); /* terminación anormal: la tarjeta no es color */
\layout Quotation


\family typewriter 

\protected_separator 
 jugar(); /* llamada a función para jugar */
\layout Quotation


\family typewriter 

\protected_separator 
 exit(0); /* terminación normal, esta sentencia no es necesaria */
\layout Quotation


\family typewriter 
}
\layout Standard

En la librería 
\family typewriter 
stdlib
\family default 
 de Turbo C hay dos constantes definidas para pasárselas como argumento
 a la función 
\family typewriter 
exit
\family default 
: 
\family typewriter 
EXIT_SUCCESS
\family default 
 que tiene valor 0 y 
\family typewriter 
EXIT_FAILURE
\family default 
 que tiene valor 1.
 De este modo, si nos olvidamos si el argumento 0 de 
\family typewriter 
exit
\family default 
 significa terminación normal o anormal, utilizamos estas constantes que
 es más difícil que se nos olvide.
 Además hace el programa más legible.
 Ejemplos de utilización:
\layout Quotation


\family typewriter 
exit (EXIT_SUCCESS);
\layout Quotation


\family typewriter 
exit (EXIT_FAILURE);
\layout Subsection

Función abort
\family typewriter 
()
\family default 
 
\layout Standard

La función 
\family typewriter 
abort
\family default 
 aborta el programa.
 Es muy similar a la función 
\family typewriter 
exit
\family default 
.
 Se diferencia de la función 
\family typewriter 
exit
\family default 
 en dos aspectos fundamentales:
\layout Enumerate

La función abort no acepta ningún argumento.
 Se le llama de la siguiente forma: 
\family typewriter 
abort();
\layout Enumerate

La función 
\family typewriter 
abort
\family default 
 no vacía los buffers ni cierra ningún fichero.
 El principal uso de 
\family typewriter 
abort
\family default 
 es prevenir una fuga del programa cerrando los ficheros abiertos.
\layout Standard

Esta función se encuentra declarada en el fichero: 
\family typewriter 
stdlib.h
\family default 
.
 Cuando se desee terminar un programa inmediatamente es preferible intentar
 utilizar la función 
\family typewriter 
exit
\family default 
.
\layout Subsection

Función assert
\family typewriter 
()
\layout Standard

La función 
\family typewriter 
assert
\family default 
 no devuelve nada y acepta una expresión como argumento.
 Esta función testea la expresión dada; si la expresión es cierta no hace
 nada; si la expresión es falsa escribe un mensaje en la salida de error
 estándar y termina la ejecución del programa.
 El mensaje presentado es dependiente del compilador pero suele tener la
 siguiente forma:
\layout Quotation

Expresión fallida: <expresión>, archivo <archivo>, línea <num_línea>
\layout Standard

La función 
\family typewriter 
assert
\family default 
 se suele utilizar para verificar que el programa opera correctamente.
 Se encuentra declarada en el fichero: 
\family typewriter 
assert.h
\family default 
.
\layout Standard

En Turbo C, el mensaje presentado por la función 
\family typewriter 
assert
\family default 
 es:
\layout Quotation

Assertion failed: <expresión>, file <fichero>, line <num_línea>
\layout Quotation

Abnormal program termination
\layout Description

Ejemplo:
\layout Quotation


\family typewriter 
#include <assert.h> /* para poder utilizar la función assert() */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x, y;
\layout Quotation


\family typewriter 

\protected_separator 
 x = y = 1;
\layout Quotation


\family typewriter 

\protected_separator 
 assert(x < y); /* la expresión x < y es falsa y el programa termina */
\layout Quotation


\family typewriter 

\protected_separator 
 x++; y++; /* estas dos sentencias nunca se ejecutan */
\layout Quotation


\family typewriter 
}
\layout Section

Funciones de E/S
\layout Standard

Se llaman funciones de entrada/salida (input/output), abreviado funciones
 de E/S (I/O), a aquéllas que transportan datos entre el programa y la entrada
 y salida estándar.
\layout Standard

La entrada estándar normalmente es el teclado y la salida estándar normalmente
 es la consola.
 Mientras no se diga lo contrario, en este tutor se considera la entrada
 estándar como el teclado y la salida estándar como la consola.
\layout Standard

El final de la entrada y salida se suele marcar (en el caso de ficheros
 de texto ocurre siempre) con un carácter especial llamado Fin-De-Fichero
 y se simboliza 
\family typewriter 
EOF
\family default 
 (End-Of-File).
 Hay una constante definida en el fichero 
\family typewriter 
stdio.h
\family default 
 que se llama 
\family typewriter 
EOF
\family default 
 y tiene el valor de -1.
 El carácter de fin de fichero se suele escribir con CONTROL-Z (código ASCII
 26) en el DOS y CONTROL-D en UNIX.
 Algunas funciones del C (por ejemplo, 
\family typewriter 
scanf
\family default 
) devuelven el valor de 
\family typewriter 
EOF
\family default 
 cuando leen el carácter de marca de fin de fichero.
\layout Standard

En las operaciones de E/S, los datos utilizados suelen pasar por buffers.
 Un buffer es una cantidad de memoria utilizada para meter y sacar datos.
 Tras estos preliminares ya estamos en condiciones de ver las principales
 funciones de E/S: 
\family typewriter 
printf
\family default 
, 
\family typewriter 
scanf
\family default 
, 
\family typewriter 
putchar
\family default 
, 
\family typewriter 
getchar
\family default 
, 
\family typewriter 
puts
\family default 
 y 
\family typewriter 
gets
\family default 
.
\layout Subsection

Funciones printf
\family typewriter 
()
\family default 
 y scanf
\family typewriter 
()
\layout Standard

La función 
\family typewriter 
printf
\family default 
 escribe datos formateados en la salida estándar.
 La función 
\family typewriter 
scanf
\family default 
 lee datos formateados de la entrada estándar.
 El término "con formato" se refiere al hecho de que estas funciones pueden
 escribir y leer datos en varios formatos que están bajo su control.
 Ambas funciones están declaradas en el fichero 
\family typewriter 
stdio.h
\family default 
, y tienen la forma general:
\layout Quotation


\family typewriter 
printf("cadena de control", lista de argumentos);
\layout Quotation


\family typewriter 
scanf("cadena de control", lista de argumentos); 
\layout Standard

La cadena de control está formada por caracteres imprimibles y códigos de
 formato.
 Debe haber tantos códigos de formato como argumentos.
 Los códigos u órdenes de formato son las siguientes:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
15 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
0 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Código
\newline 
Formato
\series default 

\newline 

\family typewriter 
%c
\family default 

\newline 
Simple carácter
\newline 

\family typewriter 
%d
\family default 

\newline 
Entero decimal con signo
\newline 

\family typewriter 
%i
\family default 

\newline 
Entero decimal con signo
\newline 

\family typewriter 
%e
\family default 

\newline 
Punto flotante en notación científica: [-]d.ddd e [+/-]ddd
\newline 

\family typewriter 
%f
\family default 

\newline 
Punto flotante en notación no científica: [-]dddd.ddd
\newline 

\family typewriter 
%g
\family default 

\newline 
Usa 
\family typewriter 
%e
\family default 
 o 
\family typewriter 
%f
\family default 
, el que sea más corto en longitud
\newline 

\family typewriter 
%o
\family default 

\newline 
Entero octal sin signo
\newline 

\family typewriter 
%s
\family default 

\newline 
Cadena de caracteres
\newline 

\family typewriter 
%u
\family default 

\newline 
Entero decimal sin signo
\newline 

\family typewriter 
%x
\family default 

\newline 
Entero hexadecimal sin signo
\newline 

\family typewriter 
%%
\family default 

\newline 
Signo de tanto por ciento: 
\family typewriter 
%
\family default 

\newline 

\family typewriter 
%p
\family default 

\newline 
Puntero
\newline 

\family typewriter 
%n
\family default 

\newline 
El argumento asociado debe ser un puntero a entero en el que se
\newline 

\newline 
pone el número de caracteres impresos hasta ese momento
\layout Standard

Las órdenes de formato pueden tener modificadores.
 Estos modificadores van entre el 
\family typewriter 
%
\family default 
 y la letra identificativa del código.
 Si el modificador es un número, especifica la anchura mínima en la que
 se escribe ese argumento.
 Si ese número empieza por 0, los espacios sobrantes (si los hay) de la
 anchura mínima se rellenan con 0.
 Si ese número tiene parte real y parte fraccionaria, indica el número de
 dígitos de la parte real y de la parte fraccionaria a imprimir en el caso
 de imprimir un número, o indica el número mínimo y máximo a imprimir en
 el caso de imprimir una cadena de caracteres.
 Por defecto, la salida se justifica a la derecha en caso de que se especifique
 anchura mínima; si el modificador es un número negativo, la justificación
 se hará a la izquierda.
 Otros dos modificadores son las letras 
\family typewriter 
l
\family default 
 y 
\family typewriter 
h
\family default 
; el primero indica que se va a imprimir un 
\family typewriter 
long
\family default 
, y 
\family typewriter 
h
\family default 
 indica que se va a imprimir un 
\family typewriter 
short
\family default 
.
 En la explicación de los modificadores se ha hablado de imprimir, es decir,
 hemos hablado del 
\family typewriter 
printf
\family default 
.
 Los modificadores de 
\family typewriter 
scanf
\family default 
 son los mismos.
\layout Description

Ejemplos
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
15 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""


\series bold 
Sentencia 
\family typewriter 
printf()
\family default 

\newline 
Salida
\series default 

\newline 

\family typewriter 
(":%f:", 123.456)
\newline 
:123.456001:
\newline 
(":%e:", 123.456)
\newline 
:1.234560e+02:
\newline 
(":%g:", 123.456)
\newline 
:123.456:
\newline 
(":%-2.5f:", 123.456)
\newline 
:123.45600:
\newline 
(":%-5.2f:", 123.456)
\newline 
:123.46:
\newline 
(":%5.5f:", 123.456)
\newline 
:123.45600:
\newline 
(":%10s:", "hola")
\newline 
:
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 hola:
\newline 
(":%-10s:", "hola")
\newline 
:hola
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 :
\newline 
(":%2.3s:", "hola")
\newline 
:hol:
\newline 
(":%x:", 15)
\newline 
:f:
\newline 
(":%o:", 15)
\newline 
:17:
\newline 
(":%05d:", 15)
\newline 
:00015:
\newline 
(":abc:%n", &var_int)
\newline 
:abc:
\family default 

\newline 

\newline 
(además la variable 
\family typewriter 
var_int
\family default 
 toma el valor de 5)
\layout Standard

Las órdenes de formato de Turbo C son un poco más rica que en el ANSI C:
\layout Description


\size largest 
Especificadores
\protected_separator 
de
\protected_separator 
Formato
\layout Quotation


\family typewriter 
% [banderas] [width] [.prec] [F|N|h|l] type
\layout Standard


\series bold 
Especificador de formato "[bandera]"
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
[bandera]
\newline 
Acción
\series default 

\newline 
(ninguna)
\newline 
Justificado a la derecha; rellenos con 0 o blancos a la izq.
\newline 

\family typewriter 
-
\family default 

\newline 
Justificado a la izquierda; rellenos con espacios a la derecha
\newline 

\family typewriter 
+
\family default 

\newline 
Siempre empieza con + o -
\newline 
blanco
\newline 
Imprime signo para valores negativos solamente
\newline 

\family typewriter 
#
\family default 

\newline 
Convierte usando forma alternativa
\layout Standard


\series bold 
Formas alternativas para la bandera #
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
c
\family default 
,
\family typewriter 
s
\family default 
,
\family typewriter 
d
\family default 
,
\family typewriter 
i
\family default 
,
\family typewriter 
u
\family default 

\newline 
(no tiene efecto)
\newline 

\family typewriter 
o
\family default 

\newline 
Los argumentos distintos de 0 empiezan con 0
\newline 

\family typewriter 
x
\family default 
 o 
\family typewriter 
X
\family default 

\newline 
Los argumentos empiezan con 0x o 0X
\newline 

\family typewriter 
e
\family default 
, 
\family typewriter 
E
\family default 
, 
\family typewriter 
f
\family default 

\newline 
Siempre usa punto decimal
\newline 

\family typewriter 
g
\family default 
 o 
\family typewriter 
G
\family default 

\newline 
Igual que e, E, o f pero con ceros al final
\layout Standard


\series bold 
Especificador de formato "[anchura]"
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
4 2 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

[anchura]
\newline 
Acción
\newline 

\family typewriter 
n
\family default 

\newline 
Anchura mínima, rellenos con blanco
\newline 

\family typewriter 
0n
\family default 

\newline 
Anchura mínima, rellenos con 0 a la izquierda
\newline 

\family typewriter 
*
\family default 

\newline 
El próximo argumento de la lista es la anchura
\layout Standard


\series bold 
Especificador de formato "[.prec]"
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

[.prec]
\newline 
Acción
\newline 
(ninguna)
\newline 
Precisión por defecto
\newline 

\family typewriter 
.0
\family default 

\newline 
(
\family typewriter 
d
\family default 
,
\family typewriter 
i
\family default 
,
\family typewriter 
o
\family default 
,
\family typewriter 
u
\family default 
,
\family typewriter 
x
\family default 
)
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
Precisión por defecto
\newline 

\family typewriter 
^
\family default 

\newline 
(
\family typewriter 
e
\family default 
,
\family typewriter 
E
\family default 
,
\family typewriter 
f
\family default 
)
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 Sin punto decimal
\newline 

\family typewriter 
.n
\family default 

\newline 
Al menos n caracteres
\newline 

\family typewriter 
*
\family default 

\newline 
El próximo argumento de la lista es la precisión
\layout Standard


\series bold 
Especificador de formato "[F|N|h|l]"
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
7 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Modificador
\newline 
Cómo es interpretado el argumento
\series default 

\newline 

\family typewriter 
F
\family default 

\newline 
el argumento es puntero 
\family typewriter 
far
\family default 

\newline 

\family typewriter 
N
\family default 

\newline 
el argumento es puntero 
\family typewriter 
near
\family default 

\newline 

\family typewriter 
h
\family default 

\newline 
el argumento es 
\family typewriter 
short int
\family default 

\newline 

\family typewriter 
l
\family default 

\newline 

\family typewriter 
d
\family default 
,
\family typewriter 
i
\family default 
,
\family typewriter 
o
\family default 
,
\family typewriter 
u
\family default 
,
\family typewriter 
x
\family default 
,
\family typewriter 
X
\family default 

\protected_separator 

\protected_separator 

\protected_separator 
 el argumento es long int
\newline 

\family typewriter 
l
\family default 

\newline 

\family typewriter 
e
\family default 
,
\family typewriter 
E
\family default 
,
\family typewriter 
f
\family default 
,
\family typewriter 
g
\family default 
,
\family typewriter 
G
\family default 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 el argumento es double (sólo 
\family typewriter 
scanf
\family default 
)
\newline 

\family typewriter 
L
\family default 

\newline 

\family typewriter 
e
\family default 
,
\family typewriter 
E
\family default 
,
\family typewriter 
f
\family default 
,
\family typewriter 
g
\family default 
,
\family typewriter 
G
\family default 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 el argumento es long double
\layout Standard


\series bold 
Especificador de formato "tipo"
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
17 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Tipo
\newline 
Acción
\series default 

\newline 
d
\newline 
signed
\protected_separator 

\protected_separator 
 decimal int
\newline 
i
\newline 
signed
\protected_separator 

\protected_separator 
 decimal int
\newline 
o
\newline 
unsigned octal
\protected_separator 

\protected_separator 
 int
\newline 
u
\newline 
unsigned decimal int
\newline 
x
\newline 
En printf = unsigned hexadecimal int; en scanf = hexadecimal int
\newline 
X
\newline 
En printf = unsigned hexadecimal int; en scanf = hexadecimal long
\newline 
f
\newline 
Punto flotante [-]dddd.ddd
\newline 
e
\newline 
Punto flotante [-]d.ddd e [+/-]ddd
\newline 
g
\newline 
Formato e o f basado en la precisión
\newline 
E
\newline 
Igual que e excepto E para exponente
\newline 
G
\newline 
Igual que g excepto E para exponente
\newline 
c
\newline 
Carácter simple
\newline 
s
\newline 
Imprime caracteres terminados en '
\backslash 
0' or [.prec]
\newline 
%
\newline 
El carácter %
\newline 
p
\newline 
Puntero: near = YYYY; far = XXXX:YYYY
\newline 
n
\newline 
Almacena número de caracteres escritos en la dirección apuntada por el argumento
 de entrada
\layout Description

Ejemplos
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
8 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Sentencia 
\family typewriter 
printf()
\family default 

\newline 
Salida
\series default 

\newline 

\family typewriter 
("%x", 2)
\newline 
2
\newline 
("%#x", 2)
\newline 
0x2
\newline 
("%#X", 2)
\newline 
0X2
\newline 
("%f", 1.2)
\newline 
1.200000
\newline 
("%g", 1.2)
\newline 
1.2
\newline 
("%#g", 1.2)
\newline 
1.200000
\newline 
("%*.*f", 5, 4, 1.2)
\newline 
1.2000
\layout Standard

Hay una diferencia muy importante entre los argumentos de 
\family typewriter 
printf
\family default 
 y 
\family typewriter 
scanf
\family default 
.
 En 
\family typewriter 
printf
\family default 
 los argumentos son expresiones pero en 
\family typewriter 
scanf
\family default 
 los argumentos han de ser direcciones de memoria (punteros).
 Los punteros se van a estudiar en una lección posterior.
 No obstante, hablaremos en este momento un poco de ellos para saber utilizar
 la función 
\family typewriter 
scanf
\family default 
.
 
\layout Standard

Los punteros hemos dicho que son direcciones de memoria.
 Para obtener la dirección de memoria de una variable es necesario aplicar
 el operador monario 
\family typewriter 
&
\family default 
 (no confundirlo con el operador binario, que es el and entre bits) de la
 siguiente forma:
\layout Quotation


\family typewriter 
& variable
\layout Standard

Hay un tipo de variable un poco especial a este respecto, que son los vectores
 (también llamados arrays), cuyo nombre es un puntero que apunta al primer
 elemento del vector.
 Ahora mismo se pretende que entendamos cómo usar la función 
\family typewriter 
scanf
\family default 
, no los punteros, que es tema de otra lección; por cierto, el tema de los
 punteros es, quizás, una de los más difíciles del C.
 Ejemplo de cómo usar la función 
\family typewriter 
scanf
\family default 
:
\layout Quotation


\family typewriter 
scanf("%d %s %f", &variable_entera, cadena_de_caracteres, &variable_float);
\layout Description

Programa
\protected_separator 
ejemplo
\layout Quotation


\family typewriter 
/* Programa que lee números enteros de teclado hasta que se introduce un
 0.
 El programa no es muy útil pero sí instructivo */
\layout Quotation


\family typewriter 
#include <stdio.h> /* para poder utilizar la función scanf */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x;
\layout Quotation


\family typewriter 

\protected_separator 
 do
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 scanf("%d", &x);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 } while(x != 0);
\layout Quotation


\family typewriter 
}
\layout Standard

Las llamadas a funciones son expresiones y como el resultado de evaluar
 una expresión es un valor (a no ser que el resultado de la expresión sea
 de tipo void), las funciones pueden devolver valores y la llamada a esa
 función toma el valor devuelto por la función.
 Supóngamos que f() es una función que devuelve un entero, entonces, las
 siguientes expresiones son correctas:
\layout Quotation


\family typewriter 
int x, y, z;
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
x = f();
\layout Quotation


\family typewriter 
y = f() * 2;
\layout Quotation


\family typewriter 
f();
\layout Quotation


\family typewriter 
(void) f();
\layout Quotation


\family typewriter 
z = f() + f();
\layout Quotation


\family typewriter 
if (f() < 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("ERROR");
\layout Standard

La función 
\family typewriter 
printf
\family default 
 devuelve un valor entero que contiene el número de caracteres escritos.
 En caso de error, devuelve 
\family typewriter 
EOF
\family default 
.
 La función 
\family typewriter 
scanf
\family default 
 devuelve el número de campos que han sido asignados.
 Si ocurre un error o se detecta el fin de fichero, se devuelve 
\family typewriter 
EOF
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
if(scanf("%u", &variable_unsigned) == EOF)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Error o Fin-De-Fichero al intentar leer un valor unsigned.");
\layout Standard

Profundicemos un poco más en el estudio de la función 
\family typewriter 
scanf
\family default 
.
 En la cadena de control de 
\family typewriter 
scanf
\family default 
 se pueden distinguir tres elementos:
\layout Itemize

Especificadores de formato.
\layout Itemize

Caracteres con espacios en blanco.
\layout Itemize

Caracteres sin espacios en blanco.
\layout Standard

Sobre los especificadores de formato ya hemos hablado.
 Sin embargo, la función 
\family typewriter 
scanf()
\family default 
 tiene otro especial: Un 
\family typewriter 
*
\family default 
 situado después del 
\family typewriter 
%
\family default 
 y antes del código de formato lee los datos del tipo especificado pero
 elimina su asignación.
 Así, dada la entrada
\layout Quotation


\family typewriter 
2 4
\layout Standard

como respuesta a la función
\layout Quotation


\family typewriter 
scanf("%*d%d", &x);
\layout Standard

asigna el valor 4 a la 
\family typewriter 
x
\family default 
 y no el valor 2 que es descartado.
 Un espacio en blanco en la cadena de control da lugar a que 
\family typewriter 
scanf()
\family default 
 salte uno o más espacios en blanco en el flujo de entrada.
 Un carácter blanco es un espacio, un tabulador o un carácter de nueva línea.
 Esencialmente, un carácter espacio en blanco en una cadena de control da
 lugar a que 
\family typewriter 
scanf()
\family default 
 lea, pero no guarde, cualquier número (incluido 0) de espacios en blanco
 hasta el primer carácter no blanco.
\layout Standard

Un carácter que no sea espacio en blanco lleva a 
\family typewriter 
scanf()
\family default 
 a leer y eliminar el carácter asociado.
 Por ejemplo, 
\family typewriter 
"%d,%d"
\family default 
 da lugar a que 
\family typewriter 
scanf()
\family default 
 lea primero un entero, entonces lea y descarte la coma, y finalmente lea
 otro entero.
 Si el carácter especificado no se encuentra, 
\family typewriter 
scanf()
\family default 
 termina.
\layout Subsection

Funciones putchar
\family typewriter 
()
\family default 
 y getchar
\family typewriter 
()
\layout Itemize

La función 
\family typewriter 
putchar
\family default 
 escribe un carácter en la salida estándar.
\layout Itemize

La función 
\family typewriter 
getchar
\family default 
 escribe un carácter en la entrada estádar.
\layout Itemize

La función 
\family typewriter 
putchar
\family default 
 necesita un argumento que es el carácter a escribir.
\layout Itemize

La función 
\family typewriter 
getchar
\family default 
 no recibe ningún argumento.
\layout Itemize

Ambas funciones devuelven, en caso de éxito, el carácter procesado (escrito
 o leído), y en caso de error o fin de fichero, 
\family typewriter 
EOF
\family default 
.
\layout Standard

Las instrucciones
\layout Quotation


\family typewriter 
char ch;
\layout Quotation


\family typewriter 
ch = getchar();
\layout Quotation


\family typewriter 
putchar(ch);
\layout Standard

hacen lo mismo que las instrucciones
\layout Quotation


\family typewriter 
char ch;
\layout Quotation


\family typewriter 
scanf("%c", &ch); 
\layout Quotation


\family typewriter 
printf("%c", &ch);
\layout Standard

pero para escribir y leer caracteres simples se prefiere la primera forma.
 En notación C, las instrucciones del primer ejemplo se escriben:
\layout Quotation


\family typewriter 
putchar(getchar());
\layout Standard

puesto que es más eficiente.
 Lo mismo se puede decir de las siguientes asignaciones:
\layout Quotation


\family typewriter 
x = x + 1;
\layout Quotation


\family typewriter 
x = x + 2;
\layout Standard

que aunque sean correctas, no es estilo C y además son menos eficientes
 que sus correspondientes en estilo C:
\layout Quotation


\family typewriter 
x++; /* o ++x; */
\layout Quotation


\family typewriter 
x += 2; /* hacer dos veces: x++; x++; ya es menos eficiente que x += 2;
 */
\layout Standard

Veamos un programa en C:
\layout Quotation


\family typewriter 
/* fichero ejemplo.c */
\layout Quotation


\family typewriter 
#include <stdio.h> /* para poder utilizar: getchar(), putchar(), EOF */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int ch;
\layout Quotation


\family typewriter 

\protected_separator 
 while((ch = getchar()) != EOF)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 putchar(ch);
\layout Quotation


\family typewriter 
}
\layout Standard

Al ser el nombre del programa ejemplo.c, el nombre del fichero ejecutable
 será ejemplo.exe.
 Si se ejecuta el programa de la siguiente forma:
\layout Quotation


\family typewriter 
ejemplo
\layout Standard

se leen caracteres de teclado y se escriben en pantalla.
 Se leen caracteres hasta que se encuentra el carácter de marca de fin de
 fichero que en el DOS se escribe con CONTROL-Z.
 Si se ejecuta el programa con redirección:
\layout Quotation


\family typewriter 
ejemplo < fichero_fuente > fichero_destino
\layout Standard

se produce una copia del 
\family typewriter 
fichero_fuente
\family default 
 al 
\family typewriter 
fichero_destino
\family default 
.
 Otro ejemplo de ejecución:
\layout Quotation


\family typewriter 
ejemplo >> fichero_destino
\layout Standard

en este caso se leen caracteres de teclado y se añaden al 
\family typewriter 
fichero_destino
\family default 
.
 Este programa no sólo es instructivo sino también útil; pero hay dos cosas
 que merecen una explicación: la variable 
\family typewriter 
ch
\family default 
 es 
\family typewriter 
int
\family default 
 no 
\family typewriter 
char
\family default 
, y la condición del 
\family typewriter 
while
\family default 
 parece un poco extravagante.
 Si 
\family typewriter 
ch
\family default 
 se hubiese declarado como: 
\family typewriter 
char ch
\family default 
.
\layout Standard


\family typewriter 
ch
\family default 
 es 
\family typewriter 
unsigned
\family default 
 y sería un error el compararlo con 
\family typewriter 
EOF
\family default 
 que vale -1.
 Sí se podía haber declarado 
\family typewriter 
ch
\family default 
 como: 
\family typewriter 
signed char ch
\family default 
; pero esto tiene el inconveniente de que 
\family typewriter 
ch
\family default 
 está en el rango -128 a 127 y 
\family typewriter 
ch
\family default 
 no podría tomar los valores de los caracteres ASCII entre 128 y 255.
 Así que siempre que manejen caracteres con las funciones de E/S es preferible
 declarar 
\family typewriter 
ch
\family default 
 como entero: 
\family typewriter 
int ch
\family default 
.
 El bucle while
\layout Quotation


\family typewriter 
while ((ch = getchar ()) != EOF)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 putchar(ch);
\layout Standard

puede parecer un poco raro pero es la forma de leer caracteres en C hasta
 que se encuentra el caracter 
\family typewriter 
EOF
\family default 
.
 Los paréntesis son necesarios puesto que los operadores de asignación son
 los penúltimos con menos precedencia (el operador, es el que tiene menos
 preferencia) y si no se incluyeran en el 
\family typewriter 
while
\family default 
 anterior, primero se ejecutaría la comparación 
\family typewriter 
!=
\family default 
 y el resultado de esta comparación (1 ó 0) se asignaría a la variable 
\family typewriter 
ch
\family default 
.
\layout Subsection

Funciones puts
\family typewriter 
()
\family default 
 y gets
\family typewriter 
()
\family default 
 
\layout Standard

La función 
\family typewriter 
puts
\family default 
 escribe una cadena de caracteres y un carácter de nueva línea al final
 de la cadena en la salida estándar.
 La función 
\family typewriter 
gets
\family default 
 lee una cadena de caracteres de la entrada estándar hasta que se encuentra
 el carácter 
\family typewriter 
'
\backslash 
n'
\family default 
, aunque este carácter no es añadido a la cadena.
 La función 
\family typewriter 
puts
\family default 
 acepta como argumento una cadena (sin formato).
 Si tiene éxito devuelve el último carácter escrito (siempre es 
\family typewriter 
'
\backslash 
n'
\family default 
).
 En otro caso, devuelve 
\family typewriter 
EOF
\family default 
.
 La llamada a función
\layout Quotation


\family typewriter 
puts("Esto es un ejemplo.");
\layout Standard

es equivalente a:
\layout Quotation


\family typewriter 
printf("Esto es un ejemplo.
\backslash 
n");
\layout Standard

La función 
\family typewriter 
gets
\family default 
 acepta como argumento un puntero al principio de la cadena, es decir, el
 nombre de la variable cadena de caracteres; y devuelve dicho puntero si
 tiene éxito o la constante 
\family typewriter 
NULL
\family default 
 si falla.
 
\family typewriter 
NULL
\family default 
 es una constante definida en el fichero 
\family typewriter 
stdio.h
\family default 
 que tiene valor 0.
 Esta constante se suele utilizar para denotar que un puntero no apunta
 a ningún sitio.
 Las instrucciones
\layout Quotation


\family typewriter 
char cadena [100];
\layout Quotation


\family typewriter 
gets(cadena);
\layout Standard

no son equivalentes a
\layout Quotation


\family typewriter 
char cadena [100];
\layout Quotation


\family typewriter 
scanf("%s", cadena);
\layout Standard

puesto que 
\family typewriter 
gets
\family default 
 lee una cadena hasta que encuentre 
\family typewriter 
'
\backslash 
n'
\family default 
 y 
\family typewriter 
scanf
\family default 
 hasta que encuentre un carácter blanco (
\family typewriter 
' '
\family default 
), un tabulador (
\family typewriter 
'
\backslash 
t'
\family default 
) o un carácter de nueva línea (
\family typewriter 
'
\backslash 
n'
\family default 
).
 Con las funciones de lectura de cadenas es necesario tener una precaución
 muy importante: en la declaración de cadena se ha reservado memoria para
 100 caracteres; por lo tanto, si la función 
\family typewriter 
gets
\family default 
 o 
\family typewriter 
scanf
\family default 
 leen más de 100 caracteres, los caracteres a partir del 100 se están escribiend
o en memoria en posiciones no reservadas con lo cual los resultados son
 impredecibles: pensad que se puede estar escribiendo datos en el código
 del sistema operativo, del compilador de C, de programas residentes, ...
 Este problema se puede solucionar con la función 
\family typewriter 
scanf
\family default 
 de la siguiente forma:
\layout Quotation


\family typewriter 
char cadena [100];
\layout Quotation


\family typewriter 
scanf("%100s", cadena);
\layout Standard

donde los caracteres introducidos a partir del número 100 son ignorados
 y no se escriben en la variable cadena.
 Con la función gets no se puede hacer esto.
\layout Section

Funciones de Consola
\layout Standard

Las funciones de consola que vamos a describir no están definidas en el
 estándar ANSI, ya que son funciones, que por su propia naturaleza, dependen
 del entorno fijado y en gran parte no son portables.
 Sin embargo, estos tipos de funciones tienen una importancia primordial
 a la hora de crear un software de calidad.
 Todo lo que se diga sobre estas funciones es válido para los dos compiladores
 de C más importantes: el de Microsoft y el de Borland.
 Si utilizas otro compilador distinto a los anteriores, es probable que
 los nombres de las funciones coincidan con las que vamos a ver, en caso
 contrario, estas funciones tendrán otros nombres.
 Las características de consola específicas de Borland sólo se estudiará
 si la opción turbo está on.
\layout Standard

Todas las funciones, y en general toda la información, de consola, están
\layout Standard

recogidas en la librería 
\family typewriter 
<conio.h>
\family default 
 (consola input/output).
 En esta lección vamos a ver diez funciones de esta librería: 
\family typewriter 
cprintf
\family default 
, 
\family typewriter 
cscanf
\family default 
, 
\family typewriter 
putch
\family default 
, 
\family typewriter 
getch
\family default 
, 
\family typewriter 
getche
\family default 
, 
\family typewriter 
ungetch
\family default 
, 
\family typewriter 
cputs
\family default 
, 
\family typewriter 
cgets
\family default 
 y 
\family typewriter 
kbhit
\family default 
.
 Además veremos tres funciones más, que pertenecen a Turbo C: 
\family typewriter 
lowvideo
\family default 
, 
\family typewriter 
higvideo
\family default 
 y 
\family typewriter 
normvideo
\family default 
.
\layout Standard

La función 
\family typewriter 
cprintf
\family default 
 es similar a la función 
\family typewriter 
printf
\family default 
.
 Lo mismo sucede con los pares de funciones: 
\family typewriter 
cscanf-scanf
\family default 
, 
\family typewriter 
cputs-puts
\family default 
, 
\family typewriter 
putch-putchar
\family default 
, 
\family typewriter 
getch-getchar
\family default 
, 
\family typewriter 
getche-getchar
\family default 
, 
\family typewriter 
cputs-puts
\family default 
 y 
\family typewriter 
cgets-gets
\family default 
.
 Las diferencias entre estos pares de funciones se muestran en la tabla:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""


\series bold 
Funciones de E/S estándar
\newline 
Funciones de E/S de consola
\series default 

\newline 
Se escribe en la salida estádar
\newline 
Se escribe en pantalla
\newline 
Se lee de la salida estándar
\newline 
Se lee de teclado
\newline 
Se escribe y lee a través de buffers
\newline 
No utiliza buffers
\newline 
Para pasar a la línea siguiente es suficiente
\newline 
Para pasar a la línea siguiente hay que escribir los caracteres de 
\newline 
escribir el carácter de nueva línea: 
\family typewriter 
'
\backslash 
n'
\family default 

\newline 
 nueva línea y el de retorno de carro: 
\family typewriter 
'
\backslash 
n'
\family default 
 y 
\family typewriter 
'
\backslash 
r'
\layout Standard

Consecuencia de estas diferencias:
\layout Enumerate

Las funciones de escritura de conio.h siempre escriben en pantalla.
 Las funciones de escritura de 
\family typewriter 
stdio.h
\family default 
 normalmente escriben en pantalla, pero si se redirige la salida (esto se
 puede hacer al ejecutar el programa mediante los símbolos 
\family typewriter 
>
\family default 
, 
\family typewriter 
>>
\family default 
 o 
\family typewriter 
|
\family default 
) ya no escribe en pantalla.
 Lo mismo se puede decir de las funciones de lectura y el teclado.
\layout Enumerate

En los programas interactivos no queda bien trabajar con buffers.
 Si has visto los ejemplos de lecciones anteriores, 
\family typewriter 
getchar
\family default 
 lee un carácter, pero lo lee una vez que se ha pulsado la tecla RETURN;
 además lo caracteres leídos hasta pulsar la tecla RETURN se mantienen en
 el buffer para ser leídos posteriormente.
 Esto queda muy mal en los programas interactivos.
 Las funciones 
\family typewriter 
getch
\family default 
 y 
\family typewriter 
getche
\family default 
, que las estudiaremos un poco más adelante, lee caracteres inmediatamente,
 es decir, tras pulsar la tecla.
\layout Enumerate

Las funciones de escritura estándar siempre escriben en pantalla con los
 colores blanco sobre negro.
 Las funciones de escritura de consola escriben con cualquier atributo de
 pantalla.
\layout Subsection

Funciones cprintf
\family typewriter 
()
\family default 
 y cscanf
\family typewriter 
()
\family default 
 
\layout Standard

Estas dos funciones son exactamente iguales que sus correspondientes 
\family typewriter 
printf
\family default 
 y 
\family typewriter 
scanf
\family default 
.
 Sólo se diferencia en dos cosas:
\layout Enumerate

La función 
\family typewriter 
cprintf
\family default 
 escribe en pantalla en la posición actual del cursor y con el atributo
 de pantalla actual.
 La función 
\family typewriter 
cscanf
\family default 
 lee de teclado.
\layout Enumerate

En la función 
\family typewriter 
cprintf
\family default 
, para pasar a la línea siguiente, es necesario escribir dos caracteres:
 
\family typewriter 
'
\backslash 
n'
\family default 
 y 
\family typewriter 
'
\backslash 
r'
\family default 
.
\layout Standard

Estas dos diferencias ocurren con todas las funciones de entrada y salida
 de 
\family typewriter 
conio.h
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
cprintf("Pasando al principio de la línea siguiente
\backslash 
n
\backslash 
r");
\layout Standard

En la librería 
\family typewriter 
conio.h
\family default 
 de Turbo C existe una variable de tipo entera que se llama 
\family typewriter 
directvideo
\family default 
.
 Esta variable controla la salida: si 
\family typewriter 
directvideo
\family default 
 tiene el valor 1, la salida va directamente a RAM de vídeo; si tiene el
 valor 0, la salida se escribe vía llamadas a la ROM BIOS.
 El valor por defecto es 
\family typewriter 
directvideo
\family default 
 = 1.
 Un valor de 1 hace la escritura más rápida pero menos portable.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <conio.h> /* directvideo: sólo Turbo C */
\layout Quotation


\family typewriter 
#include <stdio.h> /* puts () */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 directvideo = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 puts("Este mensaje se escribe vía llamadas a la ROM BIOS.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 directvideo = 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 puts("Este mensaje se escribe directamente a la RAM de vídeo.");
\layout Quotation


\family typewriter 
}
\layout Subsection

Funciones cputs
\family typewriter 
()
\family default 
 y cgets
\family typewriter 
()
\layout Standard

La función 
\family typewriter 
cputs
\family default 
 escribe una cadena de caracteres en pantalla.
 Si recuerdas, las función 
\family typewriter 
puts
\family default 
 escribía una cadena y además un caracter de nueva línea; la función 
\family typewriter 
cputs
\family default 
 no pasa a la línea siguiente a no ser que se encuentre en la cadena los
 caracteres de nueva línea y retorno de carro.
 La función 
\family typewriter 
cputs
\family default 
, al igual que la función 
\family typewriter 
puts
\family default 
, devuelve el último caracter escrito.
 La función 
\family typewriter 
cgets
\family default 
 lee una cadena de caracteres de consola.
 Esta función es un poco diferente a la función 
\family typewriter 
gets
\family default 
.
 El primer elemento de la cadena debe contener la longitud máxima de la
 cadena a ser leída.
 La función 
\family typewriter 
cgets
\family default 
 devuelve en el segundo elemento de la cadena el número de caracteres leídos.
 La cadena empieza en el tercer elemento del array.
 Devuelve la dirección del tercer elemento del array, que es donde empieza
 la cadena leída.
 Veamos un ejemplo de la función 
\family typewriter 
cgets
\family default 
:
\layout Quotation


\family typewriter 
#include <conio.h> /* para poder utilizar las funciones cputs(), cgets (),
 cprintf () y getch () */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 char cadena[83]; /* cadena[0], cadena[1] y 80 caracteres más el
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 carácter terminador nulo */
\layout Quotation


\family typewriter 

\protected_separator 
 cadena[0] = 81; /* la función cgets almacenará en cadena, como máximo,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 80 caracteres más el carácter nulo */
\layout Quotation


\family typewriter 

\protected_separator 
 cputs("Escribe una cadena de caracteres:
\backslash 
n
\backslash 
r");
\layout Quotation


\family typewriter 

\protected_separator 
 cgets(cadena); /* lee cadena de consola */
\layout Quotation


\family typewriter 

\protected_separator 
 cprintf("
\backslash 
n
\backslash 
n
\backslash 
rNúmero de caracteres leídos: %d", cadena[1]);
\layout Quotation


\family typewriter 

\protected_separator 
 cprintf("
\backslash 
n
\backslash 
rCadena leída:
\backslash 
n
\backslash 
r %s", &cadena[2]); /* &cadena[2] es la
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 dirección del tercer elemento del array cadena */
\layout Quotation


\family typewriter 

\protected_separator 
 cputs("
\backslash 
n
\backslash 
n
\backslash 
rPulsa cualquier tecla para finalizar el programa.");
\layout Quotation


\family typewriter 

\protected_separator 
 getch();
\layout Quotation


\family typewriter 
}
\layout Subsection

Funciones putch
\family typewriter 
()
\family default 
, getch
\family typewriter 
()
\family default 
, getche
\family typewriter 
()
\family default 
 y ungetch
\family typewriter 
()
\family default 
 
\layout Standard

La función 
\family typewriter 
putch
\family default 
 escribe un carácter en consola.
 Es similar a 
\family typewriter 
putchar
\family default 
.
 Las funciones 
\family typewriter 
getch
\family default 
 y 
\family typewriter 
getche
\family default 
 leen un carácter de consola, con eco a pantalla (
\family typewriter 
getche
\family default 
) o sin eco (
\family typewriter 
getch
\family default 
).
 Son similares a 
\family typewriter 
getchar
\family default 
.
 Las teclas especiales, tales como las teclas de función, están representadas
 por una secuencia de dos caracteres: un carácter cero seguido del código
 de exploración de la tecla presionada.
 Así, para leer un caracter especial, es necesario ejecutar dos veces la
 función 
\family typewriter 
getch
\family default 
 (o 
\family typewriter 
getche
\family default 
).
\layout Standard

La función 
\family typewriter 
ungetch
\family default 
 devuelve un carácter al teclado.
 Acepta como parámetro el carácter a devolver y devuelve el propio carácter
 si hace la operación con éxito o 
\family typewriter 
EOF
\family default 
 se ha ocurrido un error.
 Si hace 
\family typewriter 
ungetch
\family default 
, la próxima llamada de 
\family typewriter 
getch
\family default 
 o cualquier otra función de entrada por teclado, leerá el carácter que
 devolvió la función 
\family typewriter 
ungetch
\family default 
.
 No se puede devolver más de un carácter consecutivo.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 char ch = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 cprintf("Entra una cadena: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 while(ch != '
\backslash 
r')
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ch = getch();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 putch(ch);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 
}
\layout Subsection

Función kbhit
\family typewriter 
()
\family default 
 
\layout Standard

La función 
\family typewriter 
kbhit
\family default 
 devuelve un valor cierto (distinto de cero) si hay una tecla disponible
 y falso (0) si no la hay.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <conio.h> /* para utilizar: cprintf (), kbhit (), getch () */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 float numero = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 
 cprintf("Pulsa cualquier tecla para parar la escritura de números.
\backslash 
n
\backslash 
r");
\layout Quotation


\family typewriter 

\protected_separator 
 while(! kbhit ())
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 cprintf("
\backslash 
r%g", ++numero);
\layout Quotation


\family typewriter 

\protected_separator 
 cprintf("
\backslash 
n
\backslash 
rTecla pulsada: %c.
\backslash 
n
\backslash 
r", getch());
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 
 cprintf("
\backslash 
n
\backslash 
rPulsa cualquier tecla para finalizar.");
\layout Quotation


\family typewriter 

\protected_separator 
 getch();
\layout Quotation


\family typewriter 
}
\layout Subsection

Funciones lowvideo
\family typewriter 
()
\family default 
, highvideo
\family typewriter 
()
\family default 
 y normvideo
\family typewriter 
()
\family default 
 
\layout Standard

Estas tres funciones pertenecen a Turbo C.
 La función 
\family typewriter 
lowvideo
\family default 
 hace que los caracteres que se escriban a partir de la llamada a esta función
 se escriban en baja intensidad.
 La función 
\family typewriter 
highvideo
\family default 
 hace que los caracteres que se escriban a partir de la llamada a esta función
 se escriban en alta intensidad.
 La función 
\family typewriter 
normvideo
\family default 
 hace que los caracteres que se escriban a partir de la llamada a esta función
 se escriban en intensidad normal.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <conio.h> /* para utilizar lowvideo(), hihgvideo() y normvideo()
 */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 normvideo();
\layout Quotation


\family typewriter 

\protected_separator 
 cputs("Texto con intensidad normal.");
\layout Quotation


\family typewriter 

\protected_separator 
 lowvideo();
\layout Quotation


\family typewriter 

\protected_separator 
 cputs("Texto con baja intensidad.");
\layout Quotation


\family typewriter 

\protected_separator 
 highvideo();
\layout Quotation


\family typewriter 

\protected_separator 
 cputs("Texto con alta intensidad.");
\layout Quotation


\family typewriter 
}
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 4-1
\series default 
.
 Lectura y resolución de un sistema de ecuaciones con dos ecuaciones y dos
 incógnitas.
\layout Quote

Un sistema de ecuaciones lineales de la forma
\layout Quotation

ax + by = c
\layout Quotation

dx + ey = f
\layout Quote

puede resolverse utilizando las siguientes fórmulas:
\layout Quotation

x = (ce - bf) / (ae - bd)
\layout Quotation

y = (ae - cd) / (ae - bd)
\layout Quote

Diséñese un algoritmo para leer los dos conjuntos de coeficientes (a, b
 y c; d, e y f) e imprimir los valores que son solución para x e y.
 Imprímase un mensaje si el sistema no se pudiese resolver por estas fórmulas.
\layout Itemize


\series bold 
Ejercicio 4-2.
 Resolución de un determinada función matemática.
\layout Quote

Diseñar un programa que lee un valor x y calcule el valor de y=x*x+5 para
 el caso en que x sea menor que 0 e y=3*x-1 para valores de x entre 0 y
 2 e y=x*x-4*x+5 para x mayor que 2.
\layout Itemize


\series bold 
Ejercicio 4-3.
 Cálculo de la suma de una determinada serie.
\layout Quote

Escribir un programa que pregunte un dato N y que calcule la suma S de 1*1
 + 2*2 + 3*3 + ...
 hasta que dicha suma sea mayor o igual que N.
 Entonces escribirá N, S y el último número que ha elevado al cuadrado.
\layout Itemize


\series bold 
Ejercicio 4-4.
 Cálculo del producto de dos número mediante sumas sucesivas.
\layout Quote

Programa que obtenga el producto de dos números enteros positivos mediante
 sumas sucesivas.
\layout Itemize


\series bold 
Ejercicio 4-5.
 Tabla de multiplicar de un número.
\layout Quote

Programa que imprima la tabla de multiplicar de un número entero positivo.
\layout Itemize


\series bold 
Ejercicio 4-6.
 Contador de vocales de una frase.
\layout Quote

Programa que lea una frase en una línea, y cuente su número de vocales.
 
\layout Itemize


\series bold 
Ejercicio 4-7.
 Cálculo del producto de dos números mediante el algoritmo ruso.
\layout Quote

Programa que calcule el producto de dos números enteros positivos mediante
 el denominado "algoritmo ruso del producto".
 El algoritmo consiste en duplicar el primer factor y dividir (cociente
 entero) por 2 el segundo, obteniendo un producto equivalente, salvo si
 el segundo factor es impar, en cuyo caso es necesario acumular previamente
 el primero en donde se va a obtener el resultado.
 El proceso termina cuando el segundo factor se hace 0.
 Ejemplo: Multiplicación de 25*6.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 3 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Primer factor
\newline 
Segundo factor
\newline 
Acumulador
\series default 

\newline 
25
\newline 
6
\newline 
0
\newline 
50
\newline 
3
\newline 
50
\newline 
100
\newline 
1
\newline 
150
\newline 
200
\newline 
0
\newline 
150
\layout Itemize


\series bold 
Ejercicio 4-8.
 Cálculo del mayor y menor sueldo de una persona.
\layout Quote

Programa que lea 20 datos, compuesto cada uno de ellos por un nombre de
 persona y su sueldo neto mensual, y obtenga e imprima el nombre y sueldo
 de la persona que más cobra y de la que menos.
 Si hay varias se imprime la primera que aparezca en la secuencia de entrada.
 
\layout Chapter

Variables y Funciones
\layout Standard

El objetivo de esta lección es hacer un estudio completo en todo lo referente
 a las variables, funciones, y directivas del preprocesador del C.
 Los puntos que detallaremos son:
\layout Standard

Declaración y definición de variables y funciones.
\layout Standard

Tipos de variables según el lugar de la declaración: variables locales,
 parámetros formales y variables globales.
\layout Standard

Especificadores de clase de almacenamiento: 
\family typewriter 
extern
\family default 
, 
\family typewriter 
static
\family default 
, 
\family typewriter 
register
\family default 
 y 
\family typewriter 
auto
\family default 
.
\layout Standard

Reglas de ámbito de las funciones.
\layout Standard

Argumentos de las funciones en general y de la función 
\family typewriter 
main
\family default 
 en partiticular.
\layout Standard

Recursividad.
\layout Standard

Separación de un programa en varios ficheros.
\layout Standard

Número variable de argumentos.
 Librería 
\family typewriter 
<stdarg.h>
\family default 
: 
\family typewriter 
va_list
\family default 
, 
\family typewriter 
va_arg()
\family default 
, 
\family typewriter 
va_start()
\family default 
 y 
\family typewriter 
va_end()
\family default 
.
 Librería 
\family typewriter 
<stdio.h>
\family default 
: 
\family typewriter 
vprintf()
\family default 
 y 
\family typewriter 
vscanf()
\family default 
.
\layout Standard

Directivas del preprocesador: 
\family typewriter 
#include
\family default 
, 
\family typewriter 
#define
\family default 
, 
\family typewriter 
#undef
\family default 
, 
\family typewriter 
#error
\family default 
, 
\family typewriter 
#if
\family default 
, 
\family typewriter 
#else
\family default 
, 
\family typewriter 
#elif
\family default 
, 
\family typewriter 
#endif
\family default 
, 
\family typewriter 
#ifdef
\family default 
, 
\family typewriter 
#ifndef
\family default 
, 
\family typewriter 
#line
\family default 
 y 
\family typewriter 
#pragma
\family default 
.
\layout Section

Funciones 
\layout Standard

Los programas en C, al menos que sean muy simples, en cuyo caso estarían
 compuestos sólo por la función 
\family typewriter 
main
\family default 
, están formados por varias funciones.
\layout Subsection

Declaración de Funciones
\layout Standard

La forma general de una función en el estándar ANSI actual es: 
\layout Quotation


\family typewriter 
especificador_de_tipo nombre_de_la_funcion (lista_de_declaraciones_de_param)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 cuerpo_de_la_funcion
\layout Quotation


\family typewriter 
}
\layout Standard

y en el C de Kernighan y Ritchie es:
\layout Quotation


\family typewriter 
especificador_de_tipo nombre_de_la_funcion (lista_de_parametros)
\layout Quotation


\family typewriter 
declaracion_de_los_parametros
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 cuerpo_de_la_funcion
\layout Quotation


\family typewriter 
}
\layout Standard


\family typewriter 
especificador_de_tipo
\family default 
 es el tipo del valor que devuelve la función, si es 
\family typewriter 
void
\family default 
, la función no devuelve ningún valor, si no se pone se supone que la función
 devuelve un entero; 
\family typewriter 
lista_de_declaraciones_de_param
\family default 
 es una lista de declaraciones separadas por comas donde cada declaración
 consta de tipo y nombre de parámetro; 
\family typewriter 
cuerpo_de_la_funcion
\family default 
 es una lista de sentencias C, incluso puede no haber ninguna: 
\family typewriter 
'nada () {}'
\family default 
 en cuyo caso la función no hace nada (será útil como un lugar vacío durante
 el desarrollo de un programa); 
\family typewriter 
lista_de_parametros
\family default 
 es una lista de nombres de parámetros separados por comas; 
\family typewriter 
declaracion_de_los_parametros
\family default 
 consiste en especificar el tipo de los parámetros.
\layout Standard

La segunda forma aunque está permitida en el ANSI C es considerada como
 obsoleta.
 De hecho, las palabras claves 
\family typewriter 
void
\family default 
, 
\family typewriter 
const
\family default 
 y 
\family typewriter 
volatile
\family default 
 vistas ya, no existen en el viejo C de Kernighan y Ritchie.
 Veamos un ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
/* Función declarada según la forma del estándar ANSI */
\layout Quotation


\family typewriter 
void funcion_1(int numero_1_funcion_1, int numero_2_funcion_1)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n%d + %d = %d", numero_1_funcion_1, numero_2_funcion_1,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 numero_1_funcion_1 + numero_2_funcion_1);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
/* Función declarada según la forma del C de Kernighan y Ritchie */
\layout Quotation


\family typewriter 
void funcion_2(numero_1_funcion_2, numero_2_funcion_2)
\layout Quotation


\family typewriter 
int numero_1_funcion_2, numero_2_funcion_2;
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n%d - %d = %d", numero_1_funcion_2, numero_2_funcion_2,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 numero_1_funcion_2 - numero_2_funcion_2);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int numero_1_funcion_main = 2, numero_2_funcion_main = 3;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 funcion_1(numero_1_funcion_main, numero_2_funcion_main);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 funcion_1(numero_1_funcion_main, numero_2_funcion_main);
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa es:
\layout Quotation


\family typewriter 
2 + 3 = 5
\layout Quotation


\family typewriter 
2 - 3 = -1
\layout Standard

El funcionamiento de este ejemplo parace claro.
 Hay una observación importante que hacer acerca del mismo: Si la función
 
\family typewriter 
main
\family default 
 se hubiera definido antes de las funciones 
\family typewriter 
funcion_1
\family default 
 y 
\family typewriter 
funcion_2
\family default 
, el compilador al procesar las llamadas a 
\family typewriter 
funcion_1
\family default 
 y 
\family typewriter 
funcion_2
\family default 
 no sabe de qué tipo son dichas funciones y nos puede informar de un error
 o asumir que devuelven un entero.
 Es bueno declarar todas las funciones a utilizar (excepto 
\family typewriter 
main
\family default 
) antes de su definición para evitar problemas de este tipo.
 El ejemplo anterior se escribiría de la siguiente forma:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void funcion_1(int numero_1_funcion_1, int numero_2_funcion_1);
\layout Quotation


\family typewriter 
void funcion_2(int numero_1_funcion_2, int numero_2_funcion_2);
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int numero_1_funcion_main = 2, numero_2_funcion_main = 3;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 funcion_1(numero_1_funcion_main, numero_2_funcion_main);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 funcion_1(numero_1_funcion_main, numero_2_funcion_main);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
/* Función declarada según la forma del estándar ANSI */
\layout Quotation


\family typewriter 
void funcion_1(int numero_1_funcion_1, int numero_2_funcion_1)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n%d + %d = %d", numero_1_funcion_1, numero_2_funcion_1,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 numero_1_funcion_1 + numero_2_funcion_1);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
/* Función declarada según la forma del C de Kernighan y Ritchie */
\layout Quotation


\family typewriter 
void funcion_2(numero_1_funcion_2, numero_2_funcion_2)
\layout Quotation


\family typewriter 
int numero_1_funcion_2, numero_2_funcion_2;
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n%d - %d = %d", numero_1_funcion_2, numero_2_funcion_2,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 numero_1_funcion_2 - numero_2_funcion_2);
\layout Quotation


\family typewriter 
}
\layout Standard

El compilador, en esta nueva versión, al procesar las llamadas a las funciones
 
\family typewriter 
funcion_1
\family default 
 y 
\family typewriter 
funcion_2
\family default 
 en la función 
\family typewriter 
main
\family default 
 ya sabe cómo son estas funciones.
 
\layout Standard

En las declaraciones (no en las definiciones que son las descripciones completas
 de las funciones) es lícito suprimir el nombre de los parámetros, así que
 también se podría haber hecho:
\layout Quotation


\family typewriter 
void funcion_1 (int, int);
\layout Quotation


\family typewriter 
void funcion_2 (int, int);
\layout Standard

e incluso también:
\layout Quotation


\family typewriter 
void funcion_1 (int, int), funcion_2 (int, int);
\layout Standard

al igual que se declaran las variables.
 A las declaraciones de las funciones también se les llama prototipos.
\layout Subsection

Valores Devueltos
\layout Standard

Todas las funciones, excepto aquéllas del tipo 
\family typewriter 
void
\family default 
, devuelven un valor.
 Este valor se especifica explícitamente en la sentencia 
\family typewriter 
return
\family default 
 y si no existe ésta, el valor es 0.
 La forma general de 
\family typewriter 
return
\family default 
 es:
\layout Quotation


\family typewriter 
return expresión;
\layout Standard

Tres observaciones sobre la sentencia return:
\layout Enumerate

La sentencia 
\family typewriter 
return
\family default 
 tiene dos usos importantes.
 Primero, fuerza a una salida inmediata de la función, esto es, no espera
 a que se llegue a la última sentencia de la función para acabar.
 Segundo, se puede utilizar para devolver un valor.
\layout Enumerate


\family typewriter 
return
\family default 
 no es una función sino una palabra clave del C, por lo tanto no necesita
 paréntesis como las funciones, aunque también es correcto: 
\family typewriter 
return (expresión)
\family default 
; pero teniendo en cuenta que los parántesis forman parte de la expresión,
 no representan una llamada a una función.
\layout Enumerate

En las funciones de tipo void se puede hacer: 
\family typewriter 
return;
\family default 
 .
 Y de esta forma se provoca la salida inmediata de la función.
 
\layout Quote

Veamos un ejemplo para aclarar todo esto:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int maximo (int, int);
\layout Quotation


\family typewriter 
long potencia(int, int);
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int a = 2, b = 3, c = 4, d = 5;
\layout Quotation


\family typewriter 

\protected_separator 
 printf("
\backslash 
nEl máximo entre %d y %d es %d.", a, b, maximo (a, b));
\layout Quotation


\family typewriter 

\protected_separator 
 printf("
\backslash 
n%d elevado a %d es %d.
\backslash 
n", c, d, potencia (c, d));
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int maximo(int ma, int mb)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 return ma >= mb ? ma : mb;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
long potencia(int pa, int pb)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int i;
\layout Quotation


\family typewriter 

\protected_separator 
 long pot = 1;
\layout Quotation


\family typewriter 

\protected_separator 
 for (i = 1; i <= pb; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 pot *= pa;
\layout Quotation


\family typewriter 

\protected_separator 
 return pot;
\layout Quotation


\family typewriter 
}
\layout Quote

La salida de este programa es:
\layout Quotation


\family typewriter 
El máximo de 2 y 3 es 3.
\layout Quotation


\family typewriter 
4 elevado a 5 es 1024.
\layout Section

Tipos de Variables Según el Lugar de Declaración
\layout Standard

Existen tres lugares básicos donde se pueden declarar variables: dentro
 de funciones, en la definición de parámetros de funciones y fuera de las
 funciones.
 Estas variables son, respectivamente, variables locales, parámetros formales
 y variables globales.
\layout Subsection

Variables Locales
\layout Standard

Son aquéllas que se declaran dentro de una función.
 Estas variables se declaran al principio de un bloque de código, se destruyen
 al llegar al final del bloque de código y sólo puede ser utilizada (ya
 que sólo tiene existencia) dentro de ese bloque.
 Recuerda que un bloque de código empieza con una llave abierta y termina
 con una llave cerrada.
 Ejemplos:
\layout Quotation


\family typewriter 
void f1(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x;
\protected_separator 

\protected_separator 
 /* se reserva memoria para x */
\layout Quotation


\family typewriter 

\protected_separator 
 x = 10;
\protected_separator 
 /* se le asigna un valor */
\layout Quotation


\family typewriter 
}
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* se libera la memoria asignada a x */
\layout Quotation


\family typewriter 
void f2(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x = 1;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* se reserva memoria para x sentencias */
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int y = 2;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* se reserva memoria para y sentencias */
\layout Quotation


\family typewriter 

\protected_separator 
 }
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* se libera memoria asignada a y */
\layout Quotation


\family typewriter 

\protected_separator 
 /* sentencias */
\protected_separator 

\protected_separator 
 /* en ese punto no existe la variable y */
\layout Quotation


\family typewriter 
}
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* se libera memoria asignada a x */
\layout Quotation


\family typewriter 
void f3(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x, y; /* se reserva memoria para las variables x e y */
\layout Quotation


\family typewriter 

\protected_separator 
 x = 1;
\protected_separator 

\protected_separator 

\protected_separator 
 /* se asigna 1 a la variable x */
\layout Quotation


\family typewriter 

\protected_separator 
 y = x;
\protected_separator 

\protected_separator 

\protected_separator 
 /* se asigna x (1) a la variable y */
\layout Quotation


\family typewriter 

\protected_separator 
 {
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* comienzo de un bloque de código */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int x;
\protected_separator 
 /* se reserva memoria para x; ésta es distinta a la anterior */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 x = 2;
\protected_separator 
 /* se asigna 2 a la variable x de este bloque */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 y = x;
\protected_separator 
 /* se asigna x (2) a la variable y */
\layout Quotation


\family typewriter 

\protected_separator 
 }
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* se libera memoria asignada a la variable x de este bloque */
\layout Quotation


\family typewriter 

\protected_separator 
 y = x;
\protected_separator 

\protected_separator 

\protected_separator 
 /* se asigna x (1) a la variable y */
\layout Quotation


\family typewriter 
}
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* se libera memoria asignada a las variables x e y */
\layout Subsection

Parámetros Formales
\layout Standard

Si una función va a usar argumentos, entonces debe declarar las variables
 que van a aceptar los valores de esos argumentos.
 Estas variables son los parámetros formales de la función.
 Se comportan como cualquier otra variable local de la función.
 Ejemplos:
\layout Quotation


\family typewriter 
void f1(int x)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 /* x es una variable local a esta función */
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void f2(int x)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x; /* ERROR: se ha intentado definir dos variables del mismo
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 nombre en el mismo ámbito */
\layout Quotation


\family typewriter 
}
\layout Subsection

Variables Globales
\layout Standard

A diferencia de las variables locales, las variables globales se conocen
 a lo largo de todo el programa y se pueden usar en cualquier parte de código.
 Además, mantienen su valor durante toda la ejecución del programa.
 Las variables globales se crean al declararlas en cualquier parte fuera
 de una función.
 Ejemplo:
\layout Quotation


\family typewriter 
void f1(void), f2(void), f3(void);
\layout Quotation


\family typewriter 
int x;
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 f1();
\layout Quotation


\family typewriter 

\protected_separator 
 f2();
\layout Quotation


\family typewriter 

\protected_separator 
 f3();
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void f1(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 x = 10;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void f2(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 x = 11;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void f3(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x; /* esta variable x es local, es distinta a la global */
\layout Quotation


\family typewriter 

\protected_separator 
 x = 12; /* se le asinga x a la variable x local, no a la global */
\layout Quotation


\family typewriter 
}
\layout Section

Especificadores de Clase de Almacenamiento
\layout Standard

Existen cuatro especificadores de clase de almacenamiento soportados por
 C.
 Son: 
\family typewriter 
extern
\family default 
, 
\family typewriter 
static
\family default 
, 
\family typewriter 
register
\family default 
 y 
\family typewriter 
auto
\family default 
.
 Se usan para indicar al compilador cómo se debe almacenar la variable que
 le sigue.
 El especificador de almacenamiento precede al resto de la declaración de
 variable.
 Su forma general es:
\layout Quotation


\family typewriter 
especificador_de_almacenamiento
\protected_separator 
 tipo
\protected_separator 
 nombre_de_variable;
\layout Subsection

Extern 
\layout Standard

Consideremos los dos siguientes ejemplos:
\layout Quotation


\family typewriter 
int a;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* definición de una variable */
\layout Quotation


\family typewriter 
extern int b; /* declaración de una variable */
\layout Standard

En la primera sentencia estamos definiendo una variable de tipo entero llamada
 
\family typewriter 
a
\family default 
.
 En la segunda sentencia estamos declarando una variable de tipo entero
 llamada 
\family typewriter 
b
\family default 
.
 En la definición de una variable se reserva un espacio de memoria para
 una variable.
\layout Standard

La declaración le indica al compilador que esa variable está o será definida
 en otra parte, pero no reserva memoria para ella.
 Así pues, una variable sólo se puede definir una vez pero se puede declarar
 todas las veces que se desee.
 A partir de ahora, cuando se diga declarar nos estaremos refiriendo a la
 declaración y a la definición, a no ser que se distinga explícitamente
 entre ambos conceptos, ya que es el término más utilizado en todos los
 libros y programas.
\layout Standard

El principal uso de 
\family typewriter 
extern
\family default 
 se da cuando un programa está compuesto de varios ficheros y tenemos una
 variable global a varios de ellos.
 Obsérvese el siguiente ejemplo:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
10 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

/* Fichero 1 */
\newline 
/* Fichero 2 */
\newline 
int x;
\newline 
extern int x;
\newline 
main()
\newline 
f2()
\newline 
{
\newline 
{
\newline 

\protected_separator 
 ...
\newline 

\protected_separator 
 ...
\newline 
}
\newline 
}
\newline 
f1()
\newline 
f3()
\newline 
{
\newline 
{
\newline 

\protected_separator 
 ...
\newline 

\protected_separator 
 ...
\newline 
}
\newline 
}
\layout Standard

En la situación anterior, a la variable 
\family typewriter 
x
\family default 
 pueden acceder las cuatro funciones, es decir, los dos ficheros.
 Si no hubiésemos hecho
\layout Quotation


\family typewriter 
extern int x;
\layout Standard

las funciones del fichero 2 no podrían acceder a la variable 
\family typewriter 
x
\family default 
.
 Y si hubiésemos puesto
\layout Quotation


\family typewriter 
int x;
\layout Standard

en vez de
\layout Quotation


\family typewriter 
extern int x;
\layout Standard

en el fichero 2, entonces, el compilador daría un error porque se está intentand
o definir dos veces la misma variable en el mismo ámbito.
\layout Subsection

Static 
\layout Standard

Las variables globales son variables permanentes.
 Tienen dos significados diferentes dependiendo si son locales o globales.
\layout Subsubsection

Variables Estáticas Locales
\layout Standard

La diferencia con las variables locales normales es que su contenido no
 se pierde al salirse de la función, de tal manera que al volver a entrar
 en la función, la variable estática tiene el mismo valor que el que tenía
 cuando terminó la función en la llamada anterior.
 La variable estática sólo es inicializada en la primera llamada a la función.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void f1(void), f2(void);
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 f1();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 f1();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 f2();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 f2();
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
void f1(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 static int x = 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nx = %d", x); 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 x++;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
void f2(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int y = 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
ny = %d", y); 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 y++;
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa es:
\layout Quotation


\family typewriter 
x = 1
\layout Quotation


\family typewriter 
x = 2
\layout Quotation


\family typewriter 
y = 1
\layout Quotation


\family typewriter 
y = 1
\layout Subsubsection

Variables Estáticas Globales
\layout Standard

Cuando se aplica el modificador static a una variable global, se indica
 al compilador que cree una variable global conocida únicamente en el fichero
 en el que se declara la variable global 
\family typewriter 
static
\family default 
.
 Esto significa que, aunque la variable es global, las rutinas de otros
 ficheros no la reconocerán ni alternarán su contenido directamente; así,
 no estará sujeta a efectos secundarios.
\layout Subsection

Register
\layout Standard

El especificador 
\family typewriter 
register
\family default 
 pide al compilador de C que mantenga el valor de las variables definidas
 con ese modificador en un registro de la CPU en lugar de en memoria, que
 es donde se almacenan normalmente las variables.
 Varias observaciones:
\layout Enumerate

El acceso a los registros de la CPU es mucho más rápido que el acceso a
 la memoria.
\layout Enumerate

Las variables register se almacenan en los registros si se puede, si no,
 se almacenan en memoria.
\layout Enumerate

Las variables register sólo pueden ser de tipo 
\family typewriter 
int
\family default 
 y 
\family typewriter 
char
\family default 
, y además han de ser locales no estáticas o parámetros de función.
\layout Enumerate

En la mayoría de los sistemas sólo se permiten una o dos variables 
\family typewriter 
register
\family default 
 al mismo tiempo.
 En la práctica, se declaran variables 
\family typewriter 
register
\family default 
 aquéllas que se utilizan como índices en los bucles.
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
/* esta función calcula la potencia de dos números enteros */
\layout Quotation


\family typewriter 
int pot_ent(int base, int exponente)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 register temporal = 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(; exponente; exponente--)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 temporal *= base;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return temporal;
\layout Quotation


\family typewriter 
}
\layout Subsection

Auto 
\layout Standard

Las variables 
\family typewriter 
auto
\family default 
 (automáticas) son todas aquellas variables locales que no son estáticas.
 En la práctica, este especificador de clase de almacenamiento no se utiliza
 nunca, ya que todas las variables locales que no llevan el especificador
 
\family typewriter 
static
\family default 
 son consideradas auto.
\layout Section

Reglas de Ámbito de las funciones
\layout Standard

Las reglas de ámbito de un lenguaje son las reglas que controlan si un fragmento
 de código no tiene o tiene acceso a otro fragmento de código o de datos.
 Si queremos que una función 
\family typewriter 
f()
\family default 
 pueda ser llamada desde dos ficheros distintos, hacemos lo siguiente:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
10 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

/* Fichero 1 */
\newline 
/* Fichero 2 */
\newline 
void f(void);
\newline 
void f(void);
\newline 
void main(void)
\newline 
void f2(void)
\newline 
{
\newline 
{
\newline 

\protected_separator 
 ...
\newline 

\protected_separator 
 ...
\newline 
}
\newline 
}
\newline 
void f(void)
\newline 
f();
\newline 
{
\newline 
{
\newline 

\protected_separator 
 ...
\newline 

\protected_separator 
 ...
\newline 
}
\newline 
}
\layout Standard

Como se observa con las declaraciones (al principio de los dos ficheros)
 y las definiciones (la función 
\family typewriter 
f()
\family default 
 se define al final de primer fichero) ocurre lo mismo que con las declaraciones
 y definiciones de las variables globales.
\layout Section

Argumentos de las Funciones
\layout Standard

Si una función va a usar argumentos, debe declarar variables que tomen los
 valores de las argumentos.
 Como se dijo antes, estas variables se llaman parámetros formales de la
 función.
 Se comportan como otras variables locales dentro de la función, creándose
 al entrar en la función y destruyéndose al salir.
 Los argumentos se pueden pasar a las funciones de dos formas:
\layout Itemize

Llamada por valor: este método copia el valor del argumento en el parámetro
 formal.
\layout Itemize

Llamada por referencia: este método copia la dirección del argumento (que
 ha de ser una variable) en el parámetro formal.
\layout Standard

Los parámetros de la función 
\family typewriter 
printf
\family default 
 son pasados por valor:
\layout Quotation


\family typewriter 
printf("%d", x); /* pasamos el valor de x */
\layout Standard

Los parámetros de la función scanf son pasados por referencia:
\layout Quotation


\family typewriter 
scanf("%d", &x); /* pasamos la dirección de x */
\layout Standard

Ejemplo de programa con función con llamadas por referencia:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void intercambiar(int *px, int *py);
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int x = 2, y = 3;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nx = %d, y = %d", x, y); 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 intercambiar(&x, &y)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nx = %d, y = %d", x, y); 
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
void intercambiar(int *px, int *py) 
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int temporal;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 temporal = *px;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *px = *py;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *py = temporal;
\layout Quotation


\family typewriter 
}
\layout Standard

Comentario de este programa: En lecciones posteriores se van a estudiar
 los punteros (variables que contienen direcciones de memoria) en profundidad,
 pero inevitablemente ya nos hemos vistos obligados a hablar algo de ellos
 en lecciones anteriores, y otra vez vamos a estar obligados a hablar un
 poco más de ellos en este momento si queremos completar nuestro estudio
 sobre las funciones.
 La forma general de declarar un puntero es:
\layout Quotation


\family typewriter 
tipo *nombre_puntero;
\layout Standard

Una variable puntero es una variable que contiene una dirección de memoria.
 Al valor de la dirección de memoria apuntada por un puntero se accede de
 la siguiente manera:
\layout Quotation


\family typewriter 
*nombre_puntero
\layout Standard

La dirección de una variable, como se dijo en lecciones anteriores, se obtiene
 de la siguiente forma:
\layout Quotation


\family typewriter 
&nombre_variable
\layout Standard

En este caso, 
\family typewriter 
*
\family default 
 es el operado de contenido y 
\family typewriter 
&
\family default 
 es el operador de dirección.
 Son monarios.
 No confundir con los operadores binarios de multiplicación (
\family typewriter 
*
\family default 
) y de and a nivel de bits (
\family typewriter 
&
\family default 
).
 Después de lo dicho, estamos en condiciones de comprender el programa anterior.
\layout Standard

Al hacer '
\family typewriter 
intercambiar(&x, &y);
\family default 
' estamos pasando a la función intercambiar las direcciones de las variables
 
\family typewriter 
x
\family default 
 e 
\family typewriter 
y
\family default 
.
 Al hacer la declaración '
\family typewriter 
void intercambiar(int *px, int *py)
\family default 
' estamos declarando dos variables locales 
\family typewriter 
px
\family default 
 e 
\family typewriter 
py
\family default 
 que son punteros a enteros, es decir, que contienen direcciones en las
 cuales hay valores enteros.
 Al hacer '
\family typewriter 
*px
\family default 
' y '
\family typewriter 
*py
\family default 
' estamos accediendo a los valores de tipo entero apuntados por las punteros
 
\family typewriter 
px
\family default 
 y 
\family typewriter 
py
\family default 
, es decir, estamos accediendo a los valores de las variables 
\family typewriter 
x
\family default 
 e 
\family typewriter 
y
\family default 
 de la función 
\family typewriter 
main
\family default 
.
 Hay un caso especial de llamada por referencia que es el paso de arrays
 como argumento de una función.
 También este caso se discutió cuando se describió la función scanf en la
 lección anterior.
 Y también, al igual que los punteros, se desarrollará los arrays en lecciones
 posteriores (concretamente en la lección siguiente).
 Pero, no obstante, hay que hacer algunas observaciones en este momento
 para explicar cómo se pueden pasar como argumento a una función.
\layout Standard

Recordemos que el nombre de la variable array es un puntero al primer elemento
 del array.
 De esta forma cuando se usa un array como un argumento a una función, sólo
 se pasa la dirección del array, no una copia del array entero.
 Cuando se llama a una función con un nombre de array, se pasa a la función
 un puntero al primer elemento del array.
 Existen tres formas de declarar un parámetro que va a recibir un puntero
 a un array.
 Veamos con un ejemplo las tres formas.
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void funcion_ejemplo_1(int a[10]);
\layout Quotation


\family typewriter 
void funcion_ejemplo_2(int a[]); 
\layout Quotation


\family typewriter 
void funcion_ejemplo_3(int *a);
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int array [10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 array[i] = i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 funcion_ejemplo_1(array);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 funcion_ejemplo_2(array);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 funcion_ejemplo_3(array);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
void funcion_ejemplo_1(int a[10]) 
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", a[i]);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
void funcion_ejemplo_2(int a[])
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", a[i];
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
void funcion_ejemplo_3(int *a)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", a[i]);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

En la función 
\family typewriter 
funcion_ejemplo_1()
\family default 
, el parámetro a se declara como un array de enteros de diez elementos,
 el compilador de C automáticamente lo convierte a un puntero a entero.
 Esto es necesario porque ningún parámetro puede recibir un array de enteros;
 de esta manera sólo se pasa un puntero a un array.
 Así, debe haber en las funciones un parámetro de tipo puntero para recibirlo.
 En la función 
\family typewriter 
funcion_ejemplo_2()
\family default 
, el parámetro a se declara como un array de enteros de tamaño desconocido.
 Ya que el C no comprueba los límites de los arrays, el tamaño real del
 array es irrelevante al parámetro (pero no al programa, por supuesto).
 Además, este método de declaración define a como un puntero a entero.
\layout Standard

En la función 
\family typewriter 
funcion_ejemplo_3()
\family default 
, el parámetro a se declara como un puntero a entero.
 Esta es la forma más común en los programas escritos profesionalmente en
 C.
 Esto se permite porque cualquier puntero se puede indexar usando 
\family typewriter 
[]
\family default 
 como si fuese un array.
 (En realidad, los arrays y los punteros están muy relacionados).
 Los tres métodos de declarar un parámetro de tipo array llevan al mismo
 resultado: un puntero.
 Otro ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void funcion_ejemplo(int numero);
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int array [10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 funcion_ejemplo(array[i]);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
void funcion_ejemplo(int numero) 
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", numero);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Subsection

Argumentos de Main
\layout Standard

Algunas veces es útil pasar información al programa cuando se va a ejecutar.
 Los argumentos en la línea de órdenes son las informaciones que siguen
 al nombre del programa en la línea de órdenes del sistema operativo.
 En este caso, la función 
\family typewriter 
main
\family default 
 se declara para recibir dos parámetros especiales, 
\family typewriter 
argc
\family default 
 y 
\family typewriter 
argv
\family default 
, que se utilizan para recibir los argumentos de la línea de órdenes.
\layout Standard

El parámetro 
\family typewriter 
argc
\family default 
 contiene el número de argumentos de la línea de órdenes y es un entero.
 Siempre vale 1, por lo menos, ya que el nombre del programa cuenta como
 el primer agumento.
 El parámetro 
\family typewriter 
argv
\family default 
 es un array donde cada elemento es una cadena de caracteres, la cual contiene
 la información suministrada al programa a través de la línea de órdenes
 del sistema operativo.
 Dicho de otro modo, un array donde cada elemento es un puntero al primer
 elemento de la cadena correspondiente.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa acepta un nombre en la línea de órdenes tras el nombre
 del programa e imprime un mensaje de salutación */
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(int argc, char *argv[])
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 if(argc != 2)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El número de argumentos es incorrecto.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Hola %s.
\backslash 
n", argv[1]);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

En Turbo C, también podemos utilizar un tercer parámetro en la función 
\family typewriter 
main
\family default 
, 
\family typewriter 
arge
\family default 
, con la misma estructura que el parámetro 
\family typewriter 
argv
\family default 
, y que contiene las cadenas del entorno.
 El último elemento del vector 
\family typewriter 
arge
\family default 
 (al igual que en 
\family typewriter 
argv
\family default 
) contiene el valor 
\family typewriter 
NULL
\family default 
; esto indica que el puntero del último elemento de 
\family typewriter 
arge
\family default 
 no apunta a ningún sitio.
 Recordamos que 
\family typewriter 
NULL
\family default 
 es una constante definida en las librerías 
\family typewriter 
<stdio.h>
\family default 
 y 
\family typewriter 
<stdlib.h>
\family default 
 entre otras, y equivale al valor 0.
 
\layout Standard

Los nombres 
\family typewriter 
argc
\family default 
, 
\family typewriter 
argv
\family default 
 y 
\family typewriter 
arge
\family default 
 son una convención ya que pueden tener cualquier nombre válido de un identifica
dor en C.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa acepta una serie de argumentos en la línea de órdenes del
 sistema operativo y los imprime */
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#include <stdio.h> /* printf (), NULL */
\layout Quotation


\family typewriter 
void main(int argc, char *argv[], char *arge[])
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("argc = %d
\backslash 
n", argc);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = 0; i < argc; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("argv[%d] = 
\backslash 
"%s
\backslash 
"
\backslash 
n", i, argv[i]); 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = 0; arge[i] != NULL; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("arge[%d] = 
\backslash 
"%s
\backslash 
"
\backslash 
n", i, arge[i]); 
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Section

Recursividad
\layout Standard

Las funciones en C se pueden llamar a sí mismas.
 Si una expresión en el cuerpo de una función se llama a sí misma, la función
 es recursiva.
 Vamos a escribir dos versiones del cálculo del factorial de un número:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
9 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
unsigned long fact1(int n)
\newline 
unsigned long fact2(int n)
\newline 
{
\newline 
{
\newline 
register int i;
\newline 
unsigned long factorial;
\newline 
unsigned long factorial = 1;
\newline 
if(n <= 1)
\newline 
for(i = 1; i <= n; i++)
\newline 
factorial = 1
\newline 
factorial *= i;
\newline 
else
\newline 
return (factorial);
\newline 
factorial = n * fact2(n-1);
\newline 
}
\newline 
return (factorial);
\newline 

\newline 
}
\layout Standard

La función 
\family typewriter 
fact1
\family default 
 es la versión iterativa y 
\family typewriter 
fact2
\family default 
 es la versión recursiva del cálculo del factorial de un número.
 La versión iterativa tiene dos ventajas sobre la versión recursiva:
\layout Enumerate

Es más rápida.
\layout Enumerate

Consume menos memoria.
\layout Standard

La versión recursiva es preferible en aquellos casos en los que la lógica
 es mucho más clara y sencilla que en la versión iterativa.
 En el ejemplo anterior es preferible la versión iterativa a la recursiva
 ya que la dificultad en la lógica es similar en ambos casos.
 Cuando se escriben funciones recursivas se debe tener una expresión 
\family typewriter 
if
\family default 
 en algún sitio que fuerce a la función a volver sin que se ejecute la llamada
 recursiva.
 Si no se hace así, la función nunca devolverá el control una vez que se
 le ha llamado; esto produce un desbordamiento de la pila.
\layout Section

Separación de un Programa en Varios Ficheros
\layout Standard

En programas grandes es conveniente dividir el código fuente en varios ficheros
 y compilarlos por separados.
 Esto tiene dos grandes ventajas:
\layout Enumerate

Mayor modularidad.
\layout Enumerate

Tiempos de compilación más cortos, ya que cuando modificamos un fichero
 con código fuente, sólo tenemos que compilar ese fichero y enlazar el programa.
\layout Standard

La forma de realizar la compilación separada depende del compilador.
 En Turbo C, la compilación separada se consigue creando un fichero proyecto
 (con extensión 
\family typewriter 
.PRJ
\family default 
) en el cual se listan todos los ficheros fuentes que componen el proyecto.
 En todas las versiones hay una opción para manejar los proyectos: abrirlos,
 cerrarlos, obtener ayuda acerca de ellos, etcétera.
\layout Section

Número Variable de Argumentos
\layout Standard

En la librería 
\family typewriter 
<stdarg.h>
\family default 
 nos encontramos toda la información necesaria para declarar funciones en
 las que el número y el tipo de parámetros es variable.
 Vamos a mostrar inmediatamente un ejemplo y vamos a basar la explicación
 de este apartado sobre el ejemplo.
\layout Quotation


\family typewriter 
#include <stdio.h>
\protected_separator 
 /* vprintf() */
\layout Quotation


\family typewriter 
#include <stdarg.h> /* va_list, va_start(), va_end() */
\layout Quotation


\family typewriter 
void imprimir_cadena_con_formato(char *cadena_de_formato, ...);
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 imprimir_cadena_con_formato("%d %f %s", 5, 2.3, "cadena");
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
void imprimir_cadena_con_formato(char *cadena_de_formato, ...) 
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 va_list puntero_a_los_argumentos;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 va_start(puntero_a_los_argumentos, cadena_de_formato); 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 vprintf(cadena_de_formato, puntero_a_los_argumentos);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 va_end(puntero_a_los_argumentos);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

Si nos fijamos en la declaración de la función 
\family typewriter 
void imprimir_cadena_con_formato(char *cadena_de_formato, ...)
\family default 
 observamos que el primer argumento es una cadena (un puntero al primer
 elemento de la cadena, es decir, un puntero al primer carácter) y a continuació
n tenemos puntos suspensivos (...) que simbolizan que el número y tipo de argumento
s después del primero es variable.
 En la primera línea de la función
\layout Quotation


\family typewriter 
va_list puntero_a_los_argumentos;
\layout Standard

nos encontramos la definición de una variable (
\family typewriter 
puntero_a_los_argumentos
\family default 
) que es del tipo 
\family typewriter 
va_list
\family default 
, es decir, esta variable es un puntero a uno de los argumentos.
 El tipo 
\family typewriter 
va_list
\family default 
 es un tipo definido en la librería 
\family typewriter 
<stdarg.h>
\family default 
.
 En otras lecciones veremos cómo podemos definir nuevos tipos a partir de
 los tipos básicos del lenguaje.
 La siguiente línea de la función en cuestión
\layout Quotation


\family typewriter 
va_start(puntero_a_los_argumentos, cadena_de_formato);
\layout Standard

es una llamada a la función 
\family typewriter 
va_start()
\family default 
.
 Esta función está declarada en la librería 
\family typewriter 
<stdarg.h>
\family default 
 y acepta dos parámetros.
 El primero es de tipo 
\family typewriter 
va_list
\family default 
, es decir, es el puntero a los argumentos, y el segundo parámetro ha de
 ser el parámetro conocido situado más a la derecha en la función en que
 estamos, que en este caso es la cadena de formato.
 La misión de la función 
\family typewriter 
va_start()
\family default 
 es inicializar el puntero a los argumentos.
 A continuación nos encontramos la sentencia
\layout Quotation


\family typewriter 
vprintf(cadena_de_formato, puntero_a_los_argumentos);
\layout Standard

que es una llamada a la función 
\family typewriter 
vprintf()
\family default 
.
 La función 
\family typewriter 
vprintf()
\family default 
 hace lo mismo que la función 
\family typewriter 
printf()
\family default 
 con la diferencia que está basada en una lista de argumentos variables.
 Lo mismo ocurre con las funciones 
\family typewriter 
vscanf()
\family default 
 y 
\family typewriter 
scanf()
\family default 
.
 La última línea de la función en estudio
\layout Quotation


\family typewriter 
va_end(puntero_a_los_argumentos);
\layout Standard

es una llamada a la función 
\family typewriter 
va_end()
\family default 
.
 Esta función está declarada en la librería 
\family typewriter 
<stdarg.h>
\family default 
 y acepta un parámetro que es de tipo 
\family typewriter 
va_list
\family default 
 y debe ser el puntero a los argumentos.
 La misión de la función 
\family typewriter 
va_end()
\family default 
 es finalizar el acceso del puntero a los argumentos.
 Es importante llamar a esta función cuando ya no es necesario utilizar
 el puntero a lo argumentos.
\layout Standard

En la librería 
\family typewriter 
<stdarg.h>
\family default 
 tenemos sólamente cuatro elementos: un tipo (
\family typewriter 
va_list
\family default 
) y tres funciones (
\family typewriter 
va_start()
\family default 
, 
\family typewriter 
va_end()
\family default 
 y 
\family typewriter 
va_arg()
\family default 
).
 La función 
\family typewriter 
va_arg()
\family default 
 que es la que nos queda por explicar la vamos a ver, al igual que las otras,
 con un ejemplo.
\layout Quotation


\family typewriter 
/* Ejemplo de argumento de longitud variable: suma de una serie */
\layout Quotation


\family typewriter 
#include <stdio.h>
\protected_separator 
 /* printf() */
\layout Quotation


\family typewriter 
#include <stdarg.h> /* va_list, va_start(), va_arg(), va_end() */ 
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double d, suma_serie();
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 d = suma_serie(5, 0.5, 0.25, 0.125, 0.0625, 0.03125);
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("La suma de la serie es %f
\backslash 
n", d);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
double suma_serie(int num)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double suma = 0.0, t;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 va_list ptrarg;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 va_start(ptrarg, num);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(; num; num--)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 t = va_arg(ptrarg, double);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 suma += t;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 va_end(ptrarg);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return suma;
\layout Quotation


\family typewriter 
}
\layout Standard

La novedad en este programa es la aparición de la función 
\family typewriter 
va_arg()
\family default 
.
 Esta función está declarada en la librería 
\family typewriter 
<stdarg.h>
\family default 
.
 Acepta dos parámetros: el primero ha de ser el puntero a los argumentos
 y el segundo es el parámetro conocido más a la derecha en la función en
 la que estamos.
 La función 
\family typewriter 
va_arg()
\family default 
 devuelve el argumento al cual el puntero a los argumentos apunta actualmente.
\layout Section

El Preprocesador C
\layout Standard

El preprocesador le da ciertas órdenes al compilador.
 Conceptualmente, el preprocesador procesa el código fuente antes que el
 compilador.
 A las instrucciones del preprocesador se les llama directivas de preprocesamien
to.
 Todas empiezan con el símbolo 
\family typewriter 
#
\family default 
.
 Las directivas del ANSI C son: 
\family typewriter 
#include
\family default 
, 
\family typewriter 
#define
\family default 
, 
\family typewriter 
#undef
\family default 
, 
\family typewriter 
#error
\family default 
, 
\family typewriter 
#if
\family default 
, 
\family typewriter 
#else
\family default 
, 
\family typewriter 
#elif
\family default 
, 
\family typewriter 
#endif
\family default 
, 
\family typewriter 
#ifdef
\family default 
, 
\family typewriter 
#ifndef
\family default 
, 
\family typewriter 
#line
\family default 
 y 
\family typewriter 
#pragma
\family default 
.
\layout Subsection

Directiva #include 
\layout Standard

Cuando el preprocesador encuentra un comando 
\family typewriter 
#include
\family default 
 busca el fichero que atiende por el nombre que está situado detrás y lo
 incluye en el fichero actual.
 El nombre del fichero puede venir de dos formas:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
#include "mifichero.h"
\layout Standard

El primer 
\family typewriter 
#include
\family default 
 busca el fichero 
\family typewriter 
stdio.h
\family default 
 en los directorios del sistema.
 El segundo 
\family typewriter 
#include
\family default 
 busca el fichero en el directorio en el que se está trabajando.
 Si se incluye path, lo busca en el directorio especificado: 
\family typewriter 
#include "c:
\backslash 
programa
\backslash 
prog.h"
\family default 
.
 Ejemplo:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
/* Fichero p.h */
\newline 
/* Fichero p.c */
\newline 
void f(void);
\newline 
#include "p.h"
\newline 
void main(void) 
\newline 
 void f(void)
\newline 
{
\newline 
{
\newline 

\protected_separator 

\protected_separator 
f();
\newline 
}
\newline 
}
\newline 

\layout Standard

Conceptualmente, una vez que este programa (compuesto de dos ficheros) ha
 sido procesado por el preprocesador, el compilador encuentra un solo fichero:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
/* Fichero p.c */
\newline 
/* Fichero p.h */
\newline 
void f(void)
\newline 
void f(void)
\newline 
void main(void) 
\newline 
{
\newline 
{
\newline 
}
\newline 

\protected_separator 

\protected_separator 
f()
\newline 

\newline 
}
\newline 

\layout Subsection

Directiva #define 
\layout Standard

La directiva 
\family typewriter 
#define
\family default 
 sustituye en el código fuente un determinado identificador por la cadena
 especificada.
 Tiene dos formas.
 La primera de ellas es:
\layout Quotation


\family typewriter 
#define identificador cadena
\layout Standard

A este identificador se le llama nombre de macro o simplemente macro.
 Esta directiva hace que a partir de la definición de la macro, cada vez
 que el preprocesador encuentre identificador en el código fuente, lo sustituya
 por cadena.
 Las directivas no son sentencias C, por eso no llevan puntos y coma al
 final.
 La cadena abarca desde el primer carácter no blanco después de identificador
 hasta el final de la línea.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#define BOOLEAN short
\layout Quotation


\family typewriter 
#define TRUE 1
\layout Quotation


\family typewriter 
#define FALSE 0
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 BOOLEAN v = TRUE;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d %d", v, FALSE);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

Cuando el preprocesador procesa este programa, el compilador se encuentra:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 short v = 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d %d", v, 0);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

En realidad, en este ejemplo, el procesador también sustituiría la línea
 del 
\family typewriter 
#include
\family default 
 por el contenido del fichero 
\family typewriter 
stdio.h
\family default 
, pero lo hemos obviado porque en este momento estamos explicando la directiva
 
\family typewriter 
#define
\family default 
 y además el contenido del fichero 
\family typewriter 
stdio.h
\family default 
 depende de cada implementación de compilador de C.
\layout Standard

Por convención y para distinguir un lector las macros de los demás identificador
es del C, éstas se suelen escribir en mayúsculas.
 Las macros pueden ser utilizadas como parte de la definición de otras macros.
 Por ejemplo:
\layout Quotation


\family typewriter 
#define UNO
\protected_separator 
 1
\layout Quotation


\family typewriter 
#define DOS
\protected_separator 
 UNO + UNO
\layout Quotation


\family typewriter 
#define TRES UNO + DOS
\layout Standard

Es importante comprender que la sustitución es simplemente el reemplazamiento
 de un identificador por su cadena asociada.
 Así se puede hacer:
\layout Quotation


\family typewriter 
#define ERROR "Se ha producido un error"
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
printf(ERROR);
\layout Standard


\emph on 
RECOMENDACION IMPORTANTE
\emph default 
: siempre que se pueda es conveniente encerrar la definición de la macro
 entre paréntesis.
 Obsérvese en el siguiente ejemplo lo que puede ocurrir de no hacerse así:
\layout Quotation


\family typewriter 
#define CUATRO 2+2
\layout Quotation


\family typewriter 
/* ...
 */
\layout Quotation


\family typewriter 
x = CUATRO * CUATRO;
\layout Standard

El preprocesador expande la asignación de x a:
\layout Quotation


\family typewriter 
x = 2+2 * 2+2;
\layout Standard

Si se hubiese definido la macro CUATRO de la forma:
\layout Quotation


\family typewriter 
#define CUATRO (2+2)
\layout Standard

la expansión de la asignación de 
\family typewriter 
x
\family default 
 es:
\layout Quotation


\family typewriter 
x = (2+2) * (2+2);
\layout Standard

Como se ve, en el primer caso se asigna el valor 8 a la variable 
\family typewriter 
x
\family default 
, mientras que en el segundo se asigna el valor 16 a la variable 
\family typewriter 
x
\family default 
 que es lo que realmente se desea.
 Si el identificador aparece dentro de una cadena no se lleva a cabo sustitucion
es.
 Por ejemplo:
\layout Quotation


\family typewriter 
#define XYZ esto es una prueba
\layout Quotation


\family typewriter 
/* ...
 */
\layout Quotation


\family typewriter 
printf ("XYZ");
\layout Standard

El código anterior no imprime 
\family typewriter 
;
\family default 
 imprime 
\family typewriter 
.

\family default 
 
\layout Standard

Cuando la cadena es más larga de una línea, se puede continuar en la siguiente
 poniendo una barra invertida al final de la línea.
 Por ejemplo:
\layout Quotation


\family typewriter 
#define MACRO 
\backslash 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 if(x < y)
\protected_separator 
 
\backslash 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 f1();
\protected_separator 

\protected_separator 

\protected_separator 
 
\backslash 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 else
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\backslash 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 f2();
\layout Standard

La segunda forma de la directiva 
\family typewriter 
#define
\family default 
 es:
\layout Quotation


\family typewriter 
#define id1(id2,...) cadena
\layout Standard

El paréntesis ha de ir inmediatamente después de 
\family typewriter 
id1
\family default 
 ya que si no pertene cería a la cadena.
 Todas las instancias de 
\family typewriter 
id2
\family default 
 en cadena serán reemplazadas con el texto actual definido por 
\family typewriter 
id2
\family default 
 cuando 
\family typewriter 
id1
\family default 
 es referenciado en el código fuente.
 Ejemplo:
\layout Quotation


\family typewriter 
#define SUMA(a,b)
\protected_separator 
 a + b
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
/* ...
 */
\layout Quotation


\family typewriter 
x = SUMA (5, 8);
\layout Standard

Esto expande a:
\layout Quotation


\family typewriter 
x = 5 + 8;
\layout Standard

Observar que en el 
\family typewriter 
#define
\family default 
 es obligatorio que el paréntesis vaya junto a 
\family typewriter 
SUMA
\family default 
; sin embargo, cuando se llama a la macro no es obligatorio que el paréntesis
 abierto vaya junto a 
\family typewriter 
SUMA
\family default 
.
\layout Description

RECOMENDACION
\protected_separator 
IMPORTANTE: se recomienda que todos los argumentos de la macro en la cadena
 vayan entre paréntesis para prevenir casos como el siguiente:
\layout Quotation


\family typewriter 
#define PRODUCTO(a,b) (a * b)
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
/* ...
 */
\layout Quotation


\family typewriter 
x = PRODUCTO (2+3, 4);
\layout Standard

Esto expande la asignación de la x a:
\layout Quotation


\family typewriter 
x = (2+3 * 4);
\layout Standard

Si se hubiese definido la macro de la forma:
\layout Quotation


\family typewriter 
#define PRODUCTO(a,b)
\protected_separator 
 ((a) * (b))
\layout Standard

entonces la asignación de la 
\family typewriter 
x
\family default 
 se expandiría a:
\layout Quotation


\family typewriter 
x = ((2+3) * (4));
\layout Standard

Como se ve, en el primer caso se asigna el valor 14 a la variable 
\family typewriter 
x
\family default 
, mientras que en el segundo se asigna el valor 20 a la variable 
\family typewriter 
x
\family default 
 que es lo que realmente se desea.
 Otros ejemplos de macros:
\layout Quotation


\family typewriter 
#define MIN(a,b) ((a) < (b) ? (a) : (b))
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#define MAX(a,b) ((a) > (b) ? (a) : (b))
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
#define ESTA_ENTRE(x,x1,x2) ((x) >= (x1) && (x) <= (x2))
\layout Standard

A las macros sin argumentos también se les llama constantes simbólicas e
 incluso, en algunos sitios, simplemente constantes.
 Constantes simbólicas ya vistas son 
\family typewriter 
EOF
\family default 
 y 
\family typewriter 
NULL
\family default 
.
 Las funciones 
\family typewriter 
va_arg()
\family default 
, 
\family typewriter 
va_start()
\family default 
 y 
\family typewriter 
va_end()
\family default 
 vistas anteriormente, son macros en algunas implementaciones, pero esto
 es transparente para el usuario.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Fichero prog_ej.h */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#define funcion_principal main
\layout Quotation


\family typewriter 
#define principio {
\layout Quotation


\family typewriter 
#define final }
\layout Quotation


\family typewriter 
#define numero_entero int
\layout Quotation


\family typewriter 
#define escribir_cadena(cadena) printf(cadena)
\layout Quotation


\family typewriter 
#define escribir_numero_entero(numero) printf("%d", numero);
\layout Quotation


\family typewriter 
#define leer_numero_entero(numero) scanf("%d", &numero);
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
/* Fichero prog_ej.c */
\layout Quotation


\family typewriter 
#include "prog_ej.h"
\layout Quotation


\family typewriter 
void funcion_principal(void)
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
principio
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 numero_entero x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 escribir_cadena("Introduce un número: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 leer_numero_entero(x);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 escribir_cadena("x = ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 escribir_numero_entero(x);
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
final
\layout Standard

El uso de macros con argumentos en lugar de funciones reales tiene principalment
e una ventaja: las sustituciones incrementan la velocidad del código porque
 no se gasta tiempo en llamar a la función.
 Sin embargo, hay que pagar un precio por el aumento de velocidad: el tamaño
 del programa aumenta debido a la duplicación del código.
\layout Subsection

Directiva #undef 
\layout Standard

La directiva 
\family typewriter 
#undef
\family default 
 elimina una definición anterior de la macro que le sigue.
 La forma general es:
\layout Quotation


\family typewriter 
#undef identificador
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#define TAMANIO_ARRAY 100
\layout Quotation


\family typewriter 
int array [TAMANIO_ARRAY];
\layout Quotation


\family typewriter 
#undef TAMANIO_ARRAY
\layout Quotation


\family typewriter 
/* aquí no existe la macro TAMANIO_ARRAY */
\layout Subsection

Directiva #error 
\layout Standard

La directiva del preprocesador 
\family typewriter 
#error
\family default 
 fuerza al compilador a parar la compilación y escribir un mensaje de error.
 Tiene la forma general:
\layout Quotation


\family typewriter 
#error mensaje
\layout Standard

Ver un ejemplo de esta directiva al final de la descripción de las directivas
 
\family typewriter 
#if
\family default 
, 
\family typewriter 
#else
\family default 
, 
\family typewriter 
#elif
\family default 
 y 
\family typewriter 
#endif
\family default 
.
\layout Subsection

Directivas #if, #else, #elif y #endif 
\layout Standard

Estas directivas permiten compilar selectivamente parte del código fuente
 de un programa.
 Este proceso se llama compilación condicional.
 La forma general del bloque 
\family typewriter 
#if
\family default 
 es:
\layout Quotation


\family typewriter 
#if expresion_constante
\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Standard

y la forma del bloque 
\family typewriter 
#if-#else
\family default 
 es:
\layout Quotation


\family typewriter 
#if expresion_constante
\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Standard

La expresión que sigue a 
\family typewriter 
#if
\family default 
 se evalúa en tiempo de compilación, por eso ha de ser una expresión constante
 (que no contiene variables).
 Si la evaluación de la expresión es cierta, es decir, es 1, entonces se
 compilan la secuencia de sentencias que le siguen; en caso contrario, se
 compila la secuencia de sentencias siguientes al 
\family typewriter 
#else
\family default 
 si existe, o las sentencias siguientes al 
\family typewriter 
#endif
\family default 
 si no hay 
\family typewriter 
#else
\family default 
.
 Ejemplo del bloque 
\family typewriter 
#if
\family default 
:
\layout Quotation


\family typewriter 
#if SISTEMA == IBM
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #include "ibm.h"
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Standard

Ejemplo del bloque #if-#else:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#define MAX 10
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
main()
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #if MAX > 100
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 puts("Compilación 1");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 puts("Compilación 2");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #endif
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

La directiva 
\family typewriter 
#elif
\family default 
 quiere decir 
\family typewriter 
else if
\family default 
 y establece una escala del tipo 
\family typewriter 
if-else-if
\family default 
 para opciones de compilación múltiples.
 La directiva 
\family typewriter 
#elif
\family default 
, al igual que la 
\family typewriter 
#if
\family default 
, va seguida de una expresión constante.
 Si la expresión es cierta, ese bloque de código se compila y no se comprueba
 ninguna expresión 
\family typewriter 
#elif
\family default 
 más.
 En otro caso, se comprueba el bloque siguiente de la serie.
 La forma general de una secuencia 
\family typewriter 
#elif
\family default 
 es:
\layout Quotation


\family typewriter 
#if expresión
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias
\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#elif expresión 1
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias 1
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#elif expresión 2
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias 2
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#elif expresión 3
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias 3
\layout Quotation


\family typewriter 

\protected_separator 
 .
\layout Quotation


\family typewriter 

\protected_separator 
 .
\layout Quotation


\family typewriter 

\protected_separator 
 .
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#elif expresión N
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias N
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Standard

Las directivas 
\family typewriter 
#if
\family default 
 y 
\family typewriter 
#elif
\family default 
 se pueden anidar.
 Ejemplo:
\layout Quotation


\family typewriter 
#if X > Y
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #if X > Z
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int xyz = 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #elif
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int xyz = 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #endif
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int xyz = 3;
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Standard

La expresión constante puede contener también el operador 
\family typewriter 
sizeof
\family default 
.
\layout Standard

En Turbo C, existe un operador, 
\family typewriter 
defined
\family default 
, que puede ser utilizada en las expresiones de estas directivas.
 La forma general es:
\layout Quotation


\family typewriter 
defined identificador
\layout Standard

o
\layout Quotation


\family typewriter 
defined (identificador)
\layout Standard

La expresión formada por este operador es 1 si identificador ha sido previamente
 definido (usando 
\family typewriter 
#define
\family default 
) y no ha sido después indefinido (usando 
\family typewriter 
#undef
\family default 
).
 En otro caso, este operador devuelve 0.
 Este operador sólo puede ser utilizado en las directivas 
\family typewriter 
#if
\family default 
 y 
\family typewriter 
#elif
\family default 
.
\layout Standard

Ejemplo 1:
\layout Quotation


\family typewriter 
#if defined(X)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 v = 1;
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#elif defined(Y)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 v = 2;
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #error Ni X ni Y han sido definidos.
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Standard

Ejemplo 2:
\layout Quotation


\family typewriter 
#if !defined(MODELO)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #error Modelo no definido
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Subsection

Directivas #ifdef y #ifndef 
\layout Standard

Estas directivas, al igual que las 
\family typewriter 
#if
\family default 
 y 
\family typewriter 
#elif
\family default 
, son directivas de compilación condicional.
 La forma general de 
\family typewriter 
#ifdef
\family default 
 es:
\layout Quotation


\family typewriter 
#ifdef identificador
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Standard


\family typewriter 
#ifdef
\family default 
 significa .
 Si se ha definido previamente identificador en una sentencia 
\family typewriter 
#define
\family default 
, se compila el bloque de código que sigue a la sentencia.
 Ejemplo:
\layout Quotation


\family typewriter 
#ifdef DEBUG
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Espacio total %d
\backslash 
n", espacio);
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Standard

La forma general es 
\family typewriter 
#ifndef
\family default 
 es:
\layout Quotation


\family typewriter 
#ifndef identificador
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 secuencia de sentencias
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Standard


\family typewriter 
#ifndef
\family default 
 significa .
 Si no se ha definido previamente identificador mediante una sentencia 
\family typewriter 
#define
\family default 
, se compila el bloque de código.
 Ejemplo:
\layout Quotation


\family typewriter 
#ifndef ABC
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("ABC no definido");
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Subsection

Directiva #line 
\layout Standard

La directiva 
\family typewriter 
#line
\family default 
 hace que el compilador crea que el número de línea de la próxima línea
 a la que está esta directiva, sea la dada por 
\family typewriter 
<constante>
\family default 
, y el fichero de entrada corriente sea el dado por 
\family typewriter 
<identificador>
\family default 
.
 La forma general es:
\layout Quotation


\family typewriter 
#line <constante> [<identificador>]
\layout Standard

Si 
\family typewriter 
<identificador>
\family default 
 no es un nombre correcto de fichero, el nombre del fichero corriente no
 es cambiado.
 Ejemplo:
\layout Quotation


\family typewriter 
#line 100
\protected_separator 

\protected_separator 

\protected_separator 
 /* reinicializa el contador de líneas */
\layout Quotation


\family typewriter 
main()
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* línea 100 */
\layout Quotation


\family typewriter 

\protected_separator 
 {
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* línea 101 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d
\backslash 
n", __LINEA__); /* línea 102 */
\layout Quotation


\family typewriter 

\protected_separator 
 }
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* línea 103 */
\layout Standard


\family typewriter 
__LINE__
\family default 
 es una macro predefinida que contiene el número de la línea de código fuente
 actual.
 
\family typewriter 
__FILE__
\family default 
 es una macro predefinida que contiene el nombre del fichero fuente actual.
 La macro 
\family typewriter 
#line
\family default 
 lo que hace es cambiar los contenidos de estas dos macros.
\layout Subsection

Directiva #pragma 
\layout Standard

La directiva 
\family typewriter 
#pragma
\family default 
 es una directiva definida por la implementación que permite que se den
 varias instrucciones al compilador.
 La forma general es:
\layout Quotation


\family typewriter 
#pragma <nombre_de_directiva>
\layout Standard

Las instrucciones que se dan con esta directiva son dependientes del compilador.
 
\layout Standard

Esto también ocurre con cada versión de Turbo C.
 Comprueba el manual de usuario o la ayuda del entorno integrado de los
 distintos compiladores de Turbo C para los detalles y opciones de esta
 directiva.
\layout Section

Nombres de Macros Predefinidas
\layout Standard

El estándar ANSI propone cinco macros predefinidas:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
10 3 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
0 0 0 0
1 0 0 0
1 0 0 0
0 0 0 0
1 0 0 0
0 0 0 0
1 0 0 0
0 1 0 0
8 1 0 "" ""
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Macro
\newline 
Tipo
\newline 
Qué contiene
\series default 

\newline 
__DATE__
\newline 
Literal string
\newline 
Contiene una cadena de la forma mes/día/año que en la fecha
\newline 

\newline 

\newline 
fecha de conversión del código fuente a código fuente
\newline 
__FILE__
\newline 
Literal string
\newline 
Contiene una cadena con el nombre del fichero fuente actual
\newline 
__LINE__
\newline 
Constante decimal
\newline 
Constante Contiene el número de la línea actual del fichero
\newline 

\newline 

\newline 
fuente que está siendo procesado
\newline 
__STDC__
\newline 
Constante
\newline 
Contiene un 1 si la implementación es estándar y cualquier
\newline 

\newline 

\newline 
otro número si la implementación varía de la estándar
\newline 
__TIME__
\newline 
Literal string
\newline 
Contiene una cadena de la forma horas:minutos:segundos que es
\newline 

\newline 

\newline 
la hora de conversión del código fuente al código objeto
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
/* Fichero EJ.C: Programa ejemplo para probar las constantes predefinidas
 */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #include <stdio.h>
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n__DATE__ : %s", __DATE__);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n__FILE__ : %s", __FILE__);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n__LINE__ : %d", __LINE__);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n__TIME__ : %s", __TIME__);
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #ifdef __STDC__
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n__STDC__ : %d", __STDC__);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #endif
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

La salida de este programa en mi implementación es:
\layout Quotation


\family typewriter 
__DATE__ : Feb 23 1993
\layout Quotation


\family typewriter 
__FILE__ : EJ.C
\layout Quotation


\family typewriter 
__LINE__ : 12
\layout Quotation


\family typewriter 
__TIME__ : 16:20:59
\layout Standard

Las versiones de Turbo C tienen bastante más constantes simbólicas predefinidas
 pero como varían en cada sección, no son muy utilizadas por el usuario
 medio y requieren conocimientos más profundos del sistema que hasta aquí
 citados, no las vamos a ver.
 Consulta el manual de usuario o la ayuda del entorno integrado del compilador
 de Turbo C que usas.
 Aunque hay una en todas las versiones de Turbo C que sí es útil: 
\layout Quotation


\family typewriter 
__TURBOC__
\layout Standard

El valor de esta macro es distinto para cada versión de Turbo C, por lo
 tanto, tiene dos usos principales: 1) Para saber si estamos compilando
 en Turbo C o en cualquier otro compilador.
 2) Para saber con qué versión de Turbo C estamos compilando.
 Ejemplo:
\layout Quotation


\family typewriter 
#ifdef __TURBOC__
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #include <conio.h> /* highvideo(), cputs() */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #define alta_intensidad() highvideo()
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #define escribir(cadena) cputs(cadena)
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #include <stdio.h> /* puts() */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #define alta_intensidad()
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #define escribir(cadena) puts(cadena)
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
#endif
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 alta_intensidad(); /* se expande a nada si no Turbo C */ 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 escribir("Este mensaje está en alta intensidad ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 escribir("si está compilado en Turbo C.");
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

El ejemplo anterior se puede compilar en cualquier compilador de C, pero
 si se compila en uno de Borland el mensaje aparecerá en alta intensidad
 y si se compila en cualquier otro aparecerá con intensidad normal.
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 5-1.
 Probabilidades binomiales.
\layout Quote

La función factorial sirve, entre otras cosas, para calcular las probabilidades
 binomiales, como ilustra este ejemplo: Un empleado coge todos los días
 un determinado tren para ir a trabajar, pero sabe que existe cierta probabilida
d de que ese tren sea anulado.
 Teniendo en cuenta esa probabilidad, ¿cuáles son las de que en una semana
 sean cancelados 0, 1, 2 y hasta 5 trenes?.
 Suponiendo que la cancelación del tren en un día cualquiera es independiente
 de lo que haya ocurrido en días anteriores, la fórmula que determina las
 probabilidades pedidas es:
\begin_deeper 
\layout Quotation

c = 
\begin_inset Formula \( \frac{n!}{(n-r!)*r!} \)
\end_inset 

 * p
\begin_inset Formula \( ^{r} \)
\end_inset 

 * (1-p)
\begin_inset Formula \( ^{n-r} \)
\end_inset 


\end_deeper 
\layout Quote

(
\series bold 
Nota
\series default 
: Donde p es la probabilidad de que se cancele un tren, r el número de cancelaci
ones en una semana (0, 1, 2, ..., 5), n es el número de jornadas laborales
 de la semana (5 en este caso) y c es la probabilidad de que se produzcan
 r cancelaciones.
\layout Quote

Escriba un programa que acepte la introducción de la probabilidad p, verifique
 si está en el intervalo 0-1 y calcule el valor de c para los valores de
 r comprendidos entre 0 y 5 (es decir, las probabilidades de que se cancelen
 0, 1, 2, ...
 hasta 5 trenes).
\layout Quote

(
\series bold 
Nota
\series default 
: realizar tres funciones además de la función main: c(), factorial() y
 potencia()).
\layout Itemize


\series bold 
Ejercicio 5-2.
 Cálculo del número de Fibonacci.

\series default 
 
\layout Quote

El número de Fibonacci viene dado por la siguiente función:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | 0
\layout Quotation


\family typewriter 

\protected_separator 
FIB(n) = + 1
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | FIB(n-1) + FIB(n-2)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Quote

Realizar una función que calcule el número de Fibonacci.
 Hacerlo en dos versiones: una iterativa y otra recursiva.
\layout Itemize


\series bold 
Ejercicio 5-3.
 Cálculo del máximo común divisor.
\layout Quote

Un algoritmo muy conocido que halla el máximo común divisor de dos enteros
 es el algoritmo de Euclides.
 La función del máximo común divisor se define de la siguiente forma
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | GCD(N,M),
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 si N>M
\layout Quotation


\family typewriter 

\protected_separator 
GCD(M,N) = + M,
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 si N=0
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | GCD(N,M MOD N), si N>0
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Quote

donde M MOD N es M módulo N (el resto de dividir M por N).
 Constrúyase una función recursiva para este problema y obtener el GCD(20,6).
\layout Itemize


\series bold 
Ejercicio 5-4.
 Cálculo de la raiz cuadrada de un número.
\layout Quote

Escribir una función recursiva que calcule la raíz cuadrada de un número.
 Leer las triplas de números N, A y E, donde N es el número del cual tiene
 que hallarse su raíz cuadrada, A es un valor aproximado de la raíz cuadrada
 y E es el error de tolerancia del resultado.
 Utilícese esta función, definida por
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | A,
\layout Quotation


\family typewriter 

\protected_separator 
ROOT(N,A,E) = +
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 si |A*A-N|<E
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | ROOT(N,((A*A)+N)/(2*A),E), en caso contrario
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Itemize


\series bold 
Ejercicio 5-5.
 Cálculo de la función de Ackerman.
\layout Quote

Una importante función teórica, que se conoce por función de Ackerman, viene
 definida por
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | N+1,
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 si M=0
\layout Quotation


\family typewriter 

\protected_separator 
A(M,N) = + A(M-1,1),
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 si N=0
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | A(M-1,A(M,N-1)), en caso contrario
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Quote

Obtener una función recursiva y otra iterativa del problema.
\layout Itemize


\series bold 
Ejercicio 5-6.
 Cálculo del número de particiones distintas de un número entero.
\layout Quote

Ciertas aplicaciones necesitan conocer el número de particiones distintas
 de un número entero dado N; es decir, de cuantas formas distintas se puede
 expresar N como suma de sumandos enteros.
 Por ejemplo, N=5 admite las particiones
\layout Quotation

1+1+1+1+1, 5, 1+2+2, 3+1+1, 2+3, 1+4, y 1+1+1+2
\layout Quote

Si denotamos por Q(M,N) el número de formas en que el entero M se puede
 expresar como una suma, de sumandos no superiores a N, entonces el número
 de particiones de N viene dado por Q(M,N).
 La función Q(M,N) viene definida recursivamente por
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | 1,
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 si M=1 y para todo N
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | 1,
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 si N=1 y para todo M
\layout Quotation


\family typewriter 

\protected_separator 
Q(M,N) = + Q(M,M),
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 si M<N
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | 1+Q(M,M-1),
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 si M=N
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 | Q(M,N-1)+Q(M-N,N), si M>N
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 +
\layout Quote

Formular una función recursiva de este problema.
\layout Itemize


\series bold 
Ejercicio 5-7.
 Supresión de elementos duplicados en un vector.
\layout Quote

Diséñese una función que acepte como parámetro un vector que contenga elementos
 duplicados.
 La función tiene que sustituir cada valor repetido por -1.
 La función devuelve el número de elementos modificados.
\layout Chapter

Arrays
\layout Standard

El objetivo de esta lección es hacer un estudio completo en todo lo referente
 a la declaración, utilización e inicialización de arrays, tanto unidimensionale
s, bidimensionales como multidimensionales.
 Los puntos que detallaremos son:
\layout Itemize

Definición del concepto de array.
\layout Itemize

Arrays unidimensionales (vectores).
 Cadenas de caracteres.
\layout Itemize

Arrays bidimensionales (matrices).
 Arrays de cadenas.
\layout Itemize

Arrays multidimensionales.
\layout Itemize

Arrays y punteros.
\layout Itemize

Inicialización de arrays.
\layout Description


\size larger 
Arrays 
\layout Standard

Un array es una colección de variables del mismo tipo que se referencia
 por un nombre común.
 A un elemento específico de un array se accede mediante un índice.
 En C todos los arrays constan de posiciones de memoria contiguas.
 La dirección más baja corresponde al primer elemento y la dirección más
 alta al último elemento.
 Los arrays pueden tener de una a varias dimensiones.
\layout Section

Arrays Unidimensionales
\layout Standard

La forma general de declaración de un array unidimensional es:
\layout Quotation


\family typewriter 
especificador_de_tipo
\protected_separator 
 nombre_variable
\protected_separator 
 [tamaño];
\layout Standard

donde 
\family typewriter 
especificador_de_tipo
\family default 
 es el tipo base, es decir, el tipo de cada elemento y tamaño es el número
 de elementos del array.
 La forma general de acceder a un elemento del array es:
\layout Quotation


\family typewriter 
nombre_variable [indice]
\layout Standard

La longitud en bytes de un array se calcula mediante la fórmula:
\layout Quotation


\family typewriter 
total_de_bytes = sizeof (tipo) * numero_de_elementos
\layout Subsection

Indices de los Arrays Unidimensionales
\layout Standard

En C todas los arrays tienen el cero como índice de su primer elemento.
 Por tanto, cuando se escribe
\layout Quotation


\family typewriter 
char v[10];
\layout Standard

se está declarando un array de 10 elementos de tipo entero y el array va
 de 
\family typewriter 
v[0]
\family default 
 a 
\family typewriter 
v[9]
\family default 
.
 C no comprueba los límites de los arrays.
 Esto quiere decir que si hacemos 
\family typewriter 
v[20]
\family default 
 para el array anterior, el C no nos va a informar de ningún error.
 Es responsabilidad del programador el indexamiento correcto de un array.
\layout Subsection

Paso de Arrays Unidimensionales como Parámetros
\layout Standard

Hay tres formas de pasar un array unidimensional como parámetro a una función.
 Consultar el apartado '
\series bold 
ARGUMENTOS DE LAS FUNCIONES
\series default 
' de la lección anterior para recordar cuáles son las tres formas.
\layout Subsection

Utilización de Arrays Unidimensionales como Cadenas
\layout Standard

El uso más común de los arrays unidimensionales es, con mucho, como cadena
 de caracteres.
 En C una cadena se define como un array de caracteres que termina en un
 carácter nulo.
 Un carácter nulo se especifica como 
\family typewriter 
'
\backslash 
0'
\family default 
 y generalmente es un cero.
 Por esta razón, para declarar arrays de caracteres es necesario que sean
 de un carácter más que la cadena más larga que pueda contener.
 Por ejemplo, si se desea declarar un array s para contener una cadena de
 10 caracteres, se escribirá
\layout Quotation


\family typewriter 
char s[11];
\layout Standard

En C, todo lo que esté encerrado entre comillas es una constante de cadena.
 Por ejemplo:
\layout Quotation


\family typewriter 
"cadena"
\layout Standard

En las constantes de cadenas no es necesario añadir explícitamente el carácter
 nulo, pues el compilador de C lo hace autómaticamente.
\layout Section

Arrays Bidimensionales
\layout Standard

Un array bidimensional es, en realidad, un array unidimensional donde cada
 elemento es otro array unidimensional.
 Los arrays bidimensionales son un caso particular de los arrays multidimensiona
les.
 Así como a los arrays unidimensionales se les suele llamar vectores, a
 los arrays bidimensionales se les suele llamar matrices.
 La forma general de declaración es:
\layout Quotation


\family typewriter 
especificador_de_tipo nombre_variable [tamaño_1] [tamaño_2];
\layout Standard

y se accede a los elementos del array:
\layout Quotation


\family typewriter 
nombre_variable [indice_1] [indice_2]
\layout Description


\size larger 
Ejemplo
\protected_separator 
de
\protected_separator 
Array
\protected_separator 
Bidimensional
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 #include <stdio.h>
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 #define num_filas
\protected_separator 

\protected_separator 

\protected_separator 
 4
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 #define num_columnas 7
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int i, j, matriz [num_filas] [num_columnas]; 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < num_filas; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 for(j = 0; j < num_columnas; j++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 matriz[i][j] = i + j;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < num_filas; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 for(j = 0; j < num_columnas; j++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%2d ", matriz[i][j]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 putchar('
\backslash 
n');
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 
}
\layout Description


\size larger 
SALIDA
\protected_separator 
DEL
\protected_separator 
EJEMPLO 
\layout Quotation


\family typewriter 
0
\protected_separator 
 1
\protected_separator 
 2
\protected_separator 
 3
\protected_separator 
 4
\protected_separator 
 5
\protected_separator 
 6
\layout Quotation


\family typewriter 
1
\protected_separator 
 2
\protected_separator 
 3
\protected_separator 
 4
\protected_separator 
 5
\protected_separator 
 6
\protected_separator 
 7
\layout Quotation


\family typewriter 
2
\protected_separator 
 3
\protected_separator 
 4
\protected_separator 
 5
\protected_separator 
 6
\protected_separator 
 7
\protected_separator 
 8
\layout Quotation


\family typewriter 
3
\protected_separator 
 4
\protected_separator 
 5
\protected_separator 
 6
\protected_separator 
 7
\protected_separator 
 8
\protected_separator 
 9
\layout Subsection

Tamaño en Bytes de un Array Bidimensional
\layout Standard

El tamaño en bytes de una matriz se calcula mediante la fórmula 
\layout Quotation


\family typewriter 
bytes_de_memoria = fila * columna * sizeof (tipo)
\layout Subsection

Paso de un Array Bidimensional como Argumento a una Función
\layout Standard

El nombre de un array bidimensional es un puntero al primer elemento del
 array (
\family typewriter 
[0][0]
\family default 
).
 Para pasar un array bidimensional como argumento a una función se pasa
 el puntero al primer elemento.
 Sin embargo, la función que recibe un array bidimensional como parámetro
 tiene que definir al menos la longitud de la segunda dimensión.
 Esto es necesario debido a que el compilador de C necesita conocer la longitud
 de cada fila para indexar el array correctamente.
\layout Description


\size larger 
MISMO
\protected_separator 
EJEMPLO
\protected_separator 
DE
\protected_separator 
ANTES
\protected_separator 
PERO
\protected_separator 
CON
\protected_separator 
ARRAYS
\protected_separator 
COMO
\protected_separator 
ARGUMENTOS 
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#define num_filas 4
\layout Quotation


\family typewriter 
#define num_columnas 7
\layout Quotation


\family typewriter 
void rellenar_matriz(int m[][]), imprimir_matriz (int m[][]);
\protected_separator 
 
\layout Quotation


\family typewriter 
int i, j;
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int matriz [num_filas] [num_columnas];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 rellenar_matriz(matriz);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 imprimir_matriz(matriz);
\layout Quotation


\family typewriter 
}
\layout Description


\size larger 
MISMO
\protected_separator 
EJEMPLO
\protected_separator 
DE
\protected_separator 
ANTES
\protected_separator 
PERO
\protected_separator 
CON
\protected_separator 
ARRAYS
\protected_separator 
COMO
\protected_separator 
ARGUMENTOS 
\layout Quotation


\family typewriter 
void rellenar_matriz(int m[][num_columnas])
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < num_filas; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 for(j = 0; j < num_columnas; j++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 m[i][j] = i + j;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void imprimir_matriz(int m[][num_columnas])
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < num_filas; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 for(j = 0; j < num_columnas; j++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%2d ", m[i][j]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 putchar('
\backslash 
n');
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 
}
\layout Section

Arrays de Cadenas
\layout Standard

En C es necesario a veces la utilización de un array de cadenas.
 Recordar el 
\family typewriter 
argv
\family default 
 de la función 
\family typewriter 
main
\family default 
 visto en la lección anterior.
 Vemos un ejemplo de declaración de un array de 100 elementos en el que
 cada elemento va a contener una cadena de caracteres de 50 caracteres como
 máximo:
\layout Quotation


\family typewriter 
char array_de_cadena [100] [51];
\layout Standard

El acceso a una cadena del ejemplo anterior se hace:
\layout Quotation


\family typewriter 
array_de_cadena[indice]
\layout Standard

o
\layout Quotation


\family typewriter 
&array_de_cadena[indice][0]
\layout Standard

Y el acceso a un carácter de una de las cadenas:
\layout Quotation


\family typewriter 
array_de_cadena[indice_1][indice_2]
\layout Description


\size larger 
EJEMPLO
\protected_separator 
DE
\protected_separator 
ARRAY
\protected_separator 
DE
\protected_separator 
CADENAS
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 #include <stdio.h>
\layout Quotation


\family typewriter 

\protected_separator 
 #define NUM_CADENAS 3
\layout Quotation


\family typewriter 

\protected_separator 
 #define LONG_MAX_CADENA 81
\layout Quotation


\family typewriter 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 
 char cadenas [NUM_CADENAS] [LONG_MAX_CADENA];
\layout Quotation


\family typewriter 

\protected_separator 
 puts("
\backslash 
nINTRODUCCION DE CADENAS:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 
 for( i = 0; i < NUM_CADENAS; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Cadena %d: ", i), gets (cadenas[i]);
\layout Quotation


\family typewriter 

\protected_separator 
 puts("LISTADO DE CADENAS INTRODUCIDAS:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 
 for(i = 0; i < NUM_CADENAS; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nCadena %d: %s", i, cadenas[i]);
\layout Quotation


\family typewriter 
}
\layout Section

Arrays Multidimensionales
\layout Standard

C permite arrays de más de dos dimensiones.
 El límite exacto, si lo hay, viene determinado por el compilador.
 La forma general de declaración de un array multidimensional es:
\layout Quotation


\family typewriter 
especificador_de_tipo nombre_array [tam_1] [tam_2] ...
 [tam_n];
\layout Standard


\emph on 
NOTA
\emph default 
: 
\family typewriter 
tam_1
\family default 
, 
\family typewriter 
tam_2
\family default 
, ..., 
\family typewriter 
tam_n
\family default 
 han de ser expresiones constantes.
\layout Standard

La forma general de acceso es:
\layout Quotation


\family typewriter 
nombre_array [ind_1] [ind_2] ...
 [ind_n]
\layout Subsection

Paso de Arrays Multidimensionales como Argumentos a Funciones
\layout Standard

Cuando se pasan arrays multidimensionales a funciones, se tiene que declarar
 todo excepto la primera dimensión.
 Por ejemplo, si se declara 
\family typewriter 
am
\family default 
 como
\layout Quotation


\family typewriter 
int am [4] [3] [6] [5];
\layout Standard

entonces la función que reciba am podría ser como esta:
\layout Quotation


\family typewriter 
void func (int a [] [3] [6] [5])
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* ...
 */
\layout Quotation


\family typewriter 
}
\layout Standard

Por supuesto, si se quiere se puede incluir la primera dimensión.
\layout Section

Arrays y Punteros
\layout Standard

En C los punteros y los arrays están estrechamente relacionados.
 Por ejemplo, un nombre de array es un puntero al primer elemento del array.
 Ejemplo:
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 #include <stdio.h>
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char p[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("p == &p[0] : %d", p == &p[0]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Standard

La salida por pantalla de este programa es:
\layout Quotation


\family typewriter 
p == &p[0] : 1
\layout Section

Inicialización de Arrays
\layout Standard

La forma general de inicialización de un array en la que aparece a continuación:
\layout Quotation


\family typewriter 
especificador_de_tipo nombre_array [tamaño_1] ...
 [tamaño_N] = { lista_de_valores };
\layout Standard

Como se ve, la inicialización de arrays es similar a la inicialización de
 variables.
 La lista_de_valores es una lista de constantes, separadas por comas, cuyo
 tipo es compatible con especificador_de_tipo.
 Después de 
\family typewriter 
}
\family default 
 ha de haber un 
\family typewriter 
;
\layout Standard

Ejemplo de inicialización de un vector:
\layout Quotation


\family typewriter 
int v[5] = { 1, 2, 3, 4, 5 };
\layout Standard

La inicialización de cadenas se puede hacer de dos formas:
\layout Quotation


\family typewriter 
char cadena[4] = "abc";
\layout Quotation


\family typewriter 
char cadena[4] = { 'a', 'b', 'c', '
\backslash 
0' }; 
\layout Standard

Hay dos formas de inicializar arrays multidimensionales:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
int m [3] [4]
\newline 
int m [3] [4]
\newline 
{
\newline 
{
\newline 

\protected_separator 
 1, 2, 3, 4,
\newline 

\protected_separator 
 { 1, 2, 3, 4 },
\newline 

\protected_separator 
 5, 6, 7, 8,
\newline 

\protected_separator 
 { 5, 6, 7, 8 },
\newline 

\protected_separator 
 9, 10, 11, 12
\newline 

\protected_separator 
 { 9, 10, 11, 12 }
\newline 
};
\newline 
};
\layout Standard

No es necesario que estén todos los elementos en las inicializaciones de
 arrays.
 Los elementos que falten se inicializan a 0 o quedan sin valor fijo, según
 el compilador.
 Por ejemplo:
\layout Quotation


\family typewriter 
int v[5] = { 1, 2 };
\layout Standard

Observar que no se asigna los mismos valores a 
\family typewriter 
m1
\family default 
 que a 
\family typewriter 
m2
\family default 
 en el siguiente ejemplo:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
int m1 [3] [2]
\newline 
int m1 [3] [2]
\newline 
{
\newline 
{
\newline 

\protected_separator 

\protected_separator 
2, 3,
\newline 

\protected_separator 

\protected_separator 
{ 2, 3 },
\newline 

\protected_separator 

\protected_separator 
4,
\newline 

\protected_separator 

\protected_separator 
{ 4 },
\newline 

\protected_separator 

\protected_separator 
5, 6
\newline 

\protected_separator 

\protected_separator 
{ 5, 6 }
\newline 
};
\newline 
};
\layout Standard

El valor 5 se asigna en el primer caso a 
\family typewriter 
m1[1][1]
\family default 
 y en el segundo caso a 
\family typewriter 
m2[2][0]
\family default 
.
\layout Standard

La forma más común de inicialización de arrays es sin especificar el tamaño.
 Por ejemplo:
\layout Quotation


\family typewriter 
int v [] = { 2, 3, 4 };
\layout Standard

En este ejemplo, el compilador reserva memoria para los elementos de 
\family typewriter 
v
\family default 
: 
\family typewriter 
v[0]
\family default 
, 
\family typewriter 
v[1]
\family default 
 y 
\family typewriter 
v[2]
\family default 
, y les asigna los valores 2, 3 y 4 respectivamente.
 Otro ejemplo:
\layout Quotation


\family typewriter 
char cadena [] = "esto es una cadena de prueba";
\layout Standard

En los arrays multidimensionales es necesario especificar el tamaño de todas
 las dimensiones excepto el de la primera que es opcional.
 Ejemplo:
\layout Quotation


\family typewriter 
int m [] [4] =
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 { 1, 2, 3, 4 },
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 { 5, 6, 7, 8 } 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Standard

La ventaja de las inicializaciones de arrays sin especificar tamaño es que
 se puede insertar y quitar elementos sin modificar las dimensiones del
 array.
 Otra ventaja es que nosotros no tenemos que contar todos los elementos
 del array para dimensionarlo, así que dejamos que esta tarea la realice
 el compilador.
 Ejemplo: 
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 /* si en tu compilador da problema las dos inicializaciones de arrays que
 se van a definir, lo puede solucionar de dos formas: o bien haces estos
 dos arrays globales o los hace locales estáticos */
\layout Quotation


\family typewriter 

\protected_separator 
 char meses[12][11] =
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 };
\layout Quotation


\family typewriter 

\protected_separator 
 int dias[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
\layout Quotation


\family typewriter 

\protected_separator 
 register short i;
\layout Quotation


\family typewriter 

\protected_separator 
 for(i = 0; i < 12; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El mes de %-10s tiene %d días.
\backslash 
n", meses[i], dias[i]);
\layout Quotation


\family typewriter 
}
\layout Standard

Salida de la ejecución de este ejemplo
\layout Quotation


\family typewriter 
El mes de Enero
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tiene 31 días.
\layout Quotation


\family typewriter 
El mes de Febrero
\protected_separator 

\protected_separator 

\protected_separator 
 tiene 28 días.
\layout Quotation


\family typewriter 
El mes de Marzo
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tiene 31 días.
\layout Quotation


\family typewriter 
El mes de Abril
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tiene 30 días.
\layout Quotation


\family typewriter 
El mes de Mayo
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tiene 31 días.
\layout Quotation


\family typewriter 
El mes de Junio
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tiene 30 días.
\layout Quotation


\family typewriter 
El mes de Julio
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tiene 31 días.
\layout Quotation


\family typewriter 
El mes de Agosto
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tiene 31 días.
\layout Quotation


\family typewriter 
El mes de Septiembre tiene 30 días.
\layout Quotation


\family typewriter 
El mes de Octubre
\protected_separator 

\protected_separator 

\protected_separator 
 tiene 31 días.
\layout Quotation


\family typewriter 
El mes de Noviembre
\protected_separator 
 tiene 30 días.
\layout Quotation


\family typewriter 
El mes de Diciembre
\protected_separator 
 tiene 31 días.
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 6-1
\series default 
.
 Programa que lea 20 números enteros sobre un vector y que calcule e imprima
 las sumas de las componentes de índice par y las de índice
\protected_separator 
 impar.
\layout Itemize


\series bold 
Ejercicio 6-2
\series default 
.
 Programa que carga una matriz de 5 filas y 10 columnas con números enteros,
 imprimiendo los valores máximo y mínimo, y sus posiciones dentro de la
 matriz.
\layout Itemize


\series bold 
Ejercicio 6-3
\series default 
.
 Programa que genera e imprime una matriz unitaria de orden N.
 Una matriz unitaria de orden N es la que tiene N filas y N columnas con
 todas sus componenetes a 0 excepto las de su diagonal principal, que están
 a 1.
\layout Itemize


\series bold 
Ejercicio 6-4
\series default 
.
 Programa que imprime un CUADRADO LATINO de orden N.
 Un cuadrado latino de orden N es una matriz cuadrada en la que su primera
 fila contiene los N primeros números naturales y cada una de las siguientes
 N-1 filas contiene la rotación de la fila anterior un lugar a la derecha.
 Ejemplo:
\layout Quotation


\protected_separator 

\protected_separator 

\protected_separator 
 Cuadrado latino de orden 4.
\layout Quotation


\protected_separator 

\layout Quotation


\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 1
\protected_separator 
 2
\protected_separator 
 3
\protected_separator 
 4
\layout Quotation


\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 4
\protected_separator 
 1
\protected_separator 
 2
\protected_separator 
 3
\layout Quotation


\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 3
\protected_separator 
 4
\protected_separator 
 1
\protected_separator 
 2
\layout Quotation


\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 2
\protected_separator 
 3
\protected_separator 
 4
\protected_separator 
 1
\layout Itemize


\series bold 
Ejercicio 6-5
\series default 
.
 Programa que carga un vector numérico de N componentes y obtiene e imprime
 los M valores menores y los M valores mayores.
 N y M son introducidos por el usuario; M ha de ser menor que N.
\layout Itemize


\series bold 
Ejercicio 6-6
\series default 
.
 Programa que realiza la clasificación completa de una matriz numérica en
 orden creciente (de izquierda a derecha y de arriba a abajo).
\layout Itemize


\series bold 
Ejercicio 6-7
\series default 
.
 Programa que lee una frase y averigua si es palíndroma.
 Una frase es palíndroma si se lee igual de izquierda a derecha que de derecha
 a izquierda.
 Ejemplos: , .
\layout Quote

Considerar también el caso de las frases que se leen igual pero que no se
 escriben igual (debido a los espacios en blanco).
 Ejemplo: marzo 3, 1999.
\layout Itemize


\series bold 
Ejercicio 6-8
\series default 
.
 Diseñar un programa que lea dos matrices n*n y presente un menú de opciones
 para sumarlas, restarlas o multiplicarlas.
\layout Itemize


\series bold 
Ejercicio 6-9
\series default 
.
 Diseñar un programa que lea una matriz n*n y calcule e imprima su traspuesta.
\layout Itemize


\series bold 
Ejercicio 6-10
\series default 
.
 Diseñar un programa que genere 100 números aleatorios distintos.
\layout Quote


\series bold 
Nota
\series default 
: para saber los números que ya han sido generados, almacenar éstos en un
 array.
\layout Itemize


\series bold 
Ejercicio 6-11
\series default 
.
 Realizar un programa que lea una matriz cuadrada de dimensión máxima 50x50
 y haga lo siguiente:
\layout Quote

- Imprima la media de los elementos de la diagonal principal.
\layout Quote

- Imprima la suma de los elementos por debajo de la diagonal principal y
 por encima de ella.
\layout Itemize


\series bold 
Ejercicio 6-12
\series default 
.
 Una fábrica de automóviles produce 4 modelos de coches cuyos precios de
 venta son respectivamente 1.5, 1.75, 2.42 y 2.6 millones de pesetas.
 Esta empresa cuenta con cuatro centros de distribución y venta.
 Se dispone de una relación de datos correspondientes al tipo de vehículo
 vendido y punto de distribución en que se produjo la venta del mismo.
 Realizar un programa que leyendo la relación de datos anterior, calcule
 e imprima:
\begin_deeper 
\layout Enumerate

Volumen de ventas total.
\layout Enumerate

Volumen de ventas por centro.
\layout Enumerate

Porcentaje de unidades totales vendidas en cada centro.
\layout Enumerate

Porcentaje de unidades de cada modelo vendidos en cada centro, sobre el
 total de ventas de la empresa.
\end_deeper 
\layout Itemize


\series bold 
Ejercicio 6-13
\series default 
.
 Son números primos aquéllos divisibles solamente entre sí mismos y 1.
 Para localizar los números primos del 1 al 1000, puede empezarse con 2
 y dividir todos los números mayores entre 2, con la eliminación de los
 que no tengan residuo para pasar después al mayor número que no haya sido
 eliminado y dividirlo de la misma forma.
 Este es un método directo que se basa en la definición.
 Sin embargo, se requiere mucho tiempo porque la división es larga.
 Una forma más rápida consiste en utilizar el procedimiento de la criba
 de Erastótenes:
\layout Quote

Llena un vector con valores del 1 al 1000.
 Empieza con el segundo valor para igualar a 0 todos los múltiplos en el
 vector (todos los múltiplos de 2, esto se consigue en el programa C con
 incrementos de la variable índice de 2 en 2).
 Sigue, con el siguiente número diferente de cero y repite el proceso sucesivame
nte.
 Concluido el proceso, todas las anotaciones diferentes de cero serán números
 primos.
 Escribe un programa para utilizar este procedimiento e imprimir una tabla
 de números primos.
\layout Itemize


\series bold 
Ejercicio 6-14
\series default 
.
 Realizar una función que acepte tres vectores: A, B y C.
 Los vectores A y B son dos vectores ordenados en orden creciente de números
 enteros, sus longitudes no tienen porqué ser iguales.
 Nuestra función ha de rellenar el vector C (cuya longitud es la suma de
 las longitudes de los vectores A y B) intercalando A y B, de tal forma
 que al final del proceso el vector C es un vector ordenado en orden creciente
 con los números enteros de los vectores A y B.
\layout Itemize


\series bold 
Ejercicio 6-15
\series default 
.
 Dado un vector X de n elementos enteros en que n es impar, escribir un
 programa que calcule la mediana del vector.
 La mediana es un valor superior a la mitad del número de elementos del
 vector e inferior a la otra mitad.
 Por ejemplo, dado el vector X
\layout Quotation


\family typewriter 
X1
\protected_separator 
 X2
\protected_separator 
 X3
\protected_separator 
 X4
\protected_separator 
 X5
\protected_separator 
 X6
\protected_separator 
 x7
\protected_separator 
 X8
\protected_separator 
 X9
\layout Quotation


\family typewriter 
17
\protected_separator 
 -3
\protected_separator 
 21
\protected_separator 

\protected_separator 
 2
\protected_separator 

\protected_separator 
 9
\protected_separator 
 -4
\protected_separator 

\protected_separator 
 6
\protected_separator 

\protected_separator 
 8
\protected_separator 
 11
\layout Quote

de nueve elementos, la ejecución del programa debería dar el valor 8.
\layout Itemize


\series bold 
Ejercicio 6-16
\series default 
.
 Una matriz A de dimensión nxm es simétrica si
\layout Quotation

a(i,j) = a(j,i)
\protected_separator 
 para
\protected_separator 
 1_i_n y 1_j_m
\layout Quote

Escribir un programa que lea una matriz (de dimensión no mayor de 10x10)
 y determine si es simétrica o no.
 Supóngase que los elementos de la matriz son enteros.
 Ejemplo de matriz simétrica:
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
| 1
\protected_separator 
 4
\protected_separator 
 7 |
\layout Quotation


\family typewriter 
| 4
\protected_separator 
 2
\protected_separator 
 9 |
\layout Quotation


\family typewriter 
| 7
\protected_separator 
 9
\protected_separator 
 3 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Chapter

Punteros
\layout Standard

El objetivo de esta lección es hacer un estudio completo en todo lo referente
 a la declaración, utilización e inicialización de punteros.
 Los puntos que detallaremos son:
\layout Itemize

Definición del concepto de puntero.
\layout Itemize

Declaración de punteros.
\layout Itemize

Operadores de punteros: 
\family typewriter 
&
\family default 
 y 
\family typewriter 
*
\family default 
.
\layout Itemize

Aritmética de punteros.
\layout Itemize

Asignación dinámica de memoria.
\layout Itemize

Punteros y arrays.
\layout Itemize

Inicializaciones de punteros.
\layout Itemize

Punteros a funciones.
\layout Itemize

Funciones 
\family typewriter 
qsort()
\family default 
 y 
\family typewriter 
bsearch()
\family default 
.
\layout Itemize

Funciones de Turbo C: 
\family typewriter 
lfind()
\family default 
 y 
\family typewriter 
lsearch()
\family default 
.
\layout Itemize

Tipo void y punteros.
\layout Itemize

Modificador de acceso 
\family typewriter 
const
\family default 
 y punteros.
\layout Itemize

Declaraciones curiosas.
\layout Description


\size larger 
PUNTEROS
\layout Standard

El concepto de puntero es importantísimo en la programación en C.
 Un puntero contiene una dirección de memoria.
 Cuando una variable contiene la dirección de otra variable se dice que
 la primera variable apunta a la segunda.
\layout Section

Variables Punteros
\layout Standard

La forma general para declarar una variable puntero es:
\layout Quotation


\family typewriter 
tipo *nombre;
\layout Standard

donde 
\family typewriter 
tipo
\family default 
 es cualquier tipo válido de C (también llamado tipo base) y nombre es el
 nombre de la variable puntero.
 
\layout Section

Operadores de Punteros
\layout Standard

Existen dos operadores especiales de punteros: 
\family typewriter 
&
\family default 
 y 
\family typewriter 
*
\family default 
.
 Estos dos operados son monarios y no tienen nada que ver con los operadores
 binarios de multiplicación (
\family typewriter 
*
\family default 
) y de and a nivel de bits (
\family typewriter 
&
\family default 
).
\layout Subsection

Operador & 
\layout Standard


\family typewriter 
&
\family default 
 es un operador monario que devuelve la dirección de memoria de su operando.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int x = 10;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf(" x = %d
\backslash 
n &x = %p
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 x, &x);
\layout Quotation


\family typewriter 
}
\layout Standard

Salida del ejemplo anterior:
\layout Quotation


\family typewriter 
x = 10
\layout Quotation


\family typewriter 
&x = 8FBC:0FFE
\layout Standard


\emph on 
NOTA
\emph default 
: El valor y formato de las direcciones de las variables que se imprimen
 en esta lección (con el código de formato 
\family typewriter 
%p
\family default 
) son dependientes de la implementación.
 En mi caso las direcciones se escriben en formato 
\family typewriter 
segmento:offset
\family default 
, y el valor de la dirección de una variable es distinto según cuándo y
 desde dónde se ejecute el programa.
\layout Subsection

Operador * 
\layout Standard

El operador 
\family typewriter 
*
\family default 
 es el complemento de 
\family typewriter 
&
\family default 
.
 Es un operador monario que devuelve el valor de la variable localizada
 en la dirección que sigue.
 
\layout Standard

Ejemplo 1:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int x = 10;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\protected_separator 
 x = %d
\backslash 
n", x);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\protected_separator 
 *&x = %d", *&x);
\layout Quotation


\family typewriter 
}
\layout Standard

Salida de ejemplo 1:
\layout Quotation


\family typewriter 
x = 10
\layout Quotation


\family typewriter 
*&x = 10
\layout Standard

Ejemplo 2:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int x = 10;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int *px;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 px = &x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\protected_separator 
 x = %d
\backslash 
n", x);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\protected_separator 
 &x = %p
\backslash 
n", &x);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\protected_separator 
 px = %p
\backslash 
n", px);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\protected_separator 
 &px = %p
\backslash 
n", &px);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\protected_separator 
 *px = %d", *px);
\layout Quotation


\family typewriter 
}
\layout Standard

Salida de ejemplo 2:
\layout Quotation


\family typewriter 
x = 10
\layout Quotation


\family typewriter 
&x = 8FC4:0FFE
\layout Quotation


\family typewriter 
px = 8FC4:0FFE
\layout Quotation


\family typewriter 
&px = 8FC4:0FFA
\layout Quotation


\family typewriter 
*px = 10
\layout Standard

Gráficamente:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 px
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 x
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
+-----------+
\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 
+-----------+
\layout Quotation


\family typewriter 
| 8FC4:0FFE |
\protected_separator 

\protected_separator 
 |
\protected_separator 

\protected_separator 

\protected_separator 
 10
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
+-----------+
\protected_separator 

\protected_separator 
 
\layout Quotation


\family typewriter 
+-----------+
\layout Quotation


\family typewriter 

\protected_separator 
 8FC4:0FFA
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 8FC4:0FFE
\protected_separator 
 
\layout Standard

En el ejemplo anterior se observa que hay tres valores asociados a los punteros:
\layout Itemize

Dirección en la que se encuentra.
\layout Itemize

Dirección a la que apunta.
\layout Itemize

Valor contenido en la dirección apuntada.
\layout Description


\emph on 
¡¡OJO!!
\emph default 
 Al ejecutar el siguiente programa los resultados pueden ser inesperados
 ya que estamos asignando el valor 10 en una posición de memoria no reservada:
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int *p;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *p = 10;
\layout Quotation


\family typewriter 
}
\layout Standard

Sería correcto:
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int x;/*se reserva memoria para x*/
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int *p;/*se reserva memoria para la
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 variable p, no para la posición
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 de memoria a la que apunta p */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p = &x; /* p apunta a valor de x */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *p = 10;/* equivalente a: x = 10 */
\layout Quotation


\family typewriter 
}
\layout Section

Aritmética de Punteros
\layout Standard

Existen 4 operadores que realizan operaciones aritméticas que pueden utilizarse
 con punteros:
\layout Quotation


\family typewriter 
+, -, ++, --
\layout Standard


\series bold 
EJEMPLO DE ARITMETICA DE PUNTEROS
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int *p;
\layout Quotation


\family typewriter 

\protected_separator 
 #define imprimir_p printf ("
\backslash 
np = %p", p);
\layout Quotation


\family typewriter 

\protected_separator 
 imprimir_p;
\layout Quotation


\family typewriter 

\protected_separator 
 printf("
\backslash 
tsizeof(*p) = %d", sizeof(*p));
\layout Quotation


\family typewriter 

\protected_separator 
 p++; imprimir_p;
\layout Quotation


\family typewriter 

\protected_separator 
 p -= 5; imprimir_p;
\layout Quotation


\family typewriter 
}
\layout Standard


\series bold 
SALIDA DEL EJEMPLO
\layout Quotation


\family typewriter 
p = 7203:8D51
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 sizeof(*p) = 2
\layout Quotation


\family typewriter 
p = 7203:8D53
\layout Quotation


\family typewriter 
p = 7203:8D49
\layout Standard

En el ejemplo anterior se aprecia que si hacemos 
\family typewriter 
p++
\family default 
; no aumenta el valor de 
\family typewriter 
p
\family default 
 en 1 sino que aumenta en 2, que es el tamaño en bytes de un 
\family typewriter 
int
\family default 
, es decir, el tamaño del objeto al que apunta.
 Por lo tanto, la sentencia 
\family typewriter 
p++
\family default 
 hay que interpretarla de la siguiente forma: 
\latex latex 
<<
\latex default 
p apunta al siguiente elemento del tipo base
\latex latex 
>>
\latex default 
.
 Lo mismo se puede decir de los demás operadores aritméticos aplicados a
 los punteros.
 Toda la aritmética de punteros está en relación con el tipo base del puntero
 por lo que el puntero está siempre apuntando al elemento apropiado del
 tipo base.
\layout Section

Asignación Dinámica de Memoria
\layout Standard

Supóngase que queremos hacer un programa que lea n valores enteros introducidos
 por teclado por el usuario, los almacene en un vector y los imprima en
 orden inverso.
 Una solución es:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 #define NMAX 100 /* número máximo de elementos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int v[NMAX]; /* vector */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int n = 0; /* número de elementos introducidos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int varaux; /* variable auxiliar */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 register int i; /* índice */
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 do
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nIntroduce número de valores a leer (1-%d): ", NMAX);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 scanf("%d", &n);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 } while(n < 1 || n > NMAX);
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for (i = 0; i <= n - 1; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Introduce valor %d: ", i);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 scanf("%d", &varaux);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 v[i] = varaux;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n
\backslash 
nValores en orden inverso:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = n - 1; i >= 0; i--)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", v[i]);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

Si el usuario introduce como valor de n, el valor 10, estaremos desperdiciando,
 si un int ocupa 2 bytes, 90*2 bytes de memoria.
 Además, el usuario no puede introducir más de 
\family typewriter 
NMAX
\family default 
 valores.
 Estas restricciones vienen impuestas poque el tamaño de un array en la
 declaración ha de ser una expresión constante.
 La asignación de memoria en este caso se dice que es estática porque se
 determina en el momento de la compilación.
 Cuando la asignación de memoria se determina en tiempo de ejecución se
 dice que es asignación dinámica.
 Veamos cómo se haría el programa anterior con asignación dinámica y luego
 pasamos a explicarlo:
\layout Quotation


\family typewriter 
#include <stdio.h> /* printf(), scanf() */
\layout Quotation


\family typewriter 
#include <alloc.h> /* malloc(), free() */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int *v; /* vector */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int n = 0; /* número de elementos introducidos */ 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int varaux; /* variable auxiliar */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 register int i; /* índice */
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nIntroduce número de valores a leer: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 scanf("%d", &n);
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 v = (int *) malloc (n * sizeof (int));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 if(v == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Memoria insuficiente.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = 0; i <= n - 1; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Introduce valor %d: ", i);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 scanf("%d", &varaux);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 v[i] = varaux;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
n
\backslash 
nValores en orden inverso:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = n - 1; i >= 0; i--)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", v[i]);
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 free(v);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Standard

La primera sentencia de 
\family typewriter 
main()
\family default 
 es:
\layout Quotation


\family typewriter 
int *v;
\layout Standard

En esta declaración estamos declarando 
\family typewriter 
v
\family default 
 como un puntero a entero.
 La siguiente línea para nosotros es:
\layout Quotation


\family typewriter 
v = (int *) malloc (n * sizeof (int));
\layout Standard

La función 
\family typewriter 
malloc
\family default 
 reserva memoria; acepta como argumento los bytes de memoria a reservar
 y devuelve un puntero al primer byte de la zona de memoria reservada; los
 bytes de memoria solicitados los reserva en un espacio de memoria contiguo.
 Si no hay suficiente memoria, devuelve 
\family typewriter 
NULL
\family default 
.
 Un puntero que tiene el valor 
\family typewriter 
NULL
\family default 
 es un puntero que no apunta a ningún sitio.
 El prototipo de esta función se encuentra en el fichero 
\family typewriter 
malloc.h
\family default 
 (de ahí el incluir este fichero en nuestro ejemplo) y es el siguiente:
\layout Quotation


\family typewriter 
void *malloc (unsigned int bytes);
\layout Standard

Vemos que devuelve un puntero a 
\family typewriter 
void
\family default 
; esto quiere decir que devuelve un puntero que apunta a cualquier tipo
 base, o dicho de otro modo, un puntero que apunta a una dirección de memoria
 sin tener tipo base.
 El C de Kernighan y Ritchie, como no tiene tipo 
\family typewriter 
void
\family default 
, el prototipo de esta función es:
\layout Quotation


\family typewriter 
char *malloc (unsigned int bytes);
\layout Standard

En ambos casos, el tratamiento por parte del usuario de esta función es
 exactamente el mismo.
\layout Standard

Veamos otra vez la llamada a esta función en nuestro ejemplo:
\layout Quotation


\family typewriter 
v = (int *) malloc (n * sizeof (int));
\layout Standard

Al valor devuelto por la función 
\family typewriter 
malloc
\family default 
 (puntero a 
\family typewriter 
void
\family default 
 o puntero a 
\family typewriter 
char
\family default 
) siempre se le realiza un moldeado (recordad que esto se hacía con: (tipo))
 para adecuarlo al tipo base de nuestro puntero que va a apuntar a esa zona
 de memoria reservada.
 En nuestro caso el molde es:
\layout Quotation


\family typewriter 
(int *) /* puntero a entero */
\layout Standard

El argumento que le pasamos a 
\family typewriter 
malloc
\family default 
 ha de ser el número de bytes de memoria a reservar.
 Esto siempre se hace siguiendo la fórmula: 
\layout Quotation


\family typewriter 
numero_de_elementos * sizeof (tipo_de_cada_elemento)
\layout Standard

que traducido a nuestro caso queda:
\layout Quotation


\family typewriter 
n * sizeof (int)
\layout Standard

Otra forma de hacer lo mismo es:
\layout Quotation


\family typewriter 
n * sizeof (*v)
\layout Standard

que suele ser muy corriente.
 Las dos formas son equivalentes.
 La memoria asignada por 
\family typewriter 
malloc
\family default 
 se desasigna con la función 
\family typewriter 
free()
\family default 
.
 Esta memoria asignada no se desasigna al salir del bloque de código en
 que fue asignada como ocurre con las variables locales sino con la función
 
\family typewriter 
free
\family default 
 (liberar) o al terminar el programa.
 Por lo tanto, siempre que asignemos memoria con 
\family typewriter 
malloc
\family default 
, tenemos que desasignarla con 
\family typewriter 
free
\family default 
 cuando ya no nos sea necesaria.
 El prototipo de la función 
\family typewriter 
free
\family default 
 se encuentra en el fichero 
\family typewriter 
malloc.h
\family default 
 y es el siguiente:
\layout Quotation


\family typewriter 
void free (void *p);
\layout Standard

Un puntero a 
\family typewriter 
void
\family default 
 como parámetro indica que acepta cualquier puntero, independientemente
 del tipo base al que apunta.
 El puntero que se le pasa a 
\family typewriter 
free
\family default 
 como argumento ha de ser un puntero que apunta al principio de una zona
 reservad anteriormente por 
\family typewriter 
malloc
\family default 
; si no es así, se puede caer el sistema.
 El resto del ejemplo no tiene ya ninguna dificultad.
 Hay otra función, en la librería 
\family typewriter 
<alloc.h>
\family default 
, equivalente a 
\family typewriter 
malloc
\family default 
, que es la función 
\family typewriter 
calloc
\family default 
 cuyo prototipo es el siguiente:
\layout Quotation


\family typewriter 
void *calloc (unsigned numero_de_elementos_a_reservar,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned tamanio_en_bytes_de_cada_elemento);
\layout Standard

Esta función es igual que 
\family typewriter 
malloc
\family default 
 con la única diferencia de sus parámetros.
\layout Standard

En Turbo C, los prototipos de las funciones 
\family typewriter 
malloc()
\family default 
, 
\family typewriter 
calloc()
\family default 
 y 
\family typewriter 
free()
\family default 
, además de estar en el fichero 
\family typewriter 
alloc.h
\family default 
, también están en el fichero 
\family typewriter 
stdlib.h
\family default 
.
\layout Section

Punteros y Arrays
\layout Standard

Exite una estrecha relación entre los punteros y los arrays.
 Ya hemos dicho en varias ocasiones en lecciones anteriores que el nombre
 de un array es un puntero al primer elemento del array.
\layout Standard

A cualquier elemento de un array podemos acceder mediante la aritmética
 de punteros y viceversa, cualquier puntero lo podemos indexar con los 
\family typewriter 
[]
\family default 
: 
\layout Standard

Arrays unidimensionales:
\layout Quotation


\family typewriter 
p[i] == *(p+i)
\layout Standard

Arrays bidimensionales:
\layout Quotation


\family typewriter 
p[i][j] == *(p+(i*longitud_fila)+k) == *(*(p+i)+j)
\layout Standard

Arrays muldimensionales:
\layout Itemize

se sigue cualquiera de los dos procedimientos ejemplarizados en los arrays
 bidimensionales
\layout Standard


\series bold 
EJEMPLO DE ACCESO A UN ARRAY CON UN PUNTERO
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 float v[3] = { 1.1, 2.2, 3.3 };
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("v[1] = %g; *(v+1) = %g", v[1], *(v+1));
\layout Quotation


\family typewriter 
}
\layout Standard


\series bold 
SALIDA POR PANTALLA
\layout Quotation


\family typewriter 
v[1] = 2.2; *(v+1) = 2.2
\layout Standard


\series bold 
EJEMPLO DE ACCESO A ELEMENTOS INDEXANDO UN PUNTERO CON 
\family typewriter 
[]
\layout Quotation


\family typewriter 
#include <stdio.h> /* printf (), NULL */
\layout Quotation


\family typewriter 
#include <alloc.h> /* malloc (), free () */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 float *p;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if((p = (float *) malloc (3 * sizeof (float))) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nERROR: Memoria Insuficiente.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 *p = 1.1; *(p+1) = 2.2; *(p+3) = 3.3;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("*(p+1) = %g p[1] = %g", *(p+1), p[1]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 free(p);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 
}
\layout Standard


\series bold 
SALIDA
\layout Quotation


\family typewriter 
*(p+1) = 2.2; p[1] = 2.2 */
\layout Standard

Los programadores profesionales de C suelen utilizar la notación puntero
 en vez de la notación array porque es bastante más rápido y más cómodo,
 aunque para los no acostrumbrados a esta notación se ve un poco extraño
 al principio.
 Pensad que con notación array, para acceder a un determinado elemento,
 el compilador tiene que hacer una serie de cálculos para averiguar en qué
 posición está, mientras que en la notación puntero basta con una simple
 suma.
 No obstante, cuando el código queda más claro en la notación array que
 con la notación puntero es preferible la primera notación.
 Cuando se trabaja con cadenas de caracteres sí se sebe utilizar la notación
 puntero, no ya sólo por eficiencia sino también por convención.
\layout Standard

Una estructura común en C es el array de punteros.
 Recordar que el argumento 
\family typewriter 
argv
\family default 
 de la función 
\family typewriter 
main()
\family default 
 es un array de punteros a caracteres.
 Hay tres formas equivalentes de declarar el argumento 
\family typewriter 
argv
\family default 
 en la función 
\family typewriter 
main()
\family default 
:
\layout Quotation


\family typewriter 
main (int argc, char argv[][]);
\layout Quotation


\family typewriter 
main (int argc, char *argv[]);
\layout Quotation


\family typewriter 
main (int argc, char **argv);
\layout Standard

Habrás observado que en la primera declaración no se ha especificado el
 tamaño de la segunda dimensión de 
\family typewriter 
argv
\family default 
 cuando habíamos dicho antes que era necesario, esto sólo está permitido
 hacerlo en la función 
\family typewriter 
main()
\family default 
.
\layout Standard

La declaración para un array de 10 punteros a 
\family typewriter 
int
\family default 
 es:
\layout Quotation


\family typewriter 
int *x[10];
\layout Standard

Para asignar la dirección de una variable entera llamada var al tercer elemento
 del array de punteros, se ecribe:
\layout Quotation


\family typewriter 
x[2] = &var;
\layout Standard

Para encontrar el valor de var, se escribe:
\layout Quotation


\family typewriter 
*x[2]
\layout Standard


\series bold 
EJEMPLO DE ARRAY DE CADENAS DE CARACTERES
\layout Quotation


\family typewriter 
void error(int numero_de_error)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 char *errores [] =
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "error al intentar abrir fichero",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "error al intentar cerrar fichero",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "error al intentar leer de fichero",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "error al intentar escribir en fichero"
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 };
\layout Quotation


\family typewriter 

\protected_separator 
 printf("%s", errores[numero_de_error]);
\layout Quotation


\family typewriter 

\protected_separator 
 exit(1);
\layout Quotation


\family typewriter 
}
\layout Standard

Un array de punteros es lo mismo que punteros a punteros.
 Este ejemplo comprueba dicha afirmación.
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int x, *p, **q;
\layout Quotation


\family typewriter 

\protected_separator 
 x = 10; p = &x; q = &p;
\layout Quotation


\family typewriter 

\protected_separator 
 printf("x = %d; *p = %d; **q = %d", x, *p, **q);
\layout Quotation


\family typewriter 
}
\layout Standard


\series bold 
SALIDA
\layout Quotation


\family typewriter 
x = 10; *p = 10; **q = 10
\layout Standard

A continuación vamos a mostrar dos formas de implementar la siguiente función:
 la función a implementar acepta como argumentos una matriz de enteros y
 un elemento, y devuelve 1 si ese elemento se encuentra en la matriz o 0
 si dicho elemento no se encuentra en la matriz.
 Las funciones 
\family typewriter 
buscar_en_matriz_version_1()
\family default 
 y 
\family typewriter 
buscar_en_matriz_version_2()
\family default 
 son equivalentes pero la segunda es mucho más eficiente.
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#define N 3
\layout Quotation


\family typewriter 
int buscar_en_matriz_version_1 (int m[N][N], int x)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 register int i, j;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int encontrado = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; ! encontrado && i < N; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 for(j = 0; ! encontrado && j < N; j++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 if(m[i][j] == x)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 encontrado = 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return (encontrado);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int buscar_en_matriz_version_2 (int m[N][N], int x)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int encontrado = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int *pm = m; /* declara pm como puntero a int y lo hace apuntar a m */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 1; ! encontrado && i <= N*N; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 if(*pm == x)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 encontrado = 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 pm++;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return (encontrado);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int matriz [N][N] = { { 1, 2, 3 }, { -1, -2, -3 }, { 5, 6, 7 } };
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int resultado_1 = buscar_en_matriz_version_1 (matriz, 6);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int resultado_2 = buscar_en_matriz_version_1 (matriz, 8);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int resultado_3 = buscar_en_matriz_version_2 (matriz, 6);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int resultado_4 = buscar_en_matriz_version_2 (matriz, 8);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nresultado_1 = %d", resultado_1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nresultado_2 = %d", resultado_2);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nresultado_3 = %d", resultado_3);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nresultado_4 = %d", resultado_4);
\layout Quotation


\family typewriter 
}
\layout Standard

SALIDA
\layout Quotation


\family typewriter 
resultado_1 = 1
\layout Quotation


\family typewriter 
resultado_2 = 0
\layout Quotation


\family typewriter 
resultado_3 = 1
\layout Quotation


\family typewriter 
resultado_4 = 0
\layout Section

Inicializaciones de Punteros
\layout Standard

Un puntero que tiene el valor 
\family typewriter 
NULL
\family default 
 es un puntero que no apunta a ningún sitio.
 Una inicialización muy común en C se ilustra con el siguiente ejemplo:
\layout Quotation


\family typewriter 
char *p = cadena
\backslash 
n;
\layout Standard

En este caso el compilador guarda 
\family typewriter 
"cadena
\backslash 
n"
\family default 
 en memoria y hace que 
\family typewriter 
p
\family default 
 apunte al principio de la cadena, es decir, el carácter 
\family typewriter 
'c'
\family default 
.
 
\layout Standard


\series bold 
EJEMPLOS DE INICIALIZACIONES EQUIVALENTES 
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
13 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 1 0 0
1 0 0 0
0 0 0 0
0 1 0 0
1 0 0 0
0 0 0 0
0 1 0 0
1 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

int x = 10;
\newline 
int x = 10;
\newline 
int *p = &x;
\newline 
int *p;
\newline 

\newline 
p = &x;
\newline 
int x, *p, y;
\newline 
int x;
\newline 

\newline 
int *p;
\newline 

\newline 
int y; 
\newline 
int *p, *q, r = 10;
\newline 
int *p;
\newline 

\newline 
int *q;
\newline 

\newline 
int r = 10;
\newline 
int v[2] = { 1, 2 }, f (void), *p, x = 3;
\newline 
int v[2] = { 1, 2 };
\newline 

\newline 
int f (void);
\newline 

\newline 
int *p;
\newline 

\newline 
int x = 3;
\layout Section

Punteros a Funciones
\layout Standard

Una característica algo confusa pero muy útil de C es el puntero a función.
 La confusión surge porque una función tiene una posición física en memoria
 que puede asignarse a un puntero aunque la función no es una variable.
 La dirección de la función es el punto de entrada de la función; por tanto,
 un puntero a función puede utilizarse para llamar a la función.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h> /* printf () */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 /* escribir es una función que acepta un int como argumento y no devuelve
 nada */
\layout Quotation


\family typewriter 

\protected_separator 
 void escribir(int);
\layout Quotation


\family typewriter 

\protected_separator 
 /* pf es un puntero a una función que acepta un int como argumento y no
 devuelve nada */
\layout Quotation


\family typewriter 

\protected_separator 
 void (*pf) (int);
\layout Quotation


\family typewriter 

\protected_separator 
 pf = escribir;
\layout Quotation


\family typewriter 

\protected_separator 
 escribir (1); /* llama a la función escribir */
\layout Quotation


\family typewriter 

\protected_separator 
 (*pf) (2); /* llama a la función escribir a través de un puntero */
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void escribir(int numero)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf("%d", numero);
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa por pantalla es:
\layout Quotation


\family typewriter 
12
\layout Standard

Una utilidad de los punteros a funciones la tenemos en las funciones 
\family typewriter 
qsort()
\family default 
 y 
\family typewriter 
bsearch()
\family default 
 cuyos prototipos están en el fichero 
\family typewriter 
stdlib.h
\family default 
.
\layout Standard

El prototipo de la función 
\family typewriter 
qsort()
\family default 
 está en el fichero 
\family typewriter 
stdlib.h
\family default 
 y es:
\layout Quotation


\family typewriter 
void qsort (void *base, unsigned int num, unsigned int tam,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int (*compara) (void *arg1, void *arg2));
\layout Standard

La función 
\family typewriter 
qsort()
\family default 
 ordena el array apuntado por base utilizando el método de ordenación de
 C.A.R.
 Hoare (este método se ha explicado en el ejemplo 3 de la lección 5).
 El número de elementos en el array se especifica mediante num, y el tamaño
 en bytes de cada elemento está descrito por 
\family typewriter 
tam
\family default 
.
 La función compara se utiliza para comparar un elemento del array con la
 clave.
 La comparación debe ser:
\layout Quotation


\family typewriter 
int nombre_func (void *arg1, void *arg2);
\layout Standard

Debe devolver los siguientes valores:
\layout Itemize

Si 
\family typewriter 
arg1
\family default 
 es menor que 
\family typewriter 
arg2
\family default 
, devuelve un valor menor que 0.
\layout Itemize

Si 
\family typewriter 
arg1
\family default 
 es igual a 
\family typewriter 
arg2
\family default 
 devuelve 0.
\layout Itemize

Si 
\family typewriter 
arg1
\family default 
 es mayor que 
\family typewriter 
arg2
\family default 
, devuelve un valor mayor que 0.
\layout Standard

El array es ordenado en orden ascendente con la dirección más pequeña conteniend
o el menor elemento.
 En Turbo C, el prototipo de la función qsort() es ligeramente diferente:
\layout Quotation


\family typewriter 
void qsort (void *base, size_t num, size_t tam,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int (*compara) (const void *, const void *));
\layout Standard


\family typewriter 
size_t
\family default 
 es un tipo definido en el fichero 
\family typewriter 
stdlib.h
\family default 
 y suele ser 
\family typewriter 
unsigned int
\family default 
; (
\family typewriter 
const void *
\family default 
) no es lo mismo que (
\family typewriter 
void *
\family default 
), la diferencia entre ellos se va a estudiar unas tres o cuatro ventanas
 más adelante, pero podemos intuirla: en (
\family typewriter 
const void *
\family default 
) el objeto apuntado es constante, es decir, no se puede modificar, en (
\family typewriter 
void *
\family default 
) el objeto apuntado por el puntero sí se puede modificar.
\layout Standard

Veamos un ejemplo de la utilización de esta función, donde podemos apreciar
 además, dos formas posibles de declaración y utilización de la función
 de comparación requerida por la función 
\family typewriter 
qsort()
\family default 
.
\layout Quotation


\family typewriter 
#include <stdio.h>
\protected_separator 
 /* printf () */
\layout Quotation


\family typewriter 
#include <stdlib.h> /* qsort () */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int num[10] = { 3, 2, 8, 9, 2, 2, 1, -2, 3, 2 };
\layout Quotation


\family typewriter 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 
 int comparar_creciente (const void *elem1, const void *elem2);
\layout Quotation


\family typewriter 

\protected_separator 
 int comparar_decreciente (const int *elem1, const int *elem2);
\layout Quotation


\family typewriter 

\protected_separator 
 printf("
\backslash 
nArray desordenado: ");
\layout Quotation


\family typewriter 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", num[i]);
\layout Quotation


\family typewriter 

\protected_separator 
 qsort(num, 10, sizeof (int), comparar_creciente);
\layout Quotation


\family typewriter 

\protected_separator 
 printf("
\backslash 
nArray ordenado en orden creciente: ");
\layout Quotation


\family typewriter 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", num[i]);
\layout Quotation


\family typewriter 

\protected_separator 
 /* el molde del cuarto argumento convierte el tipo (int (*) (const int
 *, const int *)) al tipo (int (*) (const void *, const void *)) que es
 el que requiere la función qsort */
\layout Quotation


\family typewriter 

\protected_separator 
 qsort(num, 10, sizeof (int),
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (int (*) (const void *, const void *)) comparar_decreciente);
\layout Quotation


\family typewriter 

\protected_separator 
 printf("
\backslash 
nArray ordenado en orden decreciente: ");
\layout Quotation


\family typewriter 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", num[i]);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int comparar_creciente (const void *elem1, const void *elem2)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 /* para acceder al contenido de un puntero del tipo (void *) necesitamos
 moldearlo a un tipo base que no sea void */ 
\layout Quotation


\family typewriter 

\protected_separator 
 return (*(int *)elem1 - *(int *)elem2);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int comparar_decreciente(const int *elem1, const int *elem2)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 return (*elem2 - *elem1);
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa por pantalla es:
\layout Quotation


\family typewriter 
Array desordenado: 3 2 8 9 2 2 1 -2 3 2
\layout Quotation


\family typewriter 
Array ordenado en orden creciente: -2 1 2 2 2 2 3 3 8 9
\layout Quotation


\family typewriter 
Array ordenado en orden decreciente: 9 8 3 3 2 2 2 2 1 -2
\layout Standard

El prototipo de la función 
\family typewriter 
bsearch()
\family default 
 se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
 y es el siguiente:
\layout Quotation


\family typewriter 
void *bsearch (void *clave, void *base, unsigned int num,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int tam, int (*compara) (void *arg1, void *arg2));
\layout Standard

La función 
\family typewriter 
bsearch()
\family default 
 realiza una búsqueda binaria en el array ordenado apuntado por base y devuelve
 un puntero al primer elemento que se corresponde con la clave apuntada
 por clave.
 El número de elementos en el array está especificado por 
\family typewriter 
num
\family default 
 y el tamaño (en bytes) de cada elemento está descrito por 
\family typewriter 
tam
\family default 
.
 La función apuntada por compara se utiliza para comparar un elemento del
 array con la clave.
 La forma de la función de comparación debe ser:
\layout Quotation


\family typewriter 
nombre_func (void *arg1, void *arg2);
\layout Standard

Debe devolver los siguientes valores:
\layout Itemize

Si 
\family typewriter 
arg1
\family default 
 es menor que 
\family typewriter 
arg2
\family default 
, devuelve un valor menor que 0.
\layout Itemize

Si 
\family typewriter 
arg1
\family default 
 es igual que 
\family typewriter 
arg2
\family default 
, devuelve 0.
\layout Itemize

Si 
\family typewriter 
arg1
\family default 
 es mayor que 
\family typewriter 
arg2
\family default 
, devuelve un valor mayor que 0.
\layout Standard

El array debe estar ordenado en orden ascendente con la menor dirección
 conteniendo el elemento más pequeño.
 Si el array no contiene la clave, se devuelve un puntero nulo.
 Esta función está implementada en uno de los ejemplos de la lección 3.
\layout Standard

En Turbo C, el prototipo de la función 
\family typewriter 
bsearch()
\family default 
 es ligeramente diferente:
\layout Quotation


\family typewriter 
void *bsearch (const void *clave, const void *base, unsigned int *num,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int tam, int (*compara) (const void *arg1, const void *arg2));
\layout Standard

Los tipos 
\family typewriter 
size_t
\family default 
 y (
\family typewriter 
const void *
\family default 
) se han explicado en la ventana anterior: 
\family typewriter 
qsort()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#define NUM_ELEMENTOS(array) (sizeof(array) / sizeof(array[0]))
\layout Quotation


\family typewriter 
int array_de_numeros[] = { 123, 145, 512, 627, 800, 933, 333, 1000 };
\layout Quotation


\family typewriter 
int comparacion_de_numeros (const int *p1, const int *p2)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 return (*p1 - *p2);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int buscar (int clave)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int *puntero_a_elemento;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* El molde (int (*) (const void *, const void *)) es necesario para evitar
 un error de tipo distinto en tiempo de compilación.
 Sin embargo, no es necesario: puntero_a_elemento = (int *) bsearch (...
 debido a que en este caso es el compilador el que realiza la conversión
 de tipos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 puntero_a_elemento = bsearch(&clave, array_de_numeros,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 NUM_ELEMENTOS(array_de_numeros), sizeof (int),
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (int(*) (const void *, const void *)) comparacion_de_numeros);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return (puntero_a_elemento != NULL);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 if(buscar (800))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("800 está en la tabla.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("800 no está en la tabla.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa por pantalla es:
\layout Quotation


\family typewriter 
800 está en la tabla.
\layout Subsection

lfind () y lsearch () 
\layout Standard

Estas dos funciones no pertenecen al ANSI C actual pero sí están incluidas
 en las versiones de Turbo C.
 Ambas funciones realizan una búsqueda lineal.
 Sus prototipos están en el fichero 
\family typewriter 
stdlib.h
\family default 
 y son los siguientes:
\layout Quotation


\family typewriter 
void *lfind (const void *clave, const void *base,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 size_t *num, size_t anchura,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int (*func_de_comp) (const void *elem1, const void *elem2));
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
void *lsearch (const void *clave, void *base, size_t *num, size_t anchura,
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int (*func_de_comp) (const void *elem1, const void *elem2));
\layout Standard

Estas funciones utilizan una rutina definida por el usuario (
\family typewriter 
func_de_comp
\family default 
) para la búsqueda de la clave, en un array de elementos secuenciales.
 El array tiene num elementos, cada uno de tamaño anchura bytes y comienza
 en la dirección de memoria apuntada por base.
 Devuelve la dirección de la primera entrada en la tabla que coincida con
 la clave buscada.
 Si la clave buscada no se encuentra, 
\family typewriter 
lsearch
\family default 
 la añade a la lista; 
\family typewriter 
lfind
\family default 
 devuelve 0.
\layout Standard

La rutina 
\family typewriter 
*func_de_comp
\family default 
 debe devolver cero si 
\family typewriter 
*elem1 == *elem2
\family default 
, y un valor distinto de cero en caso contrario.
 Ejemplo de la función 
\family typewriter 
lfind
\family default 
:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
int comparar (int *x, int *y)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 return (*x - *y);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int array[5] = { 5, -1, 100, 99, 10 };
\layout Quotation


\family typewriter 

\protected_separator 
 size_t nelem = 5;
\layout Quotation


\family typewriter 

\protected_separator 
 int clave;
\layout Quotation


\family typewriter 

\protected_separator 
 int *resultado;
\layout Quotation


\family typewriter 

\protected_separator 
 clave = 99;
\layout Quotation


\family typewriter 

\protected_separator 
 resultado = lfind(&clave, array, &nelem, sizeof (int),
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (int (*) (const void *, const void *)) comparar);
\layout Quotation


\family typewriter 

\protected_separator 
 if (resultado)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Número %d encontrado
\backslash 
n", clave);
\layout Quotation


\family typewriter 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Número %d no encontrado.
\backslash 
n", clave);
\layout Quotation


\family typewriter 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa es:
\layout Quotation


\family typewriter 
Número 99 encontrado.
\layout Standard

Ejemplo de la función 
\family typewriter 
lsearch
\family default 
:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int numeros[10] = { 3, 5, 1 };
\layout Quotation


\family typewriter 
int nnumeros = 3;
\layout Quotation


\family typewriter 
int comparar_numeros (int *num1, int *num2)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 return (*num1 - *num2);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int aniadir_elemento (int numero_clave)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int viejo_nnumeros = nnumeros;
\layout Quotation


\family typewriter 

\protected_separator 
 lsearch ((void *) &numero_clave, numeros,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (size_t *) &nnumeros, sizeof (int),
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (int (*) (const void *, const void *)) comparar_numeros);
\layout Quotation


\family typewriter 

\protected_separator 
 return (nnumeros == viejo_nnumeros);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 
 int clave = 2;
\layout Quotation


\family typewriter 

\protected_separator 
 if(aniadir_elemento (clave))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d está ya en la tabla de números.
\backslash 
n", clave);
\layout Quotation


\family typewriter 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d está añadido a la tabla de números.
\backslash 
n", clave);
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Números en tabla:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 
 for(i = 0; i < nnumeros; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d
\backslash 
n", numeros[i]);
\layout Quotation


\family typewriter 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Standard

La salida de este programa es:
\layout Quotation


\family typewriter 
2 está añadido a la tabla de números.
\layout Quotation


\family typewriter 
Números en tabla
\layout Quotation


\family typewriter 
3
\layout Quotation


\family typewriter 
5
\layout Quotation


\family typewriter 
1
\layout Quotation

2
\layout Section

Tipo void y Punteros
\layout Standard

Hasta esta lección hemos visto que el tipo 
\family typewriter 
void
\family default 
 tiene dos usos:
\layout Itemize

1.
 Para indicar que una función no devuelve nada.
 Ejemplo:
\layout Quotation


\family typewriter 
void hola(char *nombre) { printf ("Hola, %s", nombre); }
\layout Itemize

2.
 Para indicar que una función no acepta ningún argumento.
 Ejemplo: 
\layout Quotation


\family typewriter 
int numero_1 (void) { return 1; }
\layout Standard

Aplicados a punteros tiene otro uso: los punteros a 
\family typewriter 
void
\family default 
 son punteros genéricos que pueden apuntar a cualquier objeto.
 Pero los punteros a 
\family typewriter 
void
\family default 
 no pueden ser referenciados (utilizando 
\family typewriter 
*
\family default 
) sin utilizar moldes, puesto que el compilador no puede determinar el tamaño
 del objeto al que apunta el puntero.
 Ejemplo:
\layout Quotation


\family typewriter 
int x; float f;
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
void *p = &x; /* p apunta a x */
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 *(int *) p = 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 p = &r;
\protected_separator 
 /* p apunta a f */ 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 *(float *) p = 1.1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Section

Modificador de Acceso const y punteros
\layout Standard

El modificador de acceso 
\family typewriter 
const
\family default 
 aplicado a punteros ofrece varias posibilidades.
 Veámosla en los siguientes ejemplos:
\layout Quotation


\family typewriter 
void main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *p1 = "abc";
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* puntero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *p2 = "abc";
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* puntero a constante */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *const p3 = "abc";
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* puntero constante */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *const p4 = "abc"; /* puntero constante a constante */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *p1 = 'd'; /* correcto */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *p2 = 'd'; /* error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *p3 = 'd'; /* correcto */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *p4 = 'd'; /* error */
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p1++; /* correcto */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p2++; /* correcto */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p3++; /* error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p4++; /* error */
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p1 = p2; /* warning */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p1 = p3; /* correcto */ 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p1 = p4; /* warning */
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p2 = p1; /* correcto */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p2 = p3; /* correcto */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p2 = p4; /* correcto */
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p3 = p1; /* error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p3 = p2; /* error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p3 = p4; /* error */
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p4 = p1; /* error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p4 = p2; /* error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p4 = p3; /* error */
\layout Quotation


\family typewriter 
}
\layout Standard

Las líneas que contienen el mensaje de error provocan un error de compilación.
 Las líneas que contienen el mensaje de warning provoca en algunos compiladores
 un mensaje de conversión de puntero sospechosa que se puede solucionar
 haciendo la conversión de una forma explícita:
\layout Quotation


\family typewriter 
p1 = (char *) p2;
\layout Quotation


\family typewriter 
p1 = (char *) p4;
\layout Standard

Si ahora hacemos:
\layout Quotation


\family typewriter 
*p1 = 'd';
\layout Standard

estamos modificando los valores apuntados por 
\family typewriter 
p2
\family default 
 y 
\family typewriter 
p4
\family default 
; es decir, los valores apuntados por 
\family typewriter 
p2
\family default 
 y 
\family typewriter 
p4
\family default 
 no pueden ser modificados por estos punteros pero sí pueden ser modificados
 indirectamente por otro puntero.
 Otro ejemplo de cómo se puede modificar el valor de una constante indirectament
e a través de un puntero:
\layout Quotation


\family typewriter 
const int x = 10; /* x es una variable constante */
\layout Quotation


\family typewriter 
x = 20; /* esto provoca un error en compilación */
\layout Quotation


\family typewriter 
*(int *)&x = 20; /* esto es correcto: obtenemos su dirección, que
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 es del tipo (const int *) y la moldeamos al tipo
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (int *), una vez hecho esto accedemos al valor de
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 esa dirección con el operador de contenido * */
\layout Section

Declaraciones Curiosas
\layout Standard

El C permite la creación de formas de datos muy elaboradas.
 Cuando se hace una declaración, el nombre (o "identificador") que usamos
 se puede modificar añadiéndole uno o varios modificadores:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
4 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Modificador
\newline 
Significado
\series default 

\newline 

\family typewriter 
*
\family default 

\newline 
indica un puntero
\newline 

\family typewriter 
( )
\family default 

\newline 
indica una función
\newline 

\family typewriter 
[ ]
\family default 

\newline 
indica un array
\layout Standard

La clave para desentrañar las declaraciones que mostraremos a continuación
 es averiguar el orden en que se aplican los modificadores.
 Para ello se siguen tres reglas:
\layout Enumerate

La prioridad de un modificador es tanto mayor cuanto más próximo esté el
 identificador.
\layout Enumerate

Los modificadores 
\family typewriter 
[]
\family default 
 y 
\family typewriter 
()
\family default 
 tienen mayor prioridad que 
\family typewriter 
*
\family default 
.
\layout Enumerate

Se pueden usar paréntesis para agrupar parte de la expresión otorgándole
 la máxima prioridad.
\layout Standard

Ejemplos:
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* array de arrays de int */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int x1[8][8];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* puntero a puntero a int */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int **x2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* array de 10 punteros a int */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int *x3[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* puntero a array de 10 int */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int (*x4)[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* array de 3 punteros a array de 4 int */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int *x5[3][4];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* puntero a array de 3x4 int */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int (*x6)[3][4];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* función que devuelve un puntero a int */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int *x7(void);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* puntero a función que devuelve un tipo int */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int (*x8)(void);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* función que acepta un puntero a char como argumento y que devuelve un
 puntero a un puntero a una función que devuelve un carácter */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char (*(*x11(char*)))(void);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* puntero a función que devuelve un puntero a puntero a carácter y acepta
 dos argumentos: el primero es un puntero a puntero a puntero a carácter,
 y el segundo es un array de 10 punteros a carácter */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char ** (*x12) (char ***, char *[10]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* función que acepta un puntero a puntero a puntero a constante y devuelve
 una puntero constante a constante */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const void * const x13 (const void ***);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* función que no devuelve nada y acepta como argumento un puntero a función
 que no devuelve nada y acepta como argumento un puntero a función que no
 devuelve nada y no acepta ningún argumento */ 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 void x14 (void (*) (void (*) (void)));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* función que acepta un int como argumento y devuelve un puntero a una
 función que acepta un int como argumento y que devuelve un int */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int (* (x15 (int))) (int);
\layout Quotation


\family typewriter 
}
\layout Section

Modificadores de Tipo near, far, huge y Modelos de Memoria en Turbo C
\layout Standard

En MS-DOS se suele direccionar memoria en la forma:
\layout Quotation


\family typewriter 
segmento:offset
\layout Standard

donde cada segmento son 64K y offset es el desplazamiento dentro de cada
 segmento.
\layout Standard

Los modificadores de tipo 
\family typewriter 
near
\family default 
, 
\family typewriter 
far
\family default 
 y 
\family typewriter 
huge
\family default 
, que sólo se pueden aplicar a punteros y funciones, están relacionados
 con el direccionamiento de memoria.
 El modificador 
\family typewriter 
near
\family default 
 (cerca) fuerza que el valor de un puntero o una función estén en un sólo
 segmento mientras que 
\family typewriter 
far
\family default 
 (lejos) y 
\family typewriter 
huge
\family default 
 (enorme) hacen que un puntero pueda apuntar a cualquier dirección de la
 memoria y una función puede estar en culquier lugar de la memoria disponible.
 A continuación exponemos la descripción de los modificadores 
\family typewriter 
near
\family default 
, 
\family typewriter 
far
\family default 
 y 
\family typewriter 
huge
\family default 
 así como los distintos modelos de compilación en Turbo C:
\layout Subsection

near (modificador de tipo)
\layout Standard

Fuerza a los punteros a ser 
\family typewriter 
near
\family default 
 (estar cerca, un mismo segmento), genera código de funciones para llamadas
 
\family typewriter 
near
\family default 
 y devuelve un valor 
\family typewriter 
near
\family default 
.
\layout Quotation


\family typewriter 
<tipo> near <definicion-puntero> ;
\layout Standard

o
\layout Quotation


\family typewriter 
<tipo> near <definicion-funcion>
\layout Standard

La primera versión de 
\family typewriter 
near
\family default 
 declara un puntero de tamaño una palabra (2 bytes) con un rango de 64K.
 Este modificador de tipo es usado normalmente cuando se compila en los
 modelos de memoria 
\family typewriter 
medium
\family default 
, 
\family typewriter 
large
\family default 
 y 
\family typewriter 
huge
\family default 
 para forzar a que los punteros sean 
\family typewriter 
near
\family default 
 (ya que por defecto, son 
\family typewriter 
far
\family default 
, en los modelos de memoria mencionados).
 Ejemplo
\layout Quotation


\family typewriter 
char near *s;
\layout Quotation


\family typewriter 
int (near *pi)[10];
\layout Standard

Cuando 
\family typewriter 
near
\family default 
 es usado con una declaración de función, Turbo C genera código de función
 para una llamada 
\family typewriter 
near
\family default 
 y devuelve 
\family typewriter 
near
\family default 
.
 Ejemplo
\layout Quotation


\family typewriter 
int near mi_funcion () {}
\layout Subsection

far (modificador de tipo)
\layout Standard

Fuerza a los punteros a ser 
\family typewriter 
far
\family default 
 (estar lejos, cualquier segmento), genera código de funciones para llamadas
 
\family typewriter 
far
\family default 
 y devuelve un valor 
\family typewriter 
far
\family default 
.
\layout Quotation


\family typewriter 
<tipo> far <definicion-puntero> ;
\layout Standard

o
\layout Quotation


\family typewriter 
<tipo> far <definicion-funcion>
\layout Standard

La primera versión de 
\family typewriter 
far
\family default 
 declara un puntero de tamaño dos palabras (4 bytes) con un rango de 1 megabyte.
 Este modificador de tipo es usado normalmente cuando se compila en los
 modelos de memoria 
\family typewriter 
tiny
\family default 
, 
\family typewriter 
small
\family default 
 y 
\family typewriter 
compact
\family default 
 para forzar a que los punteros sean 
\family typewriter 
far
\family default 
 (ya que por defecto, son 
\family typewriter 
near
\family default 
, en los modelos de memoria mencionados).
 Ejemplo
\layout Quotation


\family typewriter 
char far *s;
\layout Quotation


\family typewriter 
void * far * p;
\layout Standard

Cuando 
\family typewriter 
far
\family default 
 es usado con una declaración de función, Turbo C genera código de función
 para una llamada 
\family typewriter 
far
\family default 
 y devuelve 
\family typewriter 
far
\family default 
.
 Ejemplo
\layout Quotation


\family typewriter 
int far my_func() {}
\layout Subsection

huge (modificador de tipo)
\layout Standard

Es similar al modificador de tipo 
\family typewriter 
far
\layout Quotation


\family typewriter 
<tipo> huge <definicion-puntero> ;
\layout Standard

El modificador 
\family typewriter 
huge
\family default 
 es similar al modificador 
\family typewriter 
far
\family default 
 pero tiene dos características adicionales:
\layout Itemize

Su segmento es normalizado durante la aritmética de punteros así que las
 comparaciones de punteros son más precisas.
\layout Itemize

Los punteros huge pueden ser incrementados sin el temor de que sobrepase
 un segmento.
\layout Standard

En resumen, la utilización de punteros 
\family typewriter 
huge
\family default 
 es más segura que la utilización de punteros 
\family typewriter 
far
\family default 
, pero su uso es más lento porque requieren más comprobaciones.
\layout Subsection

Opciones de modelo
\layout Standard

Las opciones de modelo especifican qué modelo de memoria se quiere usar.
 El modelo de memoria elegido determina el método de direccionamiento de
 memoria por defecto.
 El modelo por defecto es 
\family typewriter 
small
\family default 
.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
10 6 0 0 -1 -1 -1 -1
1 0 0 0
0 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 0 "" ""
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
1 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
1 8 1 1 0 0 0 "" ""
1 8 1 1 0 0 0 "" ""
1 8 1 1 0 0 0 "" ""
1 8 1 1 0 0 0 "" ""
1 8 1 1 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
1 8 0 1 0 0 0 "" ""
1 8 0 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
1 8 1 1 0 0 0 "" ""
1 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""
2 8 1 1 0 0 0 "" ""
2 8 1 0 0 0 0 "" ""


\series bold 

\newline 
Segmentos 
\newline 
Punteros 
\newline 
Modelo
\newline 
Código
\newline 
Datos
\newline 
Pila
\newline 
Código
\newline 
Datos
\series default 

\newline 
Tiny
\newline 
64 K
\newline 
near
\newline 
near
\newline 
Small
\newline 
64 K
\newline 
64 K
\newline 
near
\newline 
near
\newline 
Medium
\newline 
1 MB
\newline 
64 K
\newline 
far
\newline 
near
\newline 
Compact
\newline 
64 K
\newline 
 1 MB
\newline 
near
\newline 
far
\newline 
Large
\newline 
1 MB
\newline 
 1 MB
\newline 
far
\newline 
far
\newline 
Huge
\newline 
1 MB
\newline 
64 K
\newline 
64 K
\newline 
far
\newline 
far
\newline 

\newline 

\newline 
cada uno
\newline 
pila
\newline 

\newline 

\newline 
Tiny
\newline 
 
\layout Standard

Usa el modelo 
\family typewriter 
tiny
\family default 
 (muy pequeño) cuando la cantidad de memoria a consumir es muy importante
 y ha de ser la menor posible.
 Los cuatro registros de segmentos (CS, DS, ES, SS) toman la misma dirección,
 de este modo tenemos un total de 64K para código, datos y pila.
 Siempre se usan punteros 
\family typewriter 
near
\family default 
.
 Los programas de modelo tiny pueden ser convertidos a formato 
\family typewriter 
.COM
\family default 
.
\layout Description


\size larger 
Small
\layout Standard

Usa el modelo 
\family typewriter 
small
\family default 
 (pequeño) para aplicaciones de tamaño medio.
 Los segmentos de código y datos son diferentes, así que tenemos 64K de
 código y 64K de datos y pila.
 Siempre son usados los punteros 
\family typewriter 
near
\family default 
.
\layout Description


\size larger 
Medium
\layout Standard

El modelo 
\family typewriter 
medium
\family default 
 (medio) es mejor para grandes programas que no guardan muchos datos en
 memoria.
 Los punteros 
\family typewriter 
far
\family default 
 son usados para código pero no para datos.
 Esto da como resultado que los datos y la pila juntos están limitados a
 64K, pero el código puede ocupar hasta 1MB.
\layout Description


\size larger 
Compact
\layout Standard

Usa el modelo 
\family typewriter 
compact
\family default 
 (compacto) si tu código es pequeño pero necesitas direccionar una gran
 cantidad de datos.
 El modelo compact es el contrario al modelo 
\family typewriter 
medium
\family default 
: los punteros 
\family typewriter 
far
\family default 
 son usados para los datos pero no para el código; el código está limitado
 entonces a 64K, mientras que los datos tienen un rango de 1Mb.
 Todas las funciones son 
\family typewriter 
near
\family default 
 por defecto y todos los punteros de datos son 
\family typewriter 
far
\family default 
 por defecto.
\layout Description


\size larger 
Large
\layout Standard

Usa el modelo 
\family typewriter 
large
\family default 
 (grande) para aplicaciones muy grandes solamente.
 Los punteros 
\family typewriter 
far
\family default 
 son usados para código y datos, dando un rango de 1Mb para ambos.
 Todas las funciones y punteros de datos son far por defecto.
\layout Description


\size larger 
Huge
\layout Standard

Usa el modelo 
\family typewriter 
huge
\family default 
 (muy grande) para aplicaciones muy grandes solamente.
 Los punteros 
\family typewriter 
far
\family default 
 son usados para el código y los datos.
 Turbo C limita normalmente el tamaño de los datos a 64K; el modelo de memoria
 
\family typewriter 
huge
\family default 
 aparta ese límite permitiendo a los datos ocupar más de 64K.
 El modelo 
\family typewriter 
huge
\family default 
 permite múltiples segmentos de datos (cada uno de 64K de tamaño), hasta
 1MB para el código, y 64K para la pila.
 Todas las funciones y punteros de datos se asumen como 
\family typewriter 
far
\family default 
.
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 7-1
\series default 
.
 Escribe un programa que acepte como entrada una cadena de un texto y sustituya
 todos los conjuntos de dos o más espacios seguidos por espacios únicos.
\layout Itemize


\series bold 
Ejercicio 7-2
\series default 
.
 Escribe un programa que lee dos fechas y calcule e imprima la diferencia
 en días que hay entre las dos fechas introducidas.
 Las fechas serán cadenas de caracteres con el fomato: "dd/mm/aa".
 
\series bold 
Nota
\series default 
: Sería conveniente diseñar una función que acepte como argumento un string
 conteniendo la fecha y devuelve 1 si el string contiente una fecha correcta
 o 0 en caso contrario.
 Para que la fecha sea convalidada, ésta debe superar las siguientes pruebas:
\begin_deeper 
\layout Itemize

La longitud del string correspondiente a la fecha es de 8 caracteres.
\layout Itemize

Los caracteres tercero y sexto son /.
\layout Itemize

Los restantes caracteres son números.
\layout Itemize

El valor del mes tiene que estar entre 1 y 12.
\layout Itemize

El valor del día tiene que estar 1 y el número de días de ese mes.
\end_deeper 
\layout Quote

Si se quiere tener en cuenta los años bisiestos recordar que aquellos años
 divisibles de forma exacta por 4 son bisiestos, y que el número de años
 bisiestos transcurridos desde el principio del siglo es la parte entera
 del cociente año/4.
\layout Itemize


\series bold 
Ejercicio 7-3
\series default 
.
 Implementar las funciones que se describen a continuación junto con una
 función main para probarlas.
\begin_deeper 
\layout Itemize

Función que acepte dos strings: s1 y s2, y devuelva el número de caracteres
 que hay en s1 que no están en s2.
\layout Itemize

Función que acepte dos strings: s1 y s2, y devuelva el número de caracteres
 que hay en s1 que están en s2.
\layout Itemize

Función que acepte un string que puede contener caracteres repetidos y lo
 devuelva sin ningún carácter repetido en su interior.
\layout Itemize

Función que acepte un substring y un número n y devuelva un string con tantas
 copias del substring como indique el número n.
\layout Itemize

Función que acepte un string y lo devuelva con todos sus caracteres convertidos
 en mayúsculas.
 Los caracteres con código ascii mayor de 127: ñ, á, é, í, ó y ú serán convertid
os respectivamente a: Ñ, A, E, I, O, U.
\end_deeper 
\layout Chapter

Tipos Compuestos de Datos
\layout Standard

El objetivo de esta lección es hacer un estudio completo en todo lo referente
 a la declaración, utilización e inicialización de tipos compuestos de datos
 y explicar cómo se pueden crear nuevos tipos de datos a partir de los ya
 existentes.
 El lenguaje C proporciona cinco maneras diferentes de crear tipos de datos:
\layout Itemize

Estructuras (
\family typewriter 
struct
\family default 
).
\layout Itemize

Campos de bits.
\layout Itemize

Uniones (
\family typewriter 
union
\family default 
).
\layout Itemize

Enumeraciones (
\family typewriter 
enum
\family default 
).
\layout Itemize

Tipos definidos por el usuario (
\family typewriter 
typedef
\family default 
).
\layout Standard

Al terminar la lección se presenta una tabla de precedencia de todos los
 operadores del lenguaje C.
\layout Section

Estructuras 
\layout Standard

En el lenguaje C una estructura es un conjunto de variables que se referencia
 bajo un mismo nombre, proporcionando un medio conveniente de mantener junta
 información relacionada.
 Las estructuras se denominan registros en otros lenguajes; por ejemplo,
 en Pascal.
 A los elementos de la estructura se les suele llamar miembros o campos.
\layout Subsection

Declaración de Estructuras
\layout Standard

Una estructura se declara con la palabra 
\family typewriter 
struct
\family default 
 seguida de una lista de declaraciones encerradas entre llaves.
 Ejemplo:
\layout Quotation


\family typewriter 
struct
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int dia; 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int mes; 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int anio;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Standard

Después de la palabra clave 
\family typewriter 
struct
\family default 
 va opcionalmente el nombre de la estructura y se puede emplear en declaraciones
 posteriores como una abreviatura de la entrada.
\layout Quotation


\family typewriter 
struct fecha 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int dia; 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int mes; 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int anio;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 };
\layout Standard

En los ejemplos anteriores no se han declarado realmente variables, sino
 que sólo se han definido la forma de los datos.
 Para declarar una variable de un tipo estructura sin nombre se hace:
\layout Quotation


\family typewriter 
struct
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int dia, mes, anio;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 } fecha_creacion;
\layout Standard

Si la estructura tiene nombre se puede hacer de la siguiente forma: 
\layout Quotation


\family typewriter 
struct fecha { int dia, mes, anio; };
\layout Quotation


\family typewriter 
struct fecha fecha_creacion;
\layout Standard

De la misma forma se pueden declarar varias variables separadas por comas:
\layout Quotation


\family typewriter 
struct
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int dia, mes, anio;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 } fecha1, fecha2, fecha3;
\layout Standard

o bien:
\layout Quotation


\family typewriter 
struct fecha { int dia, mes, anio; };
\layout Quotation


\family typewriter 
struct fecha fecha1, fecha2, fecha3; 
\layout Standard

También se puede crear un tipo estructura y una variable de tipo estructura
 al mismo tiempo:
\layout Quotation


\family typewriter 
struct
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int dia, mes, anio;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 } fecha1, fecha2, fecha3;
\layout Standard

La forma general de definición de un estructura es:
\layout Quotation


\family typewriter 
struct nombre_tipo_estructura
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tipo_1 nombre_variable_1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tipo_2 nombre_variable_2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ...
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tipo_n nombre_variable_n;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 } nombres_variables_estructura;
\layout Standard

donde tanto los nombres 
\family typewriter 
nombre_tipo_estructura
\family default 
 como 
\family typewriter 
nombres_variables_estructura
\family default 
 pueden omitirse.
\layout Subsection

Inicialización de Estructuras
\layout Standard

Una estructura se inicializa añadiendo a su definición la lista de inicializacio
nes de las componentes.
\layout Quotation


\family typewriter 
struct fecha fecha_creacion = { 22, 7, 90 };
\layout Subsection

Tamaño de una Estructura
\layout Standard

El tamaño en bytes de un tipo estructura en memoria es la suma de los tamaños
 en bytes de cada uno de los tipos de sus componentes:
\layout Quotation


\family typewriter 
sizeof (struct fecha) == sizeof (int) + sizeof (int) + sizef (int)
\layout Subsection

Referencia a los Elementos de la Estructura
\layout Standard

Los elementos individuales de la estructura se referencia utilizando el
 operador punto (
\family typewriter 
.
\family default 
).
 La forma general es:
\layout Quotation


\family typewriter 
fecha_creacion.dia = 3;
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
printf("%d", fecha_creacion.dia); /* muestra el valor 3 */
\layout Standard

Un elemento de una estructura, el nombre de una estructura y una variable
 ordinaria pueden tener el mismo nombre; siempre se pueden distinguir a
 través del contexto.
 Por supuesto que estas cosas se deben evitar en lo posible si disminuyen
 la legibilidad del código.
 Por ejemplo:
\layout Quotation


\family typewriter 
struct x { int x; } x;
\layout Subsection

Algunos Tipos Usuales que se Pueden Hacer con las Estructuras
\layout Subsubsection

Arrays de Estructuras 
\layout Description

Declaración
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
10 2 0 0 -1 -1 -1 -1
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
struct x
\newline 
struct x
\newline 
{
\newline 
{
\newline 

\protected_separator 
 char *s;
\newline 

\protected_separator 
 char *s;
\newline 

\protected_separator 
 int d;
\newline 

\protected_separator 
 int d;
\newline 
} y[] =
\newline 
} y[] =
\newline 
{
\newline 
{
\newline 

\protected_separator 
 "s1", 4,
\newline 

\protected_separator 
 { "s1", 4 },
\newline 

\protected_separator 
 "s2", 3,
\newline 

\protected_separator 
 { "s2", 3 },
\newline 

\protected_separator 
 "s3", 10
\newline 

\protected_separator 
 { "s3", 10 }
\newline 
};
\newline 
};
\layout Description

Utilización
\layout Quotation


\family typewriter 
printf ("%s %d", y[1].s, y1[1].d); /* imprime s2 3 */
\layout Subsubsection

Arrays dentro de Estructuras
\layout Description

Declaración
\layout Quotation


\family typewriter 
struct x
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int a[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 float b;
\protected_separator 
 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 } y;
\layout Description

Utilización
\layout Quotation


\family typewriter 
y.a[1] = 2;
\layout Subsubsection

Estructuras dentro de Estructuras (Estructuras Anidadas)
\layout Description

Declaración
\layout Quotation


\family typewriter 
struct persona
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char nombre[TAMNOMBRE], direccion[TAMDIRECCION];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 struct fecha fecha_nacimiento;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 } empleado;
\layout Description

Utilización
\layout Quotation


\family typewriter 
empleado.fecha_nacimiento.dia = 10;
\layout Subsubsection

Punteros a Estructuras
\layout Description

Declaración
\layout Quotation


\family typewriter 
struct fecha fecha_creacion, *pfecha;
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
pfecha = &fecha_creacion;
\layout Description

Utilización
\layout Standard

Hay dos formas equivalentes de acceder a los elementos de una estructura
 mediante un puntero a la estructura:
\layout Standard


\protected_separator 

\protected_separator 

\protected_separator 
 1) 
\layout Quotation


\family typewriter 
(*pfecha).dia = 20;
\layout Standard

Los paréntesis son necesarios porque el operador 
\family typewriter 
.

\family default 
 tiene más prioridad que el operador 
\family typewriter 
*
\family default 
.
\layout Standard


\protected_separator 

\protected_separator 

\protected_separator 
 2) 
\layout Quotation


\family typewriter 
pfecha->dia = 20;
\layout Standard

El operador 
\family typewriter 
->
\family default 
 se utiliza para acceder a un elemento de una estructura a través de un
 puntero.
 Esta forma es mucho más común que la anterior, es más, el primer método
 se considera arcaico en los estándares actuales.
 Debido a que este tipo de operación es tan común, C proporciona un operador
 específico para realizar esta tarea: el operador flecha (
\family typewriter 
->
\family default 
).
\layout Section

Estructuras y Funciones
\layout Standard

Con respecto a las estructuras, a una función le podemos pasar como argumento:
\layout Itemize

Un elemento de una estructura.
\layout Itemize

Una estructura completa.
\layout Itemize

La dirección de una estructura.
\layout Subsection

Paso de Elementos a Estructuras a Funciones
\layout Standard

Cuando se pasa un elemento de una variable de estructura a una función,
 se está realmente pasando el valor de ese elemento a la función.
 Además, si ese elemento es de tipo simple, se está pasando una variable
 simple.
 Ejemplo:
\layout Quotation


\family typewriter 
struct x
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 char c;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 char s[10];
\layout Quotation


\family typewriter 

\protected_separator 
 } y = { 2, 'd', "string" };
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
/* pasando argumentos por valor: */
\layout Quotation


\family typewriter 
func1 (y.i);
\protected_separator 

\protected_separator 

\protected_separator 
 /* se pasa variable entera (2) */
\layout Quotation


\family typewriter 
func2 (y.c);
\protected_separator 

\protected_separator 

\protected_separator 
 /* se pasa variable carácter ('d') */
\layout Quotation


\family typewriter 
func3 (y.s);
\protected_separator 

\protected_separator 

\protected_separator 
 /* se pasa variable string (dirección de la cadena s) */
\layout Quotation


\family typewriter 
func4 (y.s[1]); /* se pasa variable carácter ('t') */
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
/* pasando argumentos por referencia: */
\layout Quotation


\family typewriter 
func5 (&y.i);
\protected_separator 

\protected_separator 
 /* se pasa la dirección de la variable entera y.i */
\layout Quotation


\family typewriter 
func6 (&y.c);
\protected_separator 

\protected_separator 
 /* se pasa la dirección de la variable carácter y.c */
\layout Quotation


\family typewriter 
func7 (y.s);
\protected_separator 

\protected_separator 

\protected_separator 
 /* se pasa la dirección del string y.s */
\layout Quotation


\family typewriter 
func8 (&y.s[1]);/* se pasa la dirección de la variable carácter y.s[1] */
\layout Standard

Observar que el operador 
\family typewriter 
&
\family default 
 precede al nombre de la estructura y no al nombre del elemento individual.
\layout Subsection

Paso de Estructuras a Funciones
\layout Standard

Cuando se utiliza una estructura como argumento de una función, se pasa
 la estructura íntegra mediante el uso del método estándar de llamada por
 valor.
 Esto significa, por supuesto, que todos los cambios realizados en los contenido
s de la estructura, dentro de la función a la que se pasa, no afectan a
 la estructura utilizada como argumento.
\layout Standard


\series bold 
Ejemplo 1: Estructura sin nombre.
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void f(); /* los paréntesis vacíos quieren decir que no decimos
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 nada acerca de sus parámetros */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 struct { int a, b; } arg;
\layout Quotation


\family typewriter 

\protected_separator 
 arg.a = 10;
\layout Quotation


\family typewriter 

\protected_separator 
 f(arg); /* imprime 10 */
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void f(param)
\layout Quotation


\family typewriter 
struct { int x, y; } param;
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf("%d", param.x);
\layout Quotation


\family typewriter 
}
\layout Standard


\series bold 
Ejemplo 2: Estructura con nombre.
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
struct st { int a, b; }; /* si se declarase dentro de la función main, esta
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 estructura sólo se conocería en esa función */
\layout Quotation


\family typewriter 
void f(); /* los paréntesis vacíos quieren decir que no decimos
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 nada acerca de sus parámetros */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 struct st arg;
\layout Quotation


\family typewriter 

\protected_separator 
 arg.a = 10;
\layout Quotation


\family typewriter 

\protected_separator 
 f(arg); /* imprime 10 */
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void f(param)
\layout Quotation


\family typewriter 
struct st param;
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf("%d", param.a);
\layout Quotation


\family typewriter 
}
\layout Subsection

Paso de Direcciones de Estructuras a Funciones
\layout Standard

En la práctica nunca se pasan las estructuras completas a funciones porque
 ese procedimiento es tremendamente ineficiente (en cuanto a tiempo y memoria
 consumida).
 Lo que se hace en lugar de ello es pasar la dirección de la variable estructura
 como argumento y declarar el parámetro de la función como un puntero a
 esta estructura.
 Ejemplo: Paso de dirección de variable estructura.
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
struct st { int a, b; }; /* si se declarase dentro de la función main, esta
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 estructura sólo se conocería en esa función */
\layout Quotation


\family typewriter 
void f(); /* los paréntesis vacíos quieren decir que no decimos
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 nada acerca de sus parámetros */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 struct st arg;
\layout Quotation


\family typewriter 

\protected_separator 
 arg.a = 10;
\layout Quotation


\family typewriter 

\protected_separator 
 f(&arg);
\protected_separator 
 /* imprime 10 */
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void f(param)
\layout Quotation


\family typewriter 
struct st *param;
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 printf("%d", param->a);
\layout Quotation


\family typewriter 
}
\layout Standard

Si consideramos que 
\family typewriter 
sizeof(struct st *)==2
\family default 
 y 
\family typewriter 
sizeof(int)==2
\family default 
, entonces 
\family typewriter 
sizeof(struct st)==4
\family default 
.
 Por lo tanto, al pasar la estructura íntegra pasamos 4 bytes a la función
 y al pasar el puntero a la estructura sólo pasamos 2 bytes a la función.
 En el ejemplo visto la diferencia no parece muy significativa, pero si
 
\family typewriter 
sizeof(struct st)==1000
\family default 
, al pasar la estructura íntegra pasamos 1000 bytes mientras que con su
 dirección pasamos 2 bytes.
\layout Standard

Para los usuarios que tengan la opción turbo on, recordarán que los punteros
 
\family typewriter 
near
\family default 
 ocupan 2 bytes (sólo contienen el desplazamiento dentro del segmento de
 memoria) y los punteros 
\family typewriter 
far
\family default 
 4 bytes (contienen segmento y desplazamiento dentro del segmento).
 Al suponer en el párrafo anterior que 
\family typewriter 
sizeof(struct st *)==2
\family default 
, estamos suponiendo que el puntero es 
\family typewriter 
near
\family default 
.
\layout Section

Campo de Bits
\layout Standard

A difererencia de la mayoría de los lenguajes de computadoras, el lenguaje
 C tiene un método incorporado para acceder a un bit individual dentro de
 un byte.
 Esto se puede hacer con los operadores de bits que vimos en la lección
 2 pero también se puede hacer con un tipo especia de estructura llamada
 campo de bits.
\layout Subsection

Declaración
\layout Standard

La forma general de definición de un campo de bits es:
\layout Quotation


\family typewriter 
struct nombre_estructura
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 tipo1 nombre1 : longitud1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 tipo2 nombre2 : longitud2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 ...
\layout Quotation


\family typewriter 

\protected_separator 
 };
\layout Standard

Un campo de bits tiene que declararse como 
\family typewriter 
int
\family default 
, 
\family typewriter 
unsigned
\family default 
, o 
\family typewriter 
signed
\family default 
.
 Los campos de bits de 
\family typewriter 
longitud1
\family default 
 deben declararse como unsigned debido a que un bit individual no puede
 tener signo.
 Los nombres de los campos son opcionales.
 Ejemplo: 
\layout Quotation


\family typewriter 
struct operacion
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned leer: 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned escribir: 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned abrir: 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned cerrar: 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned: 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned error: 1;
\layout Quotation


\family typewriter 

\protected_separator 
 } operacion_fichero;
\layout Standard

A los campos de bits se accede de la misma forma que a los campos de cualquier
 estructura:
\layout Quotation


\family typewriter 
operacion_fichero.abrir = 1;
\layout Standard

Los campos de bits tienen algunas restricciones: no se puede tomar la dirección
 de una variable de campos de bits; en algunas máquinas, los campos se disponen
 de izquierda a derecha y en otras de derecha a izquierda, esto implica
 código menos portable.
\layout Standard

Se puede mezclar elementos normales de estructura con elementos de campos
 de bits.
 Por ejemplo:
\layout Quotation


\family typewriter 
struct st
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char ch;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned c1: 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned c2: 3;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 };
\family default 
 
\layout Standard

El tamaño de esta estructura, 
\family typewriter 
sizeof (struct st)
\family default 
, es 2: 1 byte para 
\family typewriter 
ch
\family default 
 y 1 byte para 
\family typewriter 
c1
\family default 
 y 
\family typewriter 
c2
\family default 
.
\layout Section

Uniones
\layout Standard

Las uniones son similares a las estructuras.
 Su declaración y utilización es exactamente igual que el de las estructuras
 con la excepción que utiliza la palabra clave union en vez de 
\family typewriter 
struct
\family default 
.
 La diferencia que hay entre una variable estructura y una variable unión
 es que es esta última todos sus elementos ocupan la misma posición de memoria.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 union { int x, y; } u;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 u.x = 10; /* también estamos haciendo u.y = 10, puesto
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 que x e y comparten la misma posición de memoria */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", u.y); /* imprime 10 */
\layout Quotation


\family typewriter 
}
\layout Standard

El tamaño del tipo 
\family typewriter 
union
\family default 
 es el tamaño del elemento que necesita más memoria.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 union
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char ch;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 } u;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 u.i = 257;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d %d", u.ch, (char) u.i); /* imprime:
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Section

Enumeraciones
\layout Standard

Una enumeración es un conjunto de constantes enteras con nombre que especifica
 todos los valores válidos que una variable de ese tipo puede tomar.
 La forma general de declaración es:
\layout Quotation


\family typewriter 
enum nombre_tipo_enum { lista_de_enumeracion } lista_variables;
\layout Standard

Aquí, al igual que con las estructuras, tanto el nombre de la enumeración
 
\family typewriter 
nombre_tipo_enum
\family default 
 como 
\family typewriter 
lista_variables
\family default 
 son opcionales.
 Ejemplo:
\layout Quotation


\family typewriter 
enum colores { azul, rojo, amarillo };
\layout Quotation


\family typewriter 
enum colores color;
\layout Standard

Dada esta declaración y definición la variable color sólo puede tomar tres
 valores posibles: azul, rojo o amarillo.
 Ejemplo:
\layout Quotation


\family typewriter 
color = rojo;
\layout Quotation


\family typewriter 
if(color == azul)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("el color es azul");
\layout Standard

Cada uno de los símblos del conjunto de enumeración es un valor entero,
 tomando el primero el valor 0, el segundo el valor 1 y así sucesivamente.
 Ejemplo:
\layout Quotation


\family typewriter 
printf("%d %d %d", azul, rojo, amarillo); /* muestra
\protected_separator 
 */
\layout Standard

Podríamos haber dado otros valores numéricos a los símbolos si hubiésemos
 declarado colores, por ejemplo, del siguiente modo:
\layout Quotation


\family typewriter 
enum colores { azul, rojo = 10, amarillo };
\layout Standard

Ahora la sentencia 
\family typewriter 
printf
\family default 
 anterior mostraría .
 Como se ve, los símbolos no inicializados toman el valor numérico siguiente
 al del símbolo anterior, excepto el primero que toma el valor 0 si no es
 inicializado.
\layout Section

Tipos Definidos por el Usuario: typedef 
\layout Standard

El programador puede crear (dar nombre en realidad) tipos a partir de los
 tipos ya definidos mediante la palabra clave 
\family typewriter 
typedef
\family default 
.
 La forma general de la sentencia typedef es:
\layout Quotation


\family typewriter 
typedef tipo nombre;
\layout Standard

donde tipo es cualquier tipo de datos permitido y nombre es el nuevo nombre
 para ese tipo.
 El uso de 
\family typewriter 
typedef
\family default 
 hace más fácil de leer el código y más fácil de transportar a una nueva
 máquina.
 Pero recuerda: 
\emph on 
NO
\emph default 
 se crea ningún tipo de datos nuevo, sólo se da otro nombre.
 Ejemplos:
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 typedef int boolean;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 boolean b; /* equivalente a: int b; */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 typedef int vector[100];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 vector v; /* equivalente a: int v[100]; */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 typedef char *pc;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 pc string; /* equivalente a: char *string; */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 typedef void (*pf) (void);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 pf f; /* equivalente a: void (*f) (void); */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 typedef struct { int x, y; } st;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 st estructura1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* equivalente a: struct { int x, y; } estructura; */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct st { int x, y; };
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 typedef struct st s;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 s estructura2; /* equivalente a: struct st estructura; */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 typedef int entero;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 typedef const entero * const puntero_constante_a_constante_entera;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 puntero_constante_a_constante_entera pcace;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* equivalente a: const int * const pcace; */
\layout Quotation


\family typewriter 
}
\layout Section

Precedencia de Operadores
\layout Standard

Con los operadores punto (
\family typewriter 
.
\family default 
) y flecha (
\family typewriter 
->
\family default 
) hemos completado el estudio de todos los operadores de C.
 A continuación mostramos la tabla completa de precedencia de operadores.
 En la siguiente tabla de precedencia de operadores, los operadores son
 divididos en 15 categorías.
 La categoría #1 tiene la precedencia más alta; la categoría #2 (operadores
 unarios) toma la segunda precedencia, y así hasta el operador coma, el
 cual tiene la precedencia más baja.
 Los operadores que están dentro de una misma categoría tienen igual precedencia.
 Los operadores unarios (categoría #2), condicional (categoría #13), y de
 asignación (categoría #14) se asocian de derecha a izquierda; todos los
 demás operadores se asocian de izquierda a derecha.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
45 3 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
0 0 0 0
0 0 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Categoría
\newline 
Operador
\newline 
Qué es (o hace)
\series default 

\newline 
1.
 Más alto
\newline 

\family typewriter 
()
\family default 

\newline 
Llamada a función
\newline 

\newline 

\family typewriter 
[]
\family default 

\newline 
Indexamiento de array
\newline 

\newline 

\family typewriter 
->
\family default 

\newline 
Selector de componente indirecta
\newline 

\newline 

\family typewriter 
.
\family default 

\newline 
Selector de componente directa
\newline 
2.
 Unario
\newline 

\family typewriter 
!
\family default 

\newline 
Negación Lógica (NO)
\newline 

\newline 

\family typewriter 
~
\family default 

\newline 
Complemento a 1
\newline 

\newline 

\family typewriter 
+
\family default 

\newline 
Más unario
\newline 

\newline 

\family typewriter 
-
\family default 

\newline 
Menos unario
\newline 

\newline 

\family typewriter 
++
\family default 

\newline 
Preincremento o postincremento
\newline 

\newline 

\family typewriter 
--
\family default 

\newline 
Predecremento o postdecremento
\newline 

\newline 

\family typewriter 
&
\family default 

\newline 
Dirección
\newline 

\newline 

\family typewriter 
*
\family default 

\newline 
Contenido (indirección)
\newline 

\newline 

\family typewriter 
sizeof
\family default 

\newline 
(devuelve tamaño de operando, en bytes)
\newline 
3.
 Multiplicativo
\newline 

\family typewriter 
*
\family default 

\newline 
Multiplica
\newline 

\newline 

\family typewriter 
/
\family default 

\newline 
Divide
\newline 

\newline 

\family typewriter 
%
\family default 

\newline 
Resto (módulo)
\newline 
4.
 Aditivo
\newline 

\family typewriter 
+
\family default 

\newline 
Más binario
\newline 

\newline 

\family typewriter 
-
\family default 

\newline 
Menos binario
\newline 
5.
 Desplazamiento
\newline 

\family typewriter 
<<
\family default 

\newline 
Desplazamiento a la izquierda
\newline 

\newline 

\family typewriter 
>>
\family default 

\newline 
Desplazamiento a la derecha
\newline 
6.
 Relacional
\newline 

\family typewriter 
<
\family default 

\newline 
Menor que
\newline 

\newline 

\family typewriter 
<=
\family default 

\newline 
Menor o igual que
\newline 

\newline 

\family typewriter 
>
\family default 

\newline 
Mayor que
\newline 

\newline 

\family typewriter 
>=
\family default 

\newline 
Mayor o igual que
\newline 
7.
 Igualdad
\newline 

\family typewriter 
==
\family default 

\newline 
Igual a
\newline 

\newline 

\family typewriter 
!=
\family default 

\newline 
Distinto a
\newline 
8.
\newline 

\family typewriter 
&
\family default 

\newline 
AND entre bits
\newline 
9.
\newline 

\family typewriter 
^
\family default 

\newline 
XOR entre bits
\newline 
10.
\newline 

\family typewriter 
|
\family default 

\newline 
OR entre bits
\newline 
11.
\newline 

\family typewriter 
&&
\family default 

\newline 
AND lógico
\newline 
12.
\newline 

\family typewriter 
||
\family default 

\newline 
OR lógico
\newline 
13.
 Condicional
\newline 

\family typewriter 
?:
\family default 

\newline 
(a ? x : y significa "si a entonces x, si no y")
\newline 
14.
 Asignación
\newline 

\family typewriter 
=
\family default 

\newline 
Asignación simple
\newline 

\newline 

\family typewriter 
*=
\family default 

\newline 
Asignar producto
\newline 

\newline 

\family typewriter 
/=
\family default 

\newline 
Asignar cociente
\newline 

\newline 

\family typewriter 
%=
\family default 

\newline 
Asignar resto (módulo)
\newline 

\newline 

\family typewriter 
+=
\family default 

\newline 
Asignar suma
\newline 

\newline 

\family typewriter 
-=
\family default 

\newline 
Asignar diferencia
\newline 

\newline 

\family typewriter 
&=
\family default 

\newline 
Asignar AND entre bits
\newline 

\newline 

\family typewriter 
^=
\family default 

\newline 
Asignar XOR entre bits
\newline 

\newline 

\family typewriter 
|=
\family default 

\newline 
Asignar OR entre bits
\newline 

\newline 

\family typewriter 
<<=
\family default 

\newline 
signar desplazamiento hacia la izquierda
\newline 

\newline 

\family typewriter 
>>=
\family default 

\newline 
Asignar desplazamiento hacia la derecha
\newline 
15.
 Coma
\newline 

\family typewriter 
,
\family default 

\newline 
Evaluar
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 8-1
\series default 
.
 Diseñar un programa que lea dos árboles binarios y muestre un mensaje diciciend
o si los dos árboles son iguales.
\layout Itemize


\series bold 
Ejercicio 8-2.

\series default 
 Diseñar un programa que lea un árbol binario, lo copie a otro árbol binario
 exceptuando las hojas del primero (el segundo árbol binario será igual
 que el primero pero sin las hojas de él) y lo imprima.
 Por ejemplo, si el árbol binario introducido es:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 6
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /
\protected_separator 

\protected_separator 
 
\backslash 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 2
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 10
\layout Quotation


\family typewriter 

\protected_separator 
 /
\protected_separator 
 
\backslash 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\backslash 

\layout Quotation


\family typewriter 
0
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 3
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 12
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 /
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /
\protected_separator 
 
\backslash 

\layout Quotation


\family typewriter 

\protected_separator 
 1
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 11
\protected_separator 

\protected_separator 

\protected_separator 
 20
\layout Quote

El árbol a crear será:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 6
\layout Quotation


\family typewriter 

\protected_separator 
 /
\protected_separator 

\protected_separator 
 
\backslash 

\layout Quotation


\family typewriter 
2
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 10
\layout Quotation


\family typewriter 

\protected_separator 

\backslash 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\backslash 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 3
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 12
\layout Itemize


\series bold 
Ejercicio 8-3
\series default 
.
 Diseñar un programa que lea dos árboles binarios y forme e imprima otro
 árbol binario cuya información sea la suma de las correspondientes informacione
s númericas contenidas en los dos árboles leídos.
 Se supone que si no existe el correspondiente nodo en alguno de los árboles
 se supondrá que la información contenida en el nodo de dicho árbol es cero.
\layout Itemize


\series bold 
Ejercicio 8-4
\series default 
.
 Se desea construir una estructura dinámica de datos como la que se muestra
 en la figura:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset Figure size 357 168
file 1-1.eps
width 3 60
height 3 20
flags 10

\end_inset 


\layout Quote

Como se ve, uno de los campos puntero enlaza nodos por orden ascendente
 de la clave numérica (5, 10, 15, ...), y el otro por orden descendente de
 la clave alfabética (Manolo, Juan, Antonio, ...).
 Se debe escribir un programa que permite realizar operaciones de insertar,
 eliminar y buscar elementos (número entero y cadena de caracteres), además
 de listar todos los elementos según la clave deseada (numérica o alfabética).
\layout Itemize


\series bold 
Ejercicio 8-5
\series default 
.
 Diseñar un programa que forme un árbol binario de números enteros introducidos
 por el usuario e imprima la información contenida en cada nodo por niveles.
 Es decir, primero el nodo raíz (nivel 0), luego sus hijos (nivel 1), después
 los hijos de éstos (nivel 2) y así sucesivamente.
 La función del recorrido del árbol por niveles puede hacerse con el siguiente
 pseudocódigo:
\layout Quote

<Construir una cola vacía cuyos nodos contengan un puntero a nodos del árbol
 y un entero para indicar el correspondiente nivel>
\layout Quote

<Incluir en la cola un primer nodo que contenga un puntero al nodo raíz
 y el nivel 0 e inicializar un puntero p, que señalando a nodos de la cola,
 señale a ese primer nodo>
\layout Quote

MIENTRAS (p no sea nulo)
\layout Quote

<Añadir a la cola los punteros a los hijos del nodo del árbol cuyo puntero
 está incluido en la cola y apuntado por p, así como sus correspondientes
 niveles>
\layout Quote

<Hacer p igual al siguiente de p>
\layout Quote

FINMIENTRAS
\layout Quote

<Imprimir la información contenida en los nodos del árbol señalados por
 los sucesivos punteros de la cola y los correspondientes niveles>
\layout Itemize


\series bold 
Ejercicio 8-6
\series default 
.
 Desarrollar un programa que realice la suma de dos polinomios.
 Los dos polinomios se representan en listas lineales encabezadas por p
 y q, el polinomio resultado está encabezado por el puntero r.
 La información contenida en cada nodo de las listas está compuesta de coeficien
te y exponente.
 
\series bold 
Nota
\series default 
: las listas no están ordenadas ni respecto a los coeficientes ni respecto
 a los exponentes.
\layout Itemize


\series bold 
Ejercicio 8-7
\series default 
.
 Supóngase que se está haciendo un cierto tratamiento con una serie de municipio
s de diversas provincias, para ello se utiliza la siguiente estructura:
 unas listas "horizontales" formadas cada una de ellas por municipios pertenecie
ntes ala misma provincia y una lista "vertical" formada por todas las cabeceras
 de cada una de las listas horizontales.
 Se pide:
\layout Enumerate

Implementar las funciones necesarias para buscar en la estructura un municipio
 dado de una provincia dada.
 Si está se devolverá un puntero al nodo correspondiente; en caso contrario
 el puntero devolverá valor NULL.
\layout Enumerate

Insertar en la estructura un municipio dado de una provincia dada teniendo
 en cuenta los siguientes puntos:
\begin_deeper 
\layout Itemize

Si el municipio pertenece a una provincia ya existente, se insertará el
 nuevo elemento al principio de la lista horizontal correspondiente.
\layout Itemize

Si el municipio pertenece a una provincia nueva, se deberá insertar al final
 de la lista vertical la nueva provincia que deberá tener una lista horizontal
 de un único elemento: ese municipio.
\end_deeper 
\layout Itemize


\series bold 
Ejercicio 8-8
\series default 
.
 Diseñar un programa para manipular una cola.
 Una cola es una estructura de datos en la que el primer elemento introducido
 es el primero en salir.
 Las únicas operaciones que se pueden realizar con una cola son:
\begin_deeper 
\layout Itemize

Inicializarla.
\layout Itemize

Introducir un elemento.
\layout Itemize

Sacar un elemento.
\layout Itemize

Liberar nodos.
\end_deeper 
\layout Quote

Hay dos estructuras posibles para la implementación de una cola:
\layout Enumerate

Una lista lineal enlazada con dos punteros de cabecera: uno que apunta al
 primer nodo de la lista y otro que apunta al último nodo de la lista.
\layout Enumerate

Una lista lineal enlazada circular donde el puntero de cabecera apunta al
 último nodo de la lista y el puntero siguiente de este último nodo apunta
 al primer nodo de la lista.
\layout Itemize


\series bold 
Ejercicio 8-9
\series default 
.
 Diseñar algoritmos no recursivos para hacer recorridos inorden, preorden,
 postorden y por niveles en un árbol binario.
 
\series bold 
Consejo
\series default 
: para ello es conveniente utilizar pilas y colas.
 
\layout Itemize


\series bold 
Ejercicio 8-10
\series default 
.
 Diseñar un programa para manejar un árbol n-ario.
 Un árbol n-ario (también llamados multicaminos) es un árbol donde cada
 nodo puede tener n hijos.
 Por ejemplo, un nodo puede tener 2 hijos, otro 10 hijos, otro 1, ...
\layout Quote

Una estructura adecuada para implementar un árbol n-ario es que en vez de
 utilizar un puntero al hijo izquierdo y un puntero al hijo derecho como
 en los árboles binarios, utilizamos un puntero a una lista lineal enlazada
 donde cada nodo de esta lista apunta a un nodo hijo del nodo del árbol
 al que pertenece dicha lista.
 Las inserciones en la lista han de ser al final de ésta para conservar
 el orden de los nodos hijos; para facilitar las inserciones en la lista
 es conveniente que ésta sea circular y el puntero a la cabecera de la lista
 apunte al último nodo de ella.
\layout Quote

Realizar también una función que recibe un puntero a un árbol n-ario y devuelve
 un puntero a un árbol binario equivalente al árbol n-ario recibido.
\layout Chapter

Entrada y Salida (E/S).
 Ficheros
\layout Standard

El objetivo de esta lección es hacer un estudio completo en todo lo referente
 a la entrada y salida (E/S) en C, estudiando también los dos sistemas de
 ficheros que existen en este lenguaje.
 Los puntos que se estudian en esta lección son:
\layout Itemize

E/S estándar.
\layout Itemize

Flujos y ficheros.
\layout Itemize

Tipos de flujos: flujos de texto y flujos binarios.
\layout Itemize

Flujos predefinidos: stdin, stdout y stderr.
\layout Itemize

(Turbo C añade además: stdaux y stdprn)
\layout Itemize

Pasos a realizar para manipular un fichero: declarar variable de fichero,
 abrirlo, operar con él y cerrarlo.
\layout Itemize

Estructura FILE.
\layout Itemize

Estudio completo del fichero stdio.h.
 (tanto del ANSI C como de Turbo C)
\layout Itemize

Sistema de ficheros tipo UNIX.
\layout Itemize

Descriptores de ficheros.
\layout Itemize

Estudio completo del fichero io.h en Turbo C.
\layout Title

Entrada y Salida
\layout Standard

Las operaciones de entrada y salida (abreviadamente E/S) no forman parte
 del lenguaje C propiamente dicho, sino que están en una biblioteca o librería:
 
\family typewriter 
<stdio.h>
\family default 
.
 Todo programa que utilice funciones de entrada y salida estándar deberá
 contener la línea: 
\family typewriter 
#include <stdio.h>
\family default 
.
\layout Section

E/S Estándar 
\layout Standard

Por defecto, la entrada estándar es el teclado y la salida estándar es la
 pantalla o monitor.
 Hay dos formas básicas de cambiar la entrada y la salida estándar:
\layout Enumerate

Con los símbolos de redirección (
\family typewriter 
<
\family default 
, 
\family typewriter 
>
\family default 
, 
\family typewriter 
<<
\family default 
, 
\family typewriter 
>>
\family default 
) o de tubería (
\family typewriter 
|
\family default 
) del sistema operativo al ejecutar el programa desde la línea de órdenes.
\layout Enumerate

Con determinadas funciones y variables que se encuentran en la librería
 
\family typewriter 
<stdio.h>
\family default 
 en el código fuente del programa.
\layout Section

Flujos y Ficheros
\layout Standard

Hay dos conceptos muy importantes en C relacionados con la E/S: flujos
\begin_float footnote 
\layout Standard

streams, en inglés
\end_float 
 y ficheros.
 Los flujos son sucesiones de caracteres a través de los cuales realizamos
 las operaciones de E/S.
 Para el programador todos los flujos son iguales.
 Para el C (en general para el sistema operativo) un fichero es un concepto
 lógico que puede ser aplicado a cualquier cosa desde ficheros de discos
 a terminales.
 A cada fichero se le asigna un flujo al realizar la operación de apertura
 sobre él.
 Para el programador un fichero es un dispositivo externo capaz de una E/S.
 Todos los ficheros no son iguales pero todos los flujos sí.
 Esto supone una gran simplificación para el usuario, ya que sólo tiene
 que pensar en términos de flujo y no de dispositivos concretos.
 Por ejemplo, si el usuario hace: 
\family typewriter 
printf ("mensaje")
\family default 
; sabe que
\protected_separator 
 se escribe en el flujo estándar de salida, ya sea la pantalla, un fichero
 de disco, una cinta, ...
\layout Subsection

Tipos de Flujos
\layout Standard

Cuando hemos dicho que todos los flujos son iguales, es cierto que lo son
 en su utilización por parte del programador, pero en realidad, podemos
 distinguir dos tipos:
\layout Enumerate

Flujos de texto: son una sucesión de caracteres originado en líneas que
 finalizan con un carácter de nueva-línea.
 En estos flujos puede no haber una relación de uno a uno entre los caracteres
 que son escritos (leídos) y los del dispositivo externo, por ejemplo, una
 nueva-línea puede transformarse en un par de caracteres (un retorno de
 carro y un carácter de salto de línea).
\layout Enumerate

Flujos binarios: son flujos de bytes que tienen una correspondencia uno
 a uno con los que están almacenados en el dispositivo externo.
 Esto es, no se presentan desplazamientos de caracteres.
 Además el número de bytes escritos (leídos) es el mismo que los almacenados
 en el dispositivo externo.
\layout Standard

Esta diferencia de flujos es importante tenerla en cuenta al leer ficheros
 de discos.
 Supongamos que tenemos un fichero de disco con 7 caracteres donde el cuarto
 carácter es el carácter fin de fichero (en sistema operativo DOS es el
 carácter con código ASCII 26).
 Si abrimos el fichero en modo texto, sólo podemos leer los 3 primeros caractere
s, sin embargo, si lo abrimos en modo binario, leeremos los 7 caracteres
 ya que el carácter con código ASCII 26 es un carácter como cualquier otro.
\layout Subsection

Programas C con flujos
\layout Standard

Al principio de la ejecución de un programa C se abren tres flujos de tipo
 texto predefinidos:
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
stdin
\family default 
: dispositivo de entrada estándar
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
stdout
\family default 
: dispositivo de salida estándar
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
stderr
\family default 
: dispositivo de salidad de error estándar
\layout Standard

Al finalizar el programa, bien volviendo de la función main al sistema operativo
 o bien por una llamada a 
\family typewriter 
exit()
\family default 
, todos los ficheros se cierran automáticamente.
 No se cerrarán si el programa termina a través de una llamada a 
\family typewriter 
abort()
\family default 
 o abortando el programa.
 Estos tres ficheros no pueden abrirse ni cerrarse explicítamente.
 
\layout Standard

En Turbo C, además de abrirse los tres flujos anteriores se abren otros
 dos flujos de texto predefinidos:
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
stdaux
\family default 
: dispositivo auxiliar estándar
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
stdprn
\family default 
: impresora estándar
\layout Section

Resumen de Todo lo Dicho Hasta el Momento en Esta Lección
\layout Standard

Como todo lo que acabamos de decir puede resultar un poco confuso a las
 personas que tienen poca experiencia en C, vamos a hacer un pequeño resumen
 en términos generales:
\layout Enumerate

En C, cualquier cosa externa de la que podemos leer o en la que podemos
 escribir datos es un fichero.
\layout Enumerate

El programador escribe (lee) datos en estos ficheros a través de los flujos
 de cada fichero.
 De esta forma el programador escribe (lee) los datos de la misma forma
 en todos los tipos de ficheros independientemente del tipo de fichero que
 sea.
\layout Enumerate

Aunque conceptualmente todos los flujos son iguales, en realidad hay dos
 tipos: flujos de texto y flujos binarios.
 
\layout Enumerate

Hay tres flujos de texto predefinidos que se abren automática mente al principio
 del programa: 
\family typewriter 
stdin
\family default 
, 
\family typewriter 
stdout
\family default 
 y 
\family typewriter 
stderr
\family default 
.
 Estos tres flujos se cierran automáticamente al final del programa.
\layout Section

Pasos para Operar con un Fichero
\layout Standard

Los pasos a realizar para realizar operaciones con un fichero son los siguientes
:
\layout Itemize

1) Crear un nombre interno de fichero.
 Esto se hace en C declarando un puntero de fichero (o puntero a fichero).
 Un puntero de fichero es una variable puntero que apunta a una estructura
 llamada 
\family typewriter 
FILE
\family default 
.
 Esta estructura está definida en el fichero 
\family typewriter 
stdio.h
\family default 
 y contiene toda la información necesaria para poder trabajar con un fichero.
 El contenido de esta estructura es dependiente de la implementación de
 C y del sistema, y no es interesante saberlo para el programador.
 Ejemplo:
\layout Quotation


\family typewriter 
FILE *pf; /* pf es un puntero de fichero */
\layout Itemize

2) Abrir el fichero.
 Esto se hace con la función 
\family typewriter 
fopen()
\family default 
 cuyo prototipo se encuentra en el fichero 
\family typewriter 
stdio.h
\family default 
 y es:
\layout Quotation


\family typewriter 
FILE *fopen (char *nombre_fichero, char *modo);
\layout Quote

Si el fichero con nombre 
\family typewriter 
nombre_fichero
\family default 
 no se puede abrir devuelve 
\family typewriter 
NULL
\family default 
.
 El parámetro 
\family typewriter 
nombre_fichero
\family default 
 puede contener la ruta completa de fichero pero teniendo en cuenta que
 la barra invertida (
\family typewriter 

\backslash 

\family default 
) hay que repetirla en una cadena de caracteres.
 Los valores válidos para el parámeto modo son:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
13 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Modo
\newline 
Interpretación
\series default 

\newline 
"r"
\newline 
Abrir un fichero texto para lectura
\newline 
"w"
\newline 
Crear un fichero texto para escritura
\newline 
"a"
\newline 
Añadir a un fichero texto
\newline 
"rb"
\newline 
Abrir un fichero binario para lectura
\newline 
"wb"
\newline 
Crear un fichero binario para escritura
\newline 
"ab"
\newline 
Añadir a un fichero binario
\newline 
"r+"
\newline 
Abrir un fichero texto para lectura/escritura
\newline 
"w+"
\newline 
Crear un fichero texto para lectura/escritura
\newline 
"a+"
\newline 
Abrir un fichero texto para lectura/escritura
\newline 
"rb+"
\newline 
Abrir un fichero binario para lectura/escritura
\newline 
"wb+"
\newline 
Crear un fichero binario para lectura/escritura
\newline 
"ab+"
\newline 
Abrir un fichero binario para lectura/escritura
\layout Quote

Si se utiliza 
\family typewriter 
fopen()
\family default 
 para abrir un fichero para escritura, entonces cualquier fichero que exista
 con ese nombre es borrado y se comienza con un fichero nuevo.
 Si no existe un fichero con ese nombre, entonces se crea uno.
 Si lo que se quiere es añadir al final del fichero, se debe utilizar el
 modo "a".
 Si no existe el fichero, devuelve error.
 Abrir un fichero para operaciones de lectura necesita que el fichero exista.
 Si no existe devuelve error.
 Finalmente, si se abre un fichero para operaciones de lectura/escritura,
 no se borra en caso de existir.
 Sin embargo, si no existe se crea.
 Ejemplo:
\layout Quotation


\family typewriter 
FILE *pf;
\layout Quotation


\family typewriter 
pf = fopen ("c:
\backslash 

\backslash 
autoexec.bat", "r");
\layout Quotation


\family typewriter 
if(pf == NULL) /* siempre se debe hacer esta comprobación */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 puts("No se puede abrir fichero.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit (1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 }
\layout Itemize

3) Realizar las operaciones deseadas con el fichero como pueden ser la escritura
 en él y la lectura de él.
 Las funciones que disponemos para hacer esto las veremos un poco más adelante.
\layout Itemize

4) Cerrar el fichero.
 Aunque el C cierra automáticamente todos los ficheros abiertos al terminar
 el programa, es muy aconsejable cerrarlos explícitamente.
 Esto se hace con la función 
\family typewriter 
fclose()
\family default 
 cuyo prototipo es:
\layout Quotation


\family typewriter 
int fclose (FILE *pf);
\layout Quote

La función 
\family typewriter 
fclose()
\family default 
 cierra el fichero asociado con el flujo 
\family typewriter 
pf
\family default 
 y vuelca su buffer.
 Si 
\family typewriter 
fclose()
\family default 
 se ejecuta correctamente devuelve el valor 0.
 La comprobación del valor devuelto no se hace muchas veces porque no suele
 fallar.
 Ejemplo:
\layout Quotation


\family typewriter 
FILE *pf;
\layout Quotation


\family typewriter 
if((pf = fopen ("prueba", "rb")) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 puts("Error al intentar abrir el fichero.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit (1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 
/* ...
 */
\layout Quotation


\family typewriter 
if(fclose (pf) != 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 puts("Error al intentar cerrar el fichero.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit (1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 }
\layout Description


\size larger 
RESUMEN DE LOS PASOS PARA MANIPULAR UN FICHERO
\layout Standard

Resumen de los 4 pasos anteriores para la manipulación de un fichero:
\layout Itemize

1) Declarar un puntero de fichero.
\layout Quotation


\family typewriter 
FILE *pf;
\layout Itemize

2) Abrirlo el fichero.
\layout Quotation


\family typewriter 
if((pf = fopen ("nombre_fichero", "modo_apertura")) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 error ();
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 /* ...
 */
\layout Itemize

3) Realizar las operaciones deseadas con el fichero.
 En las siguientes ventanas veremos las funciones que tenemos para ello.
\layout Itemize

4) Cerrar el fichero.
\layout Quotation


\family typewriter 
if(fclose (pf) != 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 error ();
\layout Quotation


\family typewriter 

\protected_separator 
 
\layout Quotation


\family typewriter 
else
\layout Quotation


\family typewriter 
/* ...
 */
\layout Section

Funciones del ANSI C en el Fichero de Cabecera stdio.h
\layout Description


\size largest 
fclose
\layout Standard

Cierra un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fclose (FILE *flujo);
\layout Standard

Devuelve 0 si tiene éxito; devuelve 
\family typewriter 
EOF
\family default 
 si se detecta algún error.
 Un error puede ocurrir por ejemplo cuando se intenta cerrar un fichero
 que ha sido ya cerrado.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
FILE *pf;
\layout Quotation


\family typewriter 
if ((pf = fopen ("prueba", "r")) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 error ();
\layout Quotation


\family typewriter 
/* ...
 */
\layout Quotation


\family typewriter 
if (fclose (pf))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 error ();
\layout Description


\size largest 
feof
\layout Standard

Macro que devuelve un valor distinto de cero si se se ha detectado el fin
 de fichero en un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int feof (FILE *flujo);
\layout Standard

Una vez alcanzado el final del fichero, las operaciones posteriores de lectura
 devuelven 
\family typewriter 
EOF
\family default 
 hasta que se cambie la posición del puntero del fichero con funciones como
 
\family typewriter 
rewind()
\family default 
 y 
\family typewriter 
fseek()
\family default 
.
 La función 
\family typewriter 
feof()
\family default 
 es particularmente útil cuando se trabaja con ficheros binarios porque
 la marca de fin de fichero es también un entero binario válido.
 
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf se ha abierto como fichero binario para operaciones de
 lectura */
\layout Quotation


\family typewriter 
while (! feof (pf))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 getc (pf);
\layout Description


\size largest 
ferror
\layout Standard

Macro que devuelve un valor distinto de cero si ha ocurrido algún error
 en el flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int ferror (FILE *flujo);
\layout Standard

Los indicadores de error asociados al flujo permanecen activos hasta que
 se cierra el fichero, se llama a 
\family typewriter 
rewind()
\family default 
 o a 
\family typewriter 
perror()
\family default 
.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf apunta a un flujo abierto para operaciones de escritura
 */
\layout Quotation


\family typewriter 
putc (informacion, pf);
\layout Quotation


\family typewriter 
if (ferror (pf))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 error ();
\layout Description


\size largest 
fflush
\layout Standard

Vuelca un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fflush (FILE *flujo);
\layout Standard

Si el flujo está asociado a un fichero para escritura, una llamada a 
\family typewriter 
fflush()
\family default 
 da lugar a que el contenido del buffer de salida se escriba en el fichero.
 Si flujo apunta a un fichero de entrada, entonces el contenido del buffer
 de entrada se vacía.
 En ambos casos el fichero permanece abierto.
 Devuelve 
\family typewriter 
EOF
\family default 
 si se detecta algún error.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de salida */
\layout Quotation


\family typewriter 
fwrite (buffer, sizeof (tipo_de_dato), n, pf);
\layout Quotation


\family typewriter 
fflush (pf);
\layout Description


\size largest 
fgetc
\layout Standard

Obtiene un carácter de un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fgetc (FILE *flujo);
\layout Standard

La función 
\family typewriter 
fgetc()
\family default 
 devuelve el siguiente carácter desde el flujo de entrada e incrementa el
 indicador de posición del fichero.
 El carácter se lee como un 
\family typewriter 
unsigned char
\family default 
 que se convierte a entero.
 Si se alcanza el final del fichero, 
\family typewriter 
fgetc()
\family default 
 devuelve 
\family typewriter 
EOF
\family default 
.
 Recuerda que 
\family typewriter 
EOF
\family default 
 es un valor entero.
 Por tanto, cuando trabajes con ficheros binarios debes utilizar 
\family typewriter 
feof()
\family default 
 para comprobar el final del fichero.
 Si 
\family typewriter 
fgetc()
\family default 
 encuentra un error, devuelve 
\family typewriter 
EOF
\family default 
 también.
 En consecuencia, si trabajas con ficheros binarios debe utilizar 
\family typewriter 
ferror()
\family default 
 para comprobar los errores del fichero.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de entrada */
\layout Quotation


\family typewriter 
while ((ch = fgetc (pf)) != EOF)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%c", ch);
\layout Description


\size largest 
fgetchar
\layout Standard

Obtiene un carácter de stdin.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fgetchar (void);
\layout Standard

Si tiene éxito, 
\family typewriter 
getchar()
\family default 
 devuelve el carácter leído, después de convertirlo a 
\family typewriter 
int
\family default 
 sin extensión de signo.
 En caso de fin de fichero o error, devuelve 
\family typewriter 
EOF
\family default 
.
 
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
ch = getchar ();
\layout Description


\size largest 
fgets
\layout Standard

Obtiene una cadena de caracteres de un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *fgets (char *s, int n, FILE *flujo);
\layout Standard

La función 
\family typewriter 
fgets()
\family default 
 lee hasta n-1 caracteres desde el flujo y los sitúa en el array apuntado
 por 
\family typewriter 
s
\family default 
.
 Los caracteres se leen hasta que se recibe un carácter de nueva línea o
 un 
\family typewriter 
EOF
\family default 
 o hasta que se llega al límite especificado.
 Después de leídos los caracteres, se sitúa en el array un carácter nulo
 inmediatamente después del último carácter leído.
 Se guarda un carácter de nueva línea y forma parte de 
\family typewriter 
s
\family default 
.
 Si 
\family typewriter 
fgets()
\family default 
 tiene éxito devuelve la dirección de s; se devuelve un puntero nulo cuando
 se produce un error.
 Ya que se devuelve un puntero nulo cuando se produce un error o cuando
 se alcanza el final del fichero, utiliza 
\family typewriter 
feof()
\family default 
 o 
\family typewriter 
ferror()
\family default 
 para identificar lo que ocurre realmente.
 
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de entrada */
\layout Quotation


\family typewriter 
while(! feof (pf))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(fgets (s, 126, pf))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%s", s);
\layout Description


\size largest 
fopen
\layout Standard

Abre un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
FILE *fopen (const char *nombre_fichero, const char *modo_apertura);
\layout Standard

Devuelve un puntero al flujo abierto si tiene éxito; en otro caso devuelve
 
\family typewriter 
NULL
\family default 
.
 Esta ha sido explicada más extensa en ventanas anteriores.
 
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
FILE *pf;
\layout Quotation


\family typewriter 
if((pf = fopen ("prueba", "r")) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 error ();
\layout Description


\size largest 
fprintf
\layout Standard

Envía salida formateada a un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fprintf (FILE *flujo, const char *formato[, argumento, ...]);
\layout Standard

Esta función es idéntica a la función 
\family typewriter 
printf()
\family default 
 con la excepción que 
\family typewriter 
printf()
\family default 
 escribe en la salida estándar (flujo 
\family typewriter 
stdout
\family default 
) y la función 
\family typewriter 
fprintf()
\family default 
 escribe en la salida especificada (flujo indicado en su primer argumento).
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de salida */
\layout Quotation


\family typewriter 
fprintf(pf, "esto es una prueba %d %f", 5, 2.3);
\layout Description


\size largest 
fputc
\layout Standard

Escribe un carácter en un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fputc (int c, FILE *flujo);
\layout Standard

La función 
\family typewriter 
fputc()
\family default 
 escribe un carácter 
\family typewriter 
c
\family default 
 en el flujo especificado a partir de la posición actual del fichero y entonces
 incrementa el indicador de posición del fichero.
 Aunque 
\family typewriter 
ch
\family default 
 tradicionalmente se declare de tipo 
\family typewriter 
int
\family default 
, es convertido por 
\family typewriter 
fputc()
\family default 
 en 
\family typewriter 
unsigned char
\family default 
.
 Puesto que todos los argumentos de tipo carácter son pasados a enteros
 en el momento de la llamada, se seguirán viendo variables de tipo carácter
 como argumentos.
 Si se utilizara un entero, simplemente se eliminaría el byte más significativo.
 El valor devuelto por 
\family typewriter 
fputc()
\family default 
 es el valor de número de carácter escrito.
 Si se produce un error, se devuelve 
\family typewriter 
EOF
\family default 
.
 Para los ficheros abiertos en operaciones binarias, 
\family typewriter 
EOF
\family default 
 puede ser un carácter válido.
 En estos casos, para determinar si realmente se ha producido un error utiliza
 la función 
\family typewriter 
ferror()
\family default 
.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de salida */
\layout Quotation


\family typewriter 
fputc('a', pf);
\layout Description


\size largest 
fputchar
\layout Standard

Escribe un carácter en 
\family typewriter 
stdout
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fputchar (int c);
\layout Standard

Una llamada a 
\family typewriter 
fputchar()
\family default 
 es funcionalmente equivalente a 
\family typewriter 
fputc(c,stdout)
\family default 
.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de salida */
\layout Quotation


\family typewriter 
fputchar('a');
\layout Description


\size largest 
fputs
\layout Standard

Escribe una cadena de caracteres en un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fputs (const char *s, FILE *flujo);
\layout Standard

La función 
\family typewriter 
fputs()
\family default 
 escribe el contenido de la cadena de caracteres apuntada por s en el flujo
 especificado.
 El carácter nulo de terminación no se escribe.
 La función devuelve 0 cuando tiene éxito, y un valor no nulo bajo condición
 de error.
\layout Standard

Si se abre el flujo en modo texto, tienen lugar ciertas transformaciones
 de caracteres.
 Esto supone que puede ser que no haya una correspondencia uno a uno de
 la cadena frente al fichero.
 Sin embargo, si se abre en modo binario, no se producen transformaciones
 de caracteres y se establece una correspondencia uno a uno entre la cadena
 y el fichero.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de salida */
\layout Quotation


\family typewriter 
fputs("abc", pf);
\layout Description


\size largest 
fread
\layout Standard

Lee datos de un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fread (void *buf, int tam, int n, FILE *flujo);
\layout Standard

Lee n elementos de 
\family typewriter 
tam
\family default 
 bytes cada uno.
 Devuelve el número de elementos (no bytes) realmente leídos.
 Si se han leído menos caracteres de los pedidos en la llamada, es que se
 ha producido un error o es que se ha alcanzado el final del fichero.
 Utiliza 
\family typewriter 
feof()
\family default 
 o 
\family typewriter 
ferror()
\family default 
 para determinar lo que ha tenido lugar.
 Si el flujo se abre para operaciones de texto, el flujo de retorno de carro
 y salto de línea se transforma automáticamente en un carácter de nueva
 línea.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de entrada */
\layout Quotation


\family typewriter 
float buf[10];
\layout Quotation


\family typewriter 
if(fread (buf, sizeof (float), 10, pf) != 10)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(feof (pf))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("fin de fichero inesperado");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("error de lectura en el fichero");
\layout Description


\size largest 
freopen
\layout Standard

Asocia un nuevo fichero con un flujo abierto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
FILE *freopen (const char *nombre_fichero, const char *modo, FILE *flujo);
\layout Standard

El flujo es cerrado.
 El fichero 
\family typewriter 
nombre_fichero
\family default 
 es abierto y asociado con el flujo.
 Devuelve flujo si tiene éxito o 
\family typewriter 
NULL
\family default 
 si falló.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 FILE *pf;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Esto se escribe en pantalla.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if((pf = freopen ("salida.doc", "w", stdout)) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Error: No se puede abrir el fichero salida.doc
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Esto se escribe en el fichero salida.doc");
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
fscanf
\layout Standard

Ejecuta entrada formateada de un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fscanf (FILE *flujo, const char *formato[, direccion, ...]);
\layout Standard

Esta función es idéntica a la función 
\family typewriter 
scanf()
\family default 
 con la excepción que 
\family typewriter 
scanf()
\family default 
 lee de la entrada estándar (flujo 
\family typewriter 
stdin
\family default 
) y la función 
\family typewriter 
fscanf()
\family default 
 lee de la entrada especificada (flujo indicado en su primer argumento).
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de entrada */
\layout Quotation


\family typewriter 
int d;
\layout Quotation


\family typewriter 
float f;
\layout Quotation


\family typewriter 
fscanf(pf, "%d %f", &d, %f);
\layout Description


\size largest 
fseek
\layout Standard

Posiciona el puntero de fichero de un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fseek (FILE *flujo, long desplazamiento, int origen);
\layout Standard

La función 
\family typewriter 
fseek()
\family default 
 sitúa el indicador de posición del fichero asociado a flujo de acuerdo
 con los valores de desplazamiento y origen.
 Su objetivo principal es soportar operaciones de E/S aleatorias; desplazamiento
 es el número de bytes desde el origen elegido a la posición seleccionada.
 El origen es 0, 1 ó 2 (0 es el principio del fichero, 1 es la posición
 actual y 2 es el final del fichero).
 El estándar ANSI fija los siguientes nombres para los orígenes:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
4 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 1 0 0
2 1 0 "" ""
2 1 1 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Origen
\newline 
Nombre
\series default 

\newline 
Comienzo del fichero
\newline 

\family typewriter 
SEEK_SET
\family default 

\newline 
Posición actual
\newline 

\family typewriter 
SEEK_CUR
\family default 

\newline 
Final del fichero
\newline 

\family typewriter 
SEEK_END
\layout Standard

Si se devuelve el valor 0, se supone que 
\family typewriter 
fseek()
\family default 
 se ha ejecutado correctamente.
 Un valor distinto de 0 indica fallo.
 En la mayor parte de las implementaciones y en el estándar ANSI, desplazamiento
 debe ser un 
\family typewriter 
long int
\family default 
 para soportar ficheros de más de 64K bytes.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
long tamanio_fichero (FILE *flujo);
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 FILE *flujo;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 flujo = fopen ("MIFICH.TXT", "w+");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 fprintf(flujo, "Esto es un test.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El tamaño del fichero MIFICH.TXT es %ld bytes,
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 tamanio_fichero (flujo));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 fclose(flujo);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
long tamanio_fichero (FILE *flujo)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 long posicion_corriente, longitud;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 posicion_corriente = ftell (flujo);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 fseek(flujo, 0L, SEEK_END);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 longitud = ftell (flujo);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 fseek(flujo, posicion_corriente, SEEK_SET);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return flujo;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
ftell
\layout Standard

Devuelve la posición actual del puntero de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
long ftell (FILE *flujo);
\layout Standard

Devuelve el valor actual del indicador de posición del fichero para el flujo
 especificado si tiene éxito o 
\family typewriter 
-1L
\family default 
 en caso de error.
\layout Description

Ejemplo
\layout Standard

Ver ejemplo de la función fseek
\layout Description


\size largest 
fwrite
\layout Standard

Escribe en un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fwrite (const void *buf, int tam, int n, FILE *flujo);
\layout Standard

Escribe 
\family typewriter 
n
\family default 
 elementos de tam bytes cada uno.
 Devuelve el número de elementos (no bytes) escritos realmente.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de salida */
\layout Quotation


\family typewriter 
float f = 1.2;
\layout Quotation


\family typewriter 
fwrite(&f, sizeof (float), 1, pf);
\layout Description


\size largest 
getc
\layout Standard

Macro que obtiene un carácter de un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getc (FILE *flujo);
\layout Standard

Devuelve el carácter leído en caso de éxito o 
\family typewriter 
EOF
\family default 
 en caso de error o que se detecte el fin de fichero.
 Las funciones 
\family typewriter 
getc()
\family default 
 y 
\family typewriter 
fgetc()
\family default 
 son idénticas, y en la mayor parte de las implementaciones getc() está
 definida por la siguiente macro:
\layout Quotation


\family typewriter 
#define getc(pf) fgetc(pf)
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de entrada */
\layout Quotation


\family typewriter 
while((ch = getc (pf)) != EOF)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%c", ch);
\layout Description


\size largest 
getchar
\layout Standard

Macro que obtiene un carácer de 
\family typewriter 
stdin
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getchar (void);
\layout Standard

Si tiene éxito, 
\family typewriter 
getchar()
\family default 
 devuelve el carácter leído, después de convertirlo a 
\family typewriter 
int
\family default 
 sin extensión de signo.
 En caso de fin de fichero o error, devuelve 
\family typewriter 
EOF
\family default 
.
\layout Standard

Las funciones 
\family typewriter 
getchar()
\family default 
 y 
\family typewriter 
fgetchar()
\family default 
 son idénticas, y en la mayor parte de las implementaciones 
\family typewriter 
getchar()
\family default 
 está simplemente definida como la siguiente macro:
\layout Quotation


\family typewriter 
#define getchar(pf) fgetchar(pf)
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
ch = getchar ();
\layout Description


\size largest 
gets
\layout Standard

Obtiene una cadena de caracteres de 
\family typewriter 
stdin
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *gets (char *string);
\layout Standard

Lee caracteres de 
\family typewriter 
stdin
\family default 
 hasta que un carácter de nueva línea (
\family typewriter 

\backslash 
n
\family default 
) es encontrado.
 El carácter 
\family typewriter 

\backslash 
n
\family default 
 no es colocado en el 
\family typewriter 
string
\family default 
.
 Devuelve un puntero al argumento 
\family typewriter 
string
\family default 
.
\layout Description

Ejemplo
\layout Quotation


\family typewriter 
char nombre_fichero[128];
\layout Quotation


\family typewriter 
gets (nombre_fichero);
\layout Description


\size largest 
perror
\layout Standard

Mensajes de error del sistema.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void perror (const char *s);
\layout Standard

Imprime un mensaje de error en 
\family typewriter 
stderr
\family default 
.
 Primero se imprime el argumento de 
\family typewriter 
string s
\family default 
, después se escriben dos puntos, a continuación se escribe un mensaje de
 error acorde al valor corriente de la variable 
\family typewriter 
errno
\family default 
, y por último se escribe una nueva línea.
 
\family typewriter 
errno
\family default 
 es una variable global que contiene el tipo de error.
 Siempre que ocurre un error en una llamada al sistema, a 
\family typewriter 
errno
\family default 
 se le asigna un valor que indica el tipo de error.
\layout Standard

En Turbo C, la variable 
\family typewriter 
errno
\family default 
 está declarada en los ficheros 
\family typewriter 
errno.h
\family default 
, 
\family typewriter 
stddef.h
\family default 
 y 
\family typewriter 
stdlib.h
\family default 
, siendo su declaración: 
\layout Quotation


\family typewriter 
int errno
\family default 
; 
\layout Standard

Los posibles valores que puede tomar esta variable no interesa en este momento,
 así que se dirán cuáles son cuando se estudie la librería 
\family typewriter 
<errno.h>
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa imprime: */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 FILE *fp;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fp = fopen("perror.dat", "r");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if (! fp)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 perror("No es posible abir fichero para lectura");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
printf
\layout Standard

Escribe con formateo a 
\family typewriter 
stdout
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int printf(const char *formato [, argumento, ...]);
\layout Standard

Esta función se explicó completamente en la lección 4.
\layout Description


\size largest 
putc
\layout Standard

Escribe un carácter en un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int putc (int c, FILE *flujo);
\layout Standard

Si tiene éxito, 
\family typewriter 
putc()
\family default 
 devuelve el carácter 
\family typewriter 
c
\family default 
.
 En caso de error, devuelve 
\family typewriter 
EOF
\family default 
.
 Una de las funciones 
\family typewriter 
putc()
\family default 
 y 
\family typewriter 
fputc()
\family default 
 se implementa como macro de la otra.
 Las dos son funcionalmente equivalentes.
 Ejemplo:
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de salida */
\layout Quotation


\family typewriter 
putc('a', pf);
\layout Description


\size largest 
putchar
\layout Standard

Escribe un carácter en 
\family typewriter 
stdout
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int putchar (int c);
\layout Standard

Si tiene éxito, 
\family typewriter 
putc()
\family default 
 devuelve el carácter 
\family typewriter 
c
\family default 
.
 En caso de error, devuelve 
\family typewriter 
EOF
\family default 
.
 Una de las funciones 
\family typewriter 
putchar()
\family default 
 y 
\family typewriter 
fputchar()
\family default 
 se implementa como macro de la otra.
 Las dos son funcionalmente equivalentes.
 Ejemplo:
\layout Quotation


\family typewriter 
/* supone que pf está asociado con un fichero de salida */
\layout Quotation


\family typewriter 
putchar ('a');
\layout Description


\size largest 
puts
\layout Standard

Escribe un string en 
\family typewriter 
stdout
\family default 
 (y añade un carácter de nueva línea).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int puts (const char *s);
\layout Standard

Si la escritura tiene éxito, 
\family typewriter 
puts()
\family default 
 devuelve el último carácter escrito.
 En otro caso, devuelve 
\family typewriter 
EOF
\family default 
.
 Esta función se discutió completamente en la lección 4.
\layout Description


\size largest 
remove
\layout Standard

Función que borra un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int remove (const char *nombre_fichero);
\layout Standard

La función 
\family typewriter 
remove()
\family default 
 borra el fichero especificado por 
\family typewriter 
nombre_fichero
\family default 
.
 Devuelve 0 si el fichero ha sido correctamente borrado y -1 si se ha producido
 un error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char fichero[80];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Fichero para borrar: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 gets(fichero);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(remove (fichero) == 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Fichero %s borrado.
\backslash 
n", fichero);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("No se ha podido borrar el fichero %s.
\backslash 
n", fichero);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
rename
\layout Standard

Renombra un fichero.
\layout Standard

Sintaxis
\layout Quotation


\family typewriter 
int rename (const char *viejo_nombre, const char *nuevo_nombre);
\layout Standard

La función 
\family typewriter 
rename()
\family default 
 cambia el nombre del fichero especificado por 
\family typewriter 
viejo_nombre
\family default 
 a 
\family typewriter 
nuevo_nombre
\family default 
.
 El 
\family typewriter 
nuevo_nombre
\family default 
 no debe estar asociado a ningún otro en el directorio de entrada.
 La función 
\family typewriter 
rename()
\family default 
 devuelve 0 si tiene éxito y un valor no nulo si se produce un error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char viejo_nombre[80], nuevo_nombre[80];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Fichero a renombrar: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 gets(viejo_nombre);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Nuevo nombre: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 gets(nuevo_nombre);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(rename (viejo_nombre, nuevo_nombre) == 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Fichero %s renombrado a %s.
\backslash 
n", viejo_nombre, nuevo_nombre);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("No se ha podido renombrar el fichero %s.
\backslash 
n", viejo_nombre);
\layout Quotation


\family typewriter 
"
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
rewind
\layout Standard

Reposiciona el puntero de fichero al comienzo del flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void rewind (FILE *flujo);
\layout Standard

La función 
\family typewriter 
rewind()
\family default 
 mueve el indicador de posición del fichero al principio del flujo especificado.
 También inicializa los indicadores de error y fin de fichero asociados
 con flujo.
 No devuelve valor.
 Ejemplo:
\layout Quotation


\family typewriter 
void releer(FILE *pf)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* lee una vez */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 while(! feof (pf))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 putchar(getc (pf));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 rewind(pf);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* leer otra vez */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 while(! feof (pf))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 putchar(getc (pf));
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
scanf
\layout Standard

Ejecuta entrada formateada de 
\family typewriter 
stdin
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int scanf (const char *formato [, ...]);
\layout Standard

Esta función se explicó completamente en la lección 4.
\layout Description


\size largest 
setbuf
\layout Standard

Asigna un buffer a un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void setbuf (FILE *flujo, char *buf);
\layout Standard

La función 
\family typewriter 
setbuf()
\family default 
 se utiliza para determinar el buffer del flujo especificado que se utilizará
 o -si se llama con buf a nulo- para desactivar el buffer.
 Si un buffer va a ser definido por el programador, entonces debe ser de
 
\family typewriter 
BUFSIZ
\family default 
 caracteres.
 
\family typewriter 
BUFSIZ
\family default 
 está definido en 
\family typewriter 
stdio.h
\family default 
.
 La función 
\family typewriter 
setbuf()
\family default 
 no devuelve valor.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
/* BUFSIZ está definido en stdio.h */
\layout Quotation


\family typewriter 
char outbuf[BUFSIZ];
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* añade un buffer al flujo de salida estándar */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 setbuf (stdout, outbuf);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* pone algunos caracteres dentro del buffer */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 puts("Esto es un test de salida con buffer.
\backslash 
n
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 puts("Esta salida irá a outbuf
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 puts("y no aparecerá hasta que el buffer
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 puts("esté lleno o volquemos el flujo.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* vuelca el buffer de salida */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fflush (stdout);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
setvbuf
\layout Standard

Asigna un buffer a un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int setvbuf (FILE *flujo, char *buf, int tipo, int tam);
\layout Standard

La función 
\family typewriter 
setvbuf()
\family default 
 permite al programador especificar el buffer, su tamaño y su modo para
 el flujo especificado.
 El array de caracteres apuntado por 
\family typewriter 
buf
\family default 
 se utiliza como buffer de flujo para las operaciones de E/S.
 El tamaño del buffer está fijado por 
\family typewriter 
tam
\family default 
, y 
\family typewriter 
tipo
\family default 
 determina como se usará.
 Si buf es nulo, no tiene lugar ninguna operación sobre el buffer.
\layout Standard

Los valores legales de tipo son 
\family typewriter 
_IOFBF
\family default 
, 
\family typewriter 
_IONBF
\family default 
 y 
\family typewriter 
_IOLBF
\family default 
.
 Están definidos en 
\family typewriter 
stdio.h
\family default 
.
 Cuando se activa el modo 
\family typewriter 
_IOFBF
\family default 
 se produce una operación de buffer completa.
 Este es el modo por defecto.
 Cuando se activa 
\family typewriter 
_IONBF
\family default 
, el flujo no utiliza buffer independientemente del valor de 
\family typewriter 
buf
\family default 
.
 Si el modo es 
\family typewriter 
_IOLBF
\family default 
, el flujo utiliza buffer por líneas, lo que supone que el buffer es volcado
 en el fichero cada vez que se escribe un carácter de salto de línea para
 los flujos de salida; para los flujos de entrada lee todos los caracteres
 hasta un carácter de salto de línea.
 En cualquier caso, el buffer es volcado en el fichero cuando se llena.
 El valor de tam debe ser mayor que 0.
 La función 
\family typewriter 
setvbuf()
\family default 
 devuelve 0 en caso de éxito; en caso de fallo devuelve un valor distinto
 de cero.
 Ejemplo:
\layout Quotation


\family typewriter 
setvbuf (pf, buffer, _IOLBF, 128);
\layout Description


\size largest 
sprintf
\layout Standard

Envía salida formateada a un string.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int sprintf(char *buffer, const char *formato [, argumento, ...]);
\layout Standard

Esta función es igual que la función 
\family typewriter 
printf()
\family default 
 con la diferencia de que la salida de la función 
\family typewriter 
printf()
\family default 
 va al flujo stdout y la salida de la función 
\family typewriter 
sprintf()
\family default 
 va al string buffer.
 Devuelve el número de bytes escritos.
 En caso de error, 
\family typewriter 
sprintf()
\family default 
 devuelve 
\family typewriter 
EOF
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
char cadena[80];
\layout Quotation


\family typewriter 
sprintf(cadena, "%s %d %c", "abc", 5, 'd');
\layout Description


\size largest 
sscanf
\layout Standard

Ejecuta entrada formateada de string.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int sscanf(const char *buffer, const char *formato [, direccion, ...]);
\layout Standard

Esta función es igual que la función 
\family typewriter 
scanf()
\family default 
 con la diferencia de que la entrada de la función 
\family typewriter 
scanf()
\family default 
 se coge del flujo 
\family typewriter 
stdin
\family default 
 y la entrada de la función 
\family typewriter 
sscanf()
\family default 
 se coge del string 
\family typewriter 
buffer
\family default 
.
 Devuelve el número de bytes escritos.
 En caso de error, 
\family typewriter 
sprintf()
\family default 
 devuelve 
\family typewriter 
EOF
\family default 
.
\layout Standard

Devuelve el número de campos leídos, explorados, convertidos y almacenados
 con éxito.
 Si 
\family typewriter 
sscanf
\family default 
 intenta leer más allá del final de buffer, entonces el valor devuelto es
 
\family typewriter 
EOF
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
char cadena[80];
\layout Quotation


\family typewriter 
int i;
\layout Quotation


\family typewriter 
sscanf("abc 6", "%s%d", cadena, &i);
\layout Description


\size largest 
tmpfile
\layout Standard

Abre un fichero temporal en modo binario.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
FILE *tmpfile (void);
\layout Standard

La función 
\family typewriter 
tmpfile()
\family default 
 abre un fichero temporal para actualizarlo y devuelve un puntero a un flujo.
 La función utiliza automáticamente un único nombre de fichero para evitar
 conflictos con los ficheros existentes.
 La función devuelve un puntero nulo en caso de fallo; en cualquier otro
 caso devuelve un puntero a un flujo.
 El fichero temporal creado por 
\family typewriter 
tmpfile()
\family default 
 se elimina automáticamente cuando el fichero es cerrado o cuando el programa
 termina.
 Ejemplo:
\layout Quotation


\family typewriter 
FILE *pftemp;
\layout Quotation


\family typewriter 
if((pftemp = tmpfile ()) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf(No se puede abrir el fichero de trabajo temporal.
\backslash 
n);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit (1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 }
\layout Description


\size largest 
tmpnam
\layout Standard

Crea un nombre de fichero único.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *tmpnam (char *nombre_fichero);
\layout Standard

La función 
\family typewriter 
tmpnam()
\family default 
 genera un único nombre de fichero y lo guarda en el array apuntado por
 nombre.
 El objetivo de 
\family typewriter 
tmpnam()
\family default 
 es generar el nombre de un fichero temporal que sea diferente de cualquier
 otro que exista en el directorio.
 La función puede ser llamada hasta un número de veces igual a 
\family typewriter 
TMP_MAX
\family default 
, que está definido en 
\family typewriter 
stdio.h
\family default 
.
 Cada vez se genera un nuevo nombre de fichero temporal.
\layout Standard

En caso de éxito se devuelve un puntero a una cadena de caracteres; en cualquier
 otro caso se devuelve un puntero nulo.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char nombre[13];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 tmpnam(nombre);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Nombre temporal: %s
\backslash 
n", nombre);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
ungetc
\layout Standard

Devuelve un carácter al flujo de entrada.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int ungetc(int c, FILE *flujo);
\layout Quotation


\family typewriter 
Prototype in:
\layout Quotation


\family typewriter 
stdio.h
\layout Standard

La próxima llamada a 
\family typewriter 
getc
\family default 
 (u otras funciones de entrada de flujos) para flujo devolverá 
\family typewriter 
c
\family default 
.
 La función 
\family typewriter 
ungetc()
\family default 
 devuelve el carácter 
\family typewriter 
c
\family default 
 si tiene éxito.
 Devuelve 
\family typewriter 
EOF
\family default 
 si la operación falla.
 Ejemplo:
\layout Quotation


\family typewriter 
ungetc('a', stdin);
\layout Quotation


\family typewriter 
ch = getc(stdin); /* a ch se le asigna el carácter 'a' */
\layout Description


\size largest 
vfprintf
\layout Standard

Envía salida formateada a un flujo usando una lista de argumentos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int vfprintf (FILE *fp, const char *formato, va_list lista_de_arg);
\layout Standard

Devuelve el número de bytes escritos.
 En caso de error, devuelve 
\family typewriter 
EOF
\family default 
.
\layout Description


\size largest 
vfscanf
\layout Standard

Ejecuta entrada formateada de un flujo usando una lista de argumentos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int vfscanf (FILE *flujo, const char *formato, va_list lista_de_arg);
\layout Standard

Devuelve el número de campos leídos, explorados, convertidos y almacenados
 con éxito.
\layout Description


\size largest 
vprintf
\layout Standard

Envía salida formateada a stdout usando una lista de argumentos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int vprintf (const char *formato, va_list lista_de_arg);
\layout Standard

Devuelve el número de bytes escritos.
 En caso de error, devuelve 
\family typewriter 
EOF
\family default 
.
\layout Description


\size largest 
vscanf
\layout Standard

Ejecuta entrada formateada de stdin usando una lista de argumentos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int vscanf (const char *formato, va_list lista_de_arg);
\layout Standard

Devuelve el número de campos leídos, explorados, convertidos y almacenados
 con éxito.
 Devuelve 
\family typewriter 
EOF
\family default 
 en caso de que se detecte el fin de fichero.
\layout Description


\size largest 
vsprintf
\layout Standard

Envía salida formateada a un string usando una lista de argumentos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int vsprintf (char *buffer, const char *formato, va_list lista_de_arg);
\layout Standard

Devuelve el número de bytes escritos.
 En caso de error, devuelve 
\family typewriter 
EOF
\family default 
.
\layout Description


\size largest 
vsscanf
\layout Standard

Ejecuta entrada formateada de un string usando una lista de argumentos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int vsscanf (const char *buffer, const char *formato, va_list lista_arg);
\layout Standard

Devuelve el número de campos leídos, explorados, convertidos y almacenados
 con éxito.
 Devuelve 
\family typewriter 
EOF
\family default 
 en caso de que se detecte el fin de fichero.
 
\layout Standard

Las funciones 
\family typewriter 
vprintf()
\family default 
, 
\family typewriter 
vfprintf()
\family default 
 y 
\family typewriter 
vsprintf()
\family default 
 son funciones equivalentes a 
\family typewriter 
printf()
\family default 
, 
\family typewriter 
fprintf()
\family default 
 y 
\family typewriter 
sprintf()
\family default 
 respectivamente.
 Las funciones 
\family typewriter 
vscanf()
\family default 
, 
\family typewriter 
vfscanf()
\family default 
 y 
\family typewriter 
vsscanf()
\family default 
 son funciones equivalentes a 
\family typewriter 
scanf()
\family default 
, 
\family typewriter 
fscanf()
\family default 
 y 
\family typewriter 
sscanf()
\family default 
 respectivamente.
 La diferencia se encuentra en que la lista de argumentos se sustituye por
 un puntero a una lista de argumentos.
 Este puntero está definido en 
\family typewriter 
stdarg.h
\family default 
.
 Consulta la discusión del fichero 
\family typewriter 
stdarg.h
\family default 
 en la lección 5 para tener más detalles y ver un ejemplo.
\layout Section

Funciones Añadidas por Turbo C al ANSI en el Fichero de Cabecera stdio.h
\layout Description


\size largest 
clearerr
\layout Standard

Borra indicación de error.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void clearerr (FILE *flujo);
\layout Standard

La función 
\family typewriter 
clearerr()
\family default 
 borra los indicadores de error y fin de fichero para el flujo especificado.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 FILE *fp;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char ch;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* abre un fichero para escritura */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fp = fopen("PRUEBA.TXT", "w");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* fuerza una condición de error al intentar leer */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 ch = fgetc (fp);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%c
\backslash 
n",ch);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(ferror( fp))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* visualiza un mensaje de error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Error leyendo de PRUEBA.TXT
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* borra los indicadores de error y EOF */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 clearerr(fp);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fclose (fp);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
fcloseall
\layout Standard

Cierra todos los flujos abiertos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fcloseall (void);
\layout Standard

Devuelve el número total de flujos cerrados, o 
\family typewriter 
EOF
\family default 
 si fue detectado algún error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int flujos_cerrados;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* abre dos flujos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fopen("FICHERO1", "w");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fopen("FICHERO2", "w");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* cierra los flujos abiertos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 flujos_cerrados = fcloseall ();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(flujos_cerrados == EOF)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* imprime un mensaje de error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Ha ocurrido un error al intentar cerrar los ficheros.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* imprime resultado de la función fcloseall(): */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d flujos fueron cerrados.
\backslash 
n", flujos_cerrados);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
fdopen
\layout Standard

Asocia un flujo con un descriptor de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
FILE *fdopen (int descriptor, char *tipo);
\layout Standard

Devuelve un puntero al nuevo flujo abierto o 
\family typewriter 
NULL
\family default 
 en el caso de un error.
 Los valores posibles del argumento tipo son los mismos que para los de
 la función 
\family typewriter 
fopen()
\family default 
.
 Consiste en un string con una combinación de los siguientes caracteres:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
7 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Tipo
\newline 
Significado
\series default 

\newline 
r
\newline 
Abre para lectura solamente
\newline 
w
\newline 
Crea para escritura; sobreescribe fichero existente
\newline 
a
\newline 
Añade, abre para escritura al final del fichero, o crea fichero para escritura
\newline 
+
\newline 
Símbolo de suma para permitir operaciones de lectura/escritura
\newline 
b
\newline 
Abre en modo binario
\newline 
t
\newline 
Abre en modo texto
\layout Standard

Las funciones de 
\family typewriter 
stdio.h
\family default 
: 
\family typewriter 
fileno()
\family default 
 y 
\family typewriter 
fdopen()
\family default 
, utilizan el concepto de descriptor de fichero; este concepto se explica
 en las ventanas inmediatamente siguientes.
\layout Description


\size largest 
fgetpos
\layout Standard

Obtiene la posición actual del puntero de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fgetpos (FILE *flujo, fpos_t *pos);
\layout Standard

La posición almacenada en 
\family typewriter 
*pos
\family default 
 puede ser pasada a la función 
\family typewriter 
fsetpos()
\family default 
 para poner la posición del puntero de fichero.
 Devuelve 0 en caso de éxito y un valor distinto de cero en otro caso.
 
\family typewriter 
fpos_t
\family default 
 es un tipo declarado con 
\family typewriter 
typdef
\family default 
 en el fichero 
\family typewriter 
stdio.h
\family default 
 que indica posición de fichero.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h> /* strlen() devuelve la longitud de un string */
\layout Quotation


\family typewriter 
#include <stdio.h> /* para utilizar: FILE, fpos_t, fopen (), fwrite (),
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 fgetpos (), printf () y fclose () */
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 FILE *flujo;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char string[] = "Esto es un test";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fpos_t posfich;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* abre un fichero para actualizarlo */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 flujo = fopen ("FICHERO", "w+");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* escribe un string en el fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fwrite(string, strlen (string), 1, flujo);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* informa de la posición del puntero de fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fgetpos(flujo, &posfich);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El puntero de fichero está en el byte %ld
\backslash 
n", posfich);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fclose(flujo);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
fileno
\layout Standard

Macro que devuelve el descriptor de fichero asociado con un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fileno (FILE *flujo);
\layout Standard

Las funciones de 
\family typewriter 
stdio.h
\family default 
: 
\family typewriter 
fileno()
\family default 
 y 
\family typewriter 
fdopen()
\family default 
, utilizan el concepto de descriptor de fichero; este concepto se explica
 en las ventanas inmediatamente siguientes.
\layout Description


\size largest 
flushall
\layout Standard

Vuelca todos los flujos abiertos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int flushall (void);
\layout Standard

Vacía los buffers para los flujos de entradas y escribe los buffers en los
 ficheros para los flujos de salida.
 Devuelve un entero que es el número de flujos abiertos de entrada y salida.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 FILE *flujo;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* crea un fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 flujo = fopen ("FICHERO", "w");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* vuelca todos los flujos abiertos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d flujos fueron volcados.
\backslash 
n", flushall());
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* cierra el fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fclose(flujo);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
fsetpos
\layout Standard

Posiciona el puntero de fichero de un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fsetpos (FILE *flujo, const fpos_t *pos);
\layout Standard

La nueva posición apuntada por pos es el valor obtenido por una llamada
 previa a la función 
\family typewriter 
fgetpos()
\family default 
.
 En caso de éxito, devuelve 0.
 En caso de fallo, devuelve un valor distinto de 0.
\layout Standard


\family typewriter 
fpos_t
\family default 
 es un tipo declarado con 
\family typewriter 
typdef
\family default 
 en el fichero 
\family typewriter 
stdio.h
\family default 
 que indica posición de fichero.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void mostrar_posicion(FILE *flujo);
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 FILE *flujo;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fpos_t posicion_fichero;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* abre un fichero para actualización */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 flujo = fopen("FICHERO", "w+");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* salva la posición del puntero de fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fgetpos(flujo, &posicion_fichero);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* escribe algunos datos en el fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fprintf(flujo, "Esto es una prueba");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* muestra la posición corriente en fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 mostrar_posicion(flujo);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* pone una nueva posición de fichero, la visualiza */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(fsetpos(flujo, &posicion_fichero) == 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 mostrar_posicion(flujo);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 fprintf(stderr, "Error poniendo puntero de fichero.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit (1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* cierra el fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fclose (flujo);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void mostrar_posicion(FILE *flujo)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fpos_t pos;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* visualiza la posición actual del puntero de fichero de un flujo */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fgetpos(flujo, &pos);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Posición de fichero: %ld
\backslash 
n", pos);
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
getw
\layout Standard

Obtiene un entero de un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getw (FILE *flujo);
\layout Standard

Devuelve el próximo entero en el flujo de entrada, o 
\family typewriter 
EOF
\family default 
 si ocurre un error o se detecta el fin de fichero.
 Usa las funciones 
\family typewriter 
feof()
\family default 
 o 
\family typewriter 
ferror()
\family default 
 para verificar 
\family typewriter 
eof
\family default 
 o error.
 Ejemplo:
\layout Quotation


\family typewriter 
int entero = getw (pf);
\layout Description


\size largest 
putw
\layout Standard

Escribe un entero en un flujo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int putw (int d, FILE *flujo);
\layout Standard

Devuelve el entero 
\family typewriter 
d
\family default 
.
 En caso de error, devuelve 
\family typewriter 
EOF
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
putw (10, pf);
\layout Section

Sistema de Ficheros Tipo UNIX 
\layout Standard

Debido a que el lenguaje C se desarrolló inicialmente bajo el sistema operativo
 UNIX, se creó un segundo sistema de ficheros.
 A este sistema se le llama E/S sin buffer, E/S de bajo nivel o E/S tipo
 UNIX.
 Hoy en día, este sistema de ficheros está totalmente en desuso y se considera
 obsoleto, además el nuevo estándar ANSI ha decidido no estandarizar el
 sistema de E/S sin buffer tipo UNIX.
 Por todo lo dicho no se puede recomendar este sistema a los nuevos programadore
s C.
 Sin embargo, todavía existen programas que lo usan y es soportado por la
 mayoría de los compiladores de C.
 Así que incluimos una breve explicación al respecto.
\layout Section

Descriptores de Ficheros
\layout Standard

A diferencia del sistema de E/S de alto nivel, el sistema de bajo nivel
 no utiliza punteros a ficheros de tipo 
\family typewriter 
FILE
\family default 
; el sistema de bajo nivel utiliza descriptores de fichero de tipo 
\family typewriter 
int
\family default 
.
 A cada fichero se le asocia un número (su descriptor de fichero).
 Hay tres descriptores de fichero predefinidos:
\layout List
\labelwidthstring 00.00.0000

0 entrada estándar
\layout List
\labelwidthstring 00.00.0000

1 salida estándar
\layout List
\labelwidthstring 00.00.0000

2 salida de errores estándar
\layout Standard

Los cuatro pasos para la manipulación de ficheros con E/S de alto nivel
 que vimos antes se transforman en la E/S de bajo nivel en los siguientes
 pasos: 
\layout Itemize

1) Declarar un descriptor de fichero para el fichero a abrir.
\layout Quotation


\family typewriter 
int fd;
\layout Itemize

2) Abrir el fichero.
\layout Quotation


\family typewriter 
if((fd = open (nombre_fichero, modo_apertura)) = -1)
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Error al intentar abrir el fichero.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 exit (1);
\layout Quotation


\family typewriter 

\protected_separator 
 }
\layout Itemize

3) Manipular el fichero con las funciones que tenemos disponible para ello.
\layout Itemize

4) Cerrar el fichero.
\layout Quotation


\family typewriter 
close (fd);
\layout Standard

Tanto las funciones 
\family typewriter 
open()
\family default 
 como 
\family typewriter 
close()
\family default 
 como todas las que tenemos disponibles con relación al sistema de ficheros
 de bajo nivel se explican en la siguiente ventana, pero sólo para aquellos
 usuarios que tengan la opción de turbo puesta a on, debido a que estas
 funciones no pertenecen ya al estándar ANSI y por lo tanto no son portables
 entre distintas implementaciones del C.
\layout Section

Funciones de Turbo C en el Fichero de Cabecera io.h
\layout Description


\size largest 
access
\layout Standard

Determina la accesibilidad de un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int access (const char *nombre_fichero, int modo_acceso);
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
modo_acceso
\family default 
 = 0 chequea para existencia de fichero
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
modo_acceso
\family default 
 = 2 chequea para permiso de escritura
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
modo_acceso
\family default 
 = 4 chequea para permiso de lectura
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
modo_acceso
\family default 
 = 6 chequea para permiso de lectura y escritura
\layout Standard

Si el acceso requerido es permitido, devuelve 0; en otro caso, devuelve
 -1 y se asigna un valor a la variable 
\family typewriter 
errno
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int existe_fichero(char *nombre_fichero);
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d existe NOEXISTE.FIC
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
existe_fichero ("NOEXISTE.FIC") ? "Sí" : "No");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int existe_fichero (char *nombre_fichero)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return (access (nombre_fichero, 0) == 0);
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
chmod
\layout Standard

Cambia el modo de acceso.
\layout Description

Sintaxis
\layout Quote


\family typewriter 
int chmod (const char *path, int modo_acceso);
\layout Standard

Cuando tiene éxito 
\family typewriter 
chmod()
\family default 
 cambia el modo de acceso al fichero y devuelve 0.
 En otro caso chmod() devuelve -1.
 El parámetro 
\family typewriter 
modo_acceso
\family default 
 puede tomar alguno de los siguientes valores definidos en 
\family typewriter 
<sys
\backslash 
stat.h>
\family default 
:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
9 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
S_IFMT
\family default 

\newline 
Máscara de tipo de fichero
\newline 

\family typewriter 
S_IFDIR
\family default 

\newline 
Directorio
\newline 

\family typewriter 
S_IFIFO
\family default 

\newline 
FIFO especial
\newline 

\family typewriter 
S_IFCHR
\family default 

\newline 
Carácter especial
\newline 

\family typewriter 
S_IFBLK
\family default 

\newline 
Bloque especial
\newline 

\family typewriter 
S_IFREG
\family default 

\newline 
Fichero regular
\newline 

\family typewriter 
S_IREAD
\family default 

\newline 
Poseedor puede leer
\newline 

\family typewriter 
S_IWRITE
\family default 

\newline 
Poseedor puede escribir
\newline 

\family typewriter 
S_IEXEC
\family default 

\newline 
Poseedor puede ejecutar
\layout Description

Ejemplo:
\layout Quotation


\family typewriter 
#include <sys
\backslash 
stat.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
void hacer_solo_lectura(char *nombre_fichero);
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 hacer_solo_lectura("NOEXISTE.FIC");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 hacer_solo_lectura("MIFICH.FIC");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void hacer_solo_lectura(char *nombre_fichero)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int estado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 estado = chmod(nombre_fichero, S_IREAD);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 if(estado)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("No se pudo hacer %s sólo lectura
\backslash 
n", nombre_fichero);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Hecho %s sólo lectura
\backslash 
n", nombre_fichero);
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_chmod
\layout Standard

Cambia el modo de acceso.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int _chmod (const char *path, int func [ , int atrib ] );
\layout Standard

Si 
\family typewriter 
func
\family default 
 es 0, 
\family typewriter 
_chmod()
\family default 
 devuelve los atributos del fichero.
 Si 
\family typewriter 
func
\family default 
 es 1, los atributos son puestos.
 Si la operación tiene éxito, 
\family typewriter 
_chmod()
\family default 
 devuelve la palabra de atributo del fichero; en otro caso, devuelve -1.
 En el caso de un error se asigna valor a errno.
\layout Standard

El parámetro 
\family typewriter 
atrib
\family default 
 representa los atributos de fichero de MS-DOS y puede tomar los siguientes
 valores definidos en 
\family typewriter 
dos.h
\family default 
:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
FA_RDONLY
\family default 

\newline 
Atributo de sólo lectura
\newline 

\family typewriter 
FA_HIDDEN
\family default 

\newline 
Fichero oculto
\newline 

\family typewriter 
FA_SYSTEM
\family default 

\newline 
Fichero de sistema
\newline 

\family typewriter 
FA_LABEL
\family default 

\newline 
Etiqueta de la unidad
\newline 

\family typewriter 
FA_DIREC
\family default 

\newline 
Directorio
\newline 

\family typewriter 
FA_ARCH
\family default 

\newline 
Archivo
\layout Description


\size largest 
chsize
\layout Standard

Cambia tamaño de fichero.
\layout Description

Sintaxis
\layout Quote


\family typewriter 
int chsize (int descriptor, long tamanio);
\layout Standard

Si tiene éxito, 
\family typewriter 
chsize()
\family default 
 devuelve 0.
 Si falla, devuelve -1 y se le da valor a errno.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h> /*para utilizar strlen(): devuelve longitud de string*/
\layout Quotation


\family typewriter 
#include <fcntl.h> /* para utilizar la constante O_CREAT, ver open() */
\layout Quotation


\family typewriter 
#include <io.h> /* para utilizar write(), chsize() y close() */
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char buf[11] = "0123456789";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* crea fichero de texto conteniendo 10 bytes */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 descritor = open("FICH.FIC", O_CREAT);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 write(descriptor, buf, strlen (buf));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* truncar el fichero a 5 bytes de tamaño */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 chsize(descriptor, 5);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* cierra el fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 close(handle);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_close/close
\layout Standard

Cierra un descriptor de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int _close(int descriptor);
\layout Quotation


\family typewriter 
int close(int descriptor);
\layout Standard

Si tiene éxito, 
\family typewriter 
close()
\family default 
 y 
\family typewriter 
_close()
\family default 
 devuelven 0; en caso contrario, estas funciones devuelven -1 y se le da
 valor a 
\family typewriter 
errno
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <fcntl.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 char buf[11] = "0123456789";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 /* crea un fichero conteniendo 10 bytes */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 descriptor = open("NUEVO.FIC", O_CREAT);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 if(descriptor > -1)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 write(descriptor, buf, strlen (buf));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* cierra el fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 close(descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Error abriendo fichero
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_creat/creat
\layout Standard

Crea un nuevo fichero o sobreescribe uno existente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int _creat(const char *path, int atrib);
\layout Quotation


\family typewriter 
int creat(const char *path, int modo_acceso);
\layout Standard

La función 
\family typewriter 
creat()
\family default 
 abre el fichero en el modo dado por la variable global 
\family typewriter 
_fmode
\family default 
.
 La función 
\family typewriter 
_creat()
\family default 
 siempre abre en modo binario.
 Si la operación tiene éxito, el descriptor del nuevo fichero es devuelto;
 en caso contario, un -1 es devuelto y asignado valor a 
\family typewriter 
errno
\family default 
.
 Los valores posibles para 
\family typewriter 
modo_acceso
\family default 
 se describieron en la función 
\family typewriter 
chmod()
\family default 
.
 La variable global 
\family typewriter 
_fmode
\family default 
 está definida en los ficheros 
\family typewriter 
fcntl.h
\family default 
 y 
\family typewriter 
stdlib.h
\family default 
 de esta forma: 
\family typewriter 
int _fmode
\family default 
; Por defecto, se inicializa con el valor 
\family typewriter 
O_TEXT
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <sys
\backslash 
stat.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <fcntl.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char buf[11] = "0123456789";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* cambia el modo de fichero por defecto de texto a binario */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 _fmode = O_BINARY;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* crea un fichero binario para lectura y escritura */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 descriptor = creat("FICHERO.FIC", S_IREAD | S_IWRITE);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* escribe 10 bytes al fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 write(descriptor, buf, strlen (buf));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* cierra el fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 close(descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
creatnew
\layout Standard

Crea un nuevo fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int creatnew (const char *path, int modo);
\layout Standard

La función 
\family typewriter 
creatnew
\family default 
 es identica a la función 
\family typewriter 
_creat()
\family default 
 con la excepción de que es devuelto un error si el fichero ya existe.
 (Versiones del DOS 3.0 o superiores).
 Los valores posibles para el parámetro modo se explicaron en la función
 
\family typewriter 
creat()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <errno.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char buf[11] = "0123456789";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* intenta crear un fichero que no existe */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 descriptor = creatnew ("FICHERO.FIC", 0);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(descriptor == -1)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("FICHERO.FIC ya existe.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("FICHERO.FIC creado con éxito.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 write(descriptor, buf, strlen (buf));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 close(descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
creattemp
\layout Standard

Crea un fichero único en el directorio dado por el nombre de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int creattemp (char *path, int atrib);
\layout Standard

Esta función es similar a la función 
\family typewriter 
_creat()
\family default 
, excepto que el nombre de fichero es el nombre de path que debe terminar
 con un 
\family typewriter 

\backslash 

\family default 
.
 El nombre de fichero debería ser bastante grande para alojar el nombre
 de fichero.
 (Versiones de MS-DOS 3.0 o superiores).
 Los valores posibles para 
\family typewriter 
atrib
\family default 
 son los mismos que para la función 
\family typewriter 
creat()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char nombre_de_path[128];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy(nombre_de_path, "
\backslash 

\backslash 
"); /*copia el string "
\backslash 

\backslash 
" en nombre_de_path*/
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* crea un fichero único en el directorio raíz */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 descriptor = creattemp(nombre_de_path, 0);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s fue el fichero único creado.
\backslash 
n", nombre_de_path);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 close(descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
dup
\layout Standard

Duplica un descriptor de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int dup (int descriptor);
\layout Standard

Si la operación tiene éxito, 
\family typewriter 
dup()
\family default 
 devuelve el descriptor del nuevo fichero; en otro caso, 
\family typewriter 
dup()
\family default 
 devuelve -1 y se asigna valor a 
\family typewriter 
errno
\family default 
.
\layout Description


\size largest 
dup2
\layout Standard

Duplica el descriptor de fichero 
\family typewriter 
viejo_descriptor
\family default 
 sobre el descriptor de fichero existente 
\family typewriter 
nuevo_descriptor
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int dup2 (int viejo_descriptor, int nuevo_descriptor);
\layout Standard

Devuelve 0 si tiene éxito; -1 si ocurre un error.
\layout Description


\size largest 
eof
\layout Standard

Chequea fin de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int eof (int descriptor);
\layout Standard

Devuelve uno de los siguientes valores:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
4 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Valor
\newline 
Significado
\series default 

\newline 
1
\newline 
Fin de fichero
\newline 
0
\newline 
No fin de fichero
\newline 
-1
\newline 
Error; 
\family typewriter 
errno
\family default 
 es asignado
\layout Description


\size largest 
filelength
\layout Standard

Obtiene el tamaño de un fichero en bytes.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
long filelength (int descriptor);
\layout Standard

Si ocurre un error, devuelve -1 y se asigna valor a errno.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <fcntl.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char buf[11] = "0123456789";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* crea un fichero conteniendo 10 bytes */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 descriptor = open ("FICHERO.FIC", O_CREAT);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 write(descriptor, buf, strlen (buf));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* visualiza el tamaño del fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Longitud del fichero en bytes: %ld
\backslash 
n", filelength (descriptor));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* cierra el fichero */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 close (descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
getftime
\layout Standard

Obtiene fecha y hora de un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getftime (int descriptor, struct ftime *pftime);
\layout Standard

Devuelve 0 si tiene éxito, -1 si ocurre un error y además pone 
\family typewriter 
errno
\family default 
.
 La descripción de 
\family typewriter 
struct
\family default 
 ftime se ha descrito en la función 
\family typewriter 
setftime()
\family default 
.
\layout Description


\size largest 
ioctl
\layout Standard

Controla dispositivos de I/O.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int ioctl (int descriptor, int func [ , void *argdx, int argcx ] );
\layout Standard

Para func 0 o 1, el valor devuelto es la información del dispositivo (DX
 de la llamada de IOCTL).
 Para valores de 
\family typewriter 
func
\family default 
 de 2 hasta 5, el valor devuelto es el número de bytes transferidos realmente.
 Para los valores de func 6 ó 7, el valor devuelto es el estado del dispositivo.
 En cualquier caso, si es detectado un error, un valor de -1 es devuelto,
 y se da valor a 
\family typewriter 
errno
\family default 
.
 
\family typewriter 
IOCTL
\family default 
 (Control de entrada/salida para los dispositivos) es la función 68 (44
 hexadecimal) de la interrupción 21 hexadecimal del DOS.
 Esta función del DOS tiene varias subfunciones que realizan distintas tareas.
 En las versiones DOS-3 había 11 subfunciones.
 El argumento 
\family typewriter 
func
\family default 
 de 
\family typewriter 
ioctl()
\family default 
 del C se corresponde con dichas subfunciones.
 Para saber lo que hace cada subfunción debe consultar tu manual del DOS.
 Los argumentos 
\family typewriter 
argdx
\family default 
 y 
\family typewriter 
argcx
\family default 
 se refieren a los registros DX y CX de la CPU.
\layout Description


\size largest 
isatty
\layout Standard

Chequea tipo de dispositivo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int isatty (int descriptor);
\layout Standard

Si el dispositivo es un dispositivo de carácter, 
\family typewriter 
isatty()
\family default 
 devuelve un valor distinto de cero.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 descriptor = fileno (stdprn);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(isatty (descriptor))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Descriptor %d es un tipo de dispositivo
\backslash 
n", descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Descriptor %d no es un tipo de dispositivo
\backslash 
n", descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
lock
\layout Standard

Pone los bloqueos de compartición de ficheros para controlar el acceso concurren
te de ficheros.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int lock (int descriptor, long desplazamiento, long longitud);
\layout Standard

Previene el acceso de lectura o escritura por otro programa para la región
 que empieza en la dirección desplazamiento y abarca longitud bytes.
 Devuelve 0 en caso de éxito, -1 en caso de error.
\layout Description


\size largest 
lseek
\layout Standard

Mueve el puntero de fichero de lectura/escritura.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
long lseek (int descriptor, long desplazamiento, int desde_donde);
\layout Standard

Devuelve la nueva posición del fichero, medida en bytes desde el comienzo
 del fichero.
 Devuelve -1L en caso de error, y da valor a 
\family typewriter 
errno
\family default 
.
\layout Description


\size largest 
open
\layout Standard

Abre un fichero para lectura o escritura.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int open (const char *path, int acceso [ , unsigned modo ] );
\layout Standard

Si la operación se hace correctamente, 
\family typewriter 
open()
\family default 
 devuelve un descriptor de fichero; en cualquier otro caso devuelve -1 y
 le da valor a 
\family typewriter 
errno
\family default 
.
 Las definiciones de bits para el argumento acceso están en el fichero 
\family typewriter 
fcntl.h
\family default 
 y son las siguientes:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
9 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
O_APPEND
\family default 

\newline 
Añade a final de fichero
\newline 

\family typewriter 
O_BINARY
\family default 

\newline 
No traslación
\newline 

\family typewriter 
O_CREAT
\family default 

\newline 
Crea y abre fichero
\newline 

\family typewriter 
O_EXCL
\family default 

\newline 
Apertura exclusiva
\newline 

\family typewriter 
O_RDONLY
\family default 

\newline 
Sólo lectura
\newline 

\family typewriter 
O_RDWR
\family default 

\newline 
Lectura/escritura
\newline 

\family typewriter 
O_TEXT
\family default 

\newline 
Traslación CR-LF
\newline 

\family typewriter 
O_TRUNC
\family default 

\newline 
Apertura con truncación
\newline 

\family typewriter 
O_WRONLY
\family default 

\newline 
Sólo escritura
\layout Standard

Para 
\family typewriter 
_open()
\family default 
, el valor de acceso en MS-DOS 2.x está limitado a 
\family typewriter 
O_RDONLY
\family default 
,
\layout Standard

O_WRONLY y O_RDWR.
 Para MS-DOS 3.x, los siguientes valores adicionales pueden ser usados también:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
O_NOINHERIT
\family default 

\newline 
Proceso hijo hereda fichero
\newline 

\family typewriter 
O_DENYALL
\family default 

\newline 
Error si abierto para lectura/escritura
\newline 

\family typewriter 
O_DENYWRITE
\family default 

\newline 
Error si abierto para escritura
\newline 

\family typewriter 
O_DENYREAD
\family default 

\newline 
Error si abierto para lectura
\newline 

\family typewriter 
O_DENYNONE
\family default 

\newline 
Permite acceso concurrente
\layout Standard

Sólo una de las opciones 
\family typewriter 
O_DENYxxx
\family default 
 pueden ser incluidas en una simple apertura.
 Los valores posibles que puede tomar el argumento modo se describieron
 en la función 
\family typewriter 
chmod()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <fcntl.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char mensaje[] = "Hola mundo";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if((descriptor = open ("PRUEBA.$$$", O_CREAT | O_TEXT)) == -1)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 perror("Error");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 return 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 write(descriptor, mensaje, strlen (mensaje));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 close(descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_open
\layout Standard

Abre un fichero para lectura o escritura.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int _open (const char *nombre_de_fichero, int flags);
\layout Standard

Si la operación tiene éxito, 
\family typewriter 
_open()
\family default 
 devuelve un descriptor de fichero; en cualquier otro caso devuelve -1.
 Las definiciones de bits para el argumento 
\family typewriter 
flags
\family default 
 son las mismas que para el argumento acceso en la descripción de la función
 
\family typewriter 
open()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <fcntl.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char mensaje[] = "Hola mundo";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if((descriptor = _open ("PRUEBA.$$$", O_RDWR)) == -1)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 perror("Error");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 return 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 _write(descriptor, mensaje, strlen (mensaje));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 _close(descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
read
\layout Standard

Lee de un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int read (int descriptor, void *buffer, unsigned longitud);
\layout Standard

Si la operación tiene éxito, devuelve un entero indicando el número de bytes
 colocados en el buffer; si el fichero fue abierto en modo texto, 
\family typewriter 
read()
\family default 
 no cuenta retornos de carros o caracteres Ctrl-Z en el número de bytes
 leídos.
 En caso de error, devuelve -1 y le da valor a 
\family typewriter 
errno
\family default 
.
\layout Description


\size largest 
_read
\layout Standard

Lee de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int _read (int descriptor, void *buffer, unsigned longitud);
\layout Standard

Devuelve el número de bytes leídos; si se detecta el fin de fichero, devuelve
 0; si ocurre un error devuelve -1 y da valor a 
\family typewriter 
errno
\family default 
.
\layout Description


\size largest 
setftime
\layout Standard

Pone fecha y hora de un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int setftime (int descriptor, struct ftime *ptime);
\layout Standard

Devuelve 0 si tiene éxito; en otro caso devuelve -1.
 
\family typewriter 
struct ftime
\family default 
 está declarada en el fichero 
\family typewriter 
io.h
\family default 
 del siguiente modo:
\layout Quotation


\family typewriter 
struct ftime {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 ft_tsec
\protected_separator 
 : 5; /* intervalo de dos segundos */ 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 ft_min
\protected_separator 

\protected_separator 
 : 6; /* minutos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 ft_hour
\protected_separator 
 : 5; /* horas */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 ft_day
\protected_separator 

\protected_separator 
 : 5; /* días */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 ft_month : 4; /* meses */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 ft_year
\protected_separator 
 : 7; /* año */
\layout Quotation


\family typewriter 
};
\layout Description


\size largest 
setmode
\layout Standard

Pone modo de un fichero de apertura.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int setmode (int descriptor, int modo);
\layout Standard

Devuelve 0 si tiene éxito; en otro caso -1.
 Los valores posibles de modo se describieron en la función 
\family typewriter 
open()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <fcntl.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int resultado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 resultado = setmode(fileno (stdprn), O_TEXT);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(resultado == -1)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 perror("Modo no disponible");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Modo cambiado con éxito");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
sopen
\layout Standard

Macro que abre un fichero en el modo compartido.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
sopen (path, acceso, shflag, modo)
\layout Standard

Está incluido para compatibilidad con las distintas versiones de Turbo C
 y otros compiladores.
 El significado de los parámetros acceso y modo se han explicado en las
 funciones 
\family typewriter 
open()
\family default 
 y 
\family typewriter 
chmod()
\family default 
 respectivamente.
 El parámetro 
\family typewriter 
shflag
\family default 
 contiene el modo de compartición de ficheros y las constantes definidas
 para ello en el fichero share.h son las siguientes:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
SH_COMPAT
\family default 

\newline 
Modo de compatibilidad
\newline 

\family typewriter 
SH_DENYRW
\family default 

\newline 
Denegado acceso de lectura y escritura
\newline 

\family typewriter 
SH_DENYWR
\family default 

\newline 
Denegado acceso de escritura
\newline 

\family typewriter 
SH_DENYRD
\family default 

\newline 
Denegado acceso de lectura
\newline 

\family typewriter 
SH_DENYNONE
\family default 

\newline 
Permite acceso de lectura y escritura
\newline 

\family typewriter 
SH_DENYNO
\family default 

\newline 
Igual que SH_DENYNONE (compatibilidad)
\layout Description


\size largest 
tell
\layout Standard

Obtiene la posición corriente de un puntero de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
long tell (int descriptor);
\layout Standard

Devuelve la posición actual del puntero de fichero o -1 en caso de error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <fcntl.h>
\layout Quotation


\family typewriter 
#include <io.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int descriptor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char mensaje[] = "Hola mundo";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if((descriptor = open ("PRUEBA.$$$", O_CREAT | O_TEXT | O_APPEND)) == -1)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 perror("Error");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 return 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 write(descriptor, mensaje, strlen (mensaje));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El puntero de fichero está en el byte %ld
\backslash 
n", tell (descriptor));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 close(descriptor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
unlink
\layout Standard

Borra un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int unlink (const char *nombre_de_fichero);
\layout Standard

Si el nombre de fichero tiene atributo de sólo lectura, 
\family typewriter 
unlink
\family default 
 fallará.
 Llama a 
\family typewriter 
chmod()
\family default 
 primero para cambiar el atributo de fichero.
 Devuelve 0 en caso de éxito; -1 en caso de error.
 El prototipo de esta función está en los ficheros 
\family typewriter 
dos.h
\family default 
, 
\family typewriter 
io.h
\family default 
 y 
\family typewriter 
stdio.h
\family default 
.
 La función 
\family typewriter 
remove()
\family default 
 cuyo prototipo se encuentra en 
\family typewriter 
stdio.h
\family default 
 es en realidad una macro que se expande a una llamada a 
\family typewriter 
unlink()
\family default 
.
\layout Description


\size largest 
unlock
\layout Standard

Libera bloqueos de compartición de ficheros para controlar el acceso concurrente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int unlock (int descriptor, long desplazamiento, long longitud);
\layout Standard

Devuelve 0 si tiene éxito; -1 si ocurre un error.
\layout Description


\size largest 
write
\layout Standard

Escribe en un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int write (int descriptor, void *buffer, unsigned longitud);
\layout Standard

Devuelve el número de bytes escritos, o -1 si ocurre un error.
\layout Description


\size largest 
_write
\layout Standard

Escribe en un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int _write (int descriptor, void *buffer, unsigned longitud);
\layout Standard

Devuelve el número de bytes escritos, o -1 si ocurre un error.
\layout Description


\size largest 
HANDLE_MAX (#define)
\layout Standard

Número máximo de descriptores.
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 9-1
\series default 
.
 Este programa concatena varios ficheros y los presenta en la salida estándar
 (la pantalla normalmente).
 Si redireccionamos la salida (con >) concatenamos varios ficheros en otro
 fichero.
 Si no hay ningún argumento, se lee de la estrada estándar (el teclado normalmen
te).
\layout Quotation


\family typewriter 
#include <stdio.h>
\protected_separator 
 /* FILE, stdin, fopen (), NULL, fprintf (), stderr,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 fclose (), getc (), putc (), stdout */
\layout Quotation


\family typewriter 
#include <stdlib.h> /* exit () */
\layout Quotation


\family typewriter 
void main(int argc, char *argv[])
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 FILE *pf;
\layout Quotation


\family typewriter 

\protected_separator 
 void copiar_fichero(FILE *pf);
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 
 if(argc == 1) /* ningún argumento; copiar la entrada estándar */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 copiar_fichero(stdin);
\layout Quotation


\family typewriter 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 while(--argc)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 if((pf = fopen (*++argv, "r")) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 fprintf(stderr, "
\backslash 
nError: No se puede abrir el fichero %s.
\backslash 
n", *argv);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit(1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 copiar_fichero(pf);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 fclose(pf);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 
/* copiar el fichero pf en la salida estándar */
\layout Quotation


\family typewriter 
void copiar_fichero(FILE *pf)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 int c;
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 
 while((c = getc (pf)) != EOF)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 putc(c, stdout);
\layout Quotation


\family typewriter 
}
\layout Quote

La propuesta de programa que se propone es cambiar este programa para que
 el primer argumento leído desde la línea de órdenes del sistema operativo
 sea el fichero de destino y todos los demás argumentos son los ficheros
 de entrada que se han de concatener en orden en el fichero de destino.
 De este modo no necesitamos redireccionar el programa como en el ejemplo.
 Si el usuario ejecuta el programa sin ningún argumento se le informa con
 un mensaje de error.
\layout Itemize


\series bold 
Ejercicio 9-2
\series default 
.
 Implementar las funciones de librería 
\family typewriter 
fgets()
\family default 
 y 
\family typewriter 
fputs()
\family default 
, utilizando en el primer caso la función 
\family typewriter 
getc()
\family default 
 y en el segundo la función 
\family typewriter 
putc()
\family default 
.
\layout Itemize


\series bold 
Ejercicio 9-3
\series default 
.
 Hacer un programa que acepte varios argumentos desde la línea de comando
 del sistema operativo en la forma:
\layout Quotation

nombre_programa "texto" fichero_1 fichero_2 ...
\layout Quote

es decir, que el primer argumento sea un texto entre comillas y a partir
 del segundo argumento, inclusive el segundo, una serie de ficheros.
 El programa tiene que decir el nombre del fichero y el número de línea
 de este fichero en el cual aparece la primera ocurrencia de texto.
\layout Itemize


\series bold 
Ejercicio 9-4
\series default 
.
 Hacer un programa que lea un fichero de texto y escriba el número de líneas
 y el número de caracteres que tiene ese fichero.
\layout Itemize


\series bold 
Ejercicio 9-5
\series default 
.
 Construir un programa que lee un fichero de texto e imprima una lista de
 todas las palabras aparecidas en el fichero junto con los números de líneas
 en las que aparecen.
 La lista de palabras se escribe en orden alfabético y la lista de números
 de línea para cada palabra se escriben de menor a mayor.
 Ejemplo, Fichero de texto:
\begin_deeper 
\layout Enumerate

Se considera como palabra
\layout Enumerate

una sencuencia de caracteres
\layout Enumerate

entre dos espacios o
\layout Enumerate

caracteres de nueva línea.
\layout Enumerate

Posible estructura: árbol con un
\layout Enumerate

campo para el string línea y otro
\layout Enumerate

campo contiene un puntero al
\layout Enumerate

principio de una lista ordenada
\layout Enumerate

que contiene los números de líneas.
\end_deeper 
\layout Quote

Salida:
\layout Quotation

al 7
\layout Quotation

campo 6 7
\layout Quotation

caracteres 2 4
\layout Quotation

como 1
\layout Quotation

considera 1
\layout Quotation

con 5
\layout Quotation

contiene 7 9
\layout Quotation

de 2 4 8 9
\layout Quotation

dos 3
\layout Quotation

el 6
\layout Quotation

entre 3
\layout Quotation

espacios 3
\layout Quotation

estructura: 5
\layout Quotation

línea 4 6
\layout Quotation

líneas 9
\layout Quotation

lista 8
\layout Quotation

los 9
\layout Quotation

nueva 4
\layout Quotation

números 9
\layout Quotation

o 3
\layout Quotation

ordenada 8
\layout Quotation

otro 6
\layout Quotation

palabra 1
\layout Quotation

para 6
\layout Quotation

posible 5
\layout Quotation

principio 8
\layout Quotation

puntero 7
\layout Quotation

que 9
\layout Quotation

Se 1
\layout Quotation

secuencia 2
\layout Quotation

string 6
\layout Quotation

un 5 7
\layout Quotation

una 2 8
\layout Quotation

y 6
\layout Quotation

árbol 5
\layout Itemize


\series bold 
Ejercicio 9-6
\series default 
.
 Queremos implementar una estructura de datos que represente el servicio
 de autobuses de una ciudad, teniendo en cuentra que las paradas estarán
 representadas por un carácter y las líneas de autobuses por números.
 La estructura resultante ha de ser una lista de nodos con todas las paradas
 de la ciudad, y asociado a cada parada una sola lista con la información
 de los autobuses que pasan por ella y una referencia a la siguiente parada
 para cada línea.
\layout Enumerate

Codificar un programa en C que construya la anterior estructura a partir
 de un fichero de texto con la siguiente información: una línea de texto
 por cada línea de autobús, de forma que primero figure el número de línea
 y después en orden de adyacencia las paradas de esa línea.
\layout Enumerate

Construir en C una función que reciba una lista de paradas intermedias y
 devuelva si es o no posible hacer ese recorrido y cuál sería la sucesión
 de autobuses que se habría de coger.
 Suponer que entre dos paradas sólo hay una posible línea.
\layout Itemize


\series bold 
Ejercicio 9-7
\series default 
.
 Una característica importante de las funciones 
\family typewriter 
fread()
\family default 
 y 
\family typewriter 
fwrite()
\family default 
 es que permiten leer y escribir estructuras respectivamente, es decir,
 que podemos trabajar con lo que se llama en lenguajes de gestión: registros.
\layout Quote

Supongamos que tenemos declarada la variable vst que es del tipo compuesto
 estructura:
\layout Quotation


\family typewriter 
struct st vst;
\layout Quote

entonces podemos escribir un registro de tipo struct st en el fichero pf
 de la siguiente forma:
\layout Quotation


\family typewriter 
fwrite(&vst, sizeof(struct st), 1, pf);
\layout Quote

y leer registros de la siguiente forma:
\layout Quotation


\family typewriter 
fread(&vst, sizeof(struct st), 1, pf);
\layout Quote

Cuando se va a trabajar con estructuras como la descrita conviene abrir
 el fichero en modo binario, ya que se suele abrir en modo texto cuando
 lo vamos a procesar línea a línea.
 Después de esta introducción vamos a proponer un programa que trabaje con
 registros de ficheros:
\layout Quote

Un fichero de referencia de los libros de una biblioteca está constituido
 por registros del siguiente tipo:
\begin_deeper 
\layout Enumerate

Número de referencia del libro, entero.
 No hay números de referencia repetidos.
\layout Enumerate

Autor, 25 caracteres.
\layout Enumerate

Título del libro, 50 caracteres.
\layout Enumerate

Tema del libro, 8 caracteres.
\end_deeper 
\layout Quote

Este fichero se denomina LIBROS.DAT, y viene ordenado por números de referencia.
 Realizar un programa que permita altas, bajas y consultas con el fichero
 LIBROS.DAT.
 Una vez que tenemos el fichero LIBROS.DAT, se debe realizar otro programa
 que haga lo siguiente: partiendo de dicho fichero, se tiene que formar
 primero una lista encadenada en memoria, por orden alfabético del tema,
 y a igualdad de tema, por orden alfabético del autor, y a igualdad de autor,
 por orden del número de referencia.
 Una vez formada dicha lista, el programa debe generar a partir de ella
 tantos ficheros como temas haya.
 Cada fichero tendrá el nombre del tema, sin extensión, y estará formado
 por los registros de los libros de dicho tema, conteniendo cada registro
 el número de referencia, el autor y el título, con tamaños iguales a los
 del fichero de entrada.
\layout Itemize


\series bold 
Ejercicio 9-8
\series default 
.
 Realizar un programa para el mantenimiento de los miembros de una asociación
 de ámbito provincial, según los criterios siguientes:
\layout Quote

a) Al arrancar el programa, en primer lugar, leerá de un fichero de SOCIOS
 los datos de los mismos, formando con ellos una lista encadenada.
 Los registros del fichero de entrada están en orden alfabético, por lo
 que se irán encadenando uno tras otro en el mismo orden en que sean leído.
\layout Quote

b) Tras esta operación, ofrecerá repetitivamente un menú con las opciones
 1-ALTA, 2-BAJA, 3-CONSULTA y 4-FIN.
 Los procesos de alta y de baja mantendrán la lista encadenada en orden
 alfabético.
 No se admitirán nombres repetidos.
\layout Quote

c) Al terminar el programa (opción 4-FIN), se reescribirá el fichero SOCIOS,
 con los datos actualizados que se tengan en la lista encadenada.
\layout Quote

d) Los registros del fichero se atienen al siguiente formato:
\layout Quotation

1-Nombre: 30 caracteres.
\layout Quotation

2-Domicilio: 30 caracteres.
\layout Quotation

3-Teléfono: entero.
\layout Quotation

4-Código postal: entero en el rango 1 al 999.
\layout Quote

e) En el proceso de alta se leerán de teclado todos los datos del nuevo
 socio.
 En el proceso de baja se leerá sólo el nombre.
 En el proceso de consulta, se leerá sólo el nombre y se mostrarán todos
 los datos en pantalla.
\layout Itemize


\family typewriter 
\series bold 
Ejercicio 9-9
\family default 
\series default 
.
 Un fichero de datos binario, de nombre PRECIOS.DAT, contiene registros formados
 como sigue:
\layout Quote

a) Identificación de un producto, 10 caracteres más el terminador.
\layout Quote

b) El precio en pesetas de dicho producto, un entero.
\layout Quote

Un segundo fichero contiene los datos de las sucesivas operaciones de venta
 a lo largo de un período de tiempo.
 El fichero, igualmente binario, de nombre VENTAS.DAT, contiene registros
 formados por:
\layout Quote

a) Identificador del producto, como en el fichero anterior.
\layout Quote

b) Número de unidades vendidas de dicho producto, un entero.
\layout Quote

En este fichero, van consecutivos todos los elementos correspondientes a
 la misma operación de venta, terminando cada operación con un registro
 que contiene un asterisco como único carácter identificador de producto,
 lo que cierra la factura de la operación, y a continuación sigue otra operación
 de venta de la misma manera, o el final del fichero.Realizar un programa
 que:
\layout Enumerate

Gestione los dos ficheros anteriores: altas, bajas, consultas y modificaciones.
\layout Enumerate

A partir del fichero de precios, construya un árbol binario ordenado por
 identificadores de productos.
\layout Enumerate

A partir del fichero de ventas, imprima las facturas de las distintas operacione
s, según el modelo siguiente:
\layout Quotation


\family typewriter 
UNIDADES
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ARTICULO
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 PRECIO UNITARIO
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 IMPORTE
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 10
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 patatas
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 40
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 400
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ..
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 .......
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 .....
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ......
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 12
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 leche
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 110
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 1320
\layout Quotation


\family typewriter 

\protected_separator 

\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 IMPORTE TOTAL ........................
 6850
\layout Itemize


\series bold 
Ejercicio 9-10
\series default 
.
 Se han recogido en un fichero secuencial denominado VIAJES las informaciones
 relativas a todos los desplazamientos profesionales efectuados en una empresa
 durante un año.
 Cada vez que se produce un desplazamiento se crea un registro que consta
 de lo siguientes campo:
\begin_deeper 
\layout Itemize

Nombre de la ciudad a donde se realizó el desplazamiento.
\layout Itemize

Fecha del desplazamiento.
\layout Itemize

Número de días de duración del desplazamiento.
\layout Itemize

Nombre de la persona que se ha desplazado.
\end_deeper 
\layout Quote

Estos datos se han registrado por orden cronológico y por lo tanto las informaci
ones no aparecen por el orden de los nombres de las ciudades.
 e quiere obtener un listado ordenado alfabéticamente por ciudad donde aparezcan
 para cada ciudad:
\layout Quotation

1º El número de viajes realizados.
\layout Quotation

2º El coste de las dietas.
\layout Quotation

3º El coste medio por día de estancia en esa ciudad.
\layout Quotation

4º Al final del listado se imprimirá el coste total de las dietas para la
 empresa.
\layout Quote

El número de ciudades es inferior a 100.
\layout Chapter

La Biblioteca de C (Parte I)
\layout Description

Primera
\protected_separator 
parte
\layout Standard

Introducción a la biblioteca del C.
\layout Itemize

Valores límites (
\family typewriter 
limits.h
\family default 
).
\layout Itemize

Tipos y macros estándares (
\family typewriter 
stddef.h
\family default 
).
\layout Itemize

Funciones de caracteres y de cadenas (
\family typewriter 
ctype.h
\family default 
, 
\family typewriter 
string.h
\family default 
).
\layout Itemize

(también 
\family typewriter 
mem.h
\family default 
 para los usuarios de Turbo C).
\layout Itemize

Funciones matemáticas (
\family typewriter 
math.h
\family default 
).
\layout Description

Segunda
\protected_separator 
parte
\layout Itemize

Funciones de pantalla y de gráficos (
\family typewriter 
conio.h
\family default 
 y 
\family typewriter 
graphics.h
\family default 
).
\layout Section

Introducción a la Biblioteca del C
\layout Standard

La biblioteca de C contiene el código objeto de las funciones proporcionadas
 con el compilador.
 Aunque las bibliotecas (ficheros con extensión 
\family typewriter 
.LIB
\family default 
) son parecidas a los ficheros objetos (fichero con extensión 
\family typewriter 
.OBJ
\family default 
), existe una diferencia crucial: No todo el código de una biblioteca se
 añade al programa.
 Cuando se enlaza un programa que consta de varios ficheros objetos, todo
 el código de cada fichero objeto se convierte en parte del programa ejecutable
 final.
 Esto ocurre se esté o no utilizando el código.
 En otras palabras, todos los ficheros objetos especificados en tiempo de
 enlace se unen para formar el programa.
 Sin embargo, este no es el caso de los ficheros de biblioteca.
\layout Standard

Una biblioteca es una colección de funciones.
 A diferencia de un fichero objeto, un fichero de biblioteca guarda una
 serie de información para cada función de tal forma que cuando un programa
 hace referencia a una función contenida en una biblioteca, el enlazador
 toma esta función y añade el código objeto al programa.
 De esta forma sólo se añadirán al fichero ejecutable aquellas funciones
 que realmente se utilicen en el programa.
 Para utilizar una función de biblioteca debemos incluir su correspondiente
 fichero de cabecera para que nuestro programa conozca el prototipo de la
 función a utilizar.
 En los ficheros de cabecera (suelen tener extensión 
\family typewriter 
.h
\family default 
) además de los prototipos de las funciones puede haber más información
 como macros, declaración de tipos, declaración de variables globales, etc.
 Los ficheros de cabecera definidos por el estándar ANSI se presentan en
 la siguiente tabla.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
16 2 0 0 -1 -1 -1 -1
1 0 0 0
0 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Fichero de
\newline 
Propósito
\newline 
cabecera
\newline 

\series default 

\newline 
assert.h
\newline 
Define la macro assert()
\newline 
ctype.h
\newline 
Uno de caracteres
\newline 
float.h
\newline 
Define valores en coma flotante dependiente de la implementación
\newline 
limits.h
\newline 
Define los límites dependientes de la implementación
\newline 
locale.h
\newline 
Soporta la función setlocale()
\newline 
math.h
\newline 
Definiciones utilizadas por la biblioteca matemática
\newline 
setjmp.h
\newline 
Soporta saltos no locales
\newline 
signal.h
\newline 
Define los valores de señal
\newline 
stdarg.h
\newline 
Soporta listas de argumentos de longitud variable
\newline 
stddef.h
\newline 
Define algunas constantes de uso común
\newline 
stdio.h
\newline 
Soporta la E/S de fichero
\newline 
stdlib.h
\newline 
Otras declaraciones
\newline 
string.h
\newline 
Soporta funciones de cadena
\newline 
time.h
\newline 
Soporta las funciones de tiempo del sistema
\layout Standard

Turbo C añade los siguientes ficheros de cabecera:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
18 2 0 0 -1 -1 -1 -1
1 0 0 0
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

Fichero de
\newline 
Propósito
\newline 
cabecera
\newline 

\newline 
alloc.h
\newline 
Asignación dinámica
\newline 
bios.h
\newline 
Funciones relacionadas con la ROM BIOS
\newline 
conio.h
\newline 
E/S por consola
\newline 
dir.h
\newline 
Directorio
\newline 
dos.h
\newline 
Sistema operativo DOS
\newline 
errno.h
\newline 
Errores del sistema
\newline 
fcntl.h
\newline 
Constantes simbólicas utilizadas por open()
\newline 
graphics.h
\newline 
Gráficos
\newline 
io.h
\newline 
E/S estándar a bajo nivel
\newline 
mem.h
\newline 
Funciones de memoria
\newline 
process.h
\newline 
Funciones de proceso
\newline 
share.h
\newline 
Constantes simbólicas utilizadas por sopen()
\newline 
sys
\backslash 
stat
\newline 
Información de ficheros
\newline 
sys
\backslash 
timeb
\newline 
Hora actual
\newline 
sys
\backslash 
types
\newline 
Definición de tipos
\newline 
values.h
\newline 
onstantes simbólicas para compatibilidad con UNIX
\layout Standard

El resto de esta lección y las dos lecciones siguientes estarán dedicadas
 a la descripción de cada fichero de 
\family typewriter 
cabecera.h
\family default 
.
 
\layout Description

Nota: las características ya estudiadas en lecciones anteriores no se volverán
 a explicar (por ejemplo, ficheros 
\family typewriter 
stdarg.h
\family default 
 y 
\family typewriter 
assert.h
\family default 
).
\layout Section

Valores Límites
\layout Standard

En el fichero de cabecera 
\family typewriter 
<limits.h>
\family default 
 se encuentra una serie de macros que definen valores límites para algunos
 tipos de datos.
\layout Subsection

Fichero de Cabecera limits.h 
\layout Standard

CONSTANTES SIMBOLICAS:
\layout Description

CHAR_xxx
\protected_separator 
(#defines)
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
3 2 0 0 -1 -1 -1 -1
1 1 0 0
0 1 0 0
0 1 0 0
8 1 1 "" ""
2 0 1 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""


\family typewriter 
CHAR_BIT
\family default 

\newline 
Tipo 
\family typewriter 
char
\family default 
, número de bits en un dato tipo 
\family typewriter 
char
\family default 

\newline 

\family typewriter 
CHAR_MAX
\family default 

\newline 
Tipo 
\family typewriter 
char
\family default 
, mínimo valor
\newline 

\family typewriter 
CHAR_MIN
\family default 

\newline 
Tipo 
\family typewriter 
char
\family default 
, máximo valor
\layout Standard

Estos valores son independientes de si tipo 
\family typewriter 
char
\family default 
 está definido como 
\family typewriter 
signed
\family default 
 o 
\family typewriter 
unsigned
\family default 
 por defecto.
\layout Description

INT_xxx
\protected_separator 
(#defines)
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
2 2 0 0 -1 -1 -1 -1
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\family typewriter 
INT_MAX
\family default 

\newline 
Tipo 
\family typewriter 
int
\family default 
, máximo valor
\newline 

\family typewriter 
INT_MIN
\family default 

\newline 
Tipo 
\family typewriter 
int
\family default 
, mínimo valor
\layout Description

LONG_xxx
\protected_separator 
#defines
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
2 2 0 0 -1 -1 -1 -1
1 1 0 0
0 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""


\family typewriter 
LONG_MAX
\family default 

\newline 
Tipo 
\family typewriter 
long
\family default 
, máximo valor
\newline 

\family typewriter 
LONG_MIN
\family default 

\newline 
Tipo 
\family typewriter 
long
\family default 
, mínimo valor
\layout Standard

Máximo y mínimo valor para tipo 
\family typewriter 
long
\family default 
.
\layout Description

SCHAR_xxx
\protected_separator 
(#defines)
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
2 2 0 0 -1 -1 -1 -1
1 1 0 0
0 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""


\family typewriter 
SCHAR_MAX
\family default 

\newline 
Tipo 
\family typewriter 
char
\family default 
, máximo valor
\newline 

\family typewriter 
SCHAR_MIN
\family default 

\newline 
Tipo 
\family typewriter 
char
\family default 
, mínimo valor
\layout Description

SHRT_xxx
\protected_separator 
(#defines)
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
2 2 0 0 -1 -1 -1 -1
1 1 0 0
0 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""


\family typewriter 
SHRT_MAX
\family default 

\newline 
Tipo 
\family typewriter 
short
\family default 
, máximo valor
\newline 

\family typewriter 
SHRT_MIN
\family default 

\newline 
Tipo 
\family typewriter 
short
\family default 
, mínimo valor
\layout Description

UCHAR_MAX
\protected_separator 
(#define)
\layout Standard

Máximo valor para tipo unsigned char.
\layout Description

UINT_MAX
\protected_separator 
(#define)
\layout Standard

Máximo valor para tipo unsigned int.
\layout Description

ULONG_MAX
\protected_separator 
(#define)
\layout Standard

Máximo valor para tipo unsigned int.
\layout Description

USHRT_MAX (#define)
\layout Standard

Máximo valor para tipo unsigned short.
\newline 

\layout Standard

En el ejemplo 1 de esta lección se utilizan todas estas macros.
\layout Section

Tipos y Macros Estándares
\layout Standard

El estándar ANSI define unos cuantos tipos estándares y macros en el fichero
 
\family typewriter 
<stddef.h>
\family default 
.
\layout Subsection

Fichero de Cabecera stddef.h
\layout Standard

El estándar ANSI define unos cuantos tipos estándares y macros en el fichero
 
\family typewriter 
stddef.h
\family default 
.
 Uno de los tipos es 
\family typewriter 
ptrdiff_t
\family default 
 que es un tipo entero con signo y el resultado de restar dos punteros.
 La macro 
\family typewriter 
size_t
\family default 
 es el tipo entero sin signo del resultado del operador de tiempo de compilación
 
\family typewriter 
sizeof
\family default 
.
 Las dos macros son 
\family typewriter 
NULL
\family default 
 (que se corresponde con los punteros nulos) y 
\family typewriter 
ERRNO
\family default 
 (que se corresponde con el valor modificable utilizado para guardar los
 diferentes códigos de error generados por las funciones de biblioteca).
\layout Standard

En Turbo C, la variable global 
\family typewriter 
errno
\family default 
 sustituye a la macro 
\family typewriter 
ERRNO
\family default 
.
 Además el fichero 
\family typewriter 
stddef.h
\family default 
 incluye el fichero 
\family typewriter 
errno.h
\family default 
.
 En el fichero 
\family typewriter 
errno.h
\family default 
 se encuentran declaradas dos variables globales (
\family typewriter 
errno
\family default 
 y 
\family typewriter 
_doserrno
\family default 
) y las definiciones de los números de error.
\layout Section

Funciones de Caracteres y de Cadenas
\layout Standard

La biblioteca estándar de C tiene un rico y variado conjunto de funciones
 de manejo de caracteres y de cadenas.
 La utilización de las funciones de caracteres requieren la inclusión del
 fichero 
\family typewriter 
<ctype.h>
\family default 
; y la utilización de las funciones de caracteres requieren la inclusión
 del fichero 
\family typewriter 
<string.h>
\family default 
.
\layout Standard

En C una cadena es un array de caracteres que finaliza con un carácter nulo.
 Puesto que el C no tiene asociadas operaciones de comprobación de cadenas,
 es responsabilidad del programador proteger los arrays del desbordamiento.
 Si un array se desborda, el comportamiento queda indefinido.
 
\layout Standard

Las funciones de caracteres toman un argumento entero, pero sólo se utiliza
 el byte menos significativo.
 En general, nosotros somos libres de utilizar un argumento de tipo carácter
 ya que automáticamente se transforma en entero en el momento de la llamada.
\layout Subsection

Fichero de Cabecera ctype.h
\layout Title


\family roman 
Macros definidas en 
\family default 
ctype.h.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
14 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
0 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Macro
\newline 
Verdad (true) si c es...
\series default 

\newline 
isalnum(c)
\newline 
Una letra o dígito
\newline 
isalpha(c)
\newline 
Una letra
\newline 
isdigit(c)
\newline 
Un dígito
\newline 
iscntrl(c)
\newline 
Un carácter de borrado o un carácter de control ordinario
\newline 
isascii(c)
\newline 
Un carácter ASCII válido
\newline 
isprint(c)
\newline 
Un carácter imprimible
\newline 
isgraph(c)
\newline 
Un carácter imprimible, excepto el carácter espacio
\newline 
islower(c)
\newline 
Una letra minúscula
\newline 
isupper(c)
\newline 
Una letra mayúscula
\newline 
isspace(c)
\newline 
Un espacio, tabulador, retorno de carro, nueva línea, tabulación vertical,
\newline 

\newline 
o alimentación de línea
\newline 
ispunct(c)
\newline 
Un carácter de puntuación
\newline 
isxdigit(c)
\newline 
Verdad si c es un dígito hexadecimal
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 0 0 0
1 0 0 0
0 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Macros de TC
\newline 
Convierte c ...
\series default 

\newline 
_toupper(c)
\newline 
En el rango [a-z] a caracteres [A-Z]
\newline 
_tolower(c)
\newline 
En el rango [A-Z] a caracteres [a-z]
\newline 
toascii(c)
\newline 
ayor de 127 al rango 0-127 poniendo todos los bits a cero excepto los
\newline 

\newline 
7 bits más significativos
\layout Title

Funciones declaradas en ctype.h
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
3 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Prototipo
\newline 
Qué hace
\series default 

\newline 
int toupper (int ch);
\newline 
Devuelve ch en mayúscula
\newline 
int tolower (int ch);
\newline 
Devuelve ch en minúscula
\layout Description

¡¡¡OJO!!! Con las macros anteriores se debe evitar hacer operaciones como
 las siguientes:
\layout Quotation


\family typewriter 
x = isdigit (getch ());
\layout Quotation


\family typewriter 
y = isdigit (*p++);
\layout Standard

Supongamos que la macro 
\family typewriter 
isdigit()
\family default 
 está definida así:
\layout Quotation


\family typewriter 
#define isdigit(c) ((c) >= '0' && (c) <= '9')
\layout Standard

Entonces las dos asignaciones anteriores se expanderían a:
\layout Quotation


\family typewriter 
x = ((getch ()) >= '0' && (getch ()) <= '9')
\layout Quotation


\family typewriter 
y = ((*p++) >= '0' && (*p++) <= '9')
\layout Standard

El error cometido se ve claramente: en el primer caso nuestra intención
 era leer un sólo carácter y en realidad leemos dos, y en el segundo caso
 nuestra intención era incrementar en uno el puntero 
\family typewriter 
p
\family default 
 y en realidad lo incrementamos en dos.
 Si 
\family typewriter 
isdigit()
\family default 
 fuera una función en vez de una macro no habría ningún problema.
 En el ejemplo 1 de esta lección se muestra cómo usar estas macros y estas
 funciones.
\layout Subsection

Fichero de Cabecera string.h
\layout Description

NOTA: Ver observaciones más tarde.
\layout Description


\size largest 
stpcpy (TC) 
\layout Standard

Copia un string en otro.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *stpcpy (char *destino, const char *fuente);
\layout Standard

Es igual que 
\family typewriter 
strcpy()
\family default 
, excepto que 
\family typewriter 
stpcpy
\family default 
 devuelve 
\family typewriter 
destino + strlen (fuente)
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", stpcpy (s1, s2) - 2); /* s1 contiene
\protected_separator 
 e imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strcat,
\protected_separator 
fstrcat
\layout Standard

Añade fuente a destino.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strcat (char *destino, const char *fuente);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrcat (char far *destino, const char far *fuente);
\layout Standard

Devuelve destino.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10] = "a";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "bc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strcat (s1, s2)); /* s1 contiene
\protected_separator 
 e imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strchr,
\protected_separator 
fstrchr
\layout Standard

Encuentra c en s.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strchr (const char *s, int c);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrchr (const char far *s, int c);
\layout Standard

Devuelve un puntero a la primera ocurrencia del carácter c en s; si c no
 aparece en s, 
\family typewriter 
strchr()
\family default 
 devuelve 
\family typewriter 
NULL
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char c1 = 'b', c2 = 'd';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strchr (s, c1)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strchr (s, c2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strcmp,
\protected_separator 
fstrcmp
\layout Standard

Compara un string con otro.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int strcmp (const char *s1, const char *s2);
\layout Quotation


\family typewriter 
int far _fstrcmp (const char far *s1, const char far *s2);
\layout Standard

Devuelve uno de los valores siguientes:
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
<
\protected_separator 
0
\family default 
 si s1 es menor que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
==
\protected_separator 
0
\family default 
 si s1 es igual que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
>
\protected_separator 
0
\family default 
 si s1 es mayor que s2
\layout Standard

Ejecuta una comparación con signo.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "a";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "bc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strcmp (s1, s2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strcmp (s2, s1)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strcmpi
\layout Standard

Macro que compara strings.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int strcmpi (const char *s1, const char *s2);
\layout Standard

Esta rutina está implementada como una macro para compatibilidad con otros
 compiladores.
 Es igual que 
\family typewriter 
stricmp()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "aaa";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "AAA";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strcmpi (s1, s2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strcoll
\layout Standard

Compara dos strings.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int strcoll (char *s1, char *s2);
\layout Standard

La función 
\family typewriter 
strcoll()
\family default 
 compara el string apuntado por s1 con el string apuntado por s2, según
 los valores puestos por 
\family typewriter 
setlocale()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "a";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "bc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strcoll (s1, s2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strcoll (s2, s1)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strcpy
\layout Standard

Copia el string fuente al string destino.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *strcpy (char *destino, const char *fuente);
\layout Standard

Devuelve destino.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10] = "def";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strcpy (s1, s2)); /* s1 contiene
\protected_separator 
 e imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strcspn,
\protected_separator 
fstrcspn
\layout Standard

Explora un string.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: size_t strcspn (const char *s1, const char *s2);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 size_t far far _fstrcspn (const char far *s1, const char far *s2);
\layout Standard

Devuelve la longitud del substring inicial apuntado por s1 que está constituido
 sólo por aquellos caracteres que no están contenidos en el string 2.
 Dicho de otra forma, 
\family typewriter 
strcspn()
\family default 
 devuelve el índice el primer carácter en el string apuntado por s1 que
 está como carácter del string apuntado por s2.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "defdb";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strcspn (s1, s2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strdup,
\protected_separator 
fstrdup (TC)
\layout Standard

Obtiene una copia duplicada de s, o copia s a una nueva localización.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strdup (const char *s);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrdup (const char far *s);
\layout Standard

Devuelve un puntero a la copia duplicada de s, o devuelve 
\family typewriter 
NULL
\family default 
 si no hubo espacio suficiente para la asignación de la copia.
 El programador es responsable de liberar el espacio asignado por 
\family typewriter 
strdup()
\family default 
 cuando ya no sea necesario.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if((s1 = strdup (s2)) != NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%s", s1); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 free(s1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_strerror (TC)
\layout Standard

Construye un mensaje de error hecho a medida.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *_strerror (const char *s);
\layout Standard

El mensaje de error está constituido por s, dos puntos, un espacio, el mensaje
 de error más reciente generado por el sistema, y un carácter de nueva línea.
 El string s debe tener 94 caracteres o menos.
 Devuelve un puntero al string que contiene el mensaje de error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", _strerror ("Prueba")); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
} /* la impresión descrita puede variar entre distintas implementaciones
 */
\layout Description


\size largest 
strerror
\layout Standard

Devuelve un puntero al string que contiene el mensaje de error.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *strerror (int numerr);
\layout Standard

Devuelve un puntero al mensaje de error asociado con 
\family typewriter 
numerr
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strerror (3)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
} /* la impresión descrita puede variar entre distintas implementaciones
 */
\layout Description


\size largest 
stricmp,
\protected_separator 
fstricmp (TC)
\layout Standard

Compara un string con otro ignorando el caso.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: int stricmp (const char *s1, const char *s2);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 int far _fstrcmp (const char far *s1, const char far *s2);
\layout Standard

Devuelve uno de los siguientes valores:
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
<
\protected_separator 
0
\family default 
 si s1 es menor que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
==
\protected_separator 
0
\family default 
 si s1 es igual que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
>
\protected_separator 
0
\family default 
 si s1 es mayor que s2
\layout Standard

Ejecuta una comparación con signo.
 La macro 
\family typewriter 
strcmpi()
\family default 
, definida en 
\family typewriter 
string.h
\family default 
, es equivalente a 
\family typewriter 
stricmp()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "aaa";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "AAA";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strcmpi (s1, s2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strlen,
\protected_separator 
fstrlen
\layout Standard

Calcula la longitud de un string.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: size_t strlen (const char *s);
\layout Quotation


\family typewriter 
Far: size_t _fstrlen (const char far *s);
\layout Standard

Devuelve el número de caracteres que hay en s, no contando el carácter terminado
r nulo.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s[10] = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strlen (s)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", sizeof (s)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strlwr,
\protected_separator 
fstrlwr (TC)
\layout Standard

Convierte s a caracteres en minúsculas.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strlwr (char *s);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrlwr (char char far *s);
\layout Standard

Devuelve un puntero a s.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s = "AbC";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strlwr (s)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strncat,
\protected_separator 
fstrncat
\layout Standard

Añade como máximo longmax caracteres de fuente a destino.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strncat (char *destino, const char *fuente, size_t longmax);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrncat (char far *destino, const char far *fuente,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 size_t longmax);
\layout Standard

Devuelve destino.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "bcdef";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n1 = 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n2 = 10;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy(s1, "a");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strncat (s1, s2, n1)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy (s1, "a");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strncat (s1, s2, n2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strncmp,
\protected_separator 
fstrncmp
\layout Standard

Compara como mucho 
\family typewriter 
longmax
\family default 
 caracteres de un string con otro.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: int strncmp (const char *s1, const char *s2, size_t longmax);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 int far _fstrncmp (const char far *s1, const char far *s2,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 size_t longmax);
\layout Standard

Devuelve uno de los siguientes valores:
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
<
\protected_separator 
0
\family default 
 si s1 es menor que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
==
\protected_separator 
0
\family default 
 si s1 es igual que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
>
\protected_separator 
0
\family default 
 si s1 es mayor que s2
\layout Standard

Ejecuta una comparación con signo.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "aaa";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "aab";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n1 = 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n2 = 5;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strncmp (s1, s2, n1)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strncmp (s1, s2, n2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strncmpi (TC)
\layout Standard

Compara un trozo de un string con un trozo de otro, sin sensibilidad al
 caso.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int strncmpi (const char *s1, const char *s2, size_t n);
\layout Standard

La función 
\family typewriter 
strncmpi()
\family default 
 ejecuta una comparación con signo entre s1 y s2, para una longitud máxima
 de n bytes, empezando con el primer carácter de cada string y continuando
 con los caracteres siguientes hasta encontrar caracteres correspondientes
 diferentes o hasta que se han examinado n caracteres.
 Devuelve un valor (<0, 0, o >0) basado en el resultado de la comparación
 de s1 (o parte de él) con s2 (o parte de él).
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "aaa";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "AAb";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n1 = 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n2 = 5;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strncmpi (s1, s2, n1)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strncmpi (s1, s2, n2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strncpy,
\protected_separator 
fstrncpy
\layout Standard

Copia como máximo longmax caracteres de fuente a destino.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strncpy (char *destino, const char *fuente, size_t longmax);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrncpy (char far *destino, const char far *fuente,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 size_t longmax)
\layout Standard

Si son copiados 
\family typewriter 
longmax
\family default 
 caracteres, no es añadido el carácter nulo; por lo tanto, el contenido
 de destino no es un string terminado en nulo.
 Devuelve destino.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "abcd";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n1 = 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n2 = 10;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", (strncpy (s1, s2, n1), *(s1+n1) = 0, s1)); /*imprime */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strncpy (s1, s2, n2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strnicmp,
\protected_separator 
fstrnicmp (TC)
\layout Standard

Compara como máximo n caracteres de un string con otro, ignorando el caso.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: int strnicmp (const char *s1, const char *s2, size_t longmax);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 int far _fstrnicmp (const char far *s1, const char far *s2,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 size_t longmax);
\layout Standard

Devuelve uno de los siguientes valores:
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
<
\protected_separator 
0
\family default 
 si s1 es menor que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
==
\protected_separator 
0
\family default 
 si s1 es igual que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
>
\protected_separator 
0
\family default 
 si s1 es mayor que s2
\layout Standard

Ejecuta comparación con signo.
 La macro 
\family typewriter 
strncmpi()
\family default 
, definida en string.h, es equivalente a 
\family typewriter 
strnicmp()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "aaa";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "AAb";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n1 = 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n2 = 5;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strnicmp (s1, s2, n1)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strnicmp (s1, s2, n2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strnset,
\protected_separator 
fstrnset (TC)
\layout Standard

Copia el carácter ch en las primeras n posiciones de s.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strnset (int *s, int ch, size_t n);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrnset (char far *s, int ch, size_t n);
\layout Standard

Se para cuando los n caracteres son copiados o se encuentra 
\family typewriter 
NULL
\family default 
.
 Devuelve un puntero a s.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s[10] = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char c1 = 'x';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char c2 = 'y';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n1 = 10;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n2 = 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strnset (s, c1, n1)); /* s contiene
\protected_separator 
 e imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strnset (s, c2, n2)); /* s contiene
\protected_separator 
 e imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strpbrk,
\protected_separator 
fstrpbrk
\layout Standard

Explora un string.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strpbrk (const char *s1, const char *s2);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrpbrk (const char far *s1, const char far *s2);
\layout Standard

Devuelve un puntero al primer carácter del string apuntado por s1 que se
 corresponde con algún carácter en el string apuntado por s2.
 El carácter nulo de terminación no se incluye.
 Si no hay correspondencia, se devuelve un puntero nulo.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "de";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s3 = "db";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strpbrk (s1, s2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strpbrk (s1, s3)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strrchr,
\protected_separator 
fstrrchr
\layout Standard

Encuentra la última ocurrencia de c en s.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strrchr (const char *s, int c);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrrchr (const char far *s, int c);
\layout Standard

Devuelve un puntero a la última ocurrencia del carácter c, o 
\family typewriter 
NULL
\family default 
 si c no aparece en s.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s = "abcabc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char c1 = 'b', c2 = 'd';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strrchr (s, c1)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strrchr (s, c2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strrev,
\protected_separator 
fstrrev (TC)
\layout Standard

Invierte todos los caracteres de s (excepto el carácter terminador nulo).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strrev (char *s);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrrev (char far *s);
\layout Standard

Devuelve un puntero al string invertido.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strrev (s)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strset,
\protected_separator 
fstrset (TC)
\layout Standard

Copia el carácter ch a todas las posiciones de s.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strset (char *s, int ch);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrset (char far *s, int ch);
\layout Standard

Termina cuando se encuentra el primer carácter nulo.
 Devuelve un puntero a s.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s[10] = "abcd";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char c = 'z';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strset (s, c)); /* s contiene
\protected_separator 
 e imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strspn,
\protected_separator 
fstrspn
\layout Standard

Explora un string para encontrar un segmento que es un subconjunto de un
 conjunto de caracteres.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: size_t strspn (const char *s1, const char *s2);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 size_t far _fstrspn (const char far *s1, const char far *s2);
\layout Standard

Devuelve la longitud del substring inicial del string apuntado por s1 que
 está constituido sólo por aquellos caracteres contenidos en el string apuntado
 por s2.
 Dicho de otra forma, 
\family typewriter 
strspn()
\family default 
 devuelve el índice del primer carácter en el string apuntado por s1 que
 no se corresponde con ningún carácter del string apuntado por s2.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "acbbad";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", strspn (s1, s2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strstr,
\protected_separator 
fstrstr
\layout Standard

Encuentra la primera ocurrencia de un substring en un string.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strstr (const char *s1, const char *s2);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrstr (const char far *s1, const char far *s2);
\layout Standard

Devuelve un puntero a la primera ocurrencia en la cadena apuntada por s1
 de la cadena apuntada por s2 (excepto el carácter nulo de terminación de
 s2).
 Devuelve un puntero nulo si no se encuentra.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "abcdef";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "cd";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s3 = "cdg";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strstr (s1, s2)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strstr (s1, s3)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strtok,
\protected_separator 
fstrtok
\layout Standard

Explora s1 para encontrar el primer token no contenido en s2.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strtok (char *s1, const char *s2);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrtok (char far *s1, const char far *s2);
\layout Standard

s2 define caracteres separadores; 
\family typewriter 
strtok()
\family default 
 interpreta el string s1 como una serie de tokens separados por los caracteres
 separadores que hay en s2.
 Si no se encuentra ningún token en s1, 
\family typewriter 
strtok()
\family default 
 devuelve 
\family typewriter 
NULL
\family default 
.
 Si se encuentra un token, se pone un carácter nulo en s1 siguiendo al 
\family typewriter 
token
\family default 
, y 
\family typewriter 
strtok()
\family default 
 devuelve un puntero al 
\family typewriter 
token
\family default 
.
 En las llamadas siguientes a 
\family typewriter 
strtok()
\family default 
 con 
\family typewriter 
NULL
\family default 
 como primer argumento, usa el string previo s1, empezando después del último
 token encontrado.
 Nótese que la cadena inicial es, por tanto, destruida.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s1 = "ab cd, e; fg,h:ijk.";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = " ,;:.";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *p;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p = strtok(s1, s2);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 while (p)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf(p);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 p = strtok (NULL, s2);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* el bucle while imprime:
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strupr,
\protected_separator 
fstrupr (TC)
\layout Standard

Convierte todos los caracteres de s a mayúsculas.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: char *strupr (char *s);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 char far * far _fstrupr (char far *s);
\layout Standard

Devuelve un puntero a s.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s = "aBc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", strupr (s)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strxfrm (TC)
\layout Standard

Transforma un trozo de un string.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
size_t strxfrm (char *s1, char *s2, size_t n);
\layout Standard

Es equivalente a 
\family typewriter 
strncpy()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "abcdefg";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf ("
\backslash 
n%d ", strxfrm (s1, s2, 10)); /* s1 contiene e imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description

OBSERVACIONES
\layout Enumerate

Aquellas funciones que tienen al principio de la descripción: (TC) no están
 en el ANSI C y sí en TURBO C.
 Asimismo, la distinción entre funciones near y far no está en el ANSI,
 sino que también es propio de TURBO C: el prototipo de near en aquellas
 funciones que no tienen (TC) es el prototipo de la función en el ANSI.
 No obstante, aquellos usuarios que tengan la opción turbo a off, verán
 todas las funciones ya que muchas de estas funciones que no pertenecen
 al ANSI C están en muchos compiladores y además así tienen una visión más
 amplia de la variedad de operaciones que se pueden hacer con los strings
 (llamados en castellano cadenas).
\layout Enumerate

Las funciones 
\family typewriter 
memccpy()
\family default 
, 
\family typewriter 
memchr()
\family default 
, 
\family typewriter 
memcmp()
\family default 
, 
\family typewriter 
memcpy()
\family default 
, 
\family typewriter 
memicmp()
\family default 
, 
\family typewriter 
memmove()
\family default 
, 
\family typewriter 
memset()
\family default 
, 
\family typewriter 
movedata()
\family default 
, 
\family typewriter 
movmem()
\family default 
 y 
\family typewriter 
setmem()
\family default 
 están declaradas en Turbo C en los ficheros 
\family typewriter 
string.h
\family default 
 y 
\family typewriter 
mem.h
\family default 
.
 De entre las funciones anteriores, pertenecen al ANSI las funciones 
\family typewriter 
memchr()
\family default 
, 
\family typewriter 
memcmp()
\family default 
, 
\family typewriter 
memcpy()
\family default 
 y 
\family typewriter 
memset()
\family default 
, entre todas éstas, la función 
\family typewriter 
memchr()
\family default 
 está declarada en el ANSI en el fichero 
\family typewriter 
ctype.h
\family default 
 y el resto en 
\family typewriter 
string.h
\family default 
.
 Estas funciones las estudiarán en la ventana siguiente los usuarios que
 tengan activada la opción de turbo puesta a on; los que tengan la opción
 de turbo a off no la estudiarán porque en realidad son superfluas: todo
 lo que se puede hacer con ellas, se puede hacer con las funciones de cadenas.
\layout Subsection

Fichero de Cabecera mem.h
\layout Description


\size largest 
memccpy,
\protected_separator 
fmemccpy
\layout Standard

Copia un bloque de n bytes de fuente a destino.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: void *memccpy (void *destino, const void *fuente, int c, size_t n);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 void far * far _fmemccpy (void far *destino, const void far *fuente,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int c, size_t n);
\layout Standard

Esta función se para después de copiar un byte que coincida con c y devuelve
 un puntero al byte en destino inmediatamente siguiente a c; en otro caso
 devuelve 
\family typewriter 
NULL
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <mem.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *s2 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char c1 = 'd';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char c2 = 'b';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", memccpy (s1, s2, c1, strlen (s2))); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", memccpy (s1, s2, c2, strlen (s2))); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
memchr,
\protected_separator 
fmemchr
\layout Standard

Busca el carácter c en los primeros n bytes del array s.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: void *memchr (const void *s, int c, size_t n);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 void far * far _fmemchr (const void far *s, int c, size_t n);
\layout Standard

Devuelve un puntero a la primera ocurrencia de c en s; devuelve 
\family typewriter 
NULL
\family default 
 si c no aparece en el array s.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <mem.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *s = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char c1 = 'd';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char c2 = 'b';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", memchr (s, c1, strlen (s))); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", memchr (s, c2, strlen (s))); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
memcmp,
\protected_separator 
fmemcmp
\layout Standard

Compara dos strings, s1 y s2, para una longitud de n bytes exactamente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: int memcmp (const void *s1, const void *s2, size_t n);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 int far _fmemcmp (const void far *s1, const void far *s2, size_t n);
\layout Standard

Devuelve uno de los valores siguientes:
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
<
\protected_separator 
0
\family default 
 si s1 is menor que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
==
\protected_separator 
0
\family default 
 si s1 is igual que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
>
\protected_separator 
0
\family default 
 si s1 is mayor que s2
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <mem.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *s1 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *s2 = "aBc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", memcmp (s1, s2, strlen (s1))); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
memcpy,
\protected_separator 
fmemcpy
\layout Standard

Copia un bloque de n bytes de fuente a destino.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: void *memcpy (void *destino, const void *fuente, size_t n);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 void far *far _fmemcpy (void far *destino, const void far *fuente,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 size_t n);
\layout Standard

Devuelve destino.
 Ejemplo
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <mem.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *s2 = "abc";"
\layout Quotation


\family typewriter 
""
\layout Quotation


\family typewriter 
"
\protected_separator 

\protected_separator 
 printf("%s", memcpy (s1, s2, strlen (s2))); /* imprime */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
memicmp,
\protected_separator 
fmemicmp
\layout Standard

Compara los primeros n bytes de s1 y s2, ignorando el caso.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: int memicmp (const void *s1, const void *s2, size_t n);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 int far _fmemicmp (const void far *s1, const void far *s2, size_t n);
\layout Standard

Devuelve uno de los valores siguientes:
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
<
\protected_separator 
0
\family default 
 si s1 is menor que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
==
\protected_separator 
0
\family default 
 si s1 is igual que s2
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
>
\protected_separator 
0
\family default 
 si s1 is mayor que s2
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <mem.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *s1 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *s2 = "aBc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d", memicmp (s1, s2, strlen (s1))); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
memmove
\layout Standard

Copia un bloque de n bytes de fuente a destino.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *memmove (void *destino, const void *fuente, size_t n);
\layout Standard

Devuelve destino.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <mem.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 const char *s2 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", memmove (s1, s2, strlen (s2))); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
memset,
\protected_separator 
fmemset
\layout Standard

Copia n veces el byte c en s.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
Near: void *memset (void *s, int c, size_t n);
\layout Quotation


\family typewriter 
Far:
\protected_separator 
 void far * far _fmemset (void far *s, int c, size_t n);
\layout Standard

Devuelve s.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <mem.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s[5];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char c = 'a';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", (memset (s, c, 4), s[4] = 0, s)); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
movedata
\layout Standard

Copia n bytes.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void movedata(unsigned segmento_fuente, unsigned desplazamiento_fuente,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned segmento_destino, unsigned desplazamiento_destino, size_t n);
\layout Standard

Copia n bytes de 
\family typewriter 
segmento_fuente:desplazamiento_fuente
\family default 
 a 
\family typewriter 
segmento_destino:desplazamiento_destino
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h> /* printf () */
\layout Quotation


\family typewriter 
#include <mem.h>
\protected_separator 

\protected_separator 
 /* movedata () */
\layout Quotation


\family typewriter 
#include <dos.h>
\protected_separator 

\protected_separator 
 /* FP_SEG(): devuelve segmento de una dirección
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 FP_OFF(): devuelve desplazamiento de una dirección */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 char far *s1[10];
\layout Quotation


\family typewriter 

\protected_separator 
 char far *s2 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 
 movedata (FP_SEG (s2), FP_OFF (s2), FP_SEG (s1), FP_OFF (s1), strlen (s2));
\layout Quotation


\family typewriter 

\protected_separator 
 s1[strlen(s1)] = 0;
\layout Quotation


\family typewriter 

\protected_separator 
 printf("%s", s1); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
movmem
\layout Standard

Mueve un bloque de longitud bytes de fuente a destino.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void movmem (void *fuente, void *destino, unsigned longitud);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <mem.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s1[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s2 = "abc";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 movmem(s2, s1, strlen (s2));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s", s1); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
setmem
\layout Standard

Asigna un valor a un rango de memoria.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void setmem (void *destino, int longitud, char valor);
\newline 

\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <mem.h>
\layout Quotation


\family typewriter 
void main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s[10];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char c = 'a';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 setmem (s, sizeof(s)-1, c);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 s[9] = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf ("%s", s); /* imprime
\protected_separator 
 */
\layout Quotation


\family typewriter 
}
\layout Section

Funciones Matemáticas
\layout Standard

Las funciones matemáticas toman argumentos de tipo 
\family typewriter 
double
\family default 
 y devuelven valores de tipo 
\family typewriter 
double
\family default 
.
 Estas funciones se dividen en las siguientes categorías:
\layout Itemize

Funciones trigonométricas.
\layout Itemize

Funciones hiperbólicas.
\layout Itemize

Funciones logarítmicas y exponenciales.
 
\layout Itemize

Otras.
\layout Standard

Todas las funciones matemáticas necesitan la cabecera 
\family typewriter 
<math.h>
\family default 
 en cualquier programa que las utilice.
 Además, al declarar las funciones matemáticas, esta cabecera define tres
 macros: 
\family typewriter 
EDOM
\family default 
, 
\family typewriter 
ERANGE
\family default 
, y 
\family typewriter 
HUGE_VAL
\family default 
.
 Si uno de los argumentos de las funciones matemáticas no se encuentra en
 uno de los dominios para el cual está definido, se devuelve un valor definido
 por la implementación y la variable global 
\family typewriter 
errno
\family default 
 se activa a 
\family typewriter 
EDOM
\family default 
 (error de dominio).
 Si el resultado de una rutina es demasiado grande como para ser representado
 por un tipo 
\family typewriter 
double
\family default 
, se produce desbordamiento.
 Esto da lugar a que la rutina devuelva 
\family typewriter 
HUGE_VAL
\family default 
, y 
\family typewriter 
errno
\family default 
 se active a 
\family typewriter 
ERANGE
\family default 
 (que indica error de rango).
 Si se produce un desbordamiento por abjao, la rutina devuelve 0 y activa
 
\family typewriter 
errno
\family default 
 a 
\family typewriter 
ERANGE
\family default 
.
\layout Subsection

Fichero de Cabecera math.h
\layout Description


\size largest 
abs
\layout Standard

Macro que devuelve el valor absoluto de de un entero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int abs (int x);
\layout Standard

En Turbo C, el prototipo de 
\family typewriter 
abs()
\family default 
 está en 
\family typewriter 
math.h
\family default 
 y en 
\family typewriter 
stdlib.h
\family default 
.
 En el ANSI C sólo se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
.
\layout Description


\size largest 
acos
\layout Standard

Arcocoseno.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double acos (double x);
\layout Standard

Devuelve el arcocoseno de x (valores de 0 a 
\begin_inset Formula \( \pi  \)
\end_inset 

) El argumento x debe estar en el rango -1 a 1; en cualquier otro caso se
 produce un error de dominio.
 
\layout Description


\size largest 
asin
\layout Standard

Arcoseno.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double asin (double x);
\layout Standard

Devuelve el arcoseno de x (valores en el rango -
\begin_inset Formula \( \pi  \)
\end_inset 

/2 a 
\begin_inset Formula \( \pi  \)
\end_inset 

/2).
 El argumento x debe estar en el rango de -1 a 1; en cualquier otro caso
 se produce un error de dominio.
\layout Description


\size largest 
atan
\layout Standard

Arcotangente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double atan (double x);
\layout Standard

Devuelve el arcotangente de x (un valor en el rango -
\begin_inset Formula \( \pi  \)
\end_inset 

/2 a 
\begin_inset Formula \( \pi  \)
\end_inset 

/2).
 
\layout Description


\size largest 
atan2
\layout Standard

Arcotangente de y/x.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double atan2 (double y, double x);
\layout Standard

Devuelve el arcotangente de y/x (un valor en el rango - 
\begin_inset Formula \( \pi  \)
\end_inset 

 a 
\begin_inset Formula \( \pi  \)
\end_inset 

).
 Utiliza el signo de sus argumentos para obtener el cuadrante del valor
 devuelto.
\layout Description


\size largest 
atof
\layout Standard

Convierte una cadena punto flotante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double atof (const char *s);
\layout Standard

Devuelve el valor contenido en s convertido a tipo 
\family typewriter 
double
\family default 
, o 0 si s no puede ser convertido.
 En Turbo C, el prototipo de 
\family typewriter 
atof()
\family default 
 está en 
\family typewriter 
math.h
\family default 
 y en 
\family typewriter 
stdlib.h
\family default 
.
 En el ANSI C sólo se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
.
\layout Description


\size largest 
cabs (TC)
\layout Standard

Valor absoluto de un número complejo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double cabs (struct complex z);
\layout Standard

Devuelve el valor absoluto de z como un 
\family typewriter 
double
\family default 
.
 Ver cómo es 
\family typewriter 
struct complex
\family default 
 al final de esta ventana.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa imprime:
\protected_separator 
 valor absoluto de 2.00i 1.00j es 2.24 */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <math.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct complex z;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double val;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 z.x = 2.0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 z.y = 1.0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 val = cabs (z);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El valor absoluto de %.2lfi %.2lfj es %.2lf", z.x, z.y, val);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
ceil
\layout Standard

Redondea por arriba.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double ceil (double x);
\layout Standard

Devuelve el menor entero mayor o igual que x y lo representa como double.
 Por ejemplo, dado 1.02, 
\family typewriter 
ceil()
\family default 
 devuelve 2.0.
 Dado -1.02, 
\family typewriter 
ceil()
\family default 
 devuelve -1.
\layout Description


\size largest 
cos
\layout Standard

Coseno.
\layout Standard

Sintaxis
\layout Quotation


\family typewriter 
double cos (double x);
\layout Standard

Devuelve el coseno de x.
 El valor de x debe darse en radianes.
\layout Description


\size largest 
cosh
\layout Standard

Coseno hiperbólico.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double cosh (double x);
\layout Standard

Devuelve el coseno hiperbólico de x.
 El valor de x debe darse en radianes.
\layout Description


\size largest 
exp
\layout Standard

Calcula e elevando a la x-éxima potencia.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double exp (double x);
\layout Standard

Devuelve el número e elevado a la potencia de x.
\layout Description


\size largest 
fabs
\layout Standard

Valor absoluto de valor en punto flotante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double fabs (double x);
\layout Standard

Devuelve el valor absoluto de x.
\layout Description


\size largest 
floor
\layout Standard

Redondea por abajo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double floor (double x);
\layout Standard

Devuelve el mayor entero (representando en 
\family typewriter 
double
\family default 
) que no es mayor que 
\family typewriter 
num
\family default 
.
 Por ejemplo, dado 1.02, 
\family typewriter 
floor()
\family default 
 devuelve 1.0.
 Dado -1.02, 
\family typewriter 
floor()
\family default 
 devuelve -2.0.
\layout Description


\size largest 
fmod
\layout Standard

Calcula x módulo y, el resto de x/y.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double fmod (double x, double y);
\layout Standard

Devuelve el resto de la división entera x/y.
\layout Description


\size largest 
frexp
\layout Standard

Descompone un double en mantisa y exponente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double frexp (double x, int *exp);
\layout Standard

La función 
\family typewriter 
frexp()
\family default 
 descompone el número x en una mantisa de rango entre 0.5 y 1 y en un exponente
 entero tal que 
\family typewriter 
x = mantisa * (2 elevado a exp)
\family default 
.
 Se devuelve la mantisa, y el exponente se guarda en la variable apuntada
 por 
\family typewriter 
exp
\family default 
.
\layout Description


\size largest 
hypot (TC)
\layout Standard

Calcula hipotenusa de un triángulo rectángulo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double hypot (double x, double y);
\layout Standard

Devuelve hipotenusa de un triángulo rectángulo en el que los catetos son
 x e y.
\layout Description


\size largest 
labs
\layout Standard

Calcula el valor absoluto de un 
\family typewriter 
long
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
long int labs (long int x);
\layout Standard

Devuelve el valor absoluto de x, un 
\family typewriter 
long int
\family default 
.
 En Turbo C, el prototipo de 
\family typewriter 
labs()
\family default 
 está en 
\family typewriter 
math.h
\family default 
 y en 
\family typewriter 
stdlib.h
\family default 
.
 En el ANSI C sólo se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
.
\layout Description


\size largest 
ldexp
\layout Standard

Calcula el producto entre x y 2 elevado a 
\family typewriter 
exp
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double ldexp (double x, int exp);
\layout Standard

Devuelve 
\family typewriter 
x * pow (2, exp)
\family default 
.
 Si se produce desbordamiento, se devuelve 
\family typewriter 
HUGH_VAL
\family default 
.
\layout Description


\size largest 
log
\layout Standard

Función logaritmo neperiano.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double log (double x);
\layout Standard

Devuelve el logaritmo neperiano de x.
 Se produce error de dominio si x es negativo, y un error de rango si el
 argumento es 0.
\layout Description


\size largest 
log10
\layout Standard

Función logaritmo en base 10.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double log10 (double x);
\layout Standard

Devuelve el logaritmo en base 10 de x.
 Se produce un error de dominio si x es negativo, y un error de rango si
 el argumento es 0.
\layout Description


\size largest 
matherr (TC)
\layout Standard

Define un manejador de errores matemáticos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int matherr (struct exception *e);
\layout Standard

Esta función no puede ser llamada directamente por el usuario.
 Cuando ocurre un error matemático, el sistema llama automáticamente a esta
 función.
 El usuario puede suministrar su propia función 
\family typewriter 
matherr
\family default 
 para controlar los errores detectados por la librería matemática.
 La función 
\family typewriter 
matherr()
\family default 
 debe devolver un valor distinto de cero para indicar que se resuelve problema;
 en otro caso devueve 0.
 Ejemplo 1:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <math.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 log(-1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 pow(0, -2);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 exp(-1000);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sin(10e70);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 x = exp(1000);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("x = %lg", x);
\layout Quotation


\family typewriter 
}
\layout Description

Ejemplo
\protected_separator 
2:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <math.h>
\layout Quotation


\family typewriter 
int matherr(struct exception *e)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s (%lg [, %lg]): %s.
\backslash 
n", e->name, e->arg1, e->arg2,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 e->type == DOMAIN ? "Error de dominio en argumento" :
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 e->type == SING ? "Singularidad en argumento." :
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 e->type == OVERFLOW ? "Error de rango de overflow" :
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 e->type == UNDERFLOW ? "Error de rango de underflow" :
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 e->type == TLOSS ? "Pérdida total de significancia" :
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 e->type == PLOSS ? "Pérdida parcial de significancia" :
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "Error matemático");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 e->retval = e->type == OVERFLOW ? HUGE_VAL : 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 1;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 log(-1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 pow(0, -2);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 exp(-1000);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sin(10e70);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 x = exp(1000);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("x = %lg", x);
\layout Quotation


\family typewriter 
}
\layout Standard

La ejecución del programa del ejemplo 1 imprime lo siguiente (en la versión
 2.0 de Borland C++):
\layout Quotation


\family typewriter 
log: DOMAIN error
\layout Quotation


\family typewriter 
pow: DOMAIN error
\layout Quotation


\family typewriter 
exp: OVERFLOW error
\layout Quotation


\family typewriter 
x = 1.79769e+308
\layout Standard

La ejecución del programa del ejemplo 2 imprime lo siguiente (en cualquier
 versión de Turbo C):
\layout Quotation


\family typewriter 
log (-1 [, 0]): Error de dominio en argumento.
\layout Quotation


\family typewriter 
pow (0 [, -2]): Error de dominio en argumento.
\layout Quotation


\family typewriter 
exp (-1000, [, 0]): Error de rango de underflow.
\layout Quotation


\family typewriter 
sin (1e+71 [, 0]): Pérdida total de significancia.
\layout Quotation


\family typewriter 
exp (1000 [, 0]): Error de rango de overflow.
\layout Quotation


\family typewriter 
x = 1.79769e+308
\layout Standard

Ver al final cómo es 
\family typewriter 
struct
\family default 
 exception y el sinificado de los tipos enumerados y constantes simbólicas
 que aparecen en el segundo ejemplo.
\layout Description


\size largest 
modf
\layout Standard

Descompone en parte entera y parte fraccionaria.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double modf (double x, double *parte_entera);
\layout Standard

La función 
\family typewriter 
modf()
\family default 
 descompone x en sus partes entera y fraccionaria.
 Devuelve la parte fraccionaria y sitúa la parte entera en la variable apuntada
 por 
\family typewriter 
parte_entera
\family default 
.
\layout Description


\size largest 
poly (TC)
\layout Standard

Genera un polinomio de los argumentos de esta función.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double poly (double x, int grado, double coefs[]);
\layout Standard

Devuelve el valor de un polinomio en x, de grado n, con coeficientes coefs[0],
 ..., coefs[n].
 Por ejemplo: Si n = 4, el polinomio generado es
\layout Quotation


\family typewriter 
(coefs[4] * x^4) + (coefs[3] * x^3) +
\layout Quotation


\family typewriter 
(coefs[2] * x^2) + (coefs[1] * x^1) +
\layout Quotation


\family typewriter 
(coefs[0])
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <math.h>
\layout Quotation


\family typewriter 
/* polinomio:
\protected_separator 
 x**3 - 2x**2 + 5x - 1 */
\layout Quotation


\family typewriter 
int main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double array[] = { -1.0, 5.0, -2.0, 1.0 };
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double resultado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 resultado = poly (2.0, 3, array);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf ("El polinomio: x**3 - 2.0x**2 + 5x - 1 en 2.0 es %lg.
\backslash 
n", resultado);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
/* imprime:
\protected_separator 
 polinomio: x**3 - 2.0x**2 + 5x - 1 en 2.0 es 9.
 */
\layout Description


\size largest 
pow
\layout Standard

Función potencia, x elevado a y.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double pow (double base, double exponente);
\layout Standard

Devuelve base elevado a exponente.
 Se produce un error de dominio si base es 0 y exponente es menor o igual
 que 0.
 También puede ocurrir si base es negativo y exponente no es entero.
 Un desbordamiento produce un error de rango.
\layout Description


\size largest 
pow10 (TC)
\layout Standard

Función potencia, 10 elevado a p.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double pow10 (int p);
\layout Standard

Devuelve 10 elevado a p.
\layout Description


\size largest 
sin
\layout Standard

Función seno.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double sin (double x);
\layout Standard

Devuelve el seno de x.
 El valor de x debe darse en radianes.
\layout Description


\size largest 
sinh
\layout Standard

Función seno hiperbólico.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double sinh (double x);
\layout Standard

Devuelve el seno hiperbólico de x.
 El valor de x debe darse en radianes.
\layout Description


\size largest 
sqrt
\layout Standard

Calcula raíz cuadrada.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double sqrt (double x);
\layout Standard

Devuelve la raíz cuadrada de x.
 Si se llama con un número negativo se produce un error de dominio.
\layout Description


\size largest 
tan
\layout Standard

Tangente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double tan (double x);
\layout Standard

Devuelve la tangente de x.
 El valor de x debe darse en radianes.
\layout Description


\size largest 
tanh
\layout Standard

Tangente hiperbólica.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double tanh (double x);
\layout Standard

Devuelve la tangente hiperbólica de x.
\layout Title

Constantes, Tipos de Datos y Variables Globales
\layout Description


\size largest 
COMPLEX (struct)
\layout Standard

(TC) Representación de número complejo.
\layout Quotation


\family typewriter 
struct complex {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double
\protected_separator 
 x, y;
\layout Quotation


\family typewriter 
};
\layout Standard

Esta estructura es usada solamente por la función 
\family typewriter 
cabs()
\family default 
.
 Ver ejemplo de cómo usar esta estructura en la descripción de la función
 
\family typewriter 
cabs()
\family default 
.
\layout Description


\size largest 
EDOM (#define)
\layout Standard

Código de error para errores de dominios matemáticos, es decir, cuando el
 argumento de la función matemática está fuera del dominio.
 Este valor es asignado a errno cuando se produce un error de rango.
\layout Description


\size largest 
ERANGE (#define)
\layout Standard

Código de error para resultados fuera de rango.
 Este valor es asignado a 
\family typewriter 
errno
\family default 
 cuando se produce un error de rango.
\layout Description


\size largest 
EXCEPTION (struct)
\layout Standard

(TC) El formato de información de error para las rutinas matemáticas.
 
\layout Quotation


\family typewriter 
struct exception {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 type;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 
 *name;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double
\protected_separator 
 arg1, arg2, retval;
\layout Quotation


\family typewriter 
};
\layout Standard

Ver ejemplo en la descripción de la función 
\family typewriter 
matherr()
\family default 
 para saber cómo usar esta estructura.
\layout Description


\size largest 
HUGE_VAL (#define)
\layout Standard

Valor de overflow para las funciones matemáticas.
 Ver ejemplo en descripción de la función 
\family typewriter 
matherr()
\family default 
 para ver cómo se puede usar.
\layout Description


\size largest 
M_xxxx (#defines)
\layout Standard

(TC) Los valores constantes para funciones logarítmicas.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

M_E
\newline 
El valor de e
\newline 
M_LOG2E
\newline 
El valor de log(e)
\newline 
M_LOG10E
\newline 
El valor de log10(e)
\newline 
M_LN2
\newline 
El valor de log(2)
\newline 
M_LN10
\newline 
El valor de log(10)
\layout Description


\size largest 
PI (#defines)
\layout Standard

(TC) Constantes comunes de 
\begin_inset Formula \( \pi  \)
\end_inset 

.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
7 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

M_PI
\newline 

\begin_inset Formula \( \pi  \)
\end_inset 


\newline 
M_PI_2
\newline 
Un medio de 
\begin_inset Formula \( \pi  \)
\end_inset 

 (
\begin_inset Formula \( \pi  \)
\end_inset 

/2)
\newline 
M_PI_4
\newline 
Un cuarto de 
\begin_inset Formula \( \pi  \)
\end_inset 

 (
\begin_inset Formula \( \pi  \)
\end_inset 

/4)
\newline 
M_1_PI
\newline 
Uno divido por 
\begin_inset Formula \( \pi  \)
\end_inset 

 (1/
\begin_inset Formula \( \pi  \)
\end_inset 

)
\newline 
M_2_PI
\newline 
Dos divido por 
\begin_inset Formula \( \pi  \)
\end_inset 

 (2/
\begin_inset Formula \( \pi  \)
\end_inset 

)
\newline 
M_1_SQRTPI
\newline 
Raíz cuadrada de 
\begin_inset Formula \( \pi  \)
\end_inset 

 (
\begin_inset Formula \( \sqrt{\pi } \)
\end_inset 

)
\newline 
M_2_SQRTPI
\newline 
Mitad de la raíz cuadrada de 
\begin_inset Formula \( \pi  \)
\end_inset 

 ((
\begin_inset Formula \( \sqrt{\pi } \)
\end_inset 

)/2)
\layout Description


\size largest 
M_SQRTxx (#defines)
\layout Standard

(TC) Valores constantes para raíces cuadradas de 2.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
2 2 0 0 -1 -1 -1 -1
1 1 0 0
0 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""

M_SQRT2
\newline 
Raíz cuadrada de 2 (
\begin_inset Formula \( \sqrt{2} \)
\end_inset 

)
\newline 
M_SQRT_2
\newline 
Mitad de la raíz cuadrada de 2 (
\begin_inset Formula \( \sqrt{2} \)
\end_inset 

/2)
\layout Description


\size largest 
mexcep (enum)
\layout Standard

(TC) Estas constantes representan posibles errores matemáticos.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

DOMAIN
\newline 
Error de dominio en argumento
\newline 
SING
\newline 
Singularidad en argumento
\newline 
OVERFLOW
\newline 
Error de rango de overflow
\newline 
UNDERFLOW
\newline 
Error de rango de underflow
\newline 
TLOSS
\newline 
Pérdida total de significancia
\newline 
PLOSS
\newline 
Pérdida parcial de significancia
\layout Standard

Ver ejemplo en descripción de la función 
\family typewriter 
matherr
\family default 
 para saber cómo usar estas constantes.
\layout Section

Funciones de Pantalla y de Gráficos
\layout Standard

Las funciones de pantalla y de gráficos no están definidas por el estándar
 ANSI.
 Esto ocurre por una simple razón: son, por naturaleza, dependientes del
 entorno fijado y en gran parte no portables.
 Actualmente no hay una in terfaz gráfica que sea ampliamente aceptada,
 ni hay un conjunto universal de órdenes de control de pantalla.
 Sin embargo, estos tipos de funciones son de importancia primordial cuando
 se crea software que requiere control de pantalla de alta resolución y
 de calidad de gráficos para el mercado de software.
 Las funciones descritas en las dos siguientes partes pertenecen al Turbo
 C.
\layout Standard

Estas funciones se descomponen en dos grupos: aquellas que desempeñan funciones
 relacionadas con las pantallas de texto y aquellas que se refieren a los
 gráficos.
 Las funciones gráficos requieren la cabecera 
\family typewriter 
<graphics.h>
\family default 
 y las funciones de pantalla requieren la cabecera 
\family typewriter 
<conio.h>
\family default 
.
\layout Standard

Tanto en modo texto como en modo gráfico, la mayoría de las funciones trabajan
 con una ventana.
 Una ventana es un trozo rectangular de la pantalla que hace la función
 de pantalla completa.
 Por defecto, la ventana de trabajo es la pantalla completa; pero se puede
 cambiar con la función 
\family typewriter 
window()
\family default 
 en modo texto y con la función 
\family typewriter 
setviewport()
\family default 
 en modo gráfico.
 Por ejemplo, la sentencia 
\family typewriter 
gotoxy(2,2)
\family default 
 hace que el cursor se posicione en la posición (2,2) relativa a la ventana
 actual, si la ventana actual es la pantalla entera, entonces se posicionará
 en la posición (2,2) de la pantalla.
\layout Subsection

Fichero de Cabecera conio.h (TC) 
\layout Description


\size largest 
cgets
\layout Standard

Lee una cadena de consola.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *cgets (char *cad);
\layout Standard


\family typewriter 
cad[0]
\family default 
 debe contener la longitud máxima de la cadena a ser leída.
 A la vuelta, 
\family typewriter 
cad[1]
\family default 
 contiene el número de caracteres leídos realmente.
 La cadena empieza en 
\family typewriter 
cad[2]
\family default 
.
 La función devuelve 
\family typewriter 
&cad[2]
\family default 
.
\layout Description


\size largest 
clreol
\layout Standard

Borra hasta final de línea en ventana de texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void clreol (void);
\layout Description


\size largest 
clrscr
\layout Standard

Borra ventana de texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void clrscr(void);
\layout Description


\size largest 
cprintf
\layout Standard

Escribe salida formateada en la ventana de texto en la pantalla.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int cprintf(const char *formato [, argumento,...]);
\layout Standard

Devuelve el número de bytes escritos.
\layout Description


\size largest 
cputs
\layout Standard

Escribe una cadena en la ventana de texto en la pantalla.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int cputs (const char *cad);
\layout Standard

Devuelve el último carácter escrito.
\layout Description


\size largest 
cscanf
\layout Standard

Lee entrada formateada de consola.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int cscanf(char *formato [ , direccion, ...
 ]);
\layout Standard

Devuelve el número de campos procesados con éxito.
 Si una función intenta leer en final de fichero, el valor devuelto es 
\family typewriter 
EOF
\family default 
.
\layout Description


\size largest 
delline
\layout Standard

Borra línea en ventana de texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void delline (void);
\layout Description


\size largest 
getch
\protected_separator 
y
\protected_separator 
getche
\layout Standard

Lee carácter de consola, con eco a pantalla (
\family typewriter 
getche
\family default 
), o sin eco (
\family typewriter 
getch
\family default 
).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getch (void);
\layout Quotation


\family typewriter 
int getche (void);
\layout Standard

Ambas funciones devuelven el carácter leído.
 Los caracteres están disponibles inmediatamente (no hay buffer de líneas
 completas).
 Las teclas especiales tales como las teclas de función y las teclas de
 los cursores están representadas por una secuencia de dos caracteres: un
 carácter cero seguido por el código de exploración para la tecla presionada.
\layout Description


\size largest 
getpass
\layout Standard

Lee un password (palabra de paso).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *getpass(const char *prompt);
\layout Standard

El valor devuelto es un puntero a una cadena estática que es sobreescrita
 en cada llamada.
\layout Description


\size largest 
gettext
\layout Standard

Copia texto de pantalla en modo texto a memoria.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int gettext(int izq, int ar, int der, int ab, void *destino);
\layout Standard

Las coordenadas son absolutas, no son relativas a la ventana actual.
 La esquina superior izquierda es (1,1).
 Devuelve un valor distinto de cero si tiene éxito.
\layout Description


\size largest 
gettextinfo
\layout Standard

Obtiene información de vídeo en modo texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void gettextinfo(struct text_info *r);
\layout Standard

El resultado es devuelto en r.
\layout Description


\size largest 
gotoxy
\layout Standard

Posiciona cursor en ventana de texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void gotoxy(int x, int y);
\layout Description


\size largest 
highvideo
\layout Standard

Selecciona caracteres de texto en alta intensidad.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void highvideo(void);
\layout Standard

Afecta a subsecuentes llamadas a funciones de ventana de texto tales como
 
\family typewriter 
putch()
\family default 
 y 
\family typewriter 
cprintf()
\family default 
.
\layout Description


\size largest 
insline
\layout Standard

Inserta línea en blanco en ventana de texto en la posición actual del cursor.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void insline(void);
\layout Standard

Las líneas por debajo de la posición del cursor son subidas una línea hacia
 arria y la última línea se pierde.
\layout Description


\size largest 
kbhit
\layout Standard

Chequea para ver si se ha pulsado alguna tecla, es decir, para ver si hay
 alguna tecla disponible en el buffer de teclas.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int kbhit(void);
\layout Standard

Si una tecla está disponible, 
\family typewriter 
kbhi()
\family default 
 devuelve un entero distino de cero; si no es así, devuelve 0.
\layout Description


\size largest 
lowvideo
\layout Standard

Selecciona salida de caracteres en ventana de texto en baja intensidad.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void lowvideo(void);
\layout Standard

Afecta a la salida subsiguiente escritas con funcines de ventana de texto
 tales como 
\family typewriter 
putch()
\family default 
 y 
\family typewriter 
cprintf()
\family default 
.
\layout Description


\size largest 
movetext
\layout Standard

Copia texto en pantalla de un rectángulo a otro (en modo texto).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int movetext (int izq, int ar, int der, int ab, int izqdest, int ardest);
\layout Standard

Las coordenadas son relativas a la esquina superior izquierda de la pantalla
 (1,1).
 Devuelve un valor distinto de cero si la operación tuvo éxito.
\layout Description


\size largest 
normvideo
\layout Standard

Selecciona caracteres en intensidad normal.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void normvideo(void);
\layout Standard

Afecta a la salida subsecuente de funciones de ventana de texto tales como
 
\family typewriter 
putch()
\family default 
 y 
\family typewriter 
cprintf()
\family default 
.
\layout Description


\size largest 
putch
\layout Standard

Escribe un carácter en la ventana de texto sobre en la pantalla.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int putch(int ch);
\layout Standard

Usa el color y atributo de visualización actuales.
 Devuelve ch, el carácter visualizado.
 En caso de error, devuelve 
\family typewriter 
EOF
\family default 
.
\layout Description


\size largest 
puttext
\layout Standard

Copia texto de memoria a la pantalla.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int puttext (int izq, int ar, int der, int ab, void *fuente);
\layout Standard

Las coordenadas son coordenadas de pantalla absoluta, no relativas a la
 ventana actual.
 La esquina superior izquierda es (1,1).
 Devuelve un valor distinto de cero si tiene éxito.
\layout Description


\size largest 
_setcursortype
\layout Standard

Selecciona la apariencia del cursor.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void _setcursortype (int t_cur);
\layout Standard

El tipo de cursor 
\family typewriter 
t_cur
\family default 
 puede ser
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
3 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

_NOCURSOR
\newline 
el cursor no se ve
\newline 
_SOLIDCURSOR
\newline 
bloque sólido
\newline 
_NORMALCURSOR
\newline 
cursor compuesto de varias líneas inferiores
\layout Description


\size largest 
textattr
\layout Standard

Pone los atributos de texto para las funciones de ventana de texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void textattr(int newattr);
\layout Description


\size largest 
textbackground
\layout Standard

Selecciona nuevo color de fondo de los caracteres en modo texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void textbackground (int nuevocolor);
\layout Description


\size largest 
textcolor
\layout Standard

Selecciona nuevo color de texto de los caracteres en modo texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void textcolor(int nuevocolor);
\layout Description


\size largest 
textmode
\layout Standard

Cambia modo de pantalla (en modo texto).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void textmode(int nuevomodo);
\layout Standard

No sirve para cambiar de modo gráfico a modo texto.
\layout Description


\size largest 
ungetch
\layout Standard

Devuelve un carácter al teclado.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int ungetch (int ch);
\layout Standard

La próxima llamada a 
\family typewriter 
getch()
\family default 
 o cualquier otra función de entrada de consola devolverá 
\family typewriter 
ch
\family default 
.
 Devuelve el carácter ch si tiene éxito.
 Si devuelve 
\family typewriter 
EOF
\family default 
, indica que hubo un error.
\layout Description


\size largest 
wherex
\layout Standard

Devuelve posición horizontal del cursor dentro de la ventana de texto corriente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int wherex (void);
\layout Standard

Devuelve un entero en el rango de 1 a 80.
\layout Description


\size largest 
wherey
\layout Standard

Devuelve posición vertical del cursor dentro de la ventana de texto corriente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int wherey (void);
\layout Standard

Devuelve un entero en el rango de 1 a 25.
\layout Description


\size largest 
window
\layout Standard

Define ventana activa en modo texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void window (int izq, int ar, int der, int ab);
\layout Standard

La esquina superior izquierda de la pantalla es (1,1).
\layout Description


\size largest 
Constantes,
\protected_separator 
Tipos
\protected_separator 
de
\protected_separator 
Datos
\protected_separator 
y
\protected_separator 
Variables
\protected_separator 
Globales
\layout Description


\size largest 
COLORS (enum)
\layout Standard

Colores/atributos del vídeo CGA estándar.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
8 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

BLACK
\newline 
DARKGRAY
\newline 
BLUE
\newline 
LIGHTBLUE
\newline 
GREEN
\newline 
LIGHTGREEN
\newline 
CYAN
\newline 
LIGHTCYAN
\newline 
MAGENTA
\newline 
LIGHTMAGENTA
\newline 
BROWN
\newline 
YELLOW
\newline 
LIGHTGRAY
\newline 
WHITE
\newline 
RED
\newline 
LIGHTRED
\layout Description


\size largest 
BLINK
\layout Standard

Esta constante se le suma a color de fondo para visualizar caracteres parpadeant
es en modo texto.
\layout Description


\size largest 
directvideo (variable gloval)
\layout Standard

Controla salida de vídeo.
\layout Quotation


\family typewriter 
int directvideo;
\layout Standard

La variable global directvideo controla si la salida en consola de nuestro
 programa va directamente a la RAM de vídeo (directvideo = 1) o va vía llamadas
 a la ROM BIOS (directvideo = 0).
 El valor por defecto es directvideo = 1 (salida a consola va directamente
 a RAM de vídeo).
 Para usar directvideo = 1, el hardware de vídeo de nuestro sistema debe
 ser idéntico a los adaptadores de visualización de IBM.
 Poner directvideo = 0 permite que la salida a consola trabaje con cualquier
 sistema que sea compatible a nivel BIOS con IBM.
\layout Description


\size largest 
TEXT_INFO (struct)
\layout Standard

Información de ventana de texto corriente.
\layout Quotation


\family typewriter 
struct text_info
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 winleft,
\protected_separator 

\protected_separator 
 wintop;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 winright,
\protected_separator 
 winbottom;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 attribute, normattr;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 currmode;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 screenheight;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 screenwidth;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 curx, cury;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
text_modes (enum)
\layout Standard

Modos de vídeo estándar.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
4 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

LASTMODE
\newline 
BW80
\newline 
BW40
\newline 
C80
\newline 
C40
\newline 
C4350
\newline 
MONO
\newline 

\layout Description


\size largest 
_wscroll (variable global)
\layout Standard

Habilita o desahibilita el scroll en funciones de E/S de consola.
 
\layout Quotation


\family typewriter 
extern int_wscroll;
\layout Standard

La variable global 
\family typewriter 
_wscroll
\family default 
 es un flag (bandera) de E/S de consola.
 Podemos usarla para dibujar entre los ojos de una ventana sin provocar
 un scroll de la pantalla.
 El valor por defecto es 
\family typewriter 
_wscroll
\family default 
 = 1 (scroll permitido).
\layout Description

NOTA: En el ejemplo 3 de esta lección se muestra cómo se pueden utilizar
 estas funciones en un programa
\layout Subsection

Fichero de Cabecera graphics.h (TC) 
\layout Description


\size largest 
arc
\layout Standard

Dibuja un arco.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far arc(int x, int y, int ang_comienzo, int ang_final, int radio);
\layout Standard

(x,y) es el punto central; 
\family typewriter 
ang_comienzo
\family default 
 y 
\family typewriter 
ang_final
\family default 
 son los ángulos de comienzo y final en grados; radio es el radio.
\layout Description


\size largest 
bar
\layout Standard

Dibuja una barra.
\layout Description

Sintaxix
\layout Quotation


\family typewriter 
void far bar (int izq, int ar, int der, int ab);
\layout Description


\size largest 
bar3d
\layout Standard

Dibuja una barra en 3-D.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far bar3d (int izq, int ar, int der, int ab, int profundidad, int flag_de_e
ncima);
\layout Standard

Si 
\family typewriter 
flag_de_encima
\family default 
 es 0 no se dibuja la cara superior de la barra.
\layout Description


\size largest 
circle
\layout Standard

Dibuja un círculo en (x,y) con el radio dado.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far circle (int x, int y, int radio);
\layout Description


\size largest 
cleardevice
\layout Standard

Borra la pantalla gráfica.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far cleardevice (void);
\layout Description


\size largest 
clearviewport
\layout Standard

Borra el viewport corriente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far clearviewport (void);
\layout Description


\size largest 
closegraph
\layout Standard

Cierra el sistema gráfico.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far closegraph (void);
\layout Description


\size largest 
detectgraph
\layout Standard

Determina el controlador y el modo gráfico a usar chequeando el hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far detectgraph (int far *graphdriver, int far *graphmode);
\layout Description


\size largest 
drawpoly
\layout Standard

Dibuja un polígono.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far drawpoly (int numero_de_puntos, int far *puntos_de_poligono);
\layout Standard


\family typewriter 
*puntos_de_poligono
\family default 
 apunta a 
\family typewriter 
numero_de_puntos
\family default 
 pares de valores.
 Cada par da los valores de x e y para un punto del polígono.
\layout Description


\size largest 
ellipse
\layout Standard

Dibuja un arco elíptico.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far ellipse (int x, int y, int ang_comienzo, int ang_final, int radiox,
 int radioy);
\layout Standard

(x,y) es el punto central; 
\family typewriter 
ang_comienzo
\family default 
 y 
\family typewriter 
ang_final
\family default 
 son los ángulos de comienzo y final en grados; radiox y radioy son los
 radios horizontal y vertical.
\layout Description


\size largest 
fillellipse
\layout Standard

Dibuja y rellena una elipse.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far fillellipse (int x, int y, int radiox, int radioy);
\layout Standard

Usa (x,y) como el punto central y rellena el arco usando el patrón de relleno
 actual; radiox y radioy son los radios horizontal y vertical.
\layout Description


\size largest 
fillpoly
\layout Standard

Dibuja y rellena un polígono.
\layout Description

Sintaxis
\layout Standard


\family typewriter 
void far fillpoly(int numpoints, int far *polypoints[]);
\layout Standard


\family typewriter 
*puntos_de_poligono
\family default 
 apunta a 
\family typewriter 
numero_de_puntos
\family default 
 pares de valores.
 Cada par da los valores de x e y para un punto del polígono.
\layout Description


\size largest 
floodfill
\layout Standard

Rellena una región definida.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far floodfill (int x, int y, int color_borde);
\layout Standard

(x,y) es un punto que reside dentro de la región a rellenar.
\layout Description


\size largest 
getarccoords
\layout Standard

Obtiene las coordenadas de la última llamada a arc.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far getarccoords (struct arccoordstype far *coords_arc);
\layout Description


\size largest 
getaspectratio
\layout Standard

Obtiene la cuadratura para el modo gráfico corriente.
\layout Description

Sintaxiss
\layout Quotation


\family typewriter 
void far getaspectratio (int far *cuadx, int far *cuady);
\layout Standard

cuadx debería ser 10000.
 Usa cuadx=10000 cuando los pixels son cuadrados (VGA); <10000 para pixels
 altos.
\layout Description


\size largest 
getbkcolor
\layout Standard

Devuelve el color de fondo actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far getbkcolor (void);
\layout Description


\size largest 
getcolor
\layout Standard

Devuelve el color de dibujar actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far getcolor (void);
\layout Description


\size largest 
getdefaultpalette
\layout Standard

Devuelve la estructura de definición de paleta.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
struct palettetype *far getdefaultpalette (void);
\layout Standard

Devuelve un puntero a la estructura de paleta por defecto para el controlador
 actual inicializado mediante una llamada a 
\family typewriter 
initgraph()
\family default 
.
\layout Description


\size largest 
getdrivername
\layout Standard

Devuelve un puntero al nombre del controlador gráfico actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *far getdrivername(void);
\layout Standard

El puntero 
\family typewriter 
far
\family default 
 devuelto apunta a una cadena que identifica el controlador gráfico actual.
\layout Description


\size largest 
getfillpattern
\layout Standard

Copia un patrón de relleno definido por el usuario en memoria.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far getfillpattern (char far *patron);
\layout Description


\size largest 
getfillsettings
\layout Standard

Obtiene información acerca del patrón y color de relleno actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far getfillsettings (struct fillsettingstype far *fillinfo); 
\layout Description


\size largest 
getgraphmode
\layout Standard

Devuelve el modo gráfico actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far getgraphmode (void);
\layout Standard

Antes de llamar a 
\family typewriter 
getgraphmode()
\family default 
 se debe llamar a 
\family typewriter 
initgraph()
\family default 
 o 
\family typewriter 
setgraphmode()
\family default 
.
\layout Description


\size largest 
getimage
\layout Standard

Salva una imagen de la región especificada en memoria.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far getimage(int izq, int ar, int der, int ab, void far *bitmap);
\layout Description


\size largest 
getlinesettings
\layout Standard

Obtiene el estilo, patrón y grosor actual de línea.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far getlinesettings (struct linesettingstype far *infolinea);
\layout Description


\size largest 
getmaxcolor
\layout Standard

Devuelve el valor del color máximo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far getmaxcolor(void);
\layout Description


\size largest 
getmaxmode
\layout Standard

Devuelve el número de modo gráfico máximo para el controlador corriente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far getmaxmode (void);
\layout Standard

El modo mínimo es 0.
\layout Description


\size largest 
getmaxx
\protected_separator 
y
\protected_separator 
getmaxy
\layout Standard

Devuelve la coordenada x o y máxima de pantalla.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far getmaxx(void);
\layout Quotation


\family typewriter 
int far getmaxy(void);
\layout Description


\size largest 
getmodename
\layout Standard

Devuelve un puntero a una cadena que contiene el nombre del modo gráfico
 especificado.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char * far getmodename (int numero_de_modo);
\layout Standard

El puntero devuelto apunta al nombre (cadena) del modo especificado por
 numero_de_modo.
\layout Description


\size largest 
getmoderange
\layout Standard

Obtiene el rango de los modos para un controlador gráfico dado.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far getmoderange (int controlador_grafico, int far *mode_bajo, int
 far *mode_alto);
\layout Description


\size largest 
getpalette
\layout Standard

Obtiene información acerca de la paleta actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far getpalette (struct palettetype far *paleta);
\layout Description


\size largest 
getpalettesize
\layout Standard

Devuelve el número de entradas de la paleta.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far getpalettesize (void);
\layout Standard

Devuelve el número de entradas de la paleta permitidas para el modo de controlad
or gráfico actual.
\layout Description


\size largest 
getpixel
\layout Standard

Obtiene el color de un pixel especificado.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned far getpixel (int x, int y);
\layout Description


\size largest 
gettextsettings
\layout Standard

Obtiene información acerca de las características del texto gráfico actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far gettextsettings (struct textsettingstype far *texttypeinfo);
\layout Description


\size largest 
getviewsettings
\layout Standard

Obtiene información acerca del viewport actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far getviewsettings (struct viewporttype far *viewport);
\layout Description


\size largest 
getx
\layout Standard

Devuelve la coordenada x de la posición actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far getx (void);
\layout Standard

El valor es relativo al viewport.
\layout Description


\size largest 
gety
\layout Standard

Devuelve la coordenada y de la posición actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far gety (void);
\layout Standard

El valor es relativo al viewport.
\layout Description


\size largest 
graphdefaults
\layout Standard

Pone todos los valores gráficos a sus valores por defecto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far graphdefaults (void);
\layout Description


\size largest 
grapherrormsg
\layout Standard

Devuelve un puntero a una cadena con el mensaje de error.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *far grapherrormsg (int codigo_de_error);
\layout Standard

Devuelve un puntero a una cadena asociada con el valor devuelvto por 
\family typewriter 
graphresult()
\family default 
.
\layout Description


\size largest 
_graphfreemem
\layout Standard

Manejador de usuario para desasignar memoria gráfica.
\layout Quotation


\family typewriter 
void far _graphfreemem (void far *ptr, unsigned tamanio);
\layout Standard

Esta función es llamada por las rutinas que hay en la biblioteca gráfica
 para liberar memoria.
 Podemos controlar esta asignación de memoria suministrando nuestras propias
 funciones 
\family typewriter 
_graphgetmem()
\family default 
 y 
\family typewriter 
_graphfreemen()
\family default 
.
\layout Description


\size largest 
_graphgetmem
\layout Standard

Manejador de usuario para asignar memoria gráfica.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far * far _graphgetmem (unsigned tamanio);
\layout Standard

Esta función es llamada por las rutinas que hay en la biblioteca gráfica
 para asignar memoria.
 Podemos controlar esta asignación de memoria suministrando nuestras propias
 funciones 
\family typewriter 
_graphgetmem()
\family default 
 y 
\family typewriter 
_graphfreemen()
\family default 
.
\layout Description


\size largest 
graphresult
\layout Standard

Devuelve un código de error para la última operación gráfica que no tuvo
 éxito.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far graphresult (void);
\layout Standard

Devuelve el código de error para la última operación gráfica que informó
 de un error y pone el nivel de error a grOK.
\layout Description


\size largest 
imagesize
\layout Standard

Devuelve el número de bytes requeridos para almacenar una imagen.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned far imagesize (int izq, int ar, int der, int ab);
\layout Standard

Si el tamaño requerido para la imagen seleccionada es mayor o igual que
 64K - 1 bytes, 
\family typewriter 
imagesize()
\family default 
 devuelve 0xFFFF.
\layout Description


\size largest 
initgraph
\layout Standard

Inicializa el sistema gráfico.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far initgraph (int far *controlador_grafico, int far *modo_grafico,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char far *path_para_controlador);
\layout Description

NOTA: El parámetro 
\family typewriter 
paht_para_controlador
\family default 
 usa la sintaxis:
\layout Quotation


\family typewriter 
..
\backslash 

\backslash 
bgi
\backslash 

\backslash 
drivers
\layout Standard

donde
\layout Standard


\family typewriter 
bgi
\backslash 
drivers
\family default 
 es el nombre de directorio donde buscar los controladores, el parámetro
 está encerrado entre comillas, el path para los ficheros de controladores
 gráficos incluyen dos barras invertidas
\layout Description


\size largest 
installuserdriver
\layout Standard

Instala un nuevo controlador de dispositivo a la tabla de controladores
 de dispotivo BGI.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far installuserdriver (char far *nombre, int huge (*detect) (void));
\layout Standard

El parámetro nombre es el nombre del nuevo fichero de controlador de dispositivo
 (.BGI) y 
\family typewriter 
detect
\family default 
 es un puntero a una función de autodetección opcional que puede acompañar
 al nuevo controlador.
 Esta función de autodetección no tiene ningún parámetro y devuelve un valor
 entero.
\layout Description


\size largest 
installuserfont
\layout Standard

Carga un fichero de estilo de caracteres (
\family typewriter 
.CHR
\family default 
) que no está dentro del sistema BGI.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far installuserfont (char far *nombre);
\layout Standard

El parámetro nombre es el nombre del fichero que contiene las características
 del nuevo tipo de carácter en modo gráfico.
 Al mismo tiempo pueden ser instalados hasta 20 estilos de caracteres.
\layout Description


\size largest 
line
\layout Standard

Dibuja una línea entre dos puntos especificados.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far line (int x1, int y1, int x2, int y2);
\layout Standard

Dibuja una línea desde (x1,y1) hasta (x2,y2) usando el color, estilo de
 línea y grosor actuales.
\layout Description


\size largest 
linerel
\layout Standard

Dibuja una línea a una distancia relativa a la posición actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far linerel (int dx, int dy);
\layout Standard

Usa el color, estilo de línea y grosor actual.
\layout Description


\size largest 
lineto
\layout Standard

Dibuja una línea desde la posición actual hasta (x,y).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far lineto (int x, int y);
\layout Description


\size largest 
moverel
\layout Standard

Cambia la posición actual a una distancia relativa.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far moverel (int dx, int dy);
\layout Description


\size largest 
moveto
\layout Standard

Cambia la posición actual a (x,y).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far moveto (int x, int y);
\layout Description


\size largest 
outtext
\layout Standard

Visualiza una cadena en el viewport (modo gráfico).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far outtext (char far *cadena_de_texto);
\layout Description


\size largest 
outtextxy
\layout Standard

Visualiza una cadena en el lugar especificado (modo gráfico).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far outtextxy (int x, int y, char far *cadena_de_texto);
\layout Description


\size largest 
pieslice
\layout Standard

Dibuja y rellena un sector de círculo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far pieslice (int x, int y, int ang_comienzo, int ang_final, int radio);
\layout Description


\size largest 
putimage
\layout Standard

Escribe una imagen en la pantalla.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far putimage (int izq, int ar, void far *bitmap, int op);
\layout Standard


\family typewriter 
bitmap
\family default 
 apunta a un mapa de bits, normalmente creado por la función 
\family typewriter 
getimage()
\family default 
.
 El valor op especifica cómo se combina la imagen con el contenido actual
 del área en (izq,ar).
\layout Description


\size largest 
putpixel
\layout Standard

Escribe un pixel en el punto especificado.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far putpixel (int x, int y, int color);
\layout Description


\size largest 
rectangle
\layout Standard

Dibuja un rectángulo (modo gráfico).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far rectangle (int izq, int ar, int der, int ab);
\layout Standard

Una el estilo, grosor y color de línea actual.
\layout Description


\size largest 
registerbgidriver
\layout Standard

Registra controlador gráfico en el enlazado.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int registerbgidriver (void (*driver) (void));
\layout Standard

Informa al sistema gráfico que el controlador dispositivo apuntador por
 driver fue incluido en tiempo de enlazado.
\layout Description


\size largest 
registerbgifont
\layout Standard

Registra estilo de texto en el enlazado.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int registerbgifont (void (*font) (void));
\layout Standard

Informa al sistema gráfico que el estilo de texto apuntado por 
\family typewriter 
font
\family default 
 fue incluido en tiempo de enlazado.
\layout Description


\size largest 
restorecrtmode
\layout Standard

Restaura modo de pantalla previa a entrar al modo gráfico.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far restorecrtmode (void);
\layout Description


\size largest 
sector
\layout Standard

Dibuja y rellena un sector elíptico.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far sector (int x, int y, int ang_comienzo, int ang_final, int radiox,
 int radioy);
\layout Standard

x e y definen el punto central; 
\family typewriter 
ang_comienzo
\family default 
 y 
\family typewriter 
ang_final
\family default 
 definen los ángulos de comienzo y final; 
\family typewriter 
radiox
\family default 
 y 
\family typewriter 
radioy
\family default 
 son los radios horizontal y vertical.
 El sector es dibujado con el color activo y es rellenado con el color y
 patrón de relleno actual.
\layout Description


\size largest 
setactivepage
\layout Standard

Pone la página activa para la salida gráfica.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setactivepage (int pagina);
\layout Standard

Las salidas gráficas siguientes a la llamada a esta función irán a la página
 de visualización especificada.
 Esta página puede no ser la página visual que es la que actualmente está
 visualizada.
\layout Description


\size largest 
setallpalette
\layout Standard

Cambia los colores de todas las paletas.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setallpalette (struct palettetype far *paleta);
\layout Description


\size largest 
setaspectratio
\layout Standard

Pone la cuadratura gráfica.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setaspectratio (int cuadx, int cuady);
\layout Standard


\family typewriter 
cuadx
\family default 
 debería ser 10000.
 Usa 
\family typewriter 
cuadx=10000
\family default 
 cuando los pixels son cuadrados (VGA); 
\family typewriter 
<10000
\family default 
 para pixels altos.
\layout Description


\size largest 
setbkcolor
\layout Standard

Pone el color de fondo actual usando la paleta.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setbkcolor(int color);
\layout Description


\size largest 
setcolor
\layout Standard

Pone el color actual para dibujar.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setcolor (int color);
\layout Description


\size largest 
setfillpattern
\layout Standard

Selecciona un patrón de relleno definido por el usuario.
\layout Standard

Sintaxis
\layout Quotation


\family typewriter 
void far setfillpattern (char far *patron_usuario, int color);
\layout Standard

El parámetro 
\family typewriter 
patron_usuario
\family default 
 apunta a un área de 8 bytes donde se encuentra el patrón de bits 8 por
 8.
\layout Description


\size largest 
setfillstyle
\layout Standard

Pone el patrón y color de relleno.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setfillstyle (int patron, int color);
\layout Standard

El parámetro patron identifica un patrón predefinido.
 Para poner un patrón de relleno definido por el usuario, llamar a la función
 
\family typewriter 
setfillpattern()
\family default 
.
\layout Description


\size largest 
setgraphbufsize
\layout Standard

Cambia el tamaño del buffer gráfico interno.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned far setgraphbufsize (unsigned tambuf);
\layout Standard

Esta función debe ser llamada antes de llamar a la función 
\family typewriter 
initgraph()
\family default 
.
 Devuelve el tamaño previo del buffer interno.
\layout Description


\size largest 
setgraphmode
\layout Standard

Pone el sistema en modo gráfico y borra la pantalla.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setgraphmode (int modo);
\layout Description


\size largest 
setlinestyle
\layout Standard

Pone el estilo de línea, anchura y patrón actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setlinestyle (int estilo_de_linea, unsigned patron_usuario, int
 grosor);
\layout Standard

Pone el estilo y grosor para el dibujo de líneas en funciones gráficas.
\layout Description


\size largest 
setpalette
\layout Standard

Cambia un color de la paleta.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setpalette (int num_de_color, int color);
\layout Description


\size largest 
setrgbpalette
\layout Standard

Define colores para la tarjeta gráfica IBM-8514.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setrgbpalette (int numcolor, int rojo, int verde, int azul);
\layout Standard

El parámetro 
\family typewriter 
numcolor
\family default 
 es la entrada de la paleta a ser cargada (número entre 0 y 255).
 Los parámetros rojo, verde y azul definen los colores componentes.
 Sólo el byte menos significativo de estos valores es usado, y sólo sus
 6 bits más significativos son cargados en la paleta.
\layout Description


\size largest 
settextjustify
\layout Standard

Pone justificación de texto para modo gráfico.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far settextjustify (int horiz, int vert);
\layout Standard

Afecta a la salida de texto con 
\family typewriter 
outtext()
\family default 
, etc.
 El texto es justificado horizontalmente y verticalmente.
 Los valores para 
\family typewriter 
horiz
\family default 
 y 
\family typewriter 
vert
\family default 
 son los siguientes:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
7 4 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Param
\newline 
Nombre
\newline 
Val
\newline 
Cómo justificar
\series default 

\newline 
horiz
\newline 
LEFT_TEXT
\newline 
(0)
\newline 
izquierda
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 <
\newline 

\newline 
CENTER_TEXT
\newline 
(1)
\newline 
centrar texto <
\newline 

\newline 
RIGHT_TEXT
\newline 
(2)
\newline 
>
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 derecha
\newline 
vert
\newline 
BOTTOM_TEXT
\newline 
(0)
\newline 
de abajo a arriba
\newline 

\newline 
CENTER_TEXT
\newline 
(1)
\newline 
centrar texto
\newline 

\newline 
TOP_TEXT
\newline 
(2)
\newline 
de arriba a abajo
\layout Description


\size largest 
settextstyle
\layout Standard

Pone las características actuales del texto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far settextstyle (int estilo, int direccion, int tamanio_de_caracter);
\layout Description


\size largest 
setusercharsize
\layout Standard

Factor de amplificacion de los caracteres definidos por el usuario para
 los estilos de caracteres.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setusercharsize (int multx, int divx, int multy, int divy);
\layout Description


\size largest 
setviewport
\layout Standard

Pone el viewport actual para salida gráfica.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setviewport(int izq, int ar, int der, int ab, int clip);
\layout Description


\size largest 
setvisualpage
\layout Standard

Pone el número de página gráfica visual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setvisualpage (int pagina);
\layout Standard

Algunos adaptadores gráficos tienen más de una página de memoria.
 La página visual es la página que está actualmente visualizada en la pantalla.
 Las funciones gráficas escriben en la página activa, definida por 
\family typewriter 
setactivepage()
\family default 
.
\layout Description


\size largest 
setwritemode
\layout Standard

Pone el modo de escritura para el dibujo de líneas en modo gráfico.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far setwritemode (int modo);
\layout Standard

Si el modo es 0, las líneas sobreescriben el contenido actual de la pantalla.
 Si el modo es 1, una operación exclusive 
\family typewriter 
OR
\family default 
 (
\family typewriter 
XOR
\family default 
) es ejecutada entre los pixels de la línea y los puntos correspondientes
 sobre la pantalla.
\layout Description


\size largest 
textheight
\layout Standard

Devuelve la altura de una cadena en pixels.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far textheight (char far *cadena_con_texto);
\layout Standard

La función 
\family typewriter 
textwidth()
\family default 
 es útil para ser usadas con funciones gráficas tales como 
\family typewriter 
outtext()
\family default 
.
\layout Description


\size largest 
textwidth
\layout Standard

Devuelve la anchura de una cadena en pixels.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int far textwidth (char far *cadena_con_texto);
\layout Standard

La función 
\family typewriter 
textwidth()
\family default 
 es útil para ser usadas con funciones gráficas tales como 
\family typewriter 
outtext()
\family default 
.
\layout Description


\size largest 
Constantes,
\protected_separator 
Tipos
\protected_separator 
de
\protected_separator 
Datos
\protected_separator 
y
\protected_separator 
Variables
\protected_separator 
Globales
\layout Description


\size largest 
ARCCOORDSTYPE (struct)
\layout Standard

Usado por la función 
\family typewriter 
getarccords()
\family default 
 para obtener las coordenadas de la última llamada a 
\family typewriter 
arc()
\family default 
.
\layout Quotation


\family typewriter 
struct arccoordstype
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 x, y;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* punto central */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 xstart, ystart;
\protected_separator 
 /* posición inicial */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 xend, yend;
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* posición final */
\layout Quotation


\family typewriter 

\protected_separator 
 };
\layout Description


\size largest 
EGA_xxxx (#defines)
\layout Standard

Colores para las funciones 
\family typewriter 
setpalette()
\family default 
 y 
\family typewriter 
setallpalette()
\family default 
.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
8 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

EGA_BLACK
\newline 
EGA_DARKGRAY
\newline 
EGA_BLUE
\newline 
EGA_LIGHTBLUE
\newline 
EGA_GREEN
\newline 
EGA_LIGHTGREEN
\newline 
EGA_CYAN
\newline 
EGA_LIGHTCYAN
\newline 
EGA_RED
\newline 
EGA_LIGHTRED
\newline 
EGA_MAGENTA
\newline 
EGA_LIGHTMAGENTA
\newline 
EGA_BROWN
\newline 
EGA_YELLOW
\newline 
EGA_LIGHTGRAY
\newline 
EGA_WHITE
\layout Description


\size largest 
fill_patterns (enum)
\layout Standard

Patrones de relleno para las funciones 
\family typewriter 
getfillsettings()
\family default 
 y 
\family typewriter 
setfillstyle()
\family default 
.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
13 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

EMPTY_FILL
\newline 
Usa color de fondo
\newline 
SOLID_FILL
\newline 
Usa color de relleno sólido
\newline 
LINE_FILL
\newline 
Relleno con ---
\newline 
LTSLASH_FILL
\newline 
Relleno con ///
\newline 
SLASH_FILL
\newline 
Relleno con líneas gruesas ///
\newline 
BKSLASH_FILL
\newline 
Relleno con líneas gruesas 
\backslash 

\backslash 

\backslash 

\newline 
LTBKSLASH_FILL
\newline 
Relleno con 
\backslash 

\backslash 

\backslash 

\newline 
HATCH_FILL
\newline 
Sombreado claro
\newline 
XHATCH_FILL
\newline 
Sombreado espeso
\newline 
INTERLEAVE_FILL
\newline 
Lineas entrelazadas
\newline 
WIDE_DOT_FILL
\newline 
Puntos bastante espaciados
\newline 
CLOSE_DOT_FILL
\newline 
Puntos poco espaciados
\newline 
USER_FILL
\newline 
Relleno definido por el usuario
\layout Description


\size largest 
FILLSETTINGSTYPE (struct)
\layout Standard

Usado para obtener los valores de relleno actuales por la función 
\family typewriter 
getfillsettings()
\family default 
.
\layout Quotation


\family typewriter 
struct fillsettingstype
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 pattern;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 color;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
font_names (enum)
\layout Standard

Nombres de tipos de caracteres gráficos
\layout Quotation

DEFAULT_FONT
\layout Quotation

TRIPLEX_FONT
\layout Quotation

SMALL_FONT
\layout Quotation

SANS_SERIF_FONT
\layout Quotation

GOTHIC_FONT
\layout Description


\size largest 
graphics_drivers (enum)
\layout Standard

Controladores gráficos BGI.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

CGA
\newline 
MCGA
\newline 
EGA
\newline 
EGA64
\newline 
EGAMONO
\newline 
IBM8514
\newline 
HERCMONO
\newline 
ATT400
\newline 
VGA
\newline 
PC3270
\newline 
DETECT
\newline 
(Requiere autodetección)
\layout Description


\size largest 
graphics_errors (enum)
\layout Standard

Códigos de error devuelto por 
\family typewriter 
graphresult()
\family default 
.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
9 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

grOk
\newline 
grNoInitGraph
\newline 
grNotDetected
\newline 
grFileNotFound
\newline 
grInvalidDriver
\newline 
grNoLoadMem
\newline 
grNoScanMem
\newline 
grNoFloodMem
\newline 
grFontNotFound
\newline 
grNoFontMem
\newline 
grInvalidMode
\newline 
grError
\newline 
grIOerror
\newline 
grInvalidFont
\newline 
grInvalidFontNum
\newline 
grInvalidDeviceNum
\newline 
grInvalidVersion
\newline 

\layout Description


\size largest 
graphics_modes (enum)
\layout Standard

Modos gráficos para cada controlador BGI
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
29 3 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
2 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

CGAC0
\newline 
320 x 200
\newline 
paleta 0
\newline 
CGAC1
\newline 
320 x 200
\newline 
paleta 1
\newline 
CGAC2
\newline 
320 x 200
\newline 
paleta 2
\newline 
CGAC3
\newline 
320 x 200
\newline 
paleta 3
\newline 
CGAHI
\newline 
640 x 200
\newline 
2 colores
\newline 
MCGAC0
\newline 
320 x 200
\newline 
paleta 0
\newline 
MCGAC1
\newline 
320 x 200
\newline 
paleta 1
\newline 
MCGAC2
\newline 
320 x 200
\newline 
paleta 2
\newline 
MCGAC3
\newline 
320 x 200
\newline 
paleta 3
\newline 
MCGAMED
\newline 
640 x 200
\newline 
2 colores
\newline 
MCGAHI
\newline 
640 x 480
\newline 
2 colores
\newline 
EGALO
\newline 
640 x 200
\newline 
16 colores
\newline 
EGAHI
\newline 
640 x 350
\newline 
16 colores
\newline 
EGA64LO
\newline 
640 x 200
\newline 
16 colores
\newline 
EGA64HI
\newline 
640 x 350
\newline 
4 colores
\newline 
EGAMONOHI
\newline 
640 x 350
\newline 
2 colores
\newline 
HERCMONOHI
\newline 
720 x 348
\newline 
2 colores
\newline 
ATT400C0
\newline 
320 x 200
\newline 
paleta 0
\newline 
ATT400C1
\newline 
320 x 200
\newline 
paleta 1
\newline 
ATT400C2
\newline 
320 x 200
\newline 
paleta 2
\newline 
ATT400C3
\newline 
320 x 200
\newline 
paleta 3
\newline 
ATT400MED
\newline 
640 x 200
\newline 
2 colores
\newline 
ATT400HI
\newline 
640 x 400
\newline 
2 colores
\newline 
VGALO
\newline 
640 x 200
\newline 
16 colores
\newline 
VGAMED
\newline 
640 x 350
\newline 
16 colores
\newline 
VGAHI
\newline 
640 x 480
\newline 
16 colores
\newline 
PC3270HI
\newline 
720 x 350
\newline 
2 colores
\newline 
IBM8514LO
\newline 
640 x 480
\newline 
256 colores
\newline 
IBM8514HI
\newline 
1024 x 768
\newline 
256 colores
\layout Description


\size largest 
line_styles (enum)
\layout Standard

Estilos de línea para las funciones 
\family typewriter 
getlinesettings()
\family default 
 y 
\family typewriter 
setlinestyle()
\family default 
.
\layout Quotation

SOLID_LINE
\layout Quotation

DOTTED_LINE
\layout Quotation

CENTER_LINE
\layout Quotation

DASHED_LINE
\layout Quotation

USERBIT_LINE
\protected_separator 

\protected_separator 
 estilo de línea definido por el usuario
\layout Description


\size largest 
line_widths (enum)
\layout Standard

Anchuras de línea para las funciones 
\family typewriter 
getlinesettings()
\family default 
 y 
\family typewriter 
setlinestyle()
\family default 
.
\layout Quotation

NORM_WIDTH
\layout Quotation

THICK_WIDTH
\layout Description


\size largest 
MAXCOLORS (#define)
\layout Standard

Define el número máximo de entradas de colores para el campo array de colores
 en la estructura 
\family typewriter 
palettetype
\family default 
.
\layout Description


\size largest 
PALETTETYPE (struct)
\layout Standard

Contiene información de la paleta para el controlador gráfico actual.
 Esta estructura es usada por las funciones 
\family typewriter 
getpalette()
\family default 
, 
\family typewriter 
setpalette()
\family default 
 y 
\family typewriter 
setallpalette()
\family default 
.
\layout Quotation


\family typewriter 
struct palettetype
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 size;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 signed
\protected_separator 

\protected_separator 
 char
\protected_separator 
 colors[MAXCOLORS+1];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
POINTTYPE (struct)
\layout Standard

Coordenadas de un punto.
\layout Quotation


\family typewriter 
struct pointtype
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 x ;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 y ;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
putimage_ops (enum)
\layout Standard

Operadores para 
\family typewriter 
putimage()
\family default 
.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

COPY_PUT
\newline 
Copia
\newline 
XOR_PUT
\newline 
Exclusive OR
\newline 
OR_PUT
\newline 
Inclusive OR
\newline 
AND_PUT
\newline 
AND
\newline 
NOT_PUT
\newline 
Copia inversa de fuente
\layout Description


\size largest 
text_just (enum)
\layout Standard

Justificación horizontal y vertical para la función 
\family typewriter 
settextjustify()
\family default 
.
\layout Quotation

LEFT_TEXT
\layout Quotation

CENTER_TEXT
\layout Quotation

RIGHT_TEXT
\layout Quotation

BOTTOM_TEXT
\layout Quotation

TOP_TEXT
\layout Description


\size largest 
*_DIR (Dirección) (#defines)
\layout Standard

Dirección de salida gráfica.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
2 2 0 0 -1 -1 -1 -1
1 1 0 0
0 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

HORIZ_DIR
\newline 
De izquierda a derecha
\newline 
VERT_DIR
\newline 
De abajo hacia arriba
\layout Description


\size largest 
TEXTSETTINGSTYPE (struct)
\layout Standard

Usado para obtener los valores de texto actual por la función 
\family typewriter 
gettextsettings()
\family default 
.
\layout Quotation


\family typewriter 
struct textsettingstype
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 font;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 direction;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 charsize;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 horiz;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 vert;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
USER_CHAR_SIZE (#define)
\layout Standard

Tamaño de los caracteres definidos por el usuario (tamaño de caracteres
 = amplificación de caracteres en salida gráfica).
 Valores que puede tomar esta constante simbólica:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
4 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

1
\newline 
visualiza caracteres en caja de 8-por-8 en la pantalla
\newline 
2
\newline 
visualiza caracteres en caja de 16-por-16 en la pantalla
\newline 
...
\newline 

\newline 
10
\newline 
visualiza caracteres en caja de 80-por-80 en la pantalla
\layout Description


\size largest 
VIEWPORTTYPE (struct)
\layout Standard

Estructura usada para obtener información sobre el viewport corriente por
 la función 
\family typewriter 
getviewsettings()
\family default 
.
\layout Quotation


\family typewriter 
struct viewporttype
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 left;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 top;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 right;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 bottom;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 
 clip;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description

NOTA: En el ejemplo 4 de esta lección se muestra cómo se pueden utilizar
 la mayoría de estas funciones.
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 10-1
\series default 
.
 Realiza un programa que resuelva una ecuación de segundo grado.
 Para ello, deberá leer los coeficientes a, b y c desde teclado y mostrará
 las dos soluciones por pantalla.
 Se tendrá en cuenta todos los posibles casos de error, como por ejemplo,
 división por cero y radicando negativo.
\layout Itemize


\series bold 
Ejercicio 10-2
\series default 
.
 Realiza un programa para justificar un fichero de texto.
 Los datos de entrada serán los nombres de los ficheros de texto fuente
 y destino, así como dos números que representan columna izquierda y columna
 derecha.
 El fichero fuente ha de copiarse en el fichero destino pero con el texto
 justificado tanto a la izquierda como a la derecha.
 Por ejemplo, si el fichero de texto fuente contiene el párrafo anterior
 y lo queremos justificar entre las columnas 1 y 20, el fichero destino
 podría ser:
\layout Quotation


\family typewriter 
Realiza un
\protected_separator 
 programa
\layout Quotation


\family typewriter 
para
\protected_separator 
 justificar
\protected_separator 
 un
\layout Quotation


\family typewriter 
fichero
\protected_separator 
 de
\protected_separator 

\protected_separator 
 texto.
\layout Quotation


\family typewriter 
Los datos de entrada
\layout Quotation


\family typewriter 
serán los nombres de
\layout Quotation


\family typewriter 
los
\protected_separator 

\protected_separator 
 ficheros
\protected_separator 

\protected_separator 

\protected_separator 
 de
\layout Quotation


\family typewriter 
texto
\protected_separator 

\protected_separator 

\protected_separator 
 fuente
\protected_separator 

\protected_separator 

\protected_separator 
 y
\layout Quotation


\family typewriter 
destino,
\protected_separator 
 así
\protected_separator 

\protected_separator 
 como
\layout Quotation


\family typewriter 
dos
\protected_separator 

\protected_separator 
 números
\protected_separator 

\protected_separator 

\protected_separator 
 que
\layout Quotation


\family typewriter 
representan
\protected_separator 
 columna
\layout Quotation


\family typewriter 
izquierda y
\protected_separator 
 columna
\layout Quotation


\family typewriter 
derecha.
 El
\protected_separator 
 fichero
\layout Quotation


\family typewriter 
fuente
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ha
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 de
\layout Quotation


\family typewriter 
copiarse
\protected_separator 

\protected_separator 

\protected_separator 
 en
\protected_separator 

\protected_separator 

\protected_separator 
 el
\layout Quotation


\family typewriter 
fichero destino pero
\layout Quotation


\family typewriter 
con
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 el
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 texto
\layout Quotation


\family typewriter 
justificado tanto
\protected_separator 
 a
\layout Quotation


\family typewriter 
la izquierda como
\protected_separator 
 a
\layout Quotation


\family typewriter 
la derecha.
\layout Itemize


\series bold 
Ejercicio 10-3
\series default 
.
 Con las funciones proporcionadas por Turbo C en la librería de entrada
 y salida por consola, es relativamente fácil diseñar funciones para:
\layout Quotation

- dibujar ventanas con un determinado marco y colores
\layout Quotation

- hacer un menú de opciones, tanto horizontal como vertical
\layout Quotation

- realizar una ventana de visualización que visualice un fichero de texto
\layout Quotation

- editar una línea (un editor de más de una línea es mucho más complejo)
\layout Quote

Intenta realizar funciones como las que se acaba de mencionar para ser utilizada
s en futuros programas.
 De esta forma nos podemos crear nuestra propia biblioteca de funciones.
\layout Chapter

La Biblioteca de C (Parte II)
\layout Description

Primera
\protected_separator 
parte
\layout Itemize

Saltos no locales (
\family typewriter 
setjmp.h
\family default 
).
\layout Itemize

Envío y recepción de señales (
\family typewriter 
signal.h
\family default 
).
\layout Itemize

Asignación dinámica (
\family typewriter 
alloc.h
\family default 
 en Turbo C).
\layout Itemize

Funciones de proceso (
\family typewriter 
process.h
\family default 
).
\layout Description

Segunda
\protected_separator 
parte:
\layout Itemize

Funciones de directorio (
\family typewriter 
dir.h
\family default 
).
\layout Itemize

Funciones del DOS (interrupt y 
\family typewriter 
dos.h
\family default 
).
\layout Itemize

Funciones de la ROM BIOS (
\family typewriter 
bios.h
\family default 
).
\layout Section

Saltos no Locales
\layout Standard

En el fichero de cabecera 
\family typewriter 
<setjmp.h>
\family default 
 tenemos la información necesaria para poder realizar saltos no locales,
 es decir, saltos de una función a otra.
 Recordad que la instrucción goto del C sólo puede realizar un salto dentro
 de una función.
\layout Subsection

Fichero de Cabecera setjmp.h
\layout Standard

En esta biblioteca sólo hay dos funciones: 
\family typewriter 
longjmp()
\family default 
 y 
\family typewriter 
setjmp()
\family default 
.
\layout Description


\size largest 
longjmp
\layout Standard

Ejecuta goto (salto) no local.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void longjmp (jmp_buf jmpb, int valdev);
\layout Standard

La instrucción 
\family typewriter 
longjmp()
\family default 
 da lugar a que la ejecución del programa se retome en el punto en que se
 llamó por última vez a 
\family typewriter 
setjmp()
\family default 
.
 Estas dos funciones son la forma en que C permite saltar entre funciones.
 Tenga en cuenta que se necesita la cabecera 
\family typewriter 
setjmp.h
\family default 
.
 La función 
\family typewriter 
longjmp()
\family default 
 opera inicializando la pila ya descrita por 
\family typewriter 
jmpb
\family default 
, que debe haber sido activada en una llamada anterior a 
\family typewriter 
setjmp()
\family default 
.
 Esto da lugar a que la ejecución del programa se retome en la sentencia
 siguiente al 
\family typewriter 
setjmp()
\family default 
 que la llamó.
 En otras palabras, la computadora es haciéndole pensar que nunca dejó la
 función que llamó a 
\family typewriter 
setjmp()
\family default 
.
\layout Standard

El buffer 
\family typewriter 
jmpb
\family default 
 es de tipo 
\family typewriter 
jmp_buf
\family default 
, que está definido en la cabecera 
\family typewriter 
setjmp.h
\family default 
.
 El buffer debe haber sido activado a través de una llamada a 
\family typewriter 
setjmp()
\family default 
, anterior a la llamada a 
\family typewriter 
longjmp()
\family default 
.
 El valor de 
\family typewriter 
valdev
\family default 
 se transforma en el valor de vuelta de 
\family typewriter 
setjmp()
\family default 
 y puede preguntarse por él para determinar de dónde viene 
\family typewriter 
longjmp()
\family default 
.
 El único valor no permitido es 0, puesto que 
\family typewriter 
setjmp()
\family default 
 devuelve este valor cuando se le llama por primera vez.
 Es importante comprender que 
\family typewriter 
longjmp()
\family default 
 se debe llamar antes de que la función que llamó a 
\family typewriter 
setjmp()
\family default 
 vuelva.
 Si no, el resultado queda indefinido.
 (Realmente, la mayor parte de las veces el programa aborta.)
\layout Description


\size largest 
setjmp
\layout Standard

Almacena información de contexto para poder realizar saltos no locales.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int setjmp (jmp_buf jmpb);
\layout Standard

La función 
\family typewriter 
setjmp()
\family default 
 guarda el contenido de la pila del sistema en el buffer 
\family typewriter 
jmpb
\family default 
 para ser utilizado más tarde por 
\family typewriter 
longjmp()
\family default 
.
 La función 
\family typewriter 
setjmp()
\family default 
 devuelve 0 después de la llamada.
 Sin embargo, 
\family typewriter 
longjmp()
\family default 
 pasa un argumento a 
\family typewriter 
setjmp()
\family default 
 cuando se ejecuta, y es este valor (que siempre es disntino de cero) el
 valor de 
\family typewriter 
setjmp()
\family default 
 después de la llamada a 
\family typewriter 
longjmp()
\family default 
.
\layout Standard

A continuación se presenta la estructura del buffer para estas dos funciones
 en Turbo C, si utilizas otro compilador puedes ver cómo es en el tuyo visualiza
ndo el fichero 
\family typewriter 
setjmp.h
\family default 
.
 De todas formas no es de mucha utilidad saber cuál es el contenido de esta
 estructura.
\layout Description


\size largest 
jmp_buf (tipo)
\layout Standard

Un buffer de tipo 
\family typewriter 
jmp_buf
\family default 
 es usado para salvar y restaurar el estado de un programa en un determinado
 momento.
\layout Quotation


\family typewriter 
typedef struct
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 j_sp,
\protected_separator 

\protected_separator 
 j_ss,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 j_flag, j_cs;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 j_ip,
\protected_separator 

\protected_separator 
 j_bp;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 j_di,
\protected_separator 

\protected_separator 
 j_es;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 j_si,
\protected_separator 

\protected_separator 
 j_ds;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 } jmp_buf[1];
\layout Standard

Veamos un ejemplo bastante ilustrativo de cómo poder realizar un salto no
 local.
 Este ejemplo corresponde al primer ejemplo de esta lección, de este modo
 lo puedes ejecutar.
\layout Quotation


\family typewriter 
/* Este programa imprime */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <setjmp.h>
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
void func(jmp_buf);
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int valor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 jmp_buf jmpb;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf ("1 ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 valor = setjmp (jmpb);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(valor != 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("3 ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit(valor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("2 ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 func(jmpb);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("4 ");
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void func(jmp_buf jmpb)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 longjmp(jmpb, 1);
\layout Quotation


\family typewriter 
}
\layout Section

Envío y Recepción de Señales
\layout Standard

En el fichero de cabecera 
\family typewriter 
<signal.h>
\family default 
 hay declaradas dos funciones junto con algunas macros para poder enviar
 y recibir señales (interrupciones) en un programa en ejecución.
\layout Subsection

Fichero de Cabecera signal.h
\layout Standard

Este fichero sólo declara dos funciones: 
\family typewriter 
raise()
\family default 
 y 
\family typewriter 
signal()
\family default 
.
 Al ser estas dos funciones dependientes del sistema, el ANSI C no da una
 sintaxis general para estas funciones, sino que nos dice que la función
 
\family typewriter 
raise()
\family default 
 envía una señal a un programa en ejecución y la función 
\family typewriter 
signal()
\family default 
 define la función que se ejecutará en un programa cuando éste reciba una
 determinada señal; el ANSI C también define las macros: 
\family typewriter 
SIGABRT
\family default 
, 
\family typewriter 
SIGFPE
\family default 
, 
\family typewriter 
SIGILL
\family default 
, 
\family typewriter 
SIGINT
\family default 
, 
\family typewriter 
SIGSEGV
\family default 
, 
\family typewriter 
SIGTERM
\family default 
, 
\family typewriter 
SIG_DFL
\family default 
 y 
\family typewriter 
SEIG_IGN
\family default 
, todas ellas declaradas, junto con las funciones 
\family typewriter 
raise()
\family default 
 y 
\family typewriter 
signal()
\family default 
, en el fichero de cabecera 
\family typewriter 
signal.h
\family default 
.
 Una descripción completa de todas estas macros y funciones se realizará
 en las siguientes líneas para aquellos usuarios que tengan la opción de
 turbo a on.
\layout Description


\size largest 
raise
\layout Standard

Envía una señal software.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int raise (int sig);
\layout Standard

Un programa se puede enviar señales a sí mismo usando 
\family typewriter 
raise()
\family default 
.
 Esta función ejecuta el manejador instalado por 
\family typewriter 
signal()
\family default 
 para ese tipo de señal (o el manejador por defecto).
 Devuelve 0 si tiene éxito y un valor distinto de 0 en caso contrario.
\layout Description


\size largest 
signal
\layout Standard

Especifica las acciones a realizar asociadas a una señal.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void (* signal (int sig, void (*func) (int sig [,int subcode]))) (int);
\layout Standard

La función a la cual apunta 
\family typewriter 
func
\family default 
 será llamada cuando una señal de tipo 
\family typewriter 
sig
\family default 
 sea enviada.
 Las señales son enviadas cuando ocurre una condición de excepción o cuando
 es llamada la función 
\family typewriter 
raise()
\family default 
.
 El prototipo de esta función en el fichero 
\family typewriter 
signal.h
\family default 
 es:
\layout Quotation


\family typewriter 
void (* signal (int sig, void (*func) (/* int */))) (int);
\layout Standard

lo que quiere decir que los parámetros de 
\family typewriter 
func
\family default 
 están indefinidos pero que normalmente suele ser un 
\family typewriter 
int
\family default 
.
\newline 

\layout Description


\size largest 
SIG_xxx (#defines)
\layout Standard

Las funciones predefinidas para manejar las señales generados por la función
 
\family typewriter 
raise()
\family default 
 o por sucesos externos son:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
3 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

SIG_DFL
\newline 
Terminar el programa
\newline 
SIG_IGN
\newline 
Ninguna acción, ignorar señal
\newline 
SIG_ERR
\newline 
Devuelve código de error
\layout Description


\size largest 
SIGxxxx (#defines)
\layout Standard

Los tipos de señales usados por las funciones 
\family typewriter 
raise()
\family default 
 y 
\family typewriter 
signal()
\family default 
 son:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

SIGABRT
\newline 
Abortar
\newline 
SIGFPE
\newline 
Trampa de punto flotante
\newline 
SIGILL
\newline 
Instrucción ilegal
\newline 
SIGINT
\newline 
Interrupción
\newline 
SIGSEGV
\newline 
Violación de acceso a memoria
\newline 
SIGTERM
\newline 
Terminar
\layout Standard

Veamos a continuación tres ejemplos sobre las funciones y macros del fichero
 de cabecera 
\family typewriter 
signal.h
\family default 
.
 Ejemplo 1:
\layout Quotation


\family typewriter 
/* Este programa imprime */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <signal.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int x, y;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 x = 1; y = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("x/y: %d", x / y);
\layout Quotation


\family typewriter 
}
\layout Standard


\series bold 
Ejemplo 2
\series default 
:
\layout Quotation


\family typewriter 
/* Este programa imprime */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <signal.h>
\layout Quotation


\family typewriter 
void manejador(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Error de punto flotante.
\backslash 
n");
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int x, y;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 signal(SIGFPE, manejador);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 x = 1; y = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("x/y: %d", x / y);
\layout Quotation


\family typewriter 
}
\layout Standard


\series bold 
Ejemplo 3
\series default 
:
\layout Quotation


\family typewriter 
/* Este programa imprime */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <signal.h>
\layout Quotation


\family typewriter 
void manejador(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Error de punto flotante.
\backslash 
n");
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 signal(SIGFPE, manejador);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 raise(SIGFPE);
\layout Quotation


\family typewriter 
}
\layout Section

Asignación Dinámica
\layout Standard

Hay dos modos fundamentales por los que un programa en C puede guardar informaci
ón en la memoria central de la computadora.
 El primero utilizando variables globales y locales (incluyendo arrays y
 estructuras).
 El segundo modo por el que se puede guardar información es mediante el
 sistema de asignación dinámica de C.
 Por este método se asigna de la memoria libre tanto espacio como se necesite.
 La zona de memoria libre se encuentra entre el área de almacenamiento permanent
e del programa y la pila.
 (Para la familia de procesadores 8088, el montón se supone que está en
 el segmento de datos por defecto.)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 Sistema de memoria
\layout Quotation


\family typewriter 
+----------------------+ Alta
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 Pila
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 _
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
+----------------------+
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 _
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 
 Memoria libre
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 para
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 asignación
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
+----------------------+
\layout Quotation


\family typewriter 
|
\protected_separator 
 Variables globales
\protected_separator 
 |
\layout Quotation


\family typewriter 
+----------------------+
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 Programa
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
|
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 |
\layout Quotation


\family typewriter 
+----------------------+ Baja
\layout Standard

La pila crece hacia abajo a medida que se utiliza, de modo que la cantidad
 de memoria necesaria está determinada por cómo está diseñado el terminada
 por cómo está diseñado el programa.
 Por ejemplo, un programa con muchas funciones recursivas hace un mayor
 uso de la pila que uno que no tiene funciones recursivas ya que las variables
 locales se guardan en ella.
 La memoria necesaria para el programa y los datos globales se fija durante
 la ejecución del programa.
 Para satisfacer una petición de memoria, ésta se toma del área de memoria
 libre, que comienza justo después de las variables globales y crece en
 dirección hacia la pila.
 Como se puede adivinar, es posible, que, bajo ciertos casos extremos, la
 pila pueda invadir el montón.
\layout Standard

El núcleo del sistema de asignacion dinámica son las funciones 
\family typewriter 
malloc()
\family default 
 y 
\family typewriter 
free()
\family default 
 que se encuentran en la biblioteca estándar de C.
 Cada vez que se hace una petición de memoria mediante 
\family typewriter 
malloc()
\family default 
, se asigna una porción del resto de la memoria libre.
 Cada vez que se hace una llamada para liberar memoria mediante 
\family typewriter 
free()
\family default 
, la memoria se devuelve al sistema.
 La forma más común para implementar 
\family typewriter 
malloc()
\family default 
 y 
\family typewriter 
free()
\family default 
 es organizar la memoria libre en una lista enlazada.
 Sin embargo, el estándar ANSI propuesto afirma que el método de gestión
 de memoria depende de la implementación.
\layout Standard

El estándar ANSI propuesto especifica que la información de cabecera necesaria
 para el sistema de asignación dinámica se encuentra en 
\family typewriter 
stdlib.h
\family default 
 y sólo define cuatro funciones para el sistema de asignación dinámica:
 
\family typewriter 
calloc()
\family default 
, 
\family typewriter 
malloc()
\family default 
, 
\family typewriter 
free()
\family default 
 y 
\family typewriter 
realloc()
\family default 
.
 Sin embargo, los compiladores suelen suministrar más funciones bien en
 el fichero de cabecera 
\family typewriter 
malloc.h
\family default 
 o bien en el fichero 
\family typewriter 
alloc.h
\family default 
, dependiendo del compilador.
\layout Standard

Las funciones añadidas al ANSI C son necesarias para soportar eficientemente
 la arquitectura segmentada de la familia de procesadores 8088.
 Estas funciones no son válidas para compiladores diseñados para otros procesado
res como el 68000.
 Debido a la segmentación de memoria que presenta la familia de procesadores
 8088, se incorporan dos nuevos modificadores de tipo no estándares que
 generalmente son soportados por compiladores construidos para estos procesadore
s.
 Son 
\family typewriter 
near
\family default 
 y 
\family typewriter 
far
\family default 
, que se utilizan normalmente para crear punteros de otro tipo que el normalment
e utilizado por el modelo de memoria del compilador.
 La arquitectura de la familia de procesadores 8088 permite el acceso directo
 a 1 megabyte de RAM (o más con el 80386 o 80486), pero necesita utilizar
 un segmento y una dirección de desplazamiento.
\layout Standard

Esencialmente, es posible organizar la memoria de una computadora basada
 en el 8088 en uno de estos cuatro modelos (se presentan en orden creciente
 de tiempo de ejecución):
\layout List
\labelwidthstring 00.00.0000


\series bold 
Pequeño
\series default 
: Todo el código debe ajustarse a un segmento de 64K y todos los datos deben
 ajustarse a un segundo segmento de 64K.
 Todos los punteros son de 16 bits.
 Este modelo da lugar a la ejecución más rápida del programa.
\layout List
\labelwidthstring 00.00.0000


\series bold 
Medio
\series default 
: Todos los datos deben contenerse en un segmento de 64K, pero el código
 puede utilizar varios segmentos.
 Todos los punteros a datos son de 16 bits.
 Este modelo permite un rápido acceso a los datos, pero una ejecución del
 código lenta.
\layout List
\labelwidthstring 00.00.0000


\series bold 
Compacto
\series default 
: Todo el código debe ajustarse a un segmento de 64K, pero los datos pueden
 utilizar varios segmentos.
 Todos los punteros a datos son de 32 bits.
 La organización compacta de la memoria supone un acceso lento a los datos,
 pero una ejecución de código rápida.
\layout List
\labelwidthstring 00.00.0000


\series bold 
Grande
\series default 
: Código y datos utilizan varios segmentos.
 Todos los punteros son de 32 bits.
 Este modelo da lugar a la ejecución más lenta del programa.
\layout Standard

Como puedes imaginar, el acceso a memoria utilizando punteros de 16 bits
 es mucho más rápido que utilizando punteros de 32 bits.
 Sin embargo, los punteros de 32 bits son necesarios cuando el código, los
 datos, o ambos superan la barrera de los 64K.
 Una forma de evitar el uso de los punteros de 32 bits es permitir la creación
 de punteros de 16 ó 32 bits explícitamente por parte del programa, pasando
 por alto así el valor implícito.
 Típicamente, esto ocurre cuando un programa necesita gran cantidad de datos
 para una determinada operación.
\layout Standard

En este caso se crea un puntero 
\family typewriter 
far
\family default 
, y la memoria se asigna utilizando la versión no estándar de 
\family typewriter 
malloc()
\family default 
 que asigna memoria fuera del segmento de datos por defecto.
 De esta forma todos los demás accesos a memoria son rápidos, y el tiempo
 de ejecución no se incrementa tanto como si se hubiera utilizado un modelo
 grande.
 A la inversa también puede ocurrir.
 Un programa que utilice un modelo grande puede fijar un puntero 
\family typewriter 
near
\family default 
 a un fragmento de memoria frecuentemente accedido para incrementar el rendimien
to.
\layout Standard

En la siguiente ventana estudiaremos todas las funciones que están declaradas
 en el fichero de cabecera 
\family typewriter 
<alloc.h>
\family default 
 que se encuentra en Turbo C.
 Las funciones de asignación dinámica que define el ANSI C y que en el estándar
 están declaradas en el fichero de cabecera 
\family typewriter 
<stdlib.h>
\family default 
, en el caso de Turbo C, están declaradas también en el fichero 
\family typewriter 
alloc.h
\family default 
.
 Estas funciones son: 
\family typewriter 
calloc()
\family default 
, 
\family typewriter 
malloc()
\family default 
, 
\family typewriter 
free()
\family default 
 y 
\family typewriter 
realloc()
\family default 
.
\layout Subsection

Fichero de Cabecera alloc.h (TC) 
\layout Description


\size largest 
brk
\layout Standard

Cambia la asignación de espacio del segmento de datos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int brk (void *addr);
\layout Standard

Pone el tope del segmento de datos del programa en la localización de memoria
 apuntada por addr.
 Si la operación tiene éxito, 
\family typewriter 
brk()
\family default 
 devuelve el valor de 0.
 Si ocurre un fallo, devuelve el valor de -1 y da valor a 
\family typewriter 
errno
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa imprime (en mi sistema): */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *ptr;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Cambiando asignación con brk().
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 ptr = malloc(1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Antes de la llamada a brk(): %lu bytes libres.
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (long unsigned) coreleft());
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 brk(ptr+1000);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Después de la llamada a brk(): %lu bytes libres.
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (long unsigned) coreleft());
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
calloc
\layout Standard

Asigna memoria principal.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *calloc (size_t nelems, size_t tam);
\layout Standard

El prototipo de esta función también se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
.
 Asigna espacio para 
\family typewriter 
nelems
\family default 
 elementos de tam bytes cada uno y almacena cero en el área.
 Devuelve un puntero al nuevo bloque asignado o 
\family typewriter 
NULL
\family default 
 si no existe bastante espacio.
\layout Description


\size largest 
coreleft
\layout Standard

Devuelve la cantidad de memoria no usada.
\layout Description

Sintaxis
\layout Standard

Modelos tiny, small, y medium:
\layout Quotation


\family typewriter 
unsigned coreleft (void);
\layout Standard

Modelos compact, large, y huge:
\layout Quotation


\family typewriter 
unsigned long coreleft (void);
\layout Standard

El lector de este texto quizás se pregunte cómo puede declararse la misma
 función 
\family typewriter 
coreleft()
\family default 
 con dos tipos diferentes.
 Esto es muy fácil hacerlo utilizando las directivas de compilación condicional:
\layout Quotation


\family typewriter 
#if defined(__COMPACT__) || defined(__LARGE__) || defined(__HUGE__)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned long coreleft (void);
\layout Quotation


\family typewriter 
#else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned coreleft (void);
\layout Quotation


\family typewriter 
#endif
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa imprime (en mi sistema): */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("La diferencia entre el bloque asignado más alto
\backslash 
n"
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "y la cima del montón es: %lu bytes.
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (unsigned long) coreleft());
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
farcalloc
\layout Standard

Asigna memoria del montón 
\family typewriter 
far
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far *farcalloc (unsigned long nunids, unsigned long tamunid);
\layout Standard

Asigna espacio para nunids elementos de 
\family typewriter 
tamunid
\family default 
 cada uno.
 Devuelve un puntero al nuevo bloque asignado, o 
\family typewriter 
NULL
\family default 
 si no hay suficiente memoria para el nuevo bloque.
\layout Description


\size largest 
farcoreleft
\layout Standard

Devuelve la cantidad de memoria no usada en el montón 
\family typewriter 
far
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned long farcoreleft (void);
\layout Standard

Devuelve la cantidad total de espacio libre (en bytes) entre el bloque asignado
 más alto y el final de la memoria.
\layout Description


\size largest 
farfree
\layout Standard

Libera un bloque del montón 
\family typewriter 
far
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void farfree (void far *bloque);
\layout Description


\size largest 
farheapcheck
\layout Standard

Chequea y verifica el montón 
\family typewriter 
far
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int farheapcheck (void);
\layout Standard

La función 
\family typewriter 
farheapcheck()
\family default 
 camina a través del montón 
\family typewriter 
far
\family default 
 y examina cada bloque, chequeando sus punteros, tamaño, y otros atributos
 críticos.
 El valor devuelto es menor de cero si ocurre un error y mayor de cero si
 tiene éxito.
\layout Description


\size largest 
farheapcheckfree
\layout Standard

Chequea los bloques libres en el montón 
\family typewriter 
far
\family default 
 para un valor constante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int farheapcheckfree (unsigned int valorrelleno);
\layout Standard

El valor devuelto es menor de cero si ocurre un error y mayor de cero si
 tiene éxito.
\layout Description


\size largest 
farheapchecknode
\layout Standard

Chequea y verifica un nodo simple en el montón 
\family typewriter 
far
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int farheapchecknode (void *nodo);
\layout Standard

Si un nodo ha sido liberado y 
\family typewriter 
farheapchecknode()
\family default 
 es llamado con un puntero al bloque libre, 
\family typewriter 
farheapchecknode()
\family default 
 puede devolver 
\family typewriter 
_BADNODE
\family default 
 en vez del esperado 
\family typewriter 
_FREEENTRY
\family default 
.
 Esto sucede porque los bloques libres adyacentes en el montón son unidos,
 y el bloque en cuestión no existe.
\layout Description


\size largest 
farheapfillfree
\layout Standard

Rellena el bloque libre en el montón 
\family typewriter 
far
\family default 
 con un valor constante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int farheapfillfree (unsigned int valorrelleno);
\layout Standard

El valor devuelto es menor de cero si ocurre un error y es mayor de cero
 si tiene éxito.
\layout Description


\size largest 
farheapwalk
\layout Standard

Camina a través del montón 
\family typewriter 
far
\family default 
 nodo a nodo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int farheapwalk (struct farheapinfo *hi);
\layout Standard

La función 
\family typewriter 
farheapwalk()
\family default 
 asume que el montón es correcto.
 Usa 
\family typewriter 
farheapcheck()
\family default 
 para verificar el montón antes de usar 
\family typewriter 
farheapwalk()
\family default 
.
 
\family typewriter 
_HEAPOK
\family default 
 es devuelto con el último bloque en el montón.
 
\family typewriter 
_HEAPEND
\family default 
 será devuelto en la próxima llamada a 
\family typewriter 
farheapwalk()
\family default 
.
 La estructura 
\family typewriter 
farheapinfo
\family default 
 está definida del siguiente modo:
\layout Quotation


\family typewriter 
struct heapinfo
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 void huge *ptr;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned long size;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int in_use;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
farmalloc
\layout Standard

Asigma memoria del montón 
\family typewriter 
far
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far *farmalloc (unsigned long nbytes);
\layout Standard

Devuelve un puntero al nuevo bloque asignado, o 
\family typewriter 
NULL
\family default 
 si no existe suficiente espacio para el nuevo bloque.
\layout Description


\size largest 
farrealloc
\layout Standard

Ajusta bloque asignado en montón 
\family typewriter 
far
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void far *farrealloc (void far *viejobloque, unsigned long nbytes);
\layout Standard

Devuelve la dirección del bloque reasignado, o 
\family typewriter 
NULL
\family default 
 si falla.
 La nueva dirección puede ser diferente a la dirección original.
\layout Description


\size largest 
free
\layout Standard

Libera bloques asignados con 
\family typewriter 
malloc()
\family default 
 o 
\family typewriter 
calloc()
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void free (void *bloque);
\layout Description


\size largest 
heapcheck
\layout Standard

Chequea y verifica el montón.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int heapcheck (void);
\layout Standard

La función 
\family typewriter 
farheapcheck()
\family default 
 camina a través del montón y examina cada bloque, chequeando sus punteros,
 tamaño, y otros atributos críticos.
 El valor devuelto es menor de cero si ocurre un error y mayor de cero si
 tiene éxito.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa imprime: montón está corrompido.
 */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *p;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p = malloc(100);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 free(p+1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(heapcheck () < 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El montón está corrompido.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El montón es correcto.
\backslash 
n");
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
heapcheckfree
\layout Standard

Chequea los bloques libres en el montón para un valor constante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int heapcheckfree (unsigned int valorrelleno);
\layout Standard

El valor devuelto es menor de cero si ocurre un error y mayor de cero si
 tiene éxito.
\layout Description


\size largest 
heapchecknode
\layout Standard

Chequea y verifica un nodo simple en el montón.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int heapchecknode (void *nodo);
\layout Standard

Si un nodo ha sido liberado y 
\family typewriter 
heapchecknode()
\family default 
 es llamado con un puntero al bloque libre, 
\family typewriter 
heapchecknode()
\family default 
 puede devolver 
\family typewriter 
_BADNODE
\family default 
 en vez del esperado 
\family typewriter 
_FREEENTRY
\family default 
.
 Esto sucede porque los bloques libres adyacentes en el montón son unidos,
 y el bloque en cuestión no existe.
 El valor devuelto es menor de cero si ocurre un error y mayor de cero si
 tiene éxito.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa imprime (en mi sistema): 
\layout Quotation


\family typewriter 
Las macros _HEAPEMPTY, _HEAPCORRUPT, _BADNODE, _FREEENTRY y _USEDENTRY están
 declaradas en el fichero alloc.h */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
#define NUM_PTRS
\protected_separator 
 10
\layout Quotation


\family typewriter 
#define NUM_BYTES 16
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char * array[NUM_PTRS];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < NUM_PTRS; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 array [i] = malloc (NUM_BYTES);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < NUM_PTRS; i += 2)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 free(array [i]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < NUM_PTRS; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Nodo %2d ", i);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 switch(heapchecknode (array [i]))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 case _HEAPEMPTY:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Ningún montón.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 case _HEAPCORRUPT:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Montón corrupto.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 case _BADNODE:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Nodo malo.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 case _FREEENTRY:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Entrada libre.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 case _USEDENTRY:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Entrada usada.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 default:
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Código de vuelta desconocido.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
heapfillfree
\layout Standard

Rellena el bloque libre en el montón con un valor constante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int heapfillfree(unsigned int valorrelleno);
\layout Standard

El valor devuelto es menor de cero si ocurre un error y es mayor de cero
 si tiene éxito.
\layout Description


\size largest 
heapwalk
\layout Standard

Camina a través del montón nodo a nodo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int heapwalk (struct heapinfo *hi);
\layout Standard

La función 
\family typewriter 
heapwalk()
\family default 
 asume que el montón es correcto.
 Usa 
\family typewriter 
heapcheck()
\family default 
 para verificar el montón antes de usar 
\family typewriter 
heapwalk()
\family default 
.
 
\family typewriter 
_HEAPOK
\family default 
 es devuelto con el último bloque en el montón.
 
\family typewriter 
_HEAPEND
\family default 
 será devuelto en la próxima llamada a 
\family typewriter 
heapwalk()
\family default 
.
 La función 
\family typewriter 
heapwalk()
\family default 
 recibe un puntero a una estructura de tipo 
\family typewriter 
heapinfo
\family default 
 (declarada en 
\family typewriter 
alloc.h
\family default 
).
 Para la primera llamada a 
\family typewriter 
heapwalk()
\family default 
, pon el campo 
\family typewriter 
hi.ptr
\family default 
 a 
\family typewriter 
null
\family default 
.
 La función 
\family typewriter 
heapwalk()
\family default 
 devuelve en 
\family typewriter 
hi.ptr
\family default 
 la dirección del primer bloque.
 El campo 
\family typewriter 
hi.size
\family default 
 contiene el tamaño del bloque en bytes.
 El campo 
\family typewriter 
h.in_use
\family default 
 es un flag que se pone a 1 si el bloque está actualmente en uso.
 La estructura 
\family typewriter 
heapinfo
\family default 
 está definida del siguiente modo:
\layout Quotation


\family typewriter 
struct heapinfo
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 void *ptr;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int size;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int in_use;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
malloc
\layout Standard

Asigna memoria principal.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *malloc (size_t tam);
\layout Standard

El prototipo de esta función también se encuentra en el fichero de cabecera
 
\family typewriter 
stdlib.h
\family default 
.
 El parámetro 
\family typewriter 
tam
\family default 
 está en bytes.
 Devuelve un puntero al nuevo bloque asignado, o 
\family typewriter 
NULL
\family default 
 si no existe suficiente espacio para el nuevo bloque.
 Si 
\family typewriter 
tam == 0
\family default 
, devuelve 
\family typewriter 
NULL
\family default 
.
\layout Description


\size largest 
realloc
\layout Standard

Reasigna memoria principal.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *realloc (void *bloque, size_t tam);
\layout Standard

El prototipo de esta función también se encuentra en el fichero de cabecera
 
\family typewriter 
stdlib.h
\family default 
.
 Intenta achicar o expandir el bloque asignado previamente a 
\family typewriter 
tam
\family default 
 bytes.
 Devuelve la dirección del bloque reasignado, la cual puede ser diferente
 de la dirección original.
 Si el bloque no puede ser reasignado o 
\family typewriter 
tam == 0
\family default 
, 
\family typewriter 
reallo()
\family default 
 devuelve 
\family typewriter 
NULL
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa imprime (en mi sistema): */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *str;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 /* asigna memoria para string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 str = malloc (10);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* copia "Hola" en string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy(str, "Hola");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El string es %s
\backslash 
n
\protected_separator 
 Está en la dirección %p
\backslash 
n", str, str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 str = realloc(str, 20);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El string is %s
\backslash 
n
\protected_separator 
 Está en la nueva dirección %p
\backslash 
n", str, str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* libera memoria */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 free(str);
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
sbrk
\layout Standard

Cambia la asignación de espacio del segmento de datos.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *sbrk (int incr);
\layout Standard

Suma incr bytes al valor umbral.
 Si la operación tiene éxito, 
\family typewriter 
sbrk()
\family default 
 devuelve el viejo valor umbral.
 Si falla, devuelve -1 y le da valor a 
\family typewriter 
errno
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa imprime (en mi sistema): */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Cambiando asignación con sbrk().
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Antes de la llamada a sbrk(): %lu bytes libres.
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (unsigned long) coreleft());
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sbrk(1000);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Después de la llamada a sbrk(): %lu bytes libres.
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (unsigned long) coreleft());
\layout Quotation


\family typewriter 
}
\layout Section

Funciones de Proceso
\layout Standard

En el fichero 
\family typewriter 
<process.h>
\family default 
 de Turbo C nos encontramos la declaración de una serie de funciones que
 las podemos dividir en dos grupos: las que terminan el programa en ejecución
 para volver al sistema operativo y las que ejecutan otro programa.
\layout Subsection

Fichero de Cabecera process.h (TC) 
\layout Description


\size largest 
abort
\layout Standard

Termina un proceso anormalmente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void abort (void);
\layout Standard

El prototipo de esta función también se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
 
\layout Description


\size largest 
funciones exec...
\layout Standard

Las funciones 
\family typewriter 
exec
\family default 
...
 permiten a nuestro programa ejecutar otros programs (procesos hijos).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int execl(char *path, char *arg0, .., NULL);
\layout Quotation


\family typewriter 
int execle(char *path, char *arg0, .., NULL, char **env);
\layout Quotation


\family typewriter 
int execlp(char *path, char *arg0, ..);
\layout Quotation


\family typewriter 
int execlpe(char *path, char *arg0, .., NULL, char **env);
\layout Quotation


\family typewriter 
int execv(char *path, char *argv[]);
\layout Quotation


\family typewriter 
int execve(char *path, char *argv[], char **env);
\layout Quotation


\family typewriter 
int execvp(char *path, char *argv[]);
\layout Quotation


\family typewriter 
int execvpe(char *path, char *argv[], char **env);
\layout Standard

Cuando se hace una llamada 
\family typewriter 
exec
\family default 
..., el proceso hijo ocupa el lugar del proceso padre.
 Debe haber suficiente memoria disponible para cargar y ejecutar el proceso
 hijo.
 Usa 
\family typewriter 
execl()
\family default 
, 
\family typewriter 
execle()
\family default 
, 
\family typewriter 
execlp()
\family default 
 y 
\family typewriter 
execlpe()
\family default 
 cuando conoces todos los argumentos que tendrá el proceso hijo a ejecutar.
 Usa 
\family typewriter 
execv()
\family default 
, 
\family typewriter 
execve()
\family default 
, 
\family typewriter 
execvp()
\family default 
 y 
\family typewriter 
execvpe()
\family default 
 cuando no conoces a priori los argumentos que tendrá el proceso hijo a
 ejecutar.
 Las letras al final de cada función 
\family typewriter 
exec
\family default 
...
 identifica qué variación se va a usar:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Ltr
\newline 
Variación usada
\series default 

\newline 
p
\newline 
Busca el path del DOS para el proceso hijo
\newline 
l
\newline 
exec pasó una lista fija de argumentos
\newline 
v
\newline 
exec pasó una lista variable de argumentos
\newline 
e
\newline 
exec pasó un puntero al entorno, permitiendo alterar el entorno que tendrá
 el proceso hijo
\layout Standard

Si tiene éxito, las funciones 
\family typewriter 
exec
\family default 
 no devuelven nada.
 En caso de error, las funciones exec devuelven -1 y asigna a 
\family typewriter 
errno
\family default 
 el código de error.
\layout Description


\size largest 
exit
\layout Standard

Termina el programa.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void exit (int estado);
\layout Standard

Antes de terminar, la salida buffereada es volcada, los ficheros son cerrados
 y las funciones 
\family typewriter 
exit()
\family default 
 son llamadas.
 El prototipo de esta función también se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
.
\layout Description


\size largest 
_exit
\layout Standard

Termina programa.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void _exit (int estado);
\layout Standard

El prototipo de esta función también se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
.
\layout Description


\size largest 
spawn...
 funciones
\layout Standard

Las funciones 
\family typewriter 
spawn
\family default 
...
 permiten a nuestros programas ejecutar procesos hijos (otros programas)
 y devolver el control a nuestro programa cuando el proceso hijo finaliza.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int spawnl(int mode, char *path, char *arg0, ..., NULL);
\layout Quotation


\family typewriter 
int spawnle(int mode, char *path, char *arg0, ..., NULL, char *envp[]);
\layout Quotation


\family typewriter 
int spawnlp(int mode, char *path, char *arg0, ..., NULL);
\layout Quotation


\family typewriter 
int spawnlpe(int mode, char *path, char *arg0, ..., NULL, char *envp[]);
\layout Quotation


\family typewriter 
int spawnv(int mode, char *path, char *argv[]);
\layout Quotation


\family typewriter 
int spawnve(int mode, char *path, char *argv[], char *envp[]);
\layout Quotation


\family typewriter 
int spawnvp(int mode, char *path, char *argv[]);
\layout Quotation


\family typewriter 
int spawnvpe(int mode, char *path, char *argv[], char *envp[]);
\layout Standard

Usa 
\family typewriter 
spawnl()
\family default 
, 
\family typewriter 
spawnle()
\family default 
, 
\family typewriter 
spawnlp()
\family default 
 y 
\family typewriter 
spawnlpe()
\family default 
 cuando conoces todos los argumentos que tendrá el proceso hijo a ejecutar.
 Usa 
\family typewriter 
spawnv()
\family default 
, 
\family typewriter 
spawnve()
\family default 
, 
\family typewriter 
spawnvp()
\family default 
 y 
\family typewriter 
spawnvpe()
\family default 
 cuando no conoces a priori los argumentos que tendrá el proceso hijo a
 ejecutar.
 Las letras al final de cada función 
\family typewriter 
spawn
\family default 
...
 identifica qué variación se va a usar:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Ltr
\newline 
Variación usada
\series default 

\newline 
p
\newline 
Busca el path del DOS para el proceso hijo
\newline 
l
\newline 
spawn pasó una lista fija de argumentos
\newline 
v
\newline 
spawn pasó una lista variable de argumentos
\newline 
e
\newline 
spawn pasó un puntero al entorno, permitiendo alterar el entorno que tendrá
 el proceso hijo
\layout Standard

Si la ejecución tiene éxito, el valor devuelto es el estado de salida del
 proceso hijo (0 para terminación normal).
 Si el proceso no puede ser ejecutado, las funciones 
\family typewriter 
spawn
\family default 
...
 devolverán -1.
\layout Description


\size largest 
system
\layout Standard

Ejecuta un comando DOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int system (const char *comando);
\layout Standard

El prototipo de esta función también se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
.
 comando puede ejecutar un comando interno del DOS tales como 
\family typewriter 
DIR
\family default 
, un fichero de programa 
\family typewriter 
.COM
\family default 
 o 
\family typewriter 
.EXE
\family default 
, o un fichero batch 
\family typewriter 
.BAT
\family default 
.
 Devuelve 0 en caso de éxito, -1 en caso de error y se le asigna a errno
 uno de los siguientes valores: 
\family typewriter 
ENOENT
\family default 
, 
\family typewriter 
ENOMEM
\family default 
, 
\family typewriter 
E2BIG
\family default 
 o 
\family typewriter 
ENOEXEC
\family default 
.
 La función 
\family typewriter 
system()
\family default 
 también se encuentra declarada en los ficheros 
\family typewriter 
stdlib.h
\family default 
 y 
\family typewriter 
system.h
\family default 
.
 En el fichero 
\family typewriter 
system.h
\family default 
 sólo se encuentra el prototipo de la función 
\family typewriter 
system()
\family default 
.
\newline 

\layout Description


\size largest 
Constantes,
\protected_separator 
Tipos
\protected_separator 
de
\protected_separator 
Datos
\protected_separator 
y
\protected_separator 
Variables
\protected_separator 
Globales
\layout Description


\size largest 
P_xxxx (#defines)
\layout Standard

Modos usados por las funciones 
\family typewriter 
spawn
\family default 
.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
3 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

P_WAIT
\newline 
El proceso hijo se ejecuta separadamente, el proceso padre espera a la salida
 del hijo
\newline 
P_NOWAIT
\newline 
Los procesos hijo y padre se ejecutan concurrentemente.
 (No implementado.)
\newline 
P_OVERLAY
\newline 
El proceso hijo reemplaza al proceso padre de tal forma que el padre ya
 no existe
\layout Description


\size largest 
_psp (variable global)
\layout Standard

Dirección del segmento del PSP (Prefijo de Segmento de Programa) del programa.
\layout Quotation


\family typewriter 
extern unsigned int _psp;
\layout Standard

Esta variable también se encuentra declarada en los ficheros 
\family typewriter 
dos.h
\family default 
 y 
\family typewriter 
stdlib.h
\family default 
.
\layout Section

Funciones de Directorio
\layout Standard

En el fichero de cabecera 
\family typewriter 
<dir.h>
\family default 
 de Turbo C tenemos declaradas una serie de funciones relacionadas con los
 directorios.
\layout Subsection

Fichero de Cabecera dir.h (TC) 
\layout Description


\size largest 
chdir
\layout Standard

Cambia directorio actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int chdir (const char *path);
\layout Standard

Si la operación tiene éxito, 
\family typewriter 
chdir()
\family default 
 devuelve 0.
 En otro caso, devuelve -1 y asigna a 
\family typewriter 
errno
\family default 
 código de error.
\layout Description


\size largest 
findfirst
\protected_separator 
y
\protected_separator 
findnext
\layout Standard

Busca directorio de disco.
 Continúa búsqueda de 
\family typewriter 
findfirst()
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int findfirst (const char *nombrepath, struct ffblk *ffblk, int atributo);
\layout Quotation


\family typewriter 
int findnext (struct ffblk *ffblk);
\layout Standard

El path de especificación de fichero puede contener estos caracteres comodín:
\layout Quotation


\family typewriter 
?
\family default 
 (coincidencia de un carácter)
\layout Quotation


\family typewriter 
*
\family default 
 (coincidencia de una serie de caracteres)
\layout Standard

Devuelve 0 si tiene éxito; devuelve -1 si ocurre un error, y se le asigna
 a 
\family typewriter 
errno
\family default 
 el código de error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct ffblk ffblk;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int hecho;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Listado de directorio *.*
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 hecho = findfirst("*.*", &ffblk, 0);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 while(! hecho)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\protected_separator 
 %s
\backslash 
n", ffblk.ff_name);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 hecho = findnext(&ffblk);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
fnmerge
\layout Standard

Construye un path de sus partes componentes.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void fnmerge (char *path, const char *unidad, const char *dir,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 const char *nombre, const char *ext);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char s[MAXPATH];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char unidad[MAXDRIVE];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char dir[MAXDIR];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char fichero[MAXFILE];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char ext[MAXEXT];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 getcwd(s, MAXPATH); /* obtiene el directorio de trabajo actual */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(s[strlen(s)-1] != '
\backslash 

\backslash 
')
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 strcat(s,"
\backslash 

\backslash 
"); /* añade un carácter 
\backslash 
 al final */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fnsplit(s, unidad, dir, fichero, ext); /* descompone el string en elementos
 separados */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy(fichero, "DATOS");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy(ext," .TXT");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fnmerge(s, unidad, dir, fichero, ext); /*fusiona todas las componentes*/
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 puts(s); /* visualiza el string resultado */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
fnsplit
\layout Standard

Descompone un nombre de path en sus partes componentes.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fnsplit (const char *path, char *unidad, char *dir, char *nombre, char
 *ext);
\layout Standard

Devuelve un entero compuesto de cinco flags.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *s;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char unidad[MAXDRIVE];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char dir[MAXDIR];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char fichero[MAXFILE];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char ext[MAXEXT];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int flags;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 s = getenv("COMSPEC"); /* obtiene la especificación de nombre completa
 de command.com */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 flags = fnsplit(s, unidad, dir, fichero, ext);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Información del procesador de comando:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(flags & DRIVE)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
tunidad: %s
\backslash 
n", unidad);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(flags & DIRECTORY)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
tdirectorio: %s
\backslash 
n",dir);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(flags & FILENAME)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
tfichero: %s
\backslash 
n", fichero);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(flags & EXTENSION)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
textensión: %s
\backslash 
n", ext);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
getcurdir
\layout Standard

Obtiene directorio actual para la unidad especificada.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getcurdir (int unidad, char *directorio);
\layout Standard


\family typewriter 
unidad
\family default 
 es 0 para la unidad por defecto, 1 para A, 2 para B, etc.
 Devuelve 0 si tiene éxito y -1 si hay algún error.
\layout Description


\size largest 
getcwd
\layout Standard

Obtiene directorio de trabajo actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *getcwd (char *buffer, int longitud_buffer);
\layout Standard

Devuelve un puntero a buffer; en caso de error, devuelve 
\family typewriter 
NULL
\family default 
 y a 
\family typewriter 
errno
\family default 
 se le asigna el código de error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 char buffer [MAXPATH];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 getcwd , MAXPATH);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El directorio actual es: %s
\backslash 
n", buffer);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
getdisk
\layout Standard

Obtiene unidad actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getdisk (void);
\layout Standard

Devuelve la unidad actual.
 La unidad A es la 0.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int disco;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 disk = getdisk() + 'A';
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("La unidad actual es: %c
\backslash 
n", disco);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
mkdir
\layout Standard

Crea un directorio.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int mkdir (const char *path);
\layout Standard

Devuelve 0 si tiene éxito; -1 en caso de error y se asigna código de error
 a 
\family typewriter 
errno
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
#include <process.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int estado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 clrscr();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 estado = mkdir("asdfjklm");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 (! estado) ? (printf ("Directorio creado
\backslash 
n")) :
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (printf("No es posible crear directorio
\backslash 
n"));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 getch();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 system("dir");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 getch();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 estado = rmdir("asdfjklm");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 (! estado) ? (printf("Directorio borrado
\backslash 
n")) :
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (perror("No es posible borrar directorio
\backslash 
n"));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
mktemp
\layout Standard

Hace un nombre de fichero único.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *mktemp (char *nomfich);
\layout Standard

Reemplaza 
\family typewriter 
nomfich
\family default 
 por un nombre de fichero único y devuelve la dirección de 
\family typewriter 
nomfich
\family default 
; 
\family typewriter 
nomfich
\family default 
 debería ser una cadena terminada en nulo con 6 X's restantes.
 Por ejemplo, 
\family typewriter 
MIFICHXXXXXX
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 char *nombref = "TXXXXXX", *ptr;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 ptr = mktemp(nombref);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%s
\backslash 
n", ptr);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
rmdir
\layout Standard

Quita un directorio.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int rmdir (const char *path);
\layout Standard

Devuelve 0 si tiene éxito; en caso de error, devuelve -1 y en 
\family typewriter 
errno
\family default 
 se pone el código de error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
#include <process.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
#define NOMBREDIR "testdir.$$$"
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int estado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 estado = mkdir(NOMBREDIR);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(! estado)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Directorio creado
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("No es posible crear directorio
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit (1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 getch();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 system("dir/p");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 getch();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 estado = rmdir(NOMBREDIR);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(! estado)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nDirectorio borrado
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 perror("
\backslash 
nNo es posible borrar directorio
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit(1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
searchpath
\layout Standard

Busca el path del DOS para un determinado fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *searchpath (const char *fichero);
\layout Standard

Devuelve un puntero a una cadena con el nombre de path completo de fichero
 si tiene éxito; en otro caso, devuelve 
\family typewriter 
NULL
\family default 
.
 Esta cadena está en un área estática que es sobreescrita en cada nueva
 llamada.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *p;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* Busca TLINK.EXE y devuelve un puntero al path */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p = searchpath("TLINK.EXE");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Búsqueda para TLINK.EXE: %s
\backslash 
n", p);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* Busca un fichero no existente */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 p = searchpath("NOEXISTE.FIL");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Búsqueda para NOEXISTE.FIL: %s
\backslash 
n", p);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
setdisk
\layout Standard

Pone la unidad de disco actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int setdisk (int unidad);
\layout Standard

Los valores pra unidad son
\layout Quotation

0 = A
\layout Quotation

1 = B
\layout Quotation

2 = C
\layout Quotation

etc.
\layout Standard

Devuelve el número total de unidades disponibles.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int salvar, disco, discos;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* salvar unidad original */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 salvar = getdisk();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* imprimir número de unidades lógicas */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 discos = setdisk(salvar);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%d unidades lógicas en el sistema
\backslash 
n
\backslash 
n", discos);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* imprime las letras de unidad disponible */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Unidades disponibles:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(disco = 0; disco < 26; ++disco)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 setdisk(disco);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 if(disco == getdisk ())
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%c: unidad disponible
\backslash 
n", disco + 'a');
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 setdisk(salvar);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
Constantes,
\protected_separator 
Tipos
\protected_separator 
de
\protected_separator 
Datos
\protected_separator 
y
\protected_separator 
Variables
\protected_separator 
Globales
\layout Description


\size largest 
FFBLK (struct)
\layout Standard

Estructura de bloque de control de fichero del DOS.
\layout Quotation


\family typewriter 
struct ffblk
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ff_reserved[21];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ff_attrib;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 ff_ftime;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 ff_fdate;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ff_fsize;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ff_name[13];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
fnsplit (#defines)
\layout Standard

Definiciones de bits devueltos por 
\family typewriter 
fnsplit
\family default 
 para identificar qué partes de un nombre de fichero fueron encontrados
 durante la descomposición.
 
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

WILDCARDS
\newline 
El Path contiene caracteres comodín
\newline 
EXTENSION
\newline 
El path incluye extensión
\newline 
FILENAME
\newline 
El path incluye un nombre de fichero
\newline 
DIRECTORY
\newline 
El path incluye un subdirectorio
\newline 
DRIVE
\newline 
El path incluye una unidad
\layout Section

Funciones del DOS 
\layout Standard

En el fichero 
\family typewriter 
<dos.h>
\family default 
 de Turbo C nos encontramos información (declaración de funciones, constantes,
 tipos, estructuras, ...) relacionadas con el sistema operativo DOS.
 Todas estas funciones interactúan directamente con el sistema operativo
 y por ello no están definidas en el estándar ANSI.
 
\layout Description


\size largest 
Funciones
\protected_separator 
de
\protected_separator 
Interrupción
\layout Standard

Turbo C posee la palabra clave 
\family typewriter 
interrupt
\family default 
 que define una función como un manejador de interrupción.
 La sintaxis de esta palabra clave es:
\layout Quotation


\family typewriter 
interrupt definicion_de_funcion;
\layout Standard

Las funciones de interrupción son llamadas por el sistema cuando se genera
 alguna interrupción.
 En estas funciones se salvan todos los registros de la CPU y se terminan
 con la instrucción 
\family typewriter 
IRET
\family default 
.
 
\protected_separator 
 Cuando en Turbo C usemos la palabra clave 
\family typewriter 
interrupt
\family default 
 en un programa tenemos que desactivar el chequeo de pila y el uso de variables
 registros en el entorno.
\layout Subsection

Fichero de Cabecera dos.h (TC) 
\layout Description


\size largest 
absread
\protected_separator 
y
\protected_separator 
abswrite
\layout Standard


\family typewriter 
absread()
\family default 
 lee sectores absolutos de disco.
 
\family typewriter 
abswrite()
\family default 
 escribe sectores absolutos de disco.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int absread (int drive, int nsects, long lsect, void *buffer);
\layout Quotation


\family typewriter 
int abswrite (int drive, int nsects, long lsect, void *buffer);
\layout List
\labelwidthstring 00.00.0000

drive es 0 = A, 1 = B, 2 = C, etc.
\layout List
\labelwidthstring 00.00.0000

nsects es el número de sectores a leer/escribir
\layout List
\labelwidthstring 00.00.0000

lsect es el sector lógico de comienzo (0 es el primero)
\layout List
\labelwidthstring 00.00.0000

buffer es la dirección del área de datos
\layout Standard

64K es la cantidad de memoria más grande por llamada que puede ser leída
 o escrita.
 Devuelve 0 si tiene éxito; en caso de error, devuelve -1 y pone en 
\family typewriter 
errno
\family default 
 el número de error.
\layout Description


\size largest 
allocmem
\layout Standard

Asigna memoria.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int allocmem (unsigned tam, unsigned *pseg);
\layout Standard


\family typewriter 
tam
\family default 
 es el número de párrafos a asignar (un párrafo son 16 bytes).
 La dirección del segmento del área asignada es almacenada en 
\family typewriter 
*pseg
\family default 
; el offset = 0.
 Devuelve -1 si tiene éxito.
 En otro caso devuelve el tamaño del bloque disponible más grande, y pone
 en 
\family typewriter 
_doserrno
\family default 
 y 
\family typewriter 
errno
\family default 
 el código de error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned int tam, pseg;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int estado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 tam = 64; /* (64 x 16) = 1024 bytes */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 estado = allocmem(tam, &pseg);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(estado == -1)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Memoria asignada en segmeto: %X
\backslash 
n", pseg);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Asignación fallida: el número máximo de párrafos disponibles"
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 " es %u
\backslash 
n", estado);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
bdos
\layout Standard

Invoca una función del DOS, forma corta.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int bdos (int dosfun, unsigned dosdx, unsigned dosal);
\layout Standard

El valor devuelto de 
\family typewriter 
bdos()
\family default 
 es el valor que pone en AX la llamada del sistema.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
/* Obtiene unidad actual como 'A', 'B', ...
 */
\layout Quotation


\family typewriter 
char unidad_actual(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char unidadact;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* Obtiene disco actual como 0, 1, ...
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unidadact = bdos(0x19, 0, 0);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return('A' + unidadact);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("La unidad actual es %c:
\backslash 
n", unidad_actual());
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
bdosptr
\layout Standard

LLamada al sistema MS-DOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int bdosptr (int dosfun, void *argument, unsigned dosal);
\layout Standard

El valor devuelto por 
\family typewriter 
bdosptr()
\family default 
 es el valor de AX si tiene éxito, o -1 si falla.
 En caso de fallo, se pone 
\family typewriter 
errno
\family default 
 y 
\family typewriter 
_doserrno
\family default 
 con el código de error.
\layout Description


\size largest 
country
\layout Standard

Devuelve información dependiente del país.
\layout Description

Sintaxisd
\layout Quotation


\family typewriter 
struct COUNTRY *country (int xcode, struct COUNTRY *pc);
\layout Standard

Devuelve el puntero pc.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#define USA 0
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct COUNTRY pc;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 country (USA, &pc);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nco_date: %d", pc.co_date);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nco_curr: %s", pc.co_curr);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nco_thsep: %s", pc.co_thsep);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nco_desep: %s", pc.co_desep);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nco_dtsep: %s", pc.co_dtsep);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nco_tmsep: %s", pc.co_tmsep);
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
ctrlbrk
\layout Standard

Pone manejador de control-break.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void ctrlbrk (int (*manejador) (void));
\layout Standard

La función manejador devuelve 0 para abortar el programa actual; en otro
 caso el programa continuará la ejecución.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#define ABORT 0
\layout Quotation


\family typewriter 
int c_break(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Control-Break presionado.
\protected_separator 
 Abortando programa ...
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return(ABORT);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 ctrlbrk(c_break);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(;;)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Bucle...
 Presiona <Ctrl-Break> para salir:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
delay
\layout Standard

Suspende la ejecución durante un intervalo (en milisegundos).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void delay (unsigned milisegundos);
\layout Description


\size largest 
disable
\layout Standard

Inhabilita las interrupciones.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void disable (void);
\layout Standard

Inhabilita todas las interrupciones hardware excepto NMI.
\layout Description


\size largest 
dosexterr
\layout Standard

Obtiene información de error extendido del DOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int dosexterr (struct DOSERROR *eblkp);
\layout Standard

Rellena los campos de 
\family typewriter 
*eblkp
\family default 
 basados en la última llamada al DOS.
 Devuelve el valor del campo 
\family typewriter 
de_exterror
\family default 
 de la estructura.
\layout Description


\size largest 
dostounix
\layout Standard

Convierte fecha y hora a formato de hora UNIX.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
long dostounix (struct date *d, struct time *t);
\layout Standard

Devuelve la versión de UNIX de la hora actual: número de segundos desde
 el 1 de Enero de 1970 (GMT).
\layout Description


\size largest 
__emit__
\layout Standard

Inserta valores literales directamente dentro del código.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void __emit__ (argument, ...);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* Emite código que generará una int 5 (imprimir pantalla) */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 __emit__(0xcd,0x05);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
enable
\layout Standard

Habilita las interrupciones hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void enable (void);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
/* NOTA: Cuando se utilizan rutinas de servicio de interrupción, no se puede
 compilar el programa con la opción de testear el desbordamiento de pila
 puesta a on y obtener un programa ejecutable que opere correctamente */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
#define INTR 0X1C /* interrupción de pulso de reloj */
\layout Quotation


\family typewriter 
void interrupt(*viejo_manejador)(void);
\layout Quotation


\family typewriter 
int cont = 0;
\layout Quotation


\family typewriter 
void interrupt manejador(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* inhabilita las interrupciones mientras se maneja la interrupción */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 disable();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* incrementa el contador global */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 cont++;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* vuelve a habilitar las interrupciones al final del manejador */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 enable();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* llama a la rutina original */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 viejo_manejador();
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* salva el vector de interrupción original */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 viejo_manejador = getvect(INTR);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* instala el nuevo manejador de interrupción */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 setvect(INTR, manejador);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* bucle hasta mientras el contador no exceda de 20 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 while(cont < 20)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("cont es %d
\backslash 
n", cont);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* vuelve a poner el manejador de interrupción original */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 setvect(INTR, viejo_manejador);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
macros
\protected_separator 
FP_OFF,
\protected_separator 
FP_SEG
\protected_separator 
y
\protected_separator 
MK_FP
\layout Standard

Obtiene el offset de una direc.
 
\family typewriter 
far(FP_OFF)
\family default 
.
 Obtiene el segmento de una direc.
 
\family typewriter 
far(FP_SEG)
\family default 
.
 Hace un puntero 
\family typewriter 
far(MK_FP)
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned FP_OFF(void far *p);
\layout Quotation


\family typewriter 
unsigned FP_SEG(void far *p);
\layout Quotation


\family typewriter 
void far *MK_FP(unsigned seg, unsigned ofs);
\layout Description


\size largest 
freemem
\layout Standard

Libera un bloque de momoria del DOS asignado previamente con 
\family typewriter 
allocmen()
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int freemem (unsigned segx);
\layout Standard

Devuelve 0 si tiene éxito; -1 en caso de error y se pone en 
\family typewriter 
errno
\family default 
 el código de error.
\layout Description


\size largest 
geninterrupt
\layout Standard

Macro que genera una interrupción software.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void geninterrupt (int num_interrup);
\layout Standard

El estado de todos los registros después de la llamada es dependiente de
 la interrupción llamada.
 Cuidado: las interrupciones pueden dejar registros usados por Turbo C en
 un estado impredecible.
\layout Description


\size largest 
getcbrk
\layout Standard

Obtiene el estado de control-break.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getcbrk (void);
\layout Standard

Devuelve 0 si el chequeo de control-break está off y 1 si el chequeo está
 on.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if ())
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Cntrl-brk está on
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Cntrl-brk está off
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
getdate
\layout Standard

Obtiene fecha del sistema (DOS).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void getdate (struct date *pfecha);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct date d;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 getdate (&d);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El día actual es: %d
\backslash 
n", d.da_day);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El mes actual es: %d
\backslash 
n", d.da_mon);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El año actual es es: %d
\backslash 
n", d.da_year);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
getdfree
\layout Standard

Obtiene el espacio libre de disco.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void getdfree (unsigned char drive, struct dfree *dtable);
\layout Standard

En caso de error, a 
\family typewriter 
df_sclus
\family default 
 en la estructura dfree se la da el valor de 
\family typewriter 
0xFFFF
\family default 
.
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <dir.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct dfree free;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 long disponible;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int drive;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 drive = getdisk();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 getdfree(drive+1, &free);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(free.df_sclus == 0xFFFF)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Error en la llamada a getdfree()
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit (1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 disponible = (long) free.df_avail * (long) free.df_bsec * (long) free.df_sclus;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El drive %c tiene %ld bytes disponibles
\backslash 
n", 'A' + drive, disponible);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
getdta
\layout Standard

Obtiene la dirección de transferenciad de disco.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char far *getdta (void);
\layout Standard

Devuelve un puntero a la dirección de transferencia de disco actual.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char far *dta;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 dta = getdta();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("La dirección de transferencia del disco actual es: %Fp
\backslash 
n", dta);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
getfat
\layout Standard

Obtiene información sobre la tabla de asignación de ficheros para la unidad
 dada.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void getfat (unsigned char drive, struct fatinfo *dtable);
\layout Description


\size largest 
getfatd
\layout Standard

Obtiene información sobre la tabla de asignación de fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void getfatd (struct fatinfo *dtable);
\layout Description


\size largest 
getftime
\layout Standard

Obtiene la fecha y hora de un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getftime (int descriptor, struct ftime *pftime);
\layout Standard

Devuelve 0 en caso de éxito, y -1 en caso de error y se pone en 
\family typewriter 
errno
\family default 
 el código de error.
\layout Description


\size largest 
getpsp
\layout Standard

Obtiene el prefijo de segmento de programa.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned getpsp (void);
\layout Standard


\family typewriter 
getpsp()
\family default 
 sólo puede ser llamada usando DOS 3.0 o superior.
\layout Description


\size largest 
gettime
\layout Standard

Obtiene la hora del sistema.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void gettime (struct time *phora);
\layout Standard

Ejemplo
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct time t;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 gettime(&t);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("La hora actual es: %2d:%02d:%02d.%02d
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 t.ti_hour, t.ti_min, t.ti_sec, t.ti_hund);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
getvect
\layout Standard

Obtiene un vector de interrupción.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void interrupt (*getvect (int num_interrupcion)) ();
\layout Standard

Devuelve el valor de 4 bytes almacenado en el vector de interrupción nombrado
 por 
\family typewriter 
num_interrupcion
\family default 
.
\layout Description


\size largest 
getverify
\layout Standard

Obtiene el estado de verificacion.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int getverify (void);
\layout Standard

Devuelve 0 si el estado de verificación está off, y 1 si el estado de verificaci
ón está on.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(getverify ())
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El estado de verificacion del DOS está on
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El estado de verificación del DOS está off
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
harderr
\layout Standard

Establece un manejador de error hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void harderr (int (*manejador) ());
\layout Standard

La función apuntada por manejador será llamada cuando el DOS encuentre un
 error crítico (INT 0x24).
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa atrapa los errores de disco y pregunta al usuario la acción
 a realizar.
 Intenta ejecutarlo con ningún disco en la unidad A: para invocar sus funciones.
 */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#define IGNORAR
\protected_separator 

\protected_separator 

\protected_separator 
 0
\layout Quotation


\family typewriter 
#define REINTENTAR 1
\layout Quotation


\family typewriter 
#define ABORTAR
\protected_separator 

\protected_separator 

\protected_separator 
 2
\layout Quotation


\family typewriter 
int buf[500];
\layout Quotation


\family typewriter 
/* define los mensajes de error para los problemas de disco */
\layout Quotation


\family typewriter 
static char *err_msj[] =
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "protección contra escritura",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "unidad desconocida",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "unidad no preparada",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "comando desconodido",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "error de datos (CRC)",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "respuesta mala",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "error de búsqueda",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "tipo de medio desconocido",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "sector no encontrado",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "impresora sin papel",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "fallo de escritura",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "fallo de lectura",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "fallo general",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "reservado",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "reservado",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "cambio de disco inválido"
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Quotation


\family typewriter 
int error(char *msj)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int valdev;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 cputs(msj);
\layout Quotation


\family typewriter 

\protected_separator 
 /* pide al usuario que presione una tecla para abortar, reintentar o ignorar
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 while(1)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 valdev = getch();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 if(valdev == 'a' || valdev == 'A')
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 valdev = ABORTAR;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 if(valdev == 'r' || valdev == 'R')
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 valdev = REINTENTAR;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 if(valdev == 'i' || valdev == 'I')
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 valdev = IGNORAR;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 break;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return(valdev);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
/* pragma warn -par reduce los warnings (avisos) que ocurren debidos al
 no uso de los parámetros errval, bp y si en manejador() */
\layout Quotation


\family typewriter 
#pragma warn -par
\layout Quotation


\family typewriter 
int manejador(int errval, int ax, int bp, int si)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 static char msj[80];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned di;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int unidad;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int numerror;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 di= _DI;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /*si no es un error de disco entonces fue otro problema de dispositivo*/
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(ax < 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* informa del error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 error("Error de dispositivo");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 /* y vuelve al programa directamente requiriendo abortar */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 hardretn(ABORTAR);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* en otro caso fue un error de disco */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unidad = ax & 0x00FF;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 numerror = di & 0x00FF;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* informa del error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 sprintf(msj, "Error: %s en unidad %c
\backslash 
r
\backslash 
nA)bortar, R)eintentar, "
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "I)gnorar: ", err_msj[numerror], 'A' + unidad);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* vuelve al programa vía interrupción dos 0x23 con abortar, reintentar
 o ignorar según elige usuario */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 hardresume(error (msj));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return ABORTAR;
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
#pragma warn +par
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* instala nuestro manejador de la interrupción de problemas hardware */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 harderr(manejador);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 clrscr();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Asegúrate que no hay ningún disco en unidad A:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Presiona una tecla ...
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 getch ();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Intentando acceder a la unidad A:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("fopen() devolvió %p
\backslash 
n", fopen ("A:temp.dat", "w"));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
hardresume
\layout Standard

Función de manejador de error hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void hardresume (int axret);
\layout Standard

El manejador de error establecido por 
\family typewriter 
harderr()
\family default 
 puede devolver el control de la ejecución a la rutina del COS que provocó
 el error crítico vía esta función.
 El valor en 
\family typewriter 
axret
\family default 
 es devuelto al DOS.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
4 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Valor devuelto
\newline 
Significado
\series default 

\newline 
0
\newline 
ignorar
\newline 
1
\newline 
reintentar
\newline 
2
\newline 
abortar
\layout Standard

Ver ejemplo en la función 
\family typewriter 
harderr()
\family default 
.
\layout Description


\size largest 
hardretn
\layout Standard

Manejador de error hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void hardretn (int retn);
\layout Standard

El manejador de error establecido por 
\family typewriter 
harderr
\family default 
 puede volver directamente al programa de aplicación llamando a 
\family typewriter 
hardretn()
\family default 
.
 El valor en 
\family typewriter 
retn
\family default 
 es devuelto al programa de usuario en lugar del valor normal devuelto de
 la función DOS que generó el error crítico.
 Ver ejemplo de función 
\family typewriter 
harderr()
\family default 
.
\layout Description


\size largest 
inp
\layout Standard

Macro que lee un byte de un puerto hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int inp(int portid);
\layout Description


\size largest 
inportb
\layout Standard

Lee un byte de un puerto hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned charinportb(int portid);
\layout Description


\size largest 
int86
\layout Standard

Interrupción de software 8086.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int int86(int intno, union REGS *inregs, union REGS *outregs);
\layout Standard

Esta función carga los registros de la CPU con los valores almacenados en
 
\family typewriter 
inregs
\family default 
, ejecuta la interrupción 
\family typewriter 
intno
\family default 
, y almacena los valores resultados de los registros de la CPU en 
\family typewriter 
outregs
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#define VIDEO 0x10
\layout Quotation


\family typewriter 
void movetoxy(int x, int y)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 union REGS regs;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 regs.h.ah = 2;
\protected_separator 
 /* pone la posición del cursor */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 regs.h.dh = y;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 regs.h.dl = x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 regs.h.bh = 0;
\protected_separator 
 /* página de vídeo 0 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int86(VIDEO, &regs, &regs);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 clrscr();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 movetoxy(35, 10);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Hola");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
int86x
\layout Standard

Interfase de interrupción software 8086.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int int86x(int intno, union REGS *inregs, union REGS *outregs, struct SREGS
 *segregs);
\layout Standard

Esta función carga los registros de la CPU con los valores almacenados en
 
\family typewriter 
inregs
\family default 
 y 
\family typewriter 
segregs
\family default 
, ejecuta la interrupción 
\family typewriter 
intno
\family default 
, y almacena los valores resultados de los registros de la CPU en 
\family typewriter 
outregs
\family default 
 y 
\family typewriter 
segregs
\family default 
.
\layout Description


\size largest 
intdos
\layout Standard

Interfase de interrupción DOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int intdos (union REGS *inregs, union REGS *outregs);
\layout Standard

Esta función carga los registros de la CPU con los valores almacenados en
 
\family typewriter 
inregs
\family default 
, ejecuta la interrupción DOS (int 33 o 0x21), y almacena los valores resultados
 de los registros de la CPU en 
\family typewriter 
outregs
\family default 
.
\layout Description


\size largest 
intdosx
\layout Standard

Interfase de interrupción DOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int intdosx (union REGS *inregs, union REGS *outregs, struct SREGS *segregs);
\layout Standard

Esta función carga los registros de la CPU con los valores almacenados en
 
\family typewriter 
inregs
\family default 
 y 
\family typewriter 
segregs
\family default 
, ejecuta la interrupción DOS (
\family typewriter 
int 0x21
\family default 
), y almacena los valores resultados de los registros de la CPU en 
\family typewriter 
outregs
\family default 
 y 
\family typewriter 
segregs
\family default 
.
\layout Description


\size largest 
intr
\layout Standard

Interfase de interrupción software 8086.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void intr (int intno, struct REGPACK *preg);
\layout Standard

Esta función carga los registros de la CPU con los valores almacenados en
 
\family typewriter 
preg
\family default 
, ejecuta la interrupción 
\family typewriter 
intno
\family default 
, y almacena los valores resultados de los registros de la CPU en 
\family typewriter 
preg
\family default 
.
\layout Description


\size largest 
keep
\layout Standard

Termina y queda residente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void keep (unsigned char estado, unsigned tamanio);
\layout Standard

Esta función vuelve al DOS con valor de salida en estado, pero el programa
 queda en memoria.
 La porción de programa residente ocupa tamanio párrafos y la memoria del
 programa restante es liberada.
\layout Description


\size largest 
nosound
\layout Standard

Desactiva el altavoz del PC.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void nosound (void);
\layout Description


\size largest 
outp
\layout Standard

Macro que escribe un byte en un puerto hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int outp (int portid, int byte_value);
\layout Description


\size largest 
outport
\layout Standard

Escribe una palabra en un puerto hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void outport (int portid, int value);
\layout Description


\size largest 
outportb
\layout Standard

Escribe un byte en un puerto hardware.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void outportb (int portid, unsigned char value);
\layout Description


\size largest 
parsfnm
\layout Standard

Analiza un nombre de fichero y construye un bloque de control de fichero
 (FCB).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *parsfnm (const char *cmdline, struct fcb *fcb, int opt);
\layout Standard

Después de analizar con éxito el nombre del fichero, 
\family typewriter 
parsfnm()
\family default 
 devuelve un puntero al byte siguiente después del final del nombre del
 fichero.
 Si no se produce ningún error en el análisis del nombre del fichero, devuelve
 0.
\layout Description


\size largest 
peek
\layout Standard

Devuelve la palabra que hay en la localización de memoria especificada por
 
\family typewriter 
segmento:desplazamiento
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int peek (unsigned segmento, unsigned desplazamiento);
\layout Description


\size largest 
peekb
\layout Standard

Devuelve el byte que hay en la localización de memoria especificada por
 
\family typewriter 
segmento:desplazamiento
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char peekb (unsigned segmento, unsigned desplazamiento);
\layout Description


\size largest 
poke
\layout Standard

Almacena un valor entero en la posición de memoria especificada por 
\family typewriter 
segmento:desplazamiento
\family default 
.
 
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void poke(unsigned segmento, unsigned desplazamiento, int valor);
\layout Description


\size largest 
pokeb
\layout Standard

Almacena un byte en la posición de memoria especificada por 
\family typewriter 
segmento:desplazamiento
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void pokeb (unsigned segmento, unsigned desplazamiento, char valor);
\layout Description


\size largest 
randbrd
\layout Standard

Lee bloque aleatorio.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int randbrd (struct fcb *fcb, int rcnt);
\layout Standard

Si devuelve 0 todos los registros han sido leídos correctamente, si devuelve
 otro valor ha habido algún problema.
\layout Description


\size largest 
randbwr
\layout Standard

Escribe bloque aleatorio usando el bloque de control de fichero (FCB).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int randbwr (struct fcb *fcb, int rcnt);
\layout Standard

Si devuelve 0 todos los registros han sido escritos correctamente, si devuelve
 otro valor ha habido algún problema.
\layout Description


\size largest 
segread
\layout Standard

Lee registros del segmento.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 

\protected_separator 
 void segread(struct SREGS *segp);
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct SREGS segs;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 segread(&segs);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Valores de los registros del segmento actual
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("CS: %X
\protected_separator 

\protected_separator 
 DS: %X
\backslash 
n", segs.cs, segs.ds);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("ES: %X
\protected_separator 

\protected_separator 
 SS: %X
\backslash 
n", segs.es, segs.ss);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
setblock
\layout Standard

Modifica el tamaño de un bloque asignado previamente.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int setblock(unsigned segx, unsigned nuevotam);
\layout Standard

Usa los bloques asignados con 
\family typewriter 
allocmem()
\family default 
.
 Devuelve -1 si tiene éxito.
 En caso de error, devuelve el tamaño del bloque posible más grande y a
 
\family typewriter 
_doserrno
\family default 
 se le asigna el código de error.
\layout Description


\size largest 
setcbrk
\layout Standard

Pone el estado de control-break.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int setcbrk(int valorcbrk);
\layout Standard

Si 
\family typewriter 
valorcbrk
\family default 
 es 1, chequea el Ctrl-Break en cada llamada al sistema.
 Si es 0, chequea sólo en las llamadas de E/S de consola, impresora y comunicaci
ones.
 Devuelve el valor pasado en 
\family typewriter 
valorcbrk
\family default 
.
\layout Description


\size largest 
setdate
\layout Standard

Pone la fecha del DOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void setdate(struct date *pfecha);
\layout Description


\size largest 
setdta
\layout Standard

Pone la dirección de transferencia de disco.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void setdta(char far *dta);
\layout Description


\size largest 
settime
\layout Standard

Pone la hora del sistema.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void settime(struct time *phora);
\layout Description


\size largest 
setvect
\layout Standard

Pone entrada de un vector de interrupción.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void setvect(int interruptno, void interrupt (*isr) ( ));
\layout Standard


\family typewriter 
isr
\family default 
 apunta a una función que será llamada cuando ocurra el número de interrupción
 
\family typewriter 
interrruptno
\family default 
.
 Si isr es una función C, debería ser definida con la palabra clave 
\family typewriter 
interrupt
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
/* NOTA: Cuando se utilizan rutinas de servicio de interrupción, no se puede
 compilar el programa con la opción de testear el desbordamiento de pila
 puesta a on y obtener un programa ejecutable que opere correctamente */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
#define INTR 0X1C
\protected_separator 
 /* interrupción de tick de reloj */
\layout Quotation


\family typewriter 
void interrupt(*viejo_manejador) (void);
\layout Quotation


\family typewriter 
int cont = 0;
\layout Quotation


\family typewriter 
void interrupt manejador(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* incrementa el contador global */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 cont++;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* llama a la rutina original */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 viejo_manejador();
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* salva el vector de interrupción original */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 viejo_manejador = getvect(INTR);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* instala el nuevo manejador de interrupción */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 setvect(INTR, manejador);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* bucle hasta mientras el contador no exceda de 20 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 while(cont < 20)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("cont es %d
\backslash 
n", cont);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* vuelve a poner el manejador de interrupción original */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 setvect(INTR, viejo_manejador);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
setverify
\layout Standard

Pone el estado de verificación.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void setverify (int valor);
\layout Standard

Si valor=1, cada operación de escritura en disco será seguida por una operación
 de lectura para asegurar resultados correctos.
 (0 significa no lectura de comprobación.)
\layout Description


\size largest 
sleep
\layout Standard

Suspende la ejecución durante un intervalo (en segundos).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void sleep (unsigned segundos);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 for(i = 1; i < 5; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Ejecución suspendida durante %d segundos.
\backslash 
n", i);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 sleep(i);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
sound
\layout Standard

Activa el altavoz del PC a una frecuencia especificada.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void sound (unsigned frequencia);
\layout Standard


\family typewriter 
frecuencia
\family default 
 está en herzios (ciclos por segundo)
\layout Description


\size largest 
unixtodos
\layout Standard

Convierte fecha y hora de formato UNIX a formato DOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void unixtodos (long time, struct date *d, struct time *t);
\layout Description


\size largest 
unlink
\layout Standard

Borra un fichero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int unlink (const char *nombre_de_fichero);
\layout Standard

Si el fichero 
\family typewriter 
nombre_de_fichero
\family default 
 tiene el atributo de sólo lectura, 
\family typewriter 
unlink()
\family default 
 fallará.
 En este caso es necesario llamar primero a 
\family typewriter 
chmod()
\family default 
 para cambiar el atributo del fichero.
 Devuelve 0 si tiene éxito; -1 en caso de error.
 El prototipo de esta función también se encuentra en los ficheros 
\family typewriter 
io.h
\family default 
 y 
\family typewriter 
stdio.h
\family default 
.
\newline 

\layout Description


\size largest 
Constantes,
\protected_separator 
Tipos
\protected_separator 
de
\protected_separator 
Datos
\protected_separator 
y
\protected_separator 
Variables
\protected_separator 
Globales
\layout Description


\size largest 
int _8087 (variable global)
\layout Standard

Chip de coprocesador actual.
 Si el programa está ejecutándose en una máquina con coprocesador matemático,
 
\family typewriter 
_8087
\family default 
 es distinto de cero:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
8 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
valor _8087
\newline 
Coprocesador matemático
\series default 

\newline 
1
\newline 
8087
\newline 
2
\newline 
80287
\newline 
3
\newline 
80387
\newline 
0
\newline 
(no detectado)
\layout Description


\size largest 
_argc (variable global)
\layout Standard

Contiene el número de argumentos en la línea de comandos.
\layout Quotation


\family typewriter 
extern int _argc;
\layout Standard


\family typewriter 
_argc
\family default 
 tiene el valor de 
\family typewriter 
argc
\family default 
 pasado a 
\family typewriter 
main
\family default 
 cuando empieza el programa.
\layout Description


\size largest 
_argv (variable global)
\layout Standard

Array de punteros a los argumentos de la línea de comandos.
\layout Quotation


\family typewriter 
extern char *_argv[]
\layout Description


\size largest 
BYTEREGS (struct)
\layout Description


\size largest 
WORDREGS (struct)
\layout Standard

Estructuras para almacenamientos de registros de bytes y palabras.
\layout Quotation


\family typewriter 
struct BYTEREGS
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 al, ah, bl, bh;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 cl, ch, dl, dh;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Quotation


\family typewriter 
struct
\protected_separator 
 WORDREGS
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int
\protected_separator 
 ax, bx, cx, dx;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int
\protected_separator 
 si, di, cflag, flags;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
COUNTRY (struct)
\layout Standard

La estructura COUNTRY especifica cómo se van a formatear ciertos datos dependien
tes del país.
\layout Quotation


\family typewriter 
struct COUNTRY
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 

\protected_separator 
 co_date; /* formato de fecha */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_curr[5]; /* símbolo de moneda */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_thsep[2]; /* separador de millar */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_desep[2]; /* separador decimal */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_dtsep[2]; /* separador de fecha */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_tmsep[2]; /* separador de tiempo */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_currstyle; /* estilo de moneda */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_digits; /* dígitos significativos en moneda */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_time;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long
\protected_separator 
 co_case;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_dasep[2]; /* separador de datos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 co_fill[10];
\layout Quotation


\family typewriter 

\protected_separator 
 };
\family default 
 
\layout Description


\size largest 
DATE (struct)
\layout Standard

Estructura de la fecha usada por las funciones 
\family typewriter 
dostounix()
\family default 
, 
\family typewriter 
setdate()
\family default 
, 
\family typewriter 
getdate()
\family default 
 y 
\family typewriter 
unixtodos()
\family default 
.
\layout Quotation


\family typewriter 
struct date
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 

\protected_separator 
 da_year;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 da_day;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 da_mon;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
DEVHDR (struct)
\layout Standard

Estructura de cabecera para los controladores de dispositivos de MS-DOS.
 
\layout Quotation


\family typewriter 
struct devhdr
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 dh_next;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 dh_attr;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned short
\protected_separator 
 dh_strat;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned short
\protected_separator 
 dh_inter;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 dh_name[8];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
DFREE (struct)
\layout Standard

La estructura de la información devuelta por la función 
\family typewriter 
getdfree()
\family default 
.
\layout Quotation


\family typewriter 
struct dfree
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned df_avail; /* Clusters disponibles */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned df_total; /* Clusters totales */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned df_bsec;
\protected_separator 
 /* Bytes por sector */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned df_sclus; /* Sectores por cluster */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
_doserrno (variable global)
\layout Standard

Variable que contiene el código de error de DOS actual.
\layout Quotation


\family typewriter 
int _doserrno;
\layout Standard

Cuando en una llamada al sistema MS-DOS ocurre un error, a 
\family typewriter 
_doserrno
\family default 
 se le asigna el código de error DOS actual.
 Los mnemotécnicos para los códigos de error de DOS actual que pueden ser
 asignados a 
\family typewriter 
_doserrno
\family default 
 son:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
17 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Mnemotécnico
\newline 
Código de error del DOS
\series default 

\newline 
E2BIG
\newline 
Entorno malo
\newline 
EACCES
\newline 
Acceso denegado
\newline 
EACCES
\newline 
Acceso malo
\newline 
EACCES
\newline 
Es directorio corriente
\newline 
EBADF
\newline 
Manejador malo
\newline 
EFAULT
\newline 
Reservado
\newline 
EINVAL
\newline 
Datos malos
\newline 
EINVAL
\newline 
Función mala
\newline 
EMFILE
\newline 
Demasiados ficheros abiertos
\newline 
ENOENT
\newline 
No es fichero ni directorio
\newline 
ENOEXEC
\newline 
Formato malo
\newline 
ENOMEM
\newline 
MCB destruido
\newline 
ENOMEM
\newline 
Fuera de memoria
\newline 
ENOMEM
\newline 
Bloque malo
\newline 
EXDEV
\newline 
Unidad mala
\newline 
EXDEV
\newline 
No es el mismo dispositivo
\layout Standard

Esta variable también está declarada en los ficheros 
\family typewriter 
errno.h
\family default 
 y 
\family typewriter 
stdlib.h
\family default 
.
\layout Description


\size largest 
dosSearchInfo (tipo)
\layout Quotation


\family typewriter 
typedef struct
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 
 drive;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 
 pattern [13];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 
 reserved [7];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 
 attrib;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short
\protected_separator 
 time;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short
\protected_separator 
 date;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long
\protected_separator 

\protected_separator 
 size;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 
 nameZ [13];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 } dosSearchInfo;
\layout Description


\size largest 
environ (variable global)
\layout Standard

Array de cadenas usado para acceder y alterar el entorno del proceso.
 
\layout Quotation


\family typewriter 
extern char **environ
\layout Standard

También se encuentra declarada en el fichero 
\family typewriter 
stdlib.h
\family default 
.
\layout Description


\size largest 
FATINFO (struct)
\layout Standard

La estructura de información rellenada por las funciones 
\family typewriter 
getfat()
\family default 
 y 
\family typewriter 
getfatd()
\family default 
.
\layout Quotation


\family typewriter 
struct fatinfo
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 fi_sclus; /* sectores por cluster */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 
 fi_fatid; /* el byte identificador de la FAT */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 

\protected_separator 
 fi_nclus; /* número de clusters */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 

\protected_separator 
 fi_bysec; /* bytes por sector */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
FCB (struct)
\layout Standard

La estructura de los bloques de control de ficheros de MS-DOS.
\layout Quotation


\family typewriter 
struct fcb
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 
 fcb_drive;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 
 fcb_name[8],
\protected_separator 
 fcb_ext[3];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short
\protected_separator 
 fcb_curblk,
\protected_separator 

\protected_separator 
 fcb_recsize;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long
\protected_separator 

\protected_separator 
 fcb_filsize;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short
\protected_separator 
 fcb_date;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 
 fcb_resv[10], fcb_currec;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long
\protected_separator 

\protected_separator 
 fcb_random;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
FA_xxxx (#defines)
\layout Standard

Atributos de fichero de MS-DOS.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

FA_RDONLY
\newline 
Atributo de sólo lectura
\newline 
FA_HIDDEN
\newline 
Fichero oculto
\newline 
FA_SYSTEM
\newline 
Fichero de sistema
\newline 
FA_LABEL
\newline 
Etiqueta de la unidad
\newline 
FA_DIREC
\newline 
Directorio
\newline 
FA_ARCH
\newline 
Archivo
\layout Description


\size largest 
_heaplen (variable global)
\layout Standard

Tamaño inicial del montón en bytes.
\layout Quotation


\family typewriter 
unsigned _heaplen
\layout Standard

El valor de 
\family typewriter 
_heaplen
\family default 
 al principio de la ejecución del programa determina el tamaño del montón
 
\family typewriter 
near
\family default 
 que será asignado.
 El valor de 0, por defecto, hace un montón de tamaño máximo.
 
\family typewriter 
_heaplen
\family default 
 no es usado en los modelos de datos grandes.
\layout Description


\size largest 
NFDS (#define)
\layout Standard

Número máximo de descriptores de fichero.
\layout Quotation


\family typewriter 
_osmajor
\family default 
 (variable global)
\layout Quotation


\family typewriter 
_osminor
\family default 
 (variable global)
\layout Quotation


\family typewriter 
_version
\family default 
 (variable global)
\layout Standard

La versión de MS-DOS bajo la cual está corriendo el programa actualmente.
\layout Quotation


\family typewriter 
unsigned char _osmajor /* número de versión mayor */
\layout Quotation


\family typewriter 
unsigned char _osminor /* número de versión menor */
\layout Quotation


\family typewriter 
unsigned int
\protected_separator 
 _version /* número de versión completa */
\family default 
 
\layout Description


\size largest 
_psp (variable global)
\layout Standard

Dirección del segmento del PSP (Prefijo de Segmento de Programa) del programa.
\layout Quotation


\family typewriter 
extern unsigned int _psp;
\layout Standard

También está declarada en los ficheros 
\family typewriter 
process.h
\family default 
 y 
\family typewriter 
stdlib.h
\family default 
.
\layout Description


\size largest 
REGPACK (struct)
\layout Standard

La estructura de los valores pasados y devueltos en la función 
\family typewriter 
intr()
\family default 
.
\layout Quotation


\family typewriter 
struct REGPACK
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 r_ax, r_bx, r_cx, r_dx;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 r_bp, r_si, r_di;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned
\protected_separator 
 r_ds, r_es, r_flags;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
REGS (union)
\layout Standard

La unión 
\family typewriter 
REGS
\family default 
 es usada para pasar y recibir información en las funciones 
\family typewriter 
intdos()
\family default 
, 
\family typewriter 
intdosx()
\family default 
, 
\family typewriter 
int86()
\family default 
 y 
\family typewriter 
int86x()
\family default 
.
\layout Quotation


\family typewriter 
union REGS
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 struct
\protected_separator 
 WORDREGS
\protected_separator 
 x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 struct
\protected_separator 
 BYTEREGS
\protected_separator 
 h;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
SREGS (struct)
\layout Standard

La estructura de los registros de segmentos pasadas y rellenadas en las
 funciones 
\family typewriter 
intdosx()
\family default 
, 
\family typewriter 
int86x()
\family default 
 y 
\family typewriter 
segread()
\family default 
.
\layout Quotation


\family typewriter 
struct SREGS
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int es;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int cs;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int ss;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int ds;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
_stklen (variable global)
\layout Standard

Variable con longitud de la pila.
\layout Quotation


\family typewriter 
extern unsigned _stklen;
\layout Standard


\family typewriter 
_stklen
\family default 
 especifica el tamaño de la pila.
 El tamaño de la pila por defecto es 4K.
 
\family typewriter 
_stklen
\family default 
 es usado antes de que se llame a la función 
\family typewriter 
main()
\family default 
.
 Para poner un tamaño de pila diferente, debes declarar 
\family typewriter 
_stklen
\family default 
 en tu fichero fuente como una variable global.
 (Colócala fuera de todas las funciones.).
 Por ejemplo, para poner un tamaño de pila de 20000 bytes, usa la siguiente
 declaración:
\layout Quotation


\family typewriter 
unsigned _stklen = 20000;
\layout Description


\size largest 
TIME (struct)
\layout Standard

Estructura de la hora usada por las funciones 
\family typewriter 
dostounix()
\family default 
, 
\family typewriter 
gettime()
\family default 
, 
\family typewriter 
settime()
\family default 
 y 
\family typewriter 
unixtodos()
\family default 
.
\layout Quotation


\family typewriter 
struct time
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char ti_min;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char ti_hour;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char ti_hund;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char ti_sec;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
BYTEREGS (struct)
\layout Description


\size largest 
WORDREGS (struct)
\layout Standard

Estructuras para el almacenamiento de registros de bytes y palabras.
\layout Quotation


\family typewriter 
struct BYTEREGS
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 al, ah, bl, bh;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned char
\protected_separator 
 cl, ch, dl, dh;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Quotation


\family typewriter 
struct WORDREGS
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int
\protected_separator 
 ax, bx, cx, dx;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned int
\protected_separator 
 si, di, cflag, flags;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
XFCB (struct)
\layout Standard

La estructura de bloque de control de fichero extendido de MS-DOS.
\layout Quotation


\family typewriter 
struct xfcb
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 xfcb_flag;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 xfcb_resv[5];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 xfcb_attr;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 struct
\protected_separator 
 fcb
\protected_separator 
 xfcb_fcb;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Section

Funciones de la ROM BIOS 
\layout Standard

Cada una de las funciones declaradas en el fichero de cabecera 
\family typewriter 
<bios.h>
\family default 
 de Turbo C representa una rutina de servicio de la ROM BIOS.
 Todas estas funciones se pueden implementar con las funciones 
\family typewriter 
int86()
\family default 
 y 
\family typewriter 
int86x()
\family default 
 del fichero de cabecera 
\family typewriter 
<dos.h>
\family default 
.
 Para conocer más detalles sobre las funciones del fichero bios.h tendrás
 que consultar un manual en el que se describan las funciones de la ROM
 BIOS.
\layout Subsection

Fichero de Cabecera bios.h (TC) 
\layout Description


\size largest 
bioscom
\layout Standard

E/S de comunicaciones RS-232
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int bioscom (int cmd, char byte, int puerto);
\layout Standard

Los valores para 
\family typewriter 
cmd
\family default 
 son los siguientes:
\layout List
\labelwidthstring 00.00.0000

0 pone los parámetros de comunicación con el valor en byte
\layout List
\labelwidthstring 00.00.0000

1 envía el carácter que está en byte a la línea de comunicaciones
\layout List
\labelwidthstring 00.00.0000

2 recibe un carácter de la línea de comunicaciones (en los 8 bits menos
 significativos del valor devuelto)
\layout List
\labelwidthstring 00.00.0000

3 devuelve el estado actual del puerto de comunicaciones
\layout Standard

El puerto 0 es COM1, el 1 es COM2, etc.
 Los 8 bits más significativos del valor devuelto son los bits de estado.
 Los 8 bits menos significativos dependen del cmd especificado.
\layout Description


\size largest 
biosdisk
\layout Standard

Servicios de disco de la BIOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int biosdisk (int cmd, int unidad, int cabeza, int pista, int sector,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int nsects, void *buffer);
\layout Standard

Devuelve 0 si tiene éxito; en otro caso devuelve un código de error.
 Para saber los valores que puede tomar 
\family typewriter 
cmd
\family default 
 y el significado de cada uno de ellos consulta la interrupción 
\family typewriter 
13 hex
\family default 
.
 de la ROM BIOS.
\layout Description


\size largest 
biosequip
\layout Standard

Chequea equipo.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int biosequip (void);
\layout Standard

Devuelve los indicadores de equipo de la BIOS.
\layout Description


\size largest 
bioskey
\layout Standard

Interface de teclado.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int bioskey (int cmd);
\layout List
\labelwidthstring 00.00.0000


\series bold 
cmd Acción
\layout List
\labelwidthstring 00.00.0000

0 Devuelve el código de exploración de la tecla que hay en el buffer y la
 quita de él.
 Espera la pulsación de la tecla si el buffer| está vacío
\layout List
\labelwidthstring 00.00.0000

1 Devuelve el código de exploración de la tecla que hay en el buffer pero
 no la quita de él.
 Devuelve 0 si el buffer está vacío.
 Si fue presionada la combinación de teclas Ctrol-Break, 
\family typewriter 
bioskey()
\family default 
 devuelve 
\family typewriter 
-1 (0xFFFF)
\family default 
.
\layout List
\labelwidthstring 00.00.0000

2 Devuelve los indicadores de estado de las teclas de cambio de la BIOS.
 (teclas shift izquierda y derecha, control, alt)
\layout Description


\size largest 
biosmemory
\layout Standard

Devuelve el tamaño de la memoria.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int biosmemory (void);
\layout Standard

El valor devuelto es el tamaño de la memoria en bloques de 1K.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <bios.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Tamaño de la memoria RAM: %d Kbytes
\backslash 
n", biosmemory ());
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
biosprint
\layout Standard

E/S de impresora usando directamente la BIOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int biosprint (int cmd, int byte, int puerto);
\layout Standard

Si 
\family typewriter 
cmd
\family default 
 es 0, si imprime el byte.
 Si 
\family typewriter 
cmd
\family default 
 es 1, se inicializa el puerto de impresora.
 Si 
\family typewriter 
cmd
\family default 
 es 2, se lee el estado actual de la impresora.
 Se devuelve el estado actual de la impresora para cualquier valor de 
\family typewriter 
cmd
\family default 
.
\layout Description


\size largest 
biostime
\layout Standard

Rutina del servicio de reloj de la BIOS.
\layout Standard

Sintaxis
\layout Quotation


\family typewriter 
long biostime (int cmd, long nuevahora);
\layout Standard

Si 
\family typewriter 
cmd
\family default 
 es 0, lee la hora de la BIOS.
 Si 
\family typewriter 
cmd
\family default 
 es 1, pone la hora de la BIOS.
 La hora está en pulsos de reloj desde la medianoche.
 Un segundo tiene 18.2 pulsos.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <bios.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El número de pulsos de reloj desde la medianoche es: %lu
\backslash 
n", biostime (0, 0L));
\layout Quotation


\family typewriter 
}
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 11-1
\series default 
.
 Realiza un programa que lea el nombre (no ruta) de un programa ejecutable,
 lo busque en la unidad de disco de trabajo, y lo ejecute si lo encuentra.
\layout Itemize


\series bold 
Ejercicio 11-2
\series default 
.
 Realiza un programa que mueva ficheros de un directorio a otro.
 Este programa aceptará dos argumentos, el primero es la especificación
 de los ficheros (puede contener ruta y los caracteres comodín * y ?) y
 el segundo argumento es el nombre del directorio al cual se van a mover
 los ficheros.
\layout Quote


\series bold 
Consejo
\series default 
: comprobar si el directorio de destino está en la misma unidad que el directori
o fuente (en el que están los ficheros a mover), y si es así, utilizar la
 función remove() del C para mover los ficheros; si en cambio el directorio
 de destino está en una unidad de disco diferente, entonces habrá que copiar
 los ficheros al directorio de destino y después borrarlos en el directorio
 origen.
\layout Itemize


\series bold 
Ejercicio 11-3
\series default 
.
 Diseña un programa residente que visualice continuamente la hora actual
 en la esquina superior derecha de la pantalla.
\begin_deeper 
\layout Quote


\series bold 
Consejo
\series default 
: la función que será llamada en cada interrupción de reloj tiene que ser
 declarada como interrupt.
 El programa se ha de terminar llamando a la función 
\family typewriter 
keep()
\family default 
.
\end_deeper 
\layout Chapter

La Biblioteca de C (Parte III)
\layout Description

Primera
\protected_separator 
parte:
\layout Itemize

Funciones varias (
\family typewriter 
stdlib.h
\family default 
).
\layout Itemize

Funciones de fecha y hora (
\family typewriter 
time.h
\family default 
).
\layout Itemize

Funciones relacionadas con información geográfica (
\family typewriter 
locale.h
\family default 
).
\layout Description

Segunda
\protected_separator 
parte:
\layout Itemize

Función y estructura de hora actual (
\family typewriter 
sys
\backslash 
timeb.h
\family default 
).
\layout Itemize

Funciones de información de ficheros (
\family typewriter 
sys
\backslash 
stat.h
\family default 
).
\layout Itemize

Constantes simbólicas para compatibilidad con UNIX (
\family typewriter 
values.h
\family default 
).
\layout Itemize

Funciones de coma flotante (
\family typewriter 
float.h
\family default 
).
\layout Itemize

Conexión de Turbo C con ensamblador (
\family typewriter 
#pragma inline
\family default 
 y 
\family typewriter 
asm
\family default 
).
\layout Section

Funciones Varias
\layout Standard

El fichero 
\family typewriter 
<stdlib.h>
\family default 
 es una especie de miscelánea de funciones, es decir, en él se encuentra
 declaradas una gran variedad de funciones: funciones de conversión de tipos,
 de ordenación, de búsqueda, de generación de números pseudoaleatorios,
 etc.
 La cabecera 
\family typewriter 
stdlib.h
\family default 
 también define los tipos 
\family typewriter 
div_t
\family default 
 y 
\family typewriter 
ldiv_t
\family default 
 que son los valores devueltos por 
\family typewriter 
div()
\family default 
 y 
\family typewriter 
ldiv()
\family default 
, respectivamente.
 Además define las macros: 
\layout Quotation


\family typewriter 
ERANGE
\family default 
 (valor asignado a errno si se produce un error de rango), 
\layout Quotation


\family typewriter 
HUGE_VAL
\family default 
 (mayor valor representable por rutinas en coma flotante) y 
\layout Quotation


\family typewriter 
RAND_MAX
\family default 
 (máximo valor que puede ser devuelto por la función 
\family typewriter 
rand()
\family default 
).
\layout Subsection

Fichero de Cabecera stdlib.h
\layout Description


\size largest 
abort
\layout Standard

Termina anormalmente un programa.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void abort(void);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Llamando a abort()
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 abort();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0; /* Esta línea nunca es ejecutada */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
abs
\layout Standard

Devuelve el valor absoluto de un entero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int abs(int x);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <math.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nabs(4): %d", abs (4));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nabs(-5): %d", abs (-5));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
atexit
\layout Standard

Registra una función de terminación.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int atexit(atexit_t func);
\layout Standard

La función 
\family typewriter 
atexit()
\family default 
 fija la función apuntada por 
\family typewriter 
func
\family default 
 como la función a ser llamada una vez alcanzada la terminación normal del
 programa.
 Es decir, al final de la ejecución de un programa, se llama a la función
 especificada.
 La función 
\family typewriter 
atexit()
\family default 
 devuelve 0 si la función queda establecida como función de terminación;
 en cualquier otro caso devuelve un valor distinto de cero.
 Se pueden fijar varias funciones de terminación siendo llamadas en orden
 inverso al de su establecimiento.
 En otras palabras, la naturaleza del proceso de registro es como una pila.
 El tipo 
\family typewriter 
atexit_t
\family default 
 está declarado del siguiente modo: 
\family typewriter 
typedef void (* atexit_t) (void);
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
void exit_fn1(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Llamada función de salida número 1
\backslash 
n");
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void exit_fn2(void)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Llamada función de salida número 2
\backslash 
n");
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 atexit(exit_fn1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 atexit(exit_fn2);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
atof
\layout Standard

Convierte una cadena a un punto flotante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double atof(const char *s);
\layout Standard

La función 
\family typewriter 
atof()
\family default 
 convierte la cadena apuntada por s a un valor de tipo double.
 La cadena debe contener un número válido en como flotante.
 Si no es este el caso, se devuelve el valor 0.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 float f;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *str = "123.4ABC";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 f = atof(str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("string = %s float = %f
\backslash 
n", str, f);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
atoi
\layout Standard

Convierte una cadena en un entero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int atoi(const char *s);
\layout Standard

La función 
\family typewriter 
atoi()
\family default 
 convierte la cadena apuntada por s a un valor 
\family typewriter 
int
\family default 
.
 La cadena debe contener un número entero válido.
 Si no es este el caso, se devuelve el valor 0.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int n;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *str = "12345.67";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 n = atoi(str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("string = %s integer = %d
\backslash 
n", str, n);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
atol
\layout Standard

Convierte un string a un 
\family typewriter 
long
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
long atol(const char *s);
\layout Standard

La función 
\family typewriter 
atol()
\family default 
 convierte la cadena apuntada por s a un valor long 
\family typewriter 
int
\family default 
.
 La cadena debe contener un número entero de tipo 
\family typewriter 
long
\family default 
 válido.
 Si no es este el caso, se devuelve el valor 0.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 long l;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 char *str = "98765432";
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 l = atol(str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("string = %s integer = %ld
\backslash 
n", str, l);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return (0);
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
bsearch
\layout Standard

Búsqueda binaria.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *bsearch(const void *clave, const void *base, unsigned int *num,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned int tam, int(*compara) (const void *arg1, const void *arg2));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned int tam, int(*compara) (void *arg1, void *arg2));
\layout Standard

La función 
\family typewriter 
bsearch()
\family default 
 realiza una búsqueda binaria en el array ordenado apuntado por base y devuelve
 un puntero al primer elemento que se corresponde con la clave apuntada
 por clave.
 El número de elementos en el array está especificado por 
\family typewriter 
num
\family default 
 y el tamaño (en bytes) de cada elemento está descrito por 
\family typewriter 
tam
\family default 
.
 La función apuntada por compara se utiliza para comparar un elemento del
 array con la clave.
 La forma de la función de comparación debe ser: 
\family typewriter 
nombre_func (void *arg1, void *arg2);
\family default 
.
 Debe devolver los siguientes valores:
\layout Itemize

Si arg1 es menor que arg2, devuelve un valor menor que 0.
\layout Itemize

Si arg1 es igual que arg2, devuelve 0.
\layout Itemize

Si arg1 es mayor que arg2, devuelve un valor mayor que 0.
\layout Standard

El array debe estar ordenado en orden ascendente con la menor dirección
 conteniendo el elemento más pequeño.
 Si el array no contiene la clave, se devuelve un puntero nulo.
 Esta función está implementada en uno de los ejemplos de la lección 3.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#define NUM_ELEMENTOS(array) (sizeof(array) / sizeof(array[0]))
\layout Quotation


\family typewriter 
int array_de_numeros[] = { 123, 145, 512, 627, 800, 933, 333, 1000 };
\layout Quotation


\family typewriter 
int comparacion_de_numeros(const int *p1, const int *p2)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return (*p1 - *p2);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int buscar(int clave)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 int *puntero_a_elemento;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 /* El molde (int (*) (const void *, const void *)) es necesario para evitar
 un error de tipo distinto en tiempo de compilación.
 Sin embargo, no es necesario: puntero_a_elemento = (int *) bsearch (...
 debido a que en este caso es el compilador el que realiza la conversión
 de tipos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 puntero_a_elemento = bsearch(&clave, array_de_numeros,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 NUM_ELEMENTOS(array_de_numeros), sizeof(int),
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (int(*) (const void *, const void *)) comparacion_de_numeros);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return(puntero_a_elemento != NULL);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(buscar (800))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("800 está en la tabla.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("800 no está en la tabla.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
calloc
\layout Standard

Asigna memoria principal.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *calloc(size_t nelems, size_t tam);
\layout Standard

El prototipo de esta función también se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
.
 Asigna espacio para 
\family typewriter 
nelems
\family default 
 elementos de 
\family typewriter 
tam
\family default 
 bytes cada uno y almacena cero en el área.
 Devuelve un puntero al nuevo bloque asignado o 
\family typewriter 
NULL
\family default 
 si no existe bastante espacio.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *str = NULL;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* asigna memoria para el string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 str = calloc(10, sizeof (char));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* copia "Hola" en string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy(str, "Hello");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* visualiza string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El string es %s
\backslash 
n", str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* libera memoria */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 free(str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
div
\layout Standard

Divide dos enteros.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
div_t div(int numer, int denom);
\layout Standard

La función 
\family typewriter 
div()
\family default 
 divide dos enteros y devuelve el cociente y el resto como un tipo 
\family typewriter 
div_t
\family default 
.
 Los parametros 
\family typewriter 
numer
\family default 
 y 
\family typewriter 
denom
\family default 
 son el numerador y el denominador respectivamente.
 El tipo 
\family typewriter 
div_t
\family default 
 es una estructura de enteros definida (con 
\family typewriter 
typdef
\family default 
) en 
\family typewriter 
stdlib.h
\family default 
 como sigue:
\layout Quotation


\family typewriter 
typedef struct
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long int quot; /* cociente */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long int rem;
\protected_separator 
 /* resto
\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 } div_t;
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main (void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 div_t x = div (10, 3);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf ("10 div 3 = %d resto %d
\backslash 
n", x.quot, x.rem);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
ecvt
\protected_separator 
y
\protected_separator 
fcvt (TC)
\layout Standard

Convierte número en coma flotante a cadena.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *ecvt(double valor, int ndig, int *dec, int *sign);
\layout Quotation


\family typewriter 
char *fcvt(double valor, int ndig, int *dec, int *sign);
\layout Standard

Para 
\family typewriter 
ecvt()
\family default 
, 
\family typewriter 
ndig
\family default 
 es el número de dígitos a almacenar, mientras que en 
\family typewriter 
fcvt()
\family default 
 es el número de dígitos a almacenar depués del punto decimal.
 El valor devuelto apunta a un área estática que es sobreescrita en la próxima
 llamada.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *string;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double valor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int dec, sign;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int ndig = 10;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 clrscr();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 valor = 9.876; /* número regular */ 
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 string = ecvt (valor, ndig, &dec, &sign);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("string = %s
\backslash 
tdec = %d
\backslash 
tsign = %d
\backslash 
n", string, dec, sign);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 valor = -123.45; /* número negativo */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 ndig = 15;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 string = ecvt (valor, ndig, &dec, &sign);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("string = %s
\backslash 
tdec = %d
\backslash 
tsign = %d
\backslash 
n", string, dec, sign);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 valor = 0.6789e5; /* notación científica */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 ndig = 5;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 string = ecvt (valor, ndig, &dec, &sign);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("string = %s
\backslash 
tdec = %d
\backslash 
tsign = %d
\backslash 
n", string, dec, sign);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
exit
\layout Standard

Termina programa.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void exit(int estado);
\layout Standard

Antes de terminar, la salida buffereada es volcada, los ficheros son cerrados
 y las funciones 
\family typewriter 
exit()
\family default 
 son llamadas.
 En Turbo C, el prototipo de esta función también se encuentra en el fichero
 
\family typewriter 
process.h
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int estado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Introduce 1 ó 2
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 estado = getch ();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* Pone el errorlevel del DOS */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 exit(estado - '0');
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0; /* esta línea nunca es ejecutada */
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_exit
\layout Standard

Termina programa.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void _exit(int estado);
\layout Description


\size largest 
fcvt (TC)
\layout Standard

[Ver ecvt()]
\layout Description


\size largest 
free
\layout Standard

Libera bloques asignados con 
\family typewriter 
malloc()
\family default 
 o 
\family typewriter 
calloc()
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void free(void *bloque);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *str;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* asigna memoria para el string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 str = malloc(10);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* copia "Hola" en string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy(str, "Hola");
\layout Quotation


\family typewriter 

\protected_separator 
 /* visualiza string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El string es %s
\backslash 
n", str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* libera memoria */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 free(str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
gcvt (TC)
\layout Standard

Convierte un número en coma flotante a string.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *gcvt(double valor, int ndec, char *buf);
\layout Standard

Devuelve la dirección del string apuntado por 
\family typewriter 
buf
\family default 
.
\layout Description


\size largest 
getenv
\layout Standard

Obtiene un string del entorno.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *getenv(const char *nombre);
\layout Standard

La función 
\family typewriter 
getenv()
\family default 
 devuelve un puntero a la información de entorno asociada con la cadena
 apuntada por nombre en la tabla de información de entorno definida por
 la implementación.
 La cadena devuelta no debe ser cambiada nunca por el programa.
 El entorno de un programa puede incluir cosas como nombres de caminos y
 los dispositivos que están conectados.
 La naturaleza exacta de estos datos viene definida por la implementación.
 Si se hace una llamada a 
\family typewriter 
getenv()
\family default 
 con un argumento que no se corresponde con ninguno de los datos del entorno,
 se devuelve un puntero nulo.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 char *s;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 s = getenv("COMSPEC");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Procesador de comando: %s
\backslash 
n",s);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
itoa
\layout Standard

Convierte un entero a una cadena.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *itoa(int valor, char *cad, int radix);
\layout Standard

La función 
\family typewriter 
itoa()
\family default 
 convierte el entero valor a su cadena equivalente y sitúa el resultado
 en la cadena apuntada por 
\family typewriter 
cad
\family default 
.
 La base de la cadena de salida se determina por 
\family typewriter 
radix
\family default 
, que se encuentra normalmente en el rango de 2 a 16.
 La función 
\family typewriter 
itoa()
\family default 
 devuelve un puntero a 
\family typewriter 
cad
\family default 
.
 Lo mismo se puede hacer con 
\family typewriter 
sprintf()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int numero = 12345;
\layout Quotation


\family typewriter 

\protected_separator 
 char cadena[25];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 itoa(numero, cadena, 10);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("intero = %d cadena = %s
\backslash 
n", numero, cadena);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
labs
\layout Standard

Calcula el valor absoluto de un 
\family typewriter 
long
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
long int labs(long int x);
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <math.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 long resultado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 long x = -12345678L;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 resultado = labs (x);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("número: %ld valor absoluto: %ld
\backslash 
n", x, resultado);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
ldiv
\layout Standard

Divide dos longs, devuelve el cociente y el resto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
ldiv_t ldiv(long int numer, long int denom);
\layout Standard

La función 
\family typewriter 
div()
\family default 
 divide dos longs y devuelve el cociente y el resto como un tipo 
\family typewriter 
ldiv_t
\family default 
.
 Los parametros 
\family typewriter 
numer
\family default 
 y 
\family typewriter 
denom
\family default 
 son el numerador y el denominador respectivamente.
 El tipo 
\family typewriter 
ldiv_t
\family default 
 es una estructura de enteros definida (con 
\family typewriter 
typdef
\family default 
) en 
\family typewriter 
stdlib.h
\family default 
 como sigue:
\layout Quotation


\family typewriter 
typedef struct
\layout Quotation


\family typewriter 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 long int quot; /* cociente */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 long int rem;
\protected_separator 
 /* resto
\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 
 } ldiv_t;
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 ldiv_t lx;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 lx = ldiv(100000L, 30000L);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("100000 div 30000 = %ld resto %ld
\backslash 
n", lx.quot, lx.rem);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
lfind
\protected_separator 
y
\protected_separator 
lsearch (TC)
\layout Standard

Ejecuta búsqueda lineal.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *lfind(const void *clave, const void *base,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 size_t *num, size_t anchura,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int(*func_de_comp) (const void *elem1, const void *elem2));
\layout Quotation


\family typewriter 
void *lsearch(const void *clave, void *base, size_t *num, size_t anchura,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int(*func_de_comp) (const void *elem1, const void *elem2));
\layout Standard

Estas funciones utilizan una rutina definida por el usuario (
\family typewriter 
func_de_comp
\family default 
) para la búsqueda de la clave, en un array de elementos secuenciales.
 El array tiene 
\family typewriter 
num
\family default 
 elementos, cada uno de tamaño anchura bytes y comienza en la dirección
 de memoria apuntada por base.
 Devuelve la dirección de la primera entrada en la tabla que coincida con
 la clave buscada.
 Si la clave buscada no se encuentra, 
\family typewriter 
lsearch
\family default 
 la añade a la lista; 
\family typewriter 
lfind
\family default 
 devuelve 0.
 La rutina 
\family typewriter 
*func_de_comp
\family default 
 debe devolver cero si 
\family typewriter 
*elem1 == *elem2
\family default 
, y un valor distinto de cero en caso contrario.
 Ejemplo de la función 
\family typewriter 
lfind
\family default 
:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
int comparar(int *x, int *y)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return(*x - *y);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int array[5] = { 5, -1, 100, 99, 10 };
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 size_t nelem = 5;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int clave;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int *resultado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 clave = 99;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 resultado = lfind(&clave, array, &nelem, sizeof(int),
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (int (*) (const void *, const void *)) comparar);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(resultado)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Número %d encontrado
\backslash 
n", clave);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Número %d no encontrado.
\backslash 
n", clave);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Standard

Ejemplo de la función 
\family typewriter 
lsearch
\family default 
:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int numeros[10] = { 3, 5, 1 };
\layout Quotation


\family typewriter 
int nnumeros = 3;
\layout Quotation


\family typewriter 
int comparar_numeros(int *num1, int *num2)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return(*num1 - *num2);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int aniadir_elemento (int numero_clave)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int viejo_nnumeros = nnumeros;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 lsearch((void *) &numero_clave, numeros,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (size_t *) &nnumeros, sizeof (int),
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 (int (*) (const void *, const void *)) comparar_numeros);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return(nnumeros == viejo_nnumeros);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 
 int clave = 2;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(aniadir_elemento (clave))
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d está ya en la tabla de números.
\backslash 
n", clave);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 else
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d está añadido a la tabla de números.
\backslash 
n", clave);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Números en tabla:
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < nnumeros; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d
\backslash 
n", numeros[i]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_lrotl
\protected_separator 
y
\protected_separator 
lrotr (TC)
\layout Standard

Rota un valor 
\family typewriter 
long
\family default 
 a la izquierda (
\family typewriter 
_lrotl
\family default 
).
 Rota un valor 
\family typewriter 
long
\family default 
 a la derecha (
\family typewriter 
_lrotr
\family default 
).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned long _lrotr(unsigned long val, int cont);
\layout Quotation


\family typewriter 
unsigned long _lrotl(unsigned long val, int cont);
\layout Standard

Las dos funciones devuelven el valor de val rotado cont bits.
 Ejemplo:
\layout Quotation


\family typewriter 
/* ejemplo lrotl */
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned long resultado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned long valor = 100;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 resultado = _lrotl(valor, 1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El valor %lu rotado un bit a la izquierda es: %lu
\backslash 
n", valor, resultado);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Quotation


\protected_separator 

\layout Quotation


\family typewriter 
/* ejemplo lrotr */
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned long resultado;
\layout Quotation


\family typewriter 

\protected_separator 
 unsigned long valor = 100;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 resultado = _lrotr(valor, 1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El valor %lu rotado un bit a la derecha es: %lu
\backslash 
n", valor, resultado);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
lsearch (TC)
\layout Standard

Ver 
\family typewriter 
lfind()
\family default 
.
\layout Description


\size largest 
ltoa
\layout Standard

Convierte un 
\family typewriter 
long
\family default 
 a una cadena.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *ltoa(long valor, char *cadena, int radix);
\layout Standard

Para una representación decimal, usa 
\family typewriter 
radix=10
\family default 
.
 Para hexadecimal, usa 
\family typewriter 
radix=16
\family default 
.
 Devuelve un puntero al argumento cadena.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char cadena[25];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 long valor = 123456789L;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 ltoa(valor, cadena, 10);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("número = %ld
\protected_separator 
 cadena = %s
\backslash 
n", valor, cadena);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size huge 
malloc
\layout Standard

Asigna memoria principal.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *malloc(size_t tam);
\layout Standard

El parámetro 
\family typewriter 
tam
\family default 
 está en bytes.
 Devuelve un puntero al nuevo bloque asignado, o 
\family typewriter 
NULL
\family default 
 si no existe suficiente espacio para el nuevo bloque.
 Si 
\family typewriter 
tam == 0
\family default 
, devuelve 
\family typewriter 
NULL
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *str;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if((str = (char *) malloc (10)) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Memoria insuficiente
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit(1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy(str, "Hola");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El string es %s
\backslash 
n", str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 free(str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
max
\protected_separator 
y
\protected_separator 
min (TC)
\layout Standard

Macros que generan código en línea para encontrar el valor máximo y mínimo
 de dos enteros.
 Sintaxis:
\layout Quotation


\family typewriter 
max(a,b) 
\family default 
máximo de dos enteros a y b
\layout Quotation


\family typewriter 
min(a,b) 
\family default 
mínimo de dos enteros a y b
\layout Description


\size largest 
putenv (TC)
\layout Standard

Añade una cadena al entorno actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int putenv(const char *nombre);
\layout Standard

En caso de éxito, 
\family typewriter 
putenv()
\family default 
 devuelve 0; en caso de fallo, devuelve -1.
 
\layout Description


\size largest 
qsort
\layout Standard

Ordena usando el algoritmo 
\family typewriter 
quicksort
\family default 
 (ordenación rápida).
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void qsort(void *base, size_t num, size_t tam,
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int(*compara) (const void *, const void *));
\layout Standard

La función 
\family typewriter 
qsort()
\family default 
 ordena el array apuntado por base utilizando el método de ordenación de
 C.A.R.
 Hoare (este método se ha explicado en el ejemplo 3 de la lección 5).
 El número de elementos en el array se especifica mediante 
\family typewriter 
num
\family default 
, y el tamaño en bytes de cada elemento está descrito por 
\family typewriter 
tam
\family default 
.
 La función compara se utiliza para comparar un elemento del array con la
 clave.
 La comparación debe ser: 
\family typewriter 
int nombre_func(void *arg1, void *arg2);
\family default 
.
 Debe devolver los siguientes valores:
\layout Itemize

Si arg1 es menor que arg2, devuelve un valor menor que 0.
\layout Itemize

Si arg1 es igual a arg2 devuelve 0.
\layout Itemize

Si arg1 es mayor que arg2, devuelve un valor mayor que 0.
\layout Standard

El array es ordenado en orden ascendente con la dirección más pequeña conteniend
o el menor elemento.
 Veamos un ejemplo de la utilización de esta función, donde podemos apreciar
 además, dos formas posibles de declaración y utilización de la función
 de comparación requerida por la función 
\family typewriter 
qsort()
\family default 
.
\layout Quotation


\family typewriter 
#include <stdio.h>
\protected_separator 
 /* printf () */
\layout Quotation


\family typewriter 
#include <stdlib.h> /* qsort () */
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int num[10] = { 3, 2, 8, 9, 2, 2, 1, -2, 3, 2 };
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 register int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int comparar_creciente(const void *elem1, const void *elem2);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int comparar_decreciente(const int *elem1, const int *elem2);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nArray desordenado: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", num[i]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 qsort(num, 10, sizeof (int), comparar_creciente);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nArray ordenado en orden creciente: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", num[i]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* el molde del cuarto argumento convierte el tipo (int (*) (const int
 *, const int *)) al tipo (int (*) (const void *, const void *)) que es
 el que requiere la función qsort */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 qsort(num, 10, sizeof (int), (int(*) (const void *, const void *)) comparar_dec
reciente);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nArray ordenado en orden decreciente: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d ", num[i]);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int comparar_creciente(const void *elem1, const void *elem2)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* para acceder al contenido de un puntero del tipo (void *) necesitamos
 moldearlo a un tipo base que no sea void */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return(*(int *)elem1 - *(int *)elem2);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int comparar_decreciente(const int *elem1, const int *elem2)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return(*elem2 - *elem1);
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
rand
\layout Standard

Generador de números aleatorios.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int rand(void);
\layout Standard

Devuelve números aleatorios entre 0 y 
\family typewriter 
RAND_MAX
\family default 
.
 
\family typewriter 
RAND_MAX
\family default 
 está definido en 
\family typewriter 
stdlib.h
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Diez números aleatorios entre 0 y 99
\backslash 
n
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d
\backslash 
n", rand() % 100);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
random (TC)
\layout Standard

Macro que devuelve un entero.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int random(int num);
\layout Standard

Devuelve un entero entre 0 y (
\family typewriter 
num
\family default 
-1).
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 randomize();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Número aleatorio en el rango 0-99: %d
\backslash 
n", random(100));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
randomize (TC)
\layout Standard

Macro que inicializa el generador de números aleatorios.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void randomize(void);
\layout Standard

Inicializa el generador de números aleatorios con un valor aleatorio.
 Esta función usa la función 
\family typewriter 
time()
\family default 
, así que debemos incluir time.h cuando usemos esta rutina.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 randomize();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Diez números aleatorios entre 0 y 99
\backslash 
n
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d
\backslash 
n", rand() % 100);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
realloc
\layout Standard

Reasigna memoria principal.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void *realloc(void *bloque, size_t tam);
\layout Standard

El prototipo de esta función también se encuentra en el fichero de cabecera
 
\family typewriter 
stdlib.h
\family default 
.
 Intenta achicar o expandir el bloque asignado previamente a 
\family typewriter 
tam
\family default 
 bytes.
 Devuelve la dirección del bloque reasignado, la cual puede ser diferente
 de la dirección original.
 Si el bloque no puede ser reasignado o 
\family typewriter 
tam == 0
\family default 
, 
\family typewriter 
reallo()
\family default 
 devuelve 
\family typewriter 
NULL
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <alloc.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *str;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 /* asigna memoria para string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 str = malloc(10);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* copia "Hola" en string */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy(str, "Hola");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El string es %s
\backslash 
n
\protected_separator 
 Está en la dirección %p
\backslash 
n", str, str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 str = realloc(str, 20);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El string is %s
\backslash 
n
\protected_separator 
 Está en la nueva dirección %p
\backslash 
n", str, str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* libera memoria */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 free(str);
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_rotl
\protected_separator 
y
\protected_separator 
rotr (TC)
\layout Standard

Rota un valor 
\family typewriter 
unsigned int
\family default 
 a la izquierda (
\family typewriter 
_rotl
\family default 
).
 Rota un valor unsigned 
\family typewriter 
int
\family default 
 a la derecha (
\family typewriter 
_rotr
\family default 
).
 
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned _rotl(unsigned val, int cont);
\layout Quotation


\family typewriter 
unsigned _rotr(unsigned val, int cont);
\layout Standard

Estas dos funciones devuelven el valor de 
\family typewriter 
val
\family default 
 rotado cont bits.
 Ejemplo:
\layout Quotation


\family typewriter 
/* ejemplo de _rotl */
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned valor, resultado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 valor = 32767;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 resultado = _rotl(valor, 1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El valor %u rotado un bit a la izquierda es: %u
\backslash 
n", valor, resultado);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Quotation


\protected_separator 

\layout Quotation


\family typewriter 
/* ejemplo de _rotr */
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 unsigned valor, resultado;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 valor = 32767;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 resultado = _rotr(valor, 1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El valor %u rotando un bit a la derecha es: %u
\backslash 
n", valor, resultado);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
srand
\layout Standard

Inicializa el generador de números aleatorios.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void srand(unsigned semilla);
\layout Standard

La función 
\family typewriter 
srand()
\family default 
 utiliza semilla para fijar un punto de partida para el flujo generado por
 
\family typewriter 
rand()
\family default 
, que devuelve números pseudoaleatorios.
 La función 
\family typewriter 
srand()
\family default 
 se utiliza normalmente para permitir que ejecuciones múltiples de un programa
 utilicen diferentes flujos de números pseudoaleatorios.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int i;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time_t t;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 srand((unsigned) time (&t));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Diez números aleatorios entre 0 y 99
\backslash 
n
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 for(i = 0; i < 10; i++)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("%d
\backslash 
n", rand() % 100);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strtod
\layout Standard

Convierte cadena a 
\family typewriter 
double
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double strtod(const char *inic, char **fin);
\layout Standard

La función 
\family typewriter 
strtod()
\family default 
 convierte la representación de cadena de un número almacenado en la cadena
 apuntada por inic a un valor double y devuelve el resultado.
 La función 
\family typewriter 
strtod()
\family default 
 trabaja de la siguiente forma.
 Primero, se elimina cualquier carácter en blanco de la cadena apuntada
 por 
\family typewriter 
inic
\family default 
.
 A continuación cada carácter que constituye el número es leído.
 Cualquier carácter que no pueda ser parte de un número en coma flotante
 dará lugar a que el proceso se detenga.
 Esto incluye el espacio en blanco, signos de puntuación distintos del punto,
 y caracteres que no sean E o e.
 Finalmente fin se deja apuntando al resto, si lo hay, de la cadena original.
 Esto supone que si 
\family typewriter 
strtod()
\family default 
 se llama con 
\family typewriter 
"10.10abc"
\family default 
, se devuelve el valor de 
\family typewriter 
10.10
\family default 
 y fin apunta a la 
\family typewriter 
'a'
\family default 
 de 
\family typewriter 
"abc"
\family default 
.
 Si se produce un error de conversión, 
\family typewriter 
strtod()
\family default 
 devuelve 
\family typewriter 
HUGH_VAL
\family default 
 para desbordamiento por arriba (overflow) o 
\family typewriter 
HUGN_VAL
\family default 
 para desbordamiento por abajo (underflow).
 Si no se produce la conversión se devuelve 0.
 La cadena debe tener el siguiente formato:
\layout Quotation


\family typewriter 
[sb] [sn] [ddd] [.] [ddd] [fmt[sn]ddd]
\layout Standard

Todos los elementos que están entre 
\family typewriter 
[]
\family default 
 son opcionales.
\layout List
\labelwidthstring 00.00.0000

sb espacios en blanco
\layout List
\labelwidthstring 00.00.0000

sn signo (+ o -)
\layout List
\labelwidthstring 00.00.0000

ddd dígitos 
\layout List
\labelwidthstring 00.00.0000

fmt e o E 
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
.

\family default 
 punto decimal
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char entrada[80], *ptrfinal;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double valor;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Entra un número en coma flotante: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 gets(entrada);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 valor = strtod(entrada, &ptrfinal);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El string es %s y el número es %lf
\backslash 
n", entrada, valor);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strtol
\layout Standard

Conviete cadena a long usando la base fijada.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
long strtol(const char *inic, char **final, int radix);
\layout Standard

La función 
\family typewriter 
strtol()
\family default 
 convierte la representación en cadena de caracteres de un número (almacenada
 en la cadena apuntada por 
\family typewriter 
inic
\family default 
) en un número de tipo 
\family typewriter 
long int
\family default 
 y devuelve el resultado.
 La base del número está determinada por 
\family typewriter 
radix
\family default 
.
 Si 
\family typewriter 
radix
\family default 
 es 0, la base viene determinada por las reglas que gobiernan la especificación
 de constantes.
 Si 
\family typewriter 
radix
\family default 
 es distinto de 0, debe estar en el rando de 2 a 36.
 
\layout Standard

La función 
\family typewriter 
strtol()
\family default 
 trabaja de la siguiente forma.
 Primero, elimina cualquier espacio en blanco de la cadena apuntada por
 inic.
 A continuación, se lee cada uno de los caracteres que constituyen el número.
 Cualquier carácter que no pueda formar parte de un número de tipo 
\family typewriter 
long int
\family default 
 finaliza el proceso.
 Finalmente, fin se deja apuntando al resto, si lo hay, de la cadena original.
 Esto supone que si 
\family typewriter 
strtol()
\family default 
 se llama con 
\family typewriter 
"100abc"
\family default 
, se devuelve el valor 
\family typewriter 
100L
\family default 
 y fin apunta al carácter 
\family typewriter 
'a'
\family default 
 de la cadena 
\family typewriter 
"abc"
\family default 
.
\layout Standard

Si se produce un error de conversión, 
\family typewriter 
strtol()
\family default 
 devuelve 
\family typewriter 
LONG_MAX
\family default 
 en caso de desbordamiento por arriba o 
\family typewriter 
LONG_MIN
\family default 
 en caso de desbordamiento por abajo.
 Si no se produce la conversión, se devuelve 0.
 La cadena debe tener el siguiente formato:
\layout Quotation


\family typewriter 
[sb] [sn] [0] [x] [ddd]
\layout Standard

Todos los elementos que están entre 
\family typewriter 
[]
\family default 
 son opcionales.
\layout List
\labelwidthstring 00.00.0000

sb espacios en blanco
\layout List
\labelwidthstring 00.00.0000

sn signo (+ o -)
\layout List
\labelwidthstring 00.00.0000

ddd dígitos
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *cadena = "87654321", *ptrfinal;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 long numero_long;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 numero_long = strtol(cadena, &ptrfinal, 10);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("cadena = %s
\protected_separator 
 long = %ld
\backslash 
n", cadena, numero_long);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strtoul
\layout Standard

Convierte una cadena a un 
\family typewriter 
unsigned long
\family default 
 con la base fijada.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned long strtoul(const char *inic, char **final, int radix);
\layout Standard

La función 
\family typewriter 
strtoul()
\family default 
 convierte la representación de la cadena de un número almacenada en la
 cadena apuntada por 
\family typewriter 
inic
\family default 
 en un 
\family typewriter 
unsigned long int
\family default 
 y devuelve el resultado.
 La base del número está determinada por 
\family typewriter 
radix
\family default 
.
 Si 
\family typewriter 
radix
\family default 
 es 0, la base viene determinada por la regla que gobierna la especificación
 de constantes.
 Si 
\family typewriter 
radix
\family default 
 está especificada, debe tener un valor en el rango de 2 a 36.
\layout Standard

La función 
\family typewriter 
strtoul()
\family default 
 trabaja de la siguiente forma.
 Primero, cualquier espacio en blanco en la cadena apuntada por 
\family typewriter 
inic
\family default 
 es eliminado.
 A continuación, se lee cada carácter que constituye el número.
 Cualquier carácter que no pueda formar parte de un 
\family typewriter 
unsigned long int
\family default 
 da lugar a que el proceso se detenga.
 Esto incluye espacios en blanco, signos de puntuación y caracteres.
 Finalmente, fin se deja apuntando al resto, si lo hay, de la cadena original.
 Esto supone que si 
\family typewriter 
strtoul()
\family default 
 se llama con 
\family typewriter 
"100abc"
\family default 
, el valor que se devuelve es 
\family typewriter 
100L
\family default 
 y fin apunta a la 
\family typewriter 
'a'
\family default 
 de 
\family typewriter 
"abc"
\family default 
.
\layout Standard

Si se produce un error de conversión, 
\family typewriter 
strtoul()
\family default 
 devuelve 
\family typewriter 
ULONG_MAX
\family default 
 para el desbordamiento por encima o 
\family typewriter 
ULONG_MIN
\family default 
 para desbordamiento por abajo.
 Si la conversión no tiene lugar se devuelve 0.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char *cadena = "87654321", *ptrfinal;"
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned long numero_long_unsigned;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 numero_long_unsigned = strtoul(cadena, &ptrfinal, 10);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("cadena = %s
\protected_separator 
 long = %lu
\backslash 
n", cadena, numero_long_unsigned);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
swab (TC)
\layout Standard

Intercambia bytes.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void swab(char *fuente, char *destino, int nbytes);
\layout Standard

Copia nbytes bytes de fuente a destino intercambiando cada par de bytes
 adyacentes durante la transferencia.
\layout Quotation

fuente[0] = destino[1]
\layout Quotation

fuente[1] = destino[0]
\layout Quotation


\protected_separator 

\protected_separator 

\protected_separator 
 ...
\layout Standard

nbytes debería ser un número par.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este programa imprime: */
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
char fuente[15] = "rFna koBlrna d";
\layout Quotation


\family typewriter 
char destino[15];
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 swab(fuente, destino, strlen (fuente));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Este es destino: %s
\backslash 
n", destino);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
system
\layout Standard

Ejecuta un comando DOS.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int system(const char *comando);
\layout Standard

El prototipo de esta función también se encuentra en el fichero 
\family typewriter 
stdlib.h
\family default 
.
 
\family typewriter 
comando
\family default 
 puede ejecutar un comando interno del DOS tales como DIR, un fichero de
 programa 
\family typewriter 
.COM
\family default 
 o 
\family typewriter 
.EXE
\family default 
, o un fichero batch 
\family typewriter 
.BAT
\family default 
.
 Devuelve 0 en caso de éxito, -1 en caso de error y se le asigna a 
\family typewriter 
errno
\family default 
 uno de los siguientes valores: 
\family typewriter 
ENOENT
\family default 
, 
\family typewriter 
ENOMEM
\family default 
, 
\family typewriter 
E2BIG
\family default 
 o 
\family typewriter 
ENOEXEC
\family default 
.
 La función 
\family typewriter 
system()
\family default 
 también se encuentra declarada en los ficheros 
\family typewriter 
process.h
\family default 
 y 
\family typewriter 
system.h
\family default 
.
 En el fichero 
\family typewriter 
system.h
\family default 
 sólo se encuentra el prototipo de la función 
\family typewriter 
system()
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 system("dir");
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
ultoa (TC)
\layout Standard

Convierte un unsigned long a una cadena.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *ultoa(unsigned long valor, char *cadena, int radix);
\layout Standard

Devuelve un puntero a la cadena.
 No devuelve error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 unsigned long numero_unsigned_long = 3123456789L;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char cadena[25];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 ultoa(numero_unsigned_long, cadena, 10);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("cadena = %s
\protected_separator 
 unsigned long = %lu
\backslash 
n", cadena, numero_unsigned_long);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\newline 

\layout Title


\size huge 
Constantes, Tipos de Datos y Variables Globales
\layout Description


\size largest 
div_t (tipo)
\layout Standard

Tipo devuelto por la división entera.
\layout Quotation


\family typewriter 
typedef struct { int quot, rem; } div_t;
\layout Description


\size largest 
_doserrno (variable global)
\protected_separator 
 (TC)
\layout Standard

Variable que indica el código de error del DOS actual.
\layout Quotation


\family typewriter 
int _doserrno;
\layout Standard

Cuando en una llamada al sistema MS-DOS ocurre un error, a 
\family typewriter 
_doserrno
\family default 
 se le asigna el código de error DOS actual.
 Los mnemotécnicos para los códigos de error de DOS actual que pueden ser
 asignados a _doserrno son:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
17 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Mnemotécnico
\newline 
Código de error del DOS
\series default 

\newline 
E2BIG
\newline 
Entorno malo
\newline 
EACCES
\newline 
Acceso denegado
\newline 
EACCES
\newline 
Acceso malo
\newline 
EACCES
\newline 
Es directorio corriente
\newline 
EBADF
\newline 
Manejador malo
\newline 
EFAULT
\newline 
Reservado
\newline 
EINVAL
\newline 
Datos malos
\newline 
EINVAL
\newline 
Función mala
\newline 
EMFILE
\newline 
Demasiados ficheros abiertos
\newline 
ENOENT
\newline 
No es fichero ni directorio
\newline 
ENOEXEC
\newline 
Formato malo
\newline 
ENOMEM
\newline 
MCB destruido
\newline 
ENOMEM
\newline 
Fuera de memoria
\newline 
ENOMEM
\newline 
Bloque malo
\newline 
EXDEV
\newline 
Unidad mala
\newline 
EXDEV
\newline 
No es el mismo dispositivo
\layout Standard

Esta variable también está declarada en los ficheros 
\family typewriter 
errno.h
\family default 
 y 
\family typewriter 
dos.h
\family default 
.
\layout Description


\size largest 
environ (variable global)
\protected_separator 

\protected_separator 
 (TC)
\layout Standard

Array de cadenas usado para acceder y alterar el entorno del proceso.
\layout Quotation


\family typewriter 
extern char **environ
\layout Standard

También se encuentra declarada en el fichero 
\family typewriter 
dos.h
\family default 
.
\layout Description


\size largest 
errno (global variable)
\protected_separator 

\protected_separator 
 (TC)
\layout Standard

Variable que indica el tipo de error.
\layout Quotation


\family typewriter 
int errno;
\layout Standard

Siempre que ocurre un error en una llamada al sistema, a 
\family typewriter 
errno
\family default 
 se le asigna un código de error que indica el tipo de error ocurrido.
 En Turbo C, definido también en los ficheros 
\family typewriter 
errno.h
\family default 
 y 
\family typewriter 
stddef.h
\family default 
.
\layout Description


\size largest 
EXIT_xxxx (#defines)
\protected_separator 

\protected_separator 
 (TC)
\layout Standard

Constantes que definen condiciones de salida para las llamadas a la función
 
\family typewriter 
exit()
\family default 
.
\layout Quotation

EXIT_SUCCESS Terminación normal de un programa.
\layout Quotation

EXIT_FAILURE Terminación anormal de un programa.
\layout Description


\size largest 
_fmode (variable global)
\protected_separator 

\protected_separator 
 (TC)
\layout Standard

Modo por defecto de traslación de fichero.
\layout Quotation


\family typewriter 
int _fmode;
\layout Standard

Al comienzo tiene el valor de 
\family typewriter 
O_TEXT
\family default 
 por defecto.
 Definida también en el fichero 
\family typewriter 
fcntl.h
\family default 
.
\layout Description


\size largest 
ldiv_t (type)
\layout Standard

Tipo devuelto por la división de enteros largos.
\layout Quotation


\family typewriter 
typedef struct { long quot, rem; } ldiv_t;
\layout Description


\size largest 
NULL (#define)
\layout Standard

Valor de puntero nulo.
 En Turbo C, definido también en los ficheros 
\family typewriter 
alloc.h
\family default 
, 
\family typewriter 
mem.h
\family default 
, 
\family typewriter 
stddef.h
\family default 
 y 
\family typewriter 
stdio.h
\family default 
.
\layout Description


\size largest 
_psp (variable global)
\protected_separator 

\protected_separator 
 (TC)
\layout Standard

Dirección del segmento del PSP (Prefijo de Segmento de Programa) del programa.
\layout Quotation


\family typewriter 
extern unsigned int _psp;
\layout Standard

También está declarada en los ficheros 
\family typewriter 
process.h
\family default 
 y 
\family typewriter 
dos.h
\family default 
.
\layout Description


\size largest 
RAND_MAX (#define)
\layout Standard

Valor máximo devuelto por la función 
\family typewriter 
rand()
\family default 
.
\layout Description


\size largest 
size_t (tipo)
\layout Standard

Tipo usado para los tamaños de objeto de memoria y contadores de bucles.
 En Turbo C, definido también en los ficheros 
\family typewriter 
alloc.h
\family default 
, 
\family typewriter 
mem.h
\family default 
, 
\family typewriter 
stddef.h
\family default 
, 
\family typewriter 
stdio.h
\family default 
 y 
\family typewriter 
string.h
\family default 
.
\layout Description


\size largest 
sys_errlist (variable global)
\protected_separator 

\protected_separator 
 (TC)
\layout Standard

Array de cadenas de mensajes.
\layout Quotation


\family typewriter 
char *sys_errlist[]
\layout Standard

Esta variable es un array de cadenas de mensajes que corresponden a 
\family typewriter 
errno
\family default 
 y es usada por la función 
\family typewriter 
perror()
\family default 
.
 Los mnemotécnicos y sus significados para los valores almacenados en 
\family typewriter 
sys_errlist
\family default 
 son:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
29 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Mnemotécnico
\newline 
Significado
\series default 

\newline 
E2BIG
\newline 
Lista de argumentos demasiado larga
\newline 
EACCES
\newline 
Permiso denegado
\newline 
EBADF
\newline 
Número malo de fichero
\newline 
ECONTR
\newline 
Bloques de memoria destruidos
\newline 
ECURDIR
\newline 
Intento de quitar el directorio actual
\newline 
EDOM
\newline 
Error de dominio
\newline 
EEXIST
\newline 
El fichero ya existe
\newline 
EFAULT
\newline 
Error desconocido
\newline 
EINVACC
\newline 
Código de acceso no válido
\newline 
EINVAL
\newline 
Argumento no válido
\newline 
EINVDAT
\newline 
Datos no válidos
\newline 
EINVDRV
\newline 
Unidad especificada no válida
\newline 
EINVENV
\newline 
Entorno no válido
\newline 
EINVFMT
\newline 
Formato no válido
\newline 
EINVFNC
\newline 
Número de función no válido
\newline 
EINVMEM
\newline 
Dirección de bloque de memoria no válido
\newline 
EMFILE
\newline 
Demasiados ficheros abiertos
\newline 
ENMFILE
\newline 
No más ficheros
\newline 
ENODEV
\newline 
No como dispositivo
\newline 
ENOENT
\newline 
No como fichero o directorio
\newline 
ENOEXEC
\newline 
Error de formato de exec
\newline 
ENOFILE
\newline 
No como fichero o directorio
\newline 
ENOMEM
\newline 
No hay suficiente memoria
\newline 
ENOPATH
\newline 
Path no encontrado
\newline 
ENOTSAM
\newline 
No es el mismo dispositivo
\newline 
ERANGE
\newline 
Resultado fuera de rango
\newline 
EXDEV
\newline 
Cross-device link
\newline 
EZERO
\newline 
Error 0
\layout Description


\size largest 
sys_nerr (variable global)
\protected_separator 

\protected_separator 
 (TC)
\layout Standard

Número de cademas de mensajes de error.
\layout Quotation


\family typewriter 
int sys_nerr;
\layout Standard

Esta variable contiene el número de cadenas de mensajes de error en 
\family typewriter 
sys_errlist
\family default 
.
\layout Section

Funciones de Hora y Fecha
\layout Standard

El estándar ANSI define varias funciones que utilizan la fecha y hora del
 sistema al igual que el tiempo transcurrido.
 Estas funciones requieren la cabecera 
\family typewriter 
<time.h>
\family default 
 en la declaración de funciones y también define algunos tipos.
 Los tipos 
\family typewriter 
clock_t
\family default 
 y 
\family typewriter 
time_t
\family default 
 permiten representar la hora y fecha del sistema como un entero extendido.
 El estándar ANSI se refiere a este tipo de representación como hora de
 calendario.
 El tipo de estructura 
\family typewriter 
tm
\family default 
 mantiene la fecha y la hora separada en sus componentes.
 Además, 
\family typewriter 
time.h
\family default 
 define la macro 
\family typewriter 
CLK_TCK
\family default 
 que es el número de pulsos de reloj del sistema por segundo.
\layout Subsection

Fichero de Cabecera time.h
\layout Description


\size largest 
asctime
\layout Standard

Convierte fecha y hora a ASCII.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *asctime (const struct tm *punt);
\layout Standard

La función 
\family typewriter 
asctime()
\family default 
 devuelve un puntero a una cadena que convierte la información almacenada
 en la estructura apuntada por 
\family typewriter 
punt
\family default 
 de la siguiente forma:
\layout Quotation

nombre_de_dia nombre_del_mes dia_del_mes horas:minutos:segundos año
\backslash 
n
\backslash 
0
\layout Standard

El puntero a estructura pasado a 
\family typewriter 
asctime()
\family default 
 se obtiene normalmente de 
\family typewriter 
localtime()
\family default 
 o 
\family typewriter 
gmtime()
\family default 
.
 El buffer utilizado por 
\family typewriter 
asctime()
\family default 
 para mantener la cadena de salida con formato se sitúa estáticamente en
 un array de caracteres y se sobreescribe cada vez que se llama a la función.
 Si se desea salvar el contenido de la cadena, es necesario copiarlo en
 otro lugar.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <string.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct tm t;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 char str[80];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t.tm_sec
\protected_separator 

\protected_separator 

\protected_separator 
 = 1;
\protected_separator 
 /* Segundos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t.tm_min
\protected_separator 

\protected_separator 

\protected_separator 
 = 30; /* Minutos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t.tm_hour
\protected_separator 

\protected_separator 
 = 9;
\protected_separator 
 /* Hora */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t.tm_mday
\protected_separator 

\protected_separator 
 = 22; /* Día del mes */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t.tm_mon
\protected_separator 

\protected_separator 

\protected_separator 
 = 11; /* Mes */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t.tm_year
\protected_separator 

\protected_separator 
 = 56; /* Año - no incluye centenas */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t.tm_wday
\protected_separator 

\protected_separator 
 = 4;
\protected_separator 
 /* Día de la semana */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t.tm_yday
\protected_separator 

\protected_separator 
 = 0;
\protected_separator 
 /* No mostrado en asctime */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t.tm_isdst
\protected_separator 
 = 0;
\protected_separator 
 /* Es horario de verano; no mostrado en asctime */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strcpy (str, asctime (&t));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf ("%s
\backslash 
n", str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
clock
\layout Standard

Devuelve el número de pulsos de reloj desde el comienzo del programa.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
clock_t clock(void);
\layout Standard

Devuelve el tiempo de procesador usado desde el comienzo de la ejecución
 del programa medido en pulsos de reloj.
 Para transformar este valor en segundos, se divide entre 
\family typewriter 
CLK_TCK
\family default 
.
 Se devuelve el valor -1 si el tiempo no está disponible.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 clock_t comienzo, final;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 comienzo = clock();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 delay (2000);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 final = clock();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El tiempo transcurrido ha sido: %f segundos.
\backslash 
n", (final - comienzo) / CLK_TCK);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
ctime
\layout Standard

Convierte fecha y hora a una cadena.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *ctime(const time_t *time);
\layout Standard

Esta función es equivalente a:
\layout Quotation


\family typewriter 
asctime(localtime (hora));
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time_t t;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time(&t);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("La fecha y hora de hoy es: %s
\backslash 
n", ctime(&t));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
difftime
\layout Standard

Calcula la diferencia entre dos horas.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
double difftime(time_t hora2, time_t hora1);
\layout Standard

Devuelve la diferencia, en segundos, entre hora1 y hora2.
 Es decir hora2-hora1.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <dos.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time_t primero, segundo;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 primero = time(NULL); /* Obtiene hora del sistema */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 delay (2000); /* Espera 2 segundos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 segundo = time(NULL); /* Obtiene otra vez la hora del sistema */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("La diferencia es: %f segundos
\backslash 
n", difftime (segundo, primero));
\layout Quotation


\family typewriter 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
gmtime
\layout Standard

Convierte fecha y hora a hora de Greenwich.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
struct tm *gmtime(const time_t *hora);
\layout Standard

La función 
\family typewriter 
gmtime()
\family default 
 devuelve un puntero a la forma de hora en una estructura 
\family typewriter 
tm
\family default 
.
 La hora está representada en hora de Greenwich.
 El valor de hora se obtiene normalmente a través de una llamada a 
\family typewriter 
time()
\family default 
.
 La estructura utilizada por 
\family typewriter 
gmtime()
\family default 
 mantiene la hora separada en una posición estática y se sobreescribe en
 ella cada vez que se llama a la función.
 Si se desea guardar el contenido de la estructura, es necesario copiarlo
 a otro lugar.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct tm *local, *gm;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time_t t;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t = time(NULL);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 local = localtime (&t);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Hora y fecha local: %s", asctime (local));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 gm = gmtime(&t);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Hora y fecha según Greenwich: %s", asctime (gm));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
localtime
\layout Standard

Convierte fecha y hora a una estructura.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
struct tm *localtime(const time_t *hora);
\layout Standard

La función 
\family typewriter 
localtime()
\family default 
 devuelve un puntero a la forma esperada de hora en la estructura 
\family typewriter 
tm
\family default 
.
 La hora se representa en la hora local.
 El valor hora se obtiene normalmente a través de una llamada a 
\family typewriter 
time()
\family default 
.
 La estructura utilizada por 
\family typewriter 
localtime()
\family default 
 para mantener la hora separada está situada de forma estática y se reescribe
 cada vez que se llama a la función.
 Si se desea guardar el contenido de la estructura, es necesario copiarla
 en otro lugar.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time_t hora;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct tm *bloquet;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* obtiene hora actual */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 hora = time(NULL);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* convierte fecha/hora a una estructura */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 bloquet = localtime (&hora);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("La hora local es: %s", asctime (bloquet));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
mktime
\layout Standard

Convierte hora a formato de calendario.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
time_t mktime(struct tm *t);
\layout Standard

La función 
\family typewriter 
mktime()
\family default 
 devuelve la hora de calendario equivalente a la hora separada que se encuentra
 en la estructura apuntada por hora.
 Esta función se utiliza principalmente para inicializar el sistema.
 Los elementos 
\family typewriter 
tm_wday
\family default 
 y 
\family typewriter 
tm_yday
\family default 
 son activados por la función, de modo que no necesitan ser definidos en
 el momento de la llamada.
 Si 
\family typewriter 
mktime()
\family default 
 no puede representar la información como una hora de calendario válida,
 se devuelve -1.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
char *dia_semana[] = { "Domingo", "Lunes", "Martes", "Miércoles", "Jueves",
 "Viernes", "Sábado", "Desconocido" };
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct tm chequeo_de_hora;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 int anio, mes, dia;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* lee dia, mes y anio para encontrar el día de la semana */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Día:
\protected_separator 

\protected_separator 
 ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 scanf("%d", &dia);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Mes: ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 scanf("%d", &mes);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Año:
\protected_separator 
 ");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 scanf("%d", &anio);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* carga la estructura chequeo_de_hora con los datos */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 chequeo_de_hora.tm_year = anio - 1900;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 chequeo_de_hora.tm_mon
\protected_separator 
 = mes - 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 chequeo_de_hora.tm_mday = dia;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 chequeo_de_hora.tm_hour = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 chequeo_de_hora.tm_min
\protected_separator 
 = 0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 chequeo_de_hora.tm_sec
\protected_separator 
 = 1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 chequeo_de_hora.tm_isdst = -1;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* llama a mktime() para rellenear el campo weekday de la estructura */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(mktime (&chequeo_de_hora) == -1)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 chequeo_de_hora.tm_wday = 7;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* imprime el día de la semana */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Este día es %s
\backslash 
n", dia_semana [chequeo_de_hora.tm_wday]);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
stime (TC)
\layout Standard

Pone fecha y hora del sistema.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int stime(time_t *pt);
\layout Standard

Devuelve el valor 0.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 time_t t;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t = time(NULL);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Número de segundos desde 1-1-1970: %ld
\backslash 
n", t);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Hora local: %s", asctime (localtime (&t)));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t++;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Añadido un segundo: %s", asctime (localtime (&t)));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t += 60;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Añadido un minuto : %s", asctime (localtime (&t)));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t += 3600;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Añadido una hora
\protected_separator 
 : %s", asctime (localtime (&t)));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t += 86400L;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Añadido un día
\protected_separator 

\protected_separator 

\protected_separator 
 : %s", asctime (localtime (&t)));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t += 2592000L;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Añadido un mes
\protected_separator 

\protected_separator 

\protected_separator 
 : %s", asctime (localtime (&t)));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t += 31536000L;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Añadido un año
\protected_separator 

\protected_separator 

\protected_separator 
 : %s", asctime (localtime (&t)));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
strftime
\layout Standard

Formatea hora para salida.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
size_t strftime(char *cad, size_t maxtam, const char *fmt, const struct
 tm *t);
\layout Standard

La función 
\family typewriter 
strftime()
\family default 
 sitúa la hora y la fecha (junto con otra información) en la cadena apuntada
 por 
\family typewriter 
cad
\family default 
.
 La información se sitúa de acuerdo a las órdenes de formato que se encuentran
 en la cadena apuntada por 
\family typewriter 
fmt
\family default 
 y en la forma de hora separada 
\family typewriter 
t
\family default 
.
 Se sitúan un máximo de maxtam caracteres en 
\family typewriter 
cad
\family default 
.
 La función 
\family typewriter 
strftime()
\family default 
 trabaja de forma algo parecida a 
\family typewriter 
sprintf()
\family default 
 en el que se reconoce un conjunto de órdenes de formato que comienzan con
 el signo de porcentaje (
\family typewriter 
%
\family default 
) y sitúa su salida con formato en una cadena.
 Las órdenes de formato se utilizan para especificar la forma exacta en
 que se representan diferentes informaciones de hora y fecha en 
\family typewriter 
cad
\family default 
.
 Cualquier otro carácter que se encuentre en la cadena de formato se pone
 en cad sin modificar.
 La hora y fecha presentadas están en hora local.
 Las órdenes de formato se presentan en la siguiente tabla.
 Observa que muchas órdenes distinguen entre mayúsculas y minúsculas.
 La función 
\family typewriter 
strftime()
\family default 
 devuelve el número de caracteres situados en la cadena apuntada por 
\family typewriter 
cad
\family default 
.
 Si se produce un error, la función devuelve 0.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
23 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""


\series bold 
Orden
\newline 
Substituida por
\series default 

\newline 
%a
\newline 
Día de la semana en abreviatura
\newline 
%A
\newline 
Día de la semana completo
\newline 
%b
\newline 
Abreviatura del mes
\newline 
%B
\newline 
Nombre del mes completo
\newline 
%c
\newline 
Cadena de hora y fecha estándar
\newline 
%d
\newline 
Día del mes en número (1-31)
\newline 
&H
\newline 
Hora, rango (0-23)
\newline 
%I
\newline 
Hora, rango (1-12)
\newline 
%j
\newline 
Día del año en número (1-366)
\newline 
%m
\newline 
Mes en número (1-12)
\newline 
%M
\newline 
Minuto en número (0-59)
\newline 
%p
\newline 
Equivalencia de lugar de AM y PM
\newline 
%S
\newline 
Segundos en número (0-59)
\newline 
%U
\newline 
Semana del año, domingo primer día (0-52)
\newline 
%w
\newline 
Día de la semana (0-6, domingo provoca 0)
\newline 
%W
\newline 
Semana del año, lunes primer día (0-52)
\newline 
%x
\newline 
Cadena de fecha estándar
\newline 
%X
\newline 
Cadena de hora estándar
\newline 
%y
\newline 
Año en número sin centenas (00-99)
\newline 
%Y
\newline 
Año completo en número
\newline 
%Z
\newline 
Nombre de zona temporal
\newline 
%%
\newline 
Signo de tanto por ciento
\layout Standard

Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct tm *hora_act;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time_t segs_act;
\layout Quotation


\family typewriter 

\protected_separator 
 char str[80];
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time(&segs_act);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 hora_act = localtime(&segs_act);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 strftime(str, 80, "Ahora son las %H %p del %d-%m-%y.", hora_act);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("%s
\backslash 
n", str);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
time
\layout Standard

Obtiene la hora actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
time_t time(time_t *hora);
\layout Standard

La función 
\family typewriter 
time()
\family default 
 devuelve la hora actual de calendario del sistema.
 Si el sistema no tiene hora, devuelve -1.
 La función 
\family typewriter 
time()
\family default 
 puede llamarse con un puntero nulo o con un puntero a una variable de tipo
 
\family typewriter 
time_t
\family default 
.
 Si se utiliza este último, el argumento es también asignado a la hora de
 calendario.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time_t t;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 t = time(NULL);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("El número de segundos transcurridos desde el 1 de Enero "
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 "de 1970 es %ld", t);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
tzset (TC)
\layout Standard

Para compatibilidad con hora de UNIX; da valores a las variables globales
 
\family typewriter 
daylight
\family default 
, 
\family typewriter 
timezone
\family default 
 y 
\family typewriter 
tzname
\family default 
.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void tzset(void);
\layout Standard


\family typewriter 
tzset()
\family default 
 espera encontrar una cadena de entorno de la forma 
\family typewriter 
TZ=...

\family default 
 que define la zona horaria.
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
#include <stdlib.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time_t td;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* Pacific Standard Time & Daylight Savings */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 putenv("TZ=PST8PDT");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 tzset();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 time(&td);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Hora actual = %s
\backslash 
n", asctime (localtime (&td)));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\family default 
 
\family typewriter 

\newline 

\layout Description


\size largest 
Constantes,
\protected_separator 
Tipos
\protected_separator 
de
\protected_separator 
Datos
\protected_separator 
y
\protected_separator 
Variables
\protected_separator 
Globales
\layout Description


\size largest 
clock_t (tipo)
\layout Standard

Este tipo de datos devuelto por la función 
\family typewriter 
clock()
\family default 
 almacena un tiempo transcurrido medido en pulsos de reloj.
 La constante 
\family typewriter 
CLK_TCK
\family default 
 define el número de pulsos de reloj por segundo.
\layout Description


\size largest 
daylight (global variable)
\layout Standard

Indica si se harán ajustes de horario de verano.
\layout Quotation


\family typewriter 
int daylight;
\layout Standard

Las funciones de hora y fecha usan 
\family typewriter 
dylight
\family default 
.
\layout Description


\size largest 
time_t (tipo)
\layout Standard

Este tipo de variable define el valor usado por las funciones de tiempo.
 En Turbo C, también está declarado en 
\family typewriter 
sys
\backslash 
types.h
\family default 
.
 El fichero 
\family typewriter 
sys
\backslash 
types.h
\family default 
 únicamente contiene la declaración de este tipo.
\layout Description


\size largest 
timezone (variable global)
\layout Standard

Diferencia en segundos entre hora local y hora del meridiano de Greenwich.
 
\layout Quotation


\family typewriter 
extern long timezone;
\layout Standard

Usada por las funciones de hora y fecha.
\layout Description


\size huge 
TM (struct)
\layout Standard

Describe una estructura que contiene una fecha y hora separada en sus componente
s.
\layout Quotation


\family typewriter 
struct tm
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int tm_sec;
\protected_separator 

\protected_separator 
 /* segundos, 0-59
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int tm_min;
\protected_separator 

\protected_separator 
 /* minutos, 0-59
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int tm_hour;
\protected_separator 
 /* horas, 0-23
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int tm_mday;
\protected_separator 
 /* día del mes, 1-31
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int tm_mon;
\protected_separator 

\protected_separator 
 /* mes, 0-11, Enero = 0
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int tm_year;
\protected_separator 
 /* año, año actual menos 1900
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int tm_wday;
\protected_separator 
 /* día de la semana, 0-6, Domingo = 0 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int tm_yday;
\protected_separator 
 /* día del año, 0-365, 1 de Enero = 0 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int tm_isdst; /* indicador de horario de verano
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Description


\size largest 
tzname (variable global)
\protected_separator 

\protected_separator 
 (TC)
\layout Standard

Array de punteros a cadenas.
\layout Quotation


\family typewriter 
extern char * tzname[2]
\layout Description

NOTA: esta variable está declarada en el fichero 
\family typewriter 
io.h
\family default 
, no en éste (
\family typewriter 
time.h
\family default 
).
 Un array de punteros a cadenas conteniendo las abreviaciones para los nombres
 de zonas horarias.
\layout Section

Funciones Relacionadas con Información Geográfica
\layout Standard

El fichero de cabecera 
\family typewriter 
<locale.h>
\family default 
 declara funciones que proporcionan información específica de los len guajes
 y países.
\layout Subsection

Fichero de Cabecera locale.h
\layout Description


\size largest 
localeconv (TC)
\layout Standard

Devuelve un puntero a la estructura de lugar actual.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
struct lconv *localeconv(void);
\layout Standard

localeconv pone la moneda específica del país y otros formatos numéricos.
 Sin embargo, Borland C++ actualmente sólo soporta el lugar C.
\layout Description


\size largest 
setlocale
\layout Standard

Selecciona el lugar.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
char *setlocale (int categoria, char *lugar);
\layout Standard

La función 
\family typewriter 
setlocale()
\family default 
 permite al usuario pedir o activar ciertos parámetros que son sensibles
 al lugar donde se utiliza el programa.
 Por ejemplo, en Europa, la coma se utiliza en lugar del punto decimal;
 del mismo modo los formatos de la hora y la fecha difieren.
 Si lugar es nulo, 
\family typewriter 
setlocale()
\family default 
 devuelve un puntero a la actual cadena de localización.
 En cualquier otro caso, 
\family typewriter 
setlocale()
\family default 
 intenta utilizar la cadena de localización especificada para poner los
 parámetros de lugar según se especifica en categoria.
 En el momento de la llamada, categoria debe de ser una de las siguientes
 macros:
\layout Quotation

LC_ALL
\layout Quotation

LC_COLLATE
\layout Quotation

LC_CTYPE
\layout Quotation

LC_MONETARY
\layout Quotation

LC_NUMERIC
\layout Quotation

LC_TIME
\layout Standard


\family typewriter 
LC_ALL
\family default 
 hace referencia a todas las categorías de localización.
 
\family typewriter 
LC_COLLATE
\family default 
 afecta a la operación de la función 
\family typewriter 
strcoll()
\family default 
.
 
\family typewriter 
LC_CTYPE
\family default 
 modifica la forma de trabajo de las funciones de caracteres.
 
\family typewriter 
LC_NUMERIC
\family default 
 cambia el carácter del punto decimal para las funciones de entrada/salida
 con formato.
 Finalmente, 
\family typewriter 
LC_TIME
\family default 
 determina el comportamiento de la función 
\family typewriter 
strftime()
\family default 
.
\layout Standard

El estándar define dos posibles cadenas para lugar.
 La primera es C, que especifica el mínimo entorno para la compilación de
 C.
 El segundo es , la cadena vacía, que especifica el entorno de implementación
 definido por defecto.
 El resto de los valores para 
\family typewriter 
locale()
\family default 
 están definidos por la implementación y afectan a la portabilidad.
 En Borland C++ (compilador con el que se ha desarrollado este programa),
 el único lugar soportado es "C".
 Ejemplo:
\layout Quotation


\family typewriter 
#include <locale.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Lugar activo actualmente: %s", setlocale (LC_ALL, "C"));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
LCONV (struct)
\layout Quotation


\family typewriter 
struct lconv
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *decimal_point;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *thousands_sep;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *grouping;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *int_curr_symbol;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *currency_symbol;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *mon_decimal_point;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *mon_thousands_sep;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *mon_grouping;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *positive_sign;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char *negative_sign;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char int_frac_digits;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char frac_digits;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char p_cs_precedes;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char p_sep_by_space;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char n_cs_precedes;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char n_sep_by_space;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char p_sign_posn;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 char n_sign_posn;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Section

Función y Estructura de Hora Actual
\layout Standard

El fichero de cabecera 
\family typewriter 
<sys
\backslash 
timeb.h>
\family default 
 de Turbo C declara la función 
\family typewriter 
ftime()
\family default 
 y la estructura 
\family typewriter 
timeb
\family default 
 
\protected_separator 
 para obtener la hora actual.
\layout Subsection

Fichero de Cabecera sys
\backslash 
timeb.h (TC) 
\layout Description


\size largest 
ftime
\layout Standard

Almacena hora actual en la estructura timeb.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void ftime(struct timeb *buf);
\layout Description


\size largest 
TIMEB (struct)
\layout Standard

Información de hora actual rellenada por la función 
\family typewriter 
ftime()
\family default 
.
\layout Quotation


\family typewriter 
struct timeb
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long time ; /* segundos desde 1-1-70 hora Greenwitch */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short millitm ; /* fracción de segundo (en milisegundos) */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short timezone ; /* diferencia entre hora local y hora Greenwitch */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short dstflag ; /* 0 si no es horario de verano */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 } ;
\layout Section

Funciones de Información de Ficheros
\layout Standard

El fichero de cabecera 
\family typewriter 
<sys
\backslash 
stat.h>
\family default 
 de Turbo C declara dos funciones que obtienen información de un fichero
 abierto: 
\family typewriter 
fstat()
\family default 
 y 
\family typewriter 
stat()
\family default 
.
 Además define la estructura 
\family typewriter 
stat
\family default 
 que contiene la información sobre los ficheros y también define una serie
 de constantes para identificar el estado de los ficheros.
\layout Subsection

Fichero de Cabecera sys
\backslash 
stat.h (TC) 
\layout Description


\size largest 
fstat
\layout Standard

Obtiene información del fichero abierto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int fstat (int descriptor, struct stat *statbuf);
\layout Standard

Devuelve 0 si tiene éxito; o -1 en caso de error y se pone en 
\family typewriter 
errno
\family default 
 el número de error.
\layout Quotation


\family typewriter 
#include <sys
\backslash 
stat.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 struct stat statbuf;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 FILE *stream;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if((stream = fopen ("DUMMY.FIL", "w+")) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 fprintf(stderr, "No se puede abrir el fichero.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 return (1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fprintf(stream, "Esto es una prueba.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fflush(stream);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fstat(fileno (stream), &statbuf);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fclose(stream);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(statbuf.st_mode & S_IFCHR)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El descriptor se refiere a un dispositivo.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(statbuf.st_mode & S_IFREG)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El descriptor se refiere a un fichero ordinario.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(statbuf.st_mode & S_IREAD)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El usuario tiene permiso de lectura sobre el fichero.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(statbuf.st_mode & S_IWRITE)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El usuario tiene permiso de escritura sobre el fichero.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Letra de la unidad del fichero: %c
\backslash 
n", 'A'+statbuf.st_dev);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Tamaño del fichero en bytes: %ld
\backslash 
n", statbuf.st_size);
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Hora de la última apertura del fichero: %s
\backslash 
n", ctime (&statbuf.st_ctime));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
stat
\layout Standard

Obtiene información acerca del fichero abierto.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
int stat(char *path, struct stat *statbuf);
\layout Standard

Devuelve 0 si tiene éxito; o -1 en caso de error y se pone en 
\family typewriter 
errno
\family default 
 el número de error.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <sys
\backslash 
stat.h>
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <time.h>
\layout Quotation


\family typewriter 
#define NOMBREFICHERO "TEST.$$$"
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 
 struct stat statbuf;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 FILE *stream;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if((stream = fopen (NOMBREFICHERO, "w+")) == NULL)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 fprintf(stderr, "No se puede abrir el fichero.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 return (1);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 stat(NOMBREFICHERO, &statbuf);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 fclose(stream);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(statbuf.st_mode & S_IFCHR)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El descriptor se refiere a un dispositivo.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(statbuf.st_mode & S_IFREG)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El descriptor se refiere a un fichero ordinario.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(statbuf.st_mode & S_IREAD)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El usuario tiene permiso de lectura sobre el fichero.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(statbuf.st_mode & S_IWRITE)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("El usuario tiene permiso de escritura sobre el fichero.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Letra de la unidad del fichero: %c
\backslash 
n", 'A'+statbuf.st_dev);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Tamaño del fichero en bytes: %ld
\backslash 
n", statbuf.st_size);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Hora de la última apertura del fichero: %s
\backslash 
n",
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 ctime(&statbuf.st_ctime));
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
S_Ixxxx (#defines)
\layout Standard

Definiciones usadas por las funciones de directorio y estado de fichero.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
9 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

S_IFMT
\newline 
Máscara de tipo de fichero
\newline 
S_IFDIR
\newline 
Directorio
\newline 
S_IFIFO
\newline 
FIFO especial
\newline 
S_IFCHR
\newline 
Carácter especial
\newline 
S_IFBLK
\newline 
Bloque especial
\newline 
S_IFREG
\newline 
Fichero regular
\newline 
S_IREAD
\newline 
Poseedor puede leer
\newline 
S_IWRITE
\newline 
Poseedor puede escribir
\newline 
S_IEXEC
\newline 
Poseedor puede ejecutar
\layout Description


\size largest 
STAT (struct)
\layout Standard

Describe una estructura que contiene información acerca de un fichero o
 directorio.
\layout Quotation


\family typewriter 
struct stat
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short
\protected_separator 
 st_dev,
\protected_separator 

\protected_separator 
 st_ino;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short
\protected_separator 
 st_mode,
\protected_separator 
 st_nlink;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 int
\protected_separator 

\protected_separator 

\protected_separator 
 st_uid,
\protected_separator 

\protected_separator 
 st_gid;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 short
\protected_separator 
 st_rdev;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long
\protected_separator 

\protected_separator 
 st_size,
\protected_separator 
 st_atime;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 long
\protected_separator 

\protected_separator 
 st_mtime, st_ctime;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 };
\layout Section

Constantes Simbólicas para Compatibilidad con UNIX 
\layout Standard

El fichero de cabecera 
\family typewriter 
<values.h>
\family default 
 de Turbo C define constantes compatibles con UNIX para valores límite de
 los tipos 
\family typewriter 
float
\family default 
 y 
\family typewriter 
double
\family default 
.
\layout Subsection

Fichero de Cabecera values.h (TC) 
\layout Description


\size largest 
BITSPERBYTE (#define)
\layout Standard

Número de bits en un byte.
\layout Description


\size largest 
Límites
\protected_separator 
float
\protected_separator 
y
\protected_separator 
double (#defines)
\layout Standard

UNIX System V compatible:
\layout List
\labelwidthstring 00.00.0000

_LENBASE Base a la que aplicar exponente
\layout Description

Límites
\protected_separator 
para
\protected_separator 
valores
\protected_separator 

\family typewriter 
float
\protected_separator 

\family default 
y
\protected_separator 

\family typewriter 
double
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
7 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

_DEXPLEN
\newline 
Número de bits en exponente
\newline 
DMAXEXP
\newline 
Máximo exponente permitido
\newline 
DMAXPOWTWO
\newline 
Potencia de dos más grande permitida
\newline 
DMINEXP
\newline 
Mínimo exponente permitido
\newline 
DSIGNIF
\newline 
Número de bits significativos
\newline 
MAXDOUBLE
\newline 
Valor double más grande
\newline 
MINDOUBLE
\newline 
Valor double más pequeño
\layout Description

Límites
\protected_separator 
para
\protected_separator 
valores
\protected_separator 

\family typewriter 
float
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
7 2 0 0 -1 -1 -1 -1
1 1 0 0
0 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 "" ""
2 1 1 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""

_FEXPLEN
\newline 
Número de bits en exponente
\newline 
FMAXEXP
\newline 
Máximo exponente permitido
\newline 
FMAXPOWTWO
\newline 
Potencia de dos más grande permitida
\newline 
FMINEXP
\newline 
Mínimo exponente permitido
\newline 
FSIGNIF
\newline 
Número de bits significativos
\newline 
MAXFLOAT
\newline 
Valor float más grande
\newline 
MINFLOAT
\newline 
Valor float más pequeño
\layout Section

Funciones de Coma Flotante
\layout Standard

En el fichero de cabecera 
\family typewriter 
<float.h>
\family default 
 de Turbo C están definidas una serie de funciones relacionadas con el coprocesa
dor matemático o con el emulador en su defecto, esto es, con las operaciones
 de coma flotante.
\layout Subsection

Fichero de Cabecera float.h (TC) 
\layout Description


\size largest 
_clear87
\layout Standard

Borra el estado de coma flotante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned int _clear87(void);
\layout Standard

Los bits del valor devuelto indican el viejo estado de coma flotante.
 Para obtener información acerca de los estados, ver las constantes definidas
 en el fichero de cabecera 
\family typewriter 
float.h
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <float.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 float x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 double y = 1.5e-100;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nEstado antes del error: %X
\backslash 
n", _status87 ());
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 x = y; /* crea desbordamiento por abajo y pérdida de precisión */
\layout Quotation


\family typewriter 

\protected_separator 
 printf("Estado después del error: %X
\backslash 
n", _status87 ());
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 _clear87 ();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Estado después de borrar el error: %X
\backslash 
n", _status87 ());
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 y = x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_fpreset
\layout Standard

Reinicializa el paquete matemático de coma flotante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
void _fpreset(void);
\layout Standard

Esta función se suele usar junto con las funciones de systema 
\family typewriter 
exec
\family default 
 y 
\family typewriter 
spawn
\family default 
 puesto que un proceso hijo podría alterar el estado de coma flotante del
 proceso padre.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <float.h>
\layout Quotation


\family typewriter 
#include <setjmp.h>
\layout Quotation


\family typewriter 
#include <signal.h>
\layout Quotation


\family typewriter 
#include <process.h>
\layout Quotation


\family typewriter 
#include <conio.h>
\layout Quotation


\family typewriter 
jmp_buf reentrada;
\layout Quotation


\family typewriter 
/* define un manejador para atrapar errores de coma flotante */
\layout Quotation


\family typewriter 
void trampa_matematica (int sig)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Atrapando error de coma flotante.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("La señal es: %d
\backslash 
n", sig);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Presiona una tecla para continuar.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 getch();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* reinicializa el chip 8087 o emulador para borrar cualquier error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 _fpreset();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* vuelve al lugar del problema */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 longjmp(reentrada, -1);
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 float uno = 3.14, dos = 0.0;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* instala manejador de señal para las excepciones de coma flotante */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(signal (SIGFPE, trampa_matematica) == SIG_ERR)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Error al instalar manejador de señal.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 exit(3);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 }
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Presiona una tecla para generar un error matemático.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 getch();
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 if(setjmp (reentrada) == 0)
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 uno /= dos;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("Volviendo del menajeador de la señal.
\backslash 
n");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
_control87
\layout Standard

Cambia palabra de control de coma flotante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned int _control87(unsigned int nuevo, unsigned int mascara);
\layout Standard

Si un bit en la máscara es 1, el correspondiente bit en nuevo contiene el
 nuevo valor para el mismo bit en la palabra de control.
 Si mascara es 0, la palabra de control no es alterada.
\layout Description


\size largest 
_status87
\layout Standard

Obtiene el estado de coma flotante.
\layout Description

Sintaxis
\layout Quotation


\family typewriter 
unsigned int _status87(void);
\layout Standard

Los bits del valor devuelto contienen el estado de coma flotante.
 Ejemplo:
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <float.h>
\layout Quotation


\family typewriter 
int main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 float x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 double y = 1.5e-100;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Estado del 87 antes del error: %x
\backslash 
n", _status87 ());
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 x = y; /* <-- fuerza a que se produzca un error */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 y = x;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 printf("Estado del 87 después del error: %x
\backslash 
n", _status87());
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 
 return 0;
\layout Quotation


\family typewriter 
}
\layout Description


\size largest 
CW_DEFAULT (#define)
\layout Standard

Palabra de control por defecto para el comprocesador matemático 8087/80287.
\layout Section

Conexión de Turbo C con Ensamblador
\layout Standard

El C es un lenguaje muy potente, pero hay veces que puede interesar escribir
 algunas intrucciones en ensamblador.
 Hay tres razones para ello:
\layout Itemize

Aumentar la velocidad y la eficiencia.
\layout Itemize

Realizar una función específica de la máquina que no está disponible en
 C.
\layout Itemize

Utilizar una rutina en lenguaje ensamblador empaquetada de propósito general.
\layout Standard

Aquí no nos vamos a extender mucho en este tema, sólo nos vamos a limitar
 a comentar cómo se pueden incluir instrucciones ensamblador en un programa
 de C en el caso de Turbo C.
 Antes de escribir instrucciones en ensamblador debemos incluir la siguiente
 directiva:
\layout Quotation


\family typewriter 
#pragma inline
\layout Standard

la cual le dice al compilador que el programa contiene estamentos 
\family typewriter 
asm
\family default 
.
 La palabra clave 
\family typewriter 
asm
\family default 
 tiene la siguiente sintaxis:
\layout Quotation


\family typewriter 
asm codigo_de_operacion operandos punto_y_coma_o_nueva_linea
\layout Description

Ejemplo:
\layout Quotation


\family typewriter 
int var = 10;
\layout Quotation


\family typewriter 
asm mov ax, var
\layout Standard

Si se quiere incluir varias instrucciones en ensamblador, se crea un bloque
 (con dos llaves) después de 
\family typewriter 
asm
\family default 
.
 Ejemplo:
\layout Quotation


\family typewriter 
asm
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 {
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 pop ax; pop ds
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 iret
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 }
\layout Standard

Para profundizar más en el tema consulta el manual de usuario de tu compilador
 de C.
 Ejemplo:
\layout Quotation


\family typewriter 
/* Este ejemplo instala una rutina manejadora para la señal SIGFPE, atrapa
 una condición de desbordamiento de entero, hace un reajuste del registro
 AX y vuelve.
 */
\layout Quotation


\family typewriter 
#pragma inline
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <signal.h>
\layout Quotation


\family typewriter 
#pragma argsused /* para evitar aviso de argumentos sig y tipo no usados
 */
\layout Quotation


\family typewriter 
void manejador (int sig, int tipo, int *listreg)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nInterrupción atrapada.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *(listreg + 8) = 3; /* hace devolver AX = 3 */
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 signal(SIGFPE, manejador);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 asm mov ax, 07FFFH /* AX = 32767 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 asm inc ax /* causa desbordamiento (overflow) */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 asm into /* activa manejador */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* El manejador pone AX a 3 a la vuelta.
 Si no se hubiera incluido en el código la línea anterior (instrucción del
 ensamblador into), se activaría el manejador en la instrucción into que
 han después del decremento */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 asm dec ax /* ahora no se produce desbordamiento (overflow) */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 asm into /* ahora no se activa el manejador */
\layout Quotation


\family typewriter 
}
\layout Standard


\series bold 
Otra forma de hacer el ejemplo anterior:
\layout Quotation


\family typewriter 
/* Este ejemplo instala una rutina manejadora para la señal SIGFPE, atrapa
 una condición de desbordamiento de entero, hace un reajuste del registro
 AX y vuelve.
 */
\layout Quotation


\family typewriter 
#include <dos.h> /* para utilizar la pseudovariable _AX */
\layout Quotation


\family typewriter 
#include <stdio.h>
\layout Quotation


\family typewriter 
#include <signal.h>
\layout Quotation


\family typewriter 
#pragma argsused /* para evitar aviso de argumentos sig y tipo no usados
 */
\layout Quotation


\family typewriter 
void manejador(int sig, int tipo, int *listreg)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 printf("
\backslash 
nInterrupción atrapada.");
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 *(listreg + 8) = 3; /* hace devolver AX = 3 */
\layout Quotation


\family typewriter 
}
\layout Quotation


\family typewriter 
void main(void)
\layout Quotation


\family typewriter 
{
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 signal(SIGFPE, manejador);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 _AX = 0x07FFF; /* AX = 32767 */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 _AX++; /* causa desbordamiento (overflow) */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 geninterrupt(4); /* activa manejador */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 _AX--;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 geninterrupt(4);
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 /* El manejador pone AX a 3 a la vuelta.
 Si no se hubiera incluido en el código la línea anterior (instrucción del
 ensamblador into), se activaría el manejador en la instrucción into que
 han después del decremento */
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 _AX--;
\layout Quotation


\family typewriter 

\protected_separator 

\protected_separator 
 geninterrupt(4);
\layout Quotation


\family typewriter 
}
\layout Standard

Las pseudovariables registros en Turbo C son las siguientes:
\layout Quotation


\family typewriter 
_AX
\protected_separator 

\protected_separator 

\protected_separator 
 _AL
\protected_separator 

\protected_separator 

\protected_separator 
 _AH
\protected_separator 

\protected_separator 

\protected_separator 
 _SI
\protected_separator 

\protected_separator 

\protected_separator 
 _ES
\layout Quotation


\family typewriter 
_BX
\protected_separator 

\protected_separator 

\protected_separator 
 _BL
\protected_separator 

\protected_separator 

\protected_separator 
 _BH
\protected_separator 

\protected_separator 

\protected_separator 
 _DI
\protected_separator 

\protected_separator 

\protected_separator 
 _SS
\layout Quotation


\family typewriter 
_CX
\protected_separator 

\protected_separator 

\protected_separator 
 _CL
\protected_separator 

\protected_separator 

\protected_separator 
 _CH
\protected_separator 

\protected_separator 

\protected_separator 
 _BP
\protected_separator 

\protected_separator 

\protected_separator 
 _CS
\layout Quotation


\family typewriter 
_DX
\protected_separator 

\protected_separator 

\protected_separator 
 _DL
\protected_separator 

\protected_separator 

\protected_separator 
 _DH
\protected_separator 

\protected_separator 

\protected_separator 
 _SP
\protected_separator 

\protected_separator 

\protected_separator 
 _DS
\layout Quotation


\family typewriter 
_FLAGS
\layout Standard

Estas pseudovariables registros corresponden a los registros de los procesadores
 80x86.
\layout Section

Problemas
\layout Itemize


\series bold 
Ejercicio 12-1
\series default 
.
 Implementa las funciones 
\family typewriter 
asctime()
\family default 
 y 
\family typewriter 
strftime()
\family default 
 de la librería 
\family typewriter 
time.h
\family default 
, ya que la funciones que suministra el C escribe los nombres de los días
 y los meses en inglés.
\layout Itemize


\series bold 
Ejercicio 12-2
\series default 
.
 Diseña un programa que lea una función matemática y la represente gráficamente
 en el monitor.
\the_end
