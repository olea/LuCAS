<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<!-- 0,1 -->
<!-- Kernel,0 -->
<!-- Brian,Ward,bri@blah.math.tu-graz.ac.at -->
<!-- 0.75,1996-12-29 -->
<!-- Kernel -->
<!-- Juan Antonio Retamar, correojar@yahoo.com.ar -->
<!-- 4.0,2002-6-27 -->
<!-- kernel,núcleo,compilación -->
<!-- Software,Kernel -->

<article>

<!-- ^M
************************ comienzo del comentario ************************^M
          This is the Linux Kernel HOWTO, SGML source^M
	  Versión Castellano^M
	  Revisión 4.0, 27 de Junio de 2002^M
	  Traductor: Juan Antonio Retamar, correojar@yahoo.com.ar^M
          Ej: sgml2txt - -language=spanish -c latin -v -f Kernel-Como.sgml

	  ACTUALIZACION: docbookx 4.
*********************** fin del comentario ******************************^M 
-->
					    

<articleinfo>

<title>Kernel-Como</title>

<authorgroup>
  <author>
    <firstname>Brian</firstname>
    <surname>Ward</surname>
    <affiliation>
      <address><email>bri@cs.uchicago.edu</email></address>
    </affiliation>
  </author>

  <author>
    <firstname>Alavoor</firstname>
    <surname>Vasudevan</surname>
    <othername>Al Dev</othername>
    <affiliation>
      <address><email>alavoor[AT]yahoo.com</email></address>
    </affiliation>
  </author>

  <othercredit>
    <firstname>Juan Antonio</firstname>
    <surname>Retamar</surname>
    <affiliation>
      <address><email>correojar@yahoo.com.ar</email></address>
    </affiliation>
    <contrib>Traduccion al castellano</contrib>
  </othercredit>
</authorgroup>

<!-- Traducción de Juan Antonio Retamar,-->

<pubdate>Revisión 4.0, 27 de Junio de 2002</pubdate>

<abstract>

<para>
Esta es una guía detallada de la configuración, compilación, actualizaciones y resolución de problemas del núcleo, para sistemas basados en ix86. El traductor intentó respetar al máximo el contenido del documento original, por lo que solo agregó una pequeña nota.
</para>

</abstract>

</articleinfo>

<sect1>
<title>Introducción</title>

<para>
¿Debe leer este documento? Bien, vea si tiene alguno de los siguientes 
síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
 ``¡Arg! El paquete wizzo-46.5.6 dice que necesita la versión 
del núcleo 2.8.193 y yo aún solo tengo la versión 1.0.9''.
</para>
</listitem>
<listitem>

<para>
 Hay un controlador de dispositivo en uno de los núcleos más 
nuevos que necesita tener.
</para>
</listitem>
<listitem>

<para>
 Realmente, no tiene ni idea de cómo compilar un núcleo.
</para>
</listitem>
<listitem>

<para>
 ``¿Está <emphasis remap="it">realmente</emphasis> la historia completa de este
artículo en el README?.''
</para>
</listitem>
<listitem>

<para>
 Llegó, intentó, pero éste no funcionó.
</para>
</listitem>
<listitem>

<para>
 Necesita algo par darle a la gente que insiste en pedirle que 
instale sus núcleos por ellos.
</para>
</listitem>

</itemizedlist>

</para>

<sect2>
<title>¡Lea esto primero! (Lo que yo quiero decir)</title>

<para>
Algunos de los ejemplos en este documento asumen que tiene el GNU 
<literal remap="tt">tar</literal>, <literal remap="tt">find</literal>, y <literal remap="tt">xargs</literal>. Éstos son bastante 
estándares; esto no debe causar problemas. También se asume que conoce 
la estructura del sistema de ficheros de su sistema; si no la conoce, es 
crítico que guarde una copia escrita de la salida del comando 
<literal remap="tt">mount</literal> durante la operación normal del sistema (o un listado de 
<literal remap="tt">/etc/fstab</literal>, si es que puede leerlo). Esta información es 
importante, y no cambia a menos que reparticione su disco, agregue uno 
nuevo, reinstale su sistema, o algo similar.
</para>

<para>
La última versión de ``producción'' del núcleo en el momento de la 
escritura era la 2.2.9, lo que significa que las referencias y ejemplos 
corresponden a esa versión. Incluso aunque traté de hacer este 
documento tan independiente de la versión como sea posible, el núcleo 
está constantemente en desarrollo, de manera que si obtiene una nueva 
versión, éste inevitablemente tendrá algunas diferencias. Una vez más 
esto no debe causar problemas importantes, pero puede crear un poco de 
confusión.
</para>

<para>
Hay dos versiones del fuente de núcleo de Linux, uno de ``producción'' 
y otro de ``desarrollo''. Las versiones de producción se numeran en su 
parte inferior con un número par; así la 1.2.x era de producción, y la 
2.0.x, así como la 2.2.x eran de producción. Se considera que estos 
núcleos son las versiones más estables y libres de errores en el 
momento del lanzamiento. Los núcleos en desarrollo (2.1.x, 2.3.x, etc.) 
sirven como núcleos de prueba, para gente deseosa de probar lo último 
que salió y posiblemente son núcleos como muchos errores. ¡Ha sido 
advertido!.
</para>

</sect2>

<sect2>
<title>Una palabra sobre el estilo</title>

<para>
<literal remap="tt">El texto que se parece a este</literal> es cualquier cosa que aparece en 
su pantalla, un nombre de fichero, o algo que puede ser directamente 
tecleado, tal como un comando, u opciones a un comando (si está mirando 
un fichero en ASCII, no verá ninguna diferencia). Los comandos y otras 
entradas están frecuentemente entre comillas (con ` '), lo que causa el
siguiente problema clásico de puntuación: si tal elemento aparece al
final de una frase entre comillas, la gente a menudo tecleará un `.' 
junto con el comando, debido a que el estilo Americano de encomillado 
dice que se debe poner el punto dentro de las comillas. Aunque el sentido 
común (y desafortunadamente, este asume que uno con el ``sentido 
común'' usa el también llamado estilo Americano de encomillado) 
debería decirnos el quitar la puntuación primero, mucha gente 
simplemente no lo recuerda, de manera que yo lo pondré fuera de las 
comillas en tales casos. En otras palabras, cuando se indica que debe 
teclear ``<literal remap="tt">make config</literal>'', habría que escribir `<literal remap="tt">make config</literal>', no `<literal remap="tt">make config</literal>'.
</para>

</sect2>

</sect1>

<sect1>
<title>Pasos Rápidos - Compilación del Núcleo</title>

<para>
Esta sección fue escrita por Al Dev 
<ulink
url="mailto:alavoor[AT]yahoo.com"
>Al Dev (alavoor[AT]yahoo.com)</ulink
> 
<emphasis remap="bf">(La última versión de este documento está en 
<ulink
url="http://www.milkywaygalaxy.freeservers.com"
>http://www.milkywaygalaxy.freeservers.com</ulink
>. Puede desear 
comprobar allí para saber si hay cambios). </emphasis>
Los sitios espejo están en - 
<ulink
url="http://www.angelfire.com/country/aldev0"
>angelfire</ulink
>, 
<ulink
url="http://www.geocities.com/alavoor/index.html"
>geocities</ulink
>. 
Estos sitios tienen <emphasis remap="bf">gran cantidad de cosas atractivas</emphasis> y consejos 
de Linux. 
</para>

<para>
Se necesita la recompilación del núcleo para hacer éste más delgado y 
que resulte un sistema operativo MAS RÁPIDO. Esto también se requiere 
para soportar algunos nuevos dispositivos. 
</para>

<sect2 id="precauciones">
<title>Preparaciones Preventivas</title>

<para>
Antes de que construya el núcleo, es una buena idea hacer una copia de 
respaldo del sistema. Si no había respaldado su sistema recientemente 
entonces podrá hacerlo ahora. Puede utilizar las herramientas de 
respaldo comerciales como BRS Backup-Recovery-Software <ulink
url="http://24.221.230.253"
>BRS  Backup-Recovery-Software</ulink
> (también en esta 
página puede encontrar herramientas de respaldo open- source/freeware 
enumeradas bajo 'Backup and Restore Utility'). El respaldo es solo una 
sugerencia y no es obligatorio hacer un respaldo antes de construir el 
núcleo de Linux.
</para>

</sect2>

<sect2 id="impaciente">
<title>Para el Impaciente</title>

<para>

<orderedlist>
<listitem>

<para>
 Desempaquete las fuentes
</para>
</listitem>
<listitem>

<para>
 make clean
</para>
</listitem>
<listitem>

<para>
 make xconfig
</para>
</listitem>
<listitem>

<para>
 make dep
</para>
</listitem>
<listitem>

<para>
 make
</para>
</listitem>
<listitem>

<para>
 make bzImage
</para>
</listitem>
<listitem>

<para>
 make modules
</para>
</listitem>
<listitem>

<para>
 make install
</para>
</listitem>
<listitem>

<para>
 make modules_install
</para>
</listitem>
<listitem>

<para>
 configure LILO o GRUB.
</para>
</listitem>

</orderedlist>

Vea los detalles en la siguiente sección....
</para>

</sect2>

<sect2 id="pasos">
<title>Construyendo el Núcleo - Explicación de los Pasos
</title>

<para>
<emphasis remap="bf">Detalles de los pasos mencionados en la sección anterior: </emphasis>
</para>

<para>
<emphasis remap="bf">Nota: </emphasis> Debajo, 'bash#' denota el prompt del bash, debe teclear 
los comandos que aparecen después del prompt del 'bash#'. Debajo están 
los comandos probados en el núcleo de RedHat Linux 2.4.7-10, pero estos 
deberían funcionar para otras distribuciones con pequeños cambios. Este 
debería también funcionar para versiones más antiguas del núcleo como 
la 2.2, 2.0 y 1.3.
</para>

<para>

<orderedlist>
<listitem>
<para>
 <emphasis remap="bf">Nota:</emphasis> puede tener muchas imágenes del núcleo en su 
sistema. Siguiendo los pasos de abajo, no sobreescribirá o dañará su 
núcleo existente. Estos pasos son <emphasis remap="bf">muy seguros</emphasis> y su núcleo 
actual estará intacto y no será tocado.
</para>
</listitem>
<listitem>
<para>
 Ingrese al sistema como 'root' durante todos estos pasos. Monte el 
CD-ROM de RedHat Linux e instale el fuente del núcleo de Linux en rpm

<programlisting>
bash$ su - root
bash# cd /mnt/cdrom/RedHat/RPMS 
bash# rpm -i kernel-headers*.rpm 
bash# rpm -i kernel-source*.rpm 
bash# rpm -i dev86*.rpm   
bash# rpm -i bin86*.rpm   
</programlisting>

(bin86*.rpm y 'as86' solo se requieren para sistemas <emphasis remap="bf">Linux 
VIEJOS</emphasis> como RedHat 5.x. Consiga el comando ensamblador de Intel 
'as86' desde dev86*.rpm en el CD-ROM o desde bin86-mandrake
<ulink
url="http://rpmfind.net/linux/RPM/mandrake/7.1/Mandrake/RPMS/bin86-0.4-12mdk.i586.html"
>bin86-mandrake</ulink
>, 
<ulink
url="http://rpmfind.net/linux/RPM/kondara/jirai/i586/bin86-0.4-8k.i586.html"
>bin86-kondara</ulink
>).
</para>
</listitem>
<listitem>
<para>

<itemizedlist>
<listitem>

<para>
 Inicie X-Windows con 'startx'. Si no es capaz de iniciar 
X-Windows entonces vea debajo el próximo paso.

<programlisting>
	bash# man startx
	bash# startx
	bash# cd /usr/src/linux 
	bash# make xconfig 
</programlisting>

</para>
</listitem>
<listitem>

<para>
 Si anteriormente no fue capaz de iniciar X-Windows 
entonces intente -

<programlisting>
	bash# export TERM=xterm
	bash# make menuconfig

Si encuentra una pantalla revuelta, entonces use diferentes emuladores de 
terminal como vt100, vt102, vt220 o ANSI. La pantalla se revolverá y 
tendrá caracteres basura en los casos donde usa telnet para ingresar a 
un Linux remoto. En tales casos debería utilizar emuladores de terminal 
como vt100, vt220.
Por ejemplo:
	bash# export TERM=vt220
	bash# export TERM=ansi
En un nivel más bajo, use: 
	bash# export TERM=vt100
	bash# make menuconfig

Si el comando menuconfig falla, entonces intente -
	bash# make config
</programlisting>

</para>
</listitem>

</itemizedlist>

<emphasis remap="bf">"make xconfig" o "make menuconfig"</emphasis> llevan a una 
interfase GUI amigable al usuario. Y <emphasis remap="bf">"make config"</emphasis> 
lleva a una interfase de línea de comando en modo consola. 
Puede cargar el fichero de configuración desde 
<emphasis remap="it">/usr/src/linux/.config</emphasis> (fichero de configuración 
con punto. Note el punto antes de config).
</para>
</listitem>
<listitem>
<para>
 Dentro de 'make xconfig' debe realizar esto para evitar problemas 
-

<itemizedlist>
<listitem>

<para>
 Seleccione el tipo de CPU apropiado (CPU type) - Pentium 3, AMD 
K6, Cyrix, Pentium 4, Intel 386, DEC Alpha o PowerPC, ¡de otra forma el 
núcleo no arrancará!.núcleo no arrancará!.
</para>
</listitem>
<listitem>

<para>
 Seleccione el soporte de SMP - según tenga una sola o múltiples 
CPUs.
</para>
</listitem>
<listitem>

<para>
 Sistemas de Ficheros - Seleccione Windows95 Vfat, MSDOS y NTFS 
como parte del núcleo y no como módulos cargables. (Mi preferencia 
personal, pero ustedes son libres de elegir su propia opción).
</para>
</listitem>
<listitem>

<para>
 ¡Habilite el Soporte de módulos cargables!. Con esta opción 
puede cargar/descargar dinámicamente los controladores de dispositivos 
en un sistema Linux en marcha. Vea estas páginas man:

<programlisting>
bash# rpm -i /mnt/cdrom/Redhat/RPMS/modutils*.rpm
bash# man lsmod
bash# man insmod
bash# man rmmod
bash# man depmod
bash# man modprobe
</programlisting>

</para>
</listitem>

</itemizedlist>
</para>
</listitem>
<listitem>
<para>
 Guarde la configuración y salga de "make xconfig". Todas las 
opciones que seleccionó están ahora guardadas en el fichero de 
configuración en <emphasis remap="it">/usr/src/linux/.config</emphasis> (fichero de 
configuración con punto). Y ahora, haga -

<programlisting>
bash# make dep
bash# make clean
</programlisting>
</para>
</listitem>
<listitem>
<para>
 Lea el siguiente fichero (para ganar algo de conocimiento sobre la 
construcción del núcleo. Consejo: Use el editor en colores <ulink
url="http://www.linuxdoc.org/HOWTO/Vim-HOWTO.html"
>gvim</ulink
> para una 
mejor legibilidad.

<programlisting>
bash# gvim -R   /usr/src/linux/arch/i386/config.in 
bash# man less 
bash# less   /usr/src/linux/arch/i386/config.in 
Teclee 'h' para la ayuda y para navegar presione las teclas i, j, k, l, 
H, las flechas o page up/down.
</programlisting>
</para>
</listitem>
<listitem>
<para>
 Ahora, dé el comando make -

<programlisting>
	bash# cd /usr/src/linux
	bash# man nohup
	bash# nohup make bzImage &#38;  
	bash# man tail
	bash# tail -f nohup.out     (.... para monitorear el progreso) 
Esto pondrá el núcleo en /usr/src/linux/arch/i386/boot/bzImage
</programlisting>
</para>
</listitem>
<listitem>
<para>
 Después de crear con éxito bzImage, copie la imagen del núcleo 
al directorio /boot. Debe copiar la imagen del nuevo núcleo al 
directorio /boot, de otra manera el nuevo núcleo <emphasis remap="bf">PUEDE QUE NO</emphasis> 
arranque. Hay dos opciones para gestionar el arranque bajo RedHat Linux - 
(1) Lilo y (2) GRUB. Y entonces lea la página del manual del lilo (vea 
además
<ulink
url="http://www.linuxdoc.org/HOWTO/LILO-crash-rescue-HOWTO.html"
>http://www.linuxdoc.org/HOWTO/LILO-crash-rescue-HOWTO.html</ulink
>) y 
el fichero <xref linkend="liloconf"/>. de ejemplo. Dé 
siempre una extensión de la fecha al nombre del fichero, porque ésta le 
dice cuando fue que construyo el núcleo, tal como se muestra debajo:


<programlisting>
bash# cp /usr/src/linux/arch/i386/boot/bzImage /boot/bzImage.myker.26mar2001
bash# man lilo
bash# man lilo.conf
Y edite el fichero /etc/lilo.conf y ponga estas líneas -
	image=/boot/bzImage.myker.26mar2001 
	label=myker
	root=/dev/hda1 
	read-only 
Puede comprobar el nombre del dispositivo para 'root=' con el comando - 
	bash# df   / 

</programlisting>
</para>
</listitem>
<listitem>
<para>
 Ahora dé:

<programlisting>
bash# lilo 
bash# lilo -q 
</programlisting>

Debe volver a ejecutar lilo incluso si la entrada 'myker' existe, cada 
vez que crea una nueva bzImage.
</para>
</listitem>
<listitem>
<para>
 Reinicie la máquina y en el lilo presione la tecla TAB y teclee 
'myker' Si esta arranca entonces hizo un buen trabajo!. Sino, en el lilo 
seleccione su antiguo núcleo, arranque y reintente todo de nuevo. Su 
antiguo núcleo <emphasis remap="bf">todavía está INTACTO y SEGURO</emphasis>, digamos en 
<emphasis remap="it">/boot/vmlinuz-2.0.34-0.6</emphasis>
</para>
</listitem>
<listitem>
<para>
 Si su nuevo núcleo 'myker' arranca y funciona correctamente, 
puede crear el disco de arranque. Inserte un disquete en blanco en la 
disquetera y -

<programlisting>
bash# cd /usr/src/linux
bash# make bzdisk

Vea además mkbootdisk -
bash# rpm -i mkbootdisk*.rpm
bash# man mkbootdisk
</programlisting>
</para>
</listitem>
<listitem>

<para>
 <emphasis remap="bf">MÓDULOS CARGABLES: </emphasis>
Este paso se requiere <emphasis remap="bf">SOLAMENTE si</emphasis> habílitó el soporte de 
Módulos cargables en el paso 3 de arriba. Los módulos cargables están 
ubicados en /lib/modules. DEBE realizar este paso si habilitó o 
deshabilitó algunos módulos, sino obtendrá errores 'unresolved 
symbols' durante o después de la carga del núcleo. Compruebe con el 
comando `insmod', el cual se utiliza extensivamente para cargar los 
módulos.

<programlisting>
bash# cd /usr/src/linux
bash# make modules
bash# make modules_install
</programlisting>

Esto copiará los módulos al directorio /lib/modules .

Por ejemplo, para cargar el módulo <literal remap="tt">/lib/modules/2.4.2-2/kernel/dri
vers/block/loop.o</literal>, haría:

<programlisting>
bash# man insmod
bash# modprobe loop
bash# insmod loop
bash# lsmod 
</programlisting>

Puede fijar el PATH de las búsquedas de insmod en /etc/modules.conf
</para>
</listitem>

</orderedlist>

</para>

</sect2>

<sect2>
<title>Solución a Problemas Comunes</title>

<sect3>
<title>El Sistema se Cuelga en LILO</title>

<para>
<emphasis remap="bf">Síntoma: </emphasis> Después de que construyó el núcleo y reinició, el 
sistema se cuelga justo antes del LILO.
</para>

<para>
<emphasis remap="bf">Razón: </emphasis> Probablemente no fijó en el BIOS la partición 
correcta del disco rígido IDE Primary Master y Secondary Slave.
</para>

<para>
<emphasis remap="bf">Solución: </emphasis>Encienda la máquina y presione la tecla DEL para ir 
a la configuración del BIOS (Basic Input Output System). Seleccione el 
ajuste IDE y fije la partición correcta del disco rígido primario y de 
los discos esclavos. Cuando el sistema arranque, buscará el disco 
rígido primario IDE y el Master Boot Record (MBR).  Este lee el MBR y 
comienza la carga del Núcleo de Linux desde la partición del disco 
rígido.
</para>

</sect3>

<sect3>
<title>No se encontró ningún init</title>

<para>
El siguiente problema es cometido muy frecuentemente por usuarios nuevos. 
</para>

<para>
Si su núcleo no arranca y recibe -

<programlisting>
Warning: unable to open an initial console
Kernel panic: no init found. Try passing init= option to kernel
</programlisting>

El problema es que <emphasis remap="bf">no</emphasis> fijó correctamente el parámetro "root=" 
en el fichero /etc/lilo.conf. En mi caso, utilicé root=/dev/hda1 que es 
la que está conteniendo la partición raíz "/". Debe apuntar 
correctamente el dispositivo de la raíz en su lilo.conf, este puede ser 
como /dev/hdb2 o /dev/hda7.
</para>

<para>
El núcleo busca el comando `init' que está localizado en /sbin/init. Y 
el directorio /sbin que vive en la partición raíz. Para los detalles 
vea -

<programlisting>
bash# man init
</programlisting>

</para>

</sect3>

<sect3>
<title>El comando 'depmod' da mensajes de error "Unresolved symbol"</title>

<para>
Cuando ejecuta <literal remap="tt">depmod</literal> este devuelve "Unresolved symbols". Aquí 
se da un ejemplo del mensaje para demostrar el caso:

<programlisting>
bash$ su - root
bash# man depmod
bash# depmod
depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/linear.o
depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/multipath.o
depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid0.o
depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid1.o
depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid5.o
</programlisting>

</para>

<para>
<emphasis remap="bf">Razón </emphasis> no hizo e instaló los módulos, después de construir 
el nuevo núcleo con <literal remap="tt">"make bzImage"</literal>.
</para>

<para>
<emphasis remap="bf">Solución: </emphasis> Después de que construye el nuevo núcleo, debe 
hacer:

<programlisting>
bash$ su - root
bash# cd /usr/src/linux
bash# make modules
bash# make modules_install
</programlisting>

</para>

</sect3>

<sect3>
<title>El Núcleo No Carga Módulos - Mensajes de Error "Unresolved symbols"</title>

<para>
Cuando arranca el núcleo y el sistema trata de  cargar algunos módulos 
y obtiene "Unresolved symbol : __algún_nombre_de_función" entonces esto 
significa que no realizó una compilación limpia de los módulos y el 
núcleo. Es obligatorio que haga una <emphasis remap="bf">compilación limpia</emphasis> y que 
compile los módulos. Haga esto -

<programlisting>
	bash# cd /usr/src/linux
	bash# make dep
	bash# make clean
	bash# nohup make bzImage &#38;  
	bash# tail -f nohup.out     (.... para monitorear el progreso) 
	bash# make modules
	bash# make modules_install
</programlisting>

</para>

</sect3>

<sect3>
<title>El Núcleo no puede cargar un módulo </title>

<para>
Si el núcleo falla al cargar un módulo (digamos un módulo cargable 
para la tarjeta de red u otros dispositivos), entonces puede querer 
intentar construir el controlador de dispositivo justo dentro del 
núcleo. Algunas veces <emphasis remap="it"><emphasis remap="bf">el módulo cargable NO 
funcionará</emphasis></emphasis> y el controlador necesitará ser construido justo 
dentro del núcleo. Por ejemplo - algunas tarjetas de red no soportan la 
característica de módulo cargable - DEBE construir el controlador de la 
tarjeta de red justo dentro del núcleo de Linux. Por lo tanto,  en 'make 
xconfig' NO DEBERÍA seleccionar el módulo cargable para este dispositivo.
</para>

</sect3>

<sect3>
<title>Módulos cargables</title>

<para>
Puede instalar los módulos cargables por defecto con -
</para>

<para>
El paso dado abajo puede no ser requerido, pero se necesita  <emphasis remap="bf">SOLO 
PARA EMERGENCIAS</emphasis> donde sus ficheros en /lib/modules están dañados. 
Si ya tiene el directorio /lib/modules y en el caso de que quiera 
reemplazarlos, use la opción --force para reemplazar el paquete y para 
seleccionar la arquitectura de CPU apropiada.
</para>

<para>
Para las nuevas versiones de RedHat Linux 6.0 y posteriores, los módulos 
del núcleo están incluidos con kernel-2.2*.rpm. Instale los módulos 
cargables y el núcleo con

<programlisting>
	Esto listará los paquetes que ya están instalados.
bash# rpm -qa | grep -i kernel
	
bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i686.rpm
(o) 
bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i586.rpm
(o) 
bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i386.rpm
</programlisting>

</para>

<para>
Esto es solo para las versiones antiguas de RedHat Linux 5.2 y 
anteriores. Arranque el nuevo núcleo e instale los módulos cargables 
desde el CD-ROM RedHat Linux "contrib"

<programlisting>
bash# rpm -i /mnt/cdrom/contrib/kernel-modules*.rpm 
....(Para sistemas Linux antiguos que no tienen insmod preinstalado)
</programlisting>

</para>

</sect3>

</sect2>

<sect2 id="postkernel">
<title>Después de la Construcción del Núcleo </title>

<para>
Después de construir con éxito y arrancar el núcleo de Linux, puede 
ser que requiera realizar estos pasos adicionales para hacer funcionar 
algunos de los dispositivos con Linux. (Los pasos de abajo fueron 
probados en RedHat Linux, pero deberían funcionar también con otras 
distribuciones).
</para>

<para>
<emphasis remap="bf">Configuración de la Tarjeta de video/Monitor: </emphasis>

<itemizedlist>
<listitem>

<para>
 Por favor, vea el manual de la tarjeta de video que normalmente 
viene con la PC. Debería mirar la página de "Especificaciones 
Técnicas".
</para>
</listitem>
<listitem>

<para>
 Por favor véa el manual del monitor y mire la página de 
"Especificaciones Técnicas".
</para>
</listitem>

</itemizedlist>

Puede configurar la Tarjeta de video y el monitor usando estos comandos: 

<programlisting>
bash$ su - root
bash# man Xconfigurator
bash# /usr/bin/X11/Xconfigurator --help
bash# /usr/bin/X11/Xconfigurator 
bash# /usr/bin/X11/Xconfigurator --expert

Vea también:
bash# man xf86config
bash# /usr/bin/X11/xf86config
</programlisting>

Si su tarjeta no es detectada automáticamente, entonces puede utilizar 
la opción --expert y seleccionar la "Tarjeta no listada" (Unlisted 
card). Si su monitor no está listado, entonces seleccione el tipo de 
monitor genérico SVGA 1024x768.
</para>

<para>
<emphasis remap="bf">Configuración de la Tarjeta de Sonido: </emphasis>

<itemizedlist>
<listitem>

<para>
 Conecte sus altavoces externos al puerto de audio de la tarjeta de 
sonido.
</para>
</listitem>
<listitem>

<para>
 Conecte el cable de audio de su CDROM al zócalo de audio de 
4-pines de la tarjeta de sonido (De otra forma su unidad de CD-ROM no 
reproducirá la música de su CD de música).
</para>
</listitem>
<listitem>

<para>
 Refiérase a lo documentos HOWTO de 'Sound' en 
<ulink
url="http://www.linuxdoc.org"
>http://www.linuxdoc.org</ulink
>

</para>
</listitem>

</itemizedlist>


<programlisting>
bash$ su - root
bash# man sndconfig
bash# /usr/sbin/sndconfig
</programlisting>

Luego inicie el 'Escritorio de KDE' en X-Windows con el comando 'startx'. 
Haga clic en 'KInicio-&#62;CentroDeControl-&#62;ServidorDeSonido-&#62;General-&#62;
PruebaDeSonido'. Esto reproduciría el sonido de prueba. Luego haga clic 
en 'KInicio-&#62;MultiMedia-&#62;MezcladorDeSonido-&#62;SoundVolumeSlider' y ajuste 
el volumen del sonido.
</para>

<para>
<emphasis remap="bf">Configuración de la Tarjeta de red: </emphasis>

<itemizedlist>
<listitem>

<para>
 Use /sbin/linuxconf
</para>
</listitem>
<listitem>

<para>
 O use el Centro de Control de KDE (KDE control panel)
</para>
</listitem>
<listitem>

<para>
 Refiérase a los documentos HOWTO de 'Networking' en <ulink
url="http://www.linuxdoc.org"
>http://www.linuxdoc.org</ulink
>
</para>
</listitem>

</itemizedlist>

</para>

<para>
<emphasis remap="bf">Configuración del Cortafuegos y el Enmascaramiento IP : </emphasis> Para 
la versión del núcleo de Linux 2.4 y superiores, el Contrafuegos y el 
Enmascaramiento  IP es implementado por el paquete NetFilter. De ahí que 
en la configuración del núcleo debe habilitar Netfilter y ejecutar el 
script de Firewall/IPMasq. Descargue los scripts de Firewall-IPMasq desde 
<ulink
url="http://www.BoingWorld.com/workshops/linux/iptables-tutorial"
>Firewall-IPMasq scripts</ulink
> , la 
página principal de Netfilter está en
<ulink
url="http://netfilter.samba.org"
>http://netfilter.samba.org</ulink
>. Hay materiales relacionados en 
<ulink
url="http://www.linuxsecurity.com/feature_stories/kernel-netfilter.html"
>firewalling-matures</ulink
> 
y <ulink
url="http://netfilter.filewatcher.org/netfilter-faq.html"
>Netfilter-FAQ</ulink
>.
</para>

<para>
Para las versiones del núcleo menores a la 2.4, debería instalar los 
los paquetes rpm del Contrafuegos desde 
<ulink
url="http://rpmfind.net/linux/rpm2html/search.php?query=firewall"
>rpmfind.net</ulink
> o 
<ulink
url="http://rpmfind.net/linux/RPM/contrib/noarch//SRPMS//firewall-2.2-3.src.html"
>firewall.src.rpm</ulink
>.
</para>

<para>
<emphasis remap="bf">Configuración de otros dispositivos: </emphasis>
Refiérase a los documentos HOWTO relativos a sus dispositivos en 
<ulink
url="http://www.linuxdoc.org"
>http://www.linuxdoc.org</ulink
>
</para>

</sect2>

<sect2 id="liloconf">
<title>Ejemplo de lilo.conf </title>

<para>
Debajo se da un ejemplo del fichero /etc/lilo.conf. debería seguir las 
convenciones de nombrado como ker2217 (para el núcleo 2.2.17), ker2214 
(para el núcleo 2.2.14). Puede tener muchas imágenes del núcleo en el 
mismo sistema /boot. En mi máquina, yo tengo algo como:

<programlisting>
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
default=firewall

image=/boot/vmlinuz-2.2.14-5.0
label=ker2214
read-only
root=/dev/hda9

image=/boot/vmlinuz-2.2.17-14
label=ker2217
read-only
root=/dev/hda9

#image=/usr/src/linux/arch/i386/boot/bzImage 
#	label=myker 
#	root=/dev/hda7
#	read-only 

image=/boot/bzImage.myker.11feb2001
label=myker11feb 
root=/dev/hda9
read-only 

image=/boot/bzImage.myker.01jan2001
label=myker01jan 
root=/dev/hda9
read-only 

image=/boot/bzImage.myker-firewall.16mar2001
label=firewall 
root=/dev/hda9
read-only 
</programlisting>

</para>

</sect2>

</sect1>

<sect1>
<title>Preguntas importantes y sus respuestas</title>

<sect2>
<title>Entonces, ¿qué es lo que hace el núcleo?</title>

<para>
El núcleo de Unix actúa como un mediador entre sus programas y su 
hardware. Primero, este realiza (u ordena) la administración de la 
memoria para todos los programas en ejecución (procesos), y se asegura 
que todos ellos consigan una justa (o injusta, si lo prefiere) parte de 
los ciclos del procesador. Además, este proporciona una interfase 
agradable y bastante portable para que los programas hablen con su 
hardware.
</para>

<para>
Ciertamente hay mas operaciones del núcleo que estas, pero estas 
funciones básicas son las más importantes a conocer.
</para>

</sect2>

<sect2>
<title>¿Por qué debería actualizar mi núcleo?</title>

<para>
Los nuevos núcleos generalmente ofrecen la capacidad de hablar con más 
tipos de hardware (es decir, ellos tienen mas controladores de 
		dispositivos), pueden tener una administración de procesos mejor, pueden 
funcionar más rápido que las versiones antiguas, podrían ser más 
estables que las versiones más antiguas y corregir errores tontos de la 
versiones antiguas. La mayoría de la gente actualiza los núcleos porque 
ella desea los controladores de dispositivos y las correcciones de 
errores.
</para>

</sect2>

<sect2>
<title>¿Qué clase de hardware nuevo soportan los nuevos núcleos?</title>

<para>
Vea el documento Hardware-HOWTO. Alternativamente, puede mirar el fichero 
`<literal remap="tt">config.in</literal>' en el fuente de Linux, o simplemente encontrarlo 
cuando intente  `<literal remap="tt">make config</literal>'. Esto le mostrará todo el 
hardware soportado por la distribución estándar del núcleo, pero no 
todas las cosas que Linux soporta; muchos controladores de dispositivos 
comunes (tales como los controladores PCMCIA y algunos controladores de 
		cinta) son módulos cargables mantenidos y distribuidos por separado.
</para>

</sect2>

<sect2>
<title>¿Qué versión de gcc y libc necesito?</title>

<para>
Linus recomienda una versión de gcc en el fichero <literal remap="tt">README</literal> 
incluido con el fuente del núcleo. Si no tiene esta versión, la 
documentación en la versión recomendada de gcc debe decirle si 
necesitará actualizar sus librerías libc. Éste no es un procedimiento 
difícil, pero es importante seguir la instrucciones.
</para>

</sect2>

<sect2>
<title>¿Qué es un módulo cargable?</title>

	<para>
Estas son piezas del código del núcleo que no están unidas (incluidas) 
	directamente en el núcleo. Uno los compila por separado, y puede 
	insertarlos y removerlos en un núcleo en ejecución casi en cualquier 
	momento. Debido a su flexibilidad, esta es ahora la manera preferida de 
	programar ciertas características del núcleo. Muchos controlares de 
	dispositivos populares, como los controladores PCMCIA y el controlador de 
	la unidad de cinta QIC-80/40, son módulos cargables.
	</para>

	</sect2>

	<sect2>
	<title>¿Cuánto espacio en disco necesito?</title>

	<para>
	Esto depende de la configuración particular de su sistema. Primero, el 
	fuente comprimido del fuente de Linux ocupa cerca de 14 MB en la versión 
	2.2.9. Muchos sitios conservan éste incluso después de desempaquetarlo. 
	Sin comprimir y construido con una configuración moderada, toma otros 67 
	MB más.
	</para>

	<para>
	Nota del traductor: en el momento de la traducción la última versión 
	disponible del fuente núcleo era la 2.4.19, que ocupa 32,2 MB en formato 
	tgz y 26,4 MB en formato bzip2.
	</para>

	</sect2>

	<sect2>
	<title>¿Cuánto tiempo tomará?</title>

	<para>
	Con las máquinas más nuevas, la compilación toma dramáticamente menos 
	tiempo que con las antiguas; un AMD K6-2/300 con un disco rápido puede 
	crear un núcleo 2.2.x en cerca de cuatro minutos. En cuanto a los viejos 
	Pentiums, 486s, y 386s, si planea compilar un uno, prepárese para 
	esperar, posiblemente horas, días..
	</para>

	<para>
	Si esto le molesta, y sucede que tiene una máquina más rápida 
	alrededor para compilarlo, puede construirlo en la máquina rápida 
	(asumiendo que le de los parámetros correctos, que sus utilidades estén 
	 actualizados, etcétera), y después transferir la imagen del núcleo a 
	la máquina más lenta.
	</para>

	</sect2>

	</sect1>

	<sect1>
	<title>Cómo se configura realmente el núcleo</title>

	<sect2>
	<title>Consiguiendo el fuente</title>

	<para>
	Puede obtener el fuente vía FTP anónimo desde <literal remap="tt">ftp.kernel.org</literal> 
	dentro de <literal remap="tt">/pub/linux/kernel/vx.y</literal>, donde <literal remap="tt">x.y</literal> es la 
	versión (ej. 2.2), y como mencioné antes, las que terminan con un 
	número impar son versiones de desarrollo y puede ser inestables. Este se 
	etiqueta típicamente <literal remap="tt">linux-x.y.z.tar.gz</literal>, donde <literal remap="tt">x.y.z </literal> 
	es el número de versión. Los sitios también llevan típicamente unos 
	con un sufijo <literal remap="tt">.bz2</literal>, que han sido comprimidos con bzip2 (estos 
			ficheros serán más pequeños y tomarán menos tiempo para 
			transferirse).
	</para>

	<para>
	Es mejor utilizar <literal remap="tt">ftp.xx.kernel.org</literal> , donde <literal remap="tt">xx</literal> es el 
	código de su país; siendo ejemplos <literal remap="tt">ftp.at.kernel.org</literal> para 
	Austria, y <literal remap="tt">ftp.us.kernel.org</literal> para los Estados Unidos. 
	</para>

	</sect2>

	<sect2>
	<title>Desempaquetando el fuente</title>

	<para>
	Ingrese como `<literal remap="tt">root</literal>' o conviértase en `<literal remap="tt">root</literal>' con el 
	comando <literal remap="tt">su</literal>, y vaya al directorio <literal remap="tt">/usr/src</literal>. Si instaló 
	el fuente del núcleo cuando primero instaló Linux (como hace la 
			mayoría), allí ya habrá un directorio llamado `<literal remap="tt">linux</literal>', que 
	contiene el árbol del antiguo fuente. Si tiene espacio en disco y 
	quiera actuar con seguridad, preserve ese directorio. Una buena idea es 
	deducir que versión se está ejecutando ahora en su sistema y renombrar 
	el directorio de acuerdo a esto. El comando `<literal remap="tt">uname -r</literal>' imprime 
	la versión actual de núcleo. Por lo tanto, si `<literal remap="tt">uname -r</literal>' dijo 
	`<literal remap="tt">1.0.9</literal>', tendría que renombrar (con `<literal remap="tt">mv</literal>') 
	`<literal remap="tt">linux</literal>' a `<literal remap="tt">linux-1.0.9</literal>'. Si se siente levemente 
	temerario, simplemente borre el directorio completo. En este caso, 
	asegúrese de que no halla un directorio `<literal remap="tt">linux</literal>' dentro de 
	<literal remap="tt">/usr/src</literal> antes de desempaquetar el código fuente completo.
	</para>

	<para>
	Ahora, en <literal remap="tt">/usr/src</literal>, desempaquete el fuente con `<literal remap="tt">tar zxpvf linux-x.y.z.tar.gz</literal>' (si justo obtuvo un fichero <literal remap="tt">.tar</literal> sin 
			<literal remap="tt">.gz</literal> al final, funcionará `<literal remap="tt">tar xpvf linux-x.y.z.tar</literal>' ). 
	Los contenidos del fuente comenzarán a aparecer. Cuando acabe, habrá un 
	nuevo directorio `<literal remap="tt">linux</literal>' en <literal remap="tt">/usr/src</literal>. Vaya al 
	directorio linux y mire dentro del fichero <literal remap="tt">README</literal>. Habrá una 
	sección con la etiqueta `<literal remap="tt">INSTALLING the kernel</literal>'. Lleve a cabo 
	las instrucciones cuando sean apropiadas - los vínculos simbólicos que 
	deberían estar en un lugar, borrado de los ficheros <literal remap="tt">.o</literal> 
	antiguos, etc.
	</para>

	<para>
	Si tiene un fichero <literal remap="tt">.bz2</literal> y el programa bzip2 (lea acerca de 
			éste en <literal remap="tt">http://www.muraroa.demon.co.uk/</literal>), haga esto:
	</para>

	<para>
	bz2cat linux-x.y.z.tar.bz2 | tar xvf -
	</para>

	</sect2>

	<sect2>
	<title>Configurando el núcleo</title>

	<para>
	Nota: Algo de esto es una reiteración/clarificación de una 
	sección similar en el fichero ' <literal remap="tt">README</literal> de Linus.
	</para>

	<para>
	El comando `<literal remap="tt">make config</literal>' mientras está en 
	<literal remap="tt">/usr/src/linux</literal> arranca un script de configuración que le 
	realiza muchas preguntas. Este requiere bash, así que verifique que el 
	bash esté en <literal remap="tt">/bin/bash</literal>, <literal remap="tt">/bin/sh</literal>, o 
	<literal remap="tt">$BASH</literal>.
	</para>

	<para>
	Sin embargo, hay algunas alternativas mucho más agradables a `<literal remap="tt">make config</literal>' y puede encontrarlos más fáciles y cómodos de usar. 
	`<literal remap="tt">make menuconfig</literal>' es probablemente el más ampliamente 
	utilizado. Cualquiera que elija, es mejor familiarizarse con la interfase 
	debido a que puede encontrársela de vuelta más pronto de lo que piensa.
	Para aquellos corriendo X-Windows pueden tratar con `<literal remap="tt">make xconfig</literal>' si es que tienen instalado Tk (`click-o-rama' - Nat). 
	`<literal remap="tt">make menuconfig</literal>'  es para aquellos que tienen (n)curses y 
	prefieren un menú basado en texto. Estas interfaces tienen una ventaja 
	bastante clara: Si se equivoca y elige una opción incorrecta durante la 
	configuración, es simple volver y corregirla.
	</para>

	<para>
	Las opciones de configuración aparecerán en jerarquías con `<literal remap="tt">make menuconfig</literal>' y `<literal remap="tt">make xconfig</literal>'.
	</para>

	<para>
	Está listo para responder las preguntas, usualmente con `<literal remap="tt">y</literal>' 
	(si) or `<literal remap="tt">n</literal>' (no). Los controladores de dispositivo tiene una 
	opción `m'.  Esto significa ``modulo'' lo que significa que el sistema 
	lo compilará, pero no directamente en el núcleo, sino como un módulo 
	cargable. Una forma más cómica de describir esto es ``puede ser''. 
	Aquí se describen algunas de las opciones más obvias y no críticas; 
	vea la sección ``Otras opciones de configuración'' para obtener 
	descripciones cortas de algunas otras. Con `<literal remap="tt">make menuconfig</literal>', la 
	barra espaciadora fija la selección.
	</para>

	<para>
	En la versión 2.0.x y posteriores, hay una opción `?', que proporciona 
	una breve descripción del parámetro de configuración. Ésta 
	información es probablemente la más actualizada. Aquí está un listado 
	de algunas de las características importantes, en que jerarquía están 
	ellas y una breve descripción.
	</para>

	<sect3>
	<title>Emulación de coprocesador del Kernel (Processor type and features)</title>

	<para>
	Si no tiene un coprocesador matemático (tiene un 386 o 
			486SX pelado), debe decir `<literal remap="tt">y</literal>' a esto. Si tiene un coprocesador y 
	todavía dice `<literal remap="tt">y</literal>', no se preocupe demasiado -- el coprocesador 
	todavía será usado y la emulación ignorada. Para cualquier máquina 
	media moderna, la respuesta sería no, pero no se preocupe si dice si 
	accidentalmente; si no es necesitada, esta no es usada.
	</para>

	</sect3>

	<sect3>
	<title>Soporte de discos mejorados (MFM/RLL) y discos/CD-ROMs IDE (Block Devices)</title>

	<para>
	Probablemente necesite este soporte; esto significa que el núcleo 
	soportará los discos rígidos estándares de PC, que la mayoría de la 
	gente tiene. Este controlador no incluye discos SCSI; ellos vienen más 
	adelante en la configuración.
	</para>

	<para>
	Luego se le preguntará sobre los controladores de ``old disk-only'' y 
	``new IDE''. Necesita elegir uno de ellos; la principal diferencia es que 
	el controlador antiguo soporta solamente dos discos en una sola 
	interfase, y el nuevo soporta una interfase secundaria y unidades de 
	CD-ROM IDE/ATAPI. El nuevo controlador es 4k mas largo que el antiguo y 
	además supuestamente está mejorado, lo que significa que además de 
	contener un número diferente de errores, puede ser que mejore el 
	funcionamiento de su disco, especialmente si tiene un hardware más nuevo 
	(tipo EIDE).
	</para>

	</sect3>

	<sect3>
	<title>Soporte de redes (General Setup)</title>

	<para>
	En principio, solo diría `<literal remap="tt">y</literal>' si su máquina está en una red 
	tal como el Internet, o si necesita utilizar SLIP, PPP, term, etc. para 
	discar y acceder a Internet. Sin embargo, muchos paquetes (como el 
			sistema X- Windows) requieren el soporte de red incluso si su máquina no 
	está dentro de una red verdadera, por lo que debería decir 
	`<literal remap="tt">y</literal>'. Más adelante, se le preguntará si quiere soporte de red 
	TCP/IP; nuevamente, diga `<literal remap="tt">y</literal>' aquí si no está absolutamente 
	seguro.
	</para>

	</sect3>

	<sect3>
	<title>Comunicación entre procesos System V (General Setup)</title>

	<para>
Una de las mejores definiciones del IPC (comunicación entre procesos) 
	está en el glosario del libro de Perl. No sorpresivamente, algunos 
	programadores de Perl lo emplean para permitir a los procesos hablar 
	entre sí, así como muchos otros paquetes (DOOM, el destacable); así 
	que no es una buena idea decir <literal remap="tt">n</literal> a menos que sepa exactamente lo 
	que está haciendo.
	</para>

	</sect3>

	<sect3>
	<title>Familia del procesador (Processor type and features)</title>

	<para>
	(en los núcleos antiguos: Use la opción -m486 para optimizaciones 
	 propias del 486)
	</para>

	<para>
	Tradicionalmente, este era compilado con ciertas optimizaciones para un 
	procesador particular; los núcleos funcionaban bien en otras CPUs, pero 
	el núcleo quizás era un poquito mas grande. En los núcleos más 
	nuevos, sin embargo, esto a la larga no es verdad, así que debe ingresar 
	el procesador para el cual está compilando el núcleo. Un núcleo 
	``386'' funcionará en todas las máquinas.
	</para>

	</sect3>

	<sect3>
	<title>Soporte SCSI (SCSI support)</title>

	<para>
	Si tiene dispositivos SCSI, diga `<literal remap="tt">y</literal>'. Se le preguntará 
	información mas detallada, como el soporte para CD-ROM, discos, y que 
	tipo de adaptador SCSI tiene. Vea el documento SCSI-HOWTO para mayores 
	detalles.
	</para>

	</sect3>

	<sect3>
	<title>Soporte de dispositivos de red (Network device support)</title>

	<para>
	Si tiene una tarjeta de red, o quiere utilizar SLIP, PPP, o un adaptador 
	de puerto paralelo para conectarse a Internet, diga `<literal remap="tt">y</literal>'. El 
	script de configuración le preguntará el tipo de tarjeta que tiene, y 
	el protocolo a utilizar.
	</para>

	</sect3>

	<sect3>
	<title>Sistemas de ficheros (Filesystems)</title>

	<para>
	El script de configuración luego pregunta si quiere el soporte de los 
	siguientes sistemas de ficheros:
	</para>

	<para>
	Estándar (minix) - Las distribuciones más nuevas no crean sistemas de 
	ficheros minix, y mucha gente no lo utiliza, pero todavía puede ser una 
	buena idea configurarlo. Algunos programas de ``disco de rescate'' lo 
	utilizan, y todavía muchos disquetes pueden tener un sistema de ficheros 
	minix, puesto que el sistema de ficheros minix es el menos doloroso de 
	utilizar en un disquete.
	</para>

	<para>
	Second extended - Éste el sistema de ficheros standard de Linux. Tiene 
	casi seguro uno de estos, y necesitará de decir `<literal remap="tt">y</literal>'.
	</para>

	<para>
	msdos - Si quiere utilizar sus particiones de disco rígido MS-DOS, o 
	montar disquetes formateados en MS-DOS, diga `<literal remap="tt">y</literal>'.
	</para>

	<para>
	Hay disponibles varios tipos de sistemas de ficheros de otros sistemas 
	operativos.
	</para>

	<para>
	/proc - (idea de los Laboratorio Bell, supongo). Uno no hace un sistema 
	de ficheros proc en un disco; este es un sistema de ficheros interfase al 
	núcleo y los procesos. Muchos listadores de procesos (como 
			`<literal remap="tt">ps</literal>') lo utilizan. Intente alguna vez `<literal remap="tt">cat /proc/meminfo</literal>' o `<literal remap="tt">cat /proc/devices</literal>' . Algunos shells (rc, 
				en particular) usan <literal remap="tt">/proc/self/fd</literal>  (conocido como 
					<literal remap="tt">/dev/fd</literal> en otros sistemas) para E/S. Debe decir casi seguro 
				`<literal remap="tt">y</literal>' a esto; muchas herramientas importantes del Linux dependen 
				de éste.
				</para>

				<para>
				NFS - Si su máquina vive en una red y desea utilizar sistemas de 
				ficheros que residen en otros sistemas con NFS, diga `<literal remap="tt">y</literal>'.
				</para>

				<para>
				ISO9660 - Encontrado en la mayoría de los CD-ROMs. Si tiene una unidad 
				CD-ROM y desea utilizarla bajo Linux, diga `<literal remap="tt">y</literal>'.
				</para>

				<sect4>
				<title>¡Pero no sé qué sistemas de ficheros necesito!</title>

				<para>
				Bueno, teclee `<literal remap="tt">mount</literal>'. La salida mostrará algo como esto:
				</para>

				<para>

				<screen>
	blah# mount
	/dev/hda1 on / type ext2 (defaults)
	/dev/hda3 on /usr type ext2 (defaults)
	none on /proc type proc (defaults)
/dev/fd0 on /mnt type msdos (defaults)
	</screen>

	</para>

	<para>
	Mire cada línea; la palabra después de `<literal remap="tt">type</literal>' es el tipo de 
	sistema de ficheros. En este ejemplo, mi sistema de ficheros <literal remap="tt">/</literal> 
	y <literal remap="tt">/usr</literal> son second extended, yo estoy utilizando <literal remap="tt">/proc</literal>, 
	y hay un disquete montado usando el sistema de ficheros MSDOS.
	</para>

	<para>
	Puede intentar `<literal remap="tt">cat /proc/filesystems</literal>' si actualmente tiene 
	habilitado <literal remap="tt">/proc</literal>; esto listará los sistemas de ficheros de su 
	núcleo actual.
	</para>

	<para>
	La configuración se usa raramente, los sistemas de ficheros no críticos 
	pueden causar que el núcleo se hinche; vea la sección de los módulos 
	por la forma de evitar esto y la sección de ``Trampas'' sobre el porqué 
	un núcleo hinchado es indeseable.
	</para>

	</sect4>

	</sect3>

	<sect3>
	<title>Dispositivos de caracter (Character devices)</title>

	<para>
	Aquí, habilita los controladores para su impresora (esta es una 
			impresora paralela), el puerto de ratón, el ratón PS/2 (muchas 
				notebooks usan el protocolo de ratón PS/2 para sus trackballs 
				incorporados), algunas unidades de cinta, y otros dispositivos de 
			``caracter''. Diga `<literal remap="tt">y</literal>' cuando sea apropiado.
			</para>

			<para>
			Nota: <literal remap="tt">gpm</literal> (General Purpose Mouse support) es un programa que 
			permite el uso del ratón fuera del sistema X-Windows para cortar y pegar 
			entre las consolas virtuales. Este es bastante agradable si tiene un 
			ratón serie, porque coexiste bien con X, pero necesita realizar trucos 
			especiales para otros.
			</para>

			</sect3>

			<sect3>
			<title>Sonido</title>

			<para>
			Si siente un gran deseo de oír el ladrido de <literal remap="tt">biff</literal>, diga 
			`<literal remap="tt">y</literal>', y puede decirle al programa de configuración todo acerca 
			de la tarjeta de sonido. (Nota sobre la configuración de la tarjeta de 
					sonido: cuando le pregunte si desea instalar la versión completa del 
					controlador, puede decir `<literal remap="tt">n</literal>' y ahorrar algo de memoria del 
					núcleo, eligiendo solo las características que considere necesarias).
			</para>

			<para>
			Si es serio acerca del soporte de la tarjeta de sonido, de una mirada a 
			los  controladores libres en <literal remap="tt">http://www.linux.org.uk/OSS/</literal> y al 
			comercial Open Sound System en <literal remap="tt">http://www.opensound.com/</literal>.
			</para>

			</sect3>

			<sect3>
			<title>Otras opciones de configuración</title>

			<para>
			No todas las opciones de configuración se enumeran aquí porque ellas 
			cambian demasiado a menudo o se evidencian bastante a sí mismas (por 
					ejemplo, el soporte 3Com 3C509 compila el controlador de dispositivo para 
					esta tarjeta Ethernet en particular). Existe una lista bastante extensa 
			de todas las opciones (mas la forma de colocarlas en el script 
					<literal remap="tt">Configure</literal>) en un esfuerzo comenzado y mantenido por Axel Boldt 
			(<literal remap="tt">boldt@math.ucsb.edu</literal>) y su ayuda en línea. Ésta también está 
			disponible como un fichero grande en la ubicación 
			<literal remap="tt">Documentation/Configure.help</literal> del fuente de su núcleo de Linux 
			núcleo a partir de la versión 2.0
			</para>

			</sect3>

			<sect3>
			<title>Hackeando el núcleo (Kernel hacking)</title>

			<para>
			&#62;Del fichero README de Linus:
			</para>

			<para>
			La configuración detallada del ``kernel hacking'' resulta usualmente 
			en un núcleo más grande o más lento (o ambos), y puede incluso 
			hacer el núcleo menos estable configurando algunas rutinas para 
			intentar activamente detener el código dañino para encontrar 
			problemas del núcleo (kmalloc()). Así, probablemente debe contestar 
			`n' a las preguntas para un núcleo de ``producción''.
			</para>

			</sect3>

			</sect2>

			<sect2>
			<title>¿Y ahora qué? (El fichero Makefile)</title>

			<para>
			Después que finalizó la configuración, un mensaje le dice que su 
			núcleo ha sido configurado, y que ``revise la parte superior del fichero 
			<literal remap="tt">Makefile</literal> para configuración adicional'', etc.
			</para>

			<para>
			Así, mire el fichero <literal remap="tt">Makefile</literal>. Probablemente no necesitará 
			cambiarlo, pero este nunca se dañará si se lo mira. Puede también 
			cambiar sus opciones con el comando `<literal remap="tt">rdev</literal>'  una vez que el nuevo 
			núcleo esta en su lugar. Si se siente perdido cuando mira en el fichero, 
			entonces no se preocupe por él.
			</para>

			</sect2>

			</sect1>

			<sect1>
			<title>Compilando el núcleo</title>

			<sect2>
			<title>Limpieza y dependencias</title>

			<para>
			Cuando el script de configuración termina, este también le dice a que 
			teclee `<literal remap="tt">make dep</literal>' y (posiblemente) `<literal remap="tt">make clean</literal>'. Así, 
			haga el `<literal remap="tt">make dep</literal>'. Esto asegura que todas las dependencias, 
			así como los ficheros include, están en su lugar. Esto no toma mucho 
			tiempo, a menos que su computadora sea bastante lenta desde un comienzo. 
			Para las versiones antiguas del núcleo, cuando finalizaba, debe hacer un 
			`<literal remap="tt">make clean</literal>'. Esto elimina todos los ficheros objeto y algunas 
			otras cosas que una versión antigua dejo detrás. En cualquier caso, 
			<emphasis remap="it">no</emphasis> se olvide de este paso antes de intentar recompilar un 
			núcleo.
			</para>

			</sect2>

			<sect2>
			<title>La hora de compilar</title>

			<para>
			Después de que terminan <literal remap="tt">dep</literal> y <literal remap="tt">clean</literal>, puede hacer 
			`<literal remap="tt">make bzImage</literal>' or `<literal remap="tt">make bzdisk</literal>' (esta es la parte que 
					toma un largo tiempo). `<literal remap="tt">make bzImage</literal>' compilará el núcleo, y 
			dejara un fichero en <literal remap="tt">arch/i386/boot</literal> llamado <literal remap="tt">bzImage</literal> 
			(entre otras cosas). Este es el nuevo núcleo comprimido. `make bzdisk' 
			hace la misma cosa, pero además pone una nueva bzImage en un disquete 
			que puso esperanzadamente en la unidad ``A:''. `<literal remap="tt">bzdisk</literal>' es 
			bastante práctico para probar nuevos núcleos; si este explota (o 
					simplemente no funciona apropiadamente), solo quite el disquete y 
			arranque con su antiguo núcleo. Esta también puede ser una forma 
			práctica de arrancar si accidentalmente removió su núcleo (o algo 
					igualmente terrible). También puede utilizarlo para instalar nuevos 
			sistemas cuando vuelca los contenidos de un disco a otro (``¡Todo esto y 
					más! ¿AHORA cuanto pagaría usted?'').
			</para>

			<para>
			Todos, incluso los núcleos bastante recientes están comprimidos, de 
			ahí el `<literal remap="tt">bz</literal>' en el frente de lo nombres. Un núcleo comprimido 
			se descomprime automáticamente a si mismo cuando se ejecuta.
			</para>

			<para>
			En los núcleos antiguos, no tiene la opción del construir una 
			<literal remap="tt">bzImage</literal>; simplemente era una <literal remap="tt">zImage</literal>. Esa opción 
			todavía está disponible en este momento, sin embargo, dado el tamaño 
			del código de los núcleos más nuevos, ahora es mas o menos obligatorio 
			construir una <literal remap="tt">bzImage</literal>, porque los métodos más antiguos no 
			pueden manejar un núcleo que simplemente sea demasiado grande.
			</para>

			</sect2>

			<sect2>
			<title>Otras opciones de ``make''</title>

			<para>
			`<literal remap="tt">make mrproper</literal>' realizará una `<literal remap="tt">limpieza</literal>' más extensa. 
			Esta algunas veces es necesaria; puede desear hacerla en cada parche. 
			`<literal remap="tt">make mrproper</literal>' borrará también su fichero de configuración, 
			de manera que podría querer hacer una copia de respaldo de él 
			(<literal remap="tt">.config</literal>), si lo ve como valioso.
			</para>

			<para>
			`<literal remap="tt">make oldconfig</literal>'  tratará de configurar el núcleo desde un 
			fichero de configuración antiguo; este ejecutará el proceso `<literal remap="tt">make config</literal>' por usted. Si nunca antes ha compilado un núcleo o si no 
			tiene un fichero de configuración antiguo, entonces probablemente no 
			realice esto, ya que lo más probable es que desee cambiar la 
			configuración por defecto.
			</para>

			<para>
			Vea la sección sobre los módulos para una descripción de `<literal remap="tt">make
			modules</literal>'.
			</para>

			</sect2>

			<sect2>
			<title>Instalando el núcleo</title>

			<para>
			Después de que tenga un nuevo núcleo que parece funcionar de la forma 
			que desea, es hora de instalarlo. La mayoría de la gente utiliza LILO 
			(LInux LOader) para esto. Con `<literal remap="tt">make bzlilo</literal>' se instalará el 
			núcleo ejecutando el LILO, y tendrá todo listo para arrancar, PERO SOLO 
			si el lilo está configurado de la siguiente manera en su sistema: el 
			núcleo es <literal remap="tt">/vmlinuz</literal>, el lilo está en <literal remap="tt">/sbin</literal>, y la 
			configuración de lilo (<literal remap="tt">/etc/lilo.conf</literal>) concuerdan con esto.
			</para>

			<para>
			Si no, necesita utilizar LILO directamente. Este es un paquete bastante 
			fácil de instalar y utilizar, pero este tiene una tendencia a confundir 
			a la gente con el fichero de configuración. Mire el fichero de 
			configuración (cualquier /etc/lilo/config para las versiones antiguas o 
					/etc/lilo.conf para las nuevas versiones), y vea cual es la 
			configuración actual. El fichero de configuración se parece a esto:
			</para>

			<para>
			image = /vmlinuz
			label = Linux
			root = /dev/hda1
			...
			</para>

			<para>
			La línea `<literal remap="tt">image =</literal>' se fija al núcleo instalado actualmente. La 
			mayoría de la gente usa <literal remap="tt">/vmlinuz</literal>. La etiqueta `<literal remap="tt">label</literal>' 
			es usada por lilo para determinar que núcleo o sistema operativo 
			arrancar, y `<literal remap="tt">root</literal>' es el <literal remap="tt">/</literal> de ese sistema operativo en 
			particular. Haga una copia de respaldo de su antiguo núcleo y copie la 
			<literal remap="tt">bzImage</literal> que acaba de crear en su lugar (Debería decir `<literal remap="tt">cp bzImage /vmlinuz</literal>' si utiliza `<literal remap="tt">/vmlinuz</literal>'). Luego, vuelva a 
			ejecutar lilo -- en los sistemas más nuevos, solo ejecuta `lilo', pero 
			en los productos más viejos, puede ser que usted tenga que hacer 
			<literal remap="tt">/etc/lilo/install</literal> o aún <literal remap="tt">/etc/lilo/lilo -C /etc/lilo/config</literal>.
			</para>

			<para>
			Si quiere saber más sobre la configuración del LILO, o sí no tiene 
			LILO, obtenga la versión mas nueva desde su sitio FTP preferido y siga 
			las instrucciones.
			</para>

			<para>
			Para arrancar uno de sus núcleos antiguos desde el disco rígido (otra 
					forma de salvarse en caso de que tuerza el nuevo núcleo), copia las 
			líneas de abajo (incluyendo) `<literal remap="tt">image = xxx</literal>' en la parte de abajo 
			del fichero de configuración de LILO, y cambie `<literal remap="tt">image = xxx</literal>' 
			por `<literal remap="tt">image = yyy</literal>', donde `<literal remap="tt">yyy</literal>' es el nombre del camino 
			completo al fichero en donde grabó la copia de seguridad su núcleo. 
			Luego, cambie la etiqueta `<literal remap="tt">label = zzz</literal>' por `<literal remap="tt">label = linux-backup</literal>'`<literal remap="tt">label = linux-backup</literal>' y vuelva a ejecutar 
			<literal remap="tt">lilo</literal>. Puede necesitar poner una línea en el fichero de 
			configuración diciendo `<literal remap="tt">delay=x</literal>', donde x es la cantidad de 
			décimas de segundo que el LILO espera antes de arrancar, de manera que 
			pueda interrumpirlo (con la tecla Shift, por ejemplo), y teclee la 
			etiqueta de la de la copia de respaldo de la imagen de arranque (en caso 
					de que ocurran cosas desagradables).
			</para>

			</sect2>

			</sect1>

			<sect1>
			<title>Parcheando el núcleo</title>

			<sect2>
			<title>Aplicando un parche</title>

			<para>
			Las actualizaciones incrementales del núcleo se distribuyen como 
			parches. Por ejemplo, si tiene la versión 1.1.45, y se entera que por 
			ahí hay un parche `<literal remap="tt">patch46.gz</literal>', esto significa que puede 
			actualizarse a la versión 1.1.46 a través de la aplicación del parche. 
			Puede ser que desee hacer primero una copia de seguridad del árbol del 
			fuente (`<literal remap="tt">make clean</literal>' y luego `<literal remap="tt">cd /usr/src; tar zcvf old-tree.tar.gz linux</literal>' creará un fichero tar comprimido para 
					usted).
			</para>

			<para>
			Así, continuando con el ejemplo anterior, supongamos que tiene el parche 
			`<literal remap="tt">patch46.gz</literal>' en <literal remap="tt">/usr/src</literal>. Vaya a <literal remap="tt">/usr/src</literal> y 
			haga `<literal remap="tt">zcat patch46.gz | patch -p0</literal>' (o `<literal remap="tt">patch -p0 &lt; patch46</literal>' si el parche no está comprimido). Verá cosas que pasan 
			deprisa (o confusas, si es que su sistema es lento) diciéndole que éste 
			está tratando de aplicar partes, y si esto tuvo éxito o no. 
			Generalmente, está acción pasa demasiado rápido como para que lea, y 
			no estará demasiado seguro si esto funcionó o no, así que puede que 
			quiera utilizar la opción <literal remap="tt">-s</literal> del programa <literal remap="tt">patch</literal>, la 
			cual le dice a <literal remap="tt">patch</literal> que solo reporte los mensajes de error (no 
					consigue algo de la sensación ``hey, mi computadora está haciendo 
					actualmente algo para un cambio!'', pero puede preferir esto). Para 
			buscar las partes que pueden no haberse ido fácilmente, vaya a 
			<literal remap="tt">/usr/src/linux</literal> y busque los ficheros con la extensión .rej. 
			Algunas versiones de <literal remap="tt">patch</literal> (las versiones más antiguas que 
					pudieron haber sido compiladas en un sistema de ficheros inferior) 
			dejaban los rechazos con una extensión <literal remap="tt">#</literal>. Puede utilizar el 
			comando `<literal remap="tt">find</literal>' para que busque por usted;
			find .  -name '*.rej' -print
			imprime en la salida standard todos los ficheros con una extensión 
			<literal remap="tt">.rej</literal> que existen en el directorio actual o en cualquier
			subdirectorio.
			</para>

			<para>
			Si todo fuera correcto, haga `<literal remap="tt">make clean</literal>', `<literal remap="tt">config</literal>', y 
			`<literal remap="tt">dep</literal>', como se  describe en las secciones 3 y 4.
			</para>

			<para>
			Hay bastantes opciones para el comando <literal remap="tt">patch</literal>. Como hemos 
			mencionado anteriormente, <literal remap="tt">patch -s</literal> suprimirá todos los mensajes 
			excepto los errores. Si mantiene el fuente de su núcleo en un algún 
			otro lugar que <literal remap="tt">/usr/src/linux</literal>, <literal remap="tt">patch -p1</literal> (en ese 
					directorio) parcheará las cosas limpiamente. Las otras opciones del 
			comando <literal remap="tt">patch</literal> están bien documentadas en la página del manual.
			</para>

			</sect2>

			<sect2>
			<title>Si algo va malSi algo va mal</title>

			<para>
			(Nota: esta sección se refiere en su mayoría a núcleos bastante
			 antiguos)
			</para>

			<para>
			El problema más frecuente que aparecería era cuando un parche 
			modificaba un fichero llamado `<literal remap="tt">config.in</literal>' y este no tenía un 
			aspecto totalmente correcto, debido a que cambió las opciones para 
			satisfacer a su máquina. Tiene que tener cuidado de esto, sin embargo 
			uno todavía podría encontrárselo con una versión más antigua. Para 
			arreglar esto, mire en el fichero <literal remap="tt">config.in.rej</literal>, y vea que se 
			conserva del parche original. Los cambios típicamente serán marcados 
			con `<literal remap="tt">+</literal>' y `<literal remap="tt">-</literal>' al principio de la línea. Mire las 
			líneas que la rodean, y recuerde si ellas fueron puestas a `<literal remap="tt">y</literal>' 
			o `<literal remap="tt">n</literal>'. Ahora, edite el fichero config.in, y cambie el 
			<literal remap="tt">y</literal>' por `<literal remap="tt">n</literal>'  y el `<literal remap="tt">n</literal>' por `<literal remap="tt">y</literal>' cuando 
			sea apropiado. Haga
			patch -p0 &#60; config.in.rej
			y si este reporta que tuvo éxito (no fallas), entonces puede continuar 
			adelante con una configuración y compilación. El fichero 
			<literal remap="tt">config.in.rej</literal> se conservará, pero puede llegar a borrarlo. 
			</para>

			<para>
			Si encuentra otros problemas, puede ser que haya instalado un parche 
			fuera de servicio. Si el programa patch dice `<literal remap="tt">previously applied patch detected: Assume -R?</literal>' , probablemente está intentando aplicar 
			un parche que está debajo de su número de versión actual; si contesta 
			`<literal remap="tt">y</literal>', éste intentará degradar su fuente, y muy probablemente 
			fallará; así, necesitará obtener un nuevo árbol del fuente entero (lo 
					cual no habría sido una mala idea en el primer lugar).
			</para>

			<para>
			Para volver atrás (desaplicarlo) un parche, use `<literal remap="tt">patch -R</literal>' con 
			el parche original.
			</para>

			<para>
			La mejor cosa a hacer cuando los parches realmente resultan erróneos es 
			comenzar de nuevo con todo limpio, partiendo desde el árbol del fuente 
			(Por ejemplo, desde los ficheros de <literal remap="tt">linux-x.y.z.tar.gz</literal>), y 
			comenzando otra vez.
			</para>

			</sect2>

			<sect2>
			<title>Deshaciéndose de los ficheros .orig</title>

			<para>
			Después de apenas unos pocos parches, los ficheros <literal remap="tt">.orig</literal> 
			comenzarán a amontonarse. Por ejemplo, en un árbol 1.1.51 que yo había 
			limpiado por última vez desde la 1.1.48. Removiendo los ficheros .orig 
			recuperé mas de medio Megabyte. Con
			find .  -name '*.orig' -exec rm -f {} ';'
			llevará a cabo esto por usted. Las versiones de los programas 
			<literal remap="tt">patch</literal> que usan el <literal remap="tt">#</literal> para los ficheros rechazados, 
			utilizan un tilde ` ' en vez de <literal remap="tt">.orig</literal>.
			</para>

			<para>
			Hay mejores formas de librarse de los ficheros <literal remap="tt">.orig</literal>, las cuales 
			dependen del GNU <literal remap="tt">xargs</literal>:
			find .  -name '*.orig' | xargs rm
			o el método ``bastante seguro, pero un poco más informativo'':
			find . -name '*.orig' -print0 | xargs --null rm --
			</para>

			</sect2>

			<sect2>
			<title>Otros parches</title>

			<para>
			Hay otros parches (yo los llamare ``no estándares'') además de los que 
			distribuye Linus. Si aplica esos, los parches de Linus pueden no 
			funcionar correctamente y tendrá que volver atrás ambos, corregir el 
			fuente o el parche, instalar un nuevo árbol de fuente, o una 
			combinación de lo anterior. Esto puede volverse muy frustrante, así que 
			si no desea modificar el fuente (con la posibilidad de un resultado muy 
					malo), retire los parches no estándares antes de aplicar los de Linus, o 
			simplemente instale un nuevo árbol. Luego, puede ver si los parches no 
			estándares todavía funcionan. Si no lo hacen, o está atascado con un 
			núcleo antiguo, jugando con parche o el fuente para conseguir que 
			funcione, o esperando (posiblemente rogando) que salga una nueva versión 
			del parche.
			</para>

			<para>
			¿Cómo de comunes son los parches no en la distribución standard? 
			Probablemente escuchó de ellos. Yo lo usé para utilizar el parche 
			noblink para mis consolas virtuales, porque yo detesto que los cursores 
			parpadeen. (Este parche es (o al menos era) frecuentemente actualizado 
					para las nuevas versiones del núcleo). Con la mayoría de los 
			controladores de dispositivo más nuevos desarrollándose como módulos 
			cargables, no obstante, la frecuencia de los parches ``no-estándares'' 
			está decreciendo significativamente.
			</para>

			</sect2>

			</sect1>

			<sect1>
			<title>Paquetes adicionales</title>

			<para>
			Su núcleo de Linux tiene muchas características que no están 
			explicadas en el fuente del núcleo en sí; éstas características son 
			utilizadas típicamente a través de paquetes externos. Algunas de las 
			más comunes están listadas aquí.
			</para>

			<sect2>
			<title>kbd</title>

			<para>
			La consola de Linux probablemente tiene más características de lo que 
			merece. Entre esas esta la capacidad de cambiar las fuentes, remapear el 
			teclado, cambiar los modos de video (en los núcleos más nuevos), etc. 
			El paquete kbd tiene los programas que le permiten al usuario hacer todo 
			esto, además de muchas fuentes y mapas de teclado para casi cualquier 
			teclado, y está disponible en los mismos sitios que llevan el fuente del 
			núcleo.
			</para>

			</sect2>

			<sect2>
			<title>util-linux</title>

			<para>
			Rik Faith (<literal remap="tt">faith@cs.unc.edu</literal>) reunió una gran colección de 
			utilitarios de Linux que son, solo por coincidente, llamados util-linux. 
			Éstos ahora son mantenidos por Andries Brouwer 
			(<literal remap="tt">util-linux@math.uio.no</literal>). Están disponibles vía FTP anónimo 
			en ftp://sunsite.unc.edu , dentro de <literal remap="tt">/pub/Linux/system/misc</literal>, y 
			contienen programas como <literal remap="tt">setterm</literal>, <literal remap="tt">rdev</literal>, y 
			<literal remap="tt">ctrl-alt-del</literal>, los cuales son importantes para el núcleo. Como 
			dice Rik, <emphasis remap="it">no lo instale sin pensarlo</emphasis>; no necesita instalar todas 
			las cosas en el paquete, y si lo hace muy bien podría causar serios 
			problemas.
			</para>

			</sect2>

			<sect2>
			<title>hdparm</title>

			<para>
			Como con muchos paquetes, este era una vez un parche del núcleo y 
			programas de soporte. Los parches se hicieron en el núcleo oficial, y 
			los programas para optimizar y jugar con su disco rígido se distribuyen 
			por separado.
			</para>

			</sect2>

			<sect2>
			<title>gpm</title>

			<para>
			gpm se encarga del soporte de ratón con propósitos generales. Este 
			programa le permite cortar y pegar texto entre las consolas virtuales y 
			hacer otras cosas con una gran variedad de tipos de ratón.
			</para>

			</sect2>

			</sect1>

			<sect1>
			<title>Algunas trampas</title>

			<sect2>
			<title>make clean</title>

			<para>
			Si su nuevo núcleo hace cosas realmente extrañas después de una rutina 
			de actualización del núcleo, puede que se olvidó de hacer <literal remap="tt">make clean</literal> antes de la compilar el nuevo núcleo. Los síntomas pueden 
			ser cualesquier cosa, como que su sistema se cuelgue seguido, problemas 
			extraños de E/S, hasta funcionamiento algo interrumpido. Asegúrese de 
			que haga también <literal remap="tt">make dep</literal>.
			</para>

			</sect2>

			<sect2>
			<title>Núcleos grandes o lentos</title>

			<para>
			Si su núcleo está consumiendo mucha memoria, es demasiado grande, y/o 
			solo demora para siempre al compilar, incluso cuando tiene su nueva 
			Quadbazillium-III/4400 trabajando en él, probablemente tiene 
			configuradas un montón de cosas innecesarias (controladores de 
					dispositivos, sistemas de ficheros, etc.). Si no lo utiliza, no lo 
			configure, porque estos consumen memoria. El síntoma más evidente de un 
			núcleo engordado es un extremo intercambio de dentro y fuera de memoria 
			al disco; si su disco está haciendo mucho ruido y no es uno de esos 
			viejos Fujitsu Eagles que sonaba como un jet aterrizando cuando se 
			apagaba, examine la configuración de su núcleo. 
			</para>

			<para>
			Puede averiguar cuánta memoria está utilizando el núcleo tomando la 
			cantidad total de memoria en su máquina y restándole la cantidad de 
			memoria total en <literal remap="tt">/proc/meminfo</literal> o la salida del comando 
			`<literal remap="tt">free</literal>'.
			</para>

			</sect2>

			<sect2>
			<title>El puerto paralelo no funciona/mi impresora no funciona</title>

			<para>
			Las opciones de configuración para las PCs son: Primero, bajo la 
			categoría `General Setup', seleccione `Parallel port support' y 
			`PC-style hardware'. Luego bajo `Character devices', seleccione `Parallel 
			printer support'.
			</para>

			<para>
			Después están los nombres. El Linux 2.2 nombra a los dispositivos de 
			impresión de manera diferente que las versiones anteriores. La 
			conclusión de esto es que si tenía <literal remap="tt">lp1</literal> dentro de su viejo 
			núcleo, este será probablemente <literal remap="tt">lp0</literal> dentro del nuevo. Use 
			`<literal remap="tt">dmesg</literal>' o mire dentro de los `logs' en <literal remap="tt">/var/log</literal> para 
			encontrarlo.
			</para>

			</sect2>

			<sect2>
			<title>El núcleo no compila</title>

			<para>
			Si este no compila, entonces es probable que un parche falló, o su 
			fuente está de alguna manera corrupto. La versión del programa gcc 
			también puede no ser correcta, o también puede estar corrupta (Por 
					ejemplo, los ficheros include podrían tener un error). Asegúrese que 
			los vínculos simbólicos que Linux describe en el fichero 
			<literal remap="tt">README</literal> estén fijados correctamente. En general, si un núcleo 
			estándar no compila, algo está seriamente mal con el sistema, y 
			probablemente sea necesaria la reinstalación de ciertas herramientas.
			</para>

			<para>
			En algunos casos, el gcc puede colgarse debido a problemas de hardware. 
			El mensaje de error será algo como ``xxx exited with signal 15'' y 
			generalmente parecerá muy misterioso. No mencionaría probablemente 
			esto, excepto que esto me sucediera una vez - Yo tenía una memoria cache 
			algo mala, y el compilador ocasionalmente daba errores al azar. Si 
			experimenta problemas, primero intente reinstalando el gcc. Solo debería 
			tener sospechas si su núcleo compila bien con el cache desactivado, o 
			con un monto reducido de RAM, etc.
			</para>

			<para>
			Esto tiende disgustar a la gente cuando se sugiere que su hardware tiene 
			problemas. Bien, yo no estoy haciendo esto. Hay una FAQ para esto - ésta 
			está en <literal remap="tt">http://www.bitwizard.nl/sig11/</literal>.
			</para>

			</sect2>

			<sect2>
			<title>La nueva versión del núcleo parece no arrancar</title>

			<para>
			No ejecutó LILO, o éste no está configurado correctamente. Una cosa 
			que una vez ``me ganó'' fue un problema en el fichero de configuración; 
			éste decía `<literal remap="tt">boot = /dev/hda1</literal>' en vez de `<literal remap="tt">boot = /dev/hda</literal>' (Esto puede ser realmente molesto al principio, pero una 
					vez que tenga un fichero de configuración funcionando, no debería 
					necesitar cambiarlo).
			</para>

			</sect2>

			<sect2>
			<title>Se olvidó de ejecutar LILO, o el sistema no arranca en absoluto</title>

			<para>
			¡Vaya problema! La mejor cosa que puede hacer aquí es arrancar desde un 
			disquete o un CDROM y preparar otro disquete arrancable (tal como haría 
					`<literal remap="tt">make zdisk</literal>'). Necesita saber donde está su sistema de ficheros 
			(<literal remap="tt">/</literal>) y de que tipo es (ej. second extended, minix). En el ejemplo 
			de abajo, también necesita saber en que sistema de ficheros está el 
			árbol del fuente <literal remap="tt">/usr/src/linux</literal>, su tipo, y donde este está 
			normalmente montado.
			</para>

			<para>
			En el siguiente ejemplo, <literal remap="tt">/</literal><literal remap="tt">/</literal> es <literal remap="tt">/dev/hda1</literal>, y el 
			sistema de ficheros que almacena <literal remap="tt">/usr/src/linux</literal> es 
			<literal remap="tt">/dev/hda3</literal>, montado normalmente en <literal remap="tt">/usr</literal>. Ambos están en 
			el sistema de ficheros second extended (ext2). La imagen del núcleo 
			activo está en <literal remap="tt">/usr/src/linux/arch/i386/boot</literal> y se llama 
			<literal remap="tt">bzImage</literal>.
			</para>

			<para>
			La idea es que si hay unaLa idea es que si hay una <literal remap="tt">bzImage</literal> que 
			funciona, es posible utilizar esa para el nuevo disquete. Otra 
			alternativa, que puede o no funcionar mejor (depende del método 
					particular con el cual desarregló su sistema) se discute después del 
			ejemplo.
			</para>

			<para>
			Primero, arranque desde un disquete de instalación o de rescate, y monte 
			el sistema de ficheros que contiene la imagen del núcleo que 
			funciona:
			</para>

			<para>
			mkdir /mnt
			mount -t ext2 /dev/hda3 /mnt
			</para>

			<para>
			Si el comando <literal remap="tt">mkdir</literal> le dice que el directorio ya existe, solo 
			ignórelo. Ahora, vaya al lugar donde estaba la imagen del núcleo que 
			funciona. Note que
			/mnt + /usr/src/linux/arch/i386/boot - /usr = /mnt/src/linux/arch/i386/boot
			Coloque un disco formateado en la unidad ``A:'' (no su disco de arranque 
					o instalación), copie la imagen al disco, y configúrela para su sistema 
			de ficheros raíz:
			</para>

			<para>
			cd /mnt/src/linux/arch/i386/boot
			dd if=bzImage of=/dev/fd0
			rdev /dev/fd0 /dev/hda1
			</para>

			<para>
			Vaya al directorio raíz (<literal remap="tt">/</literal>) y desmonte el sistema de ficheros 
			<literal remap="tt">/usr</literal> normal:
			</para>

			<para>
			cd /
			umount /mnt
			</para>

			<para>
			Ahora sería capaz de volver a arrancar su sistema de manera normal desde 
			este disquete. ¡No se olvide ejecutar lilo (o cualquier cosa que haya 
					hecho mal) después de volver a arrancar!
			</para>

			<para>
			Tal como mencioné anteriormente, hay otra alternativa común. Si sucede 
			que tiene una imagen del núcleo que funciona en <literal remap="tt">/</literal> 
			(<literal remap="tt">/vmlinuz</literal>, por ejemplo), puede utilizarla para un disco de 
			arranque. Suponiendo todas las condiciones anteriores, y que la imagen de 
			mi núcleo es <literal remap="tt">/vmlinuz</literal>, solo haga estas alteraciones al ejemplo 
			anterior: cambie <literal remap="tt">/dev/hda3</literal> por <literal remap="tt">/dev/hda1</literal> (sistema de 
					ficheros <literal remap="tt">/</literal>), <literal remap="tt">/mnt/src/linux</literal> por <literal remap="tt">/mnt</literal>, y 
			<literal remap="tt">if=bzImage</literal> por <literal remap="tt">if=vmlinuz</literal>. La nota que explica como 
			deducir <literal remap="tt">/mnt/src/linux</literal> puede ser ignorada.
			</para>

			<para>
			Usar LILO con discos grandes (más de 1024 cilindros) puede causar 
			problemas. Vea el documento LILO mini-HOWTO o la documentación para 
			ayuda sobre eso.
			</para>

			</sect2>

			<sect2>
			<title>Dice: `warning: bdflush not running'</title>

			<para>
			Éste puede ser un problema grave. Después de la versión 1.0 del 
			núcleo (alrededor de 20 de Abril de 1994), fue actualizado o reemplazado 
			un programa llamado `<literal remap="tt">update</literal>', que periódicamente vacía los 
			buffers del sistema de ficheros. Consiga los fuentes de 
			`<literal remap="tt">bdflush</literal>' (debería encontrarlo donde consiguió el fuente de su 
					núcleo), e instálelo (probablemente necesite utilizar su sistema con un 
						núcleo más antiguo mientras hace esto). Éste se instala a sí mismo 
					como `<literal remap="tt">update</literal>' y después de volver a arrancar, el nuevo núcleo 
					no debería quejarse más.
					</para>

					</sect2>

					<sect2>
					<title>No puedo lograr que funcione mi CD-ROM IDE/ATAPI</title>

					<para>
					Aunque parezca extraño, mucha gente no puede conseguir que sus discos 
					ATAPI funcionen, probablemente porque hay varias cosas que pueden salir 
					mal.
					</para>

					<para>
					Si su unidad CD-ROM es el único dispositivo en una interfase IDE 
					particular, este debe estar configurado como ``maestro'' (master) o 
					``único'' (simple). Supuestamente, éste es el error más común.
					</para>

					<para>
					Creative Labs (para uno) ha puesto ahora interfaces IDE en sus tarjetas 
					de sonido. Sin embargo, esto conduce a una problema interesante, mientras 
					que algunas personas trabajan con una sola interfase, muchos tienen dos 
					interfaces IDE incorporadas en sus tarjetas madres (usualmente en la IRQ 
							15), así que una práctica común es hacer la interfase soundblaster un 
					tercer puerto IDE (IRQ11, o así me dijeron).
					</para>

					<para>
					Esto causa problemas con Linux en aquellas versiones 1.2.x que no 
					soportan una tercera interfase IDE (hay soporte comenzando en alguna 
							parte de la serie 1.3.x, pero esta en desarrollo, recuerdo, y este no 
							estaba auto- examinado). Para lograr esto, tiene unas pocas opciones.
					</para>

					<para>
					Si ya tiene un segundo puerto IDE, las opciones son que no lo este 
					utilizando o que éste todavía no tenga dos dispositivos en el. 
					Desconecte el disco ATAPI de la tarjeta de sonido y póngalo en la 
					segunda interfase. Puede luego deshabilitar la interfase de la tarjeta de 
					sonido, lo que ahorrará de todos modos una IRQ.
					</para>

					<para>
					Si no tiene una segunda interfase, configure la interfase de la tarjeta 
					de sonido (no la parte de sonido de la tarjeta de sonido), es decir la 
					segunda interfase, con la IRQ 15. Esto debería funcionar.
					</para>

					</sect2>

					<sect2>
					<title>Dice cosas extrañas sobre peticiones de encaminamiento obsoletas</title>

					<para>
					Obtenga las nuevas versiones del programa <literal remap="tt">route</literal> y otros 
					programas que realizan manipulación de rutas. El fichero 
					<literal remap="tt">/usr/include/linux/route.h</literal> (que actualmente es un fichero de 
							<literal remap="tt">/usr/src/linux</literal>) ha sido cambiado.
					</para>

					</sect2>

					<sect2>
					<title>El cortafuegos no está funcionando en el núcleo 1.2.0</title>

					<para>
					Actualícese por lo menos a la versión 1.2.1.
					</para>

					</sect2>

					<sect2>
					<title>Dice: ``Not a compressed kernel Image file''</title>

					<para>
					No use el fichero <literal remap="tt">vmlinux</literal> creado en <literal remap="tt">/usr/src/linux</literal> como 
					su imagen de arranque; lo correcto es
					<literal remap="tt">[..]/arch/i386/boot/bzImage</literal> .
					</para>

					</sect2>

					<sect2>
					<title>Hay problemas con la consola después de la actualización al núcleo 1.3.x</title>

					<para>
					Cambie la cadena <literal remap="tt">nula</literal> por <literal remap="tt">linux</literal> en la entrada `console' 
					del fichero <literal remap="tt">/etc/termcap</literal>. Puede también tener que crear una
					entrada en terminfo.
					</para>

					</sect2>

					<sect2>
					<title>Parece que no se pueden compilar cosas después de actualizar el núcleo</title>

					<para>
					El núcleo de Linux incluye un número de ficheros include (las cosas que 
							terminan con <literal remap="tt">.h</literal>) a los cuales hacen referencias los estándares 
					en <literal remap="tt">/usr/include</literal>. A estos típicamente se les hace referencia 
					así (donde <literal remap="tt">xyzzy.h</literal> debería ser alguna cosa en
							<literal remap="tt">/usr/include/linux</literal>):
#include &#60;linux/xyzzy.h&#62;
					Normalmente, hay un enlace llamado <literal remap="tt">linux</literal> en el directorio 
					<literal remap="tt">/usr/include</literal> hacia el directorio <literal remap="tt">include/linux</literal> del 
					fuente de su núcleo (<literal remap="tt">/usr/src/linux/include/linux</literal> en un sistema 
							típico). Si este enlace no está ahí, o apunta a un lugar incorrecto, 
							la mayoría de las cosas no compilarán en absoluto. Si decidió que el 
							fuente del núcleo tomaba demasiado espacio en el disco y lo borró, esto 
							será obviamente un problema. Otro cosa que podría salir mal está en 
							los permisos de ficheros; si su <literal remap="tt">root</literal> tiene una umask que no 
							permite a los otros usuarios ver sus ficheros por  defecto, y extrajo el 
							fuente de núcleo sin la opción <literal remap="tt">p</literal> (preservar permisos) esos 
							usuarios tampoco podrán utilizar el compilador de C. Aunque podría 
							utilizar el comando <literal remap="tt">chmod</literal> para solucionar esto, sea 
							probablemente más fácil volver a extraer los ficheros include. Puede 
							hacer esto de la misma forma que hizo al principio con el fuente 
							completo, solo que con un argumento adicional:
							</para>

							<para>
							blah# tar zxvpf linux.x.y.z.tar.gz linux/include
							Nota: ``<literal remap="tt">make config</literal>'' recreará el enlace a 
							<literal remap="tt">/usr/src/linux</literal> si este no está allí.
							</para>

							</sect2>

							<sect2>
							<title>Incrementados los límites</title>

							<para>
							Los pocos comandos del <emphasis remap="it">ejemplo</emphasis> que sigue pueden ser útiles para 
							aquellos que se preguntan como aumentar ciertos límites suaves impuestos 
							por el núcleo:
							echo 4096 &#62; /proc/sys/kernel/file-max
							echo 12288 &#62; /proc/sys/kernel/inode-max
							echo 300 400 500 &#62; /proc/sys/vm/freepages
							</para>

							</sect2>

							</sect1>

							<sect1>
							<title>Nota para la actualización a la versión 2.0.x, 2.2.x</title>

							<para>
							Las versiones del núcleo 2.0.x y 2.2.x introdujeron bastante cambios en 
							la instalación de núcleo. El fichero <literal remap="tt">Documentation/Changes</literal> en 
							la versión 2.0.x del árbol del fuente, contiene información que debe 
							saber cuando se actualice a una de estas versiones. Muy probablemente 
							necesitará actualizar muchos paquetes claves, tales como gcc, libc, y 
							SysVInit, y quizás alterar algunos ficheros del sistema, así que espere 
							esto. No tenga pánico, sin embargo.
							</para>

							</sect1>

							<sect1>
							<title>Módulos</title>

							<para>
							Los módulos cargables del núcleo pueden ahorrar memoria y facilitar la 
							configuración. El alcance de los módulos ha crecido hasta incluir 
							sistemas de ficheros, controladores de tarjetas Ethernet, controladores 
							de impresoras, y más.
							</para>

							<sect2>
							<title>Instalando las utilidades de módulo</title>

							<para>
							Las utilidades de módulo están disponibles donde sea que consiguió el 
							fuente de su núcleo como un fichero <literal remap="tt">modutils-x.y.z.tar.gz</literal>; 
							elija el nivel de patch (patchlevel) más alto <literal remap="tt">x.y.z</literal> que sea 
							igual o menor que la versión de su núcleo actual. Desempaquete este con 
							`<literal remap="tt">tar zxvf modutils-x.y.z.tar.gz</literal>', vaya al directorio que este 
							crea (<literal remap="tt">modutils-x.y.z</literal>), examine el fichero <literal remap="tt">README</literal>, y 
							siga sus instrucciones de instalación (que usualmente son algo simples, 
									como <literal remap="tt">make install</literal>). Debe tener ahora los programas 
							<literal remap="tt">insmod</literal>, <literal remap="tt">rmmod</literal>, <literal remap="tt">ksyms</literal>, <literal remap="tt">lsmod</literal>, 
							<literal remap="tt">genksyms</literal>, <literal remap="tt">modprobe</literal>, and <literal remap="tt">depmod</literal> en el 
							directorio <literal remap="tt">/sbin</literal>. Si quiere, pruebe las utilidades con el 
							controlador de ejemplo ``hw'' con <literal remap="tt">insmod</literal>; examine el fichero 
							<literal remap="tt">INSTALL</literal> en ese subdirectorio para más detalles.
							</para>

							<para>
							<literal remap="tt">insmod</literal> inserta un módulo en un núcleo en ejecución. Los 
							módulos usualmente tienen una extensión <literal remap="tt">.o</literal>; el controlador de 
							ejemplo mencionado anteriormente se llama <literal remap="tt">drv_hello.o</literal>, de manera 
							que para insertar éste, uno diría `<literal remap="tt">insmod drv_hello.o</literal>'. Para 
							ver los módulos que el núcleo está utilizando actualmente, use el 
							comando <literal remap="tt">lsmod</literal>. La salida se verá como ésta:
							blah# lsmod
							Module:        #pages:  Used by:
							drv_hello          1
							`<literal remap="tt">drv_hello</literal>' es el nombre del módulo, éste utiliza una página 
							de memoria (4k), y no hay otros módulos del núcleo que dependan de 
							éste en este momento. Para quitar este módulo, use `<literal remap="tt">rmmod drv_hello</literal>'. Note que el comando <literal remap="tt">rmmod</literal> necesita un 
							<emphasis remap="it">nombre de módulo</emphasis>, no un nombre de fichero; éste se obtiene 
							desde el listado del comando <literal remap="tt">lsmod</literal>. Los propósitos de las otras 
							utilidades de módulo están documentados en sus páginas del manual.
							</para>

							</sect2>

							<sect2>
							<title>Módulos distribuidos con el núcleo</title>

							<para>
							A partir de versión 2.0.30, la mayoría de las cosas están disponibles 
							como módulos cargables. Para utilizarlos, primero asegúrese de que no 
							los configuró en el núcleo habitual; esto es, no diga <literal remap="tt">y</literal> a esto 
							durante `<literal remap="tt">make config</literal>'. Compile un nuevo núcleo y vuela a 
							arrancar con él. Luego, vaya nuevamente a <literal remap="tt">/usr/src/linux</literal>, y 
							haga `<literal remap="tt">make modules</literal>'. Esto compila todos los módulos que no 
							especificó en la configuración del núcleo, y pone enlaces a ellos en 
							<literal remap="tt">/usr/src/linux/modules</literal>. Puede utilizarlos directamente de ese 
							directorio o ejecutar `<literal remap="tt">make modules_install</literal>', lo que los 
							instalara dentro de <literal remap="tt">/lib/modules/x.y.z</literal>, donde <literal remap="tt">x.y.z</literal> es 
							la versión del núcleo.
							</para>

							<para>
							Esto puede ser especialmente práctico con los sistemas de ficheros. 
							Puede no utilizar frecuentemente los sistema de ficheros minix o MSDOS. 
							Por ejemplo, si yo encontrara un disquete de MSDOS (estremecimiento), yo 
							haría <literal remap="tt">insmod /usr/src/linux/modules/msdos.o</literal>, y luego cuando 
							termine <literal remap="tt">rmmod msdos</literal> . Este procedimiento ahorra cerca de 50 Kb 
							de RAM en el núcleo durante la operación normal. Una pequeña nota 
							destinada al sistema de ficheros minix: debe <emphasis remap="it">siempre</emphasis> 
							configurarlo directamente en el núcleo para usarlo en los discos de 
							rescate.
							</para>

							</sect2>

							</sect1>

							<sect1>
							<title>Consejos y trucos</title>

							<sect2>
							<title>Redireccionando la salida de los comandos make o patch</title>

							<para>
							Si quisiera tener registros de lo que hicieron los comandos 
							`<literal remap="tt">make</literal>' o `<literal remap="tt">patch</literal>', puede redireccionar la salida a un 
							fichero. Primero averigÃ¼e que shell esta utilizando: `<literal remap="tt">grep root /etc/passwd</literal>' y busque algo como `<literal remap="tt">/bin/csh</literal>'.
							</para>

							<para>
							Si utiliza sh o bash,
							(comando) 2&#62;&#38;1 | tee (fichero de salida)
							pondrá una copia de la salida de <literal remap="tt">(comando)</literal>' en el fichero 
							`<literal remap="tt">(fichero de salida)</literal>'.
							</para>

							<para>
							Para csh or tcsh, utilice
							(comando) |&#38; tee (fichero de salida)
							</para>

							<para>
							Para rc (Nota: probablemente no utilize rc) es
							(comando) &#62;[2=1] | tee (fichero de salida)
							</para>

							</sect2>

							<sect2>
							<title>Instalación condicional del núcleo</title>

							<para>
							Además de usando disquetes, hay varios formas de probar un nuevo núcleo 
							sin tocar el antiguo. A diferencia de muchos otros Unix, LILO tiene la 
							habilidad de arrancar un núcleo desde cualquier lugar del disco (si 
									tiene un disco grande (500 MB o más), por favor examine la 
									documentación del LILO sobre cómo esto puede causar problemas). Así, 
									si agrega algo similar a
									image = /usr/src/linux/arch/i386/boot/bzImage
									label = nuevo_núcleo
									al final del fichero de configuración de su LILO, puede elegir ejecutar 
									un núcleo recientemente compilado sin tocar su núcleo antiguo 
									<literal remap="tt">/vmlinuz</literal> (después de ejecutar <literal remap="tt">lilo</literal>, por supuesto). La 
									forma más fácil de  decirle a LILO de arrancar un nuevo núcleo es 
									presionar la tecla Shift durante el arranque (cuando dice <literal remap="tt">LILO</literal> 
											en la pantalla, y nada más), que le dará un prompt. En este punto, 
											puede ingresar `<literal remap="tt">nyevo_núcleo</literal>' para arrancar el nuevo núcleo. 
											</para>

											<para>
											Si quiere mantener varios árboles de núcleos diferentes en su sistema 
											al mismo tiempo (esto puede tomar <emphasis remap="it">mucho</emphasis> espacio en disco; tenga 
													cuidado), la forma más común es nombrarlos 
											<literal remap="tt">/usr/src/linux-x.y.z</literal>, donde <literal remap="tt">x.y.z</literal> es la versión del 
											núcleo. Luego puede seleccionar un árbol de fuente con un enlace 
											simbólico; Por ejemplo, `<literal remap="tt">ln -sf linux-1.2.2 /usr/src/linux</literal>' 
											hará el árbol actual el 1.2.2. Antes de la creación de un enlace 
											simbólico como éste, asegúrese con el comando <literal remap="tt">ln</literal>, que el 
											último argumento no sea un directorio real (los vínculos simbólicos 
													antiguos están bien); sino el resultado no será el esperado.
											</para>

											</sect2>

											<sect2>
											<title>Actualizaciones del núcleo</title>

											<para>
											Russell Nelson (<literal remap="tt">nelson@crynwr.com</literal>)  resume los cambios en las 
											nuevas versiones del núcleo. Éstos son cortos, y a podría gustarle 
											mirarlos antes de una actualización. Éstos están disponibles vía FTP 
											anónimo en <literal remap="tt">ftp://ftp.emlist.com</literal> dentro de <literal remap="tt">pub/kchanges</literal> 
											o a través de la URL
											http://www.crynwr.com/kchanges
											</para>

											</sect2>

											</sect1>

											<sect1>
											<title>Otros documentos COMO relacionados que podrían ser útiles</title>

											<para>

											<itemizedlist>
											<listitem>

											<para>
											Sound-HOWTO: tarjetas y sonido y utilitarios
											</para>
											</listitem>
											<listitem>

											<para>
											SCSI-HOWTO: todo acerca de los controladores y dispositivos SCSI
											</para>
											</listitem>
											<listitem>

											<para>
											NET-2-HOWTO: estableciendo una red
											</para>
											</listitem>
											<listitem>

											<para>
											PPP-HOWTO: estableciendo una red PPP en detalle
											</para>
											</listitem>
											<listitem>

											<para>
											PCMCIA-HOWTO: acerca de los controladores para su notebook
											</para>
											</listitem>
											<listitem>

											<para>
											ELF-HOWTO: ELF: Qué es esto, convirtiendo..
											</para>
											</listitem>
											<listitem>

											<para>
											Hardware-HOWTO: descripción del hardware soportado
											</para>
											</listitem>
											<listitem>

											<para>
											Module mini-HOWTO: más sobre los módulos de núcleo
											</para>
											</listitem>
											<listitem>

											<para>
											Kerneld mini-HOWTO: acerca de kerneld
											</para>
											</listitem>
											<listitem>

											<para>
											BogoMips mini-HOWTO: en caso de que estuviera preguntándose
											</para>
											</listitem>

											</itemizedlist>

											</para>

											</sect1>

											<sect1>
											<title>Miscelánea</title>

											<sect2>
											<title>El autor&#62;
											El autor y sostén del Kernel-HOWTO de Linux es Brian Ward (<literal remap="tt">bri@cs.uchicago.edu</literal>). Por favor envíeme cualquier comentario, adiciones, y correcciones (las correcciones son , en particular, lo mas importante para mí).</title>

											<para>
											Puede echar una ojeada mi `página principal' en una de estas URLs:
											http://www.math.psu.edu/bri/
http://blah.math.tu-graz.ac.at/~bri/
</para>

<para>
Aunque yo intento ser atento como sea posible con el correo, por favor 
recuerde que yo recibo <emphasis remap="it">muchos</emphasis> de ellos cada día, de manera que 
puede tomarme un poco de tiempo respondérselo. Especialmente cuando me 
envían un correo con una pregunta, por favor trate firmemente de ser 
claro y detallado en su mensaje. Si está escribiendo acerca de hardware 
que no está funcionando (o alguna cosa como eso), yo necesito saber cual 
es su configuración de hardware. Si reporta un error, no diga solo ``Yo 
probé esto pero me dio un error''; yo necesito saber cual fue el error. 
También yo quisiera saber que versión del núcleo, de gcc y de las 
librerías libc esta utilizando. Si solo me dice que está utilizando 
ésta o aquella distribución, esto no me servirá de mucho. Yo no me 
aflijo si realiza preguntas simples; ¡recuerde, si no pregunta, puede 
que nunca consiga una respuesta! Quisiera agradecer a todos los que me 
respondieron.
</para>

<para>
Si su pregunta no se relaciona con el núcleo, o si está en algún 
lenguaje que yo no entienda, puede que yo no conteste.
</para>

<para>
Si me envió un mensaje y no obtuvo una respuesta dentro de una cantidad 
razonable de tiempo (tres semanas o más), corre el riesgo que yo haya 
borrado accidentalmente su mensaje o alguna otra cosa (lo siento). Por 
favor intente nuevamente.
</para>

<para>
Yo recibo muchos mensajes acerca de cosas que son actualmente cuestiones 
o problemas de hardware. Esto está bien, pero por favor trate de tener 
en mente que yo no estoy familiarizado con todo el hardware en el mundo. 
Yo uso procesadores AMD, controladores SCSI Adapted y Sybios, y discos 
SCSI IBM.
</para>

<para>
La versión -0.1 fue escrita el 3 de Octubre de 1994. Este documento 
está disponible en los formatos SGML, PostScript, TeX, roff y ASCII.
</para>

</sect2>

<sect2>
<title>Cosas por realizar</title>

<para>
La sección de ``Consejos y trucos'' es un poco pequeña. Yo espero 
ampliarla con las sugerencias de otros.
</para>

<para>
Lo mismo para la sección ``Paquetes adicionales''.
</para>

<para>
Se necesita más información sobre depuración y recuperación de 
fallos.
</para>

</sect2>

<sect2>
<title>Contribuciones</title>

<para>
Se incluyo una pequeña parte del fichero README de Linus (opciones de 
		kernel hacking) (¡Gracias, Linus!).
		</para>

		<para>
		<literal remap="tt">uc@brian.lunetix.de</literal> (Ulrich Callmeier): patch -s y xargs.
		</para>

		<para>
		<literal remap="tt">quinlan@yggdrasil.com</literal> (Daniel Quinlan): correcciones y adiciones 
		en muchas secciones.
		</para>

		<para>
		<literal remap="tt">nat@nat@nataa.fr.eu.org</literal> (Nat Makarevitch): mrproper, tar -p, , y 
		muchas otras cosas.
		</para>

		<para>
		<literal remap="tt">boldt@math.ucsb.edu</literal> (Axel Boldt): coleccionó descripciones de 
		las opciones de configuración del núcleo en la red; y luego me las 
		proporcionó con la lista.
		</para>

		<para>
		<literal remap="tt">lembark@wrkhors.psyber.com</literal> (Steve Lembark): sugerencias sobre el 
		arranque múltiple.
		</para>

		<para>
		<literal remap="tt">kbriggs@earwax.pd.uwa.edu.au</literal> (Keith Briggs): algunas 
		correcciones y sugerencias
		</para>

		<para>
		<literal remap="tt">rmcguire@freenet.columbus.oh.us</literal> (Ryan McGuire): adiciones sobre 
		los makeables
		</para>

		<para>
		<literal remap="tt">dumas@excalibur.ibp.fr</literal> (Eric Dumas): Traducción al francés
		</para>

		<para>
		<literal remap="tt">simazaki@ab11.yamanashi.ac.jp</literal> (Yasutada Shimazaki): Traducción 
		al japonés
		</para>

		<para>
		<literal remap="tt">jjamor@lml.ls.fi.upm.es</literal> (Juan Jose Amor Iglesias): Traducción 
		al español
		</para>

		<para>
		<literal remap="tt">mva@sbbs.se</literal> (Martin Wahlen): Traducción al sueco
		</para>

		<para>
		<literal remap="tt">jzp1218@stud.u-szeged.hu</literal> (Zoltan Vamosi): Traducción al 
		húngaro
		</para>

		<para>
		<literal remap="tt">bart@mat.uni.torun.pl</literal> (Bartosz Maruszewski): Traducción al 
		polaco
		</para>

		<para>
		<literal remap="tt">donahue@tiber.nist.gov</literal> (Michael J Donahue): errores 
		tipográficos, ganador de la competencia ``sliced bread''
		</para>

		<para>
		<literal remap="tt">rms@gnu.ai.mit.edu</literal> (Richard Stallman): aviso sobre el concepto 
		de la documentación de libre distribución
		</para>

		<para>
		<literal remap="tt">dak@Pool.Informatik.RWTH-Aachen.DE</literal> (David Kastrup): Lo de NFS
		</para>

		<para>
		<literal remap="tt">esr@snark.thyrsus.com</literal> (Eric Raymond): varias cosas muy buenas 
</para>

<para>
Las personas que me han enviado correo con preguntas y problemas también 
han sido de bastante ayuda.
</para>

</sect2>

<sect2>
<title>Notas sobre el Copyright, Licencia y Todo Eso</title>

<para>
Nota del traductor: a continuación se copiaron las notas originales 
intactas para respetar los términos de la Licencia. La versión 
traducida de estas notas se encuentra después de la notas originales.
</para>

<para>

<screen>
==============Copyright notice, License, and all that stuff===============
Copyright &copy; Brian Ward, 1994-1999. 
Permission is granted to make and distribute copies of this manual 
provided the copyright notice and this permission notice are preserved on 
all copies.

Permission is granted to copy and distribute modified versions of this 
manual under the conditions for verbatim copying, provided that the 
derived work is distributed under the terms of a permission notice 
identical to this one. Translations fall under the catagory of ``modified 
versions.''

Warranty: None.

Recommendations:
Commercial redistribution is allowed and encouraged; however, it is 
strongly recommended that the redistributor contact the author before the 
redistribution, in the interest of keeping things up-to-date (you could 
send me a copy of the thing you're making while you're at it). 
Translators are also advised to contact the author before translating. 
The printed version looks nicer. Recycle.

==========================================================================
</screen>

</para>

<para>
Copyright &copy;  Brian Ward, 1994-1999.
</para>

<para>
Se concede el permiso de realizar y distribuir copias de este manual, 
preservando este aviso y el aviso del Copyright en todas las copias.
</para>

<para>
Se concede el permiso de copiar y distribuir versiones modificadas de 
este manual bajo las condiciones de copiarlo literalmente, con tal de que 
el trabajo derivado sea distribuido bajo los términos de un aviso de 
permiso idéntico a éste. Las traducciones caen dentro de la categoría 
de ``versiones modificadas''.
</para>

<para>
Garantía: Ninguna.
</para>

<para>
Recomendaciones: La redistribución comercial esta permitida y alentada, 
sin embargo, se recomienda fuertemente que el redistribuidor contacte al 
autor antes de la redistribución, con el interés de mantener las cosas 
actualizadas (podría enviarme una copia de la cosa que está haciendo 
mientras está en ella). También se aconseja a los traductores que 
avisen al autor antes de realizar una traducción. La versión impresa se 
ve más agradable. Además es reciclable.
</para>

</sect2>

</sect1>

<sect1>
<title>Otros Formatos de este Documento</title>

<para>
Esta sección fue escrita por 
<ulink
url="mailto:alavoor[AT]yahoo.com"
>Al Dev</ulink
> 
(en el sitio <ulink
url="http://www.milkywaygalaxy.freeservers.com"
>http://www.milkywaygalaxy.freeservers.com</ulink
> 
espejos en 
<ulink
url="http://www.angelfire.com/country/aldev0"
>angelfire</ulink
>, 
<ulink
url="http://www.geocities.com/alavoor/index.html"
>geocities</ulink
>, 
<ulink
url="http://aldev0.virtualave.net"
>virtualave</ulink
>, 
<ulink
url="http://members.fortunecity.com/aldev"
>Fortunecity</ulink
>, 
<ulink
url="http://aldev.freewebsites.com"
>Freewebsites</ulink
>, 
<ulink
url="http://members.tripod.lycos.com/aldev"
>Tripod</ulink
>, 
<ulink
url="http://www.101xs.com/101xs/aldev"
>101xs</ulink
>, 
<ulink
url="http://aldev0.50megs.com"
>50megs</ulink
> 
)
</para>

<para>
Este documento está publicado en 14 diferentes formatos a saber - DVI, 
PostScript, LaTeX, Adobe Acrobat PDF, LyX, GNU-info, HTML, RTF (Formato 
de Texto enRiquecido), ASCII, página de man de Unix, fichero Simple 
HTML, SGML (formato Linuxdoc), SGML (formato Docbook), formato MS 
WinHelp.
</para>

<para>
Este documento HOWTO se localiza en -

<itemizedlist>
<listitem>

<para>
 <ulink
url="http://www.linuxdoc.org"
>http://www.linuxdoc.org</ulink
>. Haga clic en HOWTOs y busque 
el nombre del documento HOWTO usando CTRL+f o ALT+f dentro de un 
navegador Web.
</para>
</listitem>

</itemizedlist>

</para>

<para>
Puede también encontrar este documento en los siguientes sitios espejo -

<itemizedlist>
<listitem>

<para>
 <ulink
url="http://www.caldera.com/LDP/HOWTO"
>http://www.caldera.com/LDP/HOWTO</ulink
>
</para>
</listitem>
<listitem>

<para>
 <ulink
url="http://www.linux.ucla.edu/LDP"
>http://www.linux.ucla.edu/LDP</ulink
>
</para>
</listitem>
<listitem>

<para>
 <ulink
url="http://www.cc.gatech.edu/linux/LDP"
>http://www.cc.gatech.edu/linux/LDP</ulink
>
</para>
</listitem>
<listitem>

<para>
 <ulink
url="http://www.redhat.com/mirrors/LDP"
>http://www.redhat.com/mirrors/LDP</ulink
>

</para>
</listitem>
<listitem>

<para>
 Otros sitios espejo cerca de suyo (direcciones de red prudentes) 
se pueden encontrar en
<ulink
url="http://www.linuxdoc.org/mirrors.html"
>http://www.linuxdoc.org/mirrors.html</ulink
>
seleccione un sitio y vaya al directorio /LDP/HOWTO/xxxxx-HOWTO.html
</para>
</listitem>

</itemizedlist>

</para>

<para>

<itemizedlist>
<listitem>
<para>
Puede obtener este documento HOWTO como un solo fichero tar ball en los 
formatos HTML, DVI, PostScript o SGML desde -
<ulink
url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO/other-formats/"
>ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO/other-formats/</ulink
> 
y <ulink
url="http://www.linuxdoc.org/docs.html#howto"
>http://www.linuxdoc.org/docs.html#howto</ulink
>
</para>
</listitem>
<listitem>
<para>
El formato de ASCII está en: <ulink
url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO"
>ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO</ulink
> 
y <ulink
url="http://www.linuxdoc.org/docs.html#howto"
>http://www.linuxdoc.org/docs.html#howto</ulink
>
</para>
</listitem>
<listitem>
<para>
El fichero en formato Simple HTML está en: 
<ulink
url="http://www.linuxdoc.org/docs.html#howto"
>http://www.linuxdoc.org/docs.html#howto</ulink
>
</para>
<para>
El fichero de Simple HTML puede ser creado con el comando (vea man 
sgml2html) -
sgml2html -split 0   xxxxhowto.sgml
</para>
</listitem>
<listitem>

<para>
Las traducciones a otros lenguajes como francés, alemán, 
español, chino y japonés están en 
<ulink
url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO"
>ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO</ulink
> 
y <ulink
url="http://www.linuxdoc.org/docs.html#howto"
>http://www.linuxdoc.org/docs.html#howto</ulink
> 
Cualquier ayuda de para traducirlos a otros lenguajes es bienvenida.
</para>
</listitem>

</itemizedlist>

Este documento está escrito usando una herramienta llamada "SGML-Tools" 
la cual puede ser obtenida de -
<ulink
url="http://www.sgmltools.org"
>sgmltools</ulink
>
Compilando el fuente obtiene los comandos como los siguientes

<itemizedlist>
<listitem>

<para>
sgml2html xxxxhowto.sgml     (para generar un fichero html)
</para>
</listitem>
<listitem>

<para>
sgml2html -split 0   xxxxhowto.sgml (para genera un fichero html de 
página simple)
</para>
</listitem>
<listitem>

<para>
sgml2rtf  xxxxhowto.sgml     (para generar un fichero RTF)
</para>
</listitem>
<listitem>

<para>
sgml2latex xxxxhowto.sgml    (para generar un fichero LaTeX)
</para>
</listitem>

</itemizedlist>

</para>

<sect2 id="acrobatpdf">
<title>Formato Acrobat PDF </title>

<para>
El fichero PDF puede ser generado desde un fichero PostScript usando 
acrobat <emphasis remap="bf">distill</emphasis> o <emphasis remap="bf">Ghostscript</emphasis>. El fichero PostScript se 
genera desde el fichero DVI el cual a su vez se genera desde el fichero 
de LaTeX. Puede obtener el programa distill en 
<ulink
url="http://www.adobe.com"
>http://www.adobe.com</ulink
>. 
La sección dada debajo es una sesión de ejemplo:

<programlisting>
bash$ man sgml2latex
bash$ sgml2latex filename.sgml
bash$ man dvips
bash$ dvips -o filename.ps filename.dvi
bash$ distill filename.ps
bash$ man ghostscript
bash$ man ps2pdf
bash$ ps2pdf input.ps output.pdf
bash$ acroread output.pdf &#38;
</programlisting>

O puede utilizar el comando de ghostscript <emphasis remap="bf">ps2pdf</emphasis>. ps2pdf es un 
trabajo similar con casi toda la funcionalidad del producto Adobe Acrobat 
Distiller: este convierte ficheros PostScript a ficheros Portable 
Document Format (PDF). <emphasis remap="bf">ps2pdf</emphasis> está implementado como un comando 
script muy pequeño (ficheros de proceso por lotes) que invoca al 
programa Ghostscript, seleccionando un dispositivo de salida especial 
llamado pdfwrite. Para usar ps2pdf, el dispositivo <emphasis remap="bf">pdfwrite</emphasis> debe 
ser incluido en el makefile cuando se compila el Ghostscript; mire la 
documentación de construcción del Ghostscript por detalles.
</para>

</sect2>

<sect2 id="linuxdoc2docbook">
<title>Conversión del formato Linuxdoc al Docbook </title>

<para>
Este documento está escrito en formato linuxdoc SGML. El formato Docbook 
SGML supercede al formato linuxdoc y tiene muchas mas prestaciones que el 
formato linuxdoc. El formato linuxdoc es muy simple y fácil de usar. 
Para convertir un fichero linuxdoc SGML a Docbook SGML use el programa 
<emphasis remap="bf">ld2db.sh</emphasis> y algunos scripts de Perl. La salida de ld2db no está 
100% limpia y necesitará usar el script de Perl <emphasis remap="bf">clean_ld2db.pl</emphasis>. 
Además puede necesitar corregir manualmente unas pocas líneas en el 
documento.

<itemizedlist>
<listitem>

<para>
 Descargue el programa ld2db desde <ulink
url="http://www.dcs.gla.ac.uk/~rrt/docbook.html"
>http://www.dcs.gla.ac.uk/~rrt/docbook.html</ulink
> o desde 
el <ulink
url="http://www.milkywaygalaxy.freeservers.com"
>sitio de Milkyway Galaxy</ulink
> 
</para>
</listitem>
<listitem>

<para>
 Descargue el script de Perl cleanup_ld2db.pl desde 
el <ulink
url="http://www.milkywaygalaxy.freeservers.com"
>sitio de Milkyway Galaxy</ulink
> 
</para>
</listitem>

</itemizedlist>

El fichero ld2db.sh no está 100% limpio, y obtendrá muchos errores 
cuando lo ejecute

<programlisting>
	bash$ ld2db.sh file-linuxdoc.sgml db.sgml
	bash$ cleanup.pl db.sgml &#62; db_clean.sgml
	bash$ gvim db_clean.sgml 
	bash$ docbook2html db.sgml
</programlisting>

Y puede tener que editar manualmente algunos de los errores menores 
después de la ejecución del script de Perl. Por ej. puede necesitar 
poner la etiqueta de cierre &#60; /Para&#62; para cada &#60; Listitem&#62;
</para>

</sect2>

<sect2 id="mswinhelp">
<title>Conversión al formato MS WinHelp </title>

<para>
Puede convertir el documento HOWTO en formato SGML a un fichero de Ayuda 
Microsoft Windows, primero convierta el SGML a HTML utilizando:

<programlisting>
	bash$ sgml2html xxxxhowto.sgml     (para generar el fichero HTML)
        bash$ sgml2html -split 0 xxxxhowto.sgml (para generar un fichero
                                                 HTML de página simple)
</programlisting>

Luego utilice la herramienta <ulink
url="http://javadocs.planetmirror.com/htmltohlpe.html"
>HtmlToHlp</ulink
>. Puede también 
utilizar el programa sgml2rtf y luego usar los ficheros RTF para generar 
los ficheros WinHelp.
</para>

</sect2>

<sect2 id="formatoslectura">
<title>Leyendo varios formatos </title>

<para>
Para ver el documento en formato dvi, use el programa xdvi. El programa 
xdvi se localiza en RedHat Linux en el paquete tetex-xdvi*.rpm, el cual 
puede ser localizado a través de los botones de menú PanelDeControl | 
Aplicaciones | Publicación | TeX
Para leer el documento dvi teclee el comando -

<screen>
	xdvi -geometry 80x90 howto.dvi
	man xdvi
</screen>

Y redimensione la ventana con el ratón.
Para navegar use las teclas con flechas, las teclas Page Up y 
Page Down, además puede usar las teclas con letras 'f', 'd', 
'u',  'c', 'l', 'r', 'p', 'n' para moverse hacia arriba, abajo, 
al centro, a la próxima página, a la página anterior, etc. 
Para desactivar el menú experto, presione 'x'.
</para>

<para>
Puede leer el fichero PostScript usando el programa 'gv' (ghostview) o 
'ghostscript'. El programa ghostscript está en RedHat Linux en el 
paquete ghostscript*.rpm y el programa gv está en Redhat Linux en el 
paquete gv*.rpm, el cual puede ser localizado a través de los botones 
del menú PanelDeControl | Aplicaciones | Gráficos. El programa gv es 
mucho más facil de usar que el ghostscript. Además ghostscript y gv 
están disponibles en otras plataformas como OS/2, Windows 95 y NT, verá 
este documento incluso en esas plataformas.
</para>

<para>

<itemizedlist>
<listitem>

<para>
Obtenga el programa ghostscript para Windows 95, OS/2 y todos los 
otros sistemas operativos desde <ulink
url="http://www.cs.wisc.edu/~ghost"
>http://www.cs.wisc.edu/~ghost</ulink
>
</para>
</listitem>

</itemizedlist>

</para>

<para>
Para leer un documento PostScript tecleé el comando -

<screen>
		gv howto.ps
		ghostscript howto.ps
</screen>

</para>

<para>
Puede leer el documento en formato HTML usando Netscape Navigator, 
Microsoft Internet Explorer, el navegador web RedHat Baron o cualquiera 
de los otros 10 navegadores Web.
</para>

<para>
Puede leer el formato LaTeX, con la salida de LyX, una interfase del 
programa LaTeX para X-Windows.
</para>

</sect2>

</sect1>

<sect1 id="Grupos">
<title>Anexo: El INSFLUG </title>

<para>
El <emphasis>INSFLUG</emphasis> forma parte del grupo internacional <emphasis>Linux Documentation Project</emphasis>, encargandose de las traducciones al castellano de los HOWTOS (COMOs), asi como la produccion de documentos originales en aquellos casos en los que no existe ananlogo en ingles.
</para>
<para>
En el <emphasis>INSFLUG</emphasis> se orienta preferentemente a la traduccion
de documentos breves, como los <emphasis>COMOs</emphasis> y <emphasis>PUFs</emphasis> (Preguntas de Uso Frecuente, las <emphasis>FAQs</emphasis>. :) etc.
</para>
<para>
Dirijase a la sede del INSFLUG para mas informacion al respecto.
</para>
<para>
En la sede del INSFLUG encontrara siempre las <emphasis>ultimas versiones</emphasis> de las traducciones: <ulink url="http://www.insflug.org">www.insflug.org</ulink>
. Asegurese de comprobar cual es la ultima version disponible en el INSFLUG antes
de bajar un documento de un servidor replica.
</para>
<para>
Se proporciona tambien una lista de los servidores replica (mirror) del INSFLUG mas cercanos a Vd., e informacion relativa a otros recursos en castellano.
</para>

<para>
Francisco Jose Montilla, <ulink url="mailto:pacopepe@insflug.org">pacopepe@insflug.org</ulink>.
</para>
</sect1>
</article>
