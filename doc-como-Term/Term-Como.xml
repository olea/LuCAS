<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>

<articleinfo>

<title>TERM-Como</title>

<author>
<firstname>Patrick Reijnen, <ulink
url="mailto:patrickr@bart.nl"
>patrickr@bart.nl</ulink
>

Traducción de Alfonso Belloso, <ulink
url="mailto:alfon@bipv02.bi.ehu.es"
>alfon@bipv02.bi.ehu.es</ulink
></firstname>
</author>

<pubdate>v1.0, 1 Enero de 1995</pubdate>

<abstract>

<para>
 Lo que sigue es una guía detallada de configuración del programa
de comunicaciones <literal remap="tt">term</literal> en Linux.
</para>

</abstract>

</articleinfo>

<sect1>
<title>Información</title>

<sect2>
<title>Copyright statement</title>

<para>
This document may be distributed freely as a whole in any form and free of
charge. Parts of this document may be distributed, provided that this
copyright message is included and the reader is informed that this is not
the full HOWTO document. Furthermore , there is to be a pointer as to
where the full document can be obtained. Specifically, it may be included
in commercial distributions, without prior consent. However, I would like
to be informed of such usage. 
</para>

<para>
This HOWTO may be translated into any language, whatsoever, provided that
you leave this copyright statement and the disclaimer intact, and that a
notice is appended stating who translated the document. 
</para>

</sect2>

<sect2>
<title>DISCLAIMER</title>

<para>
While I have tried to include the most correct and up-to-date information
available, I cannot guarantee that usage of the information in this
document does not result in loss of data. I provide NO WARRANTY about the
information in this HOWTO and I cannot be made liable for any consequences
for any damage resulting from using information in this HOWTO. 
</para>

</sect2>

</sect1>

<sect1>
<title>Introducción</title>

<sect2>
<title>Sobre este Documento</title>

<para>
 
</para>

<para>
Este COMO intenta aclarar algunas de las confusiones al usar
<literal remap="tt">term</literal>, el gran programa de Michael O'Reilly que permite
multiplexar tu línea serie y establecer una conexión de red. De principio a
fin, los documentos que vienen con el <literal remap="tt">term</literal> son bastante buenos,
y este COMO no pretende reemplazarlos.  La intención de este documento es
dar una idea de fondo de cómo trabaja el <literal remap="tt">term</literal> y detallar los
pasos para conseguir algunos de los servicios de red más comunes
trabajando bajo <literal remap="tt">term</literal>. Se debe hacer hincapié en que este
documento no cubre todo lo que se debe saber sobre el <literal remap="tt">term</literal>.
Después de leerlo, deberían leerse las <emphasis remap="it">manpages</emphasis> sobre <literal remap="tt">term</literal>, 
ya que éstas incluyen información que no se encuentra aquí.
</para>

</sect2>

<sect2>
<title>¿Qué es el <literal remap="tt">TERM?</literal></title>

<para>
<literal remap="tt">term</literal> es un programa, escrito por Michael O'Reilly,
<literal remap="tt"><ulink
url="mailto:michael@iinet.com.au"
>michael@iinet.com.au</ulink
></literal>
, que corre sobre una línea serie para permitir a
conexiones múltiples operar de forma concurrente --es decir, puedes estar
recibiendo un fichero con tu módem mientras trabajas en un sistema remoto
(distinto)-- a través de la misma conexión módem. El <literal remap="tt">term</literal> también
se puede usar para abrir ventanas de cliente X sobre una conexión serie. 
Por medio de las utilidades <literal remap="tt">tredir</literal> y <literal remap="tt">tupredir</literal> de las
versiones <literal remap="tt">2.0.x</literal> y superiores del <literal remap="tt">term</literal>, éste puede proporcionar
muchos de los servicios de red ``tradicionales'':<literal remap="tt">  mail, news, ftp, telnet,
xarchie</literal>, etc. En esencia, <literal remap="tt">term</literal> es muy parecido a otros protocolos
serie como <literal remap="tt">SLIP</literal> o <literal remap="tt">PPP</literal>. La ventaja de <literal remap="tt">term</literal> es que puede correr
enteramente desde el espacio de usuario, sin requerir soporte del kernel
ni del sistema o administradores de red.
</para>

<para>
A diferencia de <literal remap="tt">SLIP</literal> o <literal remap="tt">PPP</literal>, tu máquina no llega a tener su propia
dirección IP. Todo el tráfico deberá ir dirigido al host remoto, y
será redirigido a tu máquina mediante <literal remap="tt">TERM</literal>.
</para>

</sect2>

</sect1>

<sect1>
<title>Cómo funciona el <literal remap="tt">TERM</literal></title>

<para>
Antes de experimentar con <literal remap="tt">term</literal> es altamente aconsejable leer
primero este capítulo completo y el fichero <literal remap="tt">INSTALLATION</literal> que viene con el
paquete. También conviene echar una ojeada a las páginas de manual de
<literal remap="tt">linecheck</literal>, <literal remap="tt">(term)test</literal> y <literal remap="tt">term</literal>. Esto te ayudará a
trabajar más fácil y más rápido. 
</para>

<sect2>
<title>Nomenclatura</title>

<para>
Asumo que estás llamando a un sistema a través de algún tipo de servidor
de terminal. Utilizo los términos <emphasis remap="it">``local''</emphasis> y <emphasis remap="it">``remoto''</emphasis>
para referirme a los sistemas conectados en casa y en la red
respectivamente (a no ser que los use para referirme a alguna otra cosa :-).
</para>

<para>
<literal remap="tt">term</literal> proporciona a la máquina local, que no tiene conexión de
red, pero que está conectada por una línea serie a una máquina remota, la
cual a su vez está conectada a una red, servicios de red. Observemos cómo
una máquina con una conexión de red ``tradicional'' proporciona estos
servicios. 
</para>

<para>
Primero el usuario invoca un programa, como <literal remap="tt">telnet</literal> o <literal remap="tt">ftp</literal>,
que requiere un servicio de red. Lo que estos programas hacen es hacer una
llamada del sistema solicitando servicios de red. El sistema operativo
obtiene entonces estos servicios a través de su interface de red (por
ejemplo, manda y recibe paquetes sobre la ethernet). 
</para>

<para>
<literal remap="tt">SLIP</literal> y <literal remap="tt">PPP</literal> hacen exactamente esto, convirtiendo la línea módem
en un interface de red, lo cual en principio no es diferente de una
ethernet. La pega está en que estos protocolos hacen de la máquina
conectada por módem parte de la red, justo como cualquier otra máquina.
Esto exige toda la tarea administrativa asociada al hecho de ser un nodo
de la red (más aún, ya que el enlace módem también hay que administrarlo). 
</para>

<para>
En ausencia de una conexión de red como <literal remap="tt">SLIP</literal> o <literal remap="tt">PPP</literal>, ¿qué es lo
que se hace típicamente?. Bien, llamas a tu máquina conectada a la red,
lees tu correo, tus news, etc, si necesitas un fichero, primero te lo
transfieres a la máquina remota y entonces te lo envías a la máquina local
usando el <literal remap="tt">kermit</literal> o algún otro programa de comunicaciones.
</para>

<para>
Esto es una pena, especialmente porque en realidad sólo puedes hacer que
una cosa use el enlace módem a la vez. La idea que hay detrás del
<literal remap="tt">term</literal> es básicamente automatizar y <emphasis remap="it">multiplexar</emphasis> este proceso.
El <literal remap="tt">term</literal> se invoca en ambas máquinas, local y remota, y los dos
procesos se comunican entre sí por la línea módem.  Cuando necesitas un
servicio de red, haces una solicitud al <emphasis remap="it">daemon</emphasis> del <literal remap="tt">term</literal>
local, el cual transmite la petición al <emphasis remap="it">daemon</emphasis> del <literal remap="tt">term</literal> en
la máquina remota (conectada a la red). El resultado se devuelve a través
de la línea módem.
</para>

<para>
Para ser más precisos, pongamos que quieres conseguir un fichero por
<literal remap="tt">ftp</literal>. Primero necesitas una versión de <literal remap="tt">ftp</literal> que pueda hablar con
<literal remap="tt">term</literal>.  Invocas <literal remap="tt">termftp</literal> como lo haces con un <literal remap="tt">ftp</literal>
normal, pongamos <literal remap="tt">'termftp nethost.gov'</literal>, pero esta versión
especial hace su solicitud de red al daemon del <literal remap="tt">term</literal> local en vez
de al kernel. El <literal remap="tt">term</literal> local transfiere esta petición, a través de
la línea del módem, al <literal remap="tt">term</literal> remoto, el cual establece una
conexión con <literal remap="tt">nethost.gov</literal>, y transmite los datos de vuelta sobre el enlace
módem. 
</para>

<para>
<literal remap="tt">term</literal> es lo suficientemente listo como para tener muchas cosas
diferentes funcionando a la vez, por lo que puedes tener varias sesiones
de red distintas usando el mismo enlace módem; por ejemplo puedes estar
dentro de otra máquina lejana vía <literal remap="tt">termtelnet</literal> mientras continúa la
transferencia del <literal remap="tt">termftp</literal>.
</para>

<para>
Si esto es demasiado abstracto (o engorroso) no te preocupes; la
información importante que hay que extraer de esta sección es que hay
<emphasis remap="it">dos copias</emphasis> del <literal remap="tt">term</literal> corriendo, una a cada lado del
enlace módem.
</para>

</sect2>

</sect1>

<sect1>
<title>Poniendo a punto las cosas.</title>

<sect2>
<title>Qué necesitas tener de antemano.</title>

<para>
Antes de comenzar a construir y usar el <literal remap="tt">TERM</literal> debes asegurarte de que 
tienes incluido el soporte <emphasis remap="it">TCP/IP</emphasis> en el kernel. Además, asegúrate de
que esté activo el interface <emphasis remap="it">loopback</emphasis> de <emphasis remap="it">TCP/IP</emphasis>. Si éste es tu 
caso, puedes seguir con el resto de esta sección.
</para>

</sect2>

<sect2>
<title>Explicación de conceptos.</title>

<para>
En las versiones nuevas del <literal remap="tt">term</literal> han aparecido dos conceptos
nuevos. Estos dos conceptos se explican en los siguientes apartados. 
</para>

<sect3>
<title><emphasis remap="it">``Sharing''</emphasis> (compartición). </title>

<para>
 
</para>

<para>
A partir de la versión 1.16 aparece el concepto de compartir la conexión
<literal remap="tt">TERM</literal> con otros usuarios. Esto significa que cuando habilitas la
característica <emphasis remap="it">``shared''</emphasis> (compartida), más gente podrá usar la misma
conexión <literal remap="tt">TERM</literal> que tú estás usando, es decir, cuando estás
trabajando en tu máquina remota a través de tu conexión <literal remap="tt">TERM</literal> (has
usado <literal remap="tt">trsh</literal> en tu máquina local para acceder, por ejemplo) otra
persona en tu máquina local podrá usar la misma conexión <literal remap="tt">TERM</literal> al
mismo tiempo para transmitir un fichero con <literal remap="tt">ftp</literal> a su cuenta en tu
máquina local desde un <literal remap="tt">ftp</literal> <emphasis remap="it">site</emphasis> de cualquier lugar del mundo.
</para>

<para>
Cuando deshabilitas la característica <emphasis remap="it">``shared''</emphasis> (compartida) (o sea,
ejecutas <literal remap="tt">TERM</literal> en modo privado) tú y solo tú (sin contar a
<literal remap="tt">root</literal> :-) puede usar la conexión <literal remap="tt">TERM</literal>. 
</para>

<para>
Por supuesto, sólo necesitas instalar el <emphasis remap="it">``shared''</emphasis> <literal remap="tt">TERM</literal> en
el extremo en el que quieres permitir a la gente usar la misma conexión
<literal remap="tt">TERM</literal> que tú estés usando. Así que, si otra gente tiene cuenta en
tu máquina local y quieren usarlo desde algún lugar de tu red remota
habilitas la característica shared en el extremo remoto de tu conexión
<literal remap="tt">TERM</literal>. De esta forma toda esta gente puede acceder a tu máquina a
la vez compartiendo la misma conexión <literal remap="tt">TERM</literal> entre sí y contigo
mismo. (NOTA: el primer ejemplo necesitaba habilitar la característica
shared en el extremo local de la conexión <literal remap="tt">TERM</literal>).
</para>

<para>
<emphasis remap="bf">NOTA para la instalación como <literal remap="tt">root</literal></emphasis>: 
</para>

<para>
Cuando instalas <literal remap="tt">TERM</literal> como <literal remap="tt">root</literal>, primero debes crear un grupo
<literal remap="tt">TERM</literal> (antes de compilar) sin miembros, añadiendo la siguiente
línea en <literal remap="tt">/etc/group</literal>: 
</para>

<para>

<screen>
term::16:root
</screen>

</para>

<para>
o cualquier otro <literal remap="tt">GID</literal> no usado en lugar del 16 si éste ya está en uso.
</para>

<para>
Después de compilar e instalar coloca al <literal remap="tt">TERM</literal> y sus clientes el
<literal remap="tt">SGID</literal> <emphasis remap="it">term</emphasis>: 
</para>

<para>

<screen>
chgrp term &#60;cliente_term&#62;
chmod g+s &#60;cliente_term&#62;
</screen>

</para>

<para>
También cualquier programa que hagas utilizable con <literal remap="tt">TERM</literal> debe tener 
SGID <literal remap="tt">TERM</literal>.
</para>

</sect3>

<sect3>
<title>``<emphasis remap="it">Full TERM networking</emphasis>'' (conexión de red completamente TERM) </title>

<para>
A partir de la versión <literal remap="tt">2.0.0</literal> de <literal remap="tt">TERM</literal> se usa el concepto
<emphasis remap="it">full TERM networking</emphasis> (conexión de red totalmente TERM). Cuando tu
única conexión con el mundo exterior es una conexión <literal remap="tt">TERM</literal>, tienes
una red <emphasis remap="it">full TERM</emphasis> (completamente TERM) y deberías compilar el
<literal remap="tt">TERM</literal> con full <literal remap="tt">TERM</literal> networking.  En este caso se ha
puesto un fichero llamado <literal remap="tt">termnet</literal> en el directorio compartido.
Esto dice a <literal remap="tt">TERM</literal> que tu única conexión con el exterior es a
través del <literal remap="tt">TERM</literal>. 
</para>

<para>
Cuando también tienes algún otro tipo de conexión de red además de los
programas (pasados a <literal remap="tt">TERM</literal>) de la conexión <literal remap="tt">TERM</literal>, primero
intenta que realicen su trabajo usando esta otra conexión. Si ésta falla
entonces se invoca el <literal remap="tt">TERM</literal> y se intenta realizar el trabajo a
través de la conexión <literal remap="tt">TERM</literal>. Para aclarar esto, ahora se da un
ejemplo en el que el se usa <literal remap="tt">telnet</literal> hecho utilizable en <literal remap="tt">TERM</literal>.
Este <literal remap="tt">telnet</literal> debería funcionar con y sin <literal remap="tt">TERM</literal>. 
</para>

<para>

<screen>
telnet localhost
</screen>

</para>

<para>
no usa el <literal remap="tt">TERM</literal> para conectar, pero
</para>

<para>

<screen>
telnet zeus.cs.kun.nl
</screen>

</para>

<para>
usará el <literal remap="tt">TERM</literal> sólo si no tienes otro tipo de conexión de red.
</para>

<para>
El full TERM networking también implica el mentir sobre el nombre del
host local, diciendo que es el host remoto en su lugar. Además, provoca que
<literal remap="tt">bind (0)</literal> actúe siempre en el host remoto. En esencia hace que muchos
programas puedan usarse sin ir a través del <literal remap="tt">TERM</literal> mientras el
<literal remap="tt">TERM</literal> está corriendo. Desafortunadamente, la mayoría de programas
y demonios <literal remap="tt">UDP</literal> no funcionarán con <literal remap="tt">TERM</literal> sin estos incómodos
trucos.
</para>

</sect3>

</sect2>

<sect2>
<title>Compilación del <literal remap="tt">TERM</literal></title>

<para>
Si tienes suerte esto sólo debe implicar un <literal remap="tt">make</literal>. Sin embargo, lo
más probable es que necesites hacer más. Debido a nuevas opciones en las
versiones nuevas del <literal remap="tt">TERM</literal> (<literal remap="tt">sharing</literal>, <literal remap="tt">configure</literal>) ahora es
un poco más complicado crear el ejecutable del <literal remap="tt">TERM</literal>. Hoy en día
pueden seguirse un par de caminos para obtener el ejecutable. 
</para>

<para>
Para cubrir todos los caminos a seguir con los que puede construirse el 
<literal remap="tt">TERM</literal> vamos a dividir esta sección en tres partes:
</para>

<para>

<orderedlist>
<listitem>

<para>
Construir el <literal remap="tt">TERM</literal> hasta la versión 1.15
</para>
</listitem>
<listitem>

<para>
Construir el <literal remap="tt">TERM</literal>, versiones 1.16 hasta 1.19
</para>
</listitem>
<listitem>

<para>
Construir el <literal remap="tt">TERM</literal>, versiones 2.0.0 y superiores
</para>
</listitem>

</orderedlist>

</para>

<sect3>
<title>Construir el <literal remap="tt">term</literal> hasta la versión 1.15</title>

<para>
Para estas versiones del <literal remap="tt">term</literal>, la compilación no debería implicar 
ejecutar más que estos comandos
</para>

<para>

<screen>
make DO=install OS-type
make installman
</screen>

</para>

<para>
Encontrarás el <literal remap="tt">term</literal>, sus clientes y las páginas de manual
(<literal remap="tt">man</literal>)  cómodamente construidas e instaladas y listas para usar
después de esto. 
</para>

<para>
Además, necesitarás crear un directorio <literal remap="tt">$HOME/term</literal>. Este
directorio lo usará el <literal remap="tt">term</literal> para buscar su fichero
<literal remap="tt">termrc</literal>. 
</para>

<para>
La única cosa que puedes querer hacer es cambiar algunos de los paths
en el <literal remap="tt">Makefile</literal>, o cambiar alguna opción del compilador.
</para>

</sect3>

<sect3>
<title>Construir el <literal remap="tt">term</literal>, versiones 1.16 hasta 1.19 </title>

<para>
 
</para>

<para>
Para construir el <literal remap="tt">term</literal> ahora puedes elegir una de las siguientes
formas: 
</para>

<para>

<orderedlist>
<listitem>

<para>
Como un usuario normal, construir el <literal remap="tt">term</literal> en modo privado
</para>
</listitem>
<listitem>

<para>
Como un usuario normal, construir el <literal remap="tt">term</literal> en modo shared
</para>
</listitem>
<listitem>

<para>
Como <literal remap="tt">root</literal>, construir el <literal remap="tt">term</literal> en modo privado
</para>
</listitem>
<listitem>

<para>
Como <literal remap="tt">root</literal>, construir el <literal remap="tt">term</literal> en modo shared
</para>
</listitem>

</orderedlist>

</para>

<para>
Abajo se explicará cómo habilitar/deshabilitar la opción <literal remap="tt">shared</literal>
durante la compilación del <literal remap="tt">term</literal>
</para>

<para>

<orderedlist>
<listitem>

<para>
Eres un usuario normal (sin acceso de <literal remap="tt">root</literal>) y NO quieres
COMPARTIR (SHARE) la conexión <literal remap="tt">term</literal> con otros usuarios.

Como usuario que no quiere compartir la conexión <literal remap="tt">term</literal> con otros
usuarios deberías hacer lo siguiente para construir el <literal remap="tt">term</literal>:


<screen>
   make DO=install OS-type
   make installman
</screen>


Después de esto, el <literal remap="tt">term</literal>, sus clientes y las páginas de manual están
generados e instalados.

Además, necesitarás crear un directorio <literal remap="tt">$HOME/term</literal>. Este
directorio lo usará el <literal remap="tt">term</literal> para buscar su fichero
<literal remap="tt">termrc</literal>.

La única cosa que puedes querer hacer es cambiar algunos de los paths
en el <literal remap="tt">Makefile</literal> o cambiar algún parámetro del compilador.

</para>
</listitem>
<listitem>

<para>
Eres un usuario normal (sin acceso de <literal remap="tt">root</literal>) y SI quieres COMPARTIR
(SHARE) la conexión <literal remap="tt">term</literal> con otros usuarios.

Como usuario que quiere compartir la conexión <literal remap="tt">term</literal> con otros
usuarios deberías hacer lo siguiente para construir el <literal remap="tt">term</literal>:


<screen>
   make DO=installshare USERSHARE=$HOME/term OS-type
   make installman
</screen>


Después de esto, el <literal remap="tt">term</literal>, sus clientes y las páginas de manual 
estarán compiladas e instaladas.

Además, tendrás un directorio <literal remap="tt">$HOME/term</literal> (por defecto) con
permisos <literal remap="tt">drwxrwxr-x</literal>. En este directorio encontrarás al menos el
<emphasis remap="it">socket</emphasis> usado por el <literal remap="tt">term</literal> para sus conexiones
(<literal remap="tt">tmp/private/socket=</literal>).

</para>
</listitem>
<listitem>

<para>
Eres <literal remap="tt">root</literal> y NO quieres COMPARTIR (SHARE) la conexión <literal remap="tt">term</literal> con
otros usuarios.

Como <literal remap="tt">root</literal> que no quiere compartir la conexión <literal remap="tt">term</literal> con otros
usuarios deberías hacer lo siguiente para construir el <literal remap="tt">term</literal>:


<screen>
   make DO=install OS-type
   make installman
</screen>


Después de esto, el <literal remap="tt">term</literal>, sus clientes y las páginas de manual 
estarán compiladas e instaladas.

Además, tendrás un directorio llamado <literal remap="tt">/usr/local/lib/term</literal> (por
defecto) con permisos <literal remap="tt">drwxr-xr-x</literal>. En este directorio encontrarás
al menos el <emphasis remap="it">socket</emphasis> usado por el <literal remap="tt">term</literal> para sus conexiones
(<literal remap="tt">tmp/private/socket=</literal>).

</para>
</listitem>
<listitem>

<para>
Eres <literal remap="tt">root</literal> y quieres COMPARTIR (SHARE) la conexión <literal remap="tt">term</literal>.

Primero, asegúrate de haber leído la sección sobre ``sharing'' anterior.

Como <literal remap="tt">root</literal> que quiere compartir la conexión <literal remap="tt">term</literal> deberías hacer lo
siguiente:


<screen>
   make DO=installshare OS-type
   make installman
</screen>


Después de esto, el <literal remap="tt">term</literal>, sus clientes y las páginas de manual
estarán compiladas e instaladas.

Además, tendrás un directorio llamado <literal remap="tt">/usr/local/lib/term</literal> (por
defecto) con permisos <literal remap="tt">drwxrwxr-x</literal>. En este directorio encontrarás
al menos el <emphasis remap="it">socket</emphasis> usado por el <literal remap="tt">term</literal> para sus conexiones
(<literal remap="tt">tmp/private/socket=</literal>). 

</para>
</listitem>

</orderedlist>

</para>

</sect3>

<sect3>
<title>Construir el <literal remap="tt">TERM</literal>, versiones <literal remap="tt">2.0.0</literal> y superiores</title>

<para>
Primero asegúrate de haber leído la sección sobre ``full term networking''
de arriba.
</para>

<para>
Para las versiones de <literal remap="tt">term 2.0.0</literal> y superiores hay muchas formas
de generar el binario del <literal remap="tt">term</literal> y los clientes. Todo esto puede
hacerse tanto por <literal remap="tt">root</literal> como por un usuario cualquiera: 
</para>

<para>

<orderedlist>
<listitem>

<para>
Generar el <literal remap="tt">term</literal> en modo privado sin full term networking
</para>
</listitem>
<listitem>

<para>
Generar el <literal remap="tt">term</literal> en modo privado con full term networking
</para>
</listitem>
<listitem>

<para>
Generar el <literal remap="tt">term</literal> en modo shared sin full term networking
</para>
</listitem>
<listitem>

<para>
Generar el <literal remap="tt">term</literal> en modo shared con full term networking
</para>
</listitem>

</orderedlist>

</para>

<para>
En estas versiones de <literal remap="tt">term</literal> ha aparecido una nueva forma de
compilar, usando el script <literal remap="tt">configure</literal>. Cuando se ejecuta <literal remap="tt">configure</literal>
éste chequea en que sistema operativo estás tratando de instalar el
<literal remap="tt">term</literal>, si el directorio origen está disponible o no, y si hay
puesta alguna opción <emphasis remap="it">runtime</emphasis>.  De acuerdo con las cosas encontradas
<literal remap="tt">configure</literal> crea entonces un <literal remap="tt">Makefile</literal> usando <literal remap="tt">Makefile.in</literal> que
se entrega con el paquete del <literal remap="tt">term</literal>. 
</para>

<para>
Dos de las opciones más importantes para <literal remap="tt">configure</literal> son <literal remap="tt">--root</literal> y
<literal remap="tt">--user</literal> que establecen si el <literal remap="tt">term</literal> será instalado por
<literal remap="tt">root</literal> o por un usuario cualquiera. Se pueden usar otras opciones para
instalar el <literal remap="tt">term</literal> de la forma que quieras (con paths no estándar,
por ejemplo). 
</para>

<para>

<orderedlist>
<listitem>

<para>
Generar el <literal remap="tt">term</literal> en modo privado sin full term networking

Para generar el <literal remap="tt">term</literal> de este modo necesitas ejecutar los siguientes 
comandos (tanto para <literal remap="tt">root</literal> como para cualquiera):


<screen>
   make install installman
</screen>


Esto genera los binarios, instalándolos junto con las páginas de manual.

</para>
</listitem>
<listitem>

<para>
Generar el <literal remap="tt">term</literal> en modo privado con full term networking

Para generar el <literal remap="tt">term</literal> de este modo necesitas ejecutar los siguientes 
comandos (tanto para el <literal remap="tt">root</literal> como para cualquiera):


<screen>
   make installnet installman
</screen>


Esto genera los binarios, instalándolos junto con las páginas de manual.

</para>
</listitem>
<listitem>

<para>
Generar el <literal remap="tt">term</literal> en modo shared sin full term networking
   
Para generar el <literal remap="tt">term</literal> de este modo necesitas ejecutar los siguientes 
comandos (tanto para el <literal remap="tt">root</literal> como para cualquiera):


<screen>
   make share installman
</screen>


Esto genera los binarios e instala estos binarios y las páginas de manual.

</para>
</listitem>
<listitem>

<para>
Generar el <literal remap="tt">term</literal> en modo shared con full term networking

Para generar el <literal remap="tt">term</literal> de este modo necesitas ejecutar los siguientes 
comandos (tanto para el <literal remap="tt">root</literal> como para cualquiera):


<screen>
   make share installnet installman  
</screen>


Esto genera los binarios e instala estos binarios y las páginas de manual.

</para>
</listitem>

</orderedlist>

</para>

</sect3>

</sect2>

<sect2>
<title><literal remap="tt">client.a, libtermnet.a, libtermnet.sa, libtermnet.so</literal></title>

<para>
Con el <literal remap="tt">term</literal> se suministra una librería con funciones para
clientes <literal remap="tt">term</literal>. 
</para>

<para>
Hasta la versión 1.16 esta libreria se llamaba <literal remap="tt">client.a</literal>. Durante la
compilación de <literal remap="tt">term</literal> se generaba esta librería, que después se
usaba en la compilación de los clientes <literal remap="tt">term</literal>. No se instalaba en
otro directorio. 
</para>

<para>
A partir de la versión 1.16 se cambió el nombre de la librería por
<literal remap="tt">libtermnet.a</literal>. Hasta la versión 1.19 esta librería se crea en el
directorio <literal remap="tt">term</literal> y después se usa durante la compilación de los
clientes <literal remap="tt">term</literal>. No se instala en otro directorio.
</para>

<para>
A partir de la versión 2.0.0, además de <literal remap="tt">libtermnet.a</literal> también se crean
<literal remap="tt">libtermnet.so</literal> y <literal remap="tt">libtermnet.sa</literal> (libreria <emphasis remap="it">shared</emphasis> y librería
<emphasis remap="it">exported initialized</emphasis>) durante la instalación del paquete
<literal remap="tt">term</literal>. Durante la instalación de todas las partes del paquete,
estos tres ficheros de librerías se instalan en el directorio
<literal remap="tt">/usr/local/lib</literal> (por defecto).  Y después se hace un enlace desde
<literal remap="tt">libtermnet.so.2</literal> a <literal remap="tt">libtermnet.so.2.x.x</literal>. 
</para>

<para>
Finalmente se ejecuta <literal remap="tt">ldconfig</literal> para crear los enlaces necesarios y el
caché (para uso del enlazador dinámico, <literal remap="tt">ld.so</literal>) para las librerías
compartidas más recientes que se encuentran en los directorios
especificados en la línea de comandos, en el fichero
<literal remap="tt">/etc/ld.so.conf</literal>, y en los directorios permitidos
(<literal remap="tt">/usr/lib</literal> y <literal remap="tt">/lib</literal>). 
</para>

<para>
Si la instalación se hace correctamente, los tres ficheros de librería
podrán ser usados por los clientes de <literal remap="tt">term</literal> que son generados con
librerías dinámicas en lugar de estáticas. Estas librerías también se
pueden usar ahora para portar tu software propio a fin de poderlo usar con
el <literal remap="tt">term</literal> (ver más adelante).
</para>

</sect2>

<sect2>
<title>Estableciendo variables de entorno.</title>

<para>
<literal remap="tt">term</literal> reconoce un par de variables de entorno que pueden definir los
usuarios. Las tres primeras de éstas que se explicarán son:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">TERMDIR</literal>
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">TERMSHARE</literal>
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">TERMMODE</literal>
</para>
</listitem>

</itemizedlist>

</para>

<para>
Definiendo estas variables puedes controlar el modo en que se ejecuta el 
<literal remap="tt">term</literal>.
</para>

<para>
Para versiones del <literal remap="tt">term</literal> hasta la 1.15 sólo es importante la
variable <literal remap="tt">TERMDIR</literal> (estas versiones no reconocen el modo <emphasis remap="it">shared</emphasis>).
Para estas versiones <literal remap="tt">TERMDIR</literal> se debería definir como sigue: 
</para>

<para>

<screen>
setenv TERMDIR $HOME     # csh o tcsh
export TERMDIR=$HOME     # bash
</screen>

</para>

<para>
A partir de la versión 1.16 <literal remap="tt">term</literal> también reconoce las variables
<literal remap="tt">TERMSHARE</literal> y <literal remap="tt">TERMMODE</literal>. Con estas variables se le puede indicar al
<literal remap="tt">term</literal> que funcione en modo privado o en modo compartido. 
Explicaremos como definir las variables para ambos modos.
</para>

<para>

<orderedlist>
<listitem>

<para>
 Ejecutar <literal remap="tt">term</literal> en modo privado puede hacerse
definiendo las variables <literal remap="tt">TERMDIR</literal> y <literal remap="tt">TERMMODE</literal> de la siguiente forma:

Para <literal remap="tt">csh</literal> o <literal remap="tt">tcsh</literal>:

<screen>
   setenv TERMDIR $HOME
   setenv TERMMODE 0
</screen>


Para <literal remap="tt">bash</literal>: 


<screen>
 
export TERMDIR=$HOME export TERMMODE=0 
</screen>

</para>
</listitem>
<listitem>

<para>
Si quieres usar el <literal remap="tt">term</literal> en modo compartido hay dos formas
de definir las variables:


<orderedlist>
<listitem>

<para>
 Si <literal remap="tt">term</literal> se instala como un programa <literal remap="tt">SUID</literal> sólo se debe 
definir <literal remap="tt">TERMMODE</literal>. (<literal remap="tt">README</literal> en el paquete del <literal remap="tt">term</literal>).


<screen>
      setenv TERMMODE 'numero'    # csh o tcsh
      export TERMMODE='numero'    # bash
</screen>


En <literal remap="tt">'numero'</literal> debe ponerse 1 si se está usando una versión del
<literal remap="tt">term</literal> entre la 1.16 y la 1.19 (<literal remap="tt">README.share</literal> en el paquete del
<literal remap="tt">term</literal>) y 2 si se está usando la versión de <literal remap="tt">term</literal> <literal remap="tt">2.0.0</literal> o
superior (<literal remap="tt">README.security</literal> en el paquete del <literal remap="tt">term</literal>). 

</para>
</listitem>
<listitem>

<para>
 Si <literal remap="tt">term</literal> se instala como un programa <literal remap="tt">SGID</literal> las variables se 
deben definir del siguiente modo:

Para <literal remap="tt">csh</literal> o <literal remap="tt">tcsh</literal>:


<screen>
      setenv TERMMODE 1
      setenv TERMDIR /usr/local/lib/term
      setenv TERMSHARE $TERMDIR
</screen>



Para <literal remap="tt">bash</literal>:


<screen>
   export TERMMODE=1
   export TERMDIR=/usr/local/lib/term
   export TERMSHARE=$TERMDIR
</screen>


Poniendo las variables de esta forma hará posible que se ejecuten clientes
viejos (<emphasis remap="it">linkados</emphasis> con una versión antigua del <literal remap="tt">client.a</literal>) en modo 
compartido (shared).

</para>
</listitem>

</orderedlist>
 

</para>
</listitem>

</orderedlist>

</para>

<para>
A partir de la versión <literal remap="tt">2.0.0</literal>, <literal remap="tt">term</literal> también reconoce la variable
<literal remap="tt">TERMSERVER</literal>.  Se necesita definir esta variable cuando se tienen
varios módems y mas de una conexión a la vez. Para especificar que
conexión usar, se debe ejecutar el <literal remap="tt">term</literal> con un nombre de
servidor: 
</para>

<para>

<screen>
 
nohup term -v /dev/modem1 Connection1 &#38; nohup term -v /dev/modem2 Connection2 &#38;
</screen>
 
</para>

<para>
Los usuarios deberían definir la variable <literal remap="tt">TERMSERVER</literal> con el nombre
de conexión que quieran usar:  
</para>

<para>

<screen>
 
setenv TERMSERVER Connection1     	# csh o tcsh  
export TERMSERVER=Connection2     	# bash  
</screen>

</para>

</sect2>

<sect2>
<title>Probar el <literal remap="tt">TERM</literal></title>

<para>
 
</para>

<para>
Haz un <literal remap="tt">make test</literal> (o <literal remap="tt">make termtest</literal> para versiones nuevas
del <literal remap="tt">term</literal>) para generar el demonio de prueba del <literal remap="tt">term</literal>. 
<literal remap="tt">(term)test</literal> funciona ejecutando dos copias del <literal remap="tt">term</literal> en tu
sistema, una ``local'' y una ``remota''. Ambas leerán tu <literal remap="tt">termrc</literal>; de
modo que puedas ajustar su comportamiento. Ahora ejecuta
<literal remap="tt">(term)test</literal>. Deberías poder hacer un <literal remap="tt">trsh</literal> y un
<literal remap="tt">tupload</literal>.  Prueba con:
</para>

<para>

<screen>
 tupload ./term /usr/tmp
</screen>

</para>

<para>
deberías de conseguir tener una copia del binario <literal remap="tt">term</literal> en
<literal remap="tt">/usr/tmp</literal> ). La salida del <literal remap="tt">term</literal> local debería aparecer en
<literal remap="tt">local.log</literal> y la remota en <literal remap="tt">remote.log</literal>. Puedes ejecutar
<literal remap="tt">term</literal> con el parámetro <literal remap="tt">-d255</literal> para poder registrar lo que
ocurra en estos ficheros, o habilitar el <emphasis remap="it">debugging</emphasis> en tu <literal remap="tt">termrc</literal>.
</para>

<para>
NOTA: Ejecuta el <literal remap="tt">test</literal> como <literal remap="tt">./test</literal> para evitar el
<literal remap="tt">test</literal> del sistema. 
</para>

</sect2>

<sect2>
<title><literal remap="tt">TERM</literal> y los programas de comunicaciones.</title>

<para>
Antes de poder usar <literal remap="tt">term</literal>, tienes que establecer una conexión vía
módem usando un programa de comunicaciones como <literal remap="tt">kermit</literal> o <literal remap="tt">seyon</literal>.
En la documentación del programa encontrarás qué tienes que hacer para
conectarte con la máquina remota. 
</para>

<para>
Cuando hayas establecido la conexión y quieras ejecutar <literal remap="tt">term</literal>,
necesitas suspender o salir del programa de comunicaciones sin cerrar la
conexión. 
</para>

<para>
A continuación explicaré cómo hacer esto con algunos programas de
comunicaciones.
</para>

<sect3>
<title><literal remap="tt">kermit</literal></title>

<para>
Iniciar <literal remap="tt">term</literal> cuando se usa <literal remap="tt">kermit</literal> es fácil. En el
<emphasis remap="it">prompt</emphasis> local de <literal remap="tt">kermit</literal> se teclea ``<emphasis remap="it">suspend</emphasis>'', de modo que
volverás al prompt de Linux. Desde este prompt puedes ya establecer la
conexión <literal remap="tt">term</literal>.
</para>

</sect3>

<sect3>
<title><literal remap="tt">seyon</literal></title>

<para>
Una forma de iniciar chequeo de línea o <literal remap="tt">TERM</literal> cuando usas
<literal remap="tt">seyon</literal> es poner <literal remap="tt">linecheck</literal> y <literal remap="tt">TERM</literal> en el menú
<literal remap="tt">Transfer</literal> (controlado por el fichero 
<literal remap="tt">$HOME/.seyon/protocols</literal>). 
</para>

<para>
Añade al fichero <literal remap="tt">$HOME/.seyon/protocols</literal> lo siguiente:
</para>

<para>

<screen>
"Line check" "$cd /tmp; linecheck"
"Term" "$term -c off -w 10 -t 150 -s 38400 -l $HOME/tlog"
</screen>

</para>

<para>
Ahora, cuando inicies <literal remap="tt">linecheck</literal> o <literal remap="tt">term</literal> en la máquina local,
selecciona en el menú <literal remap="tt">Transfer</literal> el ítem ``<literal remap="tt">Line Check</literal>'' o
``<literal remap="tt">Term</literal>''. 
</para>

<para>
Por supuesto, también podrías usar el botón de comando de shell y
teclear en el cuadro de diálogo que se te abrirá los comandos <literal remap="tt">linecheck</literal> o
<literal remap="tt">term</literal>. Esto mismo hace redirección automática al comando.
</para>

</sect3>

</sect2>

<sect2>
<title>Hacer un enlace transparente.</title>

<para>
Presumiblemente, puedes establecer una conexión módem entre tus hosts 
local y remoto. Típicamente lo que haces es, llamar a algún tipo de 
servidor de terminales y conectas con tu host remoto a través de él. 
</para>

<para>
También sueles usar para ello software de terminal, como <literal remap="tt">kermit</literal> o
<literal remap="tt">seyon</literal> para comunicar con tu módem (los ejemplos de este documento
usan el <literal remap="tt">kermit</literal>, ya que es el que usa el autor). Si estás teniendo
problemas con el módem, o con el software de terminal, echa una ojeada al
<emphasis remap="it">Serial HOWTO</emphasis>; esto debería ayudarte. 
</para>

<para>
Una vez establecido el enlace, querrás hacerlo lo más transparente
posible.  Comprueba los comandos en el servidor de terminal (<literal remap="tt">help</literal> o
<literal remap="tt">?</literal> suele ser un buen comienzo). Busca la opción <emphasis remap="it">8 bits</emphasis> siempre
que sea posible. Esto puede implicar cambiar la forma en que accedes a tu
sistema, por ejemplo, si el servidor usa <literal remap="tt">rlogin</literal>, tendrás que usarlo
poniendo el parámetro <literal remap="tt">-8</literal> para hacerlo transparente. 
</para>

<para>
Especialmente vigila el control de flujo por <emphasis remap="it">xon/xoff</emphasis>. No lo
necesitas. Intenta habilitar el control de flujo por hardware,
<emphasis remap="it">rts/cts</emphasis>. Puede que tengas que mirar la documentación de tu módem para
saber cómo configurarlo para hacer comunicaciones <emphasis remap="it">rts/cts</emphasis> de 8
bits. 
</para>

</sect2>

<sect2>
<title>Ejecutar <literal remap="tt">linecheck</literal></title>

<para>
<emphasis remap="bf">ATENCIÓN:</emphasis> En algunos documentos las opciones de línea de comandos
para <literal remap="tt">linecheck</literal> se citan en orden incorrecto. He comprobado esto y
he hallado que el orden de las opciones que menciono aquí abajo es el
correcto. 
</para>

<para>
<emphasis remap="bf">NOTA:</emphasis> a partir de la versión de <literal remap="tt">term</literal> 2.3.0
<literal remap="tt">linecheck</literal> ya no necesitará tener el nombre del fichero de log en la
línea de comandos.  Escribirá su salida al fichero <literal remap="tt">linecheck.log</literal> en
el directorio desde el que se ejecute <literal remap="tt">linecheck</literal>.
</para>

<para>
<literal remap="tt">linecheck</literal> es un programa que se entrega con el <literal remap="tt">term</literal>.
Comprueba la transparencia de un enlace, produciendo información de
configuración que necesita el <literal remap="tt">term</literal> para funcionar correctamente.
<literal remap="tt">linecheck</literal> manda todos los 256 caracteres de 8 bits posibles sobre el
enlace y verifica que cada uno se transmite correctamente. 
</para>

<para>
Hay que configurar <literal remap="tt">term</literal> para manejar caracteres que no pueden ser
transmitidos por el enlace, y <literal remap="tt">linecheck</literal> determina cuáles son estos
caracteres. Debes usar <literal remap="tt">linecheck</literal> después de haber establecido un
enlace módem lo más transparente posible. Para correr <literal remap="tt">linecheck</literal> haz
lo siguiente:
</para>

<para>

<orderedlist>
<listitem>

<para>
En el sistema remoto, ejecuta  <literal remap="tt">linecheck linecheck.log</literal>

</para>
</listitem>
<listitem>

<para>
Vuelve a tu sistema local y suspende tu programa de comunicaciones
(<literal remap="tt">&circ;Z</literal> en <literal remap="tt">kermit</literal>) (si no te robará caracteres del <literal remap="tt">linecheck</literal>).

</para>
</listitem>
<listitem>

<para>
En el sistema local ejecuta 


<screen>
linecheck linecheck.log &#62; /dev/modem &#60; /dev/modem
</screen>


</para>
</listitem>

</orderedlist>

</para>

<para>
Cuando termine <literal remap="tt">linecheck</literal> encontrarás un conjunto de números al final
de los ficheros <literal remap="tt">linecheck.log</literal>. Estos son los que deberías poner como
'escape' en el <literal remap="tt">termrc</literal> al otro lado del enlace. Por ejemplo, mi
<literal remap="tt">linecheck.log</literal> local decía que 'escape' era el 29 y 157. Así que, mi
<literal remap="tt">termrc</literal> local escapa (evita) estos caracteres y mi <literal remap="tt">termrc</literal> remoto
ninguno. Si se escapa (evita) un carácter en un extremo, también debo
ignorarlo (ignore) en el otro; así que, en este ejemplo, debería ignorar
29 y 157 en mi sistema remoto. 
</para>

<para>
Si <literal remap="tt">linecheck</literal> se cuelga, prueba a usar
</para>

<para>

<screen>
linecheck linecheck.log 17 19
</screen>

</para>

<para>
en el sistema remoto, y 
</para>

<para>

<screen>
linecheck linecheck.log 17 19 &#62; /dev/modem &#60; /dev/modem
</screen>

</para>

<para>
en el sistema local. Esto evitará tus caracteres de <emphasis remap="it">xon/xoff</emphasis>
(control de flujo), que colgarán tu línea si tienes control de flujo por
software. Si soluciona los problemas de cuelgues, tendrás que
escapar/ignorar 17/19 en ambos <literal remap="tt">termrc</literal>. Si tu servidor de terminal
tiene otros caracteres que lo cuelguen, prueba a correr <literal remap="tt">lineckeck</literal> con
esos caracteres escapados como el ejemplo de arriba. Puedes marcar esos
caracteres si <literal remap="tt">linecheck</literal> se cuelga.  Si es este el caso, mátalo, y
luego mira en los logs. Los últimos caracteres transmitidos es probable
que sean los culpables. Vuelve a intentarlo escapando estos caracteres. 
</para>

<para>
En resumen, mi <literal remap="tt">termrc</literal> local tiene las líneas:
</para>

<para>

<screen>
escape 29
escape 157
</screen>

</para>

<para>
y mi <literal remap="tt">termrc</literal> remoto tiene las líneas:
</para>

<para>

<screen>
ignore 29
ignore 157
</screen>

</para>

<para>
ya que mi <literal remap="tt">linecheck.log</literal> remoto decía que 'escape 29 y 157'.
</para>

</sect2>

<sect2>
<title>Prueba a correr el <literal remap="tt">TERM</literal> </title>

<para>
 
</para>

<para>
Accede a tu sistema remoto, haciendo el enlace lo más transparente posible
(si no lo has hecho aún).  Arranca <literal remap="tt">term</literal> en el extremo remoto. Yo
lo hago así: 
</para>

<para>

<screen>
 
exec term -r -l $HOME/tlog -s 38400 -c off -w 10 -t 150
</screen>
 
</para>

<para>
Vamos a desgranar las opciones una por una (ten en cuenta que con igual
facilidad podría poner estas opciones en mi <literal remap="tt">termrc</literal>. Lo hice así
porque evitaba tener que editar un fichero mientras ponía a punto el
<literal remap="tt">term</literal>).
</para>

<para>
<literal remap="tt">exec</literal> implica destruir la <emphasis remap="it">shell</emphasis> actual, corriendo en su lugar
el programa indicado. Ejecuto las cosas con <literal remap="tt">exec</literal> porque no pretendo
usar mi <emphasis remap="it">shell</emphasis> de login de nuevo; estaría desperdiciando memoria. Si
estás depurando el enlace y eres capaz de abortar el <literal remap="tt">term</literal> remoto,
puede que no quieras hacer el <literal remap="tt">exec</literal>.
</para>

<para>
La opción <literal remap="tt">-r</literal> es necesaria sólo en un extremo. <literal remap="tt">term</literal> verá a
este extremo como el remoto de la conexión (ten en cuenta que el extremo
remoto del <literal remap="tt">term</literal> puede ser tu propia máquina local). Si no usas
esta opción en un extremo los clientes de <literal remap="tt">term</literal> se caerán
espontáneamente. 
</para>

<para>
<literal remap="tt">-l $HOME/tlog</literal>. Esto registra los errores en el fichero
<literal remap="tt">tlog</literal> en mi directorio <emphasis remap="it">home</emphasis>. Muy útil para depurar. No hay razón
para no ponerlo. 
</para>

<para>
<literal remap="tt">-s 38400</literal> : Tengo un módem 14400, con compresión. Para ratios de
compresión óptimos, necesito poder mandar bits al <emphasis remap="it">pipe</emphasis> lo más rápido
posible. Para un módem más lento, debería ser un número menor. Fíjate que
si tienes una <emphasis remap="it">UART</emphasis> 16450 en tu puerto serie, las velocidades altas
pueden provocar pérdida de datos por desbordamiento del chip de tu puerto
serie.  <literal remap="tt">term</literal> se recuperará de esto, pero si ves muchos mensajes
en tu log, (o recibes <emphasis remap="it">``overrun warnings''</emphasis> en versiones del kernel
<literal remap="tt">0.99pl15</literal> en adelante) necesitarás reducir este número. 
</para>

<para>
<literal remap="tt">-c off</literal> : Desactiva la compresión de datos. Tengo un módem con
compresión, y no necesito comprimir las cosas dos veces.
</para>

<para>
<literal remap="tt">-w 10 -t 150</literal> : De nuevo estas son opciones para optimizar mi
enlace de módem rápido. Pongo mi <emphasis remap="it">ventana</emphasis> a 10 y mi <emphasis remap="it">timeout</emphasis> a 150.
Esto lo hago de acuerdo con la recomendación de la página de manual de
<literal remap="tt">term_setup</literal>. 
</para>

<para>
Vuelve sobre tu máquina local y suspende tu programa de comunicaciones
(<literal remap="tt">&circ;Z</literal> en <literal remap="tt">kermit</literal>). No querrás que esté corriendo a la vez que
<literal remap="tt">term</literal>, ya que lucharía con el <literal remap="tt">term</literal> por el puerto serie.
Si puedes convencer a tu módem de que no cuelgue cuando salgas de tu
programa de comunicaciones (cuando cambia el <literal remap="tt">DTR</literal>), podrías salir del
programa en este punto.
</para>

<para>
Ahora lanza el <literal remap="tt">term</literal> local. Yo uso:  
</para>

<para>

<screen>
 
term -c off -l $HOME/tlog -s 38400 -w 10 -t 150 &#60; /dev/modem &#62; /dev/modem &#38;
</screen>

</para>

<para>
Necesito decirle al <literal remap="tt">term</literal> donde está el módem; Así que apunto
tanto la entrada como la salida estándar a <literal remap="tt">/dev/modem</literal> (eso es lo
que hacen <literal remap="tt">&lt;</literal> y <literal remap="tt">&gt;</literal>).  También lo hago correr en
<emphasis remap="it">background</emphasis>; de modo que puedo usar esta consola para otra cosa si la
necesito. 
</para>

<para>
<literal remap="tt">term</literal> debería de funcionar ya <literal remap="tt">:-)</literal>. Prueba con <literal remap="tt">trsh</literal>,
a ver qué pasa. Si se cuelga, o el enlace parece lento, echa una ojeada a
tu <literal remap="tt">tlog</literal> en ambos extremos. ¿Tienes <emphasis remap="it">timeouts</emphasis> o mensajes de error?
Si es así, entonces es que has configurado algo mal. Vuélvelo a intentar
(después de que hayas terminado de leer esto <literal remap="tt">:-)</literal>. Observa que la
conexión no parecerá muy rápida, especialmente si usas compresión - será
un poco a saltos. La velocidad real aparece durante transmisiones de
ficheros y similares.
</para>

</sect2>

<sect2>
<title>Terminar tu conexión <literal remap="tt">term</literal> </title>

<para>
 
</para>

<para>
Muy probablemente, una vez que hayas hecho un montón de trabajo usando el
<literal remap="tt">term</literal>, querrás terminar el trabajo y deshacer tu conexión
<literal remap="tt">term</literal>. Para poder hacer esto hay cuatro formas: 
</para>

<para>

<orderedlist>
<listitem>

<para>
Matar (<literal remap="tt">kill</literal>) los programas <literal remap="tt">term</literal> a ambos lados de la
conexión. Esta es la forma menos recomendada de terminar tu conexión.
</para>
</listitem>
<listitem>

<para>
Una forma mejor es ejecutar el siguiente comando localmente:


<screen>
   echo '00000' &#62; /dev/modem
</screen>


Esto terminará la conexión <literal remap="tt">term</literal> correctamente. Funcionará en
todas las versiones del <literal remap="tt">term</literal>. Hay que asegurarse de que la
secuencia contiene al menos cinco ceros. 

</para>
</listitem>
<listitem>

<para>
En el <literal remap="tt">termrc</literal> de versiones 2.0.0 y superiores se puede incluir
una sentencia <literal remap="tt">terminate &lt;cualquier cadena&gt;</literal>. Esto establece
una cadena que hará que salga del <literal remap="tt">term</literal> (``<literal remap="tt">00000</literal>'' por
defecto). Debe ser de una longitud de 5 caracteres por lo menos, para
evitar terminaciones accidentales. 

</para>
</listitem>
<listitem>

<para>
A partir de la versión 1.14 existe el programa <literal remap="tt">tshutdown</literal>
(realmente para la versión 1.14 está disponible como <emphasis remap="it">patch</emphasis>, para
versiones más recientes se incluye en el paquete). Ejecutando
<literal remap="tt">tshutdown</literal>, la conexión <literal remap="tt">term</literal> finalizará perfectamente. 

</para>
</listitem>

</orderedlist>

</para>

</sect2>

<sect2>
<title>Cómo eliminar <literal remap="tt">TERM</literal> de tus particiones.</title>

<para>
Ok, me habéis preguntado por esto. Así que voy a presentar los pasos a
seguir para desinstalar <literal remap="tt">term</literal>:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Eliminar directorios con su contenido. Dependiendo de cómo hayas
instalado <literal remap="tt">term</literal>, tendrás uno o más de los siguientes directorios:


<screen>
$HOME/.term/termrc
$HOME/.term/termrc.&#60;servidor&#62;
$HOME/term/termrc
$HOME/term/termrc.&#60;servidor&#62;
/usr/local/lib/term/termrc
/usr/local/lib/term/termrc.&#60;servidor&#62;
/etc/termrc
/etc/termrc.&#60;servidor&#62;
</screen>


Estos directorios pueden eliminarse con su contenido, usando 


<screen>
/bin/rm -rf 
</screen>


</para>
</listitem>
<listitem>

<para>
El grupo <emphasis remap="it">term</emphasis>. En algún momento de la instalación tuviste que
crear un grupo llamado <emphasis remap="it">term</emphasis>. Busca en <literal remap="tt">/etc/group</literal> una línea
con ese grupo y bórrala. 

</para>
</listitem>
<listitem>

<para>
Los ejecutables y paquetes del <literal remap="tt">term</literal>. Esta es la parte más
difícil. Para los ejecutables, busca en el directorio
<literal remap="tt">/usr/local/bin</literal> o <literal remap="tt">$HOME/bin</literal>. 

Con otros ejecutables que hiciste compatibles con <literal remap="tt">term</literal> no puedo
ayudarte. Necesitas saber qué ejecutables modificaste para saber cuáles
borrar. No olvides ficheros de configuración y otros que vengan con esos
ejecutables. 

</para>
</listitem>
<listitem>

<para>
Ficheros de librería. Lo mejor es teclear lo siguiente:


<screen>
cd /
find . -name libtermnet* -exec /bin/rm {} \;
</screen>


Esto encontrará y borrará todos los ficheros de librería relacionados
por todo tu disco duro.

</para>
</listitem>
<listitem>

<para>
Ficheros <literal remap="tt">include</literal>. De nuevo, lo mejor es que teclees esto:


<screen>
cd /
find . -name termnet.h -exec /bin/rm {} \;
</screen>


</para>
</listitem>
<listitem>

<para>
Manuales en línea. Cuando instalaste <literal remap="tt">term</literal> los manuales
se colocaron en uno de los directorios siguientes:


<screen>
/usr/local/man/man1
/usr/local/man/cat1
$HOME/man/man1
$HOME/man/cat1
</screen>


Debes buscar por lo menos las siguientes páginas de manual:  <literal remap="tt">term,
term_clients, term_setup, tdownload, linecheck, trdate, trdated, termrc,
termtest, tmon, tredir, trsh, tshutdown, tudpredir, tupload,
txconnand</literal> y por último, <literal remap="tt">tiptest</literal>. 

</para>
</listitem>
<listitem>

<para>
Directorio temporal del usuario. Borra el directorio
<literal remap="tt">/usr/tmp/private</literal> y sus contenidos. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
Después de todo este ejercicio, podrás estar bastante seguro de que
has borrado todo lo relacionado con <literal remap="tt">term</literal>.
</para>

</sect2>

<sect2 id="optimizando">
<title>Optimización de la conexión </title>

<para>
 
</para>

<para>
Una vez que consigues ejecutar el <literal remap="tt">term</literal>, puede que quieras intentar
optimizar las cosas. Una buena forma de medir la velocidad de tu enlace es
corriendo <literal remap="tt">tmon</literal> en una ventana mientras transfieres un fichero en
otra. Intenta con ficheros de texto y ficheros comprimidos suficientemente
grandes; el texto a secas debería dar un factor del doble de rápido que el
comprimido. Los parámetros que querrás ajustar son <literal remap="tt">baudrate</literal>
&lsqb;velocidad del puerto&rsqb;  (<literal remap="tt">-s</literal>), <literal remap="tt">compression</literal>
(<literal remap="tt">-c</literal>), <literal remap="tt">windows</literal> &lsqb;tamaño de ventana&rsqb;  (<literal remap="tt">-w</literal>),
<literal remap="tt">timeout</literal> &lsqb;tiempo de espera&rsqb; (<literal remap="tt">-t</literal>) y <literal remap="tt">retrain</literal>
(<literal remap="tt">-A</literal>). 
</para>

<para>
Cuidado con el parámetro <literal remap="tt">retrain</literal>. Con la versión 1.19 del
<literal remap="tt">term</literal> obtengo peor rendimiento, que va de un 80% a un 90%
comparado con la ejecución del <literal remap="tt">term</literal> sin el parámetro
<literal remap="tt">retrain</literal>. No está claro si se trata de un <emphasis remap="it">bug</emphasis> en la versión 1.19
y si este problema existe sólo en la versión 1.19 del <literal remap="tt">term</literal>. 
</para>

<para>
<literal remap="tt">Baudrate</literal>: el número máximo de bits por segundo que el
<literal remap="tt">term</literal> intentará enviar a través del enlace serie. <literal remap="tt">term</literal>
evitará enviar caracteres a una velocidad superior a ésta. Por defecto se
usa la velocidad del puerto serie del ordenador, pero hay que avisar 
que ésta puede ser demasiado alta si el módem funciona a una velocidad
menor sobre la línea telefónica. La opción <literal remap="tt">baudrate</literal> está indicada
para sistemas que almacenan en <emphasis remap="it">buffer</emphasis> la salida al módem. Durante la
configuración y el ajuste es mejor usar un <literal remap="tt">baudrate</literal> pequeño que uno
que sea demasiado grande. Para enlaces de alta velocidad (&gt; 38400),
ponerlo sin límite será probablemente ventajoso. Esto se consigue usando
el valor <emphasis remap="it">off</emphasis>. <literal remap="tt">term</literal> confiará entonces solamente en el kernel
para controlar el flujo.
</para>

<para>
<literal remap="tt">Compression</literal>: necesitarás poner en <emphasis remap="it">on</emphasis> si no tienes un módem
con compresión. Si tienes un módem de éstos, pon <emphasis remap="it">compression off</emphasis>, de
lo contrario estarás comprimiendo las cosas dos veces, lo que
habitualmente <emphasis remap="it">incrementa</emphasis> la cantidad de datos transmitidos. Los
módems con compresión son aquellos que usan los protocolos <emphasis remap="it">MNP-5</emphasis> o
<emphasis remap="it">V42.bis</emphasis>. Observa la documentación del módem y el mensaje del módem
cuando conecta. 
</para>

<para>
<literal remap="tt">Windows</literal>: este es el número de unidades de datos, o paquetes, que
el <literal remap="tt">term</literal> enviará por la línea antes de obtener reconocimiento
(<emphasis remap="it">ack</emphasis>) desde el <literal remap="tt">term</literal> remoto. Para módems rápidos, aumentar
esto puede ser una mejora; para enlaces más lentos esto puede saturar el
extremo remoto.
</para>

<para>
<literal remap="tt">Timeout</literal>: el tiempo que el <literal remap="tt">term</literal> esperará a un <emphasis remap="it">ack</emphasis>.
Si has aumentado <literal remap="tt">windows</literal> y estás teniendo <literal remap="tt">timeouts</literal> en el fichero
de log, prueba a aumentar este valor. 
</para>

<para>
Para un <emphasis remap="it">14400/V42.bis</emphasis>, yo uso <literal remap="tt">-c off -w 10 -t 150</literal>. Consigo
unos 1700 <emphasis remap="it">cps</emphasis> en ficheros comprimidos y 3500 <emphasis remap="it">cps</emphasis> en ficheros
ASCII usando <literal remap="tt">tupload</literal>.
</para>

</sect2>

<sect2>
<title>Resolución de problemas</title>

<para>
En esta sección se dan algunas opiniones sobre qué comprobar cuando se
tienen problemas ejecutando el <literal remap="tt">term</literal> o alguno de sus clientes.
</para>

<para>

<itemizedlist>
<listitem>

<para>
¿Has borrado la estructura de directorios del <literal remap="tt">term</literal>? En las
nuevas versiones del term ha cambiado un par de veces la estructura del
árbol de directorios bajo <literal remap="tt">/usr/local/lib/term</literal>. Si no te has dado
cuenta de ello, puedes haber causado todo tipo de mensajes de error.  Lo
mejor es borrar el árbol de directorios bajo <literal remap="tt">/usr/local/lib/term</literal>
(salvando tu <literal remap="tt">termrc</literal>) y entonces instalar la nueva versión. De esta
forma evitas pelearte con un árbol de directorios lioso. 

</para>
</listitem>
<listitem>

<para>
¿Borraste los <emphasis remap="it">sockets</emphasis> antiguos? Cuando pongas al día tu versión
del <literal remap="tt">term</literal> borra todos los <emphasis remap="it">sockets</emphasis> (llamados <literal remap="tt">socket=</literal>) creados
por el <literal remap="tt">term</literal>. El no hacer esto puede causar extraños problemas.
Para averiguar qué <emphasis remap="it">socket</emphasis> está atendiendo el <literal remap="tt">term</literal>, puedes
usar el programa <literal remap="tt">netstat</literal>. 

</para>
</listitem>
<listitem>

<para>
 ¿El <literal remap="tt">term</literal> no compila correctamente en SunOS 4.1.3? Has
configurado el <literal remap="tt">term</literal> con <literal remap="tt">./configure --user</literal>. Durante la
compilación estás teniendo un error de ensamblador, relacionado con que el
parámetro <literal remap="tt">-k</literal> no es reconocido.  La razón de este error es
desconocida. La solución es configurar el <literal remap="tt">term</literal> con librerías
estáticas. Es decir, tendrás que hacer <literal remap="tt">./configure --user
--static</literal> y entonces seguir con el proceso de compilación como sueles
hacerlo normalmente. Ahora el <literal remap="tt">term</literal> debería compilar correctamente.

</para>
</listitem>
<listitem>

<para>
¿El <literal remap="tt">termtest</literal> te está presentando el error: 


<screen>
Term: failed to connect to term socket '/root/.term/sockettest'
</screen>


(Term: falla la conexión al socket de <literal remap="tt">term '/root/.term/sockettest'</literal>) 

Cuando <literal remap="tt">termtest</literal> corre espera que el ejecutable <literal remap="tt">term</literal> esté en el
mismo sitio que éste. Cuando haces un <literal remap="tt">make install</literal> antes de ejecutar
<literal remap="tt">termtest</literal>, el binario de <literal remap="tt">TERM</literal> es movido a <literal remap="tt">/usr/local/bin</literal>
(u otro similar). 

Para ello hay que hacer algo parecido a esto:


<screen>
ln -s /usr/local/bin/term /usr/src/term-&#60;numero_de_version&#62;/term
</screen>

</para>
</listitem>
<listitem>

<para>
¿Estás usando el binario adecuado? El <literal remap="tt">term</literal> se ha modificado
bastante, y muchos sistemas tienen versiones diferentes de los programas
rondando por ellos. Asegúrate de que estás usando la versión correcta.
Esto también se aplica al <literal remap="tt">linecheck</literal>. Puede usarse una orden del tipo
<literal remap="tt">bash -a</literal>, o el comando <literal remap="tt">whereis</literal> para saber qué programa se está
ejecutando. Las versiones de <literal remap="tt">term</literal> posteriores a 1.11 deberían
mostrar su número de versión al comenzar. (Aunque la versión 1.14 dice ser
la 1.12. Sigh.) 

</para>
</listitem>
<listitem>

<para>
¿Tienes el <literal remap="tt">termrc</literal> correcto en el lugar adecuado? Dependiendo de
la versión de <literal remap="tt">term</literal> que estés corriendo y el modo en que
instalaste el <literal remap="tt">term</literal> (siendo <literal remap="tt">root</literal> o usuario) este fichero debe
estar en uno de los siguientes directorios: 


<screen>
   /usr/local/lib/term/termrc
   /usr/local/lib/term/termrc.&#60;servidor&#62;
   /etc/termrc
   /etc/termrc.&#60;servidor&#62;
</screen>
  

Algunos sistemas tienen <literal remap="tt">termrc</literal>'s preinstalados; asegúrate de que no
estén antes de instalar. Si estás ejecutando cosas como <literal remap="tt">root</literal>, busca
en <literal remap="tt">/.term</literal>. 

El <literal remap="tt">term</literal> crea ficheros (<emphasis remap="it">sockets</emphasis> en realidad) mientras se
ejecuta;  de modo que tiene su propio directorio, <literal remap="tt">&tilde;/.term</literal>,
donde está el fichero <literal remap="tt">termrc</literal> (nótese, ¡no hay un punto precediendo a
<literal remap="tt">termrc</literal>!). 

</para>
</listitem>
<listitem>

<para>
¿Encuentra el <literal remap="tt">term</literal> su fichero <literal remap="tt">termrc</literal>? Cuando inicias
<literal remap="tt">term</literal> a ambos lados, deberías ver mensajes como este de abajo: 


<screen>
   Term version: 2.2.9
   Reading file:  /usr/local/lib/term/termrc
   Using shared mode.
</screen>


Cuando falta la segunda línea el <literal remap="tt">term</literal> no puede encontrar su
fichero <literal remap="tt">termrc</literal> y sabes que algo ha ido mal durante la instalación (a no
ser que no estés usando el fichero <literal remap="tt">termrc</literal> y estés introduciendo todas
las opciones en línea de comandos <literal remap="tt">:-)</literal>. Comprueba la localización y
los permisos del fichero <literal remap="tt">termrc</literal> en el lugar donde <literal remap="tt">term</literal> no
puede encontrar su fichero <literal remap="tt">termrc</literal>.
</para>
</listitem>
<listitem>

<para>
¿Es correcta la sintaxis de las entradas en el <literal remap="tt">termrc</literal>? Un
problema común es que la gente que necesite usar el escape e ignorar
ciertos caracteres, los introduzca así en el fichero <literal remap="tt">termrc</literal>: 


<screen>
escape 1,4,30,255
ignore 1,4,30,255
</screen>


Aunque si <literal remap="tt">term</literal> no reconoce lo anterior tampoco avisará de
ello. Simplemente lo ignorará.

Cuando tienes que ignorar o ``escapar'' caracteres, tendrás que ponerlos
en diferentes líneas del fichero <literal remap="tt">termrc</literal>, cada línea comenzando por la
palabra <literal remap="tt">escape</literal> o <literal remap="tt">ignore</literal>. Sólo cuando haya que hacerlo
con varios caracteres deberá hacerse de la siguiente forma: 


<screen>
escape 16-19      # escapar caracteres 16, 17, 18, 19
escape 23         # 23
escape 255        # ...y 255
ignore 16-19      # ignorar caracteres 16, 17, 18, 19
ignore 23         # 23
ignore 255        # ...y 255
</screen>


</para>
</listitem>
<listitem>

<para>
¿Está montado tu directorio <literal remap="tt">term</literal> o <literal remap="tt">.term</literal> con <emphasis remap="it">NFS</emphasis>? Si
tu directorio <literal remap="tt">term</literal> o <literal remap="tt">.term</literal> está montado con <emphasis remap="it">NFS</emphasis> necesitas
poner el parámetro <literal remap="tt">-DTERM_NFS_DIR</literal> en la línea
<literal remap="tt">CFLAGS</literal> del <literal remap="tt">Makefile</literal>. Aunque, al autor el usar este parámetro
le produce un error de compilación al compilar <literal remap="tt">term</literal> 1.19 en una
máquina con <emphasis remap="it">SunOS 4.*</emphasis>. 

</para>
</listitem>
<listitem>

<para>
¿Pertenecen los ficheros y directorios al usuario y grupo correcto y
tienen los permisos adecuados? Esto no debería ser problema ya que estos
permisos se ponen durante la fase de instalación. Sin embargo, cuando
portas tus propios programas a <literal remap="tt">term</literal> debes prevenirte de ello.
También cuando se cambia el modo en que esta trabajando <literal remap="tt">term</literal> (por
ejemplo de modo privado a modo shared) deben adaptarse las propiedades y
permisos de ficheros y directorios. 

</para>
</listitem>
<listitem>

<para>
¿Estás obteniendo el error <literal remap="tt">gethostbyname: &lt;hostname&gt;:
Non-authoritative `host not found', o `server failed'</literal>?

Para resolver esto tienes que chequear las siguientes cosas:


<orderedlist>
<listitem>

<para>
¿Está configurado correctamente el fichero <literal remap="tt">/etc/hosts</literal>? 
<literal remap="tt">&lt;hostname&gt;</literal> no es el nombre de tu host (las versiones viejas de SLS y
algunas viejas y nuevas versiones Slackware se entregan con el
<literal remap="tt">hostname</literal> <emphasis remap="it">darkstar</emphasis>, por ejemplo). Cambia esto en el fichero. Debe
contener al menos una línea como la que sigue (el formato se describe
encima de ella): 


<screen>
# Formato del fichero:
#  IP_NUMBER            HOSTNAME        ALIASES
#
# Este es el nombre de tu maquina, en primer lugar, seguido de aliases
#
127.0.0.1       localhost       linuxpc.dominio  linuxpc
</screen>


Cuando tu única conexión con el exterior se hace mediante <literal remap="tt">term</literal>,
la línea anterior es la única que debe aparecer en <literal remap="tt">/etc/hosts</literal>. No
pongas otros nodos de Internet en ese fichero, pues <literal remap="tt">term</literal> no
trabajará con ellos. 

</para>
</listitem>
<listitem>

<para>
¿Puede leer todo el mundo tus ficheros <literal remap="tt">/etc/rc*</literal> y
<literal remap="tt">/etc/resolv.conf</literal>? 


<screen>
chmod ugo+r
</screen>


</para>
</listitem>
<listitem>

<para>
Por último, asegúrate de haber instalado el <emphasis remap="it">loopback-interface</emphasis>
de <emphasis remap="it">TCP/IP</emphasis> en tu máquina. Puedes comprobarlo ejecutando el comando
<literal remap="tt">ifconfig</literal>. Cuando está instalado dicho interface, se verá lo siguiente
en pantalla: 


<screen>
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Bcast:127.255.255.255  Mask:255.255.255.0
          UP BROADCAST LOOPBACK RUNNING  MTU:2000  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0
          TX packets:4984 errors:0 dropped:0 overruns:0
</screen>


Durante el arranque también puedes ver qué protocolos se utilizan. En
mi máquina aparece lo siguiente:


<screen>
IP Protocols: ICMP, UDP, TCP
</screen>


Para más información sobre cómo instalar el <emphasis remap="it">loopback-interface</emphasis>, léete
el <emphasis remap="it">NET-HOWTO</emphasis>.

</para>
</listitem>

</orderedlist>


</para>
</listitem>
<listitem>

<para>
¿Estás obteniendo todo tipo de mensajes <literal remap="tt">timed out</literal> en tus
ficheros log de <literal remap="tt">term</literal>? Esto significa que tu conexión de
<literal remap="tt">term</literal> no está optimizada. Un pequeño número de esos mensajes nunca
es problema. Estos son debidos muy posiblemente a que los factores
temporales influyen en la conexión física entre tus <emphasis remap="it">hosts</emphasis> remoto y
local. 

Cuando tienes un montón de estos mensajes todo el tiempo, tu conexión se
ralentizará considerablemente. Tienes que ajustar los parámetros
mencionados en la anterior sección <xref linkend="optimizando"/>. Además, esta
parte de la instalación es un proceso de prueba y error. No se pueden dar
unas reglas fijas sobre los valores a colocar en los variados parámetros
ya que son muchos los factores que influyen en la conexión.  Estos
factores difieren entre las conexiones e incluso en el tiempo. 


</para>
</listitem>
<listitem>

<para>
¿No te funcionan los <literal remap="tt">ftp</literal> con puertos redirigidos? Es un
problema habitual con <literal remap="tt">ftp</literal>, que necesita trabajar con los puertos 20 y
21. La única solución es usar una versión <literal remap="tt">TERM</literal>ificada de <literal remap="tt">ftp</literal>
o <literal remap="tt">ncftp</literal>. Sin embargo, algunas de estas aplicaciones adaptadas tampoco
funcionarán. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

</sect1>

<sect1>
<title>Clientes <literal remap="tt">TERM</literal> </title>

<para>
 
</para>

<para>
<literal remap="tt">Term</literal> proporciona varios clientes por defecto. Esto incluye
<literal remap="tt">trsh</literal>, <literal remap="tt">tmon</literal>, <literal remap="tt">tupload</literal>, <literal remap="tt">tredir</literal>,
<literal remap="tt">txconn</literal> y en nuevas versiones <literal remap="tt">trdate</literal>, <literal remap="tt">trdated</literal>.
Además, a partir de la versión 2.0.0 está disponible <literal remap="tt">tudpredir</literal> y
desde la versión 2.1.0 también <literal remap="tt">tdownload</literal>.  Esta sección hará
referencia a <literal remap="tt">trsh, tmon, tupload, tdownload, trdate</literal> y
<literal remap="tt">trdated</literal>. El resto tiene su propia sección cada uno.  No
funcionará ningún cliente de <literal remap="tt">term</literal> hasta que se haya establecido
un enlace <literal remap="tt">term</literal>.
</para>

<para>
<literal remap="tt">tmon</literal> es una utilidad simple para monitorizar las estadísticas del
enlace. Imprime un diagrama de tiempo de caracteres transmitidos y
recibidos. Se invoca simplemente como <literal remap="tt">tmon</literal>. Desde la versión 1.11,
<literal remap="tt">tmon</literal> ha tenido un bug que provoca que alguna información se
trunque (??). 
</para>

<para>
<literal remap="tt">trsh</literal> es similar a <literal remap="tt">rsh</literal>. Sin argumentos, genera una shell
interactiva en el sistema remoto (esto es, te introduce directamente en el
sistema remoto). <literal remap="tt">trsh</literal> es uno de las principales maneras de
acceder al extremo remoto del enlace a través de <literal remap="tt">term</literal>. Si se le
pasa un argumento, <literal remap="tt">trsh</literal> ejecuta ese argumento como un comando en
el sistema remoto. Por ejemplo, con <literal remap="tt">trsh ls</literal> se obtendría una lista de
ficheros del directorio <emphasis remap="it">home</emphasis> del sistema remoto.
</para>

<para>
<literal remap="tt">tupload</literal> transfiere un fichero, si se indica como primer
argumento, desde el sistema local al remoto. Por defecto los ficheros se
pondrán en el mismo directorio desde el que se invocó <literal remap="tt">term</literal> en el
otro extremo. Para colocar los ficheros en otro directorio se deben poner
sus nombres como segundo argumento a <literal remap="tt">tupload</literal>. Por ejemplo, si se
desea poner una copia del fichero <literal remap="tt">term114.tar.gz</literal> en <literal remap="tt">/usr/tmp</literal>
en el sistema remoto, se escribiría <literal remap="tt">tupload term114.tar.gz
/usr/tmp</literal>.
</para>

<para>
Cuando se usa <literal remap="tt">tupload</literal> es posible utilizar comodines como en
<literal remap="tt">tupload a.*</literal>.  La shell expande los comodines y llama a
<literal remap="tt">tupload</literal> como <literal remap="tt">tupload a.1 a.2 .....</literal>. 
</para>

<para>
<literal remap="tt">tdownload</literal> transferirá un fichero, si se indica como primer
argumento, desde el sistema remoto al local. Por defecto, los ficheros se
colocarán en el mismo directorio desde el que se invocó al <literal remap="tt">term</literal>
en el lado local. Para colocar los ficheros en otro directorio, hay que
indicar sus nombres como segundo argumento a <literal remap="tt">tdownload</literal>. Por
ejemplo si se quiere poner una copia del fichero <literal remap="tt">term114.tar.gz</literal> en
<literal remap="tt">/usr/tmp</literal> del sistema local, escribiría <literal remap="tt">tdownload
term114.tar.gz /usr/tmp</literal>. 
</para>

<para>
Cuando se usa <literal remap="tt">tdownload</literal> no es posible utilizar comodines como
<literal remap="tt">tdownload a.*.</literal> La razón es que el directorio remoto no está
disponible para la shell local cuando se usa <literal remap="tt">tdownload</literal>; de modo
que la shell local no puede expandir los comodines.
</para>

<para>
<literal remap="tt">trdate</literal> es una utilidad de puesta en hora. Lee la hora en la
máquina remota y pone el reloj local con la hora del remoto. Se debe
ejecutar como <literal remap="tt">root</literal>. 
</para>

<para>
<literal remap="tt">trdated</literal> es la versión demonio de <literal remap="tt">trdate</literal>. Cuando se pone en
marcha en <literal remap="tt">rc.local</literal> se ejecuta como un demonio en cuyo caso ajusta el
tiempo cada 5 minutos (por defecto). Incluso si no existe conexión
<literal remap="tt">term</literal>, este demonio se pondrá en marcha si se coloca en
<literal remap="tt">rc.local</literal>. Una vez que se cree una conexión <literal remap="tt">term</literal>, comenzará a
ajustar la hora.
</para>

</sect1>

<sect1>
<title>X y <literal remap="tt">TERM</literal></title>

<para>
<literal remap="tt">term</literal> permite a los usuarios abrir ventanas X en la máquina local
desde clientes que están corriendo en una máquina de la red. Esto se hace
usando el cliente <literal remap="tt">txconn</literal>. <literal remap="tt">txconn</literal> se ejecuta en el remoto, la
máquina conectada en red; se invoca simplemente como <literal remap="tt">txconn</literal>. Se
coloca en background y devuelve un número a la salida estándard; este
número es el número de <emphasis remap="it">display</emphasis> que los clientes deben usar para
acceder al servidor X de la máquina local. Un ejemplo aclarará ésto. Estoy
accediendo a mi cuenta, vía <literal remap="tt">trsh</literal>, en mi host remoto, llamado
``<literal remap="tt">foo</literal>''. En <literal remap="tt">foo</literal> realizo lo siguiente: 
</para>

<para>

<screen>
foo$ txconn
Xconn bound to screen 10
:10
foo$
</screen>

</para>

<para>
Ahora, para cualquier host en el que quiera correr un cliente X, o sea, 
verlo en el servidor X de mi máquina local, haré:
</para>

<para>

<screen>
setenv DISPLAY foo:10
</screen>

</para>

<para>
(para <literal remap="tt">bash</literal> debería usarse <literal remap="tt">export DISPLAY=foo:10</literal>). En algunos
casos además de eso puede ser necesario hacer un <literal remap="tt">xhost + foo</literal> en la
máquina local. Ahora, cuando arranque el cliente, intentará conectar con la
pantalla 10 de la máquina <literal remap="tt">foo</literal>, pero <literal remap="tt">txconn</literal> estará escuchando en
esa pantalla, y pasará todos los paquetes con protocolo X vía
<literal remap="tt">term</literal> al servidor X en el host local; es decir, la ventana se
abrirá en la máquina local. 
</para>

<para>
Es posible trabajar en el otro sentido - correr un cliente en la máquina
local y tener abierta la ventana en una máquina remota de la red; sin
embargo, retrasaremos esta explicación hasta después de haber comentado
<literal remap="tt">tredir</literal>. 
</para>

<para>
<literal remap="tt">txconn</literal> no es terriblemente seguro; cualquiera puede conectar con el
servidor local vía <literal remap="tt">term</literal> y provocar todo tipo de daños. Si este
tipo de cosas son preocupantes, podría ser una buena idea considerar el
uso de <literal remap="tt">xauth</literal> para autorizar las conexiones. Consulte la página de
manual sobre <literal remap="tt">xauth</literal>. 
</para>

<para>
El protocolo X no es muy eficiente; desperdicia algo de ancho de banda. 
Esto no suele ser un problema en una ethernet, pero puede ser un crimen
vía módem. Se supone que X11R6 presenta una versión de bajo ancho de banda
del protocolo X, <emphasis remap="it">LBX</emphasis>. Si, por el contrario, se está usando X11R5
puede recurrirse a una utilidad llamada <literal remap="tt">sxpc</literal> que comprime el
protocolo X, mejorando la respuesta sobre líneas serie. <literal remap="tt">sxpc</literal> incluye
un texto sobre cómo hacerlo funcionar con <literal remap="tt">term</literal>, y está
recomendado. El paquete <literal remap="tt">sxpc</literal> también explica como usar <literal remap="tt">xauth</literal>;
por lo que está doblemente recomendado. 
</para>

</sect1>

<sect1>
<title><literal remap="tt">tredir</literal> </title>

<para>
 
</para>

<para>
<literal remap="tt">tredir</literal> es una de las utilidades más potentes de <literal remap="tt">term</literal>,
permitiendo que la mayoría de los servicios de red importantes puedan
obtenerse en un enlace <literal remap="tt">term</literal>. Antes de explicar cómo se usa
<literal remap="tt">tredir</literal>, es necesario dar algunas nociones sobre los servicios de
red.
</para>

<para>
Ya se ha hablado antes sobre los servicios de red, pero no se ha dicho
exactamente qué son. Los servicios son justo eso - servicios que
proporciona la red. Ejemplos de servicios incluyen <literal remap="tt">telnet</literal>, que proporciona
logins entre máquinas, el <literal remap="tt">ftp</literal> (<emphasis remap="it">File Transfer Protocol</emphasis>), o
Protocolo de Transferencia de Ficheros, que transfiere ficheros entre
máquinas, y <emphasis remap="it">smtp</emphasis>, el protocolo de transmisión de correo, que se usa
siempre que se envía un correo electrónico.
</para>

<para>
Cada servicio de red tiene un número de puerto asociado a él. El mapeo de
números de puerto con los servicios correspondientes se da en el fichero
<literal remap="tt">/etc/services</literal>. Este fichero debería ser el mismo en todas las
máquinas conectadas a Internet.
</para>

<para>
¿Como se accede a estos servicios? Cada máquina en red corre un demonio
llamado <literal remap="tt">inetd</literal>, el cual escucha los intentos de conexión a los puertos
de red. Estas peticiones pueden llegar tanto desde la red, como desde la
propia máquina. Un servicio de red se obtiene conectando con un puerto
<literal remap="tt">inetd</literal> en particular. Cuando se hace una solicitud de red, <literal remap="tt">inetd</literal>
conoce exactamente qué servicio está implicado, por el número de puerto al
que se hizo la solicitud. Si se configura <literal remap="tt">inetd</literal> para hacerlo,
proporcionará el servicio adecuado a la conexión que lo solicita. La
configuración de <literal remap="tt">inetd</literal> es la que se da en el fichero
<literal remap="tt">/etc/inetd.conf</literal>, que contiene una lista de los servicios que
proporciona <literal remap="tt">inetd</literal>. Para más información vea las páginas de manual de
<literal remap="tt">inetd</literal> e <literal remap="tt">inetd.conf</literal>. 
</para>

<para>
Se puede comunicar directamente con los servicios de red usando
<literal remap="tt">telnet</literal> (nótese bien, no <literal remap="tt">termtelnet</literal>). Por ejemplo, para hablar
con el demonio de <literal remap="tt">sendmail</literal> (o <emphasis remap="it">smtp</emphasis>) en la máquina
<literal remap="tt">nombre_de_máquina;</literal>, se puede hacer un <literal remap="tt">telnet
nombre_de_máquina smtp</literal> , o <literal remap="tt">telnet
nombre_de_máquina 25</literal>, (ya que 25 es el puerto asignado
a <literal remap="tt">smtp</literal> en <literal remap="tt">/etc/services</literal>). Debería obtener una agradable
bienvenida del demonio de la máquina remota. Este es un truco muy útil
para depurar problemas de red y chequear puertos redirigidos con
<literal remap="tt">tredir</literal> (ver abajo). 
</para>

<para>
<literal remap="tt">tredir</literal> funciona de modo similar a <literal remap="tt">inetd</literal>. Funciona en
<emphasis remap="it">background</emphasis> como un demonio, escuchando los puertos de red, esperando
a una petición. Cuando se hace una solicitud de un servicio, en vez de
proporcionar ese servicio, como hace <literal remap="tt">inetd</literal>, <literal remap="tt">tredir</literal> traslada
la solicitud a través del enlace <literal remap="tt">term</literal> hasta el <literal remap="tt">term</literal>
remoto, quien hace la solicitud a la red, devolviendo el resultado de
nuevo por el enlace hasta el cliente local. <literal remap="tt">tredir</literal> puede
trasladar la solicitud a cualquier máquina de la red, pero por defecto la
envía a la máquina al otro extremo del enlace <literal remap="tt">term</literal>.
<literal remap="tt">tredir</literal> ``redirige'' los servicios <literal remap="tt">TCP</literal> (<emphasis remap="it">Transmision Control
Protocol</emphasis>) a través del enlace <literal remap="tt">term</literal>.
</para>

<para>
Un ejemplo lo aclarará. Vamos a redirigir un puerto local al puerto <literal remap="tt">telnet</literal>
de la máquina remota. Para hacer esto pondríamos <literal remap="tt">tredir 2023 23</literal>.
Ahora, cualquiera que conecte al puerto 2023 de la máquina local será
redirigido al puerto 23 (<literal remap="tt">telnet</literal>) de la máquina remota. Aquí va una
sesión de ejemplo; la máquina local es <literal remap="tt">mimaquina.modem.casa</literal> y la
remota es <literal remap="tt">netsun</literal>. 
</para>

<para>

<screen>
$ tredir 2023 23
Redirecting 2023 to 23
$ telnet localhost 2023
Trying 127.0.0.1...
Connected to mimaquina.modem.casa
Escape character is '^]'.


SunOS UNIX (netsun)
login:
</screen>

</para>

<para>
Este ejemplo es realmente muy útil. Si en su lugar hiciera el
<literal remap="tt">tredir</literal> sobre <literal remap="tt">netsun</literal>, entonces podría hacer <literal remap="tt">telnet</literal> a
<literal remap="tt">mimaquina</literal> desde la red simplemente conectándome al puerto redirigido
de la máquina en red (usando <literal remap="tt">telnet</literal>) - esto es, <literal remap="tt">telnet netsun
2023</literal>.
</para>

<para>
El principio general de uso del <literal remap="tt">tredir</literal> es redirigir el servicio
deseado a una máquina de la red. El siguiente ejemplo nos permitirá leer
las News en la máquina local a través del enlace <literal remap="tt">term</literal> desde un
servidor de News de la red. Las News las proporciona el servicio
<literal remap="tt">nntp</literal>, puerto 119. Todos los lectores de News decentes permiten
especificar qué puerto van a utilizar, ya sea en un fichero de
configuración o en una variable de entorno. Vamos a especificar que el
puerto local sea el 2119.  Ahora supongamos que el servidor de News es
<literal remap="tt">news.domain.org</literal>; entonces le diremos al software de lectura de News
que el servidor <literal remap="tt">nntp</literal> se encuentra en el puerto 2119 del <emphasis remap="it">host</emphasis>
local. Como esto dependerá del lector de News que se use, probaremos el
enlace con <literal remap="tt">telnet</literal> en lugar de ejecutar un lector de News:
</para>

<para>

<screen>
$ tredir 2119 news.domain.org:119
Redirecting 2119 to news.domain.org:119
$ telnet localhost 2119
Trying 127.0.0.1...
Connected to mimaquina.modem.casa.
Escape character is '^]'.
200 news.domain.org InterNetNews NNRP server INN 1.4 07-Dec-41 ready
(posting ok).
</screen>

</para>

<para>
Si ha podido llegar tan lejos, todo lo que tiene que hacer es configurar
su lector de News para poder leer las News desde casa vía <literal remap="tt">term</literal>. 
(nótese bien, si lee las News de este modo, asegúrese de que en todos los
mensajes que deje ponga una cabecera <literal remap="tt">Reply-To:</literal> a una dirección de
correo en la que pueda ser localizado, o de lo contrario la gente que
quiera ponerse en contacto con Ud. mandará el correo a cualquier dato que
su lector de News ponga en la cabecera <literal remap="tt">From:</literal>).
</para>

<sect2>
<title>¡<literal remap="tt">tredir</literal> puede morder!</title>

<para>
El astuto lector, tras leer el último ejemplo se preguntará porqué se
redirigió en puerto 2119 al puerto 119 --ya que el puerto por defecto de
los lectores de News es el 119--, ¿porqué no podría hacer un <literal remap="tt">tredir
119 news.domain.org:119</literal> y evitar la configuración del lector de News?
La respuesta es que todos los puertos con números inferiores a 1024 son
``puertos reservados'', y únicamente el superusuario puede escucharlos. Si
se desea tomar un riesgo en seguridad y hacer de <literal remap="tt">tredir</literal> un programa
<emphasis remap="it">suid</emphasis>, o ejecutar <literal remap="tt">tredir</literal> como <literal remap="tt">root</literal>, entonces se pueden
redirigir puertos reservados y evitar así la molestia de renombrar
servicios. 
</para>

<para>
Otro problema de usar los puertos reservados es que <literal remap="tt">inetd</literal> a menudo ya
está escuchando en esos puertos, y solamente un programa puede escuchar un
puerto a la vez. Si se quiere usar tal puerto, se debe cambiar
<literal remap="tt">inetd.conf</literal> de modo que <literal remap="tt">inetd</literal> ya no escuche en ese puerto que se
quiere redirigir.  Esto se hace fácilmente comentando la línea
correspondiente al servicio poniendo el carácter <literal remap="tt">#</literal> al comienzo de
la misma. El superusuario tiene que mandar una señal <literal remap="tt">HUP</literal> a
<literal remap="tt">inetd</literal> (<literal remap="tt">kill -1 &lt;inetd-pid&gt;</literal>) 
para hacer que vuelva a leer su configuración. 
</para>

</sect2>

<sect2>
<title>Trucos tontos de <literal remap="tt">tredir</literal></title>

<para>
En esta sección describiremos algunos de los usos más comunes de
<literal remap="tt">tredir</literal>. Ya hemos descrito como redirigir los servicios <literal remap="tt">nntp</literal> y
<literal remap="tt">telnet</literal>; Ahora daremos algunos ejemplos más complicados. 
</para>

<sect3>
<title>X window</title>

<para>
En una sección previa, se describió como hacer que un cliente X que corre
en la red abra una ventana en la máquina de casa usando <literal remap="tt">txconn</literal>. 
La misma técnica se podría usar en la máquina de casa para mostrar un
cliente en la máquina del lado remoto del enlace <literal remap="tt">term</literal>. ¿Pero cómo
puede uno ver un cliente X en una máquina de red que no es el extremo
remoto? La respuesta se basa en conocer que X usa un servicio de red
concreto igual que los otros programas que hemos explicado. Un servidor X
escucha peticiones de red en un puerto cuyo número viene dado por la
fórmula: <emphasis remap="it">puerto = 6000 + número de display</emphasis>, p.ej. un servidor X
manejando la pantalla 0 en una máquina escucharía el puerto 6000, si
estuviéramos manejando la pantalla 2, escucharía el puerto 6002. Si se
pone la variable de entorno <literal remap="tt">DISPLAY</literal> en maquinaX:n, los clientes X
tratarán de conectar con el puerto <literal remap="tt"
>6000+n</literal
> de maquinaX.
</para>

<para>
Podemos usar esto para trucar los clientes X de la máquina local y abrir
ventanas en displays remotos. Supongamos que quiero abrir un
<literal remap="tt">xterm</literal>, corriendo en mi máquina local, en el display 0 de la
máquina maquinaX, que esta corriendo en algún lugar de la red. Primero
escogeré un número de display local, digamos que el 2 (no se usa el 0, ya
que es el que estará usando el servidor X local). Mapearé este display al
display 0 de maquinaX.  En término de puertos, esto significa que quiero
redirigir el puerto local 6002 al puerto remoto 6000. Haré lo siguiente: 
</para>

<para>

<screen>
$ tredir 6002 xmachine:6000 
$ setenv DISPLAY localhost:2
$ xterm 
</screen>

</para>

<para>
Esto debería abrir un <literal remap="tt">xterm</literal> en la máquina maquinaX. Observe que
he puesto el <literal remap="tt">DISPLAY</literal> a <literal remap="tt">localhost:2</literal>. Esto es porque los
clientes X usan a veces <emphasis remap="it">sockets</emphasis> de dominio unix en lugar de
<emphasis remap="it">sockets</emphasis> de dominio Internet, a su propio criterio, cuando conectan con
un display local, si <literal remap="tt">DISPLAY</literal> se pone a <literal remap="tt">:2</literal>.
<literal remap="tt">localhost:2</literal> indica que use una conexión <literal remap="tt">TCP</literal>.
</para>

<para>
Observe que en lo que concierne a maquinaX, la solicitud X viene de la
máquina del extremo remoto del enlace <literal remap="tt">term (máquinaremota)</literal> - de modo
que si necesita autorizar la conexión, debería hacer bien <literal remap="tt">xhost +
máquinaremota</literal> en maquinaX, o bien usar <literal remap="tt">xauth</literal> para actualizar el
fichero <literal remap="tt">.Xauthority</literal> en su máquina local para el display número 2,
usando la clave de maquinaX.
</para>

<para>
De nuevo, para acelerar las conexiones X, se puede usar el programa
<literal remap="tt">sxpc</literal>, que incluye una explicación sobre cómo usar <literal remap="tt">tredir</literal>
para establecer el enlace y autorizarlo usando <literal remap="tt">xauth</literal>.
</para>

</sect3>

<sect3>
<title>Correo con <literal remap="tt">TERM</literal></title>

<para>
Está bien, vosotros lo pedísteis. El correo electrónico tiene la
justificada reputación de ser una de las cosas más dificiles de hacer
funcionar bien en un sistema UNIX. Para conseguir que el <literal remap="tt">term</literal>
funcione correctamente con el correo es preciso entender cómo funciona el
correo, lo cual va más allá del objetivo de este documento.
</para>

<para>
Para aprender más sobre correo, debería consultar un libro de
administración de sistemas UNIX y/o la FAQ de la conferencia
<literal remap="tt">comp.mail.misc</literal>, disponible en el <literal remap="tt">ftp</literal> anónimo de
<literal remap="tt"><ulink
url="ftp://rtfm.mit.edu/pub/usenet/comp.mail.misc"
>ftp://rtfm.mit.edu/pub/usenet/comp.mail.misc</ulink
></literal>.
</para>

<para>
También tiene a su disposición 2 paquetes en el <literal remap="tt">ftp</literal> anónimo de
<literal remap="tt">sunsite.unc.edu</literal> que le ayudarán a poner en marcha el correo bajo
<literal remap="tt">term</literal> - son <literal remap="tt">term.mailerd+smail</literal> de Byron A. Jeff y
<literal remap="tt">BCRMailHandlerXXX</literal> de Bill C. Riemers. 
</para>

<para>
Como se ha dicho, haremos una breve descripción de como funciona el correo
electrónico. Hay dos partes que hacen funcionar el correo, el envío de
mensajes y la recepción de los mismos. Comenzaremos con el envío de
mensajes desde su ordenador local a la red. 
</para>

<para>
Hay dos clases de programas de correo. El primero es el <emphasis remap="it">Agente de
Correo de Usuario</emphasis> (<emphasis remap="it">MUA - Mail User Agent</emphasis>). Los <emphasis remap="it">MUA</emphasis>s ayudan a
leer, componer y mandar mensajes. Ejemplos de <emphasis remap="it">MUA</emphasis>s son el
<literal remap="tt">elm</literal>, <literal remap="tt">pine</literal>, <literal remap="tt">mail</literal> y <literal remap="tt">vm</literal>. Los <emphasis remap="it">MUA</emphasis>s no
usan para nada la red; solamente agrupan los mensajes - el trabajo duro de
envío de correo se hace a través de la segunda clase de programas, los
agentes de transferencia de correo (<emphasis remap="it">MTA - Mail Transfer Agent</emphasis>). Estos
son invocados desde los <emphasis remap="it">MUA</emphasis>s. Toman el mensaje, deciden dónde
enviarlo observando la dirección, y finalmente lo envían a través de la
red. 
</para>

<para>
Los dos <emphasis remap="it">MTA</emphasis>s mas comunes en sistemas Linux son <literal remap="tt">sendmail</literal> y
<literal remap="tt">smail</literal>. La idea básica es hacer que su <emphasis remap="it">MTA</emphasis> se conecte a otro
<emphasis remap="it">MTA</emphasis> que esté corriendo en otra máquina de la red que sepa qué hacer
con su mensaje. Esto se consigue redirigiendo un puerto local hacia el
puerto <literal remap="tt">smtp</literal> de la máquina en red.  Entonces debe indicar a su
<emphasis remap="it">MTA</emphasis> que tome todos los mensajes con los que no sepa que hacer, y los
envíe fuera a través del puerto redirigido de su máquina local al <emphasis remap="it">MTA</emphasis>
de la máquina remota, la cual encaminará los mensajes hacia su destino
correcto.
</para>

<para>
¿Cómo hacemos esto usando <literal remap="tt">smail</literal>? Primero redirigiremos un puerto al
puerto <literal remap="tt">smtp</literal> de la máquina de correo de la red (<literal remap="tt">mailhost</literal>): 
</para>

<para>

<screen>
tredir XXXX mailhost:25
</screen>

</para>

<para>
donde <literal remap="tt">XXXX</literal> es el número de puerto al que se conecta <literal remap="tt">smail</literal> en
el host local (tenga en cuenta que hay que dar un nombre al puerto en
<literal remap="tt">/etc/services</literal> para hacer que <literal remap="tt">smail</literal> lo reconozca). <literal remap="tt">smail</literal>
tiene varios ficheros de configuración que generalmente están en
<literal remap="tt">/usr/local/lib/smail</literal>.  Los que nos interesan son <literal remap="tt">config,
routers</literal> y <literal remap="tt">transports</literal>.  Observar que presumimos que ya ha
configurado <literal remap="tt">smail</literal> correctamente para el correo local - envío a
ficheros y tuberías y demás cosas. De nuevo, consulte la documentación si
no lo ha hecho.
</para>

<para>
En el fichero <literal remap="tt">config</literal>, ponemos la siguiente definición:      
</para>

<para>

<screen>
smart_path=localhost
</screen>
 
</para>

<para>
<literal remap="tt">localhost</literal> es la máquina a la que se conecta <literal remap="tt">smail</literal> cuando no sabe que 
hacer con un mensaje.
</para>

<para>
En <literal remap="tt">routers</literal> ponemos:
</para>

<para>

<screen>
 
smart_host: 
driver=smarthost, 
transport=termsmtp; 
path = localhost 
</screen>

</para>

<para>
En <literal remap="tt">transports</literal> ponemos:
</para>

<para>

<screen>
  
termsmtp:        driver=tcpsmtp, 
	inet,                    
	return_path, 
	remove_header="From", 
	append_header="From: SU_DIRECCION_DE_RED", 
	-received, 
	-max_addrs, -max_chars; 
	service=SU_SERVICIO_SMTP, 
</screen>

</para>

<para>
En el de arriba, las líneas <literal remap="tt">header</literal> cambian la cabecera <literal remap="tt">From</literal>
en todo correo saliente por la dirección
<literal remap="tt">SU_DIRECCION_DE_RED</literal>, que será la dirección de red a la que quiere
que le envíen el correo. Si su enlace <literal remap="tt">term</literal> va a ser usado por más
de una persona, tendrá que hacer algo más laborioso, como mantener una
base de datos de direcciones de red de usuarios locales e insertar las
mismas en las cabeceras <literal remap="tt">From:</literal>. 
</para>

<para>
La línea <literal remap="tt">service</literal> es el nombre del número de puerto local que ha
redirigido al puerto <literal remap="tt">smtp</literal> de la máquina conectada a la red. En mi
versión de <literal remap="tt">smail</literal> no es posible ponerlo como un número, asi que tengo
que ponerlo como un nombre, como ``<literal remap="tt">foo</literal>'', y entonces definir
``<literal remap="tt">foo</literal>'' en <literal remap="tt">/etc/services</literal> de modo que sea el número del
puerto redirigido. Si usa un <emphasis remap="it">suid</emphasis> de <literal remap="tt">tredir</literal> y se redirige el
puerto <literal remap="tt">smtp</literal> (25), no es necesario definir esto. 
</para>

<para>
Esto debería ser suficiente para hacerlo funcionar. Si decide usar
<literal remap="tt">sendmail</literal> la base es la misma pero difiere en los detalles. Ronald
Florence (<literal remap="tt"><ulink
url="mailto:ron@mlfarm.com"
>ron@mlfarm.com</ulink
></literal>) me dijo que el <literal remap="tt">sendmail</literal> de <emphasis remap="it">Sun</emphasis>
no mandará mensajes múltiples encolados a través de un puerto redirigido;
el <literal remap="tt">sendmail</literal> 8.6.9 de <emphasis remap="it">BSD</emphasis> funciona bien. Él hizo los
siguientes cambios al <literal remap="tt">sendmail.cf</literal> para que funcionase con <literal remap="tt">term</literal>.
En este caso se usa el puerto por defecto de <literal remap="tt">sendmail</literal> (25) para
el tráfico sobre una ethernet local de forma que el correo Internet se
pasa al puerto <literal remap="tt">TCP</literal> redirigido. 
</para>

<para>

<screen>
#
# Crear el mailer termsmtp, el cual envia el correo via el puerto TCP 
# redirigido
#
Mtermsmtp,P=[TCP], F=mDFMuCXe, S=22, R=22, A=TCP $h PORTNUMBER
</screen>

</para>

<para>
Aquí, <literal remap="tt">PORTNUMBER</literal> es el número del puerto redirigido en la máquina
local. Este debería ser un puerto sin usar por encima del 2000.
Seguidamente le decimos a <literal remap="tt">sendmail</literal> a que máquina conectarse, y
ponemos a <literal remap="tt">termsmtp</literal> como <emphasis remap="it">mailer</emphasis> por defecto. 
</para>

<para>

<screen>
#
# relevo de correo principal
#
DMtermsmtp
#
# maquina del relevo principal: usa el mailer $M para enviar el
# correo de otros dominios
#
DR HOSTNAME
CR HOSTNAME
</screen>

</para>

<para>
Aquí <literal remap="tt">HOSTNAME</literal> es el nombre de tu host local (¿funcionará
<literal remap="tt">localhost</literal>?). La última entrada va debajo de <literal remap="tt">Rule 0</literal> para pasar
el correo Internet.
</para>

<para>

<screen>
# Pass other valid names up the ladder to our forwarder
R$*&#60;@$*.$+&#62;$*		$#$M    $@$R $:$1&#60;@$2.$3&#62;$4	user@any.domain
</screen>

</para>

<para>
Cuando la conexión <literal remap="tt">term</literal> se haya establecido con el host Internet,
ejecute los siguientes comandos en la máquina local. 
</para>

<para>

<screen>
tredir PORTNUMBER internet.host:25
/usr/lib/sendmail -q
</screen>

</para>

<para>
Pasamos ahora a la recepción de correo electrónico usando <literal remap="tt">term</literal>.
Asumiremos que el correo se envía a su cuenta en el servidor de correo
(<literal remap="tt">mailhost</literal>) de la red. La solución más simple es usar <literal remap="tt">trsh</literal> o
<literal remap="tt">termtelnet</literal> para acceder al servidor y leer su correo allí. 
</para>

<para>
Sin embargo, también es posible hacer pasar el correo automáticamente a su
máquina local. Una forma de hacer esto es usar el <emphasis remap="it">Post Office
Protocol</emphasis>, (<emphasis remap="it">POP</emphasis>). <emphasis remap="it">POP</emphasis> fue diseñado precisamente para este
propósito: enviar correo a máquinas que tienen conexiones de red
esporádicas.
</para>

<para>
Para usar <emphasis remap="it">POP</emphasis> ha de tener instalado un servidor <emphasis remap="it">POP</emphasis> en
<emphasis remap="it">mailhost</emphasis>. Suponiendo que lo tiene, puede usar entonces un cliente
<emphasis remap="it">POP</emphasis> para recoger su correo cada poco tiempo. Esto se hace, como
podría esperar, usando <literal remap="tt">tredir</literal>. El servicio <emphasis remap="it">POP</emphasis> es el 110
(Observe que hay un protocolo más antiguo, <emphasis remap="it">POP-2</emphasis>, que usa el puerto
109; en este documento describiremos <emphasis remap="it">POP-3</emphasis>, que es la última versión
de <emphasis remap="it">POP</emphasis>). Hay varios clientes <emphasis remap="it">POP</emphasis> disponibles. Uno, escrito en el
lenguaje de scripts <literal remap="tt">perl</literal>, es <literal remap="tt">pop-perl-1.X</literal>, escrito por
William Perry y mantenido por mí mismo - puede encontrarse en <literal remap="tt">sunsite</literal>
en <literal remap="tt">/pub/Linux/system/Mail</literal>.
</para>

<para>
Para usar <emphasis remap="it">POP</emphasis> se redirige un puerto local al puerto 110 de
<literal remap="tt">mailhost</literal> y se configura el cliente para recoger su correo de
<literal remap="tt">localhost</literal> usando el puerto local. Como ejemplo, supongamos que hay un
servidor <emphasis remap="it">POP</emphasis> corriendo en <literal remap="tt">mailhost</literal>. Redirigiremos en puerto
local 2110, y ejecutamos el cliente pop-perl: 
</para>

<para>

<screen>
$ tredir 2110 mailhost:110
Redirecting 2110 to mailhost:110
$ pop 
Username: bill
Password: &#60;introduzca su password para mailhost&#62;
Pop Host: name of local 
Pop Port: 2110 
Starting popmail daemon for bill 
</screen>

</para>

<para>
Si no tiene un servidor <emphasis remap="it">POP</emphasis> disponible, el paquete
<literal remap="tt">BCRMailHandler</literal> tiene un programa para capturar su correo desde un
enlace <literal remap="tt">term</literal> hasta su máquina local. No lo he usado, pero
cualquier comentario de alguien que lo haya hecho será bienvenido. También
puede usar el paquete <literal remap="tt">term.mailerd+smail</literal> para este propósito. Sin
embargo, <literal remap="tt">BCRMailHandler</literal> y <literal remap="tt">term.mailerd+smail</literal> ya no
funcionan con versiones de <literal remap="tt">term</literal> 2.0.0 o superiores.
</para>

</sect3>

</sect2>

</sect1>

<sect1>
<title><literal remap="tt">tudpredir</literal></title>

<para>
<literal remap="tt">tudpredir</literal> es similar a <literal remap="tt">tredir</literal> si se observa lo que estos
programas hacen y cómo se ejecutan. La gran diferencia entre los dos es
que <literal remap="tt">tredir</literal> se usa para redirigir servicios de red <literal remap="tt">TCP</literal>, mientras
<literal remap="tt">tudpredir</literal> redirige servicios de red <literal remap="tt">UDP</literal> (<emphasis remap="it">User Datagram
Protocol</emphasis>) a través de un enlace <literal remap="tt">term</literal>. Una diferencia más
importante entre los dos programas es que <literal remap="tt">tredir</literal> se convierte en un
demonio en segundo plano una vez que se ha establecido el puerto local,
mientras los comandos <literal remap="tt">tudpredir</literal> hay que ponerlos en segundo plano
manualmente. 
</para>

<para>
El formato de una llamada a <literal remap="tt">tupredir</literal> es:
</para>

<para>

<screen>
tudpredir [esta_maquina:]puerto [la_otra_maquina:]puerto
</screen>

</para>

</sect1>

<sect1>
<title>Automatizando las cosas.</title>

<para>
 
</para>

<para>
Ahora que ya sabe cómo conseguir todos los servicios de red sobre
<literal remap="tt">term</literal>, sería bonito colocar las cosas de tal modo que su enlace se
establezca y configure automáticamente. Básicamente hay infinitas formas
de hacerlo, dependiendo de que programa de comunicación utilice y cómo
acceda a su sistema remoto.
</para>

<para>
Un programa que yo no he usado, pero que he oído que es bastante
agradable, es <literal remap="tt">fet</literal>: un <emphasis remap="it">front-end</emphasis> para <literal remap="tt">term</literal>. Está
diseñado para introducirle en un sistema remoto y poner en marcha
<literal remap="tt">term</literal> y todos sus <literal remap="tt">tredirs</literal>. Cualquier comentario sobre
<literal remap="tt">fet</literal> será bienvenido. 
</para>

<para>
Le daré un ejemplo de una serie de comandos que usa <literal remap="tt">kermit</literal> para
introducirse en el sistema remoto y que efectúa todas las inicializaciones
de <literal remap="tt">term</literal>. Obviamente, si usa estos ejemplos, tendrá que
modificarlos para sus propios procedimientos de acceso.
</para>

<para>
El comando que se invoca en este caso es la <emphasis remap="it">shell script</emphasis> <literal remap="tt">knet</literal>, dada 
por:
</para>

<para>

<screen>
#!/bin/sh
/usr/bin/kermit -y $HOME/.kerm_term &#62; $HOME/klog &#60; /dev/null 2&#62;&amp; 1 
exec $HOME/bin/tstart &#62;&#62; $HOME/klog 2&#62;&amp; 1
</screen>

</para>

<para>
La script <literal remap="tt">.kerm_term</literal> viene dada por:
</para>

<para>

<screen>
 
pause 2 
# El numero al que llamar
output atdtXXXXXXX \13 
# Acceso al servidor de terminal
input 145 {name: } 
output MYNAME \13 
input 3 {word: } 
output MYPASSWORD \13 
input 5 {xyplex&#62;} 
# Hacer la linea transparente
output term telnet-t \13 
output term stopb 1 \13 
# Conectar al host remoto
output telnet remotehost.somedomain.org \13 
input 10 {ogin: } 
output MYOTHERNAME \13 
input 3 word: 
output MYOTHERPASSWORD \13 
pause 5  
# Lanzar term en el host remoto
output exec term -s 38400 -l $HOME/tlog -w 10 -t 150  \13
! /usr/bin/term -r -l $HOME/tlog -s 38400 -c off -w 10 -t 150 &#60; /dev/modem  &#62; /dev/modem &#38;
# Abrir otros clientes aqui
suspend 
!killall -KILL term 
</screen>

</para>

<para>
y finalmente, el <emphasis remap="it">script</emphasis> <literal remap="tt">tstart</literal> que lanza los clientes <literal remap="tt">term</literal> es:
</para>

<para>

<screen>
 
#!/bin/sh 
# 
# Esto hace que salga el correo, pueda leer news, y pueda recoger correo.
# 
/usr/local/bin/tredir 2025 25 2119 newshost:119 2110 pophost:110 
# 
# Puedo abrir una Xwindow aqui
# 
/usr/local/bin/trsh -s txconn 
# 
# Ahora recibire el correo....
# 
/usr/local/bin/pop 
# 
# Limpiar la cola, en caso de boo-boos
# 
/usr/bin/runq 
# 
# Acabado
# 
echo ^G^G &#62; /dev/console 
</screen>

</para>

<para>
Cuando por fin quiera cerrar la conexión, retoma y termina el <literal remap="tt">kermit</literal>.
La última línea del <emphasis remap="it">script</emphasis> mata el <literal remap="tt">term</literal> local y al sistema a
su estado inicial.
<footnote>

<para>
 Nota del autor: en lugar de hacer
<literal remap="tt">!killall -KILL term</literal>, creo que sería posible hacer solamente
<literal remap="tt">!tshutdown</literal>. ¿Funcionará esto también?  
</para>

</footnote>

</para>

<para>
Como ya dije, hay <emphasis remap="it">zillones</emphasis> de formas de hacerlo; estas sólo se han
citado como ejemplos para que pueda comenzar. Otros ejemplos pueden
encontrarse en los paquetes <literal remap="tt">autoterm</literal> y <literal remap="tt">JoelTermStuff</literal>. 
</para>

</sect1>

<sect1>
<title>Portando software para usarlo con <literal remap="tt">term</literal>.</title>

<para>
En principio, todos los programas que se puedan usar sobre una red pueden
usarse en combinación con <literal remap="tt">term</literal>. Algunos de ellos podrá
encontrarlos ya como binarios con soporte para <literal remap="tt">term</literal>. Esto incluye
<literal remap="tt">telnet, (nc)ftp, mosaic</literal> y muchos otros. La mayoría de estos
programas se han compilado para <literal remap="tt">term</literal> 1.17 o anteriores. A pesar
de eso, aún deberían funcionar con versiones más nuevas de <literal remap="tt">term</literal>.
</para>

<para>
Otra forma de hacer que los programas funcionen con <literal remap="tt">term</literal> es
portarlos usted mismo. Este proceso es el que se describe en la siguiente
subsección. 
</para>

<para>
El último modo de compatibilizar sus programas con <literal remap="tt">term</literal> es
<emphasis remap="it">termificándolos</emphasis>. 
</para>

<sect2>
<title>Portar y compilar los fuentes. </title>

<para>
Portar software a <literal remap="tt">term</literal> se puede hacer usando un procedimiento bastante 
sencillo:
</para>

<para>
Si está instalado en <literal remap="tt">/usr/local</literal> por <literal remap="tt">root</literal>:
</para>

<para>

<orderedlist>
<listitem>

<para>
 Añada a los flags de compilación <literal remap="tt">-include
/usr/local/include/termnet.h</literal>

</para>
</listitem>
<listitem>

<para>
 y añada a la lista de librerías <literal remap="tt">-ltermnet</literal>
</para>
</listitem>

</orderedlist>

</para>

<para>
Si está instalado en su directorio <emphasis remap="it">home</emphasis>:
</para>

<para>

<orderedlist>
<listitem>

<para>
 Añada a los parámetros de compilación
<literal remap="tt">-include $HOME/term/termnet.h</literal>

</para>
</listitem>
<listitem>

<para>
 y añada a la lista de librerías 
<literal remap="tt">-L$HOME/term -ltermnet</literal>

</para>
</listitem>

</orderedlist>

</para>

<para>
Ahora compile el software como se describe en el documento <literal remap="tt">INSTALL</literal> o
<literal remap="tt">README</literal> que venga con el software. ¡Ya estaría todo! 
</para>

<para>
En este momento los comandos deberían funcionar con y sin <literal remap="tt">term</literal>.
</para>

<para>

<screen>
telnet localhost
</screen>

</para>

<para>
no usa <literal remap="tt">term</literal> para conectar, pero
</para>

<para>

<screen>
telnet bohr.physics.purdue.edu
</screen>

</para>

<para>
usará <literal remap="tt">term</literal> sólo si no hay otro tipo de conexión de red.
</para>

<para>
Algunos comandos, como <literal remap="tt">rlogin</literal>, sólo pueden ser usados por
<literal remap="tt">root</literal> y por el propietario de la conexión <literal remap="tt">term</literal> (personas
privilegiadas). 
</para>

<para>
Algunos comandos <literal remap="tt">term</literal> serán transparentes a <literal remap="tt">term</literal> y sólo
usarán <literal remap="tt">term</literal> cuando no haya otra opción. Algunos ejemplos típicos
son <literal remap="tt">telnet</literal> y <literal remap="tt">ftp</literal>. 
</para>

<para>
Otros requieren un parámetro externo para indicarles que les es posible
usar <literal remap="tt">term</literal>. En estos programas se incluyen <literal remap="tt">xarchie, fsp</literal> e
<literal remap="tt">ytalk</literal>. 
</para>

<para>
Se puede poner el parámetro a estos programas para que usen <literal remap="tt">term</literal>,
bien colocando la variable de entorno <literal remap="tt">TERMMODE</literal> como se especifica en
<literal remap="tt">README.security</literal>, o bien, ejecutando <literal remap="tt">make installnet</literal>. 
Eventualmente, el fichero <literal remap="tt">termnet</literal> creado contendrá instrucciones de
red específicas, pero por ahora sólo está probada su existencia.
</para>

<para>
Si se añade una <emphasis remap="it">conexión ethernet</emphasis>, puede simplemente quitar el
fichero <literal remap="tt">termnet</literal> y ¡continuar usando los mismos binarios! 
</para>

<para>
NOTA: Aquellos programas que fueron portados en los tiempos del <literal remap="tt">client.a</literal>,
aún pueden ser recompilados para usarlos con versiones nuevas de <literal remap="tt">term</literal> 
cambiando simplemente la referencia a <literal remap="tt">client.a</literal> por <literal remap="tt">libtermnet.a</literal>.
</para>

</sect2>

<sect2>
<title><emphasis remap="it">Termificar</emphasis> (<literal remap="tt">termify</literal>).</title>

<para>
Este paquete convertirá los binarios enlazados dinámicamente para usar
<literal remap="tt">term</literal>. 
</para>

<para>
Antes de poder <emphasis remap="it">termificar</emphasis> deberá asegurarse de que tiene una
versión 2.2i (en esta versión 2.2.8?) de <literal remap="tt">term</literal> o posterior y
<literal remap="tt">libc.so.4.5.26</literal> o posterior.  Entonces hay que crear el fichero
<literal remap="tt">libt.so.4</literal> en el directorio <literal remap="tt">/lib</literal> (ver el fichero <literal remap="tt">README</literal>
del paquete).
</para>

<para>
El problema en este momento es que hay que rehacer el fichero <literal remap="tt">libt.so.4</literal> 
cada vez que renueve la versión de <literal remap="tt">term</literal>.
</para>

<para>
Después de crear la librería podrá dejar que <literal remap="tt">termify</literal>
<emphasis remap="it">``digiera''</emphasis> al programa que se quiere hacer <emphasis remap="it">term-compatible</emphasis>,
usando el comando: 
</para>

<para>

<screen>
termify &#60;programa&#62;
</screen>

</para>

<para>
Si no le gusta el resultado puede <emphasis remap="it">des-termificar</emphasis> el programa que
acaba de termificar, usando el comando: 
</para>

<para>

<screen>
termify -u &#60;programa&#62;
</screen>

</para>

<para>
Por fin, el paquete también contiene un <emphasis remap="it">script</emphasis> para <emphasis remap="it">termificar</emphasis>
completamente <literal remap="tt">smail</literal>; de modo que no son necesarias definiciones
especiales de transporte. La única cosa que quizá quiera cambiar es la
dirección del <literal remap="tt">From:</literal>. 
</para>

</sect2>

</sect1>

<sect1>
<title>Clientes <literal remap="tt">term</literal>.</title>

<sect2>
<title>Clientes <literal remap="tt">term</literal> disponibles en los servidores <literal remap="tt">ftp</literal>.</title>

<para>
A continuación se da una lista de aplicaciones que corren con
<literal remap="tt">term</literal>. Yo no digo que esta lista esté completa; así que cualquier
añadido será bienvenido. Siempre que sea posible indicaré el <emphasis remap="it">site</emphasis> y
directorio donde se pueda encontrar la aplicación. Si indico
<literal remap="tt">sunsite.unc.edu</literal>
<footnote>

<para>
En España contamos con un magnífico y veloz <emphasis remap="it">mirror</emphasis> de SunSite,
localizable en <literal remap="tt"><ulink
url="ftp://sunsite.rediris.es"
>sunsite.rediris.es</ulink
></literal>
</para>

</footnote>
 como el lugar donde encontrar
la aplicación, quiero decir que puede encontrarla en uno de los dos
directorios siguientes:
</para>

<para>

<orderedlist>
<listitem>

<para>
<literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/apps/comm/term/apps"
>ftp://sunsite.unc.edu/pub/Linux/apps/comm/term/apps</ulink
></literal>

</para>
</listitem>
<listitem>

<para>
<literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/apps/comm/term/extra"
>ftp://sunsite.unc.edu/pub/Linux/apps/comm/term/extra</ulink
></literal>

</para>
</listitem>

</orderedlist>

</para>

<para>
¡Allá vamos! <literal remap="tt">:-)</literal>
</para>

<para>
<emphasis remap="bf">paquete <literal remap="tt">TERM</literal>:</emphasis>
</para>

<para>

<screen>
tupload
tdownload           (versiones 2.1.0 y posteriores)
trsh
tmon
tredir
tudpredir           (versiones 2.0.0 y posteriores)
txconn
trdate(d)
tshutdown
libtermnet
</screen>

</para>

<para>
<emphasis remap="bf">Transferencia de ficheros:</emphasis>
</para>

<para>

<screen>
ftpd                sunsite.unc.edu
termncftp           sunsite.unc.edu
ncftp185            sunsite.unc.edu:/pub/Linux/system/Network/file-transfer
fsp                 sunsite.unc.edu:/pub/Linux/system/Network/file-transfer
</screen>

</para>

<para>
<emphasis remap="bf">Sistemas de Información:</emphasis>
</para>

<para>

<screen>
lynx                
Mosaic              sunsite.unc.edu:/pub/Linux/system/Network/info-systems/Mosaic
chimera
netscape            sunsite.unc.edu:/pub/Linux/system/Network/info-systems
httpd
xgopher
gopher              sunsite.unc.edu
</screen>

</para>

<para>
<emphasis remap="bf">Acceso remoto:</emphasis>
</para>

<para>

<screen>
termtelnet          sunsite.unc.edu
rlogin              physics.purdue.edu:/pub/bcr/term/extra
rsh                 physics.purdue.edu:/pub/bcr/term/extra
</screen>

</para>

<para>
<emphasis remap="bf">Noticias (news):</emphasis>
</para>

<para>

<screen>
tin 1.3             sunsite.unc.edu:/pub/Linux/system/Mail/news
news2               sunsite.unc.edu
</screen>

</para>

<para>
<emphasis remap="bf">Correo:</emphasis>
</para>

<para>

<screen>
slurp               sunsite.unc.edu
smail               sunsite.unc.edu
term.mailerd+smail  sunsite.unc.edu
BCRMailHandlerXXX   physics.purdue.edu:/pub/bcr/term
</screen>

</para>

<para>
<emphasis remap="bf">Scripts automatizadores:</emphasis>
</para>

<para>

<screen>
JoelTermStuff       sunsite.unc.edu
autoterm            sunsite.unc.edu
fet                 sunsite.unc.edu
</screen>

</para>

<para>
<emphasis remap="bf">Otros programas:</emphasis>
</para>

<para>

<screen>
inetd               sunsite.unc.edu
rdate               sunsite.unc.edu
xgospel             sunsite.unc.edu:/pub/Linux/games/x11/networked
termify             physics.purdue.edu:/pub/bcr/term/extra
xboard              sunsite.unc.edu
ircII               sunsite.unc.edu:/pub/Linux/system/Network/chat
whois               
xwebster            sunsite.unc.edu
sxpc                ftp.x.org:/R5contrib
xztalk              sunsite.unc.edu:/pub/Linux/apps/sound/talk
</screen>

</para>

</sect2>

<sect2>
<title>El paquete <literal remap="tt">termnet</literal>.</title>

<para>
El paquete <literal remap="tt">termnet-2.0.4-Linux-bin.tar.gz</literal> 
(<literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/apps/comm/term"
>ftp://sunsite.unc.edu/pub/Linux/apps/comm/term</ulink
></literal>) contiene un
par de clientes precompilados, un par de scripts, páginas de manual y
<literal remap="tt">libtermnet.so.2.00.04</literal>.  Los clientes se han compilado usando esta
versión de <literal remap="tt">libtermnet.so</literal>. El paquete contiene los siguientes
clientes: 
</para>

<para>

<screen>
fet         perl        sperl4.036  tmon        tshutdown   xgopher
finger      perl4.036   suidperl    trdate      tudpredir   ytalk
ftp         rcp         taintperl   trdated     tupload
fwhois      rlogin      telnet      tredir      txconn
ncftp       rsh         term        trsh        xarchie
</screen>

</para>

<para>
AVISO: El paquete también contiene el conjunto completo de clientes
compilados de <literal remap="tt">term</literal> 2.0.4 incluyendo el mismo <literal remap="tt">term</literal>. No
instale este paquete hasta que esté seguro de lo que quiere. Destruirá
otras versiones de <literal remap="tt">term</literal> y sus clientes si empieza a enredar con
los ejecutables.
</para>

</sect2>

<sect2>
<title>Solicitado, pero aún no soportado:</title>

<para>

<orderedlist>
<listitem>

<para>
 <literal remap="tt">DOOM</literal>: El problema con este juego parece ser el hecho de que
usa el puerto 5029 ya sea como cliente o como servidor. 

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">NFS</literal>: El servidor <literal remap="tt">NFS</literal> se supone que sólo acepta
llamadas si el <emphasis remap="it">socket</emphasis> que solicita la conexión está ligado a un
puerto por debajo del 1024. Esto parece ser problemático. Sin embargo,
algunos servidores <literal remap="tt">NFS</literal> tienen una opción <emphasis remap="it">insegura</emphasis>. En este caso
<literal remap="tt">NFS</literal> podría funcionar ocasionalmente, si se le añade al <literal remap="tt">term</literal>
soporte <literal remap="tt">RPC</literal>.  

</para>
</listitem>

</orderedlist>

</para>

</sect2>

</sect1>

<sect1>
<title><literal remap="tt">Term</literal> y la seguridad</title>

<para>
En esta sección puntualizaré algunos aspectos sobre la seguridad
usando <literal remap="tt">TERM</literal>. Los problemas serán expuestos junto a un
mecanismo para aumentar su seguridad.
</para>

<sect2>
<title><literal remap="tt">trsh</literal>.</title>

<para>
<literal remap="tt">trsh</literal> es inseguro si se usa para acceder al Linux local desde
el sistema remoto. El problema con <literal remap="tt">TERM</literal> y sus clientes es que
en el otro extremo de la comunicación el superusuario puede ejecutar
programas de <literal remap="tt">TERM</literal>.
</para>

<para>
Esto también indica que el ``<literal remap="tt">root</literal>'' del otro sistema puede ejecutar
<literal remap="tt">trsh</literal> y entrar con los privilegios del propietario de la conexión
fácilmente. Si este propietario es ``<literal remap="tt">root</literal>'' la <emphasis remap="it">habremos liado</emphasis>. 
</para>

<para>
La solución es simple: poner la siguiente línea en el fichero <literal remap="tt">termrc</literal>
de la máquina local:
</para>

<para>

<screen>
denyrsh on
</screen>

</para>

<para>
Con esto, nadie podrá usar <literal remap="tt">trsh</literal> desde el sistema remoto para entrar
en el local. Cuando tú mismo quieras entrar, podrás hacerlo aún usando
<literal remap="tt">telnet</literal> y puertos redirigidos. 
</para>

</sect2>

<sect2>
<title><literal remap="tt">txconn</literal> y <literal remap="tt">xauth</literal></title>

<para>
<literal remap="tt">txconn</literal> no es terriblemente seguro; cualquiera puede conectar al
servidor local con <literal remap="tt">term</literal> y hacer de todo. Si te preocupa, puedes
usar <literal remap="tt">xauth</literal> para establecer las autorizaciones de acceso. Mira el
ejemplo de la siguiente sección. 
</para>

</sect2>

<sect2>
<title><literal remap="tt">sxpc</literal>, <literal remap="tt">xhost</literal> y <literal remap="tt">xauth</literal></title>

<para>
<literal remap="tt">sxpc</literal> en combinación con <literal remap="tt">xhost +</literal> es muy peligroso si no usas
<literal remap="tt">xauth</literal>. 
</para>

<para>
Usar <literal remap="tt">xauth</literal> es muy importante para mantener la seguridad cuando se usa
<literal remap="tt">sxpc</literal>. Si no usas <literal remap="tt">xauth</literal> al usar <literal remap="tt">sxpc</literal>, será muy peligroso
tener <literal remap="tt">xhost +</literal>.  Algunos peligros son: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
Alguien puede saber lo que hay en tu pantalla
</para>
</listitem>
<listitem>

<para>
Alguien puede saber lo que tecleas
</para>
</listitem>
<listitem>

<para>
Alguien puede teclear sobre alguna de tus ventanas (por ejemplo,
un comando que borre tus ficheros <literal remap="tt">:-(</literal> )
</para>
</listitem>

</itemizedlist>

</para>

<para>
<literal remap="tt">xauth</literal> forma parte de las versiones R4 y posteriores de X. Aquí
describiremos cómo usar básicamente el <literal remap="tt">xauth</literal>. Esta configuración es
vulnerable al husmeo de la red, pero puede convivir con ella fácilmente. 
</para>

<para>
<emphasis remap="bf">NOTA:</emphasis> cuando uses <literal remap="tt">xauth</literal> asegúrate que la variable
<literal remap="tt">$DISPLAY</literal> no tiene el valor <literal remap="tt">localhost</literal> (o
<literal remap="tt">localhost:loquesea</literal>). Si tu variable <literal remap="tt">$DISPLAY</literal> vale
<literal remap="tt">localhost</literal>, los clientes no podrán encontrar la información de
autorización. Lo mejor es usar el nombre real de la máquina. Si sigues las
instrucciones de compilación del <literal remap="tt">README</literal>, y compilas sin la variable
<literal remap="tt">-DNOGETHOSTNAME</literal> puede que todo funcione. 
</para>

<para>
Sea <emphasis remap="it">C</emphasis> la máquina que ejecuta clientes, y <emphasis remap="it">D</emphasis> la máquina que pone la 
pantalla.
</para>

<para>
Primero, elige una ``clave'', de hasta 16 pares de dígitos hexadecimales
(números del rango 0-9 y a-f). Necesitarás proporcionar esta clave en
el lugar de <literal remap="tt">&lt;clave&gt;</literal> en este ejemplo:
</para>

<para>
En <emphasis remap="it">C</emphasis>:
</para>

<para>

<screen>
% xauth
xauth:  creating new authority file $HOME/.Xauthority
Using authority file $HOME/.Xauthority
xauth&#62; add Nombre_de_C:8 MIT-MAGIC-COOKIE-1 &#60;clave&#62;
xauth&#62; exit
</screen>

</para>

<para>
En <emphasis remap="it">D</emphasis>:
</para>

<para>

<screen>
% xauth
xauth:  creating new authority file $HOME/.Xauthority
Using authority file $HOME/.Xauthority
xauth&#62; add Nombre_de_D/unix:0 MIT-MAGIC-COOKIE-1 &#60;clave&#62;
xauth&#62; add Nombre_de_D:0 MIT-MAGIC-COOKIE-1 &#60;clave&#62;
xauth&#62; exit
</screen>

</para>

<para>
Cuando inicies el servidor X en <emphasis remap="it">D</emphasis> deberías poner el parámetro
<literal remap="tt">-auth $HOME/.Xauthority</literal>. Puede que necesites crear o
editar el fichero <literal remap="tt">$HOME/.xserverrc</literal> para controlar el
inicio del servidor X. Por ejemplo: 
</para>

<para>

<screen>
#!/bin/sh
exec X  -auth $HOME/.Xauthority $*
</screen>

</para>

<para>
Asegúrate que el fichero <literal remap="tt">.Xauthority</literal> es legible sólo por <literal remap="tt">C</literal> y
por <emphasis remap="it">D</emphasis>. 
</para>

</sect2>

</sect1>

<sect1>
<title>Cosas a recordar</title>

<para>
En esta sección intento obsequiarle con una lista de direcciones <literal remap="tt">ftp</literal>
de utilidad, <emphasis remap="it">url</emphasis>'s, etc. donde puede encontrar software e información
sobre <literal remap="tt">term</literal>. 
</para>

<para>
<emphasis remap="bf">Ftp:</emphasis>
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt"><ulink
url="ftp://sunsite.unc.edu:/pub/Linux/apps/comm/term/"
>ftp://sunsite.unc.edu:/pub/Linux/apps/comm/term/</ulink
></literal>
</para>
</listitem>
<listitem>

<para>
<literal remap="tt"><ulink
url="ftp://sunsite.unc.edu:/pub/Linux/docs/HOWTO/"
>ftp://sunsite.unc.edu:/pub/Linux/docs/HOWTO/</ulink
></literal>
</para>
</listitem>
<listitem>

<para>
<literal remap="tt"><ulink
url="ftp://physics.purdue.edu:/pub/bcr/term/"
>ftp://physics.purdue.edu:/pub/bcr/term/</ulink
></literal>
</para>
</listitem>

</itemizedlist>

</para>

<para>
<emphasis remap="bf">url:</emphasis>
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt"><ulink
url="http://sunsite.unc.edu/mdw/HOWTO/Term-HOWTO.html"
>http://sunsite.unc.edu/mdw/HOWTO/Term-HOWTO.html</ulink
></literal>
</para>
</listitem>
<listitem>

<para>
<literal remap="tt"><ulink
url="http://www.bart.nl/&#732;patrickr/term-howto/Term-HOWTO.html"
>http://www.bart.nl/&#732;patrickr/term-howto/Term-HOWTO.html</ulink
></literal>
(siempre tiene la última versión)
</para>
</listitem>
<listitem>

<para>
<literal remap="tt"><ulink
url="http://physics.purdue.edu/&#732;bcr/homepage.html"
>http://physics.purdue.edu/&#732;bcr/homepage.html</ulink
></literal>
</para>
</listitem>

</itemizedlist>

</para>

<para>
<emphasis remap="bf">Netnews:</emphasis>
</para>

<para>

<screen>
comp.os.linux.announce           aqui se anuncian nuevas versiones de term
comp.os.linux.help               aqui puede poner sus dudas sobre term
comp.os.linux.misc               o aqui
comp.protocols.misc              las respuestas a las preguntas son enviadas aqui.
</screen>

</para>

<para>
Cuando comience a hacer preguntas en las news, por favor, asegúrese de que
da a la gente del grupo tanta información como necesitan para resolver su
problema (versión de <literal remap="tt">term</literal>, de qué modo establece su conexión, etc.). 
</para>

<para>
En este momento hay en uso muchas versiones de <literal remap="tt">term</literal> y todas ellas
tienen sus problemas comunes y específicos. Además, cuando quiera una
respuesta útil, al menos indique qué versión de <literal remap="tt">term</literal> está usando. De
lo contrario, en algunos casos sólo por adivinación será posible ayudarle
a resolver sus problemas. 
</para>

<para>
<emphasis remap="bf">Documentos relacionados:</emphasis>
</para>

<para>

<itemizedlist>
<listitem>

<para>
<emphasis remap="it">Using Term to Pierce an Internet Firewall HOWTO</emphasis> 
de Barak Pearlmutter, 

<literal remap="tt"><ulink
url="mailto:bap@learning.scr.siemens.com"
>bap@learning.scr.siemens.com</ulink
></literal>

</para>
</listitem>
<listitem>

<para>
<emphasis remap="it">Cortafuegos-Como</emphasis>
<footnote>

<para>
Disponible en castellano, consulte 
la sección <xref linkend="Grupos"/>
</para>

</footnote>
 de David Rudder,
<literal remap="tt"><ulink
url="mailto:drig@execpc.com"
>drig@execpc.com</ulink
></literal>

</para>
</listitem>
<listitem>

<para>
<emphasis remap="it">Serial HOWTO</emphasis>, de Greg Hankins,
<literal remap="tt"><ulink
url="mailto:gregh@cc.gatech.edu"
>gregh@cc.gatech.edu</ulink
></literal>

</para>
</listitem>
<listitem>

<para>
<emphasis remap="it">Net-2/Net-3 HOWTO</emphasis> de Terry Dawson,
<literal remap="tt"><ulink
url="mailto:terryd@extro.ucc.su.oz.au"
>terryd@extro.ucc.su.oz.au</ulink
></literal>

</para>
</listitem>

</itemizedlist>

</para>

</sect1>

<sect1>
<title>Estabilidad de las versiones de <literal remap="tt">term</literal></title>

<para>
Hay muchas versiones de <literal remap="tt">term</literal> rondando en estos momentos. El que
mantiene el <literal remap="tt">term</literal>, Bill Riemers, ha hecho una lista de versiones
de <literal remap="tt">term</literal> indicando qué versiones son estables y qué versiones es
mejor evitar. La lista es la siguiente: 
</para>

<para>

<screen>
      term110          --&#62; no puedo decir con seguridad
      term111          --&#62; no puedo decir con seguridad
      term112          --&#62; no puedo decir con seguridad
      term113          --&#62; no puedo decir con seguridad
      term114          --&#62; version BETA bastante estable
      term115          --&#62; version BETA inestable BETA
      term116          --&#62; version BETA inestable BETA
      term117          --&#62; version BETA inestable BETA
      term118          --&#62; version BETA semiestable
      term119          --&#62; version GAMMA estable
      term-2.0.X       --&#62; BETA versiones BETA semiestables
      term-2.1.X       --&#62; mas versiones BETA estables
      term-2.2.X       --&#62; nuevas versiones BETA
      term-2.3.X       --&#62;
</screen>
 
</para>

</sect1>

<sect1>
<title>Tabla de velocidad de <literal remap="tt">term</literal>.</title>

<para>
Gracias a Bill McCarthy ahora disponemos de una tabla con información de
la velocidad de <literal remap="tt">term</literal> para diferentes módems, versiones de
<literal remap="tt">term</literal> y condiciones de conexión. El propósito es dar, tanto a los
usuarios nuevos como a los experimentados, una idea de lo que otra gente
está usando y los resultados que consiguen.
</para>

<para>

<screen>
			   LINUX TERM CHART 8/14/94


|___velocidad/marca____|___vel. linea__|__cps med__|__max.__|__ver term_|
| 1)  USR SP 14.4      |   9600        |  950      |  963   | 1.17      |
| 2)  USR SP 14.4      |  14400        | 1376      |  n/a   | 1.18p06   |
| 3)  Zoom 2400        |   2400        |  220      |  230   | 1.19      | 
| 4)  Boca V.32bis 14  |  57600        | 1400      |  n/a   | 1.01/09?  |
| 5)  Viva 14.4        |  14400        | 1300      |  n/a   | 1.16      |
| 6)  USR SP 14.4      |  14400+       | 1550      | 1680   | 1.19      |
| 7)  Intel 14.4 Fax   |  14400        | 1400      | 1650   | 2.0.4     | 
| 8)  cable tv hookup  |  57600        | 1500      | 1800   | 1.18p06   |
| 9)  Twincom 144/DFi  |  57600        | 1500      | 4000?  | 2.0.4     |
| 10) USR SP 14.4      |  14400        | 1200      | 1500   | 1.08      |
| 11) cable tv hookup  |  19200        | 1300      | 1800   | 1.19      |
|-----------------------------------------------------------------------|

+parametros en el termrc:

1) default escapes   2) window 5       3) baudrate 2400    4) n/a            
 baudrate 9600        timeout 200       window 3
 window 10                              noise on
 timeout 150

5) compress off      6) baudrate 19200  7) ignore 19+17    8) compress off
 window 10            compress on        window 4           escape 0, 13, 
 timeout 150                             timeout 90         16-19, 255
 baudrate 38400                                             baudrate 0
                                                            shift 224
						            flowcrtl 500
						            window 10
						            timeout 70
						            retrain on
						            breakout 24
9) compress off     10) compress off      11) baudrate 19200
 baudrate 57600       baudrate 38400        compress on
 window 10            escape 17, 19         shift 224
 timeout 200          remote                escape 0, 13 16-17
 noise on                                   19, 255
 share on                                   window 10
 remote                                     timeout 40

Escapar caracteres en un extremo implica ignorarlos en el otro extremo.
</screen>

</para>

</sect1>

<sect1>
<title>Pistas y trucos encontrados en la red</title>

<para>
En los grupos de news relacionados con Linux surgen de nuevo muchas 
preguntas sobre <literal remap="tt">term</literal> cada 15 días, junto con las respuestas a estas 
preguntas. Para reducir el tráfico del grupo de news, intentaré hacer un 
resumen de esas preguntas y las respuestas a las mismas. Algunas de las
respuestas han sido probadas por mí, ya que también tuve los citados 
problemas. Otras simplemente las he tomado sin comprobarlas.
</para>

<para>

<itemizedlist>
<listitem>

<para>
Mucha gente, en especial los que usan <emphasis remap="it">Ultrix</emphasis>, parecen tener 
problemas 
con el <literal remap="tt">vi</literal> porque les muestra menos de 24 líneas en ventanas con 24 
líneas. Hay dos formas de resolver este problema:


<orderedlist>
<listitem>

<para>
Acceda al sistema remoto usando: 


<screen>
trsh -s telnet &#60;hostname&#62;
</screen>


</para>
</listitem>
<listitem>

<para>
Ponga <literal remap="tt">resize; clear</literal> en su fichero <literal remap="tt">.login</literal>

</para>
</listitem>
<listitem>

<para>
La mejor solución parece ser poner lo siguiente en el remoto:


<screen>
stty 38400
</screen>


</para>
</listitem>

</orderedlist>


</para>
</listitem>
<listitem>

<para>
 Mucha gente parece tener problemas con caídas de la conexión
<literal remap="tt">term</literal>, cualesquiera que sean los motivos de la caída. Así que
antes de poner en marcha aplicaciones, la gente quiere saber si su
conexión <literal remap="tt">term</literal> sigue viva o no. Esto se puede probar usando estos
pequeños ejemplos de <emphasis remap="it">shell scripts</emphasis>: 

Si está usando <literal remap="tt">tcsh</literal>:


<screen>
if ( { trsh -s true } ) then
  ...
endif
</screen>


Si está usando <literal remap="tt">bash</literal>:


<screen>
if trsh -s true; then
  ...
fi
</screen>


</para>
</listitem>
<listitem>

<para>
 El navegador de <emphasis remap="it">WWW</emphasis> <literal remap="tt">netscape</literal> causa a la gente
problemas para funcionar con <literal remap="tt">term</literal>. La buena noticia es que puede
funcionar. He aquí cómo: 


<orderedlist>
<listitem>

<para>
Termificar el netscape

</para>
</listitem>
<listitem>

<para>
Lanzar <literal remap="tt">termnetscape</literal>. En el menú <literal remap="tt">Options | Preferences |
Mail/Proxys</literal> dejar todos los campos <literal remap="tt">proxy</literal> en blanco; poner en el
campo <literal remap="tt">SOCKS</literal>: <literal remap="tt">remotehost</literal> y 80
</para>
</listitem>
<listitem>

<para>
Ignorar el error que saldrá en el menú de opciones.

</para>
</listitem>
<listitem>

<para>
Si no funciona bien: en el menú <literal remap="tt">Options | Preferences |
Mail/Proxys</literal> dejar todos los campos <literal remap="tt">proxy</literal> en blanco, poner en el
campo <literal remap="tt">SOCKS</literal>: <literal remap="tt">none</literal> y 80

</para>
</listitem>
<listitem>

<para>
Ignorar el error que saldrá en el menú de opciones.

</para>
</listitem>

</orderedlist>


Scott Blachowicz me envió un mensaje diciendo que hay una forma fácil
de hacer que Netscape u otro navegador funcione bien con <literal remap="tt">term</literal>
si tiene instalado un servidor proxy (como el <literal remap="tt">httpd</literal> del CERN) para ser
usado en el lado <emphasis remap="it">remoto</emphasis> del enlace <literal remap="tt">term</literal>. En el lado
local tendrás que hacer esto entonces:


<itemizedlist>
<listitem>

<para>

<screen>
    tredir local:8080 remota:80
</screen>


Donde <literal remap="tt">remota</literal> es el nombre remoto del servidor <emphasis remap="it">proxy</emphasis>.

</para>
</listitem>
<listitem>

<para>
 Ejecuta el navegador, y en las opciones o como se llame,
pon los proxies como <literal remap="tt">local</literal>, puerto 8080. En algunos navegadores esto
se hace mediante variables de entorno como:


<screen>
                export http_proxy=http://localhost:8080/
                export ftp_proxy=http://localhost:8080/
</screen>


</para>
</listitem>

</itemizedlist>

</para>
</listitem>

</itemizedlist>

</para>

</sect1>

<sect1>
<title>Otras Cosas</title>

<para>
Algunas cosas que se podrían incluir:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Aumento de soluciones a problemas
</para>
</listitem>
<listitem>

<para>
Extensión del tema sobre seguridad
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">termwrap</literal>
</para>
</listitem>
<listitem>

<para>
Sugerencias
</para>
</listitem>

</itemizedlist>

</para>

<para>
De todos modos, si tiene sugerencias, críticas, o cualquier otra cosa que
decir sobre este documento, por favor, ¡hágalo!. Como Bill Reynolds está muy
ocupado en estos momentos, yo, Patrick Reijen, me he hecho cargo de la 
autoría del <literal remap="tt">Term</literal>-COMO. Se me puede encontrar (actualmente) en 
<literal remap="tt"><ulink
url="mailto:patrickr@cs.kun.nl"
>patrickr@cs.kun.nl</ulink
></literal> 
o en 
<literal remap="tt"><ulink
url="mailto:patrickr@sci.kun.nl"
>patrickr@sci.kun.nl</ulink
></literal>.
</para>

</sect1>

<sect1>
<title>Reconocimientos</title>

<para>
Hay que dar las gracias a mucha gente. Primero y principalmente a Michael
o'Reilly y todos los desarrolladores del <literal remap="tt">term</literal>, que nos han
proporcionado esta gran herramienta. También quisiera agradecer a todos
los que dieron su experiencia y contribuyeron a este COMO. Esto incluye a
Ronald Florence, Tom Payerle, Bill C. Riemers, Hugh Secker-Walker, Matt
Welsh, Bill McCarthy, Sergio y todos los que me olvido de mencionar.
</para>

</sect1>

<sect1 id="Grupos">
<title>Anexo: El INSFLUG </title>

<para>
El <emphasis>INSFLUG</emphasis> forma parte del grupo internacional 
<emphasis remap="it">Linux Documentation Project</emphasis>, 
encargándose de las traducciones al castellano de los Howtos (Comos),
así como la producción de documentos originales en aquellos casos
en los que no existe análogo en inglés.
</para>

<para>
En el <emphasis remap="bf">INSFLUG</emphasis> se orienta preferentemente a la traducción de documentos
breves, como los <emphasis>COMOs</emphasis> y <emphasis>PUFs</emphasis> (<emphasis remap="bf">P</emphasis>reguntas de
<emphasis remap="bf">U</emphasis>so <emphasis remap="bf">F</emphasis>recuente, las <emphasis remap="it">FAQs</emphasis>. <literal remap="tt">:)</literal> ), etc.
</para>

<para>
Diríjase a la sede del INSFLUG para más información al respecto.
</para>

<para>
En la sede del INSFLUG encontrará siempre las <emphasis remap="bf">últimas</emphasis> versiones 
de las traducciones:  <literal remap="tt"><ulink
url="http://www.insflug.org"
>www.insflug.org</ulink
></literal>. Asegúrese de comprobar cuál es la última versión 
disponible en el Insflug antes de bajar un documento de un servidor réplica.
</para>

<para>
Se proporciona también una lista de los servidores
réplica (<emphasis remap="it">mirror</emphasis>) del Insflug más cercanos a Vd.,  
e información relativa a otros recursos en castellano.
</para>

<para>
Francisco José Montilla, <literal remap="tt"><ulink
url="mailto:pacopepe@insflug.org"
>pacopepe@insflug.org</ulink
></literal>.
</para>

</sect1>

</article>
