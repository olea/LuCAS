.\" Copyright 1993 David Metcalfe (david@prism.demon.co.uk)
.\"
.\" Se concede autorizaci√≥n para hacer y distribuir copias literales de este 
.\" manual siempre que el aviso de copyright y esta autorizaci√≥n se conserven
.\" en todas las copias.
.\"
.\" Se concede autorizaci√≥n para copiar y distribuir versiones modificadas de 
.\" este manual bajo las condiciones de copia literal, siempre que el resultado 
.\" completo del trabajo realizado se distribuya bajo los t√©rminos de una 
.\" autorizaci√≥n id√©ntica a esta.
.\" 
.\" Como el n√∫cleo y las bibliotecas de Linux est√°n permanentemente cambiando
.\" esta p√°gina del manual puede ser incorrecta o estar desactualizada. El 
.\" autor o autores no asumen ninguna responsabilidad sobre los errores u 
.\" omisiones, o por los da√±os que resulten del uso de la informaci√≥n contenida
.\" aqu√≠. Puede que el autor o los autores no hayan tenido el mismo cuidado en
.\" escribir este manual, cuya licencia es libre de cargo, como el que puedan
.\" tener cuando trabajan profesionalmente.
.\" 
.\" Versiones formatadas o procesadas de este manual, si no van acommpa√±adas 
.\" por la fuente, deben dar a conocer el copyright y los autores de este 
.\" trabajo.
.\"
.\" Referencias consultadas:
.\"     c√≥digo fuente de libc de Linux 
.\"     _Gu√≠a del programador de POSIX_ de Lewine (O'Reilly & Associates, 1991)
.\"     p√°ginas del manual de 386BSD
.\" Modificado el Domingo 25 de Julio de 1993 a las 10:53:39 por Rik Faith 
.\" (faith@cs.unc.edu)
.\" Correcciones a√±adidas por to nsd@bbc.com (Nick Duffek) - aeb, 950610
.\" Traducido el Jueves 12 de Marzo de 1998 por Carlos Gomez Romero 
.\" (cgomez@databasedm.es)
.\" TraducciÛn revisada por Miguel PÈrez Ibars <mpi79470@alu.um.es> el 21-enero-2005
.\"
.TH STRTOL 3  "30 mayo 2002" "GNU" "Manual del Programador de Linux "
.SH NOMBRE
strtol, strtoll, strtoq \- convierten una cadena en un entero de tipo long
.SH SINOPSIS
.nf
.B #include <stdlib.h>
.sp
.BI "long int"
.BI "strtol(const char *" nptr ", char **" endptr ", int " base );
.sp
.BI "long long int"
.BI "strtoll(const char *" nptr ", char **" endptr ", int " base );
.fi
.SH DESCRIPCI√ìN
La funci√≥n \fBstrtol()\fP convierte la parte inicial de la cadena de entrada 
\fInptr\fP en un valor entero de tipo long de acuerdo a la \fIbase\fP dada, que debe estar 
entre 2 y 36 ambos incluidos o ser el valor especial 0.
.PP
La cadena debe comenzar con una cantidad arbitraria de espacios en blanco, (tal
y como los define la funci√≥n
.BR isspace (3))
seguida por un √∫nico y opcional signo `+' o `-'.  Si la \fIbase\fP is 0 o 16, 
la cadena puede incluir el prefijo `0x', y el n√∫mero ser√° interpretado en base 
16, en caso contrario la \fIbase\fP cero se toma como base 10 (decimal), a 
menos que el car√°cter siguiente sea `0', en cuyo caso se toma como base 8 
(octal).
.PP
El resto de la cadena se convierte en un entero de tipo long de una forma 
evidente, par√°ndose la conversi√≥n en el primer car√°cter que no es un d√≠gito 
v√°lido en la base dada.  (En bases superiores a 10, la letra `A' en may√∫sculas
o min√∫sculas representa el 10, `B' representa el 11, y as√≠ sucesivamente, con
la `Z' representando el 35.)
.PP
Si \fIendptr\fP no es NULL, \fBstrtol()\fP almacena la direcci√≥n del primer
car√°cter no v√°lido en \fI*endptr\fP.  Si no hubiera d√≠gitos en toda la cadena
\fBstrtol()\fP almacena el valor original de \fInptr\fP en \fI*endptr\fP.
(y devuelve 0).
En particular, si \fI*nptr\fP es distinto de `\\0' pero \fI**endptr\fP
es `\\0' a la vuelta, la cadena entera es v·lida.
.PP
La funciÛn
.B strtoll()
hace el mismo trabajo que la funciÛn
.B strtol()
pero devuelve un valor entero de tipo long long.
.SH "VALOR DEVUELTO"
La funci√≥n \fBstrtol()\fP devuelve el resultado de la conversi√≥n, a menos que 
el valor se desbordara por arriba o por abajo.  Si ocurriera un desbordamiento
inferior, \fBstrtol()\fP devuelve LONG_MIN.  Si ocurriera un desbordamiento 
superior, \fBstrtol()\fP devuelve LONG_MAX.  En ambos casos, \fIerrno\fP se
establece a ERANGE.
Precisamente lo mismo se aplica a
.B strtoll()
(con LLONG_MIN y LLONG_MAX en lugar de LONG_MIN y LONG_MAX).
.SH ERRORES
.TP
.B ERANGE
El valor resultante est· fuera de rango.
.TP
.B EINVAL
(no est· en C99)
La
.I base
dada contiene un valor no soportado.
.LP
La implementaciÛn puede poner tambiÈn \fIerrno\fP a \fBEINVAL\fP 
en caso de que no se realice ninguna conversiÛn (no se encuentren dÌgitos, y se devuelva 0).
.SH OBSERVACIONES
En otras localizaciones distintas a la localizaciÛn "C", se pueden aceptar
tambiÈn otras cadenas.
(Por ejemplo, el separador de miles de la localizaciÛn actual puede estar
soportado.)
.LP
BSD tiene tambiÈn la funciÛn
.sp
.in +4n
.nf
.BI "quad_t"
.BI "strtoq(const char *" nptr ", char **" endptr ", int " base );
.sp
.in -4n
.fi
con una definiciÛn completamente an·loga.
Dependiendo del tamaÒo de palabra de la arquitectura actual, 
Èsta puede ser equivalente a
.B strtoll()
o a
.BR strtol() .
.SH "CONFORME A"
.B strtol()
es conforme con SVID 3, BSD 4.3, ISO 9899 (C99) y POSIX, y
.B strtoll()
es conforme con ISO 9899 (C99) y POSIX-2001.
.SH "V…ASE TAMBI…N"
.BR atof (3),
.BR atoi (3),
.BR atol (3),
.BR strtod (3),
.BR strtoul (3)

