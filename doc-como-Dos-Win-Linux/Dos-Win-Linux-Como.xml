<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>

<articleinfo>

<title> Cómo pasar de DOS/Windows a Linux</title>

<author>
<firstname>Por Guido Gonzato <ulink
url="BORRAMEguido@ibogeo.df.unibo.it"
>BORRAMEguido@ibogeo.df.unibo.it</ulink
>
(Elimine el BORRAME)

 Traducido por David Marín Carreño, <ulink
url="davefx@bigfoot.com"
>davefx@bigfoot.com</ulink
></firstname>
</author>

<pubdate>v1.3.2 22 de Febrero de 1999. Traducción: 8 de Junio de 1999.</pubdate>

<abstract>

<para>
 Este documento <emphasis remap="it">Cómo</emphasis> está dedicado a todos los (pronto ex-)usuarios de
DOS y Windows que acaban de decidir pasarse a Linux, el clónico gratuito de
UNIX. El propósito de este documento es ayudar al lector a trasladar su
conocimiento de DOS y Windows al entorno Linux, así como dar indicaciones
acerca de intercambiar archivos y recursos entre ambos sistemas operativos.
</para>

</abstract>

</articleinfo>

<sect1>
<title>Introducción</title>

<sect2>
<title>¿Es Linux adecuado para usted?</title>

<para>
¿Quiere pasar del mundo DOS (esta definición incluye Windows) a Linux?
Buena idea: Linux es técnicamente superior a DOS, Windows 95 e incluso
Windows NT. Pero cuidado: puede no ser útil para usted. Estas son las
diferencias principales entre DOS y Linux:
</para>

<para>

<itemizedlist>
<listitem>

<para>
 Windows ejecuta Microsoft Office y muchos juegos; está claro que
es fácil de instalar y configurar; es notablemente inestable; su
rendimiento es pobre; los bloqueos del ordenador son frecuentes.

</para>
</listitem>
<listitem>

<para>
 Linux ejecuta StarOffice, mucho software técnico y unos pocos
juegos; puede ser difícil de instalar y configurar; es sólido como una roca;
rinde al máximo; los bloqueos de la máquina son muy raros.

</para>
</listitem>

</itemizedlist>

</para>

<para>
De usted depende el decidir qué necesita. Linux le da potencia, pero lleva
algún tiempo aprender a aprovecharla. Es decir, si necesita software comercial,
o si no le apetece aprender órdenes y conceptos nuevos, sería mejor que buscara
en otra parte. Sepa que muchos novatos lo dejan debido a las dificultades
iniciales.
</para>

<para>
Se está trabajando para hacer Linux más facil de usar, pero <emphasis>no espere ser
un experto en Linux a menos que lea mucha documentación y lo use durante al
menos unos meses</emphasis>. Linux no le dará resultados instantáneos.  A pesar de
estas advertencias, tengo un 100% de seguridad en que si usted es el
usuario correcto, entonces encontrará en Linux su Nirvana informático. Por
cierto, Linux + DOS/Win pueden coexistir sin problemas en la misma máquina.
</para>

<para>
Requisitos previos para la lectura de este Cómo. Asumiré que:
</para>

<para>

<itemizedlist>
<listitem>

<para>
 conoce las órdenes y conceptos básicos del DOS;

</para>
</listitem>
<listitem>

<para>
 Linux, posiblemente con el sistema X Window (X11 para abreviar), está
adecuadamente instalado en su ordenador;

</para>
</listitem>
<listitem>

<para>
 su intérprete de órdenes (el equivalente de <literal remap="tt">COMMAND.COM</literal>) es
<literal remap="tt">bash</literal>;

</para>
</listitem>

</itemizedlist>

</para>

<para>
A menos que se especifique lo contrario, toda la información de este
trabajo está dirigida al antiguo DOS. Hay información acerca de Windows en
algunos lugares de este documento, pero tenga en cuenta que Windows y
Linux son completamente distintos, al contrario que DOS, que es una
especie de hermano pobre de UNIX.
</para>

<para>
Dese cuenta también de que este trabajo no es ni una guía de configuración ni
un manual completo para los no iniciados.
</para>

<para>
La última versión de este documento está disponible en muchos formatos en
<literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/docs/howto"
>ftp://sunsite.unc.edu/pub/Linux/docs/howto</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>Ya está. Ahora cuénteme más.</title>

<para>
Ha instalado Linux y los programas que necesita en su ordenador. Se ha
proporcionado una cuenta (si no, ¡teclee <literal remap="tt">adduser suNombre</literal> <emphasis>ahora
mismo</emphasis>!) y Linux está ejecutándose. Acaba de introducir su nombre y su
contraseña, y ahora está mirando a la pantalla pensando...
<emphasis remap="it">¿Y ahora qué?</emphasis>
</para>

<para>
Bien, no se desespere. Puede hacer casi las mismas cosas que solía hacer
con DOS/Win, y muchas más. Si estuviera ejecutando DOS/Win en lugar de Linux,
realizaría alguna de las siguientes tareas: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
 ejecutar programas y crear, copiar, ver, borrar, imprimir, renombrar
ficheros; 

</para>
</listitem>
<listitem>

<para>
 cambiar de directorio, crearlos, borrarlos y listar sus contenidos;

</para>
</listitem>
<listitem>

<para>
 formatear disquetes y copiar ficheros de/hacia ellos;

</para>
</listitem>
<listitem>

<para>
 configuración del sistema;

</para>
</listitem>
<listitem>

<para>
 navegar por Internet;

</para>
</listitem>
<listitem>

<para>
 escribir ficheros <literal remap="tt">.BAT</literal> y programas en su lenguaje favorito;

</para>
</listitem>
<listitem>

<para>
 el restante 1%.
</para>
</listitem>

</itemizedlist>

</para>

<para>
Estará contento al saber que todas esas tareas pueden llevarse a cabo bajo
Linux de una manera similar a como se hacen bajo DOS. Bajo DOS, el usuario
medio usa muy pocos de las más de 100 órdenes disponibles: lo mismo,
hasta cierto punto, sucede con el Linux.
</para>

<sect3>
<title>Conceptos introductorios</title>

<para>
La mejor manera de aprender algo es mojándose los pies. Desde aquí le
animo a experimentar y «jugar» con Linux: a menos que entre como usuario
«root», no puede llegar a dañar el sistema de esa manera. Unos cuantos
conceptos:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Primero, cómo salir de Linux de manera segura. Si ve una pantalla en
modo texto, pulse &lt;Ctrl-Alt-Supr&gt;, espere a que el sistema realice
unas tareas y le diga que todo está bien, y entonces apague el ordenador.
Si está trabajando bajo el sistema X Window, pulse primero
&lt;Ctrl-Alt-Retroceder&gt;, y después &lt;Ctrl-Alt-Supr&gt;. <emphasis>Nunca</emphasis>
apague o reinicie el ordenador directamente: podría dañar el sistema de
ficheros;

</para>
</listitem>
<listitem>

<para>
Al contrario que en DOS o Windows, Linux tiene mecanismos de
seguridad intrínsecos, debido a su naturaleza multiusuario. Los ficheros y
los directorios tienen permisos asociados, y por lo tanto el
usuario normal puede no tener acceso a alguno de ellos; vea la sección
<xref linkend="Permisos"/>. DOS y Windows, por el contrario, le
dejarían machacar todo el contenido de su disco duro;

</para>
</listitem>
<listitem>

<para>
Hay un usuario especial denominado «root»: el administrador del
sistema, que tiene todo el poder sobre la máquina. Si usted trabaja con
su propio PC, también será root. Trabajar como root es <emphasis>peligroso</emphasis>:
cualquier error puede dañar seriamente o destruir el sistema de la misma
manera que con DOS/Win. No trabaje como root a menos que sea
absolutamente necesario;

</para>
</listitem>
<listitem>

<para>
Mucha de la complejidad de Linux viene de su extrema configurabilidad:
prácticamente cada característica y aplicación puede ser configurada mediante
uno o más archivos de configuración. La complejidad es el precio a pagar por la
potencia;

</para>
</listitem>
<listitem>

<para>
La redirección y el entubamiento (<emphasis remap="it">piping</emphasis>) son características
«secundarias» de DOS. En Linux pasan a ser muy importantes y mucho más
potentes. Se pueden enlazar órdenes para ejecutar tareas complejas.
Le recomiendo sobremanera que aprenda a usarlas.

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

<sect3>
<title>Obtención de ayuda</title>

<para>
Hay muchas maneras de conseguir ayuda con Linux. Las más importantes son:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<emphasis>Leyendo la documentación</emphasis> Aunque el documento CÓMO que está leyendo
puede servir como introducción a Linux, hay unos cuantos libros que debería
leer: <emphasis remap="it">Linux: Instalación y Primeros Pasos</emphasis> de Matt Welsh (<literal remap="tt"><ulink
url="http://sunsite.unc.edu/mdw/LDP/gs/gs.html"
>http://sunsite.unc.edu/mdw/LDP/gs/gs.html</ulink
></literal>), la <emphasis remap="it">Guía del
Usuario de Linux</emphasis> de Larry Greenfield (<literal remap="tt"><ulink
url="http://sunsite.unc.edu/pub/Linux/docs/linux-doc-project/users-guide"
>http://sunsite.unc.edu/pub/Linux/docs/linux-doc-project/users-guide</ulink
></literal>),
y la lista PUF de Linux (respuestas a Preguntas de Uso Frecuente) (<literal remap="tt"><ulink
url="http://sunsite.unc.edu/mdw/FAQ/Linux-FAQ.html"
>http://sunsite.unc.edu/mdw/FAQ/Linux-FAQ.html</ulink
></literal>.  Todos ellos pueden
conseguirse en <literal remap="tt"><ulink
url="http://lucas.hispalinux.es"
>http://lucas.hispalinux.es</ulink
></literal> en su versión traducida. Mantenga un
sentimiento de culpabilidad hasta haber leído al menos uno de ellos;

</para>
</listitem>
<listitem>

<para>
La documentacion de los paquetes instalados en la máquina puede
encontrarse usualmente en los directorios bajo <literal remap="tt">/usr/doc/</literal>;

</para>
</listitem>
<listitem>

<para>
Para conseguir ayuda acerca de las «órdenes internas» del intérprete
de órdenes, teclee <literal remap="tt">help</literal> o, mejor, <literal remap="tt">man bash</literal> o <literal remap="tt">info bash</literal>;

</para>
</listitem>
<listitem>

<para>
Para conseguir ayuda acerca de una orden, teclee <literal remap="tt">man orden</literal>, lo
cual invoca a la página del manual («man») correspondiente a <literal remap="tt">orden</literal>.
Alternativamente, teclee <literal remap="tt">info orden</literal>, lo cual mostrará la página info
relativa a <literal remap="tt">orden</literal>. info es un sistema de documentacion basado en
hipertexto. Quizá no es intuitivo en un principio. Finalmente, puede
intentar con <literal remap="tt">apropos orden</literal> o <literal remap="tt">whatis orden</literal>. Con todas estas
órdenes, pulse 'q' para salir.

</para>
</listitem>
<listitem>

<para>
Finalmente, en Internet: el lugar más adecuado para conseguir ayuda
es Usenet, en el foro <literal remap="tt"><ulink
url="news:comp.os.linux.setup"
>news:comp.os.linux.setup</ulink
></literal>. Por favor, no me envíe mensajes
solicitando ayuda, porque tengo bastante trabajo.

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<sect2>
<title>Convenciones</title>

<para>
A lo largo de este documento, los ejemplos seguirán el siguiente formato:
<literal remap="tt">&lt;...&gt;</literal> significa algo que debe ser especificado, mientras que
<literal remap="tt">[...]</literal> es algo opcional. Ejemplo:
</para>

<para>

<screen>
$ tar -tf &#60;fichero.tar&#62; [&#62; fichero_redir]
</screen>

</para>

<para>
Debe indicar <literal remap="tt">fichero.tar</literal>, pero la redirección a
<literal remap="tt">fichero_redir</literal> es opcional.
</para>

<para>
Desde ahora «LPM» significa «para más información Lea las Páginas del Manual».
No puedo dejar de recordar lo importante que es leer la documentación. «DosWin»
significa «DOS/Windows».
</para>

<para>
Cuando el simbolo de la línea de órdenes en un ejemplo sea '#', la
orden solo puede ser ejecutada por el root.
</para>

</sect2>

</sect1>

<sect1>
<title>Para el Impaciente</title>

<para>
¿Quiere empezar ya? Eche un vistazo a esta tabla: 
</para>

<para>

<screen>
DOS                     Linux                          Notas
------------------------------------------------------------------------------

ATTRIB (+-)attr fich    chmod &#60;modo&#62; fich              completamente distinto
BACKUP                  tar -Mcvf dispositivo dir/     ídem
CD nombredir\           cd nombredir/                  casi la misma sintaxis
COPY fich1 fich2        cp fich1 fich2                 idem
DEL fichero             rm fichero                     cuidado no hay undelete
DELTREE directorio      rm -R directorio/              idem
DIR                     ls                             no exact. misma sintaxis
DIR fich /S             find . -name fich              completamente distinto
EDIT fichero            vi fichero                     creo que no le gustara
                        joe fichero                    mas parecido al EDIT
EDLIN fichero           ed fichero                     olvídelo
FORMAT                  fdformat
                        mount, umount                  sintaxis muy distinta
HELP orden              man orden                      misma filosofia
                        info orden
MD directorio           mkdir directorio/              casi la misma sintaxis
MOVE fich1 fich2        mv fich1 fich2                 idem
NUL                     /dev/null                      idem
PRINT fichero           lpr fichero                    idem
PRN                     /dev/lp0,
                        /dev/lp1                       idem
RD directorio           rmdir directorio/              idem
REN fich1 fich2         mv fich1 fich2                 no para varios ficheros
RESTORE                 tar -Mxpvf device              sintaxis distinta
TYPE fichero            less fichero                   mucho mejor
WIN                     startx                         ¡polos opuestos!
</screen>

</para>

<para>
Si necesita más que una tabla de órdenes, continúe con las secciones
siguientes. 
</para>

</sect1>

<sect1>
<title>Encontrándose con bash</title>

<para>
Buenas noticias: con Linux usted escribe mucho menos en la línea de órdenes,
porque el intérprete <literal remap="tt">bash</literal> escribe por usted siempre que sea posible, y
goza de muy buenas características de edición de línea.  Para empezar, la tecla
flecha-arriba llama a las últimas líneas ejecutadas; pero aún hay más. Pulsar
&lt;TAB&gt; completa los nombres de ficheros y directorios, por lo que teclear
</para>

<para>

<screen>
$ ls /uTABloTABbTAB
</screen>

</para>

<para>
es como teclear
</para>

<para>

<screen>
$ ls /usr/local/bin
</screen>

</para>

<para>
Si hubiera ambigüedades, como al teclear
</para>

<para>

<screen>
$ ls /uTABloTABiTAB
</screen>

</para>

<para>
<literal remap="tt">bash</literal> para porque no sabe si usted se refiere a
<literal remap="tt">/usr/local/info</literal> o a <literal remap="tt">/usr/local/include</literal>.
Proporcione más caracteres y pulse &lt;TAB&gt; de nuevo.
</para>

<para>
Otras combinaciones de teclas útiles son &lt;ESC-BACKSPACE&gt; que borra una
palabra a la izquierda, mientras que &lt;ESC-D&gt; borra una palabra a la
derecha; &lt;ESC-F&gt; mueve el cursor una palabra a la derecha, &lt;ESC-B&gt;
a la izquierda; &lt;CTRL-A&gt; mueve el cursor al principio de la línea,
&lt;CTRL-E&gt; al final. La tecla &lt;ALT&gt; es equivalente a &lt;ESC&gt;.
</para>

<para>
Suficiente por ahora. Una vez que se acostumbre a estas combinaciones de
teclas, encontrará bastante molesto el intérprete de órdenes de DOS.
</para>

</sect1>

<sect1>
<title>Ficheros y Programas</title>

<sect2>
<title>Ficheros: Nociones preliminares</title>

<para>
Linux tiene una estructura de directorios y ficheros muy similar a la de
DOSWin. Los ficheros tienen nombres que obedecen unas normas especiales, están
guardados en directorios y algunos son ejecutables, y entre éstos,
la mayoría tiene opciones en la línea de órdenes. Incluso puede utilizar
comodines, redirección y tuberías. Sólo hay unas pocas diferencias:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Bajo DOS, los nombres de ficheros están en el llamado formato 8.3;
por ejemplo <literal remap="tt">NOTENOUG.TXT</literal>. Bajo Linux podemos hacerlo mejor. Si
instaló Linux usando un sistema de ficheros tal como ext2 o umsdos, puede
utilizar nombres más largos (hasta 255 caracteres), y con más de un punto
en ellos: por ejemplo, <literal remap="tt">Este_es.un.nombre_de.fichero.MUY.largo</literal>.
Fíjese que he utilizado tanto mayúsculas como minúsculas: en efecto... 
</para>
</listitem>
<listitem>

<para>
Las mayúsculas y las minúsculas en nombres de ficheros u órdenes son
distintas. Por lo tanto, <literal remap="tt">FICHERO.tar.gz</literal>, y <literal remap="tt">fichero.tar.gz</literal> son
dos ficheros distintos. <literal remap="tt">ls</literal> es una orden, <literal remap="tt">LS</literal> es un error;

</para>
</listitem>
<listitem>

<para>
Usuarios de Windows, cuidado al usar nombres de ficheros largos bajo
Linux. Si un nombre de fichero contiene espacios (no recomendado, pero
posible), debe encerrar el nombre de fichero entre comillas dobles cada
vez que se refiera a él. Por ejemplo:


<screen>
$ # la siguiente orden crea un directorio llamado "Mis ficheros antiguos"
$ mkdir "Mis ficheros antiguos"
$ ls
Mis ficheros antiguos   	bin		tmp
</screen>


No deben usarse ciertos caracteres: algunos son <literal remap="tt">!*$&amp;#</literal>.

</para>
</listitem>
<listitem>

<para>
No hay extensiones obligadas como .COM y .EXE para los programas, o .BAT
para los ficheros de procesamiento por lotes. Los ficheros ejecutables se
marcan con un asterisco cuando se ejecuta la orden <literal remap="tt">ls -F</literal>. Por ejemplo:


<screen>
$ ls -F
cindy.jpg    cjpg*    Soy_un_directorio/  mi_1er_script*  old~
</screen>


Los ficheros <literal remap="tt">cjpg*</literal> y <literal remap="tt">mi_1er_script*</literal> son «programas»
ejecutables. Bajo DOS, las copias de seguridad de los ficheros suelen acabar en
<literal remap="tt">.BAK</literal>, mientras que bajo Linux acaban con un virgulilla &tilde;. Un fichero
cuyo nombre empieza con un punto es considerado como oculto. Ejemplo: el
fichero <literal remap="tt">.Soy.un.fichero.oculto</literal> no se mostrará a un orden <literal remap="tt">ls</literal>; 

</para>
</listitem>
<listitem>

<para>
Las opciones de los programas bajo DOS se obtienen con <literal remap="tt">/opción</literal>.
En Linux se obtienen con <literal remap="tt">-opción</literal> o <literal remap="tt">--opción</literal>.  Ejemplo: <literal remap="tt">dir
/s</literal> se convierte en <literal remap="tt">ls -R</literal>. Fíjese en que muchos programas DOS
(como <literal remap="tt">PKZIP</literal> o <literal remap="tt">ARJ</literal>) utilizan opciones de tipo Unix.

</para>
</listitem>

</itemizedlist>

</para>

<para>
Ahora puede saltar a la sección <xref linkend="Traduciendo"/>,
pero yo de usted seguiría leyendo.
</para>

</sect2>

<sect2>
<title>Enlaces simbólicos</title>

<para>
Unix tiene un tipo de fichero que no existe bajo DOS: el enlace simbólico.
Puede pensar en él como un puntero o enlace a un fichero o a un directorio y
que puede utilizarse en lugar del fichero o del directorio al que apunta; es
similar a los «Accesos Directos» de Windows. Ejemplos de enlaces simbólicos son
<literal remap="tt">/usr/X11</literal>, que apunta a <literal remap="tt">/usr/X11R6</literal>; <literal remap="tt">/dev/modem</literal>, que
apunta a <literal remap="tt">/dev/ttyS0</literal> o a <literal remap="tt">/dev/ttyS1</literal>.
</para>

<para>
Para crear un enlace simbólico:
</para>

<para>

<screen>
$ ln -s &#60;fichero_o_directorio&#62; &#60;nombre_del_enlace&#62;
</screen>

</para>

<para>
Ejemplo:
</para>

<para>

<screen>
$ ln -s /usr/doc/g77/DOC g77manual.txt
</screen>

</para>

<para>
Ahora puede referirse a <literal remap="tt">g77manual.txt</literal> en lugar de
<literal remap="tt">/usr/doc/g77/DOC</literal>. Los enlaces aparecen en los listados de
directorio así:
</para>

<para>

<screen>
$ ls -F
g77manual.txt@
$ ls -l
l(muchas cosas...)             g77manual.txt -&#62; /usr/doc/g77/DOC
</screen>

</para>

</sect2>

<sect2 id="Permisos">
<title>Permisos y Propiedades </title>

<para>
Los ficheros y directorios de DOS tienen los siguientes atributos: <literal remap="tt">A</literal>
(fichero), <literal remap="tt">H</literal> (oculto), <literal remap="tt">R</literal> (sólo-lectura), y <literal remap="tt">S</literal> (sistema). 
Sólo <literal remap="tt">H</literal> y <literal remap="tt">R</literal> tienen sentido bajo Linux: los ficheros ocultos
comienzan con un punto, y los de sólo lectura, tienen activado el permiso
<literal remap="tt">r</literal>, pero nada más. 
</para>

<para>
Bajo Unix un fichero tiene «permisos» y un propietario, que pertenece a
un «grupo». Mire este ejemplo:
</para>

<para>

<screen>
$ ls -l /bin/ls
-rwxr-xr-x  1  root  bin  27281 Aug 15 1995 /bin/ls*
</screen>

</para>

<para>
El primer campo contiene los permisos del fichero <literal remap="tt">/bin/ls</literal>, que
pertenece a <literal remap="tt">root</literal>, del grupo <literal remap="tt">bin</literal>. Dejando la información restante
a un lado (el libro de Matt esta ahí para ese propósito), sólo recordaré
lo que significa <literal remap="tt">-rwxr-xr-x</literal> (de izquierda a derecha):
</para>

<para>
<literal remap="tt">-</literal> es el tipo de fichero (<literal remap="tt">-</literal> = fichero normal, <literal remap="tt">d</literal> =
directorio, <literal remap="tt">l</literal> = enlace, etc.); <literal remap="tt">rwx</literal> son los permisos del
propietario del fichero (leer, escribir, ejecutar); <literal remap="tt">r-x</literal> son los
permisos para el grupo del propietario del fichero (leer y ejecutar); (no
tocaré el concepto de grupo, puede pasar sin él mientras sea un novato ;-)
<literal remap="tt">r-x</literal> son los permisos para todos los demás usuarios (leer, ejecutar).
</para>

<para>
Esa es la razón de que no pueda borrar el fichero <literal remap="tt">/bin/ls</literal> a
menos que sea root: no tiene el permiso de escritura para hacer eso. Para
cambiar los permisos de un fichero, la orden es: 
</para>

<para>

<screen>
	
$ chmod &#60;quiénXperm&#62; &#60;fichero&#62;
</screen>

</para>

<para>
donde <literal remap="tt">quién</literal> podría ser:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">u</literal> usuario, que es el propietario,
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">g</literal> (grupo), 
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">o</literal> (otros).
</para>
</listitem>

</itemizedlist>

</para>

<para>
<literal remap="tt">X</literal> puede ser tanto <literal remap="tt">+</literal> como <literal remap="tt">-</literal>, y  <literal remap="tt">perm</literal> puede ser:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">r</literal> (lectura), 
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">w</literal> (escritura)
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">x</literal> (ejecución). 
</para>
</listitem>

</itemizedlist>

</para>

<para>
Ejemplos: 
</para>

<para>

<screen>
$ chmod u+x fichero
</screen>

</para>

<para>
esto habilita el permiso de ejecución para el propietario del fichero.
Atajo: <literal remap="tt">chmod +x fichero</literal>. 
</para>

<para>

<screen>
$ chmod go-wx fichero
</screen>

</para>

<para>
esto quita el permiso de escritura y de ejecución para todo el mundo menos
al usuario. 
</para>

<para>

<screen>
$ chmod ugo+rwx fichero
</screen>

</para>

<para>
esto le da a todo el mundo el permiso de lectura, escritura y ejecución. 
</para>

<para>

<screen>
$ chmod +s fichero
</screen>

</para>

<para>
esto convierte al fichero en <emphasis remap="it">setuid</emphasis> o <emphasis remap="it">suid</emphasis>; esto es, un fichero
que todo el mundo puede ejecutar con los privilegios de su dueño.
Normalmente, se encontrará con archivos suid del root; estos son, a
menudo, ficheros importantes del sistema, como el servidor X. 
</para>

<para>
Una manera más corta de referirse a los permisos es con números: <literal remap="tt">rwxr-xr-x</literal>
puede ser expresado como <literal remap="tt">755</literal> (cada letra corresponde a un bit:
<literal remap="tt">---</literal> es 0, <literal remap="tt">--x</literal> es 1, <literal remap="tt">-w-</literal> es 2, <literal remap="tt">-wx</literal> es 3...).  Parece
difícil, pero con algo de práctica el concepto se domina.  root, el
administrador y superusuario, puede cambiar los permisos de los ficheros de
todo el mundo. Hay mucha más información acerca de esto: LPM.
</para>

</sect2>

<sect2 id="Traduciendo">
<title>Ficheros: órdenes equivalentes
</title>

<para>
A la izquierda, las órdenes de DOS; a la derecha, sus equivalentes en Linux. 
</para>

<para>

<screen>
COPY:         cp
DEL:          rm
MOVE:         mv
REN:          mv
TYPE:         more, less, cat
</screen>

</para>

<para>
Operadores de redirección y de tuberías: 
</para>

<para>
<literal remap="tt">&lt; &gt; &gt;&gt;  |</literal>
</para>

<para>
Comodines: <literal remap="tt">* ?</literal>
</para>

<para>

<screen>
nul: /dev/null

prn, lpt1:  /dev/lp0 o /dev/lp1; lpr
</screen>

</para>

<para>
EJEMPLOS
</para>

<para>

<screen>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO&#62;ATTRIB +R FICH.TXT             $ chmod 400 fich.txt
C:\GUIDO&#62;COPY JOE.TXT JOE.DOC           $ cp joe.txt joe.doc
C:\GUIDO&#62;COPY *.* TOTAL                 $ cat * &#62; total
C:\GUIDO&#62;COPY FRACTALS.DOC PRN          $ lpr fractals.doc
C:\GUIDO&#62;DEL TEMP                       $ rm temp
C:\GUIDO&#62;DEL *.BAK                      $ rm *~
C:\GUIDO&#62;MOVE PAPER.TXT TMP\            $ mv paper.txt tmp/
C:\GUIDO&#62;REN PAPER.TXT PAPER.ASC        $ mv paper.txt paper.asc
C:\GUIDO&#62;PRINT LETTER.TXT               $ lpr letter.txt
C:\GUIDO&#62;TYPE LETTER.TXT                $ more letter.txt
C:\GUIDO&#62;TYPE LETTER.TXT                $ less letter.txt
C:\GUIDO&#62;TYPE LETTER.TXT &#62; NUL          $ cat letter.txt &#62; /dev/null
        no disponible                   $ more *.txt *.asc
        no disponible                   $ cat section*.txt | less
</screen>

</para>

<para>
Notas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">*</literal> es más inteligente bajo Linux: <literal remap="tt">*</literal> equivale a todos los
ficheros excepto los ocultos; <literal remap="tt">.*</literal> equivale a todos los ficheros ocultos;
<literal remap="tt">*.*</literal> equivale sólo a aquellos ficheros que tienen un punto en medio del
nombre, seguido de otros caracteres; <literal remap="tt">p*r</literal> equivaldría tanto a <literal remap="tt">peor</literal>
como a <literal remap="tt">por</literal>;  <literal remap="tt">*c*</literal> equivaldría tanto a <literal remap="tt">pecado</literal> como a <literal remap="tt">peca</literal>. 

</para>
</listitem>
<listitem>

<para>
Cuando utilice <literal remap="tt">more</literal>, pulse espacio para ir leyendo a través del
fichero, <literal remap="tt">q</literal> o Ctrl-C para salir. <literal remap="tt">less</literal> es más intuitivo y permite
utilizar las teclas del cursor;

</para>
</listitem>
<listitem>

<para>
No hay <literal remap="tt">UNDELETE</literal>, así que <emphasis>piénselo dos veces</emphasis> antes de borrar
cualquier cosa;

</para>
</listitem>
<listitem>

<para>
Además de los &lt; &gt; &gt;&gt; del DOS, Linux tiene el operador
<literal remap="tt">2&gt;</literal> para redirigir los mensajes de error (stderr); más aún, el
operador <literal remap="tt">2&gt;&amp;1</literal> redirige stderr a stdout (la salida estándar),
mientras que <literal remap="tt">1&gt;&amp;2</literal> redirige stdout a stderr;

</para>
</listitem>
<listitem>

<para>
Linux tiene otro comodín: los corchetes <literal remap="tt">[]</literal>. Usar <literal remap="tt">[abc]*</literal>
equivale a los ficheros que empiezan por <literal remap="tt">a</literal>, por <literal remap="tt">b</literal> o por <literal remap="tt">c</literal>; 
<literal remap="tt">*[I-N,1,2,3]</literal> equivale a los ficheros que acaban por <literal remap="tt">I, J, K, L,
M, N, 1, 2, 3</literal>;

</para>
</listitem>
<listitem>

<para>
No hay un <literal remap="tt">RENAME</literal> como en DOS; esto es, <literal remap="tt">mv *.xxx *.yyy</literal> no
funciona. Un orden similar a REN está disponible en
<literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/utils/file"
>ftp://sunsite.unc.edu/pub/Linux/utils/file</ulink
></literal>;

</para>
</listitem>
<listitem>

<para>
Use <literal remap="tt">cp -i</literal> y <literal remap="tt">mv -i</literal> para ser avisado cuando un fichero vaya
a ser sobreescrito. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Ejecución de programas: Multitarea y Sesiones</title>

<para>
Para ejecutar un programa, escriba su nombre tal y como lo haría bajo DOS.  Si
el directorio ---vea la sección <xref linkend="Directorios"/>---
donde el programa está guardado está incluido en la variable de entorno
<literal remap="tt">PATH</literal> ---sección <xref linkend="Inicializacion"/>--- el
programa comenzará a ejecutarse.  Excepción: al contrario que bajo DOS, en
Linux un programa localizado en el directorio actual no se ejecutará a manos
que el directorio actual (simbolizado por «<literal remap="tt">.</literal>») esté incluido en el PATH.
Para evitarlo, suponiendo que el programa se llame <literal remap="tt">prog</literal>, teclee
<literal remap="tt">./prog</literal>.
</para>

<para>
Este es el aspecto típico de una línea de órdenes:
</para>

<para>

<screen>
$ orden [-o1 [-o2] ... [-on]] [par1 [par2] ... [parn]]  [&#60; input] [&#62; output]
</screen>

</para>

<para>
donde <literal remap="tt">-o1</literal>, ..., <literal remap="tt">-on</literal> son las opciones del programa, <literal remap="tt">par1</literal>,
..., <literal remap="tt">parn</literal> son los parámetros del programa. Puede encadenar varias
órdenes en la línea de órdenes: 
</para>

<para>

<screen>
$ orden1 ; orden2 ; ... ; ordenN
</screen>

</para>

<para>
Esto es todo acerca de ejecutar órdenes, pero es fácil ir un paso más
allá. Una de las principales razones para usar Linux es que es un sistema
operativo multitarea ---puede ejecutar varios programas (a partir de
ahora, procesos) a la vez---. Puede lanzar procesos en segundo plano
(<emphasis remap="it">background</emphasis>)  y seguir trabajando inmediatamente. Más aún, Linux
permite tener varias sesiones abiertas simultáneamente: es como tener
muchos ordenadores en los que trabajar a la vez. 
</para>

<para>

<itemizedlist>
<listitem>

<para>
 Para cambiar a la sesión 1..6 de las consolas virtuales, presione
&lt;ALT-F1&gt; ... &lt;ALT-F6&gt;

</para>
</listitem>
<listitem>

<para>
 Para comenzar una nueva sesión en la misma consola virtual sin
dejar la actual, teclee <literal remap="tt">su - &lt;nombre_de_usuario&gt;</literal>. Ejemplo:
<literal remap="tt">su - root</literal>.  Esto es útil, por ejemplo, cuando se necesita realizar
una tarea que sólo el root puede hacer.

</para>
</listitem>
<listitem>

<para>
 Para acabar una sesión, teclee <literal remap="tt">exit</literal>. Si hay trabajos parados
(ver más abajo), será avisado.

</para>
</listitem>
<listitem>

<para>
 Para lanzar un proceso en segundo plano, añada un '<literal remap="tt">&amp;</literal>',
al final de la línea de órdenes:

</para>
</listitem>

</itemizedlist>

</para>

<para>

<screen>
$ nomprog [-opciones] [parametros] [&#60; input] [&#62; output] &#38;
[1] 123
</screen>

</para>

<para>

<itemizedlist>
<listitem>

<para>
el intérprete de órdenes identifica el proceso con un número de
trabajo (p.e. <literal remap="tt">[1]</literal>; ver más abajo), y con un PID (123 en nuestro
ejemplo).

</para>
</listitem>
<listitem>

<para>
Para ver cuántos procesos hay, teclee <literal remap="tt">ps ax</literal>. Esto generará
una lista de procesos actualmente en ejecución.

</para>
</listitem>
<listitem>

<para>
 Para matar (finalizar) un proceso, teclee <literal remap="tt">kill &lt;PID&gt;</literal>.
Puede que necesite matar un proceso cuando no sepa cómo cerrarlo de la
manera correcta...  ;-). A veces, sólo podrá matar un proceso con
<literal remap="tt">kill -SIGKILL &lt;PID&gt;</literal>.

Además, el intérprete de órdenes permite suspender temporalmente (parar)
un proceso, mandar un proceso al segundo plano, y traer un proceso del
segundo plano al primer plano. En este contexto, los procesos son
denominados «trabajos» (jobs).

</para>
</listitem>
<listitem>

<para>
 Para ver cuántos trabajos hay, teclee <literal remap="tt">jobs</literal>. Aquí los trabajos
son identificados por su número de trabajo, no por su PID.

</para>
</listitem>
<listitem>

<para>
 Para parar un proceso ejecutándose en primer plano pulse
&lt;CTRL-C&gt; (no siempre funciona).

</para>
</listitem>
<listitem>

<para>
 Para suspender un proceso ejecutándose en primer plano, pulse
&lt;CTRL-Z&gt; (ídem al anterior).

</para>
</listitem>
<listitem>

<para>
 Para mandar un proceso suspendido al segundo plano (convirtiéndolo
en trabajo), teclee <literal remap="tt">bg &lt;trabajo&gt;</literal>.

</para>
</listitem>
<listitem>

<para>
 Para traer un trabajo al primer plano, teclee
<literal remap="tt">fg &lt;%trabajo&gt;</literal>. Para traer al primer plano el último trabajo
enviado al segundo plano, simplemente teclee <literal remap="tt">fg</literal>.

</para>
</listitem>
<listitem>

<para>
 Para matar un trabajo, teclee <literal remap="tt">kill &lt;%trabajo&gt;</literal>
donde <literal remap="tt">trabajo</literal> puede ser 1, 2, 3...

</para>
</listitem>

</itemizedlist>

</para>

<para>
Usando estas órdenes puede formatear un disco, comprimir un puñado de
ficheros, compilar un programa, y descomprimir un fichero simultáneamente,
y todavía tener la línea de órdenes a su disposición. Inténtelo con
Windows, sólo para ver la diferencia de prestaciones (siempre que no se le
cuelgue, claro).
</para>

</sect2>

<sect2>
<title>Ejecución de programas en sistemas remotos</title>

<para>
Para ejecutar un programa en una máquina remota cuyo nombre es
<literal remap="tt">maquina.remota.edu</literal>, teclee:
</para>

<para>

<screen>
$ telnet maquina.remota.edu
</screen>

</para>

<para>
Tras introducir su nombre de usuario y contraseña, arranque su programa
favorito. Obviamente, debe tener una cuenta en la máquina remota.
</para>

<para>
Si tiene X11, puede incluso ejecutar una aplicación X en un ordenador
remoto, mostrándolo en su pantalla de X. Supongamos
<literal remap="tt">maquina.remota.edu</literal> la máquina X remota y <literal remap="tt">sistema.linux.yo</literal> su
máquina Linux. Para ejecutar desde <literal remap="tt">sistema.linux.yo</literal> un programa X
que reside en <literal remap="tt">maquina.remota.edu</literal>, haga lo siguiente:
</para>

<para>

<itemizedlist>
<listitem>

<para>
arranque X, arranque un xterm o un emulador de terminal
equivalente, y después teclee:


<screen>
$ xhost +maquina.remota.edu
$ telnet maquina.remota.edu
</screen>


</para>
</listitem>
<listitem>

<para>
tras introducir su nombre y contraseña, teclee:


<screen>
remote:$ DISPLAY=sistema.linux.yo:0.0
remote:$ programa &#38;
</screen>


(en vez de <literal remap="tt">DISPLAY...</literal>, puede que tenga que escribir <literal remap="tt">setenv
DISPLAY sistema.linux.yo:0.0</literal>. Depende del intérprete de órdenes remoto).

</para>
</listitem>

</itemizedlist>

</para>

<para>
Y.. ¡voila! Ahora <literal remap="tt">programa</literal> se iniciará en <literal remap="tt">maquina.remota.edu</literal> y
se mostrará en su máquina. Aunque mejor no intente esto con un módem,
porque sería demasiado lento para poder utilizarse. Además: es un método
muy inseguro: por favor, lea el «mini-COMO de Aplicaciones X Remotas» en
<literal remap="tt"><ulink
url="http://sunsite.unc.edu/LDP/HOWTO/mini/Remote-X-Apps"
>http://sunsite.unc.edu/LDP/HOWTO/mini/Remote-X-Apps</ulink
></literal>.
</para>

</sect2>

</sect1>

<sect1 id="Directorios">
<title>Gestión de Directorios
</title>

<sect2>
<title>Directorios: Nociones preliminares</title>

<para>
Hemos visto las diferencias entre los ficheros de DOSWin y Linux. Entre
directorios, bajo DOSWin el directorio raíz es <literal remap="tt">&bsol;</literal> y bajo Linux es
<literal remap="tt">/</literal> . De manera similar, los directorios anidados se separan
mediante <literal remap="tt">&bsol;</literal> en DOSWin y mediante <literal remap="tt">/</literal> en Linux. Ejemplo de
rutas de fichero: 
</para>

<para>

<screen>
DOS:    C:\PAPERS\GEOLOGY\MID_EOC.TEX
Linux:  /home/guido/papers/geology/middle_eocene.tex
</screen>

</para>

<para>
Como es normal, <literal remap="tt">..</literal> es el directorio padre y <literal remap="tt">.</literal> es el directorio
actual.  Recuerde que el sistema no le dejará hacer <literal remap="tt">cd</literal>, <literal remap="tt">rd</literal> o
<literal remap="tt">md</literal> donde usted quiera. Cada usuario tiene sus propias cosas en un
directorio llamado `home', directorio personal o de usuario, cedido por el
administrador del sistema; por ejemplo, en mi PC mi directorio personal es
<literal remap="tt">/home/guido</literal>.
</para>

</sect2>

<sect2 id="Permisos-de-directorios">
<title>Permisos de directorios. </title>

<para>
Los directorios también tienen permisos. Lo que hemos visto en la sección
<xref linkend="Permisos"/> también rige para los directorios (usuario,
grupo, y otros). Para un directorio, <literal remap="tt">rx</literal> significa que puede cambiar a ese
directorio, y <literal remap="tt">w</literal> significa que puede crear o borrar ficheros en él (según
los permisos de los ficheros, por supuesto), o el directorio mismo.
</para>

<para>
Por ejemplo, para prevenir que otros usuarios husmeen en
<literal remap="tt">/home/guido/text</literal>: 
</para>

<para>

<screen>
$ chmod o-rwx /home/guido/text
</screen>

</para>

</sect2>

<sect2 id="dirtrad">
<title>Equivalencia de órdenes
</title>

<para>

<screen>
DIR:            ls, find, du
CD:             cd, pwd
MD:             mkdir
RD:             rmdir
DELTREE:        rm -R
MOVE:           mv
</screen>

</para>

<para>
EJEMPLOS
</para>

<para>

<screen>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO&#62;dir                            $ ls
C:\GUIDO&#62;dir file.txt                   $ ls file.txt
C:\GUIDO&#62;dir *.h *.c                    $ ls *.h *.c
C:\GUIDO&#62;dir/p                          $ ls | more
C:\GUIDO&#62;dir/a                          $ ls -l
C:\GUIDO&#62;dir *.tmp /s                   $ find / -name "*.tmp"
C:\GUIDO&#62;cd                             $ pwd
        n/a - ver nota                  $ cd
        idem                            $ cd ~
        idem                            $ cd ~/temp
C:\GUIDO&#62;cd \otros                      $ cd /otros
C:\GUIDO&#62;cd ..\temp\trash               $ cd ../temp/trash
C:\GUIDO&#62;md newprogs                    $ mkdir newprogs
C:\GUIDO&#62;move prog ..                   $ mv prog ..
C:\GUIDO&#62;md \progs\turbo                $ mkdir /progs/turbo
C:\GUIDO&#62;deltree temp\trash             $ rm -R temp/trash
C:\GUIDO&#62;rd newprogs                    $ rmdir newprogs
C:\GUIDO&#62;rd \progs\turbo                $ rmdir /progs/turbo
</screen>

</para>

<para>
Notas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
 Cuando se use <literal remap="tt">rmdir</literal>, el directorio a borrar debe estar vacío.
Para borrar un directorio y todos sus contenidos, use <literal remap="tt">rm -rf</literal> (bajo su
propia responsabilidad). 

</para>
</listitem>
<listitem>

<para>
 El carácter <literal remap="tt">&tilde;</literal> es un atajo para el nombre de su
directorio personal. Las órdenes <literal remap="tt">cd</literal> o <literal remap="tt">cd &tilde;</literal> le llevarán
a su directorio personal desde dondequiera que esté; la orden <literal remap="tt">cd
&tilde;/tmp</literal> le llevará a <literal remap="tt">/home/su_directorio_de_usuario/tmp</literal>.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">cd -</literal> «deshace» el último <literal remap="tt">cd</literal>.

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

</sect1>

<sect1 id="Disquetes">
<title>Disquetes, discos duros y similares.
</title>

<para>
Hay dos maneras de adminsitrar dispositivos bajo Linux: a la manera de DOS
y a la manera de UNIX. Elija.
</para>

<sect2>
<title>Administración de dispositivos en «modo DOS»</title>

<para>
La mayor parte de las distribuciones de Linux incluyen las Mtools, un
conjunto de órdenes que son perfectamente equivalentes a sus
correspondientes órdenes en DOS, pero que empiezan con una 'm': p.e.,
<literal remap="tt">mformat</literal>, <literal remap="tt">mdir</literal>, <literal remap="tt">mmd</literal>, <literal remap="tt">mdel</literal>, y así. Pueden incluso
conservar los nombres de ficheros largos, pero no los permisos de los
ficheros. Si usted configura las Mtools editando un fichero llamado
<literal remap="tt">/etc/mtools.conf</literal> (se proporciona un ejemplo en la
distribución), podrá también acceder a la partición DOS/Win, el CD-ROM,
y la unidad Zip. Sin embargo, para formatear un disco sin formato, la
orden <literal remap="tt">mformat</literal> no funcionará. Como root, tendrá que ejecutar esta
orden con anterioridad: <literal remap="tt"> fdformat /dev/fd0H1440 </literal>
</para>

<para>
Nota: no podrá acceder a los ficheros del disquete con una orden como, por
ejemplo, <literal remap="tt">less a:fich.txt</literal>. Esta es la desventaja de la manera DOS
de montar discos.
</para>

</sect2>

<sect2>
<title>Administración de dispositivos en «modo UNIX»</title>

<para>
UNIX maneja los dispositivos de una manera distinta. No hay unidades
separadas como A: o C:; un disco, sea un disquete o lo que sea, pasa a
ser parte del sistema de ficheros local mediante una operación denominada
«montaje» (mounting). Cuando se acaba de utilizar el disco, antes de
extraerlo, debe «desmontarlo» (unmount).
</para>

<para>
Físicamente, dar formato a un disco es una cosa, hacer un sistema de
ficheros en él es otra. La orden de DOS <literal remap="tt">FORMAT A:</literal> hace ambas cosas,
pero bajo Linux son acciones separadas. Para dar formato a un disco, mire
más arriba. Para crear un sistema de ficheros:
</para>

<para>

<screen>
# mkfs -t ext2 -c /dev/fd0H1440
</screen>

</para>

<para>
Puede utilizar <literal remap="tt">dos</literal>, <literal remap="tt">vfat</literal> (recomendado) u otros formatos en
lugar de <literal remap="tt">ext2</literal>. Una vez que el disco esté preparado, móntelo con la
orden
</para>

<para>

<screen>
# mount -t ext2 /dev/fd0 /mnt
</screen>

</para>

<para>
especificando el sistema de ficheros correcto si no utiliza <literal remap="tt">ext2</literal>.
Ahora usted puede acceder a los ficheros del disquete. Todo lo que solía
hacer con A: o B: se hace ahora utilizando en su lugar <literal remap="tt">/mnt</literal>.
Ejemplos:
</para>

<para>

<screen>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO&#62;DIR A:                         $ ls /mnt
C:\GUIDO&#62;COPY A:*.*                     $ cp /mnt/* .
C:\GUIDO&#62;COPY *.ZIP A:                  $ cp *.zip /mnt
C:\GUIDO&#62;EDIT A:FILE.TXT                $ jstar /mnt/file.txt
C:\GUIDO&#62;A:                             $ cd /mnt
A:&#62; _                                   /mnt/$ _
</screen>

</para>

<para>
Cuando haya acabado, antes de sacar el disco <emphasis>deberá</emphasis> desmontarlo con
la orden 
</para>

<para>

<screen>
# umount /mnt
</screen>

</para>

<para>
Obviamente, debe hacer un <literal remap="tt">fdformat</literal> y un <literal remap="tt">mkfs</literal> sólo a los discos no
formateados, que no han sido usados nunca. Si quiere utilizar la unidad B:,
ponga <literal remap="tt">fd1H1440</literal> y <literal remap="tt">fd1</literal> en lugar de <literal remap="tt">fd0H1440</literal> y <literal remap="tt">fd0</literal> en los
ejemplos anteriores.
</para>

<para>
No hace falta decir que la manera de proceder con los disquetes también
funciona con otros dispositivos, como por ejemplo, otro disco duro o una
unidad CD-ROM. Esto es para montar el CD-ROM: 
</para>

<para>

<screen>
# mount -t iso9660 /dev/cdrom /mnt
</screen>

</para>

<para>
Esta era la manera «oficial» de montar discos, pero hay un truco. Como
es algo incómodo tener que ser root para montar un disquete o un CD-ROM,
puede darse permisos a cada usuario de esta manera:
</para>

<para>

<itemizedlist>
<listitem>

<para>
como root, hacer lo siguiente:


<screen>
# mkdir /mnt/a: ; mkdir /mnt/floppy ; mkdir /mnt/cdrom
# chmod 777 /mnt/floppy* /mnt/cd*
# # asegúrese de que el dispositivo CD-ROM es el adecuado
# chmod 666 /dev/hdb ; chmod 666 /dev/fd*
</screen>


</para>
</listitem>
<listitem>

<para>
añadir en <literal remap="tt">/etc/fstab</literal> las siguientes líneas:


<screen>
/dev/cdrom        /mnt/cdrom    iso9660   ro,user,noauto          0       0
/dev/fd0          /mnt/floppy   vfat      user,noauto             0       0
</screen>

</para>
</listitem>

</itemizedlist>

</para>

<para>
Ahora, para montar un disquete DOS y un CD-ROM:
</para>

<para>

<screen>
$ mount /mnt/floppy
$ mount /mnt/cdrom
</screen>

</para>

<para>
Cualquier usuario puede acceder a <literal remap="tt">/mnt/floppy</literal>,
<literal remap="tt">/mnt/a:</literal>, y <literal remap="tt">/mnt/cdrom</literal>. Recuerde que si considera
importante la seguridad, dejar que todo el mundo pueda montar discos de
esta manera constituye un gran agujero.
</para>

<para>
Dos órdenes útiles son <literal remap="tt">df</literal>, que da información acerca de los sistemas
de ficheros montados, y <literal remap="tt">du nombredir</literal> que informa del espacio de
disco consumido por el directorio.
</para>

</sect2>

<sect2 id="Copias-de-Seguridad">
<title>Copias de seguridad </title>

<para>
Hay muchos paquetes que pueden servirle, pero lo más simple para hacer una
copia de seguridad multivolumen (como root) es:
</para>

<para>

<screen>
# tar -M -cvf /dev/fd0H1440 /directorio_a_guardar
</screen>

</para>

<para>
Asegúrese de tener un disquete formateado en la unidad, y otros ya
preparados. Para restaurar sus ficheros, inserte el primer disquete en la
unidad y utilice: 
</para>

<para>

<screen>
# tar -M -xpvf /dev/fd0H1440
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>¿Qué pasa con Windows?</title>

<para>
El «equivalente» a Windows es el sistema gráfico X Window, o X11, para
abreviar. Al contrario que Windows o el Mac, X11 no fue diseñado para
facilitar el uso o para lograr una mejor apariencia, sino para
proporcionar utilidades gráficas a las estaciones de trabajo UNIX. Estas
son las principales diferencias:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Mientras que la apariencia y comportamiento de Windows es similar
en todo el mundo, en X11 esto no es así: es mucho más configurable. La
apariencia general de X11 está encomendada a un programa clave llamado
«gestor de ventanas» (window manager), del cual hay una amplia oferta
entre la que escoger: <literal remap="tt">fvwm</literal>, basico pero agradable y eficiente con
el consumo de memoria, <literal remap="tt">fvwm2-95</literal>, <literal remap="tt">Afterstep</literal>, <literal remap="tt">WindowMaker</literal>,
<literal remap="tt">Enlightenment</literal>, y muchos más. El gestor de ventanas es normalmente
llamado por un fichero denominado <literal remap="tt">.xinitrc</literal>;

</para>
</listitem>
<listitem>

<para>
Su gestor de ventanas puede ser configurado de manera que las
ventanas actúen como en Windows: si usted hace click en ella, viene al
primer plano. Otra posibilidad es que venga al primer plano si el puntero
del ratón está sobre ella («focus»). También, el lugar de emplazamiento de
las ventanas en la pantalla puede ser automático o interactivo: si un
marco extraño aparece en lugar de su programa, haga click con el botón
izquierdo del ratón donde quiera que aparezca;

</para>
</listitem>
<listitem>

<para>
La mayor parte de las acciones pueden configurarse editando uno o
más ficheros de configuración. Lea la documentación de su gestor de
ventanas; el archivo de configuración puede ser <literal remap="tt">.fvwmrc</literal>,
<literal remap="tt">.fvwm2rc95</literal>, <literal remap="tt">.steprc</literal>, etc. Un fichero ejemplo de configuración
suele encontrarse en
<literal remap="tt">/etc/X11/nombre-de-gestor-de-ventanas/system.nombre-gestor-ventanas</literal>;

</para>
</listitem>
<listitem>

<para>
Las aplicaciones X11 se escriben empleando unas bibliotecas
especiales (<emphasis remap="it">widget sets</emphasis>); como hay muchas disponibles, las aplicaciones
tienen aspectos distintos. Las más básicas son aquellas que usan los
controles (widgets) Athena (con aspecto 2D; <literal remap="tt">xdvi</literal>, <literal remap="tt">xman</literal>,
<literal remap="tt">xcalc</literal>); otras usan Motif (<literal remap="tt">netscape</literal>), otras aún usan Tcl/Tk,
Xforms, Qt, Gtk, y otra más. Casi todas esas bibliotecas dan el mismo
aspecto y comportamiento que Windows;

</para>
</listitem>
<listitem>

<para>
La manera de comportarse, desafortunadamente, puede no ser
coherente. Por ejemplo, si selecciona una línea de texto utilizando el
ratón y pulsa &lt;RETROCEDER&gt;, esperará que la línea desaparezca,
¿verdad? Esto no sucede con aplicaciones basadas en Athena, pero sucede
con aplicaciones basadas en otros controles;

</para>
</listitem>
<listitem>

<para>
El cómo funcionen las barras de desplazamiento y el cambio de
tamaño dependerá del gestor de ventanas y el juego de widgets. Pista: si
se encuentra con que las barras de desplazamiento no se comportan como
usted esperaba, utilice el botón central o los dos botones juntos para
moverla;

</para>
</listitem>
<listitem>

<para>
Las aplicaciones no tienen un icono por defecto, pero pueden tener
muchos. La mayor parte de los gestores de ventanas proporcionan un menu
al que se tiene acceso haciendo click en el escritorio («ventana raíz»);
no hará falta decir que el menú puede ser configurado. Para cambiar la
apariencia de la ventana raíz, utilice <literal remap="tt">xsetroot</literal> o <literal remap="tt">xloadimage</literal>;

</para>
</listitem>
<listitem>

<para>
El portapapeles sólo puede contener texto, y se comporta de manera
extraña. Cada vez que selecciona texto, se copia automáticamente al
portapapeles: vaya a cualquier sitio y pulse en botón central del ratón
para pegarlo. Hay una aplicación, <literal remap="tt">xclipboard</literal>, que proporciona varios
portapapeles;

</para>
</listitem>
<listitem>

<para>
Arrastrar y soltar es una opción, y está disponible solamente si
usted utiliza aplicaciones X11 que la permitan.

</para>
</listitem>

</itemizedlist>

</para>

<para>
Para ahorrar memoria, uno debería utilizar aplicaciones que usaran las
mismas bibliotecas, pero esto es difícil de hacer en la práctica.
</para>

<para>
Hay proyectos que pretenden hacer que X11 tenga una apariencia y
comportamiento tan coherente como Windows. Gnome,
<literal remap="tt"><ulink
url="http://www.gnome.org"
>http://www.gnome.org</ulink
></literal>
y KDE, <literal remap="tt"><ulink
url="www.kde.org"
>www.kde.org</ulink
></literal> son un
ejemplo. Pruébelos: no echará de menos su escritorio Windows nunca más.
</para>

</sect1>

<sect1>
<title>Personalización del sistema</title>

<sect2 id="Inicializacion">
<title>Ficheros de inicialización del sistema
</title>

<para>
Dos ficheros importantes bajo DOS son el <literal remap="tt">AUTOEXEC.BAT</literal> y el
<literal remap="tt">CONFIG.SYS</literal>, los cuales se utilizan al rearrancar el sistema para
inicializarlo, dar valores a algunas variables de entorno como <literal remap="tt">PATH</literal> y
<literal remap="tt">FILES</literal>, y posiblemente lanzar un programa o fichero de procesamiento por
lotes. Bajo Linux hay varios ficheros de inicialización, algunos de los cuales
no deberían ser modificados hasta que usted supiese con seguridad lo que está
haciendo. De todos modos, estos son los más importantes:
</para>

<para>

<screen>
FICHEROS             NOTAS
/etc/inittab         ¡no tocar por ahora!
/etc/rc.d/*          idem
</screen>

</para>

<para>
Si todo lo que necesita es establecer el PATH y otras variables de
entorno, o desea cambiar los mensajes del login o ejecutar
automáticamente un programa tras iniciar una sesión, eche un vistazo a
los siguientes ficheros:
</para>

<para>

<screen>
FICHEROS                        NOTAS
/etc/issue                      establece el mensaje de antes del login
/etc/motd                       establece el mensaje de despues del login
/etc/profile                    establece $PATH y otras variables, etc.
/etc/bashrc                     define alias y funciones, etc. (ver mas abajo)
/home/su_home/.bashrc           define sus alias y sus funciones
/home/su_home/.bash_profile   o
/home/su_home/.profile          establece el entorno y ejecuta sus programas 
</screen>

</para>

<para>
Si el último fichero existe (fíjese en que es un fichero oculto), se leerá
tras el inicio de sesión y se ejecutarán las órdenes en él almacenados.
</para>

<para>
Ejemplo; mire este <literal remap="tt">.bash_profile</literal>:
</para>

<para>

<screen>
# Soy un comentario
echo Entorno:
printenv | less   # equivalente de la orden SET bajo DOS
alias d='ls -l'   # es facil comprender lo que es un alias
alias up='cd ..'
echo "Recuerde que su path es "$PATH
echo "Hoy es `date`"  # usa la salida de la orden 'date'
echo "Que tenga un buen dia, "$LOGNAME
# Lo siguiente es una funcion del shell
ctgz() # Lista los contenidos de un fichero .tar.gz 
{
  for file in $*
  do
    gzip -dc ${file} | tar tf -
  done
}
# fin de .profile
</screen>

</para>

<para>
<literal remap="tt">$PATH</literal> y <literal remap="tt">$LOGNAME</literal>, lo adivinó, son variables de
entorno.  Hay muchas otras con las que jugar; para buscar ejemplos, LPM
de aplicaciones como <literal remap="tt">less</literal>.
</para>

<para>
Poner esta línea en su <literal remap="tt">/etc/profile</literal> le proporcionará el
equivalente de <literal remap="tt">PROMPT $P$G</literal>;
</para>

<para>

<screen>
export PS1="\w\\$ "
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>Ficheros de inicialización de programas</title>

<para>
Bajo Linux, casi todo puede ser configurado de acuerdo con sus
necesidades. La mayoría de los programas tienen uno o más ficheros de
inicialización con los que puede trastear, a menudo llamados
<literal remap="tt">.nombreprogramarc</literal>, situados en su directorio <literal remap="tt">home</literal>. Los primeros
que querrá modificar son:
</para>

<para>

<itemizedlist>
<listitem>

<para>
 <literal remap="tt"> .inputrc</literal>: usado por <literal remap="tt">bash</literal> para definir significados de
teclas;
</para>
</listitem>
<listitem>

<para>
 <literal remap="tt"> .xinitrc</literal>: usado por <literal remap="tt">startx</literal> para inicializar el sistema
X Window;
</para>
</listitem>
<listitem>

<para>
 <literal remap="tt"> .fvwmrc</literal>: usado por el gestor de ventanas <literal remap="tt">fvwm</literal>. 
</para>
</listitem>
<listitem>

<para>
 <literal remap="tt"> .joerc</literal>: usado por el editor <literal remap="tt">joe</literal>;
</para>
</listitem>
<listitem>

<para>
 <literal remap="tt"> .jedrc</literal>: usado por el editor <literal remap="tt">jed</literal>;
</para>
</listitem>
<listitem>

<para>
 <literal remap="tt"> .pinerc</literal>: usado por el lector de correo <literal remap="tt">pine</literal>;
</para>
</listitem>
<listitem>

<para>
 <literal remap="tt"> .Xdefault</literal>: usado por muchos programas X.

</para>
</listitem>

</itemizedlist>

</para>

<para>
Para el resto de programas con el que se encontrará tarde o temprano, LPM.
Quizá podría ser interesante para usted el documento «Cómo configurar Linux»
<literal remap="tt"><ulink
url="http://sunsite.unc.edu/mdw/HOWTO/Config-HOWTO.html"
>http://sunsite.unc.edu/mdw/HOWTO/Config-HOWTO.html</ulink
></literal>.
</para>

</sect1>

<sect1>
<title>Trabajo en red: conceptos</title>

<para>
No solo está disponible bajo Linux un «Acceso telefónico a redes», sino que
también es más estable y más rápido. El nombre clave es «PPP», el protocolo
empleado para conectarse a Internet utilizando módems.  Necesita un núcleo que
de soporte a PPP y una herramienta que marque y realice la conexión.
</para>

<para>
Para recoger el correo de su proovedor de servicios Internet necesita una
herramienta llamada «recolector de correo» (email fetcher) que utiliza el
protocolo POP; cuando recoja el correo, parecerá como si hubiera sido enviado
directamente a su sistema Linux. Entonces deberá utilizar un gestor de correo
de usuario como <literal remap="tt">pine</literal>, <literal remap="tt">mutt</literal>, <literal remap="tt">elm</literal> u otros muchos para
administrarlo.
</para>

<para>
Mientras que bajo Windows, siempre que lanza una aplicación de Internet se
ejecuta el programa de conexión, bajo Linux el proceso es al revés.  Primero se
conecta, y después se lanza la aplicación. Un programa llamado <literal remap="tt">diald</literal>
proporciona el acceso usual. Instalar y configurar una red solía ser una de las
cosas más difíciles de hacer bajo Linux, pero ya no lo es: por favor, consulte
el documento COMO configurar Linux.
</para>

<para>
Finalmente, acerca del «Entorno de red»: puede hacer que su máquina Linux
aparezca como un Windows NT/9x en una red local de máquinas Windows. La palabra
mágica es Samba: no el baile brasileño, sino una implementación del protocolo
SMB para Linux. Visite <literal remap="tt"><ulink
url="http://samba.anu.edu.au/samba"
>http://samba.anu.edu.au/samba</ulink
></literal>.
</para>

</sect1>

<sect1>
<title>Un poco de programación</title>

<sect2 id="Scripts">
<title>Rutinas del Intérprete de Comandos: Ficheros .BAT con esteroides </title>

<para>
Si ha utilizado ficheros <literal remap="tt">.BAT</literal> para crear atajos de largas líneas de orden
(yo solía hacerlo), el objetivo puede ser obtenido insertando las líneas de
alias convenientes (ver ejemplo de más arriba) en el <literal remap="tt">profile</literal> o en el
<literal remap="tt">.bash_profile</literal>. Pero si sus ficheros <literal remap="tt">.BAT</literal> son más complicados, le
encantará el lenguaje de Script (guionado) que el shell pone a su disposición:
es tan potente como el viejo Qbasic (o más).  Tiene variables, estructuras como
<literal remap="tt">while</literal>, <literal remap="tt">for</literal>, <literal remap="tt">case</literal>, <literal remap="tt">if-then-else</literal>, y montones de nuevas
características: puede ser una buena alternativa a un lenguaje de programación
«de verdad». 
</para>

<para>
Para escribir una rutina (script) ---el equivalente a un fichero
<literal remap="tt">.BAT</literal> bajo DOS--- todo lo que tiene que hacer es escribir un fichero
ASCII estándar que contenga las instrucciones, guardarlo, y entonces
hacerlo ejecutable con la orden <literal remap="tt">chmod +x fichero</literal>. Para
ejecutarlo, teclee su nombre. 
</para>

<para>
Aviso: el editor del sistema se llama <literal remap="tt">vi</literal>, y es un hecho probado que
la mayor parte de los nuevos usuarios lo encuentran muy difícil de usar.
No voy a explicar cómo usarlo; por favor, consulte el libro de Matt Welsh
o busque un cursillo en la red. Suficiente decir por ahora que:
</para>

<para>

<itemizedlist>
<listitem>

<para>
para insertar texto, pulse `i' y después el texto;
</para>
</listitem>
<listitem>

<para>
para borrar caracteres, teclee <literal remap="tt">ESC</literal> y después `x';
</para>
</listitem>
<listitem>

<para>
para salir de <literal remap="tt">vi</literal> sin guardar, pulse <literal remap="tt">ESC</literal> y después <literal remap="tt">:q!</literal>
</para>
</listitem>
<listitem>

<para>
para guardar y salir, pulse <literal remap="tt">ESC</literal> y luego <literal remap="tt">:wq</literal>
</para>
</listitem>

</itemizedlist>

</para>

<para>
<literal remap="tt">joe</literal> es un buen editor para novatos: llámelo tecleando <literal remap="tt">jstar</literal>
y tendrá los mismos atajos de teclas que en el editor de DOSWin.
<literal remap="tt">jed</literal> en modo WordStar o IDE es incluso mejor. Por favor, consulte
la sección <xref linkend="Programas"/> para
ver dónde conseguir estos editores.
</para>

<para>
Escribir rutinas bajo bash es una materia tan extensa que requeriría un
libro para abarcarla toda, y no voy a profundizar más allá en este tema.
Sólo daré un ejemplo de script, del cual se pueden extraer las reglas
básicas: 
</para>

<para>

<screen>
#!/bin/sh
# ejemplo.sh
# Soy un comentario
# no cambie la primera linea: debe estar ahi
echo "Este sistema es: `uname -a`" # usa la salida de la orden
echo "Me llamo $0" # variables intrinsecas
echo "Usted me dio $# parametros: "$*
echo "El primer parametro es: "$1
echo -n "¿Como se llama? " ; read su_nombre
echo fijese en la diferencia: "Hola, $su_nombre" # entrecomillando con "
echo fijese en la diferencia: 'Hola, $su_nombre' # entrecomillando con '
DIRS=0 ; FILES=0
for fichero in `ls .` ; do
  if [ -d ${fichero} ] ; then # si el fichero esta en el directorio
    DIRS=`expr $DIRS + 1`  # DIRS = DIRS + 1
  else if [ -f ${fichero} ] ; then
   FILES=`expr $FILES + 1`
  fi
  case ${fichero} in
    gif|*jpg) echo "${fichero}: fichero grafico" ;;
    *.txt|*.tex) echo "${fichero}: fichero de texto" ;;
    *.c|*.f|*.for) echo "${fichero}: fichero de codigo fuente" ;;
    *) echo "${fichero}: fichero generico" ;;
  esac
done
echo "Hay ${DIRS} directorios y ${FILES} ficheros"
ls | grep "ZxY--!!!WKW"
if [ $? != 0 ] ; then # Sacar el codigo del ultimo orden
  echo "ZxY--!!!WKW no encontrado"
fi
echo "ya es suficiente... Para mas informacion teclee 'man bash'." 
</screen>

</para>

</sect2>

<sect2>
<title>Sus programas en C</title>

<para>
Bajo Unix, el lenguaje del sistema es C, le guste o no. Pero también están a su
disposición otros lenguajes como FORTRAN, Pascal, Lisp, Basic, Perl,
awk...
</para>

<para>
Suponiendo que usted sepa C, hay un par de guías para aquellos que han
utilizado Turbo C++ o uno de sus hermanos bajo DOS. El compilador de C se
denomina gcc y carece de todas las florituras que normalmente acompañan a sus
análogos bajo DOS: no tiene IDE, ni ayuda en línea, ni debugger integrado,
etc... Es sólo un rústico compilador de línea de órdenes, muy potente y
eficiente. Esto es lo que debe teclear para compilar el típico programa
<literal remap="tt">hello.c</literal>:
</para>

<para>

<screen>
$ gcc hello.c
</screen>

</para>

<para>
lo que creará un fichero ejecutable llamado <literal remap="tt">a.out</literal>. Para cambiar el
nombre del ejecutable a otro nombre: 
</para>

<para>

<screen>
$ gcc -o hola hello.c
</screen>

</para>

<para>
Para enlazar una librería al programa, añada la opción
<literal remap="tt">-lnombre_de_librería</literal>. Por ejemplo, para enlazar la librería
<literal remap="tt">math</literal>:
</para>

<para>

<screen>
$ gcc -o mathprog mathprog.c -lm
</screen>

</para>

<para>
(<literal remap="tt">-lnombre_libreria</literal> fuerza a gcc a enlazar la librería
<literal remap="tt">/usr/lib/libnombre_librería.a</literal>; por lo tanto <literal remap="tt">-lm</literal> enlaza
<literal remap="tt">/usr/lib/libm.a</literal>). 
</para>

<para>
Bien. Pero cuando su programa está compuesto por varios ficheros de código
fuente, necesitará usar la utilidad <literal remap="tt">make</literal>. Supongamos que ha escrito un
evaluador de expresiones: su código fuente se denomina <literal remap="tt">parser.c</literal> e tiene un
<literal remap="tt">#include</literal> de dos ficheros en su cabecera: <literal remap="tt">parser.h</literal> y <literal remap="tt">xy.h</literal>.
Entonces, desea utilizar las rutinas de <literal remap="tt">parser.c</literal> en otro programa,
<literal remap="tt">calc.c</literal>, que hace un <literal remap="tt">#include</literal> de <literal remap="tt">parser.h</literal>. ¡Vaya lío! ¿Cómo se
puede compilar <literal remap="tt">calc.c</literal>? 
</para>

<para>
Debe escribir un fichero llamado <literal remap="tt">Makefile</literal>, el cual muestra al compilador
las dependencias entre los ficheros de código fuente y los ficheros de código
objeto. En nuestro ejemplo: 
</para>

<para>

<screen>
# Este es el Makefile utilizado para compilar calc.c
# ¡Pulse la tecla &#60;TAB&#62; en las posiciones marcadas!

calc: calc.o parser.o
&#60;TAB&#62;gcc -o calc calc.o parser.o -lm
# calc depende de dos ficheros de codigo objeto: calc.o and parser.o

calc.o: calc.c parser.h
&#60;TAB&#62;gcc -c calc.c
# calc.o depende de dos ficheros de codigo fuente

parser.o:  parser.c parser.h xy.h
&#60;TAB&#62;gcc -c parser.c
# parser.o depende de tres ficheros de codigo fuente

# fin de Makefile.
</screen>

</para>

<para>
Guarde esto como <literal remap="tt">Makefile</literal> y teclee
</para>

<para>

<screen>
$ make
</screen>

</para>

<para>
para compilar su programa. Guárdelo como <literal remap="tt">calc.mak</literal> de forma
alternativa y teclee
</para>

<para>

<screen>
$ make -f calc.mak
</screen>

</para>

<para>
Y, por supuesto, LPM.
</para>

<para>
Puede pedir ayuda acerca de las funciones de C, que se encuentra en las
páginas <literal remap="tt">man</literal>, sección 3; por ejemplo: 
</para>

<para>

<screen>
$ man 3 printf
</screen>

</para>

<para>
Hay muchas librerías disponibles por ahí; entre las primeras que deseará usar
están las <literal remap="tt">ncurses</literal> (efectos en modo texto) y <literal remap="tt">svgalib</literal>, (gráficos para
consola). Si se siente suficientemente valiente para atacar la programación
bajo X (no es tan difícil), hay muchas bibliotecas que harán mucho más fácil
escribir programas para X11. Eche un vistazo a <literal remap="tt"><ulink
url="http://www.xnet.com/~blatura/linapp6.html"
>http://www.xnet.com/~blatura/linapp6.html</ulink
></literal>, teniendo en cuenta el
hecho de que Gtk se está volviendo un estándar.
</para>

<para>
Muchos editores pueden actuar como IDE. <literal remap="tt">emacs</literal> y <literal remap="tt">jed</literal>, por ejemplo,
proporcionan marcado de sintaxis, indentación automática, y cosas similares. De
manera alternativa, consiga el paquete <literal remap="tt">rhide</literal> de <literal remap="tt"><ulink
url="ftp://sunsite.unc.edu:/pub/Linux/devel/debuggers/"
>ftp://sunsite.unc.edu:/pub/Linux/devel/debuggers/</ulink
></literal>.  Es un clon del
IDE de Borland, y cabe la posibilidad de que le guste.
</para>

</sect2>

</sect1>

<sect1>
<title>El restante 1%</title>

<para>
Mucho más que un 1%, en realidad...
</para>

<sect2>
<title>Utilización de <literal remap="tt">tar</literal> y <literal remap="tt">gzip</literal></title>

<para>
Bajo Unix hay algunas aplicaciones ampliamente utilizadas para archivar y
comprimir ficheros. <literal remap="tt">tar</literal> se utiliza para archivar varios ficheros en uno
---es como <literal remap="tt">PKZIP</literal> o <literal remap="tt">Winzip</literal>, pero no comprime, sólo archiva. Para
archivar varios ficheros en uno (que llamaremos archivo de ahora en adelante):
</para>

<para>

<screen>
$ tar -cvf &#60;nombre_fichero_final.tar&#62; &#60;fichero1&#62; [fichero2...]
</screen>

</para>

<para>
Para extraer ficheros de un archivo:
</para>

<para>

<screen>
$ tar -xpvf &#60;nombre_fichero.tar&#62; [fichero]
</screen>

</para>

<para>
Para listar los ficheros contenidos de un archivo:
</para>

<para>

<screen>
$ tar -tf &#60;nombre_fichero.tar&#62; | less
</screen>

</para>

<para>
Puede comprimir los ficheros usando <literal remap="tt">compress</literal>, el cual es obsoleto y
no debería ser utilizado nunca más, o usando <literal remap="tt">gzip</literal>:
</para>

<para>

<screen>
$ compress &#60;fichero&#62;
$ gzip &#60;fichero&#62;
</screen>

</para>

<para>
eso crea un fichero comprimido con la extensión <literal remap="tt">.Z</literal> (compress) o
<literal remap="tt">.gz</literal> (gzip). Estos programas sólo pueden comprimir un fichero cada
vez. Para descomprimir, use:
</para>

<para>

<screen>
$ compress -d &#60;fichero.Z&#62;
$ gzip -d &#60;fichero.gz&#62;
</screen>

</para>

<para>
LPM.
</para>

<para>
Hay también utilidades <literal remap="tt">unarj</literal>, <literal remap="tt">zip</literal> y <literal remap="tt">unzip</literal> (compatibles con
ARJ y PK??ZIP). Los ficheros con la extensión <literal remap="tt">.tar.gz</literal> o <literal remap="tt">tgz</literal>
(archivados con <literal remap="tt">tar</literal>, posteriormente comprimidos con <literal remap="tt">gzip</literal>) son
tan comunes en el mundo Unix como los ficheros <literal remap="tt">.ZIP</literal> bajo DOS. Para
listar los contenidos de un fichero <literal remap="tt">.tar.gz</literal> utilice:
</para>

<para>

<screen>
$ gzip -dc &#60;fichero.tar.gz&#62; | tar tf - | less
</screen>

</para>

<para>
o también:
</para>

<para>

<screen>
$ tar -cvzf &#60;fichero.tar.gz&#62;
</screen>

</para>

</sect2>

<sect2>
<title>Instalación de aplicaciones</title>

<para>
Antes de nada: instalar paquetes es trabajo del root. La mayoría de las
aplicaciones Linux se distribuyen como ficheros <literal remap="tt">.tar.gz</literal>, que contienen,
típicamente, un directorio bien denominado conteniendo ficheros y/o
subdirectorios. Una buena norma es instalar esos paquetes en el directorio
<literal remap="tt">/usr/local</literal> con la orden
</para>

<para>

<screen>
# tar -zxf &#60;archive.tar.gz&#62;
</screen>

</para>

<para>
leyendo después el fichero <literal remap="tt">README</literal> o <literal remap="tt">INSTALL</literal>. En la mayoría de los
casos, la aplicación se distribuye en código fuente, por lo que deberá
compilarla; a menudo, será suficiente teclear <literal remap="tt">make</literal> y después <literal remap="tt">make
install</literal>.  Si el archivo contiene una rutina <literal remap="tt">configure</literal> ejecútela
primero.  Obviamente, necesitará el compilador <literal remap="tt">gcc</literal> o <literal remap="tt">g++</literal>.
</para>

<para>
Algunos archivos deben ser desempaquetados desde el directorio raíz; éste
es el caso de los archivos <literal remap="tt">.tgz</literal> de Slackware. Otros archivos contienen los
ficheros pero no un subdirectorio - cuidado con liar las cosas. Antes de
instalar un archivo, liste su contenido.
</para>

<para>
Debian y Red Hat tienen su propio formato de archivo; respectivamente,
<literal remap="tt">.deb</literal> y <literal remap="tt">.rpm</literal>. El último está ganando una amplia aceptación; para
instalar un paquete <literal remap="tt">rpm</literal>, teclee
</para>

<para>

<screen>
# rpm -i package.rpm
</screen>

</para>

</sect2>

<sect2>
<title>Trucos imprescindibles</title>

<para>
<emphasis remap="bf">Visión de pantallas anteriores</emphasis>: presionar &lt;MAYÚS + RE PÁG&gt; (la tecla
gris) le permite volver atrás unas cuantas páginas, dependiendo de la memoria
de vídeo que posea.
</para>

<para>
<emphasis remap="bf">Resetear la pantalla</emphasis>: si por un casual hace un <literal remap="tt">cat</literal> o un <literal remap="tt">more</literal> de
un fichero binario, su pantalla puede acabar llena de basura.  Para arreglar
las cosas, teclee <literal remap="tt">reset</literal> a ciegas o pulse esta secuencia de caracteres:
<literal remap="tt">echo CTRL-V ESC c RETURN</literal>.
</para>

<para>
<emphasis remap="bf">Pegar texto</emphasis>: en consola, ver más abajo; en las X, haga click y arrastre
para seleccionar el texto en una ventana xterm, después haga click en el botón
central (o con los dos a la vez si tiene un ratón de dos botones) para pegar.
También hay un <literal remap="tt">xclipboard</literal> (portapapeles de X) (de momento, sólo para
texto); no se confunda por su muy baja velocidad de respuesta.
</para>

<para>
<emphasis remap="bf">Usar el ratón</emphasis>: instale <literal remap="tt">gpm</literal>, el controlador de ratón para la consola.
Haga click y arrastre para seleccionar texto, entonces haga un click con el
botón derecho para pegar el texto seleccionado. Funciona a través de diferentes
consolas virtuales.
</para>

<para>
<emphasis remap="bf">Mensajes del núcleo</emphasis>: échele un vistazo a <literal remap="tt">/var/adm/messages</literal> o
<literal remap="tt">/var/log/messages</literal> como root para ver lo que el núcleo le dice,
incluyendo los mensajes de inicio. La orden <literal remap="tt">dmesg</literal> también es útil.
</para>

</sect2>

<sect2 id="Programas">
<title>¿Dónde encontrar aplicaciones? </title>

<para>
Si se está preguntando si puede reemplazar su vieja y fiable aplicación DOS/Win
con una aplicación de Linux, le sugiero que navegue por los mayores directorios
de software para Linux: <literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux"
>ftp://sunsite.unc.edu/pub/Linux</ulink
></literal>, <literal remap="tt"><ulink
url="ftp://tsx-11.mit.edu/pub/linux"
>ftp://tsx-11.mit.edu/pub/linux</ulink
></literal>, y <literal remap="tt"><ulink
url="ftp://ftp.funet.fi/pub/Linux"
>ftp://ftp.funet.fi/pub/Linux</ulink
></literal>.
Otros buenos lugares para empezar son la «Página de Utilidades y Aplicaciones
para Linux» <literal remap="tt"><ulink
url="http://www.xnet.com/~blatura/linapps.shtml"
>http://www.xnet.com/~blatura/linapps.shtml</ulink
></literal>, y la página «oficial»
de Linux <literal remap="tt"><ulink
url="http://www.linux.org"
>http://www.linux.org</ulink
></literal>.
</para>

</sect2>

<sect2>
<title>Unas cuantas cosas que Usted no podía hacer</title>

<para>
Linux puede hacer muchas cosas que eran difíciles o imposibles de hacer con
DOS/Windows. Esta es una pequeña lista que puede abrir su apetito:
</para>

<para>

<itemizedlist>
<listitem>

<para>
 <literal remap="tt">at</literal> le permite ejecutar programas a una hora determinada;
</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">awk</literal> es un lenguaje simple pero potente para manipular ficheros
de datos (y no sólo de datos). Por ejemplo, siendo <literal remap="tt">data.dat</literal> su
fichero de datos con varios campos,


<screen>
$ awk '$2 ~ "abc" {print $1, "\t", $4}' data.dat
</screen>


imprime los campos 1 y 4 de cada línea de <literal remap="tt">data.dat</literal> cuyo segundo campo
contenga la cadena «abc».

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">cron</literal> es útil para realizar tareas periódicamente, en una
fecha y hora determinadas. Escriba <literal remap="tt">man 5 crontab</literal>.

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">find</literal> (vea también sección <xref linkend="dirtrad"/>) es una de las órdenes más potentes y útiles. Se
utiliza para encontrar ficheros que tengan unas determinadas características y
para realizar acciones en ellos. Un uso general de <literal remap="tt">find</literal> es:


<screen>
$ find &#60;directorio&#62; &#60;expresión&#62;
</screen>


donde &lt;expresión&gt; incluye los criterios de búsqueda y las acciones.
Ejemplos:


<screen>
$ find . -type l -exec ls -l {} \;
</screen>


encuentra todos los ficheros que son enlaces simbólicos y muestra a quién
apuntan.


<screen>
$ find / -name "*.old" -ok rm {} \;
</screen>


encuentra todos los ficheros que ajusten con el patrón y los borra,
pidiendo su permiso primero.


<screen>
$ find . -perm +111
</screen>


encuentra todos los ficheros cuyos permisos ajusten con 111 (ejecutables).


<screen>
$ find . -user root
</screen>


encuentra todos los ficheros que pertenecen al root. Hay cientos de
posibilidades. LPM.

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">grep</literal> busca patrones de texto en ficheros. Por ejemplo,


<screen>
$ grep -l "geología" *.txt
</screen>


lista todos los ficheros <literal remap="tt">*.txt</literal> que contengan la palabra «geología». La
variante <literal remap="tt">zgrep</literal> trabaja con ficheros comprimidos con gzip. LPM;

</para>
</listitem>
<listitem>

<para>
 <emphasis remap="bf">Las expresiones regulares</emphasis> son un método complejo pero muy potente
de efectuar operaciones de búsqueda en un texto. Por ejemplo,
<literal remap="tt">&circ;a[&circ;a-m]X&lcub;4,&rcub;txt$</literal> se ajusta a una línea que comienza con `a',
seguida de cualquier carácter excepto los del intervalo a-m, seguido de 4 o más
`X', y terminado en `txt'. Puede utilizar expresiones regulares con editores
avanzados, <literal remap="tt">less</literal>, y muchas otras aplicaciones.  <literal remap="tt">man grep</literal> para
una introducción.

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">script &lt;fichero_script&gt;</literal> vuelca los contenidos de la
pantalla en <literal remap="tt">fichero_script</literal> hasta que teclee la orden <literal remap="tt">exit</literal>.
Es útil para depuración;

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">sudo</literal> permite a usuarios efectuar algunas tareas propias del
root, como por ejemplo, formatear y montar discos; LPM);

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">uname -a</literal> le da información acerca de su sistema;

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">zcat</literal> y <literal remap="tt">zless</literal> son útiles para visualizar y trabajar con
ficheros comprimidos mediante gzip sin necesidad de descomprimirlos.
Por ejemplo:


<screen>
$ zless textfile.gz
$ zcat textfile.gz | lpr
</screen>


</para>
</listitem>
<listitem>

<para>
 Los siguientes órdenes son útiles a menudo: <literal remap="tt">bc, cal, chsh, cmp,
cut, fmt, head, hexdump, nl, passwd, printf, sort, split, strings, tac,
tail, tee, touch, uniq, w, wall, wc, whereis, write, xargs, znew. </literal>
LPM.

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Practicando UNIX bajo DOS/Windows</title>

<para>
Tanto como si me cree como si no, hay buenas utilidades que proporcionan un
entorno similar a UNIX bajo DOS/Windows. Uno es la suite Djgpp (<literal remap="tt"><ulink
url="http://www.delorie.com/djgpp"
>http://www.delorie.com/djgpp</ulink
></literal>)
para DOS, mientras que Cygnus (<literal remap="tt"><ulink
url="http://www.cygnus.com"
>http://www.cygnus.com</ulink
></literal>) es un puerto más completo para Win32. Ambos
incluyen las mismas herramientas y utilidades de desarrollo GNU que Linux; sin
embargo, no conseguirá la misma estabilidad.
</para>

<para>
Si desea tener el sabor de Linux, pruebe Djgpp. Descargue e instale los
siguientes ficheros (en el momento de escribir, la última versión era la
2.02): <literal remap="tt">djdev202.zip, bnu281b.zip, bsh1147b.zip, fil316b.zip,
find41b.zip, grep22b.zip, gwk303b.zip, lss332b.zip, shl112b.zip.</literal>. Se
proporcionan instrucciones de instalación, y puede encontrar ayuda en
<literal remap="tt"><ulink
url="news:comp.os.msdos.djgpp"
>news:comp.os.msdos.djgpp</ulink
></literal>.
</para>

<para>
En particular, utilizar <literal remap="tt">bash</literal> bajo DOSWin es una bocanada de
aire fresco. Para configurarlo adecuadamente, edite el fichero
<literal remap="tt">BOOT.BAT</literal> que viene en la distribución para que refleje su
instalación, y ponga estos ficheros en su directorio de usuario (de la
partición Windows) en lugar de los que se proporcionan:
</para>

<para>

<screen>
# este es _bashrc

LS_OPTIONS="-F -s --color=yes"
alias cp='cp -i'
alias d='ls -l'
alias l=less
alias ls="ls $LS_OPTIONS"
alias mv='mv -i'
alias rm='rm -i'
alias u='cd ..'
</screen>

</para>

<para>

<screen>
# este es _bprof
if [ -f ~/_bashrc ]; then
  . ~/_bashrc
fi
PS1='\w\$ '
PS2='&#62; '
CDPATH="$CDPATH:~"
# cosas para less(1)
LESS="-M-Q"
LESSEDIT="%E ?lt+%lt. %f"
VISUAL="jed"                    # editor
LESSCHARSET=latin1              # visualizar letras acentuadas
export PS1 PS2 CDPATH LS_OPTIONS LESS LESSEDIT LESSOPEN VISUAL LESSCHARSET
</screen>

</para>

</sect2>

<sect2>
<title>Extensiones comunes y programas relacionados</title>

<para>
Se podrá encontrar con una gran variedad de extensiones de ficheros.
Excluyendo las más exóticas (como las de fuentes, etc.), aquí tenemos una
lista de las extensiones más usuales:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">1 ... 8</literal>: páginas de manual. Léalas con
<literal remap="tt">groff -Tlatin1 -man &lt;file.1&gt;</literal>.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">arj</literal>: archivo hecho con <literal remap="tt">arj</literal>.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">dvi</literal>: fichero de salida producido por TeX (ver más abajo).
Use <literal remap="tt">xdvi</literal> para visualizarlo; Use <literal remap="tt">dvips</literal> para transformarlo en un
fichero PostScript (<literal remap="tt">.ps</literal>). 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">gz</literal>: archivo comprimido con <literal remap="tt">gzip</literal>.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">info</literal>: archivo <emphasis>info</emphasis> (Algo así como una alternativa a
las páginas de manual). Consiga <literal remap="tt">info</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">lsm</literal>: Fichero <emphasis>Linux Software Map</emphasis>. Es un fichero de
texto ASCII plano que contiene la descripción de un paquete. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">ps</literal>: Fichero PostScript. Para visualizarlo o imprimirlo
consiga <literal remap="tt">gs</literal> y, opcionalmente, <literal remap="tt">ghostview</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">rpm</literal>: Paquete de Red Hat. Puede instalarlo en cualquier
sistema utilizando el gestor de paquetes <literal remap="tt">rpm</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">taz, tar.Z</literal>: archivo hecho con <literal remap="tt">tar</literal> y posteriormente
comprimido con <literal remap="tt">compress</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">tgz, tar.gz</literal>: archivo hecho con <literal remap="tt">tar</literal> y posteriormente
comprimido con <literal remap="tt">gzip</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">tex</literal>: fichero de texto para utilizar con TeX, un poderoso
formateador de textos. Consiga el paquete <literal remap="tt">tex</literal>, disponible en muchas
distribuciones.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">texi</literal>: fichero texinfo, a partir del cual se pueden producir
tanto archivos TeX como info. Consiga <literal remap="tt">texinfo</literal>. 

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">xbm, xpm, xwd</literal>: fichero gráfico.

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">Z</literal>: archivo hecho con <literal remap="tt">compress</literal>.

</para>
</listitem>
<listitem>

<para>
 <literal remap="tt">zip</literal>: archivo hecho con <literal remap="tt">zip</literal>. Consiga <literal remap="tt">zip</literal> y
<literal remap="tt">unzip</literal>. 
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Conversión de ficheros</title>

<para>
Si necesita intercambiar ficheros de texto entre DOS/Win y Linux, tenga en
cuenta del problema de «fin de línea». Bajo DOS, cada línea de texto
finaliza con CR/LF (esto es, ASCII 13 + ASCII 10). Bajo Linux, con LF. Si
edita un fichero de texto DOS bajo Linux, cada línea acabará con un
carácter `M' de extraña apariencia. un fichero de texto Linux bajo DOS
aparecerá como una sóla línea kilométrica sin párrafos. Hay un par de
utilidades, <literal remap="tt">dos2unix</literal> y <literal remap="tt">unix2dos</literal>, que convierten estos ficheros.
</para>

<para>
<emphasis remap="it">Nota del revisor</emphasis>: Puede utilizar <literal remap="tt">vim</literal> para convertir este tipo de
ficheros:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Para convertir un fichero DOS a formato Linux:
(Las líneas con # delante son comentarios)


<screen>
vi fichero_dos.txt
# pulse ESC
:set fileformat=unix
# pulse Enter
!wq fichero_linux.txt
# pulse Enter
</screen>


</para>
</listitem>
<listitem>

<para>
Para convertir un fichero Linux para su uso en DOS:


<screen>
vi fichero_linux.txt
# pulse ESC
:set fileformat=dos
# pulse Enter
!wq fichero_dos.txt
# pulse Enter
</screen>

</para>
</listitem>

</itemizedlist>

</para>

<para>
Si sus ficheros de sólo-texto contienen caracteres acentuados, asegúrese
de que están hechos bajo Windows (con NotePad) y no bajo DOS; si no,
todas las letras acentuadas aparecerán como caracteres extraños.
</para>

<para>
Para convertir ficheros del Word o WordPerfect a texto plano, la cuestión
es más dificil, pero aún posible. Necesita una de las herramientas que
pueden encontrarse en los sitios CTAN; uno de ellos es <literal remap="tt"><ulink
url="ftp://ftp.tex.ac.uk"
>ftp://ftp.tex.ac.uk</ulink
></literal>. Consiga el
programa <literal remap="tt">word2x</literal> del directorio <literal remap="tt">/pub/tex/tools/</literal>. En
concreto, <literal remap="tt">word2x</literal> convierte ficheros de Word 6, mientras que para
ver ficheros realizados con Word 97 necesitará <literal remap="tt">mswordview</literal>
(<literal remap="tt"><ulink
url="http://www.csn.ul.ie/~caolan/docs/MSWordView.html"
>http://www.csn.ul.ie/~caolan/docs/MSWordView.html</ulink
></literal>) que los
transforma en HTML.
</para>

</sect2>

<sect2>
<title>Entornos ofimáticos gratuitos</title>

<para>
Si convertir ficheros no le parece suficiente, tiene la posibilidad de
probar un paquete (¡gratuito!) similar a Microsoft Office.
</para>

<para>
La suite StarOffice es gratuita para uso privado. Es grande, algo lenta,
pero muy buena: ofrece muchas funcionalidades no encontradas en Microsoft
Office. Puede también leer y escribir ficheros de Word y Excel, aunque la
conversión no es siempre perfecta. Visite <literal remap="tt"><ulink
url="http://www.stardivision.com"
>http://www.stardivision.com</ulink
></literal>.
</para>

<para>
Otro buen paquete es Corel WordPerfect, del cual está disponible para
descarga una edición gratuita. ¿Debería decir más? Vaya a por él:
<literal remap="tt"><ulink
url="http://www.corel.com"
>http://www.corel.com</ulink
></literal>.
</para>

</sect2>

</sect1>

<sect1>
<title>Fin, por ahora</title>

<para>
¡Felicidades! Se ha iniciado un poco en el UNIX y está preparado para
comenzar a trabajar. Recuerde que su conocimiento del sistema es aún
limitado, y que se espera que practique más con Linux para usarlo
cómodamente. Pero si todo lo que quería hacer era conseguir un puñado de
aplicaciones y empezar a trabajar con ellas, apuesto a que lo que se
incluyó aquí fue suficiente. 
</para>

<para>
Estoy seguro de que habrá disfrutado de usar Linux y seguirá aprendiendo
más acerca de él (todo el mundo lo hace). ¡Apuesto lo que sea,
también, a que nunca volverá a DOSWin! Espero haberme hecho entender y
haber realizado un buen servicio a mis 3 o 4 lectores.
</para>

<sect2>
<title>Copyright</title>

<para>
A menos que se establezca lo contrario, los documentos COMO de Linux
tienen copyright de sus respectivos autores. Los documentos COMO de Linux
pueden ser reproducidos y distribuidos de manera completa o en parte, en
cualquier medio físico o electrónico, siempre y cuando este aviso de
copyright se mantenga en todas las copias. Se permite y se anima a la
redistribución comercial; sin embargo, al autor le gustaría ser notificado
de cualquier distribución. 
</para>

<para>
Todas las traducciones, trabajos derivados o agregados que incorporen
cualquier documento COMO de Linux deben ser mantenidos bajo este aviso de
Copyright. Esto es, no puede producir un trabajo derivado de un documento
COMO e imponer restricciones adicionales a su distribución. Se pueden
conceder excepciones a estas reglas bajo ciertas condiciones;  por favor,
contacte con el coordinador de los COMO de Linux en la dirección dada más
abajo. 
</para>

<para>
En resumen, deseamos promocionar la dispersión de esta información a
través de cuantos canales sea posible. Sin embargo, deseamos retener el
copyright de los documentos COMO, y nos gustaría tener noticias de
cualquier plan de redistribuir los COMOs. 
</para>

<para>
Si tiene dudas, contacte con Tim Bynum, el coordinador de Linux HOWTO,
en <literal remap="tt"><ulink
url="linux-howto@sunsite.unc.edu"
>linux-howto@sunsite.unc.edu</ulink
></literal> vía e-mail.
</para>

</sect2>

<sect2>
<title>Agradecimientos</title>

<para>
"CÓMO pasar de DOS a Linux" fue escrito por Guido Gonzato, <literal remap="tt"><ulink
url="BORREMEguido@ibogeo.df.unibo.it"
>BORREMEguido@ibogeo.df.unibo.it</ulink
></literal> (Borre el «BORREME»).  Muchas
gracias a Matt Welsh, el autor de <emphasis remap="it">Linux: Instalación y Primeros Pasos</emphasis>, a
Ian Jackson, el autor del <emphasis remap="it">Linux frequently asked questions with answers</emphasis>,
a Giuseppe Zanetti, el autor de <emphasis remap="it">Linux</emphasis>, a todos los amigos que me enviaron
sugerencias, y especialmente a Linus Torvalds y GNU que nos trajeron Linux. 
</para>

<para>
Este documento se distribuye «tal cual». He puesto un gran esfuerzo en
escribirlo tan correctamente como he podido. Pese a ello, la información
contenida en el mismo debe ser utilizada bajo su propia responsabilidad. 
En ningún caso el autor será responsable de cualquier daño resultante del
uso de este documento. 
</para>

<para>
Los comentarios son bienvenidos. Para cualquier duda, sugerencia, crítica,
etc., siéntase libre de contactar conmigo. 
</para>

<para>
Disfrute de Linux y de la vida,
</para>

<para>
Guido   <literal remap="tt">=8-)</literal>					
</para>

</sect2>

<sect2>
<title>Traducción</title>

<para>
«CÓMO pasar de DOS/Win a LINUX» fue traducido por David Marín Carreño,
<literal remap="tt"><ulink
url="mailto:davefx@bigfoot.com"
>davefx@bigfoot.com</ulink
></literal>,
como un pequeño grano de arena más dentro del Proyecto INSFLUG. Para más
información, vea la sección <xref linkend="Grupos"/>.
</para>

<para>
He intentado una traducción fidedigna del documento original de Guido,
aunque en algunos lugares haya actualizado información o cambiado algunas
expresiones por otras más adecuadas a la jerga en nuestro idioma. 
</para>

<para>
Si desea plantear alguna duda, sugerencia o crítica, pues tampoco dude en
contactar conmigo. 
</para>

<para>

<screen>
     |   |   |  _|   David Marín Carreño (aka DaveFX)
      \  |  /  /
       |/____\|      Estudiante de Ingeniería en Informática.
      /_|_/\_|_\     Traductor de documentos Línux.
      \| (__) |/     Madrid. España.
      / \____/ \
     (____  ____)    ICQ#: 34866516
     _____||_____    E-mail: &#60;davefx@bigfoot.com&#62;
    /  _      _  \   WEb SiTe: http://www.bigfoot.com/~davefx
</screen>

</para>

</sect2>

</sect1>

<sect1 id="Grupos">
<title>Anexo: El INSFLUG </title>

<para>
El <emphasis>INSFLUG</emphasis> forma parte del grupo internacional <emphasis remap="it">Linux
Documentation Project</emphasis>, encargándose de las traducciones al castellano de
los Howtos (Comos), así como la producción de documentos originales en
aquellos casos en los que no existe análogo en inglés.
</para>

<para>
En el <emphasis remap="bf">INSFLUG</emphasis> se orienta preferentemente a la traducción de
documentos breves, como los <emphasis>COMOs</emphasis> y <emphasis>PUFs</emphasis> (<emphasis remap="bf">P</emphasis>reguntas de
<emphasis remap="bf">U</emphasis>so <emphasis remap="bf">F</emphasis>recuente, las <emphasis remap="it">FAQs</emphasis>. <literal remap="tt">:)</literal> ), etc.
</para>

<para>
Diríjase a la sede del INSFLUG para más información al respecto.
</para>

<para>
En la sede del INSFLUG encontrará siempre las <emphasis remap="bf">últimas</emphasis> versiones de
las traducciones:  <literal remap="tt"><ulink
url="http://www.insflug.org"
>www.insflug.org</ulink
></literal>. Asegúrese de comprobar cuál es la última
versión disponible en el Insflug antes de bajar un documento de un
servidor réplica.
</para>

<para>
Se proporciona también una lista de los servidores réplica (<emphasis remap="it">mirror</emphasis>)
del Insflug más cercanos a Vd., e información relativa a otros recursos en
castellano.
</para>

<para>
Francisco José Montilla, <literal remap="tt"><ulink
url="mailto:pacopepe@insflug.org"
>pacopepe@insflug.org</ulink
></literal>.
</para>

</sect1>

</article>
