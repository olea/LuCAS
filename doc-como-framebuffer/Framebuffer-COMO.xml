<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>

<articleinfo>

<title>Framebuffer COMO</title>
<author>
		<firstname>Alex</firstname>
		<surname>Buell</surname>
		<affiliation>
			<address><email><remark>alex.buell@tahallah.demon.co.uk</remark></email></address>
		</affiliation>
</author>
<revhistory>
			<revision>
				<revnumber>1.1</revnumber>
				<date>22 de Julio de 1999</date>
			</revision>
		</revhistory>
<abstract>

<para>
Este documento describe como se pueden usar los dispositivos framebuffer
en Linux con multitud de plataformas. También incluye información acerca
de como establecer pantallas multi-dirigidas (<emphasis>multi-headed</emphasis>).
</para>

</abstract>

</articleinfo>

<sect1>
	<title>Aportaciones</title>

	<para>
	Gracias a todas las personas que nombro a continuación por ayudar en la
	mejora de este documento:
	</para>

	<para>

	<itemizedlist>
		<listitem>
		<para>
			Jeff Noxon <email>jeff@planetfall.com</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Francis Devereux <email>f.devereux@cs.ucl.ac.uk</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Andreas Ehliar <email>ehliar@futurniture.se</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Martin McCarthy <email>marty@ehabitat.demon.co.uk</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Simon Kenyon <email>simon@koala.ie</email>
		</para>
		</listitem>
		<listitem>

		<para>
			David Ford <email>david@kalifornia.com</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Chris Black <email>cblack@cmpteam4.unil.ch</email>
		</para>
		</listitem>
		<listitem>

		<para>
			N Becker <email>nbecker@fred.net</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Bob Tracy <email>rct@gherkin.sa.wlk.com</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Marius Hjelle <email>marius.hjelle@roman.uib.no</email>
		</para>
		</listitem>
		<listitem>

		<para>
			James Cassidy <email>jcassidy@misc.dyn.ml.org</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Andreas U. Trottmann <email>andreas.trottmann@werft22.com</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Lech Szychowski <email>lech7@lech.pse.pl</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Aaron Tiensivu <email>tiensivu@pilot.msu.edu</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Jan-Frode Myklebust por su información sobre las tarjetas Permedia
			<email>janfrode@ii.uib.no</email>
		</para>
		</listitem>
		<listitem>

		<para>
			Y a toda la gente que debería aparecer y no aparece, también 
			gracias!
		</para>
		</listitem>

	</itemizedlist>

	</para>

	<para>
		Gracias a Rick Niles <email>frederick.a.niles@gsfc.nasa.gov</email> 
		por ceder amablemente a la inclusión de su documento <emphasis>Multi-Head Mini-HOWTO</emphasis>.
	</para>

	<para>
		Gracias a la gente que indico a continuación por construir las versiones
		libc5/glibc2 de los drivers framebuffer, <prompt>XF86_FBdev</prompt>, para X11 sobre
		plataformas Intel.
	</para>

	<para>

	<itemizedlist>
	<listitem>

	<para>
		Brion Vibber <email>brion@pobox.com</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Gerd Knorr <email>kraxel@cs.tu-berlin.de</email>
	</para>
	</listitem>

	</itemizedlist>

	</para>

	<para>
		y por supuesto, gracias a los autores de los dispositivos framebuffer:
	</para>

	<para>

	<itemizedlist>
	<listitem>

	<para>
		Martin Schaller - autor original del concepto de framebuffer.
	</para>
	</listitem>
	<listitem>

	<para>
		Roman Hodek <email>Roman.Hodek@informatik.uni-erlangen.de</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Andreas Schwab <email>schwab@issan.informatik.uni-dortmund.de</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Guenther Kelleter 
	</para>
	</listitem>
	<listitem>

	<para>
		Geert Uytterhoeven <email>Geert.Uytterhoeven@cs.kuleuven.ac.be</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Roman Zippel <email>roman@sodom.obdg.de</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Pavel Machek <email>pavel@atrey.karlin.mff.cuni.cz</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Gerd Knorr <email>kraxel@cs.tu-berlin.de</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Miguel de Icaza <email>miguel@nuclecu.unam.mx</email>
	</para>
	</listitem>
	<listitem>

	<para>
		David Carter <email>carter@compsci.bristol.ac.uk</email>
	</para>
	</listitem>
	<listitem>

	<para>
		William Rucklidge <email>wjr@cs.cornell.edu</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Jes Sorensen <email>jds@kom.auc.dk</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Sigurdur Asgeirsson
	</para>
	</listitem>
	<listitem>

	<para>
			Jeffrey Kuskin <email>jsk@mojave.stanford.edu</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Michal Rehacek <email>michal.rehacek@st.mff.cuni.edu</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Peter Zaitcev <email>zaitcev@lab.ipmce.su</email>
	</para>
	</listitem>
	<listitem>

	<para>
		David S. Miller <email>davem@dm.cobaltmicro.com</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Dave Redman ><email>djhr@tadpole.co.uk</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Jay Estabrook 
	</para>
	</listitem>
	<listitem>

	<para>
		Martin Mares <email>mj@ucw.cz</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Dan Jacobowitz <email>dan@debian.org</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Emmanuel Marty <email>core@ggi-project.org</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Eddie C. Dost <email>ecd@skynet.be</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Jakub Jelinek <email>jj@ultra.linux.cz</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Phil Blundell <email>philb@gnu.org</email>
	</para>
	</listitem>
	<listitem>

	<para>
		Anyone else, stanted up and be counted. :o)
	</para>
	</listitem>

	</itemizedlist>

	</para>

</sect1>

<sect1>
<title>¿Qué es un dispositivo framebuffer?</title>

	<para>
		Un dispositivo framebuffer es una abstracción para el hardware gráfico.
		Representa un buffer de imagen para algunos hardware de vídeo, y permite a
		las aplicaciones software acceder al hardware gráfico a través de una
		interfaz bien definida, de manera que el software no necesita saber nada
		sobre la interfaz de bajo nivel (Tomado del fichero
		<prompt>/Documentation/fb/framebuffer.txt</prompt> de Geert Uytterhoeven incluido
		en los fuentes del núcleo de linux).
	</para>

</sect1>

<sect1>
<title>¿Qué ventajas ofrecen los dispositivos framebuffer? </title>

	<para></para>

	<para>
		Vemos un pingüino durante el arranque. :o) Hablando seriamente, la mayor
		ventaja de los controladores framebuffer es que estos presentan una
		interfaz genérica a través de todas las plataformas.
	</para>

	<para>
		Se daba el caso hasta bien avanzado el proceso de desarrollo de los
		núcleos 2.1.x en el que los controladores de consola para plataformas
		Intel eran completamente diferentes a los controladores de consola para
		otras plataformas. Con la introducción de la versión del núcleo 2.1.109
		todo esto cambió para mejor, se puso en práctica un manejo más uniforme de
		la consola bajo plataformas Intel además de introducir la consola gráfica
		mapeada por bit (<emphasis>bitmapped</emphasis>), también se permitió que el código fuera
		compartido a través de diferentes plataformas. Tenga en cuenta que los
		núcleos 2.0.x no soportan dispositivos framebuffer, aunque es posible que
		algún día alguien porte el código de los núcleos 2.1.x a los 2.0.x. Existe
		una excepción de lo anteriormente comentado y es que los núcleos 0.9.x
		portados sobre plataformas m68k incluyen el soporte para dispositivos
		framebuffer.
	</para>

	<tip>
	<para>
		Con la versión del núcleo 2.2.x, el soporte para dispositivos
		framebuffer es mucho más sólido y estable. Puede usar el dispositivo
		framebuffer si su tarjeta gráfica lo soporta y está utilizando un núcleo
		2.2.x. Los núcleos anteriores 2.0.x no soportan dispositivos framebuffer,
		al menos en plataformas Intel.
		
	</para>
	</tip>
	<para>

		<itemizedlist>
			<listitem>

				<para>
					0.9.x (m68k) - introduce dispositivos framebuffer para plataformas
					m68k. Tenga en cuenta que las versiones 0.9.x para plataformas m68k son
					funcionalmente equivalentes a las veriones del núcleo 1.0.9 para
					plataformas Intel (mejorado en las versiones 1.2.x)
				</para>
			</listitem>
			<listitem>

				<para>
					2.1.107 - introduce framebuffer en plataformas Intel, nuevos
					dispositivos de consola y añade soporte genérico, sin soporte para
					<emphasis>scrollback buffer</emphasis>.
				</para>
			</listitem>
			<listitem>

				<para>
					2.1.113 - soporte <emphasis>scrollback buffer</emphasis> añadido a <emphasis>vgacon</emphasis>.
				</para>
			</listitem>
			<listitem>

				<para>
					2.1.116 - soporte <emphasis>scrollback buffer</emphasis> añadido a <emphasis>vesafb</emphasis>.
				</para>
			</listitem>
			<listitem>

				<para>
					2.2.x - incluidos <emphasis>matroxfb</emphasis> (Matrox) y <emphasis>atyfb</emphasis> (ATI).
				</para>
			</listitem>

		</itemizedlist>

	</para>

	<para>
		Hay algunas características nuevas de los dispositivos framebuffer, de
		echo puede pasar opciones genéricas al núcleo durante el arranque,
		incluyendo opciones específicas para dispositivos framebuffer concretos.
		Estas son:
	</para>

	<para>

		<itemizedlist>
			<listitem>

				<para>
					<prompt>video=xxx:off</prompt> - desabilita la prueba para dispositivos
					framebuffer concretos
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>video=map:octal-number</prompt> - mapea las consolas virtuales (VCs,
					<emphasis>Virtual Consoles</emphasis>) hacia dispositivos framebuffer (FB)

			<itemizedlist>
				<listitem>

					<para>
						<prompt>video=map:01</prompt> mapeará VC0 a FB0, VC1 a FB1, VC2 a FB0, VC3
						a FB1..
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>video=map:0132</prompt> mapeará VC0 a FB0, VC1 a FB1, VC2 a FB3, VC4
						a FB2, VC5 a FB0..
					</para>
				</listitem>

			</itemizedlist>

				</para>
			</listitem>

		</itemizedlist>

	</para>

	<para>
		Normalmente los dispositivos framebuffer son probados en un orden
		específico por el núcleo, pero utilizando la opción <prompt>video=xxx</prompt>, puede
		añadir el dispositivo framebuffer concreto que usted quiere probar antes
		que el resto de dispositivos especificados en el núcleo.
	</para>

</sect1>

<sect1>
<title>Usando los dispositivos framebuffer en plataformas Intel</title>

	<sect2>
	<title>¿Qué es el <prompt>vesafb</prompt>?</title>

		<para>
		<emphasis>Vesafb</emphasis> es un controlador framebuffer para la arquitectura Intel que
		trabaja con las tarjetas gráficas compatibles con la norma VESA 2.0. Este
		<emphasis>driver</emphasis> se encuentra estrechamente relacionado dentro del núcleo con
		los controladores de dispositivo para framebuffer.
		</para>

		<para>
		Vesafb es un driver de pantalla que habilita el uso de modos gráficos en
		la plataforma Intel para las consolas de texto mediante mapas de bits
		(<emphasis>bitmapping</emphasis>). También permite desplegar un logotipo que probablemente
		es la razón principal por la que quiere usar vesafb <prompt>:o)</prompt>
		</para>

		<para>
		Desafortunadamente, no puede usar vesafb con las tarjetas que soportan la
		norma VESA 1.2. Esto es debido a que estas tarjetas no usan <emphasis>frame
		buffering</emphasis> <emphasis>lineal</emphasis>. <emphasis>Frame buffering</emphasis> lineal significa simplemente
		que la CPU del sistema puede acceder a cada bit de la pantalla.
		Historicamente, los antiguos adaptadores gráficos podían permitir el
		acceso de la CPU a sólo 64K a la vez, de aquí las limitaciones de los
		horribles modos gráficos CGA/EGA! Puede ser que alguien decida escribir un
		controlador de dispositivo (<prompt>vesafb12</prompt>) para estas tarjetas, pero esto
		usaría la preciada memoria del núcleo e implicaría un vil parcheo.
		<prompt>:o(</prompt>
		</para>

		<para>
		Sin embargo, existe la posibilidad de habilitar extensiones VESA 2.0 para
		tarjetas VESA 1.2. Puede conseguir un tipo de programa TSR que se
		ejecutará desde DOS, y usado en conjunción con <prompt>loadlin</prompt>, puede ayudar
		a configurar la tarjeta para los modos gráficos de consola apropiados.
		Tenga en cuenta que esto no siempre funcionará, por ejemplo algunas
		tarjetas como la serie VLB 54xx de Cirrus Logic son mapeadas en un rango
		de direcciones de memoria (por ejemplo, dentro del rango 15MB-16MB) que
		exigen al sistema tener más de 32MB de memoria para funcionar. Hay una
		manera de solucionar esto, si tiene una opción en la BIOS para dejar un
		hueco de memoria en el rango 15MB-16MB, podría funcionar, pero Linux no
		soporta el uso de estos huecos en la memoria. Sin embargo hay parches para
		esta opción (pero, ¿Quién los tiene y como puedo conseguirlos?). Si desea
		experimentar con esta opción, hay un completo repertorio de programas TSR
		disponibles (un ejemplo de ellos es UNIVBE) que pueden ser encontrados en
		Internet.
		</para>

		<para>
		Como alternativa, puede obtener los parches del núcleo para permitir que
		su tarjeta VESA 1.2 trabaje con el driver para framebuffer VESA. Por
		ejemplo, hay parches para el uso con las viejas tarjetas S3 (tales como la
		S3 Trio, S3 Virge) que soportan la norma VESA 1.2. Para estas tarjetas,
		puede recoger los parches de: <ulink url="ftp://ccssu.crimea.ua/pub/linux/kernel/v2.2/unofficial/s3new.diff..gz">
		ftp://ccssu.crimea.ua/pub/linux/kernel/v2.2/unofficial/s3new.diff.gz</ulink>
		</para>

	</sect2>

	<sect2>	
	<title>¿Cómo puedo activar los drivers <prompt>vesafb</prompt>?</title>

		<para>
		Asumiendo que usa <prompt>menuconfig</prompt>, necesitará realizar los siguientes
		pasos:
		</para>

		<para>
		Si su procesador (en plataformas Intel) soporta MTRRs, habilitela. Esta
		opción acelera las transferencias de memoria entre el procesador y la
		tarjeta gráfica, aunque no es estrictamente necesario. Usted puede, por
		supuesto, habilitar esta opción después de asegurarse que los dispositivos
		de consola funcionan.
		</para>

		<para>
		<emphasis>IMPORTANTE: Para núcleos 2.1.x, vaya a la opción del menú <emphasis>Code
		Maturity Level</emphasis>, y habilite la opción para <emphasis>development and</emphasis>or
		incomplete drivers. Esta opción no es necesaria para los núcleos 2.2.x.</emphasis>
		</para>
		
		<para>
		Entre en el sub-menú de dispositivos de consola (<emphasis>Console Drivers</emphasis>), y
		habilite lo siguiente:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						VGA Text Console
					</para>
				</listitem>
				<listitem>

					<para>
						Video Selection Support
					</para>
				</listitem>
				<listitem>

					<para>
						Support for frame buffer devices (experimental)
					</para>
				</listitem>
				<listitem>

					<para>
						VESA VGA Graphic console
					</para>
				</listitem>
				<listitem>

					<para>
						Advanced Low Level Drivers
					</para>
				</listitem>
				<listitem>

					<para>
						Select Mono, 2bpp, 4bpp, 8bpp, 16bpp, 24bpp and 32bpp packed pixel
						drivers
					</para>
				</listitem>

			</itemizedlist>

		</para>

		<para>
		<emphasis>VGA Chipset Support (text only)</emphasis> - (<prompt>vgafb</prompt>) - era parte de la
		lista anterior, pero ha sido eliminado ya que está obsoleto y no será
		soportado. Se eliminará en breve. Use <emphasis>VGA Text Console</emphasis> (<prompt>fbcon</prompt> en
		su lugar. <emphasis>VGA Character/Attributes</emphasis> es también usado con <emphasis>VGA
		Chipset Support</emphasis>, y no es necesario seleccionarlo.
		</para>

		<para>
		Asegúrese de que <emphasis>Mac variable bpp packed pixel support</emphasis> no está
		habilitado. En las versiones del núcleo 2.1.111/ (y <prompt>112</prompt>) esta opción
		parece habilitarse de forma automática si los <emphasis>Advanced Low Level
		Drivers</emphasis> son seleccionados inicialmente. Esto no sucede con las versiones
		del núcleo superiores a la 2.1.113.
		</para>

		<para>
		Existe también la opción de compilar las fuentes en memoria, pero esto no
		es realmente necesario, y usted puede siempre usar la utilidad
		<prompt>setfont</prompt> del paquete <prompt>kdb-0.99</prompt> (ver la sección de fuentes) para
		cambiar las fuentes mediante la carga de las mismas en el dispositivo de
		consola.
		</para>

		<para>
		Asegúrese de que no sean módulos (No es seguro que sea posible compilarlos
		todavía como módulos; por favor corríjame si me equivoco en esto).
		</para>

		<para>
		Es necesario crear los dispositivos framebuffer en el directorio <prompt>dev</prompt>.
		Introduciendo un enlace por cada por cada dispositivo framebuffer, así
		para crear el primer dispositivo ejecutamos el comando <prompt>mknod </prompt>dev/fb0
		c 29 0/. El resto de dispositivos serán múltiplos de 32, por ejemplo, para
		crear el dispositivo <prompt>dev</prompt>fb1/ deberá emplear el comando <prompt remap="tt">mknod
		/dev/fb1 c 29 32</prompt>, y así en adelante hasta el octavo dispositivo
		framebuffer (<prompt>mknod /dev/fb7 c 29 224</prompt>).
		</para>

		<para>
		Entoces recompile el núcleo, modifique el fichero <prompt>/etc/lilo.conf</prompt>
		incluyendo el parámetro <prompt>VGA=ASK</prompt>, y ejecute <prompt>lilo</prompt>. Todo esto es
		requerido para que usted pueda seleccionar los modos que desee utilizar.
		</para>

		<para>
		A continuación puede observar un ejemplo de configuración para <prompt>LILO</prompt>
		(extraido de mi máquina):
		</para>

		<para>

			<screen>
				# LILO configuration file
				boot = /dev/hda3
				delay = 30 
				prompt
				vga = ASK # Let user enter the desired modes
				image = /vmlinuz
			      root = /dev/hda3
				  label = Linux
				  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
			</screen>

		</para>

		<para>
		Reinicie el núcleo, y para realizar una simple prueba, intente introdudir
		el valor <prompt>0301</prompt> tras la solicitud de entrada <prompt>VGA</prompt> (este le dará una
		resolución de 640x480 con 256 colores), y podrá ver un pequeño pingüino.
		</para>

		<para>
		Tenga en cuenta que tras la solicitud de entrada <prompt>VGA</prompt>, usted deberá
		introducir un número que empieze por <prompt>0</prompt> seguido de 3 dígitos (ver la
		tabla inferior), y eliminando la 'x'. Esto no es necesario si usted esta
		utilizando LILO.
		</para>

		<para>
		Una vez que comprueba que todo funciona correctamente, puede explorar los
		distintos modos VESA (mostrados a continuación) y decidir cual de ellos
		prefiere, para seguidamente introducir el parámetro <prompt>VGA=x</prompt> en el
		fichero <prompt>lilo.conf</prompt>. Cuando haya decidido que modo prefiere, mire el
		número hexadecimal equivalente de la tabla inferior y úselo (por ejemplo,
		para una resolución 1280x1024 @ 256, tendrá que usar el parámetro
		<prompt>'VGA=0x307'</prompt>), y re-ejecutar <prompt>lilo</prompt>. Esto es todo lo que hay que
		hacer. Para referencias más extensas, lea los documentos <emphasis>Loadlin/LILO
		COMOs</emphasis>.
		</para>

		<para>
		<emphasis>¡ATENCION!</emphasis> <prompt>vesafb</prompt> no permite <prompt>scrollback buffering</prompt> por
		defecto. Usted tendrá que pasar al núcleo la opción necesaria para
		habilitarlo. Use <prompt>video=vesa:ypan</prompt> o <prompt>video=vesa:ywrap</prompt> para
		activarlo. Ambos hacen lo mismo, pero de diferente forma. <emphasis>ywrap</emphasis> es
		más rápido que <emphasis>ypan</emphasis> pero este no trabaja en tarjetas gráficas que no
		sean 100&percnt; compatibles con la norma VESA 2.0. <emphasis remap="it">ypan</emphasis> es más lento que
		<emphasis>ywrap</emphasis> pero es más compatible.  Esta opción se encuentra sólo presente
		en los núcleos 2.1.116 y superiores. Los núcleos anteriores no tienen
		soporte para <emphasis>scrollback buffering</emphasis> con los dispositivos <emphasis>vesafb</emphasis>.
		</para>
	
	</sect2>

	<sect2>
	<title>¿Qué modos VESA puedo encontrar disponibles?</title>

		<para>
		Esto realmente depende del tipo de tarjeta gráfica compatible con la norma
		VESA 2.0 que usted tenga instalada en su sistema, y de la cantidad de
		memoria de video que tenga disponible. Es sólo una manera de comprobar qué
		modos funcionan mejor con su tarjeta gráfica.
		</para>

		<para>
		La siguiente tabla muestra los números de los modos que puede utilizar en
		la solicitud del parámetro VGA (realmente, a estos modos se le han sumado
		el valor 0x200 para facilitar su referencia en la tabla):
		</para>

		<para>

			<screen>
			Colours   640x400 640x480 800x600 1024x768 1280x1024 1600x1200
			--------+-----------------------------------------------------
			 4 bits |    ?       ?     0x302      ?        ?         ?
			 8 bits |  0x300   0x301   0x303    0x305    0x307     0x31C
			15 bits |    ?     0x310   0x313    0x316    0x319     0x31D
			16 bits |    ?     0x311   0x314    0x317    0x31A     0x31E
			24 bits |    ?     0x312   0x315    0x318    0x31B     0x31F
			32 bits |    ?       ?       ?        ?        ?         ?
			</screen>

		</para>

		<para>
		Importante: 8 bits = 256 colores, 15 bits = 32,768 colores, 16 bits =
		65,536 colores, 24 bits = 16.8 millones de colores, 32 bits - igual que 24
		bits, pero los 8 bits extra pueden ser usados para otras cosas, y se
		adapta perfectamente con el bus de 32 bit PCI/VLB/EISA.
		</para>

		<para>
		El documento VESA 2.0 sólo define modos hasta el 0x31F, aunque en
		ocasiones el fabricante ofrece modos adicionales. No es una tarea
		complicada encontrar estos modos adicionales.
		</para>

	</sect2>

	<sect2>
	<title>Tarjetas Matrox</title>

		<para>
		Si usted tiene una tarjeta gráfica Matrox, realmente no necesita el driver
		<emphasis>vesafb</emphasis>, en su lugar tendrá que utilizar el controlador <emphasis>matroxfb</emphasis>.
		Este incrementa en gran medida las capacidades de su tarjeta.
		<emphasis>Matroxfb</emphasis> trabajará con las tarjetas <emphasis>Matrox Mystique Millennium I
		&#38; II</emphasis>, <emphasis>G100</emphasis> y <emphasis>G200</emphasis>. Este también soporta sistemas
		<emphasis>multiencabezado</emphasis> (es decir, si tiene dos tarjetas Matrox en su
		máquina, puede utilizar dos pantallas en la misma máquina!). Para
		configurar su tarjeta Matrox necesitará realizar lo siguiente:
		</para>

		<para>
		Si usted quiere actualizar su BIOS, puede obtener las actualizaciones de:
		<ulink url="http://www.matrox.com/mgaweb/drivers/ftp_bios.htm">
		http://www.matrox.com/mgaweb/drivers/ftp_bios.htm</ulink>. Sea
		cuidadoso porque puede necesitar el DOS para realizar esto.
		</para>

		<para>
		Vaya al menú <emphasis>Code Maturity Level</emphasis>, y habilite la opción para
		<emphasis>development and</emphasis>or incomplete drivers/ (Tenga en cuenta que esta
		opción puede cambiar para núcleos futuros - cuando esto suceda, este
		documento será revisado).
		</para>
	
		<para>
		Vaya al menú <emphasis>Console Drivers</emphasis>, y habilite lo siguiente:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						VGA Text Console
					</para>
				</listitem>
				<listitem>

					<para>
						Video Selection Support
					</para>
				</listitem>
				<listitem>

					<para>
						Support for frame buffer devices (experimental)
					</para>
				</listitem>
				<listitem>

					<para>
						Matrox Acceleration
					</para>
				</listitem>
				<listitem>

					<para>
						Seleccione la tarjeta que posea:

					<itemizedlist>
						<listitem>

							<para>
								Millennium I/II support
							</para>
						</listitem>
						<listitem>
	
							<para>
								Mystique support
							</para>
						</listitem>
						<listitem>

							<para>
								G100/G200 support
							</para>
						</listitem>

					</itemizedlist>

					</para>
				</listitem>
				<listitem>

					<para>
						Seleccione <emphasis>Multihead Support</emphasis> si quiere usar más de una
						tarjeta Matrox.
					</para>
				</listitem>
				<listitem>

					<para>
						Advanced Low Level Drivers
					</para>
				</listitem>
				<listitem>

					<para>
						Select Mono, 2bpp, 4bpp, 8bpp, 16bpp, 24bpp and 32bpp packed pixel
						drivers
					</para>
				</listitem>

			</itemizedlist>

		</para>

		<para>
		Recompile el núcleo. A continuación modifique el fichero <prompt>lilo.conf</prompt>
		para habilitar el dispositivo <emphasis>Matroxfb</emphasis>. La forma más rápida y
		sencilla es re-utilizar mi configuración:
		</para>

		<para>

			<screen>
				# LILO configuration file
				boot = /dev/hda3
				delay = 30 
				prompt
				vga = 792    # You need to do this so it boots up in a sane state
				# Linux bootable partition config begins
				image = /vmlinuz
				  append = "video=matrox:vesa:440" # then switch to Matroxfb
				  root = /dev/hda3
				  label = Linux
				  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
			</screen>

		</para>

		<para>
		Finalmente, necesitará crear los dispositivos framebuffer en el directorio
		<prompt>dev</prompt>. Necesitará crear un enlace por cada por cada dispositivo
		framebuffer, así para crear el primer dispositivo ejecutamos el comando
		<prompt>mknod /dev/fb0 c 29 0</prompt>. El resto de dispositivos serán múltiplos
		de 32, por ejemplo, para crear el dispositivo <prompt>/dev/fb1</prompt> deberá
		emplear el comando <prompt>mknod /dev/fb1 c 29 32</prompt>, y así en adelante
		hasta el octavo dispositivo framebuffer (<prompt>mknod /dev/fb7 c 29
		224</prompt>).
		</para>

		<para>
		¡Y eso es todo! (NOTA: Si alguien esta utilizando el soporte
		multiencabezado, por favor, contacte conmigo LO ANTES POSIBLE - ¡Necesito
		hablar con usted lo antes posible para documentar esto!).
		</para>

	</sect2>

	<sect2>
	<title>Tarjetas Permedia</title>

		<para>
		Las tarjetas Permedia no pueden ser utilizadas con los controladores
		<emphasis>vesafb</emphasis>, pero afortunadamente, existe un controlador disponible para
		utilizar framebuffer con las tarjetas Permedia. Asumiendo que está
		utilizando <prompt>menuconfig</prompt>, realice lo siguiente:
		</para>

		<para>
		Vaya al menú <emphasis>Code Maturity Level</emphasis>, y habilite la opción para
		<emphasis>development and</emphasis>or incomplete drivers/ (Tenga en cuenta que esta
		opción puede cambiar para núcleos futuros - cuando esto suceda, este
		documento será revisado).
		</para>

		<para>
		Vaya al menú <emphasis>Console Drivers</emphasis> y seleccione lo siguiente:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						VGA Text Console 
					</para>
				</listitem>
				<listitem>
	
					<para>
						Video Selection Support 
					</para>
				</listitem>
				<listitem>

					<para>
						Support for frame buffer devices (experimental) 
					</para>
				</listitem>
				<listitem>

					<para>
						Permedia2 support (experimental)
					</para>
				</listitem>
				<listitem>

					<para>
						Generic Permedia2 PCI board support
					</para>
				</listitem>
				<listitem>

					<para>
						Advanced Low Level Drivers 
					</para>
				</listitem>
				<listitem>

					<para>
						Select Mono, 2bpp, 4bpp, 8bpp, 16bpp, 24bpp and 32bpp packed pixel
						drivers
					</para>
				</listitem>
				<listitem>

					<para>
						Opcionalmente, seleccione lo siguiente, si usted desea usar fuentes
						precompiladas

						<itemizedlist>
							<listitem>

								<para>
									Select compiled-in fonts
								</para>
							</listitem>
							<listitem>
	
								<para>
									Select Sparc console 12x22 font
								</para>
							</listitem>

						</itemizedlist>

					</para>
				</listitem>

			</itemizedlist>
	
		</para>

		<para>
		Recompile el núcleo. A continuación modifique el fichero <prompt>lilo.conf</prompt>
		para habilitar el dispositivo <emphasis>pm2fb</emphasis>. La forma más rápida y sencilla
		es re-utilizar mi configuración:
		</para>

		<para>
	
			<screen>
				# LILO configuration file
				boot = /dev/hda3
				delay = 30 
				prompt
				vga = 792    # You need to do this so it boots up in a sane state
				# Linux bootable partition config begins
				image = /vmlinuz
				  append = "video=pm2fb:mode:1024x768-75,font:SUN12x22,ypan"
				# then switch to pm2fb
				  root = /dev/hda3
				  label = Linux
				  read-only
				# Non-UMSDOS filesystems should be mounted read-only for checking
			</screen>

		</para>

		<para>
		La línea «<prompt>pm2fb:mode:1024x768-75,font:SUN12x22,ypan</prompt>» significa que
		usted está seleccionando un modo de 1024x768 a 75Hz, con las fuentes
		<emphasis>SUN12x22</emphasis> seleccionadas (si las ha incluido previamente), incluyendo
		<prompt>ypan</prompt> para soporte <emphasis>scrollback</emphasis>. Puede seleccionar otros modos si
		usted lo desea.
		</para>

		<para>
		Finalmente, necesitará crear los dispositivos framebuffer en el directorio
		<prompt>dev</prompt>. Necesitará crear un enlace por cada por cada dispositivo
		framebuffer, así para crear el primer dispositivo ejecutamos el comando
		<prompt>mknod /dev/fb0 c 29 0</prompt>. El resto de dispositivos serán múltiplos
		de 32, por ejemplo, para crear el dispositivo <prompt>/dev/fb1</prompt> deberá
		emplear el comando <prompt>mknod /dev/fb1 c 29 32</prompt>, y así en adelante
		hasta el octavo dispositivo framebuffer (<prompt>mknod /dev/fb7 c 29
		224</prompt>).
		</para>

		<para>
		Para más información acerca de otras características de los controladores
		frameuffer para tarjetas Permedia visite la página:<ulink
		url="http://www.cs.unibo.it/~nardinoc/pm2fb/index.html">
		http://www.cs.unibo.it/~nardinoc/pm2fb/index.html</ulink>.
		</para>

		<para>
		<prompt>video=pm2fb:[option[,option[,option...]]]</prompt>
		</para>

		<para>
		donde <prompt>option</prompt> tomará algún valor de los siguientes:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						<prompt>off</prompt> para desabilitar el controlador. 
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>mode:resolution</prompt> para establecer la resolución de la consola.
						Los modos han sido cogidos del fichero <prompt>fb.modes.ATI</prompt> en el paquete
						<prompt>fbset</prompt> de Geert. La profundidad de todos los modos es de 8bpp.
						Esta es la lista de modos disponibles: 

					<itemizedlist>
						<listitem>

							<para>
								640x480-(60,72,75,90,100)
							</para>
						</listitem>
						<listitem>

							<para>
								800x600-(56,60,70,72,75,90,100) 
							</para>
						</listitem>
						<listitem>

							<para>
								1024x768-(60,70,72,75,90,100,illo) illo=80KHz 100Hz 
							</para>
						</listitem>
						<listitem>

							<para>
								1152x864-(60,70,75,80) 
							</para>
						</listitem>
						<listitem>

							<para>
								1280x1024-(60,70,74,75)
							</para>
						</listitem>
						<listitem>

							<para>
								1600x1200-(60,66,76)
							</para>
						</listitem>

					</itemizedlist>

					</para>
				</listitem>
				<listitem>

					<para>
						La resolución por defecto es 640x480-60. 
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>font:font name</prompt> para establecer las fuentes de consola.
						Ejemplo: <prompt>font:SUN12x22</prompt>
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>ypan</prompt> establece la altura de la pantala tan grande como sea
						posible dependiendo del tamaño permitido por la memoria de video.
					</para>
				</listitem>
				<listitem>
	
					<para>
						<prompt>oldmem</prompt> esta opción es sólamente para usuarios
						<emphasis>CybervisionPPC</emphasis>. Especifique esta opción si su placa tiene montado
						<emphasis>Fujitsu SGRAMs</emphasis> (todos los <emphasis>CVisionPPCs</emphasis> antes del 30 de Diciembre
						de 1998).
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>virtual</prompt> (provisional) especifique esta opción si su núcleo
						acota las regiones PCI en su plataforma. 
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>Tarjetas ATI</title>

		<para>
		(NOTA: Esta información es en el mejor de los casos, información de
		segunda o tercera mano, dado que yo no poseo una tarjeta ATI para
		comprobar esta. Siéntase libre de corregirme si estoy equivocado! 8).
		</para>

		<para>
		Las tarjetas ATI pueden ser usadas con los controladores <emphasis>vesafb</emphasis>,
		puede o no tener problemas, dependiendo de como de horriblemente mala sea
		su tarjeta. Afortunadamente, exite un controlador framebuffer <emphasis>atyfb</emphasis>
		disponible para estas tarjetas. Asumiendo que esta usando <prompt>menuconfig</prompt>,
		realice lo siguiente:
		</para>

		<para>
		Vaya al menú <emphasis>Code Maturity Level</emphasis>, y habilite la opción para
		<emphasis>development and</emphasis>or incomplete drivers/ (Tenga en cuenta que esta
		opción puede cambiar para núcleos futuros - cuando esto suceda, este
		documento será revisado).
		</para>

		<para>
		Vaya al menú <emphasis>Console Drivers</emphasis> y seleccione lo siguiente:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						VGA Text Console
					</para>
				</listitem>
				<listitem>

					<para>
						Video Selection Support
					</para>
				</listitem>
				<listitem>

					<para>
						Support for frame buffer devices (experimental)
					</para>
				</listitem>
				<listitem>

					<para>
						ATI Mach64 display support      
					</para>
				</listitem>
				<listitem>

					<para>
						Advanced Low Level Drivers
					</para>	
				</listitem>
				<listitem>

					<para>
						Select Mono, 2bpp, 4bpp, 8bpp, 16bpp, 24bpp and 32bpp packed pixel
						drivers
					</para>
				</listitem>
				<listitem>

					<para>
						Opcionalmente, seleccione lo siguiente, si usted desea usar fuentes
						precompiladas

						<itemizedlist>
							<listitem>

								<para>
									Select compiled-in fonts
								</para>
							</listitem>
							<listitem>

								<para>
									Select Sparc console 12x22 font
								</para>
							</listitem>
	
						</itemizedlist>

					</para>
				</listitem>

			</itemizedlist>

		</para>

		<para>
		Recompile el núcleo. A continuación modifique el fichero <prompt>lilo.conf</prompt>
		para habilitar el dispositivo <emphasis>pm2fb</emphasis>. La forma más rápida y sencilla
		es re-utilizar mi configuración:
		</para>

		<para>

			<screen>
				# LILO configuration file
				boot = /dev/hda3
				delay = 30
				prompt
				vga = 792    # You need to do this so it boots up in a sane state
				# Linux bootable partition config begins
				image = /vmlinuz
				  append = "video=atyfb:1024x768,font:SUN12x22"
				  root = /dev/hda3
				  label = Linux
				  read-only
				# Non-UMSDOS filesystems should be mounted read-only for checking
			</screen>

		</para>

		<para>
		La línea «<prompt>atyfb:mode:1024x768,font:SUN12x22</prompt>» indica que usted esta
		seleccionando un modo de resolución de 1024x768.
		</para>
	
		<para>
		Finalmente, necesitará crear los dispositivos framebuffer en el directorio
		<prompt>dev</prompt>. Necesitará crear un enlace por cada por cada dispositivo
		framebuffer, así para crear el primer dispositivo ejecutamos el comando
		<prompt>mknod /dev/fb0 c 29 0</prompt>. El resto de dispositivos serán múltiplos
		de 32, por ejemplo, para crear el dispositivo <prompt>/dev/fb1</prompt> deberá
		emplear el comando <prompt>mknod /dev/fb1 c 29 32</prompt>, y así en adelante
		hasta el octavo dispositivo framebuffer (<prompt>mknod /dev/fb7 c 29
		224</prompt>).
		</para>

		<para>
		<prompt>video=atyfb:[option[,option[,option...]]]</prompt>
		</para>

		<para>
		donde <prompt>option</prompt> tomará algún valor de los siguientes:
		</para>

		<para>

			<itemizedlist>
				<listitem>
			
					<para>
						<prompt>font:STRING</prompt> selecciona la fuente a construir
						(compilada dentro del núcleo)
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>noblink</prompt> Apaga el parpadeo
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>noaccel</prompt> Desabilita la aceleración
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>vram:ULONG</prompt> Informa al controlador <prompt>atyfb</prompt> de cuanta memoria
						tiene disponible
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>pll:ULONG</prompt> Desconocido
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>mclk:ULONG</prompt> Desconocido
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>vmode:ULONG</prompt> Desconocido
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>cmode:ULONG</prompt> - establece la profundidad - 0, 8, 15, 16, 24 y 32
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>¿Que tarjetas gráficas son compatibles con VESA 2.0?</title>

		<para>
		La siguiente lista muestra aquellas tarjetas gráficas de las que es
		conocido su funcionamiento con los dispositivos vesafb:
		</para>
	
		<para>
	
			<itemizedlist>
				<listitem>

					<para>
					ATI PCI VideoExpression 2MB (max. 1280x1024 @ 8bit)
					</para>
				</listitem>
				<listitem>

					<para>
						ATI PCI All-in-Wonder
					</para>
				</listitem>
				<listitem>

					<para>
						Matrox Millennium PCI - BIOS v3.0
					</para>	
				</listitem>
				<listitem>

					<para>
						Matrox Millennium II PCI - BIOS v1.5
					</para>
				</listitem>
				<listitem>
	
					<para>
						Matrox Millennium II AGP - BIOS v1.4
					</para>
				</listitem>
				<listitem>

					<para>
						Matrox Millennium G200 AGP - BIOS v1.3
					</para>
				</listitem>
				<listitem>

					<para>
						Matrox Mystique &#38; Mystique 220 PCI - BIOS v1.8
					</para>
				</listitem>
				<listitem>

					<para>
						Matrox Mystique G200 AGP - BIOS v1.3
					</para>
				</listitem>
				<listitem>

					<para>
						Matrox Productiva G100 AGP - BIOS v1.4
					</para>
				</listitem>
				<listitem>

					<para>
						Todas las tarjetas basadas en la Riva 128
					</para>
				</listitem>
				<listitem>

					<para>
						Diamond Viper V330 PCI 4MB
					</para>
				</listitem>
				<listitem>

					<para>
						Genoa Phantom 3D/S3 ViRGE/DX
					</para>
				</listitem>
				<listitem>

					<para>
						Hercules Stingray 128/3D con salida de TV
					</para>
				</listitem>
				<listitem>

					<para>
						Hercules Stingray 128/3D con salida de TV - necesita una
						actualización de la BIOS (support@hercules.com)
					</para>
				</listitem>
				<listitem>

					<para>
						SiS 6326 PCI/AGP 4MB 
					</para>
				</listitem>
				<listitem>

					<para>
						STB Lightspeed 128 (Nvida Riva 128 based) PCI 
					</para>
				</listitem>
				<listitem>	

					<para>
						STB Velocity 128 (Nvida Riva 128 based) PCI
					</para>
				</listitem>
				<listitem>

					<para>
						Jaton Video-58P ET6000 PCI 2MB-4MB (max. 1600x1200 @ 8bit)
					</para>
				</listitem>

			</itemizedlist>
	
		</para>

		<para>
		Esta lista esta formada por <emphasis>chipsets</emphasis> de placas-madre soportadas:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						Trident Cyber9397
					</para>
				</listitem>
				<listitem>

					<para>
						SiS 5598
					</para>
				</listitem>

			</itemizedlist>

		</para>

		<para>
			La siguiente lista-negra muestra las tarjetas gráficas que no trabajan con
			dispositivos <emphasis>vesafb</emphasis>:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						TBA
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>¿Puedo compilar <prompt>vesafb</prompt> como modulo?</title>

		<para></para>
		
		<para>
		Hasta donde llega mi información, los controladores <prompt>vesafb</prompt> no pueden
		ser modularizados, aunque en cualquier momento, el desarrollador de
		<prompt>vesafb</prompt> puede decidir modificar los fuentes para permitir esta
		modularización. Tenga en cuenta que aunque fuera posible dicha
		modularización, en el momento del arranque usted no podría ver ninguna
		salida por pantalla hasta que el controlador <prompt>vesafb</prompt> fuera cargado
		(<emphasis>modprobe</emphasis>d). Probablemente, dejar este controlador en el núcleo sea
		la decisión más sabia, sobre todo para los casos en los que existen
		problemas durante el arranque.
		</para>

	</sect2>

	<sect2>
	<title>¿Cómo puedo modificar el cursor?</title>

		<para>
		(Cogido de <prompt>VGA-softcursor.txt</prompt> - ¡Gracias a Martin Mares!).
		</para>

		<para>
		Linux tiene hoy en dia la capacidad de manipular el aspecto de nuestro
		cursor. Normalmente, usted puede fijar el tamaño del cursor hardware (y
		también trabajar alrededor de algún desagradable error en aquellas
		desgraciadas tarjetas Trident -- Ver <prompt>&num;define TRIDENT_GLITCH</prompt> en
		<prompt>drivers</prompt>char/vga.c/). En el caso de que habilite la opción «Software
		generated cursor» en la configuración del sistema, puede probar algunos
		trucos nuevos: puede hacer que su cursor aparezca como un bloque rojo
		no-parpadeante, puede invertir el color de fondo del carácter sobre el que
		se situe o para destacar el carácter y elegir si el cursor hardware
		original debe permanecer visible o no. Hay algunas otras cosas sobre las
		que nunca he pensado.
		</para>

		<para>
		La apariencia del cursor es controlado por una secuencia de escape
	
			<screen>
				&#60;ESC&#62;[?1;2;3c
			</screen>
			 donde 1, 2 y 3 son los
			parámetros que describo a continuación. Si omite alguno de estos
			parámetros, serán establecidos por defecto a cero.
		</para>

		<para>
		El parámetro 1 especifica el tamaño del cursor (0 = por defecto, 1 =
		invisible, 2 = subrayado, ..., 8 = bloque completo), + 16 si quiere que
		sea aplicado el cursor software, + 32 si quiere que siempre cambie el
		color de fondo, + 64 si no desea tener el mismo color para el fondo
		(<prompt>background</prompt>) y primer plano (<prompt>foreground</prompt>). Las acentuaciones
		(<prompt>highlights</prompt>) son ignoradas por los últimos dos flags.
		</para>

		<para>
		El segundo parámetro selecciona los bits de atributo para el carácter que
		usted desea cambiar (realizando un simple XOR con el valor de este
		parámetro). En las VGA estándar, los cuatro bits superiores especifican el
		color de fondo y los cuatro bits inferiores el color de primer plano. En
		ambos grupos, los 3 bits inferiores establecen el color (como un código de
		color normal utilizado por la pantalla) y el bit más significante activa
		la acentuación (algunas veces parpadeante -- esto depende de la
		configuración de su VGA).
		</para>

		<para>
		El tercer parámetro consiste en los bits de atributo para el carácter que
		usted quiere establecer. El «bit setting» tiene lugar antes del «bit
		toggling», así que puede simplemente borra un bit incluyendolo tanto en
		«set mask» como en «toggle mask».
		</para>

		<para>
			<variablelist>

				<varlistentry>
					<term>Para obtener un subrayado parpadeante:</term>
					<listitem>
						<para>

							<screen>
								echo -e '\033[?2c'
							</screen>

						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Para obtener un bloque parpadeante:</term>
					<listitem>
						<para>
							<screen>
								echo -e '\033[?6c'
							</screen>

						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Para establecer un bloque rojo no-parpadeante:</term>
					<listitem>
						<para>

							<screen>
								echo -e '\033[?17;0;64c'
							</screen>

						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</para>

	</sect2>

</sect1>

<sect1>
<title>Usando dispositivos framebuffer en plataformas Atari m68k</title>

	<para>
	Esta sección describe las opciones framebuffer en plataformas Atari m68k.
	</para>

	<sect2>
	<title>¿Qué modos están disponibles en plataformas Atari m68k?</title>

		<para>

			<screen>
				Colours   320x200 320x480 640x200 640x400 640x480 896x608 1280x960
				--------+---------------------------------------------------------
				 1 bit  |                         sthigh   vga2    falh2   tthigh
				 2 bits |                 stmid            vga4
				 4 bits | stlow                         ttmid/vga16 falh16
				 8 bits |         ttlow                   vga256
			</screen>

		</para>

		<para>
		<prompt>ttlow, ttmid y tthigh</prompt> son usados únicamente por TT, mientras que
		<prompt>vga2, vga4, vga15, vga256, falh3 y falh16</prompt> son usados por Falcon.
		</para>

		<para>
		Cuando utilizamos la opción del núcleo <prompt>video=xxx</prompt>, y no incluimos
		subopciones, el núcleo probará los siguientes modos en el orden que
		indicamos hasta que encuentra un modo disponible por el hardware:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						<prompt>ttmid</prompt>
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>tthigh</prompt>
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>vga16</prompt>
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>sthigh</prompt>
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>stmid</prompt>
					</para>
				</listitem>

			</itemizedlist>

		</para>

		<para>
		Puede especificar un modo particular si no desea probar de forma
		automática (<prompt>auto-probe</prompt>) el resto de modos. Por ejemplo,
		<prompt>video=vga16</prompt> le dará una resolución de 640x480 en pantalla con 4 bits
		para el color.
		</para>

	</sect2>

	<sect2>
	<title>Subopciones adicionales en plataformas Atari m68k</title>

		<para>
		Existen un número de subopciones disponibles para el parámetro
		<prompt>video=xxx</prompt>:
		</para>

		<para>
	
			<itemizedlist>
				<listitem>

					<para>
						<prompt>inverse</prompt> - invierte la pantalla de forma que los colores de
						fondo y primer plano (<prompt>background/foreground</prompt>) son reservados.
						Normalmente el color de fondo es negro, mientras que con esta subopción,
						este se pone en blanco.
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>font</prompt> - establece las fuentes a usar en los modos de texto.
						Actualmente usted puede seleccionar únicamente <prompt>VGA8x8</prompt>, <prompt>VGA8x16</prompt>,
						<prompt>PEARL8x8</prompt>. Por defecto es usado <prompt>VGA8x8</prompt> únicamente si el tamaño
						vertical de la pantalla es menor de 400 picels, de lo contrario se emplea
						por defecto <prompt>VGA8x16</prompt>.
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>internal</prompt> - una opción muy interesante. Ver la siguiente sección
						para más información.
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>external</prompt> - como arriba.
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>monitorcap</prompt> - describe las posibilidades de la
						multi-sincronización. NO usar con monitores se sincronización fija!.
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>Usando la subopción <prompt>internal</prompt> en plataformas Atari m68k</title>

		<para>
		Sintaxis: <prompt>internal:(xres);(yres)[;(xres_max);(yres_max);(offset)]</prompt>
		</para>

		<para>
		Esta opción especifica las posibilidades añadidas del hardware de video
		interno, por ejemplo los modos <prompt>OverScan</prompt>. <prompt>(xres)</prompt> y <prompt>(yres)</prompt>
		obtiene las dimensiones añadidas de la pantalla.
		</para>
	
		<para>
		Si su modo OverScan necesita un borde negro, deberá escribir los últimos 3
		argumentos de la subopción <prompt>internal:</prompt>.  <prompt>(xres_max)</prompt> es la longitud
		máxima de línea permitida por el hardware, <prompt>(yres_max)</prompt> es el número
		máximo de líneas, y <prompt>(offset)</prompt> es el desplazamiento de la parte visible
		de la memoria de pantalla desde el inicio físico, en bytes.
		</para>

		<para>
		A menudo, las ampliaciones de hardware de video interno tienen que ser
		activadas, para esto necesitará las opciones <prompt>"switches=*"</prompt>. (Nota: El
		autor desearía recibir información ampliada de todo esto, por favor. La
		documentación de m68k en el núcleo no es suficientemente clara en este
		punto, y el autor no tiene un Atari! Los ejemplos también serán útiles)
		</para>
	
	</sect2>

	<sect2>
	<title>Usando la subopción <prompt>external</prompt> en plataformas Atari m68k</title>

		<para>
		Sintaxis:
		<prompt>external:(xres);(yres);(depth);(org);(scrmem)[;(scrlen)[;
		(vgabase)[;(colw)[;(coltype)[;(xres_virtual)]]]]]</prompt>
		</para>

		<para>
		Esto es un poco complicado, de forma que este documento intentará
		explicarlo tan claro como sea posible, pero el Autor apreciaría que
		alguien le echara un vistazo! :o)
		</para>

		<para>
		Esta opción especifica que usted tiene un hardware video externo
		(probablemente una tarjeta gráfica), y como usarla con Linux. El núcleo
		esta básicamente limitado a lo que se conoce como hardware de video
		interno, así que tiene que suministrar los parámetros necesarios para
		habilitar el uso de hardware de video externo. Existen dos limitaciones;
		usted debe cambiar el modo antes de arrancar, y una vez arrancado, ya no
		podrá cambiar el modo.
		</para>

		<para>
		Los primeros tres parámetros son obvios; obtiene las dimensiones de la
		pantalla por altura, anchura y profundidad en pixels. La profundidad
		proporcionada debe ser el número de colores 2&circ;n dado por el número de
		planos requeridos. Por ejemplo, si desea utilizar una resolución de 256
		colores, entonces tendrá que utilizar el valor 8 como profundidad. Esto
		depende del hardware de video externo, aunque estará limitado por lo que
		el hardware pueda hacer.
		</para>

		<para>
		Continuando, usted necesitará informar al núcleo acerca de la organización
		de memoria de video - proporcionando una letra como parámetro <prompt>(org)</prompt>:
		</para>
	
		<para>
	
			<itemizedlist>
				<listitem>
	
					<para>
						<prompt>n</prompt> - utilizar planos normales, por ejemplo un plano completo
						despues de otro.
					</para>
				</listitem>
				<listitem>
	
					<para>
						<prompt>i</prompt> - utilizar planos entrelazados, por ejemplo 16 bits del
						primer plano, despues 16 bits del siguiente plano y así en adelante.
						Sólamente los modos de video de Atari integrados (<prompt>built-in</prompt>) utilizan
						esto - y no hay tarjetas gráficas que soporten este modo.
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>p</prompt> - utilizar pixels comprimidos, por ejemplo bits consecutivos
						presentan todos los planos para un pixel. Este es el modo más común para
						las resoluciones de 256 colores en tarjetas gráficas.
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>t</prompt> - utilizar color real, por ejemplo esto es realmente pixels
						comprimidos, pero no requiere una tabla de colores como los modos que
						utilizan el pixel comprimido. Estos modos poseen normalmente una
						resolución de 24 bits - lo que posibilita la utilización de un total de
						16.8 millones de colores.
					</para>
				</listitem>

			</itemizedlist>

		</para>
	
		<para>
		<emphasis>Sin embargo</emphasis>, para modos monocromo, el parámetro <prompt>(org)</prompt> tiene un
		significado diferente:
		</para>		

		<para>

			<itemizedlist>
				<listitem>

					<para>
						<prompt>n</prompt> - utilizar colores normales, por ejemplo 0=blanco, 1=negro
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>i</prompt> - utilizar colores invertidos, por ejemplo 0=negro, 1=blanco
					</para>
				</listitem>

			</itemizedlist>

		</para>

		<para>
		La siguiente opción importante acerca del hardware de video es la
		dirección base de la memoria de video. Esto es dado por el parámetro
		<prompt>(scrmem)</prompt> como un número hexadecimal con el prefijo <prompt>0x</prompt>. Usted
		necesitará encontrar ésta de la documentación que viene con su hardware de
		video externo.
		</para>

		<para>
		El siguiente parámetro <prompt>(scrlen)</prompt> informa al núcleo acerca del tamaño
		de la memoria de video. Si este es ausente, es calculado de los parámetros
		<prompt>(xres)</prompt>, <prompt>(yres)</prompt> y <prompt>(depth)</prompt>. De todas formas hoy en dia no es
		útil escribir un valor aquí. Para dejar esto vacío, si necesitas dar el
		<prompt>(vgabase)</prompt> deja dos puntos y coma consecutivos, si no, déjalo.
		</para>

		<para>
		El parámetro <prompt>(vgabase)</prompt> es opcional. Si éste no es dado, el núcleo no
		puede leer/escribir ningún registro de color del hardware de vídeo, y así
		tienes que establecer los colores apropiados antes de iniciar Linux. Pero
		si tu tarjeta es compatible VGA, puede darle la direccion donde puede
		encontrarse establecido el registro VGA de modo que pueda cambiar las
		tablas de color. Esta informacion se puede encontrar en la documentacion
		de su hardware de video externo. Para hacer esto <emphasis>mas claro</emphasis>,
		<prompt>(vgabase</prompt> es la direccion <emphasis>base</emphasis>, p.e. una direccion alineada a 4k.
		Para leer/escribir en los registros de color, el nucleo usa un rango de
		direcciones entre <prompt>(vgabase) + 0x3c7</prompt> y <prompt>(vgabase) + 0x3c9</prompt>. Este
		parametro se da en hexadecimal y debe tener un prefijo <prompt>0x</prompt>, justo como
		<prompt>((scrmem)</prompt>.
		</para>

		<para>
		<prompt>(colw)</prompt> es solo significativo, si el parametro <prompt>(vgabase</prompt> es
		especificado. Este le dice al nucleo que ancho tiene cada registro de
		color, p.e. el numero de bits por color simple (rojo/verde/azul). Por
		defecto son normalmente 6 bits, pero ademas es comun especificarlo a 8
		bits.
		</para>

		<para>
		<prompt>(coltype)</prompt> es usado con el parametro <prompt>(vgabase)</prompt>, le dice al nucleo
		sobre el modelo de registro de color de su tarjeta grafica. Actualmente
		los tipos soportados son <prompt>vga</prompt> y <prompt>mv300</prompt>. <prompt>vga</prompt> está por defecto.
		</para>

		<para>
		<prompt>(xres_virtual)</prompt> es solo requerido para las tarjetas ProMST/ET4000
		donde la longitus de linea fisica no coincide con la longitud visible. Con
		ProMST, necesitará indicarle 2048, mientras que para ET4000, depende de la
		inicializacion de la tarjeta grafica.
		</para>

	</sect2>

</sect1>

<sect1>
<title>Usando dispositivos framebuffer en plataformas Amiga m68k</title>

	<para></para>

	<para>
	Esta sección describe las opciones para Amigas que son bastante similiares
	a las que hay en las plataformas Atari m68k.
	</para>

	<sect2>
	<title>¿Que modos estan disponibles para plataformas Amiga m68k?</title>

		<para>
		Esto depende del chipset usado en el Amiga. Hay tres principalmente:
		<prompt>OCS, ECS y AGA</prompt>, y ambos usan el dispositivo de color del framebuffer
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						Los modos NTSC
	
						<itemizedlist>
							<listitem>

								<para>
									<prompt>ntsc</prompt> - 640x200
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>ntsc-lace</prompt> - 640x400 
								</para>
							</listitem>

						</itemizedlist>

					</para>
				</listitem>
				<listitem>

					<para>
						Modos PAL

						<itemizedlist>
							<listitem>

								<para>
									<prompt>pal</prompt> - 640x256 
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>pal-lace</prompt> - 640x512
								</para>
							</listitem>

						</itemizedlist>

					</para>
				</listitem>
				<listitem>

					<para>
						los modos ECS - 2 bits de color en ECS, 8 bits de color en los
						chipsets de AGA solamente.

						<itemizedlist>
							<listitem>
	
								<para>
									<prompt>multiscan</prompt> - 640x480
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>multiscan-lace</prompt> - 640x960
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>euro36</prompt> - 640x200
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>euro36-lace</prompt> - 640x400
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>euro72</prompt> - 640x400
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>euro72-lace</prompt> - 640x800
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>super72</prompt> - 800x300
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>super72-lace</prompt> - 800x600
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>dblntsc</prompt> - 640x200
								</para>
							</listitem>
							<listitem>
		
								<para>
									<prompt>dblpal</prompt> - 640x256
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>dblntsc-ff</prompt> - 640x400
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>dblntsc-lace</prompt> - 640x800
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>dblpal-ff</prompt> - 640x512
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>dblpal-lace</prompt> - 640x1024
								</para>
							</listitem>

						</itemizedlist>

					</para>
				</listitem>
				<listitem>

					<para>
						Modos de VGA - 2 bits de color en ECS, 8 bits de color solo en 
						los chipsets de AGA. 

						<itemizedlist>
							<listitem>

								<para>
									<prompt>vga</prompt> - 640x480
								</para>
							</listitem>
							<listitem>

								<para>
									<prompt>vga70</prompt> - 640x400
								</para>
							</listitem>
	
						</itemizedlist>

					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>Subopciones adicionales en plataformas Amiga m68k</title>
	
		<para>
			Son similares a las subopciones del Atari m68k. Estas son:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						<prompt>Depth (Profundidad)</prompt> - especifica la profundidad de bits del
						pixel.
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>inverse</prompt> - hace lo mismo que la subopcion de Atari.
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>font</prompt> - hace lo mismo que la subopcion de Atari, aunque la
						fuente <prompt>PEARL8x8</prompt> se usa en lugar de la fuente <prompt>VGA8x8</prompt> caracteres,
						si el tamaño de la pantalla es menor de 400 pixel de ancho.
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>monitorcap</prompt> - especifica las capacidades de multisincronismo del
						monitor. No la use con monitores de sincronismo fijo.
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>Tarjetas graficas de expansión soportadas por Amiga</title>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						<prompt>Phase5 CyberVision 64</prompt> (S3 Trio64 chipset)
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>Phase5 CyverVision 64-3D</prompt> (S3 ViRGE chipset)
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>MacroSystems RetinaZ3</prompt> (NCR 77C32BLT chipset)
					</para>
				</listitem>
				<listitem>

					<para>
						<prompt>Helfrich Piccolo, SD64, GVP ECS Spectrum, Village Tronic Picasso
						II</prompt>II+ y IV/ (Cirrus Logic GD542x/543x)
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

</sect1>

<sect1>
<title>Usando dispositivos de framebuffer en plataformas Macintosh m68k</title>

	<para>
	Actualmente, el dispositivo del framebuffer implementado sólo soporta el
	modo seleccionado en MacOS antes de iniciar Linux, también soporta modos
	con una profundidad de color de 1, 2, 4 y 8 bits.
	</para>

	<para>
	Las subopciones del Framebuffer se seleccionan usando la sintaxis
	siguiente:
	</para>

	<para>

		<screen>
			video=macfb:&#60;font&#62;:&#60;inverse&#62;
		</screen>

	</para>

	<para>
	Usted puede seleccionar fuentes como VGA8x8, VGA8x16 y 6x11 etc. La opcion
	<prompt>inverse</prompt> le permite usar video inverso.
	</para>

</sect1>

<sect1>
<title>Usando dispositivos de framebuffer en plataformas PowerPC</title>

	<para>
	El autor agradeceria recibir información sobre el uso de framebuffers en
	esta plataforma.
	</para>

</sect1>

<sect1>
<title>Usando dispositivos de framebuffer en plataformas Alfa</title>

	<sect2>
	<title>¿Qué modos están disponibles para mí?</title>

		<para></para>

		<para>
		Hasta ahora esta unicamente la tarjeta TGA PCI - qué sólo alcanza 80x30
		con una resolución de 640x480 a 8 o 24/32 bits.
		</para>

	</sect2>

	<sect2>
	<title>¿Qué tarjetas gráficas funcionan con el dispositivo frambuffer?</title>

		<para>
		Esta es la lista de todas las tarjetas gráficas probadas:
		</para>

		<para>
	
			<itemizedlist>
				<listitem>
	
					<para>
						<prompt>DEC TGA PCI (DEC21030)</prompt> - 640x480 @ En versiones de 8 bit o
						24/32.
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

</sect1>

<sect1>
<title>Usando dispositivos de framebuffer en plataformas SPARC</title>

	<sect2>
	<title>¿Qué tarjetas gráficas pueden trabajar con el dispositivo de
	framebuffer?</title>

		<para>
		Esta es la lista de todas las tarjetas gráficas disponibles:
		</para>

		<para>

			<itemizedlist>
				<listitem>
	
					<para>
						MG1/MG2 - SBus o integrado en Sun3 - max. 1600x1280 @ mono (BWtwo)
					</para>
				</listitem>
				<listitem>
	
					<para>
						CGthree - Similar a MG1/MG2 pero con soporte de color - ¿a
						resolución maxima?
					</para>
				</listitem>
				<listitem>

					<para>
						GX - SBus - max. 1152x900 @ 8bit (CGsix)
					</para>
				</listitem>
				<listitem>

					<para>
						TurboGX - SBus - max. 1152x900 @ 8 bit (CGsix)
					</para>
				</listitem>
				<listitem>

					<para>
						SX - SS10/SS20 solo - max. 1280x1024 @ 24 bit - (CGfourteen)
					</para>
				</listitem>
				<listitem>

					<para>
						ZX(TZX) - SBus - Tarjeta aceleradora 3D de 24bit - ¿max resolucion?
						(Leo)
					</para>
				</listitem>
				<listitem>

					<para>
						TCX - AFX - Solo para Sparc 4 - max. 1280x1024 @ 8bit
					</para>
				</listitem>
				<listitem>

					<para>
						TCX(S24) - AFX - Solo para Sparc 5 - max. 1152x900 @ 24bit
					</para>
				</listitem>
				<listitem>
	
					<para>
						Creator - SBus - max. 1280x1024 @ 24bit (FFB)
					</para>
				</listitem>
				<listitem>

					<para>
						Creator3D - SBus - max. 1920x1200 @ 24bit (FFB)
					</para>
				</listitem>
				<listitem>

					<para>
						ATI Mach64 - Aceleradora de 8/24 bit solo para Sparc64 PCI
					</para>
				</listitem>

			</itemizedlist>

		</para>

		<para>
		Hay una opción para usar el PROM para la salida de caracteres por pantalla
		o por consola en serie.
		</para>

		<para>
		Ademas, eche un vistazo a la FAQ del framebuffer de sparc. 
		<ulink url="http://c3-a.snvl1.sfba.home.com/Framebuffer.html">
		http://c3-a.snvl1.sfba.home.com/Framebuffer.html</ulink>
		</para>

	</sect2>

	<sect2>
	<title>Configurando los dispositivos del framebuffer</title>

		<para></para>

		<para>
		Durante el <prompt>make config</prompt>, debe escoger si compila <prompt>promcon</prompt> y/o
		<prompt>fbcon</prompt>. Puede seleccionar ambos, pero si lo hace, necesitara
		establecer los <emphasis>Kernel flags</emphasis> para seleccionar cada dispositivo.
		<prompt>Fbcon</prompt> siempre toma preferencia si no estan establecidos. Si
		<prompt>promcon</prompt> no está seleccionado, durante el arranque, se pone por
		defecto en <prompt>dummycon</prompt>. Si el promcon está seleccionado, usará este
		dispositivo. Una vez los buses son inicializados, y <prompt>fbcon</prompt> está
		compilado, el kernel testea los FrameBuffers anteriores y usará
		<prompt>fbcon</prompt>. Si no hay dispositivos de framebuffer, tendrá como valor
		predefinido <prompt>promcon</prompt>.
		</para>

		<para>
		Aquí está las opciones del kernel:
		</para>

		<para>

			<screen>
				video=sbus:opciones
				donde "opciones" es una lista separada por comas:
				nomargins	
				Establece los margenes a 0,0
				margins=12x24   
				Establece los margenes a 12,24 (Por defecto es calculado segun la resolución)
				off		
				No prueba framebuffers SBus/UPA
				font=SUN12x22	
				usa una fuente especifica
			</screen>

		</para>

		<para>
		Por ejemplo, arrancando con:

			<screen>
				video=sbus:nomargins,font=SUN12x22
			</screen>

		Obtendrá una rapida y bonita consola en modo texto con una resolucion de
		96x40, con una apariencia similar a una consola de Solaris pero con
		colores y terminales virtuales como en la plataforma de Intel.
		</para>

		<para>
		Si quiere usar la fuente <prompt>SUN12x22</prompt> , necesita habilitarla durante el
		"Make config" (deshabilita la opción <prompt>fontwidth != 8</prompt>). Los
		framebuffers acelerados soportan cualquier ancho de la fuente entre 1 a 16
		pixels, aunque los dump framebuffers sólo soportan anchos de fuentes de 4,
		8, 12 y 16 pixeles.
		</para>

		<para>
		Es recomiendable que consiga unos paquetes de utilidades de consola
		recientes.
		</para>

	</sect2>

</sect1>

<sect1>
<title>Usando dispositivos de framebuffer en plataformas de MIPS</title>

	<para></para>

	<para>
	No hay ninguna necesidad de cambiar nada para esta plataforma, todo se
	configura automáticamente. Indyns en particular está hecho para ser usado
	con una consola de tamaño 160x64. Sin embargo, ya se está trabajando en
	reescribir el codigo de la consola para estas Indys, asi que eche un
	vistazo a esta seccion.
	</para>

</sect1>

<sect1>
<title>Usando dispositivos de framebuffer en plataformas ARM</title>

	<sect2>
	<title>Netwinders</title>

		<para>
		Para el Netwinders (qué usa el chip ARM SA110 RISC - un procesador
		británico encantador), hay dos versiones del driver del framebuffer
		Cyber2000- uno para los kernels 2.0.x y otro para los 2.2.x. Se avanza
		bastante si Ud. habilita y usa este driver en ambos kernels, Sin embargo,
		la version mas antigua ha sido optimizada para profundidad y resolución
		aunque la buena noticia es que la nueva versión en los kernels 2.2.x es
		mucho más flexible, aunque actualmente está todavía está en desarrollo.
		Para configurarlo y ejecutarlo, su mejor opcion es leer la documentación
		que viene con las fuentes del nucleo sobre el «ARM port».
		</para>

		<para>
		El Netwinders usa un chipset compatible VGA, pero desgraciadamente nadie
		ha portado vgafb todavía para él. Esto podría pasar si alguien tuviera
		algún tiempo libre (Yo lo haría si alguien me diera un NetWinder para
		jugar con él).
		</para>

	</sect2>

	<sect2>
	<title>Acorn Archimedes</title>

		<para>
		Los Acorns siempre han tenido soporte de framebuffer desde los dias del
		Linux 1.9.x. Sin embargo el driver para el Acornfb en los 2.2.x es
		totalmente nuevo desde que cambió la interfaz generica del framebuffer
		durante el desarrollo de los nucleos 2.1.x (qué, por supuesto, continuó
		con los 2.2.x).  Como previamente se ha dicho, es una forma simple para
		activar el driver y configurar profundidad y resoluciones.
		</para>
	
	</sect2>

	<sect2>
	<title>Otros ARM ports (SA 7110s et. al)</title>

		<para>
		Sorprendentemente, hay incluso un driver de framebuffer para el Psion 5 y
		¡el Geofox!  Me han dicho que muestra bastante bien el Pingüino (¡Por
		favor que alguien me done un Psion 5!).
		</para>

	</sect2>

</sect1>

<sect1>
<title>Usando Framebuffers multi-dirigidos</title>

	<para>
	Esta parte del documento ha sido donada amablemente por Frederick A. Niles
	que mantiene todos los derechos sobre la información contenida en esta
	sección del HOWTO.
	</para>

	<sect2>
	<title>Introducción</title>

		<para>
		El objetivo principal de este documento es permitirle empezar a ejecutar
		una configuración de pantalla dual en Linux. Aunque de esta forma Ud.
		puede lograr un gran avance hay muchas cosas que puede hacer mal durante
		el camino.
		</para>

		<para>
		Un ejemplo concreto es consiguir ejecutar un servidor X sobre un segundo
		monitor.  Creo interesante que Ud. pueda encontrar monitores de 19" o 21"
		viejos y grandes de frecuencia fija que la gente regala porque no pueden
		usarlos.  De esta forma usted puede abandonar un pequeño monitor
		multifrecuencia y usar X en un gran monitor.
		</para>

		<para>
		Por favor entienda el soporte de monitor dual está actualmente en
		desarrollo asi que esta información cambia rápidamente. Algo de este
		documento podría estar obsoleto o simplemente incorrecto cuando usted este
		leyendo esto.
		</para>
	
		<para>
		* * ADVERTENCIA * * Este documento se escribió antes de la salida de
		cualquier XFree86 4.0.  Si usted está leyendo esto y la version 4.0 de
		XFree86 4.0 está ya disponible muchas cosas pueden haber cambiado.  
		Intente obtener una version actualizada de este documento si está
		disponible.
		</para>

	</sect2>

	<sect2>
	<title>Sugerencias</title>

		<para>
		Las sugerencias para este documento son ciertamente bienvenidas. Sin sus
		envios y colaboración, este documento no existiría. Asi que, por favor
		envieme sus complementos, comentarios y críticas a:
		<email>Frederick.A.Niles@gsfc.nasa.gov</email>.
		</para>

	</sect2>

	<sect2>
	<title>Han contribuido</title>

		<para>
		Las personas siguientes han contribuido a este mini-HOWTO.
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						Petr Vandrovec <email>vandrove@vc.cvut.cz</email>
					</para>
				</listitem>
				<listitem>

					<para>
						Andreas Ehliar <email>ehliar@lysator.liu.se</email> (x2x)
					</para>
				</listitem>
				<listitem>

					<para>
						Marco Bizzarri <email>m.bizzarri@icube.it</email> (multiples servidores X)
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>Responsabilidad</title>

		<para>
		No será aceptada ninguna responsabilid derivada del contenido del
		documento. Use los conceptos, ejemplos y otro contenido bajo su
		resposabilidad. Como esta es una nueva edición de este documento, puede
		haber errores y inexactitudes que podrian ser dañinas para su sistema.
		Actue con prudencia, y aunque esto es muy improbable, no me responsabilizo
		de eso.
		</para>

	</sect2>

	<sect2>
	<title>Información del Copyright</title>

		<para>
		Esta sección del documento es propiedad de (c)1999 Frederick Niles y
		distribuida bajo los términos siguientes:
		</para>
	
		<para>

			<itemizedlist>
				<listitem>
			
					<para>
						Linux HOWTO documents may be reproduced and distributed in whole or
						in part, in any medium physical or electronic, as long as this copyright
						notice is retained on all copies. Commercial redistribution is allowed and
						encouraged; however, the author would like to be notified of any such
						distributions.
					</para>
				</listitem>
				<listitem>

					<para>
						All translations, derivative works, or aggregate works incorporating
						any Linux HOWTO documents must be covered under this copyright notice.  
						That is, you may not produce a derivative work from a HOWTO and impose
						additional restrictions on its distribution. Exceptions to these rules may
						be granted under certain conditions; please contact the Linux HOWTO
						coordinator at the address given below.
					</para>
				</listitem>
				<listitem>

					<para>
						If you have questions, please contact, the Linux HOWTO coordinator,
						at linux-howto@sunsite.unc.edu
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>¿Qué hardware es soportado?</title>

		<para>
		Se asume para mayoría de las tarjetas graficas que son las únicas del
		sistema y estan permanentemente establecidas en la direccion del adaptador
		de pantalla primario.  Hay unas pocas excepciones.
		</para>

		<para>

			<itemizedlist>
				<listitem>
	
					<para>
						Las tarjetas de Matrox: Esto incluye las tarjetas Matrox Millennium,
						Matrox Millennium II, Matrox Mystique, Matrox Mystique 220, Matrox
						Productiva G100, Matrox Mystique G200, Matrox Millennium G200 y Matrox		
						Marvel G200.
					</para>
				</listitem>
				<listitem>
	
					<para>
						MDA: Esto incluye al adaptador grafico Hércules monocromo entre
						otros. Esto es solo para el texto de soporte de un segundo monitor.
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>Soporte comercial.</title>

		<para>
		Este mini-HOWTO en principalmente involucrado con el software libre. Sin
		embargo, hay servidores de X comerciales con soporte multidirigido. Éstos
		incluyen Metro Link's (www.metrolink.com) Metro-X y Xi Graphics'
		(<ulink url="http://www.xig.com">http://www.xig.com</ulink>)
		Accelerated-X.
		</para>

	</sect2>
	
	<sect2>
	<title>Consiguiendo todo lo necesario</title>

		<para>
		Usted necesitará los parches siguientes y programas:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						El programa «fbset» Pruebe: <ulink
						url="http://www.cs.kuleuven.ac.be/~geert/bin/">
						http://www.cs.kuleuven.ac.be/~geert/bin/</ulink>
						 (nota:  este programa viene con RedHat 6.0)
					</para>
				</listitem>
				<listitem>

					<para>
						«fbaddon» los parches multidirigidos para Matrox para el nucleo de
						Linux pruebe: <ulink url="ftp://platan.vc.cvut.cz/pub/linux/matrox-lastest/">
						ftp://platan.vc.cvut.cz/pub/linux/matrox-lastest/</ulink>
					</para>
				</listitem>
				<listitem>

					<para>
						El programa «con2fb». Pruebe: <ulink url="ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/">
						ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/</ulink>
					</para>
				</listitem>
				<listitem>

					<para>
						El servidor de framebuffer para X11 XF86_FBDev. Es una parte
						estandard de XFree86 3.3.1.
					</para>
				</listitem>

			</itemizedlist>

		</para>

	</sect2>

	<sect2>
	<title>Empezando</title>

		<para>
		Lo primero que usted necesitará hacer es parchear una copia del codigo
		fuente de Linux con el parche <prompt>fbaddon</prompt>. Entonces usted necesitará
		configurar el nucleo y activar el soporte de Framebuffer. Si usted tiene
		tarjetas de Matrox active el soporte para el driver acelerador unificado
		para Matrox así como el tipo particular de tarjeta que usted tenga.  No
		active el «VESA framebuffer support». Puede causar conflicto.  Active el
		soporte para multi-dirigido (obviamente).  Compile el Nucleo y reinicie.
		Ahora usted necesitará instalar el programa «fbset» y leer cuidadosamente
		toda la documentación sobre cómo configurar las opciones.  El uso del
		archivo <prompt>/etc/fb.modes</prompt> es muy recomendable una vez que haya
		decidido su configuración.  El programa fbset incluye un script en Perl
		para convertir su archivo XF86Config a la configuración de fb.modes.  He
		incluido mi <emphasis>octave/Borne shell script</emphasis> para convertir su archivo
		XF86Config file en el Appendice A &#38; B.  Debe acostubrarse al uso del
		dispositivo framebuffer en un monitor supervisando y entiendiendo
		cualquier problema que puede ocurrir en su su configuración antes de
		intentar el soporte multi-dirigido. Esto puede ahorrarle muchos dolores de
		cabeza después.
		</para>

		<para>
		Yo voy a concentrar mi explicación en conseguir que X corra en un segundo
		monitor, y como hacerlo para la mayoría de las otras configuraciones
		apenas será un subconjunto obvio del procedimiento.
		</para>

			<sect3>
			<title>Mover una consola al...</title>

			<para>
			Compile el programa <prompt>con2fb</prompt>. 
			Si usted lo ejecuta sin ningun argumento aparecerá el mensaje 
			de uso siguiente:
			</para>

			<para>
			<prompt>usage: con2fb fbdev console</prompt>.
			</para>

			<para>
			Así, un comando de ejemplo sería <prompt>con2fb /dev/fb1 /dev/tty6</prompt> para
			mover la consola virtual número seis al segundo monitor.  Use
			<prompt>Ctrl+Alt+F6</prompt> para irse a esa consola y ver que muestra de hecho en el
			segundo monitor.
			</para>

		</sect3>

		<sect3>
		<title>Uso de <prompt>fbset</prompt> para ajustar la configuración en este segundo
		monitor</title>

			<para>
			Sólo establecca la configuración de <prompt>fbset</prompt> en el monitor donde ejecute
			el comando <prompt>fbset</prompt>.  Por consiguiente, usted debe ser cuidadoso en el
			uso de la opcion <prompt>-fb</prompt> sobre el segundo monitor.  En particular, si no
			hace nada más probablemente quiera poner la resolución vertical virtual
			por lo menos a su resolución vertical real.
			</para>

			<para>
			p.e. <prompt>fbset -fb /dev/fb1 -vyres 600</prompt>
			</para>

			<para>
			Esto será ciertamente lento bajo modo texto, pero X serian tediosas sin
			él.
			</para>

		</sect3>

		<sect3>
		<title>Configurando X para el soporte de Framebuffer</title>

			<para>
			El archivo <prompt>framebuffer.txt</prompt> explica esto mejor que yo, pero aquí estan
			los dos puntos importantes.
			</para>

			<para>
			Asegúrese que usted ha establecido el link para X apuntando a
			<prompt>XF86&lowbar;FBDev</prompt>.
			</para>

			<para>
			Lo siguiente que usted necesita es agregar una <emphasis>monitor section</emphasis> a su
			archivo XF86Config para el dispositivo Framebuffer.  Aquí hay un ejemplo:
			</para>

			<para>

				<screen>
					# El servidor de framebuffer

						Section "Screen"
					    Driver      "fbdev"
					    Device      "Millennium"
					    Monitor     "NEC MultiSync 5FGp"
					    Subsection "Display"
				        Depth       8
				        Modes       "default"
				        ViewPort    0 0
				    EndSubsection
				    Subsection "Display"
					        Depth       16
					        Modes       "default"
					        ViewPort    0 0
				    EndSubsection
				    Subsection "Display"
					        Depth       24
					        Modes       "default"
					        ViewPort    0 0
				    EndSubsection
				    Subsection "Display"
					        Depth       32
					        Modes       "default"
					        ViewPort    0 0
						    EndSubsection
					EndSection
				</screen>

			</para>

			<para>
			Use el modo <emphasis>default</emphasis> ya que no se me ocurre ninguna otra forma de
			funcionamiento del Framebuffer de Matrox.
			</para>

		</sect3>

		<sect3>
		<title>Pruebe a arrancar el servidor de X en el segundo monitor</title>
	
			<para>
			Establezca la variable FRAMEBUFFER al segundo frame buffer.
			</para>

			<para>
			<prompt>export FRAMEBUFFER=/dev/fb1</prompt>
			</para>

			<para>
			o
			</para>

			<para>
			<prompt>setenv FRAMEBUFFER /dev/fb1</prompt>
			</para>

			<para>
			Usted necesita iniciar el servidor X de modo que coincida la profundidad
			de color seleccionada y aparezca en el mismo monitor desde donde ha
			iniciado el servidor X.
			</para>

			<para>
			p.e. <prompt>startx -- :0 -bpp 16 vt06</prompt>
			</para>
	
			<para>
			Este ejemplo iniciara el servidor de X nº 0 en al consola virtual 6 con 16
			bits de color. Usando <prompt>:1</prompt> al lanzar otro servidor de X para el otro
			framebuffer le permitirá tener dos servidores X en funcionamiento.
			</para>
	
		</sect3>

	</sect2>

	<sect2>
	<title>Resumen</title>
	
		<para>
		Los pasos necesarios para obtener un servidor X que corre en un segundo
		monitor puede resumirse en:
		</para>

		<para>
	
			<itemizedlist>
				<listitem>
	
					<para>
						Consiga el parche del Nucleo, <prompt>fbset</prompt>, y <prompt>con2fb</prompt>.
					</para>
				</listitem>
				<listitem>

					<para>
						parchee el nucleo, configurarlo, recompilarlo, y reiniciar.
					</para>
				</listitem>
				<listitem>

					<para>
						Agregue la seccion <prompt>XF86_FBDev</prompt> al archivo <prompt>XF86Config</prompt>
						archivo y establezca el link a X.
					</para>
				</listitem>

			</itemizedlist>

		</para>

		<para>
		Entonces cada vez que usted reinicie:
		</para>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						Active una consola, ej. <prompt>con2fb /dev/fb1 /dev/tty6</prompt>
					</para>
				</listitem>
				<listitem>

					<para>
						Ajuste la configuración, ej. <prompt>fbset -fb /dev/fb1 1280x1024</prompt>
					</para>
				</listitem>
				<listitem>

					<para>
						Establezca el Framebuffer, ej. <prompt>export FRAMEBUFFER=/dev/fb1</prompt>
					</para>
				</listitem>
				<listitem>

					<para>
						Inicie el servidor X, ej. <prompt>startx -- -bpp 16 vt06</prompt>
					</para>
				</listitem>

			</itemizedlist>

		</para>

		<para>
		Usted puede automatizar esto para cada vez que reinicie via shell alias.
		Debe ser un alias y no un shell script ya que necesita detectar el numero
		de consola actual.  Éste es mi alias en C-shell para iniciar X en un
		segundo monitor de frecuencia fijo:
		</para>

		<para>
	
			<screen>
				alias startxfb = "
				setenv FRAMEBUFFER /dev/fb\!*;    # Set the env var to the cmd arg.
				con2fb $FRAMEBUFFER /dev/$tty;    # Move the fb to the current tty.
				fbset -fb $FRAMEBUFFER 1280x1024@62;  # Favorite from /etc/fb.modes
				startx -- :\!* -bpp 16 vt0`echo $tty | cut -dy f 2`' # X on this tty.
				"
			</screen>

		</para>

		<para>
		En mi archivo .cshrc esta todo en la misma linea y sin comentarios, pero
		es más fácil de leer aquí con los saltos de línea y insertando
		comentarios. Solamente doy el número de framebuffer como argumento y se
		inicia perfectamente.
		</para>

		<para>
		No estoy seguro de como se hace este mismo alias en la bash. No sé cómo
		determinar el tty actual o obtener los argumentos en un alias de bash. Si
		alguien me indica como se hace lo insertaré aquí.  Sin embargo, usted
		puede usar el comando <prompt>tty</prompt> para obtener en nombre del VT actual y y
		entonces hacer dos alias distintos para cada servidor X.
		</para>

	</sect2>

	<sect2>
	<title>Otras Notas y Problemas</title>

		<para>

			<itemizedlist>
				<listitem>

					<para>
						Tanto <prompt>fbset</prompt> como <prompt>startx</prompt> deben ser ejecutados desde el
						mismo framebuffer <emphasis>as the one being affected</emphasis>. Esto conlleva serios
						límites sobre cuantos de estos comandos pueden automatizarse vía scripts.
					</para>
				</listitem>
				<listitem>

					<para>
						Tanto <prompt>fbset</prompt> como <prompt>startx</prompt> deben ser ejecutados desde el
						mismo framebuffer <emphasis>as the one being affected</emphasis>. Esto conlleva serios
						límites sobre cuantos de estos comandos pueden automatizarse vía scripts.
					</para>
				</listitem>
				<listitem>

					<para>
						XFree86 4.0 tendrá su propio soporte multi-dirigido, pero 3.3.1 no
						lo tiene. Sin embargo Ud puede ejecutar dos servidores con 3.3.1 y puede
						usar x2x para moverse entre ellos... (vea la próxima seccion)
					</para>
				</listitem>
				<listitem>

					<para>
						El framebuffer inactivo solo mantendra la última imagen que tenia
						cuando estaba activo, ninguna actualización ocurrirá.
					</para>
				</listitem>
				<listitem>

					<para>
						El monitor que no este seleccionado no siempre mantiene su estado
						cuando no está activo. (Pero normalmente lo hace.)
					</para>
				</listitem>
				<listitem>

					<para>
						Geert Uytterhoeven (el responsable de Framebuffer) y Linus Torvalds
						no estan de acuerdo con la actual consola multi-dirigida con <emphasis>un
						framebuffer por VT</emphasis> acepten cambios (por ejemplo fbaddon) asi que podria
						haber novedades en la corriente de desarrollo del Nucleo.  (Esto lo he
						oido de terceras personas y puede ser completamente falso.)
					</para>
				</listitem>
				<listitem>

					<para>
						Si usted <emphasis>rompe las reglas</emphasis> y inicia el servidor X (ejecutando
						<prompt>startx</prompt>) en un monitor distinto, la máquina puede colgarse
						completamente con todas las entradas del ratón y el teclado mezcladas.
					</para>
				</listitem>
				<listitem>
	
					<para>
						La documentación <prompt>framebuffer.txt</prompt> de las fuentes del nucleo
						explica que usted puede usar las opcion Modeline directamente en su
						archivo XF86Config cuando ejecute X. Usar el framebuffer para Matrox
						significa forzar al servidor X a ignorar todo esto.  Asi que solo puede
						tener una unica configuración (por defecto) establecida a la vez (la misma
						que tenía en modo texto).
					</para>
				</listitem>
				<listitem>
	
					<para>
						Los XF86_FBDev no son aceleradores. Sim embargo, hay parches para
						que los aceleradores Matrox lo soporten en: <ulink
						url="http://www.in-berlin.de/User/kraxel/xfree86/">
						http://www.in-berlin.de/User/kraxel/xfree86/</ulink>
					</para>
				</listitem>
	
			</itemizedlist>

		</para>

			<sect3>
			<title>Consiguiendo que funcione <emphasis>el arranque en nivel cinco</emphasis>
			(es decir el <prompt>xdm/gdm</prompt>)</title>

					<para>
					No se me ha ocurrido ninguna manera de arrancar con init level 5 con una
					configuración de monitor dual (y realmente tengo el servidor para o tener
					segundo monitor o arracar).  Aunque parece bastante fácil agregar una
					línea a el fichero <prompt>gdm/xdm</prompt> de Xservers, la limitación de que
					usted deba accancar el servidor X en el mismo framebuffer impide la
					solución obvia para que funcione. Si alguien encuentra una manera, por
					favor, indiquemela por e-mail y la añadiré aquí.
					</para>

			</sect3>

			<sect3>
			<title>Usando el programa x2x</title>

				<para>
				Hay un magnifico pequeño programa llamado x2x que le cambiará los
				servidores de X <emphasis>you get to the edge of the screen</emphasis> La ultima direccin
				conocida para este programa era: <ulink url="http://ftp.digital.com/pub/DEC/SRC/x2x/">
				http://ftp.digital.com/pub/DEC/SRC/x2x/</ulink>. También es un
				paquete de Debian opcional. Yo no lo he probado todavía pero algunos
				usuarios me han informado que funciona.
				</para>

			</sect3>

			<sect3>
			<title>Otras órdenes útiles</title>

				<para>
				Existen muchos comandos en Linux que no son muy recordados cuando se
				trabaja con una configuración multidirigida. (especialmente escribiendo
				scripts).
				</para>

				<para>

					<itemizedlist>
						<listitem>

							<para>
								<prompt>chvt</prompt> le permitirán cambiar entre los términos virtuales.
							</para>
						</listitem>
						<listitem>

							<para>
								<prompt>openvt</prompt> Inicia un programa en un nuevo término virtual (VT).
							</para>
						</listitem>
						<listitem>

							<para>
								<prompt>tty</prompt> Le indica el nombre del término actual.
							</para>
						</listitem>

					</itemizedlist>

				</para>

			</sect3>

			<sect3>
			<title>Apéndice A. <emphasis>Octave cvtmode.m script</emphasis></title>

				<para>
				(Fijese en el establecimiento de <prompt>bpp</prompt>)
				</para>

				<para>

					<screen>
						#!/usr/bin/octave -q
						bpp = 16;
						DCF = sscanf(argv(1,:), "%f");
						HR  = sscanf(argv(2,:), "%f");
						SH1 = sscanf(argv(3,:), "%f");
						SH2 = sscanf(argv(4,:), "%f");
						HFL = sscanf(argv(5,:), "%f");
						VR  = sscanf(argv(6,:), "%f");
						SV1 = sscanf(argv(7,:), "%f");
						SV2 = sscanf(argv(8,:), "%f"); 
						VFL = sscanf(argv(9,:), "%f");
						pixclock = 1000000 / DCF;
						left_margin = HFL - SH2;
						right_margin = SH1 - HR;
						hsync_len = SH2 - SH1;

						# 3) vertical timings:
						upper_margin = VFL - SV2;
						lower_margin = SV1 - VR;
						vsync_len = SV2 - SV1;
	
						RR = DCF / (HFL * VFL) *1e6;
						HSF = DCF / HFL * 1e3;

						printf("mode \"%dx%d\"\n",HR,VR);
						printf("   # D: %3.2f MHz, H: %3.2f kHz, V: %2.2f Hz\n", DCF, HSF, RR);
						printf("   geometry %d %d %d %d %d\n", HR, VR, HR, VR, bpp);
						printf("   timings %d %d %d %d %d %d %d\n", ...
                              pixclock, left_margin, right_margin, ....
                              upper_margin, lower_margin, ...
                              hsync_len, vsync_len);
						printf("endmode\n");
					</screen>

				</para>

			</sect3>

			<sect3>
			<title>Apéndice B. Script para el Borne Shell <prompt>cvtfile</prompt></title>

				<para>
				(Este llama al script octavo <prompt>cvtmode</prompt>)			
				</para>

				<para>

					<screen>
						#!/bin/sh

						# Shell script to convert XF86Config file to fb.modes file.
						# Uses octave script cvtmode.m

						if [ -z $1 ]; then
						  FILE=/etc/X11/XF86Config
						else
						  FILE=$1
						fi

						i=1
						LEN=`grep Modeline $FILE | wc -l`
						while expr $i \&#60; $LEN &#62; /dev/null ;
						do
						  CURLINE=`grep Modeline $FILE | cut -d'"' -f 3-20 | head -$i | tail -1 `
						  ./cvtmode.m $CURLINE
						  echo " "
						  i=`expr $i + 1`
						done
					</screen>
	
				</para>

			</sect3>

		</sect2>

</sect1>

<sect1>
<title>Usando/Cambiando fuentes</title>

	<para>
	Para conseguir la capacidad para cambiar fuentes, usted necesita kbd-0.99.
	Usted puede obtenerlo de <ulink url="ftp://ftp.win.tue.nl/pub/linux/utils/kbd">
	ftp://ftp.win.tue.nl/pub/linux/utils/kbd</ulink>.
	</para>

	<para>
	Una ventaja de bajarse e instalar kbd-0.99 es que usted podrá cargar
	fuentes internacionales (p.e el símbolo de Euro) en su dispositivo de
	consola (¡Es tres veces chic tener tres símbolos en mi teclado, el simbolo
	dólar, el de la libra inglesa y el del Euro!).
	</para>

</sect1>

<sect1>
<title>Cambiando los modos de consola</title>

	<para>
	Para conseguir la capacidad para cambiar modos (i.e 640x480, 800x800 etc),
	usted necesita fbset (actualmente <prompt>fbset-19990118.tar.gz</prompt>) - usted
	puede bajarselo por ftp de:
	</para>

	<para>
    <ulink url="http://www.cs.kuleuven.ac.be/~geert/bin/fbset-19990118.tar.gz">
	http://www.cs.kuleuven.ac.be/~geert/bin/fbset-19990118.tar.gz</ulink>
	</para>

	<para>
	Viene con un completo juego de instrucciones sobre cómo funciona.
	</para>

</sect1>

<sect1>
<title>Configurando el driver de X11 <prompt>FBdev</prompt></title>

	<para>
	Si usted no usa XFree86 3.3.3.1 o posterior, debe actualizarse a XFree86
	3.3.3.1 - incluye un driver X <prompt>FBdev</prompt> para dispositivos framebuffer. De
	todas formas, o siga los pasos debajo indicados para bajarse o compilar su
	propio driver <prompt>FBdev</prompt> para las versiones mas antiguas de XFree86 como
	3.3.2, 3.3.3 etc.
	</para>

	<para>
	Vaya a <ulink url="http://www.xfree86.org">http://www.xfree86.org</ulink>, 
	y bajese el archivo de las fuentes de los últimos XServers, desempaquetelo, 
	y configure los drivers y siga estos pasos:
	</para>

	<para>

		<itemizedlist>
			<listitem>

				<para>
					Edite <prompt>xc/config/cf/xf86site.def</prompt>, Quite el comentario del
					&num;define para <prompt>XF68FBDevServer</prompt>
				</para>
			</listitem>
			<listitem>

				<para>
					Comente em/todas/ las referencias a
					<prompt>FB_VISUAL_STATIC_DIRECTCOLOR</prompt>, éstas no se usaran. Si usted está
					usando XFree86 3.3.3.1, no hay ninguna necesidad de hacer este paso -
					Ellos ya han quitado esto.
				</para>
			</listitem>
			<listitem>

				<para>
				Edite
				<prompt>xc/programs/Xserver/hw/xfree86/os-support/linux/lnx_io.c</prompt>, y
				canbie <prompt>K_RAW</prompt> a <prompt>K_MEDIUMRAW</prompt>.
				</para>
			</listitem>

		</itemizedlist>

	</para>

	<para>
	y entonces compile el driver. No se preocupe por las referencias a m68k,
	son soportadas por las plataformas Intel. Entonces compilelo todo Tardará
	bastante tiempo ya que es un codigo fuente muy grande.
	</para>

	<para>
	Alternativamente, si usted no tiene el tiempo que perder, usted puede
	obtener los binarios de los sitios siguientes. Por favor tenga en cuenta
	que soy sitios no oficiales y Ud. los usara bajo su responsabilidad.
	</para>

	<para>
	Para libc5, use:
	</para>

	<para>
	<ulink url="http://user.cs.tu-berlin.de/~kraxel/linux/XF68_FBDev.gz">
	http://user.cs.tu-berlin.de/~kraxel/linux/XF68_FBDev.gz</ulink>
	</para>

	<para>
	Para glibc2, bajelos de las siguientes URLs.
	</para>

	<para>
	<ulink url="http://user.cs.tu-berlin.de/~kraxel/linux/XF68_FBDev.libc6.gz">
	http://user.cs.tu-berlin.de/~kraxel/linux/XF68_FBDev.libc6.gz</ulink>
	</para>

	<para>
	<ulink url="http://pobox.com/~brion/linux/fbxserver.html">
	http://pobox.com/~brion/linux/fbxserver.html</ulink>
	</para>

	<para>
	Hay noticias de que X11 no funcionan en cierto tarjetas graficas con la
	opcion vesafb habilitada, si esto le pasa, pruebe el nuevo driver
	<prompt>XF86_FBdev</prompt> para X11.
	</para>

	<para>
	Este driver, junto con el vesafb puede también ayudar a ejecutar X11 a
	resoluciones más altas con ciertos chipsets gráficos no soportados por
	ninguno de los drivers actuales de X11. Por ejemplo, el MGA G-200
	</para>

	<para>
	Para configurar el driver <prompt>XF86_FBdev</prompt> con su sistema X11, usted
	necesitará editar su <prompt>XF86Config</prompt> con lo siguiente:
	</para>

	<para>

		<screen>
			Section "Screen"
				Driver		"FBDev"
				Device		"Primary Card"
				Monitor		"Primary Monitor"
					SubSection	"Display"
						Modes		"default"
					EndSubSection
			EndSection
		</screen>

	</para>

	<para>
	Usted también necesitará poner XkbDisable en la sección del teclado, o
	invoque el servidor <prompt>XF86_FBDev</prompt> con la opción <prompt>-kb</prompt> para configurar
	su teclado de modo que funcione perfectamente. Si usted se olvida de poner
	XkbDisable, usted, tendrá que poner las líneas siguientes lineas en su
	<prompt>.Xmodmap</prompt> para corregir los mapas del teclado. Alternativamente, usted
	puede editar su <prompt>xkb</prompt> para que refleje la siguiente lista.
	</para>

	<para>
	<emphasis>Esto es fijo en XFree86 3.3.3.1, y es una idea buena para actualizarse
	a esta versión de todas formas porque hay unos pocos bugs arreglados, y
	también,se incluye FBDev como uno del drivers, como he mencionado
	previamente.</emphasis>
	</para>

	<para>

		<screen>
			! Keycode settings required
			keycode 104 = KP_Enter
			keycode 105 = Control_R
			keycode 106 = KP_Divide
			keycode 108 = Alt_R Meta_R
			keycode 110 = Home
			keycode 111 = Up
			keycode 112 = Prior
			keycode 113 = Left
			keycode 114 = Right
			keycode 115 = End
			keycode 116 = Down
			keycode 117 = Next
			keycode 118 = Insert
			keycode 119 = Delete
		</screen>

	</para>

	<para>
	Puede necesitar hacer algún pequeño cambio en esto (intente copiar la
	definición original del driver original de X11 que usted estaba usando y
	carbiar el nombre del driver a <prompt>FBDev</prompt>), pero básicamente esto es lo
	que usted necesita hacer para usar el driver vesafb de X11 .
	</para>

	<para>
	Espero que se arreglen los problemas de X11 con el soporte de tarjetas
	gráficas que será corregido en futuras revisiones.
	</para>

</sect1>

<sect1>
<title>¿Cómo convierto los mode-lines de XFree86 en un dispositivo de
framebuffer temporizado?</title>

	<para>
	Si usted tiene XFree86 (X11) instalado en su máquina, y usted puede usarlo
	con éxito, hay una manera simple de convertir los mode-lines en su
	<prompt>XF86Config</prompt> a la temporización requerida necesaria para los
	dispositivos framebuffer.
	</para>

	<para>
	El dispositivo del framebuffer requiere los campos siguientes:
	</para>

	<para>

		<itemizedlist>
			<listitem>

				<para>
					<prompt>pixclock</prompt> - tiempo del pixel en pico segundos
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>left_margin</prompt> - tiempo desde el <prompt>sync</prompt> hasta la figura
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>right_margin</prompt> - tiempo desde la figura hasta el <prompt>sync</prompt>
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>upper_margin</prompt> - tiempo desde el <prompt>sync</prompt> hasta la figura
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>lower_margin</prompt> - tiempo desde la figura hasta el <prompt>sync</prompt>
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>hsync_len</prompt> - longitud de <prompt>sync</prompt> horizontal
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>vsync_len</prompt> - longitud de <prompt>sync</prompt> vertical
				</para>
			</listitem>

		</itemizedlist>

	</para>

	<para>
	Un mode-line Xfree86 tiene los siguientes campos:
	</para>

	<para>
	
		<screen>
			Modeline "1280x1024" DCF HR SH1 SH2 HFL VR SV1 SV2 VFL
		</screen>

	</para>

	<para>
	Es necesario hacer algunos cálculos simples para traducir los XF86
	modo-line en un conjunto de temporizadores de dispositivo framebuffer. A
	modo de ejemplo, examinaremos cómo convertir un mode-line tomado de mi
	archivo <prompt>XF86Config</prompt>.
	</para>

	<para>

		<screen>
			Modeline "1280x1024" 110.00 1280 1328 1512 1712 1024 1025 1028 1054
		</screen>

	</para>

	<para>
	Primero, calcule la tasa del pixclock requerida. XFree86 usa megahertzios
	mientras que los dispositivos del framebuffer usan picosegundos (¿Por
	qué?, no lo sé). Divida un millón por DCF.  Por ejemplo, 1,000,000 / 110.0
	= 9090.9091
	</para>

	<para>
	Ahora necesitamos calcular el temporizador horizontal.
	</para>

	<para>

		<itemizedlist>
			<listitem>

				<para>
					<prompt>left_margin = HFL - SH2</prompt>
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>right_margin = SH1 - HR</prompt>
				</para>
			</listitem>
			<listitem>
	
				<para>
					<prompt>hsync_len = SH2 - SH1</prompt>
				</para>
			</listitem>

		</itemizedlist>

	</para>

	<para>
	En nuestro ejemplo, este podria ser:
	</para>

	<para>

		<itemizedlist>
			<listitem>

				<para>
					<prompt>left_margin = 1712 - 1512 = 200</prompt>
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>right_margin = 1328 - 1280 = 48</prompt>
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>hsync_len = 1512 - 1328 = 184</prompt>
				</para>
			</listitem>

		</itemizedlist>

	</para>

	<para>
	Y ahora necesitamos calcular el temporizador vertical.
	</para>

	<para>

		<itemizedlist>
			<listitem>
	
				<para>
					<prompt>upper&lowbar;margin = VFL - SV2</prompt>
				</para>
			</listitem>
			<listitem>
	
				<para>
					<prompt>lower&lowbar;margin = SV1 - VR</prompt>
				</para>
			</listitem>
			<listitem>
	
				<para>
					<prompt>vsync&lowbar;len = SV2 - SV1</prompt>
				</para>
			</listitem>

		</itemizedlist>
	
	</para>

	<para>
	Para nuestro ejemplo, este podria ser:
	</para>

	<para>

		<itemizedlist>
			<listitem>
	
				<para>
					<prompt>upper&lowbar;margin = 1054 - 1028 = 26</prompt>
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>lower&lowbar;margin = 1025 - 1024 = 1</prompt>
				</para>
			</listitem>
			<listitem>

				<para>
					<prompt>vsync&lowbar;len = 1028 - 1025 = 3</prompt>
				</para>
			</listitem>

		</itemizedlist>

	</para>

	<para>
	Ahora podemos usar esta información para configurar el framebuffer para el
	modo deseado. Por ejemplo, para el framebuffer del <prompt>matroxfb</prompt>, se
	requiere:
	</para>

	<para>

		<screen>
			video=matrox:xres:&#60;&#62;,yres:&#60;&#62;,depth:&#60;&#62;,left:&#60;&#62;,right:&#60;&#62;,
			hslen:&#60;&#62;,upper:&#60;&#62;,lower:&#60;&#62;,vslen:&#60;&#62;
		</screen>

	</para>

	<para>
	Yo puse en mi <prompt>/etc/lilo.conf</prompt>
	la línea siguiente:
	</para>

	<para>

		<screen>
			append = "video=matrox:xres:1280,yres:1024,depth:32,left:200,
			right:48,hslen:184,upper:26,lower:0,vslen:3"
		</screen>

	</para>

	<para>
	Dese cuenta que en este caso el pixclock no se usa. Es sólo necesario si
	no le gustan las tasas de pixclock predefinidas. Usted puede
	proporcionarlas como parámetro también. La configuración del pixclock se
	documenta en otras partes de este HOWTO.
	</para>

</sect1>

<sect1>
<title>¿Buscando mas información?</title>

	<para>
	Para aquéllos de ustedes interesados en trabajar con los drivers del
	framebuffer, apunte su browser a <ulink url="http://www.csoft.net/~systems/jim/fb.html">
	http://www.csoft.net/~systems/jim/fb.html</ulink> para información
	sobre programacion.
	</para>

	<para>
	Francohablantes, hay una traduccion en 
	<ulink url="http://www.freenix.org/unix/linux/HOWTO/mini/Vesafb.html">
	http://www.freenix.org/unix/linux/HOWTO/mini/Vesafb.html</ulink>
	</para>

</sect1>

<sect1>
<title>Traducción</title>

	<para>
	Este documento ha sido traducido por el grupo <emphasis>Linux-Kfe</emphasis>. Puede
	visitar nuestra página en la siguiente dirección: <ulink url="http://members.es.tripod.de/linuxkfe">
	http://members.es.tripod.de/linuxkfe</ulink>
	(también puede utilizar los enlaces: <ulink url="http://go.to/linuxkfe">
	http://go.to/linuxkfe</ulink> y 
	<ulink url="http://members.xoom.com/linuxkfe">http://members.xoom.com/linuxkfe</ulink>).
	</para>

	<para>
	Actualmente gestionamos este grupo las siguientes personas:
	</para>

	<para>
		<variablelist>

			<varlistentry>
				<term>Director del Proyecto:</term>
				<listitem>
					<para>
						Jesús Martínez Mateo <email>jmartinez@sportec.es</email>,
						<email>kfetro@cajamurcia.es</email>
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<variablelist>

			<varlistentry>
				<term>Coordinadores:</term>
					<listitem>
						<para>
							Juan José Roldán Guerrero <email>jroldan@sportec.es</email>
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term></term>
					<listitem>
						<para>
							Pedro Ruiz Maldonado <email>bigplac@newmail.net</email>
						</para>
					</listitem>
			</varlistentry>
		</variablelist>
	</para>

	<para>
	Si desea colaborar con nosotros en futuras traducciones y distintos
	proyectos relacionados con el mundo de Linux (o si simplemente desea
	realizar alguna aportación, crítica o sugerencia), envíe un e-mail a la
	siguiente dirección: <email>linuxkfe@lycosmail.com</email>.
	Procuraremos atenderle lo antes posible, de todas formas, si lo cree conveniente puede 
	dirigirse de forma directa a cualquiera de los coordinadores nombrados anteriormente.
	</para>

	<para>
	Traducción: Jesús Martínez Mateo, Pedro Ruiz Maldonado.

	Revisión: 0.2

	Última modificación: 21 de Diciembre de 1999.
	</para>

</sect1>

</article>
