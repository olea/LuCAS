<!DOCTYPE Article PUBLIC "-//Davenport//DTD DocBook V3.0//EN">

<Article>

<ArtHeader>

<Title>Programación Orientada a Objetos: Conceptos</Title>
<AUTHOR
>
<FirstName>Paulino Huerta Sánchez 
 Colaborador: Pablo Arranz Alés, 
 </FirstName>

<AuthorBlurb>

<Para>
<ULink URL="mailto:parranza@nexo.es">parranza@nexo.es
</ULink>
</Para>

</AuthorBlurb>
</AUTHOR
>
<PubDate>Primera parte v2, 14 de Noviembre de 1998 </PubDate>

<Abstract>

<Para>
 Este documento es una guía de conceptos básicos sobre Programación Orientada a Objetos (<Emphasis remap="it">OOP; Object Oriented Programing</Emphasis>). Está destinado
a programadores que comiencen a iniciarse o usen algún Lenguaje Orientado
a Objetos (LOO), tales como C++ y Smalltalk, y desean conocer el Paradigma Orientado a Objetos.
</Para>

</Abstract>

</ArtHeader>

<Sect1>
<Title>Aviso</Title>

<Para>
La versión de este documento será, de momento, la definitiva.
</Para>

<Para>
Póngase en contacto con el colaborador si encuentra errores u omisiones
obvias. 
</Para>

</Sect1>

<Sect1>
<Title>Objetos</Title>

<Para>
Un <Emphasis remap="bf">objeto</Emphasis> es una <Emphasis remap="it">estructura de datos</Emphasis> con un
conjunto de comportamientos que es capaz de realizar. Llamamos
<Emphasis remap="bf">comportamiento</Emphasis>a aquello que puede ser ejecutado por el objeto
directamente. Por ejemplo podríamos decir que un rectángulo conoce al
mismo como visualizarse sobre la pantalla o conoce como obtener su propia
área. Un objeto consigue estos comportamientos por ser <Emphasis remap="it">instancia</Emphasis>
de una <Emphasis remap="it">clase</Emphasis>.
</Para>

</Sect1>

<Sect1>
<Title>Clases</Title>

<Para>
Las <Emphasis remap="bf">clases</Emphasis> definen métodos que se aplican a todos los objetos
que pertenecen a aquella <Emphasis remap="it">clase</Emphasis>, son llamados <Emphasis remap="bf">métodos de
instancia</Emphasis>.
</Para>

<Para>
La <Emphasis remap="it">clase</Emphasis> también puede incluir métodos independientes a
los de instancia, llamados <Emphasis remap="bf">métodos de clase ó métodos estáticos</Emphasis>.
Algunos métodos de clase crean nuevos objetos de la clase y son
llamados <Emphasis remap="bf">métodos constructores</Emphasis> (<Emphasis remap="it">tal como crear un nuevo
rectángulo de base 10 cms y altura 5 cms</Emphasis>), o provee otra
operación necesaria (<Emphasis remap="it">leer un rectángulo desde un fichero</Emphasis>).
</Para>

<Para>
Una clase puede ser definida <Emphasis remap="it">heredando</Emphasis> de otra clase, los
<Emphasis remap="it">métodos de instancia</Emphasis> son los de la <Emphasis remap="it">clase padre o clase
base</Emphasis>. Esto permite que una nueva clase sea creada a partir de una
clase similar existente pero agregando nuevos comportamientos.
Cualquier invocación a métodos que no son encontrados en una
clase particular serán buscados en la clase padre automáticamente. Por
ejemplo un rectángulo podría heredar algún comportamiento común de una
clase genérica polígonos.
</Para>

<Para>
Si bien podrías conocer la <Emphasis remap="it">implementación</Emphasis> particular de un
objeto, generalmente deberías tratar al objeto como una <Emphasis remap="it">'caja
negra'</Emphasis>. Todos los accesos al objeto deberían obtenerse a través
de una interfaz pública vía los métodos provistos. Esto permite
que las implementaciones pueden ser revisadas y modificadas.
Para la interfaz pública, debe existir documentación escrita
describiendo como usar una clase particular.
</Para>

<Para>
<Emphasis remap="it">Objetos</Emphasis> de diferentes <Emphasis remap="it">clases</Emphasis> pueden ser 
<Emphasis remap="it">'nombrados'</Emphasis> en la misma variable en diferente tiempo. Cuando un
método es invocado sobre el contenido de la variable, el propio método de
la clase del objeto consigue seleccionar automáticamente. Si, por
ejemplo, el <Emphasis remap="it">método dibuja()</Emphasis> es invocado sobre una
variable la que contiene o un rectángulo ó un círculo, el método usado
depende de la naturaleza actual del objeto al cual refiere la
variable. Por ello, los métodos para dibujar círculos y
rectángulos, ambos deben llamarse <Emphasis remap="it">dibuja()</Emphasis>.
</Para>

<Para>
Admitamos que hay más que decir acerca del tema, pero nuestra
propuesta llega hasta aquí. 
</Para>

</Sect1>

<Sect1>
<Title>Características de los LOO.</Title>

<Para>

<ItemizedList>
<ListItem>

<Para>
Soportan los <Emphasis remap="it">'tipos abstractos de datos'</Emphasis>.
</Para>
</ListItem>
<ListItem>

<Para>
Es mediante la noción de 'clase' como los LOO permiten
representar TAD.
</Para>
</ListItem>
<ListItem>

<Para>
Las operaciones que caracterizan a un TAD son llamadas métodos
o funciones.
</Para>
</ListItem>
<ListItem>

<Para>
Un método es una operación que tiene un primer argumento un
objeto receptor abstracto, con notación  A1.M(A2,...): el
mensaje que invoca el método va dirigido al objeto A1 con
parámetros eventuales A2,... El concepto de <Emphasis remap="it">'operación'</Emphasis> es
común sea para la aproximación funcional como para la
aproximación a objetos. La <Emphasis remap="it">aproximación funcional</Emphasis> no distingue
los argumentos, y la <Emphasis remap="it">aproximación orientada a objetos</Emphasis> si
distingue el <Emphasis remap="it">objeto receptor del mensaje</Emphasis> que invoca el método.
</Para>
</ListItem>
<ListItem>

<Para>
Los lenguajes orientados a objetos <Emphasis remap="it">'puros'</Emphasis> solo gestionan
objetos, tales como <Emphasis remap="bf">Smalltalk</Emphasis> o <Emphasis remap="bf">Spoke</Emphasis>. Es decir son
<Emphasis remap="it">'totalmente'</Emphasis> orientados a objetos.
</Para>
</ListItem>
<ListItem>

<Para>
Un objeto tiene una propiedad que permite distinguirlo del
resto: su <Emphasis remap="it">identificador</Emphasis>.

Esta es una característica distintiva de los LOO. Los <Emphasis remap="it">tipos</Emphasis> se
implementan bajo la forma de <Emphasis remap="it">clases</Emphasis>, cuyos <Emphasis remap="it">elementos son
objetos con identificadores</Emphasis>. El <Emphasis remap="it">identificador de un objeto</Emphasis>,
a nivel interno es un <Emphasis remap="it">puntero en memoria</Emphasis>.
</Para>
</ListItem>
<ListItem>

<Para>
La <Emphasis remap="it">activación de un método</Emphasis> se realiza por medio del
<Emphasis remap="it">envío de un mensaje a un objeto receptor</Emphasis>.
El <Emphasis remap="it">mensaje</Emphasis> comporta el <Emphasis remap="it">selector del método
(nombre)</Emphasis> y los parámetros que se pasan al método.
El <Emphasis remap="it">'enlace'</Emphasis> del código del método a ejecutar en el momento de
la recepción del mensaje por parte de un objeto, es <Emphasis remap="it">'dinámico'</Emphasis>
cuando la búsqueda del código se hace durante la ejecución.
El enlace es <Emphasis remap="it">'estático'</Emphasis> cuando se lleva a cabo durante la
compilación.
</Para>
</ListItem>
<ListItem>

<Para>
La <Emphasis remap="it">creación de objetos</Emphasis> requiere la asignación de una zona
de memoria y la inicialización del estado. Generalmente la creación de
objetos se realiza mediante la activación de un <Emphasis remap="it">'constructor'</Emphasis> de
objetos.

El <Emphasis remap="it">constructor</Emphasis> se puede considerar como una función particular
disponible a nivel de la clase. Su llamada no se considera un
envío de mensaje, ya que el objeto receptor no existe.
</Para>
</ListItem>
<ListItem>

<Para>
La <Emphasis remap="it">destrucción de los objetos</Emphasis> puede ser automática
(<Emphasis remap="it">Smalltalk,Clos, Spoke</Emphasis>) o manual (<Emphasis remap="it">C++</Emphasis>). La destrucción
automática necesita de un mecanismo de recogida de basura (<Emphasis remap="it">garbage
collection</Emphasis>), este debe  conocer mediante una técnica específica que
objeto no es referenciado, para eliminarlo. Mientras que la destrucción
manual se realiza mediante la invocación de un <Emphasis remap="it">'destructor'</Emphasis>.
</Para>
</ListItem>

</ItemizedList>
 
</Para>

<Para>
<Emphasis remap="bf">Anotaciones</Emphasis>:

<ItemizedList>
<ListItem>

<Para>
Las <Emphasis remap="it">clases</Emphasis> de los LOO constituyen un <Emphasis remap="it">tipo</Emphasis> más.
</Para>
</ListItem>
<ListItem>

<Para>
Se pueden ver como una extensión de los <Emphasis remap="it">struct</Emphasis> del C.
</Para>
</ListItem>
<ListItem>

<Para>
Obtenemos una parte autónoma del programa: <Emphasis remap="it">estructura de
datos</Emphasis> + <Emphasis remap="it">métodos</Emphasis> 
</Para>
</ListItem>
<ListItem>

<Para>
Constituirán un TDA.
</Para>
</ListItem>
<ListItem>

<Para>
Un TDA es una <Emphasis remap="it">'encapsulación'</Emphasis>.
</Para>
</ListItem>
<ListItem>

<Para>
El objeto es la unidad de encapsulación.
</Para>
</ListItem>

</ItemizedList>
 
La mayor parte de los LOO utilizan la creación dinámica de
objetos, aplicando el método <Emphasis remap="it">'new'</Emphasis> a la clase de ese objeto.
</Para>

<Para>
En Smalltalk:
|t1|
t1:= Trabajador new
(<Emphasis remap="it">En Smalltalk todos los objetos son creados dinámicamente</Emphasis>)
</Para>

<Para>
En C++ (<Emphasis remap="it">dinámicamente</Emphasis>)
trabajador *t1;
t1=new trabajador;  
</Para>

<Para>
Para destruir el objeto en C++:
delete t1; 
(<Emphasis remap="it">En C++ es el usuario quien debe preocuparse de la destrucción
de los objetos</Emphasis>)
</Para>

<Para>
En C una función es llamada:
z=max(x,y)
y=size(c) 
</Para>

<Para>
En Smalltalk: Se envía un mensaje a un objeto
 
z:= x max: y
y:= c size 
</Para>

</Sect1>

<Sect1>
<Title>Aclaraciones</Title>

<Para>
Una <Emphasis remap="it">clase</Emphasis> realiza varias funciones que a veces se confunden.
Intentemos aclararlo.
</Para>

<Para>
En primer lugar, es un <Emphasis remap="it">tipo abstracto de datos</Emphasis>. Además,
es un generador de instancias ya que una clase permite crear objetos los
que son sus instancias. También una clase permite representar referencias
a objetos de otras clases.
</Para>

<Para>
Existe una relación interclase. Las clases pueden organizarse de
acuerdo a la "relación de generalización" o relación es-un,
esta representación se puede representar mediante el <Emphasis remap="it">'grafo
deherencia</Emphasis>. La <Emphasis remap="bf">generalización</Emphasis> es útil para clasificar
objetos en función de las características o rasgos comunes y de aquellos
específicos.
</Para>

<Para>
La inversa de la <Emphasis remap="it">función generalización</Emphasis>, es llamada
<Emphasis remap="bf">"especialización"</Emphasis>, y esta permite agregar propiedades específicas
a una clase generando una subclase. 
</Para>

<Para>
<Emphasis remap="bf">Definimos:</Emphasis>
</Para>

<Para>
La <Emphasis remap="it">generalización</Emphasis> hace corresponder a una subclase o
clase origen, una clase más general o superclase.
</Para>

<Para>
La <Emphasis remap="it">especialización</Emphasis> hace corresponder a una clase todas
las subclases de las cuales es la superclase.
</Para>

<Para>
El <Emphasis remap="it">enlace de generalización</Emphasis> indica que las <Emphasis remap="it">instancias
de una subclase</Emphasis> son también <Emphasis remap="it">instancias de la superclase</Emphasis>, lo
que nos dice que objetos que pertenecen a la subclase poseen las 
propiedades de la subclase además de aquellas de la superclase.
</Para>

<Para>
Hay también una relación entre un objeto y su clase. Es la
función de instanciación y es la que ha permitido crearlo. Entonces
observamos una dicotomía entre objeto y clase. Esta dicotomía se pierde si
fuese posible generar clases como objetos, es decir que una clase fuese
instancia de otra.
</Para>

<Para>
Podemos considerar una clase <Emphasis remap="it">'metaclase'</Emphasis> generadora de
clases contendría métodos aplicables a las clases generadas (<Emphasis remap="it">comunes a
todas las clases</Emphasis>) y datos comunes, como el OID. Es decir, las
<Emphasis remap="it">'metaclases'</Emphasis> son clases cuyas instancias son también clases.  Así
podríamos utilizar una clase para guardar datos que sean compartidos por
todas sus instancias, -variables de clase, en Smalltalk-, coincidiendo
esta posibilidad con el concepto de 'información global', ya que es común
a todas las instancias de la clase y no pertenece a ninguna instancia en
particular. 
</Para>

<Para>
Y, en cuanto a los <Emphasis remap="it">métodos de clase</Emphasis>, se posibilita que
cada clase puede tener su propio método para crear instancias. Como
ejemplo <Emphasis remap="bf">(1)</Emphasis> podemos definir una <Emphasis remap="it">clase Alumno</Emphasis>, con una
<Emphasis remap="it">'variable de clase: Media'</Emphasis>, en la que se almacena la nota media
del curso al que pertenece. <Emphasis remap="bf">(2)</Emphasis> una <Emphasis remap="it">clase
EmpleadoEspecialista</Emphasis> con una variable de <Emphasis remap="it">clase 'SueldoMin'</Emphasis>,
la cual almacena el valor del sueldo mínimo por convenio. <Emphasis remap="bf">(3)</Emphasis> una
<Emphasis remap="it">clase Cuadrado</Emphasis> que el método para creación de instancias, escribe
un mensaje: "un Cuadrado creado", y además inicializa con '1' al lado del
objeto creado (<Emphasis remap="it">siendo 'lado' una variable de instancia</Emphasis>).
</Para>

<Para>
Concluyendo, hemos observado, que las clases dan a los
programadores una interesante interfaz para crear objetos, una
manipulación de las mismas como <Emphasis remap="it">'objetos'</Emphasis> hace posible
manipular también sus definiciones, lo mismo que ocurre con las
definiciones de objetos.
</Para>

<Para>
<Emphasis remap="bf">Anotaciones:</Emphasis>
</Para>

<Para>
El mecanismo de <Emphasis remap="it">'herencia'</Emphasis> proporcionado por los LOO,
incrementa el éxito de las utilizaciones LOO en aplicaciones
<Emphasis remap="it">'complejas'</Emphasis>; analicemos donde se fundamenta esta afirmación:

<ItemizedList>
<ListItem>

<Para>
la relación de generalización facilita la modularidad del
código, debido a que una clase corresponde a un módulo, la
herencia entonces da correspondencia a módulos.
</Para>
</ListItem>
<ListItem>

<Para>
Facilita la reutilización del software, atributos y métodos
de una clase son utilizados por las subclases.
</Para>
</ListItem>
<ListItem>

<Para>
Mediante el enlace dinámico disminuye dr sticamente el
mantenimiento de los programas de usuarios.
</Para>
</ListItem>

</ItemizedList>
 
</Para>

<Para>
Nos quedan algunas  reflexiones acerca de lo dicho al
principio:
</Para>

<Para>
Ejemplo: si <Emphasis remap="it">'media'</Emphasis> es el nombre de un método, el cual obtiene
la media de dos números enteros pasados como argumentos, sería
interesante conseguir que una invocación de <Emphasis remap="it">'media'</Emphasis> con
argumentos reales, racionales o complejos sirva del mismo modo,
es decir que pueda operar con distintas clases de argumentos,
sean estos, distintintos en número o distintos en su tipo, o
incluso que el método retorne valores de distinto tipo. En
nuestro ejemplo diríamos que el método media está
<Emphasis remap="it">'sobrecargado'</Emphasis>.
</Para>

</Sect1>

<Sect1>
<Title>Sobrecarga</Title>

<Para>
<Emphasis remap="bf">Sobrecarga:</Emphasis> redefinición de un método con un código distinto.
</Para>

<Para>
El concepto de sobrecarga suele verse en los lenguajes de
programación 'no' orientados a objetos; en C estamos
acostumbrados a tratar algunos "operadores sobrecargados", como
'*', el que tiene más de un significado (<Emphasis remap="it">mientras que la
sobrecarga funcional como en nuestro ejemplo se incorpora en
C++</Emphasis>), los LOO extienden la capacidad de la sobrecarga de
operadores al ámbito de la definición de clases.
</Para>

<Para>
La interpretación del mensaje está supeditada al <Emphasis remap="it">receptor del
mensaje</Emphasis>. Reflexionemos sobre lo ya comentado al principio:  "Un
<Emphasis remap="it">método</Emphasis> es invocado sobre el contenido de la variable, el propio
método de la clase del objeto consigue seleccionar automáticamente el
método correspondiente" <Emphasis remap="bf">(1)</Emphasis> hemos citado el <Emphasis remap="it">método
dibuja()</Emphasis> invocado sobre un objeto receptor conteniendo un rectángulo
ó un círculo, la selección del método, se realiza según la naturaleza del
receptor.  <Emphasis remap="bf">(2)</Emphasis> Podríamos definir el método <Emphasis remap="it">'sueldo'</Emphasis> en
una <Emphasis remap="it">clase Empleado</Emphasis>, el cual muestra el sueldo base contenido en
una variable de instancia; definimos una <Emphasis remap="it">subclase de Empleado</Emphasis> 
llamada <Emphasis remap="it">EmpleadoIncentivado</Emphasis> en la que se define un método
<Emphasis remap="it">'sueldo'</Emphasis> distinto al anterior ya que este proporciona el valor de
sueldo base más incentivo. Es preciso llamar a los dos métodos
con el mismo nombre ya que así nos estamos acercando a la
manera en que el ser humano piensa para resolver problemas,
frecuentemente utilizamos el mismo nombre para nombrar tareas 
similares. 
En los ejemplos: el <Emphasis remap="it">método dibuja()</Emphasis> y el <Emphasis remap="it">método sueldo()</Emphasis> 
son <Emphasis remap="bf">'métodos polimórficos'</Emphasis>. 
</Para>

</Sect1>

<Sect1>
<Title>Polimorfismo</Title>

<Para>
<Emphasis remap="bf">Polimorfismo</Emphasis>: el uso de un nombre ó símbolo -por ejemplo un
operador- para ejecutar más de una acción.
</Para>

<Para>
<Emphasis remap="bf">Anotaciones:</Emphasis>
</Para>

<Para>
Cuando un método está redefinido, puede tomar diferentes
implementaciones. La decisión sobre el tipo de respuesta, es
decir, cual implementación se ejecuta se toma en <Emphasis remap="it">'tiempo de
ejecución'</Emphasis>, basándose en el tipo de receptor.
</Para>

<Para>
El <Emphasis remap="it">polimorfismo</Emphasis> es una herramienta importante para
diseñadores. Permite que un diseño permanezca <Emphasis remap="it">'abierto'</Emphasis> a la
incorporación de nuevas clases de datos y valores aún después que el
diseño ha sido creado, codificado y depurado.
</Para>

</Sect1>

<Sect1>
<Title>Un poco de historia.</Title>

<Para>
La <Emphasis remap="bf">'programación orientada a objetos'</Emphasis> es la precursora de
la <Emphasis remap="bf">'aproximación a objetos'</Emphasis>.
</Para>

<Para>
Smalltalk y C++ son dos representativos de la misma (quizás los
más conocidos).
</Para>

<Para>
Los primeros aciertos de la orientación a objetos fueron
conseguidos por la programación de interfaces gráficas. Luego 
su aplicación se ha generalizado a diversos ámbitos que van
desde los métodos de análisis, a los sistemas distribuidos y
las bases de datos.
</Para>

<Para>
Los lenguajes orientados a objetos son bastante diversos;
diversidad esta que viene dada según el origen, el ámbito de
utilización, y el lenguaje utilizado. Así, el primer lenguaje -totalmente-
orientado a objetos es Simula, aparecido antes de los años setenta; con
sintaxis próxima al Algol, fuertemente tipado, se adapta muy bien a la
resolución de problemas de simulación de sistemas o procesos.
</Para>

<Para>
El primer lenguaje que popularizó la aproximación a objetos fue
Smalltalk, (año 1976); a su vez este deja ver las influencias
de Lisp y Simula que ejercieron sobre él. El primero por la
interpretación y flexibilidad y el segundo por el concepto de
metaclase. Se lo utilizó con éxito en el desarrollo de las
primeras estaciones gráficas.
</Para>

<Para>
En los años ochenta con el despliegue de las estaciones de
trabajo aparecen nuevos lenguajes orientados a objetos
derivados o inspirados en Simula ó Smalltalk.
Entre los lenguajes compilados los más conocidos son C++,
Eiffel y Objective C, debido a la compatibilidad del código
producido, o del mismo lenguaje con el C. Mientras que los lenguajes
interpretados son derivaciones del Lisp como por ejemplo Clos, Loops y
otros.
</Para>

<Para>
También en la actualidad la mayor parte de los populares
lenguajes de tercera generación ya han practicado alguna clase
de extensión para convertirse en orientados a objetos.
</Para>

</Sect1>

</Article>
