<!doctype linuxdoc system>

<article>

<title>Programación Orientada a Objetos: Conceptos</title> 
<author>Paulino Huerta Sánchez &nl; 
Colaborador: Pablo Arranz Alés, <htmlurl
url="mailto:parranza@nexo.es" name="parranza@nexo.es">&nl;  
<date>Primera parte v2, 14 de Noviembre de 1998 
<abstract> Este documento es una guía de conceptos básicos sobre Programación 
Orientada a Objetos (<it>OOP; Object Oriented Programing</it>). Está destinado
a programadores que comiencen a iniciarse o usen algún Lenguaje Orientado
a Objetos (LOO), tales como C++ y Smalltalk, y desean conocer el Paradigma 
Orientado a Objetos.
</abstract>

<toc>

<sect>Aviso
<p>
La versión de este documento será, de momento, la definitiva.

Póngase en contacto con el colaborador si encuentra errores u omisiones
obvias. 
 
<sect>Objetos
<p>

	Un <bf>objeto</bf> es una <it>estructura de datos</it> con un
conjunto de comportamientos que es capaz de realizar. Llamamos
<bf>comportamiento</bf>a aquello que puede ser ejecutado por el objeto
directamente. Por ejemplo podríamos decir que un rectángulo conoce al
mismo como visualizarse sobre la pantalla o conoce como obtener su propia
área. Un objeto consigue estos comportamientos por ser <it>instancia</it>
de una <it>clase</it>.

<sect>Clases
<p>

	Las <bf>clases</bf> definen métodos que se aplican a todos los objetos
que pertenecen a aquella <it>clase</it>, son llamados <bf>métodos de
instancia</bf>.

	La <it>clase</it> también puede incluir métodos independientes a
los de instancia, llamados <bf>métodos de clase ó métodos estáticos</bf>.
Algunos métodos de clase crean nuevos objetos de la clase y son
llamados <bf>métodos constructores</bf> (<it>tal como crear un nuevo
rectángulo de base 10 cms y altura 5 cms</it>), o provee otra
operación necesaria (<it>leer un rectángulo desde un fichero</it>).
 
	Una clase puede ser definida <it>heredando</it> de otra clase, los
<it>métodos de instancia</it> son los de la <it>clase padre o clase
base</it>. Esto permite que una nueva clase sea creada a partir de una
clase similar existente pero agregando nuevos comportamientos.
Cualquier invocación a métodos que no son encontrados en una
clase particular serán buscados en la clase padre automáticamente. Por
ejemplo un rectángulo podría heredar algún comportamiento común de una
clase genérica polígonos.
 
	Si bien podrías conocer la <it>implementación</it> particular de un
objeto, generalmente deberías tratar al objeto como una <it>'caja
negra'</it>. Todos los accesos al objeto deberían obtenerse a través
de una interfaz pública vía los métodos provistos. Esto permite
que las implementaciones pueden ser revisadas y modificadas.
Para la interfaz pública, debe existir documentación escrita
describiendo como usar una clase particular.

<it>Objetos</it> de diferentes <it>clases</it> pueden ser 
<it>'nombrados'</it> en la misma variable en diferente tiempo. Cuando un
método es invocado sobre el contenido de la variable, el propio método de
la clase del objeto consigue seleccionar automáticamente. Si, por
ejemplo, el <it>método dibuja()</it> es invocado sobre una
variable la que contiene o un rectángulo ó un círculo, el método usado
depende de la naturaleza actual del objeto al cual refiere la
variable. Por ello, los métodos para dibujar círculos y
rectángulos, ambos deben llamarse <it>dibuja()</it>.
 
Admitamos que hay más que decir acerca del tema, pero nuestra
propuesta llega hasta aquí. 
 
<sect>Características de los LOO.
<p>

<itemize>
<item>Soportan los <it>'tipos abstractos de datos'</it>.
<item>Es mediante la noción de 'clase' como los LOO permiten
representar TAD.
<item>Las operaciones que caracterizan a un TAD son llamadas métodos
o funciones.
<item>Un método es una operación que tiene un primer argumento un
objeto receptor abstracto, con notación  A1.M(A2,...): el
mensaje que invoca el método va dirigido al objeto A1 con
parámetros eventuales A2,... El concepto de <it>'operación'</it> es
común sea para la aproximación funcional como para la
aproximación a objetos. La <it>aproximación funcional</it> no distingue
los argumentos, y la <it>aproximación orientada a objetos</it> si
distingue el <it>objeto receptor del mensaje</it> que invoca el método.
 
<item>Los lenguajes orientados a objetos <it>'puros'</it> solo gestionan
objetos, tales como <bf>Smalltalk</bf> o <bf>Spoke</bf>. Es decir son
<it>'totalmente'</it> orientados a objetos.
 
<item>Un objeto tiene una propiedad que permite distinguirlo del
resto: su <it>identificador</it>.

Esta es una característica distintiva de los LOO. Los <it>tipos</it> se
implementan bajo la forma de <it>clases</it>, cuyos <it>elementos son
objetos con identificadores</it>. El <it>identificador de un objeto</it>,
a nivel interno es un <it>puntero en memoria</it>.
 
<item>La <it>activación de un método</it> se realiza por medio del
<it>envío de un mensaje a un objeto receptor</it>.
El <it>mensaje</it> comporta el <it>selector del método
(nombre)</it> y los parámetros que se pasan al método.
El <it>'enlace'</it> del código del método a ejecutar en el momento de
la recepción del mensaje por parte de un objeto, es <it>'dinámico'</it>
cuando la búsqueda del código se hace durante la ejecución.
El enlace es <it>'estático'</it> cuando se lleva a cabo durante la
compilación.
 
<item>La <it>creación de objetos</it> requiere la asignación de una zona
de memoria y la inicialización del estado. Generalmente la creación de
objetos se realiza mediante la activación de un <it>'constructor'</it> de
objetos.

El <it>constructor</it> se puede considerar como una función particular
disponible a nivel de la clase. Su llamada no se considera un
envío de mensaje, ya que el objeto receptor no existe.
 
<item>La <it>destrucción de los objetos</it> puede ser automática
(<it>Smalltalk,Clos, Spoke</it>) o manual (<it>C++</it>). La destrucción
automática necesita de un mecanismo de recogida de basura (<it>garbage
collection</it>), este debe  conocer mediante una técnica específica que
objeto no es referenciado, para eliminarlo. Mientras que la destrucción
manual se realiza mediante la invocación de un <it>'destructor'</it>.
</itemize> 

<bf>Anotaciones</bf>:
<itemize>  
<item>Las <it>clases</it> de los LOO constituyen un <it>tipo</it> más.
<item>Se pueden ver como una extensión de los <it>struct</it> del C.
<item>Obtenemos una parte autónoma del programa: <it>estructura de
datos</it> + <it>métodos</it> 
<item>Constituirán un TDA.
<item>Un TDA es una <it>'encapsulación'</it>.
<item>El objeto es la unidad de encapsulación.
</itemize> 
La mayor parte de los LOO utilizan la creación dinámica de
objetos, aplicando el método <it>'new'</it> a la clase de ese objeto.

En Smalltalk:
<verb>
|t1|
t1:= Trabajador new
</verb>
(<it>En Smalltalk todos los objetos son creados dinámicamente</it>)
 
En C++ (<it>dinámicamente</it>)
<verb>
trabajador *t1;
t1=new trabajador; 
</verb> 

Para destruir el objeto en C++:
<verb>
delete t1;
</verb> 
(<it>En C++ es el usuario quien debe preocuparse de la destrucción
de los objetos</it>)
 
En C una función es llamada:
<verb>
z=max(x,y)
y=size(c)
</verb> 

En Smalltalk: Se envía un mensaje a un objeto
<verb> 
z:= x max: y
y:= c size
</verb> 
 
<sect>Aclaraciones
<p>

Una <it>clase</it> realiza varias funciones que a veces se confunden.
Intentemos aclararlo.

	En primer lugar, es un <it>tipo abstracto de datos</it>. Además,
es un generador de instancias ya que una clase permite crear objetos los
que son sus instancias. También una clase permite representar referencias
a objetos de otras clases.

	Existe una relación interclase. Las clases pueden organizarse de
acuerdo a la "relación de generalización" o relación es-un,
esta representación se puede representar mediante el <it>'grafo
deherencia</it>. La <bf>generalización</bf> es útil para clasificar
objetos en función de las características o rasgos comunes y de aquellos
específicos.

	La inversa de la <it>función generalización</it>, es llamada
<bf>"especialización"</bf>, y esta permite agregar propiedades específicas
a una clase generando una subclase. 

<bf>Definimos:</bf>

	 La <it>generalización</it> hace corresponder a una subclase o
clase origen, una clase más general o superclase.

	La <it>especialización</it> hace corresponder a una clase todas
las subclases de las cuales es la superclase.
 
	El <it>enlace de generalización</it> indica que las <it>instancias
de una subclase</it> son también <it>instancias de la superclase</it>, lo
que nos dice que objetos que pertenecen a la subclase poseen las 
propiedades de la subclase además de aquellas de la superclase.
 
	Hay también una relación entre un objeto y su clase. Es la
función de instanciación y es la que ha permitido crearlo. Entonces
observamos una dicotomía entre objeto y clase. Esta dicotomía se pierde si
fuese posible generar clases como objetos, es decir que una clase fuese
instancia de otra.

	Podemos considerar una clase <it>'metaclase'</it> generadora de
clases contendría métodos aplicables a las clases generadas (<it>comunes a
todas las clases</it>) y datos comunes, como el OID. Es decir, las
<it>'metaclases'</it> son clases cuyas instancias son también clases.  Así
podríamos utilizar una clase para guardar datos que sean compartidos por
todas sus instancias, -variables de clase, en Smalltalk-, coincidiendo
esta posibilidad con el concepto de 'información global', ya que es común
a todas las instancias de la clase y no pertenece a ninguna instancia en
particular. 

	Y, en cuanto a los <it>métodos de clase</it>, se posibilita que
cada clase puede tener su propio método para crear instancias. Como
ejemplo <bf>(1)</bf> podemos definir una <it>clase Alumno</it>, con una
<it>'variable de clase: Media'</it>, en la que se almacena la nota media
del curso al que pertenece. <bf>(2)</bf> una <it>clase
EmpleadoEspecialista</it> con una variable de <it>clase 'SueldoMin'</it>,
la cual almacena el valor del sueldo mínimo por convenio. <bf>(3)</bf> una
<it>clase Cuadrado</it> que el método para creación de instancias, escribe
un mensaje: "un Cuadrado creado", y además inicializa con '1' al lado del
objeto creado (<it>siendo 'lado' una variable de instancia</it>).
 
	Concluyendo, hemos observado, que las clases dan a los
programadores una interesante interfaz para crear objetos, una
manipulación de las mismas como <it>'objetos'</it> hace posible
manipular también sus definiciones, lo mismo que ocurre con las
definiciones de objetos.
 
<bf>Anotaciones:</bf>

	El mecanismo de <it>'herencia'</it> proporcionado por los LOO,
incrementa el éxito de las utilizaciones LOO en aplicaciones
<it>'complejas'</it>; analicemos donde se fundamenta esta afirmación:
<itemize>
<item>la relación de generalización facilita la modularidad del
código, debido a que una clase corresponde a un módulo, la
herencia entonces da correspondencia a módulos.
<item>Facilita la reutilización del software, atributos y métodos
de una clase son utilizados por las subclases.
<item>Mediante el enlace dinámico disminuye dr sticamente el
mantenimiento de los programas de usuarios.
</itemize> 

Nos quedan algunas  reflexiones acerca de lo dicho al
principio:
 
Ejemplo: si <it>'media'</it> es el nombre de un método, el cual obtiene
la media de dos números enteros pasados como argumentos, sería
interesante conseguir que una invocación de <it>'media'</it> con
argumentos reales, racionales o complejos sirva del mismo modo,
es decir que pueda operar con distintas clases de argumentos,
sean estos, distintintos en número o distintos en su tipo, o
incluso que el método retorne valores de distinto tipo. En
nuestro ejemplo diríamos que el método media está
<it>'sobrecargado'</it>.
 
<sect>Sobrecarga
<p>
 
<bf>Sobrecarga:</bf> redefinición de un método con un código distinto.
 
El concepto de sobrecarga suele verse en los lenguajes de
programación 'no' orientados a objetos; en C estamos
acostumbrados a tratar algunos "operadores sobrecargados", como
'*', el que tiene más de un significado (<it>mientras que la
sobrecarga funcional como en nuestro ejemplo se incorpora en
C++</it>), los LOO extienden la capacidad de la sobrecarga de
operadores al ámbito de la definición de clases.
 
La interpretación del mensaje está supeditada al <it>receptor del
mensaje</it>. Reflexionemos sobre lo ya comentado al principio:  "Un
<it>método</it> es invocado sobre el contenido de la variable, el propio
método de la clase del objeto consigue seleccionar automáticamente el
método correspondiente" <bf>(1)</bf> hemos citado el <it>método
dibuja()</it> invocado sobre un objeto receptor conteniendo un rectángulo
ó un círculo, la selección del método, se realiza según la naturaleza del
receptor.  <bf>(2)</bf> Podríamos definir el método <it>'sueldo'</it> en
una <it>clase Empleado</it>, el cual muestra el sueldo base contenido en
una variable de instancia; definimos una <it>subclase de Empleado</it> 
llamada <it>EmpleadoIncentivado</it> en la que se define un método
<it>'sueldo'</it> distinto al anterior ya que este proporciona el valor de
sueldo base más incentivo. Es preciso llamar a los dos métodos
con el mismo nombre ya que así nos estamos acercando a la
manera en que el ser humano piensa para resolver problemas,
frecuentemente utilizamos el mismo nombre para nombrar tareas 
similares. 
En los ejemplos: el <it>método dibuja()</it> y el <it>método sueldo()</it> 
son <bf>'métodos polimórficos'</bf>. 
 
<sect>Polimorfismo
<p>

<bf>Polimorfismo</bf>: el uso de un nombre ó símbolo -por ejemplo un
operador- para ejecutar más de una acción.
 
<bf>Anotaciones:</bf>

	Cuando un método está redefinido, puede tomar diferentes
implementaciones. La decisión sobre el tipo de respuesta, es
decir, cual implementación se ejecuta se toma en <it>'tiempo de
ejecución'</it>, basándose en el tipo de receptor.

	El <it>polimorfismo</it> es una herramienta importante para
diseñadores. Permite que un diseño permanezca <it>'abierto'</it> a la
incorporación de nuevas clases de datos y valores aún después que el
diseño ha sido creado, codificado y depurado.
 
<sect>Un poco de historia.
<p>
 
	La <bf>'programación orientada a objetos'</bf> es la precursora de
la <bf>'aproximación a objetos'</bf>.

	Smalltalk y C++ son dos representativos de la misma (quizás los
más conocidos).

	Los primeros aciertos de la orientación a objetos fueron
conseguidos por la programación de interfaces gráficas. Luego 
su aplicación se ha generalizado a diversos ámbitos que van
desde los métodos de análisis, a los sistemas distribuidos y
las bases de datos.
 
	Los lenguajes orientados a objetos son bastante diversos;
diversidad esta que viene dada según el origen, el ámbito de
utilización, y el lenguaje utilizado. Así, el primer lenguaje -totalmente-
orientado a objetos es Simula, aparecido antes de los años setenta; con
sintaxis próxima al Algol, fuertemente tipado, se adapta muy bien a la
resolución de problemas de simulación de sistemas o procesos.
 
	El primer lenguaje que popularizó la aproximación a objetos fue
Smalltalk, (año 1976); a su vez este deja ver las influencias
de Lisp y Simula que ejercieron sobre él. El primero por la
interpretación y flexibilidad y el segundo por el concepto de
metaclase. Se lo utilizó con éxito en el desarrollo de las
primeras estaciones gráficas.

	En los años ochenta con el despliegue de las estaciones de
trabajo aparecen nuevos lenguajes orientados a objetos
derivados o inspirados en Simula ó Smalltalk.
Entre los lenguajes compilados los más conocidos son C++,
Eiffel y Objective C, debido a la compatibilidad del código
producido, o del mismo lenguaje con el C. Mientras que los lenguajes
interpretados son derivaciones del Lisp como por ejemplo Clos, Loops y
otros.

	También en la actualidad la mayor parte de los populares
lenguajes de tercera generación ya han practicado alguna clase
de extensión para convertirse en orientados a objetos.

</article>
