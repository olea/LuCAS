<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>

<articleinfo>

<title>Fetchmail+Sendmail-COMO</title>
<author>
<firstname>Roberto Suárez Soto</firstname>
<affiliation><address><email>rss-trgn@usa.net</email></address></affiliation>
</author>
<pubdate>16 de Noviembre de 1998</pubdate>

<abstract>

<para>
Este "COMO" cubre la configuración y manejo básicos de sendmail y fetchmail.
Su objetivo es hacer posible el recoger y enviar correo de una manera cómoda
("off-line", es decir, mientras no estamos conectados a Internet) y lo más
transparente posible (se puede automatizar todo sin problemas). Se cubren
aspectos ya tocados en el "Infovía-HOWTO", pero ampliándolos en lo tocante a
los dos programas que dan título al COMO. También se explica uno de los usos
más frecuentes del programa procmail, que es el de organizar el correo
entrante en diferentes carpetas. Esto es especialmente útil cuando se está
suscrito a varias listas de correo.
</para>

</abstract>

</articleinfo>

<sect1>
<title>Notas Previas </title>

<sect2>
<title>Cambios desde la versión 1.0 </title>

<para>
Esto lo pongo aquí porque creo que empieza a hacer falta una sección así en
el "COMO" :-)
</para>

<para>
En la <emphasis remap="bf">versión 1.0b3</emphasis> se corrigieron dos "bugs" que no eran tales:
uno de ellos consistía en que debía haber una línea con el nombre y el
dominio de la máquina en el fichero /etc/hosts, en vez de sólo una con el
nombre (o simplemente "localhost"); y otro, algo que no viene documentado
sobre fetchmail: que si las passwords o los nombres de usuario contienen
números, hay que ponerlos entre comillas. Digo que no eran tales "bugs"
porque no tengo yo toda la culpa :-) El primer bug es algo que mucha gente
tiene bien configurado, ya que es una de las primeras cosas (por lo menos en
mi caso) que se mira (para la conexión a Internet, y estas cosas :-)). Y el
segundo ... bueno, no viene documentado, ¿qué iba a saber yo? :-) El sufrido
BetaTester que me notificó estos "bugs" fue David Fernández Vaamonde, y las
soluciones (como siempre O:-)) fueron facilitadas por Fernando Sánchez.
</para>

<para>
En la <emphasis remap="bf">versión 1.1b1</emphasis> (siempre conviene poner que es una versión
beta, porque así la gente es más condescendiente con los fallos que puedas
tener &rcub;:-)), se añade un pequeño apartado sobre la compilación del
sendmail.cf. He decidido incluirla después de un fallo que Fernando Sánchez
(el omnipresente :-)) descubrió con cómo eran enmascarados mis mensajes y
cómo los trataba la nueva versión del sendmail, la 8.9.x. Con versiones
anteriores de sendmail no había problema, pero era debido a un pequeño
agujero de seguridad que tenían. El problema es que no se enmascara
correctamente el dominio, y hace falta haber compilado el sendmail.cf con
una opción especial ("masquerade_envelope") para que funcione bien. Esta
opción viene por defecto en Debian, y supongo que en las demás
distribuciones también; pero por si acaso ... :-) También amplié un poco la
sección dedicada a procmail, para cubrir algún detalle que me había dejado
en la versión anterior :-)
</para>

<para>
En la <emphasis remap="bf">versión 1.1b2</emphasis>, sólo he cambiado la manera de automatizar las
llamadas a fetchmail y sendmail al conectarse a Internet. Era algo que
debería haber hecho hace tiempo, pero ya se sabe cómo son estas cosas :-)
</para>

<para>
En la <emphasis remap="bf">versión 1.2</emphasis> he cambiado la manera de enmascarar el usuario y
el dominio; ahora lo hago con "genericstable", una "feature" de sendmail que
es perfecta para el usuario normal. A pesar de usar esto, sigo poniendo la
forma "antigua" de hacer las cosas, por si a alguien no le funcionara la
nueva o prefiera la anterior.
</para>

<para>
En la <emphasis remap="bf">versión 1.2b2</emphasis> he cambiado un par de cosas sin mucha
importancia, "detallitos": cambié la forma de encontrar el directorio de
macros de sendmail y añadí una nota sobre la localización de éste en las
versiones más modernas del paquete sendmail (en Debian, por lo menos).
</para>

</sect2>

<sect2>
<title>Agradecimientos </title>

<para>
En este "COMO" debería haber un "co-autor": Fernando Sánchez, que fue el que
me dijo cómo montar sendmail, y además me dio numerosos consejos para montar
fetchmail y procmail (además, ha sido uno de los "betatesters"/supervisores
de este COMO :-)).
</para>

<para>
Así que si algo falla, echadle a él la culpa :-P ;-) (que no, que es broma
... Fer, deja el bate de béisbol, por favor =:-m ... ;-D).
</para>

<para>
También quiero dar gracias a mis dos primeros betatesters "oficiales" (es
decir, los únicos que han comentado directamente conmigo lo que les había
pasado siguiendo las instrucciones del documento): David Fernández Vaamonde
y Francisco Expósito Pequeño.
</para>

<para>
En la versión 1.1b2 también recojo un par de sugerencias de Jacobo Tarrío.
</para>

</sect2>

<sect2>
<title>Aspectos legales ("Disclaimer" y "Copyright") </title>

<para>
Estoy seguro de que habéis visto muchos documentos con este apartado, así
que ya os lo sabréis de memoria :-)
</para>

<para>
Lo de siempre: que este documento se distribuye SIN GARANTIA DE NINGUNA
CLASE. A mí me ha funcionado, y no creo ser ningún ente de infinita
sabiduría o superior intelecto :-)
</para>

<para>
Copyright ... pues el típico, que hagáis lo que os dé la gana con el
documento, pero si lo modificáis o algo así, sería bonito que dijérais de
quién es el original :-)
</para>

</sect2>

<sect2>
<title>Lo que necesitaréis ("Ingredientes" :-)) </title>

<para>
Lo primero, un ordenador con Linux instalado &percnt;-) (es el chiste típico, lo
siento O:-)).
</para>

<para>
Además, aseguraos de que tenéis los siguientes programas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
 <emphasis remap="it"> sendmail </emphasis> : es un estándar en todas las distribuciones, lo más
probable es que lo tengáis ya instalado y medianamente configurado. Si
tenéis alguna duda, sólo tenéis que ver si existe el fichero
/etc/sendmail.cf. Si existe, es que tenéis instalado sendmail. Si no ...
mala suerte y un vistazo al "sendmail-mini-COMO" :-) (más sobre esto en el
apartado "Compilando el sendmail.cf")

</para>
</listitem>
<listitem>

<para>
 <emphasis remap="it"> fetchmail </emphasis> : Debian y RedHat lo traen "de serie", y
Slackware también, pero desde la 3.3. Si no lo tenéis, podéis conseguirlo de
su página oficial, <ulink
url="http://www.ccil.org/~esr/fetchmail"
>http://www.ccil.org/~esr/fetchmail</ulink
> o del espejo de SunSite en
RedIris, <ulink
url="ftp://ftp.rediris.es/software/linux/distributions"
>ftp://ftp.rediris.es/software/linux/distributions</ulink
>. Buscad vuestra
distribución, coged la última versión que encontréis de fetchmail e
instaladla. Si usáis RedHat o Debian, la instalación se reduce a hacer un
"rpm -i" (RedHat) o un "dpkg -i" (Debian) del paquete. Si usáis SlackWare, y
cogéis el paquete .tgz ... pues bueno, supongo que tendrá algún README que
explica cómo se instala O:-)

</para>
</listitem>
<listitem>

<para>
 <emphasis remap="it"> procmail </emphasis> : también es estándar en todas las
distribuciones. Si queréis bajar la última (o una versión más o menos
reciente, porque el espejo de RedIris no es todo lo actualizado que se
desearía), lo podéis encontrar en RedIris, en el mismo sitio que fetchmail.

</para>
</listitem>

</itemizedlist>

</para>

<para>
También necesitaréis un fichero <emphasis remap="it">/etc/hosts</emphasis> bien puesto: ¿qué
quiere decir "bien puesto"? Pues que debe contener una línea no sólo con
"localhost" y el nombre de vuestra máquina, sino también el de la máquina
con su dominio. Un ejemplo:
</para>

<para>
Los programas de instalación de algunas distribuciones (con Debian pasa, por
lo menos) dejan un /etc/hosts parecido a esto:
</para>

<para>
	127.0.0.1 localhost murphy
</para>

<para>
(murphy es el nombre de mi máquina)
</para>

<para>
Esto funciona para casi todo, pero no para sendmail. Sendmail necesita
saber, además del nombre de la máquina, su dominio. Y es en este fichero
donde mirará primero (después mirará en un DNS, pero no creo que os interese
;-)). Por lo tanto, sólo tenéis que añadir a la línea actual vuestro nombre
y dominio. El dominio puede ser inventado. Mi /etc/hosts está ahora así:
</para>

<para>
	127.0.0.1 localhost murphy murphy.darkland.es
</para>

<para>
Desfogad vuestra imaginación y poned un dominio bonito :-) De hecho, cuando
tenéis varias máquinas conectadas en red, podéis hacer que pertenezcan todas
al mismo dominio. Eso es lo más profesional :-) No estoy muy seguro del
formato del dominio (si tiene sólo dos campos o puede tener más), aunque
podéis hacer pruebas y comprobarlo vosotros mismos :-)
</para>

</sect2>

<sect2>
<title>Bugs </title>

<para>
Sí, hijos míos, este COMO tiene un "bug" (uno que yo sepa O:-)). Lo siento, no
soy infalible, como el Papa :-)
</para>

<para>
(Parece mentira que a pesar de las tres revisiones que he hecho, siga sin
saber cómo solucionar esto O:-))
</para>

<para>
Este bug no es demasiado serio: simplemente, consiste en que, modificando el
sendmail.cf tal y como se os indica aquí, el correo enviado por el usuario
que uséis será enmascarado ... incluso si el destinatario sea otro usuario
de la máquina local. Es decir, si yo con mi usuario "robe", y habiendo
enmascarado la dirección de salida como "rss-trgn@usa.net", le mando un mail
al root de mi máquina, la dirección de retorno de este mail no aparecerá
como "robe@murphy.darkland.es" (mi usuario y el dominio de mi máquina), sino
como "rss-trgn@usa.net". Por supuesto, cuando intentemos responder a este
mensaje, la respuesta irá al buzón de correo de Internet, y desde ahí
tendremos que recogerlo para leerlo.
</para>

<para>
Sin embargo, como en la mayoría de los casos no nos interesará demasiado
mandarnos mails a nosotros mismos, no creo que haya ningún problema :-)
</para>

</sect2>

</sect1>

<sect1>
<title>El temido /etc/sendmail.cf </title>

<para>
para que sendmail funcione correctamente, necesitaremos hacer algunas
modificaciones a su fichero de configuración, el <emphasis remap="it">/etc/sendmail.cf</emphasis>
(de ahora en adelante, simplemente "sendmail.cf"). Sin embargo, "don't
panic!" :-) Son modificaciones sencillas, con las que no deberíais tener
ningún problema. Pero, por si acaso, haced una copia de seguridad del
sendmail.cf, que nunca se sabe :-)
</para>

<para>
También veremos, muy por encima, cómo compilar el fichero sendmail.cf a
partir de un fichero de macros. Suena un poco raro, pero es fácil :-) El
"Sendmail-MiniComo" de Juan Ignacio Llona cubre este aspecto, así que ante
la duda, echadle un vistazo; es uno de los documentos en los que se basa
éste "COMO".
</para>

<para>
A partir de la versión 1.2 de este documento, no hace falta hacer ninguna
modificación al sendmail.cf; basta con compilar un fichero de macros
adecuado (se incluye un ejemplo) y ya está.
</para>

<sect2>
<title>Compilando, que es gerundio </title>

<para>
El fichero sendmail.cf no es creado "a pelo". para crearlo, se unan varios
ficheros de macros (extensión m4, aunque no venga muy a cuento :-)), en los
que vienen definidas las partes del fichero cf. Sólo hay que "juntar" varios
ficheros m4 con lo que necesitemos, y compilar otro fichero "maestro".
Necesitaréis el paquete <emphasis remap="it"> GNU m4 </emphasis> (m4 es un procesador de macros),
que (como siempre :-)) suele venir instalado en la mayoría de
distribuciones.
</para>

<para>
Puede que parezca complicado, pero ¡tranquilidad! A lo mejor no necesitáis
compilar nada :-) para saberlo, mirad en vuestro fichero /etc/sendmail.cf
(supongo que ya tenéis uno compilado, que viene en todas las
distribuciones). Fijaos a ver si en él hay una línea parecida a esta:
</para>

<para>

	#####  @(#)masquerade_envelope.m4       8.1 (Berkeley) 7/9/95  #####

</para>

<para>
Si es así, felicidades, no necesitáis compilar un nuevo sendmail.cf ni nada
:-) Podéis pasar al siguiente apartado (menos mal ':-)).
</para>

<para>
Si no es así ... bien, no pasa nada ... vamos a COMPILAR (imagínate que esto
es dicho por Cristopher Lee en una película de Drácula, para captar mejor la
esencia de la frase ;-)).
</para>

<para>
Como dije un poco más arriba, la compilación del sendmail.cf viene muy bien
explicada en el Sendmail-mini-COMO, de Ignacio Llona (<ulink
url="http://www.infor.es/LuCAS/Otros/html/sendmail-minicomo/"
>http://www.infor.es/LuCAS/Otros/html/sendmail-minicomo/</ulink
>). Míralo un
poco si no entiendes bien algo de lo que viene a continuación :-)
</para>

<para>
Lo primero que hay que hacer es localizar el sitio donde están instaladas
las macros de sendmail. En Debian, están en el directorio <emphasis remap="it">/usr/lib/sendmail.cf </emphasis>. Si en tu distribución no están ahí, puedes
buscarlas con:
</para>

<para>
	find / -type d -name 'sendmail*' | grep cf
</para>

<para>
Que te dará una salida parecida a esto:
</para>

<para>
	[root @ ~]# find / -type d -name 'sendmail*' | grep cf
	/usr/lib/sendmail.cf
	[root @ ~]#
</para>

<para>
El directorio sería, en este caso, /usr/lib/sendmail.cf, como dije antes.
</para>

<para>
<emphasis remap="bf">NOTA:</emphasis> En el último sendmail que he probado (en paquete Debian, no
sé si en otras distribuciones pasará lo mismo), versión 8.9.1 (y versión de
paquete Debian mayor que 3, que es el que tengo en otro ordenador y todavía
no ha cambiado :-m), el directorio con las macros ha pasado de ser
<emphasis remap="it">/usr/lib/sendmail.cf</emphasis> a ser <emphasis remap="it">/usr/share/sendmail.cf</emphasis>.
</para>

<para>
Muy bien, pues ya tenemos el directorio donde están las macros de sendmail.
Vete ahí, y entra en el directorio "cf"; en mi caso,
/usr/lib/sendmail.cf/cf, en otra distribución puede ser algo como /(... la
ruta que sea ...)/sendmail/cf/cf. Ahora deberías buscar un fichero
"linux.smtp.mc", o en Debian, un "debproto.mc", y luego modificarlo. Pero lo
mejor es que copies este que pongo a continuación :-)
</para>

<para>

<programlisting>

include(`../m4/cf.m4')
VERSIONID(`linux for smtp-only setup')dnl
# Aunque aquí en OSTYPE ponga "debian", normalmente es "linux"
# (si tienes Debian, es mejor que lo dejes así; si no, cambialo por "linux")
OSTYPE(debian)dnl
FEATURE(nouucp)dnl
FEATURE(nodns)dnl
# Esta es la línea que corrige la "incompatibilidad" con sendmail 8.9:
FEATURE(masquerade_envelope)dnl
FEATURE(always_add_domain)dnl
define('confCON_EXPENSIVE', 'True')
define(SMTP_MAILER_FLAGS, e)
# Aquí pongo el servidor SMTP que voy a usar
define(`SMART_HOST', smtp:smtp.mx3.redestb.es)
# Aquí pongo el dominio de mi dirección de correo (rss-trgn@usa.net)
MASQUERADE_AS(usa.net)
MAILER(local)dnl
MAILER(smtp)dnl

</programlisting>

</para>

<para>
Creo que no pasa nada si dejas los comentarios, pero mejor quítalos cuando
lo copies. Queda más profesional ;-)
</para>

<para>
Copia todo esto a un fichero "local.mc" (por seguir la nomenclatura del
"Sendmail-minicomo" :-)). Recuerda que tienes que estar en el directorio cf,
si no, no funcionará (la línea del fichero que pone "include(`../m4/cf.m4')"
tiene algo que ver con eso ;-)).
</para>

<para>
Y ahora lo compilas:
</para>

<para>
	m4 local.mc &#62; sendmail.cf
</para>

<para>
Y ya está :-) Copia el fichero sendmail.cf que acabas de crear a /etc (o
donde deba estar el sendmail.cf; en mi Debian 2.0, está en /etc/mail), y
pasa al siguiente apartado.
</para>

</sect2>

<sect2>
<title>Indicando el servidor SMTP </title>

<para>
Esta parte ya está cubierta en el "Infovía-HOWTO", pero he decidido ponerla
también aquí para que no tengáis que andar mirando en varios docs a la vez
:-)
</para>

<para>
Esta modificación que vamos a hacer vale para que todo el correo que
escribáis "off-line" se mande a un servidor SMTP, que se encargará de
distribuir el correo a donde corresponda. En principio, no es necesario: si
no existe esta entrada, sendmail buscará él mismo las direcciones a las que
habéis mandado el correo. Pero esto puede llevarle tiempo, así que lo mejor
es mandar todo a un servidor y dejarle a éste hacer todo el trabajo :-)
</para>

<para>
Si habéis utilizado el "Sendmail-MiniComo" para compilar vuestro
sendmail.cf, esta línea ya la tendréis creada, y podéis saltaros esta
sección :-) (si habéis compilado el sendmail.cf con las instrucciones del
apartado anterior, también estará creada :-))
</para>

<para>
Tenéis que buscar unas líneas en el sendmail.cf que pongan los siguiente:
</para>

<para>
	# "Smart" relay host (may be null)
	DS
</para>

<para>
A lo mejor no están, pero no os preocupéis. Sólo tenéis que añadirlas. Yo
las tengo al principio de la sección "local info", después de unas líneas en
las que pone lo de "my official domain name". Supongo que con que la pongáis
más o menos por ahí llegará :-)
</para>

<para>
La línea que empieza por '&num;' es un comentario, no hace falta que la pongáis.
Sólo tenéis que preocuparos de la siguiente línea, la que pone únicamente
"DS". A continuación de estas letras debéis poner vuestro servidor SMTP. En
mi caso, lo tengo así:
</para>

<para>
	# "Smart" relay host (may be null)
	DSsmtp:smtp.mx3.redestb.es  
</para>

<para>
Y ya está. Asegúrate de tener una única entrada como esta (una única línea que
empiece por "DS") en todo el sendmail.cf, porque si hay dos entradas
definiendo un servidor de éstos, no sé qué podría pasar :-)
</para>

</sect2>

<sect2>
<title>Enmascaramiento con "genericstable"</title>

<para>
Como decía más arriba, en la revisión 1.2 he adoptado una nueva (y más
sencilla) forma de enmascarar tanto el usuario como el dominio de la
dirección: genericstable. Es una característica de sendmail que permite
justamente lo que yo hacía antes con userdb: enmascarar el correo de salida
de un usuario con otra dirección diferente a la local.
</para>

<para>
para usar esta característica, hace falta recompilar el fichero de macros de
sendmail. Si tomamos como ejemplo el que os ponía más arriba, las
modificaciones que hacen falta son las siguientes:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Añadir la siguiente línea:
	FEATURE(`genericstable',`hash -o /etc/mail/genericstable')dnl
(Preferiblemente, después del resto de "features")
</para>
</listitem>
<listitem>

<para>
Quitar la línea de "MASQUERADE_AS"
</para>
</listitem>

</itemizedlist>

</para>

<para>
De esta forma, no harán falta posteriores modificaciones del fichero
sendmail.cf; sólo con la salida de m4 con este fichero ya tendremos un
fichero cf funcional.
</para>

<para>
El fichero /etc/mail/genericstable que se menciona en la línea a añadir
puede estar en otro sitio o llamarse de otra forma, sólo importa que se lo
indiques ahí. Este fichero es el que va a indicar los usuarios a enmascarar,
y la forma de hacerlo. El contenido de un fichero de este tipo con mi
dirección sería así:
</para>

<para>
robe	rss-trgn@usa.net
</para>

<para>
Es decir: usuario, tabulado para separar los dos campos y dirección que
quieras usar. Después de esto, hay que compilar el fichero, haciendo:
</para>

<para>
makemap hash /etc/mail/genericstable &#60; /etc/mail/genericstable
</para>

<para>
Y ya está. A partir de ahora, el correo que envíe el usuario robe aparecerá
como si proviniera de rss-trgn@usa.net. No hay que hacer ninguna
modificación más.
</para>

<para>
Al final del documento incluyo un sendmail.mc de ejemplo en el que se aplica
esta característica, así como la especificación de procmail como agente de
entrega del correo local.
</para>

</sect2>

<sect2>
<title>Enmascarando con "userdb"</title>

<para>
Esta es la manera que venía usando antes de conocer lo de genericstable. Si
has leido la sección anterior, verás que es mucho más sencilla de aplicar
que ésta. Sin embargo, dejo esta sección porque puede que haya gente a la
que le valga de algo, o que por alguna razón incomprensible no le funcione
la anterior (¿quién dijo que la informática fuera una ciencia exacta? :-)).
</para>

<sect3>
<title>Enmascarando el usuario </title>

<para>
A lo largo del COMO, emplearé como ejemplo mi propia dirección de correo,
<emphasis remap="it"> rss-trgn@usa.net </emphasis> . En esta dirección sabéis que hay dos campos:
</para>

<para>
Usuario: es el campo que va antes de la arroba, que en mi caso es rss-trgn.
</para>

<para>
Dominio: es el campo que va detrás de la arroba (en mi caso, usa.net), y que
corresponde al dominio del servidor de correo que utilicéis.
</para>

<para>
En el "Infovía-COMO" se os sugiere que creéis en vuestra máquina un usuario
como el que tengáis en la dirección de correo. Esto no hace falta si
enmascaramos el usuario, o sea, le decimos al sistema de correo que en los
mensajes que envíe nuestro usuario "habitual" (en mi caso, "robe") cambie el
campo del usuario local por uno que nosotros le diremos, que será el del
usuario remoto (el que figura en la dirección, en mi caso "rss-trgn").
</para>

<para>
para esto, cread un fichero /etc/userdb con vuestro editor preferido, y en
él pondréis las siguientes líneas:
</para>

<para>
	local:mailname remoto
	remoto:maildrop local
</para>

<para>
Donde tenéis que cambiar lo de "local" por vuestro usuario en la máquina
local, y "remoto" por vuestro usuario en la máquina remota. Mi /etc/userdb
está así:
</para>

<para>
	robe:mailname rss-trgn
	rss-trgn:maildrop robe
</para>

<para>
Ahora, hay que convertir ese fichero de texto en un fichero db, que es el
que va a utilizar el sendmail. para eso, sólo tenéis que hacer:
</para>

<para>
	makemap btree /etc/userdb.db &#60; /etc/userdb
</para>

<para>
para hacer esto, necesitáis una versión moderna del makemap (la de la
SlackWare 3.2, por ejemplo, NO VALE), o el makemap que viene en el paquete
del propio sendmail. En caso de duda, intentad conseguir la última versión
de Internet (o de una BBS, o de un amigo, o de un CD, o ... :-)). Yo no he
tenido problemas con el makemap que venía en la RedHat 4.1, ni con el que
viene con la Debian 1.3.1, por lo que si tenéis una de estas distribuciones
(o una más moderna) debería funcionar.
</para>

<para>
Muy bien, y ahora hay que decirle al sendmail que use este fichero. para
eso, debéis añadir una línea al sendmail.cf, tal que así:
</para>

<para>
	# Fichero userdb para reescribir el usuario
	Kuserdb btree -o /etc/userdb.db
</para>

<para>
La línea que empieza por '&num;' es un comentario, así que la podéis quitar si
queréis. Pero bueno, dejad algo para saber qué es lo que hace esa línea, por
si después queréis cambiarlo y no os acordáis de dónde era :-)
</para>

<para>
El sitio donde pongáis esta línea no es demasiado significativo. Yo la tengo
después de otras cuatro opciones que empiezan también por K, otras que
también tratan sobre tablas dbm. Buscad directamente "dbm" en el editor y
las encontraréis.
</para>

</sect3>

<sect3>
<title>Cambiando las "rules" para que el Pine no dé problemas </title>

<para>
El Pine tiene un problema con el uso de un fichero como el que hemos creado.
Si quieres saber cuál es exactamente, vete a la FAQ del sendmail y mira en
la pregunta Q3.6 :-) Se debe a la manera que tiene el Pine de reescribir las
cabeceras de los mensajes. Pero bueno, lo importante aquí es saber cómo
arreglarlo.
</para>

<para>
(Si no usas el Pine ... pues no debería hacerte falta cambiar nada. Pero ya
que estás aquí, aprovecha y cámbialo ... algún día, quizás quieras utilizar
el Pine, y a lo mejor no te acuerdas de que había que hacer esta
modificación :-))
</para>

<para>
para esto, vamos a añadir un "parche" a las "rules", que son la parte con
multitud de signos '$' y que no hay quien entienda &percnt;-) que aparece al final del
sendmail.cf. Añade el fragmento siguiente a tu sendmail.cf, justo después
del comentario (enorme, seguro que lo ves :-)) que pone "Rewriting rules":
</para>

<para>

<programlisting>

#LOCAL_RULE_1
########################################################
### Local Ruleset 1, rewrite sender header &#38; envelope ##
########################################################
#Thanks to Bjart Kvarme &#60;bjart.kvarme@usit.uio.no&#62;

S1
R$-			$1 &#60; @ $j . &#62;			user=&#62;user@localhost
R$- &#60; @ $=w . &#62; $*	$: $1 &#60; @ $2 . &#62; $3 ?? $1	user@localhost ?
R$+ ?? $+		$: $1 ?? $(userdb $2 :mailname $: @ $)
R$+ ?? @		$@ $1				Not found
R$+ ?? $+		$&#62;3 $2				Found, rewrite

</programlisting>

</para>

<para>
MUY IMPORTANTE: los espacios que ves entre cada columna DEBEN SER TABULADOS.
Es decir, que si coges este fragmento de arriba con el gpm y lo pegas en
otra consola (que es lo más lógico y fácil para estas cosas :-)), tienes que
editarlo después y sustituir el espacio entre columnas por tabulados.
</para>

<para>
Más fácil todavía: un ejemplo de cómo sería una de estas líneas:
</para>

<para>

R$-    (3 tabulados)	$1 &#60; @ $j . &#62;   (3 tabulados)	user=&#62;user@localhost

</para>

<para>
Creo que se entiende, ¿no? :-) Una pista más: la tercera línea que comienza
por 'R$' son sólo dos columnas, no intentes convertirla en tres :-)
</para>

<para>
Si ves que al cargar el sendmail te da errores extraños, muy probablemente
sea de que te has dejado algún espacio donde no debías, o que al cortar y
pegar alguna de las líneas ha quedado mal. Asegúrate de que todo queda tal y
como aparece aquí.
</para>

</sect3>

<sect3>
<title>Enmascarando el dominio </title>

<para>
Esta es la parte más fácil :-) Sólo tienes que buscar unas líneas en el
sendmail.cf que ponen:
</para>

<para>
	# who I masquerade as (null for no masquerading) (see also $=M)
	DM
</para>

<para>
Después de "DM", tienes que poner el dominio de tu servidor de correo. En mi
caso, sería "usa.net":
</para>

<para>
	# who I masquerade as (null for no masquerading) (see also $=M)
	DMusa.net
</para>

<para>
Y ya está. Hemos acabado todo lo relacionado con modificar el sendmail.cf.
¿No ha dolido, verdad? :-) Pues sigamos.
</para>

</sect3>

</sect2>

<sect2>
<title>Reiniciando el sendmail </title>

<para>
para que los cambios que hemos hecho surtan efecto, hemos de reiniciar el
sendmail. En Debian, que es lo que usa un menda, basta con hacer (siendo
root):
</para>

<para>
	/etc/init.d/sendmail reload
</para>

<para>
Pero no os asustéis si no tenéis Debian: lo que hace este script es
perfectamente factible en cualquier Linux/Unix, ya que sólo se trata de una
señal que le mandáis al proceso con "kill", de este modo:
</para>

<para>
	killall -1 sendmail
</para>

<para>
A lo mejor tenéis que cambiar otra cosa, pero ahora en el fichero de
arranque de sendmail. Dependiendo de la distribución que uséis, estará en el
directorio /etc/init.d (Debian), o /etc/rc.d (RedHat y SlackWare, creo). El
nombre no lo sé, pero seguro que contiene la palabra mágica "sendmail"
:-) Si tenéis alguna otra distribución, seguramente siga el mismo patrón que
cualquiera de estas tres.
</para>

<para>
para encontrar esta línea, también podéis recurrir a "find" y "grep":
</para>

<para>
	find /etc -type f | xargs grep sendmail
</para>

<para>
Que os mostrará todos los ficheros que contengan en su nombre la palabra
"sendmail".
</para>

<para>
En este fichero, aseguraos de que la llamada a sendmail contiene el
parámetro "-bd". A lo mejor tiene a continuación otro parámetro, de la forma
"-q..." (por ejemplo, "-q10m", "-q1h30m", o algo parecido). Quitad éste
último, y dejad sólo el primero. Si dejásemos este último parámetro,
sendmail intentaría procesar la cola de correo cierto tiempo (el indicado en
el parámetro "-q": "-q10m" serían 10 minutos, "-q1h30m" sería 1 hora y 30
minutos, etc.). Dejando sólo el primer parámetro, sendmail esperará a
nuestra señal para procesar y enviar el correo.
</para>

<para>
Cada vez que queráis mandar el correo, tenéis que hacer:
</para>

<para>
	/usr/bin/sendmail -q
</para>

<para>
Aseguraos de que ponéis la ruta correcta a sendmail, porque sino os
econtraréis con un "sendmail: command not found" bastante desagradable :-)
</para>

</sect2>

</sect1>

<sect1>
<title>Configuración de fetchmail </title>

<sect2>
<title>Preparando fetchmail: el archivo fetchmailrc </title>

<para>
Fetchmail puede ser utilizado sin archivo de configuración, simplemente con
los parámetros que le demos en la línea de comandos. Esto puede ser una
opción si sólo tenemos que recoger el correo de un buzón, sin demasiadas
zarandajas. Pero lo más útil (y comprensible) es que indiquemos las opciones
de fetchmail en su fichero de configuración, un fichero llamado
<emphasis remap="it"> .fetchmailrc </emphasis>. Tiene que estar en el directorio de trabajo del
usuario que vaya a usar fetchmail, así que en mi caso (usuario "robe") sería
<emphasis remap="it"> /home/robe/.fetchmailrc </emphasis>.
</para>

<para>
Creo que la mejor manera de entenderlo es ver un ejemplo. Aquí os pongo mi
fetchmailrc, comentado, y con los passwords cambiados, por supuesto ;-).
</para>

<para>

<programlisting>

#
# .fetchmailrc
#

defaults			# Comandos comunes a todos los servidores:
	fetchall		# - Coger todos los mensajes en el buzón
	flush			# - Borrar todos los mensajes ya recogidos
				#   en anteriores llamadas al servidor

poll pop.netaddress.com		# Indica el primer servidor al que llamar
	user rss-trgn 		# Nombre de usuario (cuenta) en este servidor 
	pass "password1" 	# Password para esta cuenta de correo
	to robe 		# Usuario local al que enviar el correo

poll pop3.mx3.redestb.es	# El segundo servidor al que llamar
	user rbss		# Usuario (cuenta) en este servidor
	pass "password2"	# Password para esta cuenta de correo
	to robe			# Usuario local al que enviar el correo

</programlisting>

</para>

<para>
Las comillas que envuelven a las passwords SON NECESARIAS. Si no aparecen,
puede que el fetchmail consiga acceder a vuestro buzón, o puede que no: si
vuestra password estaba formada sólo por letras (por ejemplo, "pepito"), no
tendréis ningún problema. Pero si además, contenía números o signos de
puntuación (por ejemplo, "mola1000"), el servidor de correo no aceptará la
password como válida y no podréis recoger el correo. Creo que también son
necesarias si el nombre de usuario contiene caracteres que no sean letras;
si tenéis algún problema, probad así :-)
</para>

<para>
Esta es una configuración bastante sencilla. Si le echáis un vistazo a la
página del manual de fetchmail, veréis que hay algunas opciones más.
</para>

<para>
Este fichero tiene que tener permisos de sólo lectura y escritura para
&nbsp;vuestro usuario (es decir, hay que hacerle un "chmod 600" siendo el usuario
que va a usar fetchmail), o fetchmail se negará a funcionar.
</para>

</sect2>

<sect2>
<title>Llamando a fetchmail en la línea de comandos </title>

<para>
Habiendo creado un .fetchmailrc como el anterior, para recoger el correo
sólo tenéis que llamar a fetchmail, sin que haga falta ninguna opción más:
</para>

<para>
	fetchmail
</para>

<para>
Pero claro ... hay opciones muy interesantes que merece la pena utilizar :-)
Os muestro la línea de comandos con la que llamo yo a fetchmail:
</para>

<para>
	fetchmail -d 600 -v -L /home/robe/etc/fetchmail.log
</para>

<para>
Es un poco más larga que la anterior :-)
</para>

<para>
Esto es lo que hacen esos parámetros:
</para>

<para>

<itemizedlist>
<listitem>

<para>
 <emphasis remap="it"> -d 600 </emphasis> : hace que fetchmail se quede residente (modo
"daemon", de ahí la "d"), y que recoja el correo cada 600 segundos (10
minutos). para matar el proceso, podéis optar por el método tradicional
("ps"+"kill") o, mucho más fácil, hacer <emphasis remap="it"> "fetchmail --quit" </emphasis>, que
se encarga de buscar el PID del fetchmail y matarlo de una forma
"civilizada" :-)

</para>
</listitem>
<listitem>

<para>
 <emphasis remap="it"> -v </emphasis> : "verbose", o sea, que vaya diciendo lo que está
haciendo en cada momento.

</para>
</listitem>
<listitem>

<para>
 <emphasis remap="it"> -L /home/robe/etc/fetchmail.log </emphasis> : "-L" indica que la
salida de los mensajes que pudiera generar (los creados por "-v",
concretamente) se pasen a un archivo de log. "/home/robe/etc/fetchmail.log"
es el fichero al que quiero que se pasen estos mensajes.

</para>
</listitem>

</itemizedlist>

</para>

<para>
para comprobar qué es lo que va a hacer fetchmail con los parámetros dados y
los que se encuentran en el fichero de configuración, vamos a añadir otra
opción a la llamada en la línea de comandos: <emphasis remap="it">"-V"</emphasis> (o también
"--version"). De esta forma, no se realizará ninguna llamada; simplemente,
se mostrará en pantalla cómo ha interpretado fetchmail la configuración
actual. En resumen, algo que deberéis hacer para evitaros sorpresas
inesperadas :-)
</para>

</sect2>

</sect1>

<sect1>
<title>Configurando procmail (opcional, pero recomendable :-)) </title>

<para>
Procmail no hace falta para recoger el correo, de ahí el caracter "opcional"
de este apartado. Sin embargo, es un programa muy potente, que nos permitirá
(entre otra muchas cosas) filtrar el correo entrante y clasificarlo en
varias carpetas según le digamos. La utilidad más obvia para esto es tener
los mensajes de varias listas de correo en una carpeta para cada lista, lo
que queda bastante mejor que tener todo el mogollón en el "inbox" :-)
</para>

<sect2>
<title>Uso de procmail para filtrar listas de correo </title>

<para>
Como he dicho antes, procmail no hace falta para recoger el correo.
Configurando sendmail y fetchmail tal y como se ha dicho hasta aquí, ya está
todo. A pesar de todo, creo que no hace daño a nadie aprender un poco cómo
se maneja :-) Sólo trataré un tema, que es el de preparar procmail para que
almacene en diferentes carpetas las listas de correo a las que podamos estar
suscritos. Por supuesto, ésta no es más que una mínima utilización de este
programa, que es capaz de hacer muchas más cosas ... pero a mí me llega :-)
Si queréis saber más ... pues, como siempre, "man procmail" :-) (y "man
procmailex", con ejemplos)
</para>

<sect3>
<title>Uso de procmail con Sendmail &#62;= 8.9 </title>

<para>
Si usáis una <emphasis remap="it">versión de sendmail superior o igual a la 8.9</emphasis>, puede que
tengáis problemas con este fichero: por defecto, sendmail considera
"inseguros" los directorios con permiso de escritura para un grupo o para
todo el mundo, e ignora los ficheros .forward que se encuentren en ellos.
</para>

<para>
La solución óptima a este problema es hacer que procmail sea el ¿MDA?
(¿"Mail Delivering Agent"? :-?) por defecto. Esto se especifica en el
fichero de macros del sendmail (sí, ése que habíais compilado hace un rato y
que pensásteis que no habría que volver a tocar O:-)), añadiendo dos líneas
nada más. Estas líneas tienen que ir en un orden más o menos claro, que
explico a continuación:
</para>

<para>
La primera línea es esta:
</para>

<para>
FEATURE(local_procmail)dnl
</para>

<para>
Esta línea le indica a sendmail que el que entregará el correo local será
procmail. Puede ir más o menos en cualquier sitio, aunque (como antes) yo
recomendaría ponerla al final del resto de "features".
</para>

<para>
La otra línea es la siguiente:
</para>

<para>
MAILER(procmail)
</para>

<para>
Que le indica a sendmail que "se prepare" para usar este mailer. Esta línea
debe ir <emphasis remap="it">antes</emphasis> del resto de líneas "MAILER" (yo la tengo justo antes
de la de "MAILER(smtp)").
</para>

<para>
Además, debéis quitar la línea que pone:
</para>

<para>
MAILER(local)
</para>

<para>
O directamente cambiar lo de "local" por "procmail", vamos. Como más os
guste :-)
</para>

<para>
No hace falta nada más. A partir de ahora, al ser procmail el que entregue
el correo local, no hace falta un fichero .forward como el que se menciona
en el siguiente apartado (es decir, que te saltes el apartado siguiente
:-)); si procmail encuentra un fichero .procmailrc (el fichero de
configuración de procmail, se explica más adelante) en el directorio raíz de
un usuario, procesará el correo según se indique en este fichero; y si no lo
encuentra, entregará el correo normalmente.
</para>

<para>
Esta modificación se puede usar en cualquier versión más o menos reciente de
sendmail. De hecho, es incluso más recomendable que el uso de un fichero
.forward. Al final del documento he incluido otro fichero sendmail.mc de
ejemplo en el que se aplican tanto esta modificación como la necesaria para
usar la característica "genericstable".
</para>

</sect3>

<sect3>
<title>El fichero .forward </title>

<para>
(Recuerda que debes saltarte este apartado si has seguido el anterior ;-))
</para>

<para>
Lo primero que tenemos que hacer es crear un fichero <emphasis remap="it"> .forward </emphasis> (en
directorio de trabajo del usuario que vayáis a usar, evidentemente). En él
se llamará automáticamente a procmail cuando nos llegue correo. Os pongo
aquí mi .forward:
</para>

<para>

"|IFS=' ' &#38;&#38; p=/usr/bin/procmail &#38;&#38; test -f $p &#38;&#38; exec $p -Yf- || exit 75 #robe"

</para>

<para>
Atención: sólo una línea. No sé cómo se verá esto en el COMO resultante (por
eso de pasarlo a HTML o TXT), pero tened en cuenta eso. Y otra cosa: las
comillas (") al principio y al final de la línea SON NECESARIAS.
</para>

<para>
Y otra cosa más: verificad que la ruta a procmail sea la correcta, porque
sino vuestro correo desaparecerá sin dar ningún aviso :-) para saber cuál es
la ruta adecuada, no tenéis más que hacer:
</para>

<para>
	which procmail
</para>

<para>
El campo del que tenéis que preocuparos ahora es del que viene después de la
almohadilla (&num;): aquí tenéis que poner vuestro usuario local (como véis, yo
tengo puesto "&num;robe", ya que "robe" es el usuario que utilizo en mi
máquina).
</para>

</sect3>

<sect3>
<title>El fichero .procmailrc </title>

<para>
Y ahora, el fichero de configuración del procmail en sí: el <emphasis remap="it"> .procmailrc</emphasis>. Su sintaxis es algo complicada, porque usa "regular expressions"
(expresiones regulares, como las utilizadas con "egrep", "find", y multitud
de programas más). Pero para un uso sencillo, como el que le daremos
nosotros, se entiende bastante bien.
</para>

<para>
He aquí mi .procmailrc:
</para>

<para>

<programlisting>

PATH=/bin:/usr/bin:/usr/bin
MAILDIR=$HOME/mail		# El directorio donde están almacenadas
				# vuestras carpetas de correo; yo lo tengo
				# configurado para el Pine, otros programas
				# usan $HOME/Mail (creo que Elm, por
				# ejemplo) o algún otro directorio.

:0:
* ^(To|Cc).*gpul-admin		# Busca "gpul-admin" en el campo "To" o "Cc"
gpul-admin			# Carpeta destino

:0:
* ^From.*spammers.com		# para correo de spammers conocidos ...
/dev/null			# ... un destino igualmente conocido :-)

:0:
* ^(To|Cc|From).*gnome		# para listas de correo en las que la
GNOME				# dirección puede aparecer en varios campos
				# distintos (To, Cc o From)

</programlisting>

</para>

<para>
Como digo en el fichero, la variable MAILDIR indica dónde se almacenan las
carpetas de correo. Es MUY IMPORTANTE que sea correcto, o sino perderéis
todo el correo que proceséis con este filtro.
</para>

<para>
Creo que se entienden bastante bien los campos: uno busca en el "To" (el
destinatario) y otro en el "Cc" ("Carbon Copy", copias del mensaje). Los
mensajes que encuentra con el criterio dado (con una cadena que contenga
"gpul-admin", en este caso) los guarda en la carpeta que se indica debajo
(en este caso, "gpul-admin" también :-)). Si la carpeta destino no existe,
es creada automáticamente.
</para>

<para>
De esta manera, el correo que llegue será filtrado por procmail, y así
tendréis el correo normal en vuestro "inbox" y el correo de las listas de
correo a las que estéis suscritos en carpetas aparte.
</para>

<para>
Pero ... muchas veces, por cualquier razón, podemos encontrarnos con que no
hemos filtrado correctamente el correo entrante, y como resultado tenemos
135 mensajes de las listas "linux-is-amazing" y "linux-it-flies" (por
supuesto, son ejemplos imaginarios ;-)) en el "inbox". ¿Qué hacer? Moverlos
uno a uno puede llevarnos bastante tiempo.
</para>

<para>
Bien, pues para estas ocasiones, podemos usar el siguiente script. Este
script utiliza la información en .procmailrc para coger el correo del
"inbox" y filtrarlo, clasificando los mensajes y colocándolos en sus
carpetas correspondientes:
</para>

<para>

<programlisting>

#!/bin/sh

# postmail (para filtrar el correo del inbox)

ORGMAIL=/var/spool/mail/$LOGNAME

if cd $HOME &#38;&#38;
	test -s $ORGMAIL &#38;&#38;
	lockfile -r0 -l3600 .newmail.lock 2&#62;/dev/null
              then
                trap "rm -f .newmail.lock" 1 2 3 15
                umask 077
                lockfile -l3600 -ml
                cat $ORGMAIL &#62;&#62;.newmail &#38;&#38;
                 cat /dev/null &#62;$ORGMAIL
                lockfile -mu
                formail -s procmail &#60;.newmail &#38;&#38;
                 rm -f .newmail
                rm -f .newmail.lock
              fi
              exit 0

</programlisting>

</para>

<para>
Un detalle más: a partir de ahora, sólo se os informará de que habéis
recibido nuevo correo si tenéis nuevos mensajes en el "inbox", y no cuando
recibáis correo en alguna de las listas. En este último caso, sólo se os
informará de que tenéis correo en el buzón local.
</para>

</sect3>

<sect3>
<title>Una solución, quiero: la variable MAILPATH </title>

<para>
Pero bueno, hay una solución para esto :-) <emphasis remap="it"> (¡nuevo en la versión 1.1!
;-)) </emphasis> Lo primero que debéis hacer, sólo para saber un poco de qué va la
cosa, es "man bash", y una vez en la página, buscar "MAILPATH", así en
mayúsculas. Como veréis, es bash el que informa de cuando hay nuevo correo.
Por defecto, avisa cuando hay nuevo correo en /var/spool/mail/usuario, que
en mi caso (usuario robe) sería /var/spool/mail/robe. Pero esto, como casi
todo en Linux/Unix, se puede ajustar a nuestras necesidades :-)
</para>

<para>
para ello, tenemos que cambiar la variable MAILPATH, en el .bash_profile
(porque estamos usando bash; en el caso de otros shells, como zsh, sh, ksh,
etc., no sé si se podrá hacer O:-) - aunque en el caso del zsh, casi
aseguraría que sí ;-)). He aquí la definición que yo tengo puesta:
</para>

<para>

<programlisting>

# Hago una definición "preliminar" de la variable MAILPATH
MAILPATH='/var/spool/mail/robe? -- Tienes nuevo correo!'

# Añado el resto de "folders" a la variable:
for i in gpul-admin linux-alert debian-announce kernel-announce 
do
	MAILPATH=$MAILPATH:'/home/robe/mail/'$i'? -- Hay correo en '$i
done

export MAILPATH

</programlisting>

</para>

<para>
Ahora explico todo eso que pone ahí arriba :-)
</para>

<para>
La sintaxis de la definición de MAILPATH es la siguiente:
</para>

<para>
MAILPATH='(ruta al fichero de correo) ? (mensaje)'
</para>

<para>
Las comillas no estoy muy seguro de si son obligatorias o no, pero a mí me
funcionan ;-) La <emphasis remap="bf"> "ruta al fichero de correo" </emphasis> es la ruta al
fichero del "folder" del que queréis ser avisados cuando haya nuevo correo.
Con Pine, están almacenados en /home/usuario/mail. El <emphasis remap="bf"> "mensaje"</emphasis> es, ni más ni menos, el mensaje que queréis que os ponga bash cuando
haya nuevo correo en ese "folder" (algún día traduciré todos los anglicismos
que hay en el "COMO" O:-) , sorry - oops! :-D).
</para>

<para>
En el ejemplo, tengo definida MAILPATH como:
</para>

<para>
	MAILPATH='/var/spool/mail/robe? -- Tienes nuevo correo!'
</para>

<para>
Lo que quiere decir que, cuando haya correo nuevo en el fichero
/var/spool/mail/robe (el fichero por defecto a donde va todo el correo del
usuario robe), aparecerá la frase "-- Tienes nuevo correo!" en la pantalla.
</para>

<para>
Lo que hace el "for" que viene después es añadir los "folders" que tengo en
/home/robe/mail a la variable MAILPATH. De este modo, cada vez que haya
nuevo correo en uno de ellos, bash me soltará lo de " -- Hay correo en " y
el nombre del "folder"; lo hago con un "for" para no tener que añadir a mano
todos los ficheros de correo. Espero que entendáis cómo funciona un "for" en
bash, porque sino creo que no os quedará muy claro todo esto O:-) para las
dudas, "help for" ;-)
</para>

<para>
Si después del "help", todavía no os ha quedado claro, podéis hacerlo a
mano. La sintaxis sería como la de antes, pero separando por dos puntos (:)
cada definición que hagáis para un "folder", de esta manera:
</para>

<para>
MAILPATH='(fichero 1) ? (mensaje 1)':'(fichero 2) ? (mensaje 2)'
</para>

<para>
Y así "ad infinitum" :-)
</para>

</sect3>

</sect2>

<sect2>
<title>Otro ejemplo del uso de procmail </title>

<para>
Hace unos días, he creado una cuenta en un redireccionador de correo,
NetForward. Pues bien, resulta que NetForward mete tres líneas de publicidad
al principio de cada mensaje que recibo. No es muy molesto, pero ... ¿no
quedaría todo mucho mejor si pudiera "cortar" esas líneas, para que no me
aparecieran?
</para>

<para>
Con procmail se puede :-)
</para>

<para>
Las líneas ofensivas son éstas:
</para>

<para>
Thanks for using NetForward!
http://www.netforward.com
v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
</para>

<para>
para quitarlas, tenemos que hacer un pequeño script que deje pasar todo el
mensaje, menos las líneas que no queremos ver. Un script así puede ser éste:
</para>

<para>

<programlisting>

#!/bin/sh

USUARIO=robe

cat | \
egrep -v "^Thanks for using NetForward|^http://www.netforward.com|^v.v.v.v." \
	| formail &#62;&#62; /var/spool/mail/$USUARIO

</programlisting>

</para>

<para>
Creo que egrep viene en todas las distribuciones :-m Haz un "which egrep"
para salir de dudas :-) Y si no lo tienes, sustitúyelo por "grep -E", que me
imagino que también valdrá (aunque no lo he probado :-m).
</para>

<para>
Este script deja pasar todo lo que le entre por stdin (la entrada estándar),
menos las líneas que empiecen por eso de "Thanks for ...",
"http://www.netforward ..." o "v&circ;v&circ;v&circ;v&circ;" (aunque no lo parezca; son
expresiones regulares, por lo que pueden confundir un poco). Después, lo que
queda es mandado al "folder" /var/spool/mail/robe, que si recuerdas era el
fichero de correo por defecto del usuario robe, mi usuario local. He puesto
la variable "USUARIO" para que tú pongas en ella tu usuario local, y no
tengas que cambiar nada más :-) (aunque no habría mucho que cambiar ;-)).
Una vez creado este script (vamos a suponer que lo has llamado
"filtro.netforward.sh", que no es un nombre muy práctico pero sí explicativo
:-)), lo hacemos ejecutable ("chmod +x filtro.netforward.sh") y seguimos.
</para>

<para>
Puedes probar si funciona el script cogiendo un mensaje que tengas por ahí y
que te haya llegado redireccionado desde NetForward (que tenga las líneas
ésas, vamos :-)). Grábalo en un fichero, y a continuación haces:
</para>

<para>
	cat mensaje.grabado | filtro.netforward.sh | less
</para>

<para>
Si lo que sale (he puesto el "less" al final por si el mensaje es largo y no
cabe en una sóla pantalla) es el mensaje original, pero sin las tres líneas
que no deben salir ;-) , entonces todo va bien :-) En caso contrario ...
¿qué es lo que has hecho mal? &rcub;;-)
</para>

<para>
Ahora, tenemos que decirle a procmail que use este script. para eso,
añadimos una entrada en el fichero .procmailrc:
</para>

<para>

<programlisting>

:0 B
* ^Thanks for using NetForward
| cat | /home/robe/bin/filtro.netforward.sh

</programlisting>

</para>

<para>
Suponiendo que el script anterior estuviera en el directorio /home/robe/bin.
No hace falta que pongas la ruta completa al script si éste está en tu path
(asegúrate de que está en tu path si no pones la ruta completa, o de lo
contrario tus mensajes se perderán sin razón aparente :-m).
</para>

<para>
Esta "receta" (no sé si he dicho antes que las entradas del .procmailrc se
llaman así) busca la cadena "Thanks for using NetForward" al principio de
una línea en el cuerpo del mensaje (la "B" que aparece en la primera línea
es para buscar en el cuerpo del mensaje, en vez de la cabecera), y si la
encuentra ejecuta el comando que aparece en la tercera línea.
</para>

<para>
No hace falta que entiendas exactamente todo lo que hace en cada momento (yo
no lo entiendo bien, y ya ves &percnt;-D), pero siempre conviene tener una idea,
por si acaso falla algo :-)
</para>

</sect2>

</sect1>

<sect1>
<title>Organizando todo esto en scripts </title>

<para>
Aquí os pongo los scripts que tengo yo para automatizar todo lo del correo.
</para>

<para>
He cambiado esto desde la versión anterior (1.1b1) para que se ejecute
confiando más en los ficheros ip-up e ip-down, que son los que el demonio
pppd lanza automáticamente cuando inicia (ip-up) o termina (ip-down) una
conexión PPP. Así que los scripts quedan mucho más sencillos.
</para>

<para>
Fichero para la conexión a Internet:
</para>

<para>

<programlisting>
	#!/bin/sh

	#
	# inet_on
	#

	# 		------- Conexión a Internet --------
	# Lanzo el pppd:
	/usr/sbin/pppd
	# En Debian, se usaría el comando "pon", tal que así:
	# 	pon
	# O también, según lo tengas configurado:
	# 	pon &#60;proveedor&#62;
	# Donde &#60;proveedor&#62; es un fichero que contiene datos para la
	# conexión con un proveedor determinado; esto es lo normal cuando
	# has usado la utilidad "pppconfig"

	# Miro en los logs cómo va la conexión (con Infovía, nunca se sabe :-))
	(/usr/bin/tail -f /var/log/messages | egrep "pppd||chat")&#38;
	# En Debian, esto sería equivalente a hacer:
	# plog -f
	
</programlisting>

</para>

<para>
Fichero para la desconexión:
</para>

<para>

<programlisting>
	#!/bin/sh

	#
	# inet_off
	#

	# Corto la conexión:
	echo "Cerrando enlace ppp ..."
	killall -v -HUP pppd
	# En Debian, esto se haría con el comando "poff":
	#	poff
</programlisting>

</para>

<para>
Normalmente, todas las distribuciones traen un comando para matar el pppd.
En Debian, como digo más arriba, es "poff". En Slackware, es "ppp-off". Es
mucho más intuitivo que hacer un killall, y además estos scripts suelen
hacer comprobaciones adicionales, por lo que es muy recomendable su uso.
</para>

<para>
En el directorio /usr/doc/ppp/examples tienes un "ppp-on" y un "ppp-off" de
ejemplo (al menos en mi versión, 2.3.5). Por si no los trae, te pego el
"ppp-off". El "ppp-on" es mucho más largo, así que no lo pego (tampoco es
tan importante; iniciar el pppd de una manera u otra no importa mucho, pero
cerrarlo correctamente sí que importa).
</para>

<para>
Fichero ppp-off:
</para>

<para>

<programlisting>

	#!/bin/sh
	######################################################################
	#
	# Determine the device to be terminated.
	#
	if [ "$1" = "" ]; then
		DEVICE=ppp0
	else
		DEVICE=$1
	fi
	
	######################################################################
	#
	# If the ppp0 pid file is present then the program is running. Stop it.
	if [ -r /var/run/$DEVICE.pid ]; then
	        kill -INT `cat /var/run/$DEVICE.pid`
	#
	# If the kill did not work then there is no process running for this
	# pid. It may also mean that the lock file will be left. You may wish
	# to delete the lock file at the same time.
	        if [ ! "$?" = "0" ]; then
	                rm -f /var/run/$DEVICE.pid
	                echo "ERROR: Removed stale pid file"
	                exit 1
	        fi
	#
	# Success. Let pppd clean up its own junk.
	        echo "PPP link to $DEVICE terminated."
	        exit 0
	fi
	#
	# The ppp process is not running for ppp0
	echo "ERROR: PPP link is not active on $DEVICE"
	exit 1
	
</programlisting>

</para>

<sect2>
<title>Fichero ip-up </title>

<para>
Creo que en todas las distribuciones está en /etc/ppp/ip-up. Es un script
ejecutable, que como decía un poco más arriba, el pppd lanza cuando se
inicia una conexión. Es mucho mejor poner aquí el comando que llama al
fetchmail, ya que así, si la conexión no se realiza con éxito (tristemente
habitual en Infovía :-/), no hay que matar los demonios que se hayan
lanzado. Todo lo que lances desde aquí será ejecutado <emphasis remap="bf"> como root </emphasis>,
así que ten cuidado con lo que pones.
</para>

<para>
A partir del pppd 2.3.x (creo :-m), estos ficheros no son los que contienen
directamente los comandos a ejecutar. En su lugar, se hace una llamada a
run-parts para que ejecute los scripts que se encuentren en el directorio
/etc/ppp/ip-up.d. Aquí lo voy a poner de las dos maneras, es decir, tanto
para versiones anteriores de pppd (2.2.0f es la más habitual, me parece)
como para las versiones 2.3.x.
</para>

<para>
El fichero ip-down se rige más o menos por las mismas normas, salvo que en
vez de ejecutar los scripts en ip-up.d, ejecuta los que se encuentran en
ip-down.d.
</para>

<para>
para saber cuál de las dos debes utilizar, sólo tienes que hacer un "ls
/etc/ppp". Si ves dos directorios llamados "ip-up.d" e "ip-down.d", es la
versión 2.3.x; si no, la 2.2.x. Hay una manera más lógica, que es llamando
al pppd con un parámetro que da la versión que tiene. Pero ahora no me
acuerdo cuál es O:-) ;-)
</para>

<sect3>
<title>Un fichero ip-up para versiones de <emphasis remap="it">pppd 2.2.x</emphasis>: </title>

<para>

<programlisting>

	#!/bin/sh

	# Actualización de IP
	# (para poder hacer cosas como talks, por ejemplo :-))
	echo 127.0.0.1 localhost &#62; /etc/hosts
	echo $4 murphy.darkland.es murphy &#62;&#62; /etc/hosts

	# para el correo:
	fetchmail -d 600 -v -a -L /dev/tty9
	(sendmail -v -q &#62; /dev/tty10) &#38;

</programlisting>

</para>

<para>
Está claro, ¿no? La línea del fetchmail está explicada más arriba (aquí, en
vez de dirigir el log a un fichero, lo hago a una terminal, para poder
consultarlo directamente - y sin que el fichero de logs crezca y crezca sin
control ;-)), y la del sendmail es para mandar el correo que se haya
encolado antes de la conexión.
</para>

</sect3>

<sect3>
<title>Un fichero ip-up para versiones de <emphasis remap="it">pppd 2.3.x</emphasis>: </title>

<para>
Esta es la versión que viene con el pppd de Debian, pero modificándola
ligeramente:
</para>

<para>

<programlisting>
	#!/bin/sh
	#
	# $Id: doc-como-fetchmail+sendmail.xml,v 1.3 2002/11/30 11:19:30 ricardo.cervera Exp $
	#

	# The  environment is cleared before executing this script
	# so the path must be reset
	PATH=/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin
	export PATH
	# These variables are for the use of the scripts run by run-parts
	PPP_IFACE="$1"
	PPP_TTY="$2"
	PPP_SPEED="$3"
	PPP_LOCAL="$4"
	PPP_REMOTE="$5"
	PPP_IPPARAM="$6"
	export PPP_IFACE PPP_TTY PPP_SPEED PPP_LOCAL PPP_REMOTE PPP_IPPARAM

	# as an additional convenience, $PPP_TTYNAME is set to the tty name,
	# stripped of /dev/ (if present) for easier matching.
	PPP_TTYNAME=`/usr/bin/basename "$2"`
	export PPP_TTYNAME 

	# Main Script starts here

	echo "" &#62; /dev/console
	echo "Conexión con éxito ..." &#62; /dev/console
	echo "" &#62; /dev/console

	echo 127.0.0.1 localhost &#62; /etc/hosts
	echo $4 cheetah.darkland.es cheetah &#62;&#62; /etc/hosts

	# Lanzo los scripts que hay en /etc/ppp/ip-up.d
	run-parts /etc/ppp/ip-up.d

# last line

</programlisting>

</para>

<para>
Y en el directorio /etc/ppp/ip-up.d tengo el siguiente script para el correo
(tengo más, pero éste es el que interesa :-)):
</para>

<para>

<programlisting>

	#!/bin/sh

	# para el correo:
	fetchmail -d 600 -v -a -L /dev/tty9
	(sendmail -v -q &#62; /dev/tty10) &#38;

</programlisting>

</para>

<para>
Se ve que son las dos líneas que antes tenía en el ip-up.
</para>

</sect3>

</sect2>

<sect2>
<title>Fichero ip-down </title>

<para>
He aquí un ip-down para <emphasis remap="it">pppd 2.2.x</emphasis>:
</para>

<para>

<programlisting>
	#!/bin/sh
	# "Desactualización" de IP:
	echo 127.0.0.1 cheetah.darkland.es localhost cheetah &#62; /etc/hosts

	fetchmail --quit
</programlisting>

</para>

<para>
Y para <emphasis remap="it">pppd 2.3.x</emphasis>:
</para>

<para>

<programlisting>

	#!/bin/sh
	# "Desactualización" de IP:
	echo 127.0.0.1 cheetah.darkland.es localhost cheetah &#62; /etc/hosts

	run-parts /etc/ppp/ip-down.d
</programlisting>

</para>

<para>
Y en el directorio /etc/ppp/ip-down.d, tengo un script "correo-off" tal que
así:
</para>

<para>

<programlisting>

	#!/bin/sh
	fetchmail --quit
</programlisting>

</para>

<para>
Ya está ':-) Ahora, cuando te conectes a Internet, el propio pppd lanzará
los scripts adecuados para recoger el correo. Yo tengo así también los
scripts para recoger/enviar las news y para recoger/enviar los bloques de
llaves para el concurso RC5-64. Puedes usarlos también para subir
automáticamente tu página web por ftp, o para ... no sé, los usos son
infinitos :-) Echale imaginación :-P
</para>

</sect2>

</sect1>

<sect1>
<title>Apéndice 1: otro sendmail.mc de ejemplo </title>

<para>
A lo largo de este documento se plantean dos posibilidades a la hora de
hacer algunas modificaciones. Una de ellas es la de cambiar el método
"tradicional" (con respecto a anteriores versiones del "COMO", no porque
todo el mundo lo hiciera así hasta ahora :-)) de enmascarar usuario y
dominio, y otra para usar procmail como agente de correo local. He aquí un
sendmail.mc que incluye ambas modificaciones. Parte del que se había puesto
como ejemplo en la sección "Compilando el sendmail.cf", pero con las
modificaciones pertinentes para estas dos opciones.
</para>

<para>

<programlisting>

include(`../m4/cf.m4')
VERSIONID(`linux for smtp-only setup')dnl
# Aunque aquí en OSTYPE ponga "debian", normalmente es "linux"
# (si tienes Debian, es mejor que lo dejes así; si no, cambialo por "linux")
OSTYPE(debian)dnl
FEATURE(nouucp)dnl
FEATURE(nodns)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(always_add_domain)dnl
FEATURE(`genericstable',`hash -o /etc/mail/genericstable')dnl
FEATURE(local_procmail)dnl
define('confCON_EXPENSIVE', 'True')
define(SMTP_MAILER_FLAGS, e)
# Aquí pongo el servidor SMTP que voy a usar
define(`SMART_HOST', smtp:smtp.mx3.redestb.es)
MAILER(procmail)dnl
MAILER(smtp)dnl

</programlisting>

</para>

</sect1>

<sect1>
<title>Apéndice 2: compartiendo una única cuenta de correo </title>

<para>
Esto es una contribución de Esteve Sala, <ulink
url="mailto:esala@usa.net"
>esala@usa.net</ulink
>. Hace tiempo que me escribió comentando este documento
y contando lo que había hecho él, que era precisamente esto. Perdí el mail
hace unos meses, así que no sé si los datos son correctos; tampoco me
acuerdo muy bien de los detalles, por lo que cualquier fallo de lo que
escribo a continuación es culpa mía, no suya :-)
</para>

<para>
La mejor manera de entender esto es con un ejemplo. El caso de Esteve era
que tenía un club, y quería dar email a sus socios. para ello, había cogido
una cuenta gratuita en Usa.Net, y el correo que entraba en ella era filtrado
a cada usuario. El correo de todos los usuarios salía con esta dirección.
</para>

<para>
Esteve usaba procmail y sendmail, con la característica de userdb. Yo lo
haré con procmail y sendmail también, pero en vez de usar userdb voy a usar
genericstable (que como he dicho N veces a lo largo del documento, me parece
más sencillo :-)). No he probado nada de esto, así que descargo toda
responsabilidad sobre lo que pueda pasar O:-) Sin embargo, no creo que
ocurra nada: me limito a aplicar lo que se cuenta en este documento (y eso
sí que lo he comprobado :-)).
</para>

<sect2>
<title>Enmascarando la salida </title>

<para>
Supongamos que la cuenta de correo que queremos compartir se llama
club@gratis.com, y que son tres los usuarios que la van a compartir: pepe
(Jose López), paco (Francisco Pérez) y toni (Antonio Fernández).
</para>

<para>
Habiendo compilado el sendmail.cf con la opción de "genericstable",
crearíamos un fichero /etc/mail/genericstable así:
</para>

<para>

pepe	club@gratis.com
paco	club@gratis.com
toni	club@gratis.com

</para>

<para>
Y lo compilaría con "makemap hash /etc/mail/genericstable &#60;
/etc/mail/genericstable", como se decía más arriba. De esta forma, ya
tendríamos solucionado el tema del correo saliente.
</para>

</sect2>

<sect2>
<title>Filtrando el correo de entrada </title>

<para>
Ahora tendríamos que asegurarnos de que el correo entrante fuera a parar a
sus respectivos dueños. Esto lo haríamos con procmail, filtrando por el
nombre de destino. Es decir, que incluiríamos unas recetas tal que así en el
procmailrc del usuario que recogiera el correo (que en este caso lo más
normal es que fuera el root, aunque podría ser cualquier usuario):
</para>

<para>

<programlisting>

# (Los nombres del corren entrante no llevan tildes)

:0
* ^To.*Jose Lopez
! pepe

:0
* ^To.*Francisco Perez
! paco

:0
* ^To.*Antonio Fernandez
! toni

</programlisting>

</para>

<para>
Aunque la dirección de destino de los que escribiesen a los socios del club
siempre sería club@gratis.com, el nombre sería el del socio al que se
hubiera escrito, y por eso usamos el campo "To" para filtrar el correo
entrante.
</para>

<para>
El carácter "!" en las recetas de procmail indica que el mensaje que
verifique las condiciones de esa receta en particular debe ser enviado
("forwardeado") al usuario indicado a continuación. Cuando el usuario reciba
el correo así mandado, la dirección de origen seguirá siendo la del que
envió el mensaje original, no la de quien hizo el forward.
</para>

<para>
Y no haría falta nada más. Gracias de nuevo a Esteve Sala por esta
contribución, que creo bastante interesante :-) No todo el mundo tendrá un
club para compartir entre sus socios una cuenta de correo, pero vale
perfectamente para un usuario normal que quiera dejar a su familia escribir
email, por ejemplo. Como siempre, hay multitud de usos interesantes para
esto.
</para>

</sect2>

</sect1>

<sect1>
<title>Referencias</title>

<para>

<itemizedlist>
<listitem>

<para>
 FAQ de sendmail: <ulink
url="http://www.his.com/~brad/sendmail/index.html"
>http://www.his.com/~brad/sendmail/index.html</ulink
>
</para>
</listitem>
<listitem>

<para>
Sendmail-mini-COMO, por Ignacio Llona : <ulink
url="http://www.infor.es/LuCAS/Otros/html/sendmail-minicomo/"
>http://www.infor.es/LuCAS/Otros/html/sendmail-minicomo/</ulink
>
</para>
</listitem>
<listitem>

<para>
Infovía-HOWTO, por Francisco José Montilla: <ulink
url="http://www.infor.es/LuCAS/COMO-INSFLUG/html/Infovia-Howto/Infovia-Howto"
>http://www.infor.es/LuCAS/COMO-INSFLUG/html/Infovia-Howto/Infovia-Howto</ulink
>
</para>
</listitem>
<listitem>

<para>
 Las páginas man de sendmail, fetchmail y procmail (que son 3:
procmail, procmailrc y procmailex) 
</para>
</listitem>

</itemizedlist>

</para>

</sect1>

</article>
