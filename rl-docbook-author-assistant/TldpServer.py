
##################################################################
# This file was generated by CherryPy-0.10-beta
# For more information about CherryPy, see http://www.cherrypy.org
##################################################################

# As a special exception, the CherryPy team gives unlimited permission to 
# copy, distribute and modify the CherryPy scripts that are the 
# output of CherryPy.  You need not follow the terms of the GNU 
# General Public License when using or distributing such scripts, even 
# though portions of the text of CherryPy appear in them.  The GNU 
# General Public License (GPL) does govern all other use of the 
# material that constitutes the CherryPy program. 
# 
# Certain portions of the CherryPy source text are designed to be 
# copied (in certain cases, depending on the input) into the output of 
# CherryPy.  We call these the "data" portions.  The rest of the 
# CherryPY source text consists of comments plus executable code that 
# decides which of the data portions to output in any given case.  We 
# call these comments and executable code the "non-data" portions. 
# CherryPy never copies any of the non-data portions into its output. 
# 
# This special exception to the GPL applies to versions of CherryPy 
# released by the CherryPy team.  When you make and distribute a modified 
# version of CherryPy, you may extend this special exception to the 
# GPL to apply to your modified version as well, *unless* your 
# modified version has the potential to copy into its output some of 
# the text that was the non-data portion of the version that you 
# started with.  (In other words, unless your change moves or copies 
# text from the non-data portions to the data portions.)  If your 
# modification has such potential, you must delete any notice of this 
# special exception to the GPL from your modified version. 


from tldpDoc import Documento, Processor4Suite
from Ft.Xml import InputSource
from TldpData import *
from itools.i18n import accept
import gettext
from gettext import gettext as _
from xml.sax.saxutils import escape
import tempfile, os
from cStringIO import StringIO
_debugFile='TldpServer.dbg'
configFileName='TldpServer.cfg'
_debug=0
_outputFile="TldpServer.py"
_outputFile="TldpServer.py"
_cacheMap={}
class Root:
    processorHtml = Processor4Suite()  #init xslt Processor, a customized Processor object
    processorXhtml = Processor4Suite('/usr/share/sgml/docbook/stylesheet/xsl/nwalsh/xhtml/docbook.xsl')
    processorFo = Processor4Suite('/usr/share/sgml/docbook/stylesheet/xsl/nwalsh/fo/docbook.xsl')
    language="en"
    def getPath(self):
        return request.base+"/root"
    def dame(self, campo):
        """ Devuelve el valor del campo (si existe)
        """
        return request.sessionMap.get(campo,"")
    def navBarX(self):
        model = """<div class="navhead">
            <table width="100%%" border="0" cellpadding="0" cellspacing="0" bgcolor="#606080" summary="Navigation">
            <tr>
            <td >%s</td>
            <td align="center" >%s</td>
            <td align="center" >%s</td>
            <td align="right" >%s</td>
            </tr>
            </table>
            </div>"""
        actualPage=request.sessionMap.get('actualPage', 0)
        prevText=_('Previous')
        if actualPage == 0:
            prev=prevText
        else:
            prev='<a href="previous">%s</a>' %  prevText
        nextText = _('Next')
        next=nextText
        clear=_('Clear Form')
        createXml=('Create docbook-xml')
        clearRef='''<input type="submit" value="%s" name="Clear" >''' % clear
        createXmlRef='''<input type="submit" value="%s" >'''  % createXml
        myValues = (prev, clearRef, createXmlRef , next)
        print myValues
        return  model % myValues
    def navBar1(self):
        model = """<div class="navhead">
            <table width="100%%" border="0" cellpadding="0" cellspacing="0" bgcolor="#606080" summary="Navigation">
            <tr>
            <td >%s</td>
            <td >%s</td>
            <td align="right" >%s</td>
            </tr>
            </table>
            </div>"""
        clear=_('Clear Form')
        createXml=('Create docbook-xml')
        clearRef='''<input type="submit" tabindex="2" value="%s" name="Clear" >''' % clear
        createXmlRef='''<input type="submit" tabindex="1"  value="%s" name="toXml">'''  % createXml
        uploadRef='''<input type="submit" value="%s" name="upload" >''' % _('Upload docbook-xml file')
        myValues = (clearRef, createXmlRef, uploadRef)
        return  model % myValues
    def navBar2(self):
        model = """<div class="navhead">
            <table width="100%%" border="0" cellpadding="0" cellspacing="0" bgcolor="#606080" summary="Navigation">
            <tr>
            <td >%s</td>
            <td >%s</td>
            <td >%s</td>
            <td align="right" >%s</td>
            </tr>
            </table>
            </div>"""
        cont='''<input type="button" value="%s" name="continue" onClick="history.go(-1)">''' % _('Continue editing')
        createHtml='''<input type="submit" value="%s" name="toHtml" >''' % _('Create Html')
        createXhtml='''<input type="submit" value="%s" name="toXhtml" >''' % _('Create Xhtml')
        createPdf='''<input type="submit" value="%s" name="toPdf" >''' % _('Create Pdf')
        myValues = (cont, createHtml, createXhtml, createPdf)
        return  model % myValues
    def index(self):
        newPage=self.modelPage(self.cuerpo(), self.navBar1())
        return newPage
    def modelPage(self, myBody="", navBar=""):
        actualPage=request.sessionMap.get('actualPage', 0) # don't use
        doc = """<html><head><title>%s</title></head><body>""" % (_("Docbook Author Assistant"))
        form="""<FORM NAME="theLinuxDocform" action="creaDoc" method="POST"> """
        endForm="""</FORM>"""
        return doc + self.mainHeader(self.language)+ '<br/>'+ form+ navBar+'<br/>' +myBody + '<br/>'+ navBar+'<br/>'+endForm+self.footer()
    def mainHeader(self,lang):
        """ i18n function. change the base language with itools
        """
        formato="""<div class="header">
        <center>
        <h1>%s</h1>
        %s&nbsp;&nbsp;
        %s&nbsp;&nbsp;
        %s
        </center>
        """
        titulo=_("The Linux Documentation Project HOWTO Generator")
        about=_('About')
        aboutRef='<a href="about">%s</a>' % about
        return formato % (titulo, 'Español', 'English', aboutRef)
    def footer(self):
        pie = """
        <div class="footer">
        <center>
        <a href="http://www.python.org"><img src="%s" border=0></a>&nbsp;&nbsp
        <a href="http://www.cherrypy.org"><img src="%s" border=0></a>&nbsp&nbsp
        <a href="http://www.4suite.org"><img src="%s" border=0></a>
        </center>
        </div>""" % (request.base+'/static/PythonPoweredSmall.gif', request.base+'/static/poweredByCherryPy.gif',request.base+'/static/4Suite-org.png')
        return pie
    def about(self):
        """Very provisional description of the tool"""
        textAbout="""<p>[only spanish]</p><h3>Programa generador de esqueletos de howtos</h3>.
        <small><font color=gray>Copyright &copy; 2003,2004 by Luis Miguel Morillas
        <!-- Comments and questions to <a href="mailto:morillas@unizar.es"><font color=gray>morillas@unizar.es</font></a>-->
        </font></small>
        <br/>Genera howtos en formato docbook-xml y permiten convertirlos a html, xhtml y pdf.<br>
        Desarrollado por Luis Miguel Morillas a partir de un script de Stein Gjoen<br>
        <br><br>
        La versión original de Stein Gjoen se encuentra en <a href="http://www.nyx.net/~sgjoen/The_LDP_HOWTO_Generator.html">http://www.nyx.net/~sgjoen/The_LDP_HOWTO_Generator.html</a>
        <br><br>
        Versión: 0.05 1-marzo-2004
        <br><br>
        Licencia: Úsalo sin restricciones.
        <br><br>
        Sin garantías.
        <br><br>
        <h3>Características</h3>
        Servidor: <a href="http://www.python.org">python</a> y <a href="http://www.cherrypy.org">cherrypy</a> <br>
        Procesado de xml/xsl <a href="http://www.4suite.org">4Suite libs.</a><br>
        Hojas de estilo xsl (html/xhtml/fo) <a href="http://docbook.sourceforge.net/projects/xsl/">Docbook</a><br>
        <br>
        Aquí puedes descargar el código:<i>
        <br>cvs -d :pserver:anoncvs@cvs.hispalinux.es:/cvs/lucas login
        <br>[password: anoncvs]
        <br>cvs -d :pserver:anoncvs@cvs.hispalinux.es:/cvs/lucas co rl-docbook-author-assistant</i>
        <br>
        Envía tus comentarios y sugerencias a <a href="mailto:luismiguel.morillas@hispalinux.es">Luis Miguel Morillas</a>
        o a <a href="mailto:lucas-desarrollo@listas.hispalinux.es"> Lista de lucas-desarrollo</a>
        Puedes colaborar añadiendo comentarios en el <a href="http://155.210.19.185:8080/ccia/nodes/2004-03-04/howtoGen">wiki </a>
        <br><br>
        [Por Hacer]
        <br>
        * Refinar creación de docbook-xml<br>
        <br>
        * Traducción del programa
        <br>
        * Mucho más
        <br>
        """
        newPage=self.modelPage(textAbout)
        return newPage
    def uploadFile(self):
        form = """<div class="formUpload"> <form method=post action=postFile enctype="multipart/form-data">
            <center>
            <h3>Select the docbook-xml file to upload</h3>
            <br/>
            File:&nbsp;&nbsp;<input type=file name=xmlfile><br>
            <br>
            <input type=submit value="Upload">
            </center>
        </form>
        </div>"""
        return self.mainHeader(self.language)+ '<br/>'+ form + '<br/>' +self.footer()
    def postFile(self, xmlfile):
        print type(xmlfile)
        request.sessionMap['docXml']=xmlfile
        docXml="""<table> <tr><td><pre>\n%s
                </pre></td></tr></table>""" % escape(request.sessionMap['docXml'])
        return self.modelPage(docXml, self.navBar2())
    def creaDoc(self, **kw):
        """
        creaDoc(diccionario)
        Devuelve una página html con el documento generado a partir de los datos
        recogidos del formulario. Utiliza variable formulario.
        """
        if kw.has_key('Clear'): # Hay que borrar todo. Clear Form
            for k in kw.keys():
                if request.sessionMap.has_key(k):
                    del(request.sessionMap[k])
            return self.index()
        elif kw.has_key('toXml'):
            doc=Documento(kw)
            request.sessionMap['docXml']=doc.imprimir() #save docXml
            docXml="""<table> <tr><td><pre>\n%s
                </pre></td></tr></table>""" % escape(request.sessionMap['docXml'])
            return self.modelPage(docXml, self.navBar2())
        elif kw.has_key('upload'):
            return self.uploadFile()
        elif kw.has_key('toHtml'):
            docXml = InputSource.DefaultFactory.fromString(request.sessionMap['docXml'], "file:///")
            return self.processorHtml.run(docXml)
        elif kw.has_key('toXhtml'):
            docXml = InputSource.DefaultFactory.fromString(request.sessionMap['docXml'], "file:///")
            response.headerMap['content-type'] = "application/xhtml+xml"
            return self.processorXhtml.run(docXml)
        elif kw.has_key('toPdf'):
            docXml = InputSource.DefaultFactory.fromString(request.sessionMap['docXml'], "file:///")
            nomFich=tempfile.mktemp()
            f=open(nomFich+'.fo', 'w')
            f.write(self.processorFo.run(docXml))
            f.close()
            os.system('fop  %s %s' % (nomFich+'.fo', nomFich+'.pdf'))
            if os.path.exists(nomFich+'.pdf'):
                response.headerMap['content-disposition'] ="filename=tldpHowto.pdf"
                response.headerMap['content-type'] = "application/pdf"
                return open(nomFich +'.pdf').read()
            else:
                print "somethin is wrong. user will see an error, because i don't return a string"
    def cuerpo(self, datos=""):
        _page=[]
        _page.append("""<div align="Right">""")
        _page.append(str('Version 0.05  ' + fechaVersion()))
        _page.append("""</div>
      Welcome to the LDP HOWTO Generator. By following through this form
you will be able to generate the skeleton of your new HOWTO, customised
to your particular needs. Examples of markup used can be found in the
<a href="http://www.nyx.net/~sgjoen/template.sgml">HOWTO Template SGML source</a>
along with the resulting
<a href="http://www.nyx.net/~sgjoen/template.html">HOWTO Template HTML output</a>.
<p>
<!-- Note: This Generator requires JavaScript.<br>
Note: Currently this is only a mock-up, only limited functionality is
implemented yet, nor is functionality fully tested.
Please read the <a href="http://www.nyx.net/~sgjoen/home.html">home page</a> for updates. -->
<!-- <FORM NAME="theHOWTOform" action="creaDoc" method="POST">-->
<h2>Heading Definition</h2>
All HOWTOs have to have a number of fields defined in order to be usable
by others and also to be easily maintained. The following fields are therefore
mandatory:<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
   <tbody>
     <tr>
       <td valign="Top">Title<br>
       </td>
       <td valign="Top" bgcolor="#606080"><input type="text" name="TITLE" size="72"  value=\"""")
        _page.append(str(self.dame('TITLE')))
        _page.append("""\"><br>
       </td>
       <td valign="Top">This will be the title of your HOWTO. For practical
   reasons it should not be more than one line (72 characters) long, preferrably less.
   It is important to be precise as well as concise.<br>
       </td>
     </tr>
     <tr>
       <td valign="Top">Author<br>
       </td>
       <td valign="Top" bgcolor="#606080" style="color: rgb(255, 255, 255);">Name:&nbsp;<input type="text" name="FIRSTNAME" size="20">
   Surname: <input type="text" name="SURNAME" size="30"> <br>
       </td>
       <td valign="Top">Your name(s)<br>
       </td>
     </tr>
     <tr>
       <td valign="Top">Email<br>
       </td>
       <td valign="Top" bgcolor="#606080"><input type="text" name="EMAIL" size="40"><br>
       </td>
       <td valign="Top">The email address you wish to be contacted at. HOWTOs
are long lived documents, make sure your email address is equally durable.
If needed the Linux Documentation Project can provide an email address,
inquire for more information.<br>
       </td>
    </tr>
    <tr>
       <td valign="Top">Version<br>
       </td>
       <td valign="Top" bgcolor="#606080"><input type="text" name="VERSION" value="V0.01"><br>
       </td>
       <td valign="Top">Input a version number and date, for
instance "<font size="+1"><tt>V0.01</tt></font>". Version number is free format.<br>
    </td>
    </tr>
    <tr>
       <td valign="Top">Date<br>
       </td>
       <td valign="Top" bgcolor="#606080"><input type="text" name="DATE"
   value=\"""")
        _page.append(str(hoy()))
        _page.append("""\"><br>
       </td>
       <td valign="Top">Input a date, for instance "<font size="+1"><tt>2000-05-11</tt></font>".
Recommended date format is ISO standard for dates:"<font size="+1"><tt>YYYY-MM-DD</tt></font>".<br>
</td>
     </tr>
<!-- Aquí incluyo el resto del formulario original de Stein Gjoen-->
""")
        _page.append("""<!-- original page of Stein Gjoen at encuentra en http://www.nyx.net/~sgjoen/The_LDP_HOWTO_Generator.html 
Without javascript code.
-->
<trs>
<td valign="Top">Primary Category<br>
</td>
<td valign="Top" bgcolor="#606080">
<select name="PRIMARYCATEGORY">
<option>1. {The Linux OS}
<option>1.1. {Getting Started}
<option>1.2. {Switching from Other Operating Systems}
<option>1.3. {Distributions}
<option>1.4. {Installation}
<option>1.5. {Kernel}
<option>1.6. {Boot Loaders and Booting the OS}
<option>1.7. {Parallel Processing}
<option>1.8. {Partitions and Filesystems}
<option>1.9. {RAID}
<option>1.10. {Printing}
<option>1.11. {Shell}
<option>1.12. {Using Linux}
<option>2. {System Administration and Configuration}
<option>2.1. {Configuration / Installation}
<option>2.2. {Benchmarking}
<option>2.3. {Clustering}
<option>2.4. {Backup}
<option>2.5. {Recovery}
<option>2.6. {Security}
<option>3. {Hardware}
<option>3.1. {General}
<option>3.2. {Platforms}
<option>3.3. {Video Cards}
<option>3.4. {CPUs / Architectures}
<option>3.5. {CD-ROM / DVD-ROM Drives}
<option>3.6. {Optical Disks}
<option>3.7. {Keyboard and Console}
<option>3.8. {Digital Cameras}
<option>3.9. {Graphic Tablets}
<option>3.10. {Diskettes}
<option>3.11. {Hard Disks}
<option>3.12. {Jaz and ZIP Drives}
<option>3.13. {Mice}
<option>3.14. {Modems}
<option>3.15. {Routers}
<option>3.16. {SCSI}
<option>3.17. {Serial Ports}
<option>3.18. {Sound Cards}
<option>3.19. {Tape Drives}
<option>3.20. {Touchscreens}
<option>3.21. {UPS}
<option>3.22. {Wireless}
<option>3.23. {Miscellaneous}
<option>4. {Networking}
<option>4.1. {General}
<option>4.2. {Protocols}
<option>4.3. {Dial-up}
<option>4.4. {DNS}
<option>4.5. {Virtual Private Networks}
<option>4.6. {Bridging}
<option>4.7. {Routing}
<option>4.8. {Security}
<option>4.9. {Telephony / Satellite}
<option>4.10. {Miscellaneous}
<option>5. {Applications / GUI / Multimedia}
<option>5.1. {Installing Applications}
<option>5.2. {User Applications}
<option>5.3. {Server Applications}
<option>5.3.1. {DBMS / Databases}
<option>5.3.2. {Mail}
<option>5.3.3. {Usenet Network News}
<option>5.3.4. {HTTP / FTP}
<option>5.3.5. {Miscellaneous}
<option>5.4. {GUI / Window Managers}
<option>5.4.1. {X Window System}
<option>5.4.2. {Window Managers}
<option>5.4.3. {Fonts}
<option>5.5. {Multimedia}
<option>5.5.1. {Audio}
<option>5.5.2. {Video}
<option>6. {Programming}
<option>6.1. {General}
<option>6.2. {Compilers}
<option>6.3. {Languages}
<option>6.4. {Libraries}
<option>6.5. {Interfaces / API / Protocols}
<option>6.6. {Security}
<option>6.7. {Tools}
<option>6.8. {Version Control}
<option>6.9. {DBMS / Databases}
<option>6.10. {Miscellaneous}
<option>7. {Other (human) Languages}
<option>7.1. {Language Support}
<option>7.2. {Using Specific Languages}
<option>8. {Miscellaneous}
<option>8.1. {Authoring / Documentation}
<option>8.2. {Linux Advocacy / Getting (and Staying) Involved}
<option>8.3. {Hobbies and Special Interests}
<option>X No Fit
</select>
<br>
       </td>
       <td valign="Top">Chose the category that best fits your HOWTO. This will be used in
categorising and in generating lists of HOWTOs. If no category fits chose the last
category which is <i>No Fit</i> and someone will help you.<br>
       </td>
     </tr>


     <tr>
       <td valign="Top">Keywords<br>
       </td>
       <td valign="Top" bgcolor="#606080"><input type="text" name="KEYWORDS" size="72"><br>
       </td>
       <td valign="Top">A string of comma separated keywords that will aid
search engines in locating your document.<br>
       </td>
     </tr>
     <tr>
       <td valign="Top">Index<br>
       </td>
       <td valign="Top" bgcolor="#606080"><input type="text" name="INDEX"><br>
       </td>
       <td valign="Top">A single word used in creating indices. Use a word
as descriptive of your HOWTO as possible. This word can also be the file
name of the saved contents of this Generator.<br>
       </td>
     </tr>

     <tr>
       <td valign="Top">Oneliner<br>
       </td>
       <td valign="Top" bgcolor="#606080"><input type="text" name="ONELINER" size="72"><br>
       </td>
       <td valign="Top">A single line used for brief description in indices. Be
as descriptive of your HOWTO as possible.<br>
       </td>
     </tr>

  </tbody> 
</table>
 <br>
 
<h2>Abstract</h2>
      All HOWTOs have an abstract, a single, brief paragraph that should
tell your readers what this HOWTO is going to be about. Avoid using linebreaks.<br>
 <textarea name="ABSTRACT" rows="4" cols="72"></textarea><br>
 <br>

<hr width="100%" size="2"><br>
 <br>

<h2>HOWTO Body</h2>
      Having defined the heading the time has come to the main body of the
HOWTO. It is divided into sections and sub sections but here we will only
do sections and just a few sub sections. This will give you the pattern
to flesh out the rest of the document. Suggested titles are in editable
boxes where appropriate, entire sections can be removed if you feel they
are not needed for your topic.<br>
<br>
      Do keep in mind that this is just a quick start template based system 
that suggests a few more or less common conventions; this should not be 
regarded as a straightjacket.<br>
 <br>

<h2>1. Introduction</h2>
      As the title suggests, an introduction. Expand on the abstract, give
the background, be creative.<br>
 <textarea name="INTRO" rows="4" cols="72"></textarea><br>
 <br>

<h2>1.1 Copyright</h2>
     All documents are copyrighted and it is up to the author to determine
how their documents are to be distributed. For the LDP to be able to distribute 
your document as part of the body of works that it contains it is necessary 
that the copyrights allow this by being one of the free copyrights of which 
there is a few to chose from. Additionally you can roll your own but to 
be effective you have to know how copyright laws work.<p>
An overview of several copyright licenses for documentation as well as software
can be found at <a href="http://www.gnu.org">GNU</a>.
<br>

<table cellpadding="2" cellspacing="2" border="1" width="100%">
   <tbody>
     <tr>
       <td valign="Top"><input type="radio" name="COPYRIGHT" value="GFDL" checked="checked">
     GFDL<br>
       </td>
       <td valign="Top">       
      <h3>GNU Free Documentation Licence</h3>
This is the license recommended by GNU for documentation.<br>
       <br>
      <blockquote>This document is Copyright &copy; &lt;date&gt;&lt;name&gt;. 
Permission is granted to copy, distribute and/or modify this document under 
the terms of the GNU Free Documentation License, Version 1.1 or any later 
version published by the Free Software Foundation with no Invariant Sections, 
no Front-Cover Texts, and no Back-Cover Texts.<br>
         </blockquote>
         <br>
         </td>
       </tr>
       <tr>
         <td valign="Top"><input type="radio" name="COPYRIGHT" value="OPDL">
     OPDL<br>
         </td>
         <td valign="Top">         
        <h3>Open Documentation License</h3>
This is an alternative license used for documentation.<br>
         <br>
      <blockquote>This document is Copyright &copy; &lt;date&gt;&lt;name&gt;. 
This material may be distributed only subject to the terms and conditions
set forth in the Open Publication License, vX.Y or later
(the latest version is presently available at
<a href="http://www.opencontent.org/openpub/">OpenContent</a>).<br>
         </blockquote>
         <br>
         </td>
       </tr>
       <tr>
         <td valign="Top"><input type="radio" name="COPYRIGHT" value="OTHER">
     Other<br>
         </td>
         <td valign="Top">         
        <h3>Rolling your own</h3>
         <br>
         <textarea name="COPYRIGHTother" rows="4" cols="72"></textarea><br>
         <br>
         </td>
       </tr>
     
    </tbody>   
  </table>
   <br>
   <br>
   
  <h2>1.2 Disclaimer</h2>
     We live in the age of lawyers, a disclaimer can save you legal problems, 
court cases and bankrupcy. This is not a joke. As always there is number 
of choices:<br>
   
  <table cellpadding="2" cellspacing="2" border="1" width="100%">
     <tbody>
       <tr>
         <td valign="Top"><input type="radio" name="DISCLAIMER" value="SIMPLE" checked="checked">
     Simple<br>
         </td>
         <td valign="Top">         
        <h3>Simple Disclaimer</h3>
      This is one used a number of places.<br>
         <br>
         
        <blockquote>Use the information in this document at your own risk. 
I disavow any potential liability for the contents of this document. Use 
of the concepts, examples, and/or other content of this document is entirely 
at your own risk.<br>
           <br>
     All copyrights are owned by their owners, unless specifically noted
otherwise. Use of a term in this document should not be regarded as affecting
the validity of any trademark or service mark.<br>
           <br>
     Naming of particular products or brands should not be seen as endorsements.<br>
           <br>
     You are strongly recommended to take a backup of your system before
major installation and backups at regular intervals.<br>
           </blockquote>
           <br>
           </td>
         </tr>
         <tr>
           <td valign="Top"><input type="radio" name="DISCLAIMER" value="NONE">
     None<br>
           </td>
           <td valign="Top">           
          <h3>None</h3>
     If you feel you need no disclaimers you can check this box.<br>
           <br>
           </td>
         </tr>
         <tr>
           <td valign="Top"><input type="radio" name="DISCLAIMER" value="OTHER">
     Other<br>
           </td>
           <td valign="Top">           
          <h3>Rolling your own</h3>
           <br>
           <textarea name="DISCLAIMERother" rows="4" cols="72"></textarea><br>
           <br>
           </td>
         </tr>
       
      </tbody>     
    </table>
     <br>
     <br>


<hr width="40%">
We are now finished with the fixed formats header and are
ready to fill in the main contents of this HOWTO.
Each chapter below has a title as well as a small text field with the
title repeated. If you are not satisfied with the proposed title you
can change it in the small single line text box, making it the title
of your own HOWTO.
<p>
Furthermore if you do not need the chapter at all you can remove it
by unchecking the checkbox at the right edge which removes the chapter
by commenting it out.
<p>
You can also change the level of a chapter from section to subsection
or subsubsection. Note that the next few introductory chapters are
given a default setting of subsection while the rest are given a
default value of section.
<hr width="40%">



    <h2>1.3 News</h2>
<input type="text" name="NEWSTITLE" value="News" size="50">
Chapter type: <input type="radio" name="NEWSLEVEL" value="0">Section  <input type="radio" name="NEWSLEVEL" value="1" checked="checked">Subsection  <input type="radio" name="NEWSLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLENEWS" CHECKED>Enable this chapter<br></div>

   This is where you make a summary of news and recent updates to your document.
For a new document this isn't expected to be much. When a HOWTO exceeds 20
pages it takes more than a casual read to find the updates. This is where
you help your readers with that, alerting them to specific and important
news. A pointer to where to get the latest version would also be useful.
Many authors keep the letest version on their own home pages too.<br>
     <br>
     <textarea name="NEWS" rows="4" cols="72"></textarea><br>
     <br>
     
    <h2>1.4 Credits</h2>
<input type="text" name="CREDITSTITLE" value="Credits" size="50">
Chapter type: <input type="radio" name="CREDITSLEVEL" value="0">Section  <input type="radio" name="CREDITSLEVEL" value="1" checked="checked">Subsection  <input type="radio" name="CREDITSLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLECREDITS" CHECKED>Enable this chapter<br></div>

   It is always nice to acknowledge people who help you with inputs, it
is also regarded by many as important in the Linux world new economy. Example:<br>
     <br>
     
    <blockquote>In this version I have the pleasure of acknowledging<br>
       <br>
    corff (at) ZEDAT.FU-Berlin.DE<br>
    dwood (at) plugged.net.au<br>
    lcl (at) spiretech.com<br>
    kgh12351 (at) nifty.ne.jp<br>
    dave (at) lafn.org<br>
    name (at) site.org<br>
       <br>
    Also <i>Somecompany</i> is acknowledged for sending me documentation
on their gizmos as well as permission to quote from the material. These
quotes have been approved before appearing here and will be clearly labelled.<br>
       </blockquote>
    Scramble the addresses so email harvesters cannot get addresses from
your HOWTO and then spam people. That has happened in the past.<br>
       <textarea name="CREDITS" rows="4" cols="72"></textarea><br>
       <br>
       
      <h2>1.5 Translations</h2>
<input type="text" name="TRANSLATIONSTITLE" value="Translations" size="50">
Chapter type: <input type="radio" name="TRANSLATIONSLEVEL" value="0">Section  <input type="radio" name="TRANSLATIONSLEVEL" value="1" checked="checked">Subsection  <input type="radio" name="TRANSLATIONSLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLETRANSLATIONS" CHECKED>Enable this chapter<br></div>

   Not everyone speaks English, pointers to translations are nice. Also your
translators tend to give very important inputs. Example:<br>
       <br>
       
      <blockquote>German Translation by someone (at) somewhere.de<br>
    Swedish Translation by someone (at) somewhere.se<br>
    French Translation by someone (at) somewhere.fr<br>
    Chinese Translation by someone (at) somewhere.cn<br>
    Italian Translation by someone (at) somewhere.it<br>
         <br>
         </blockquote>
         <textarea name="TRANSLATIONS" rows="4" cols="72"></textarea><br>
         <br>
   When manually editing the HOWTO afterwards, you are recommended to insert
hyperlinks to respective translations.<br>
         <br>


        <h2>2. Structure</h2>
<input type="text" name="STRUCTURETITLE" value="Structure" size="50">
Chapter type: <input type="radio" name="STRUCTURELEVEL" value="0" checked="checked">Section  <input type="radio" name="STRUCTURELEVEL" value="1">Subsection  <input type="radio" name="STRUCTURELEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLESTRUCTURE" CHECKED>Enable this chapter<br></div>

   A quick overview on how all parts fit together in the structure. Here
I use an example from my Multi Disk HOWTO.<br>
         <br>

        <blockquote>As this type of document is supposed to be as much for
learning as a technical reference document I have rearranged the structure
to this end. For the designer of a system it is more useful to have the
information presented in terms of the goals of this exercise than from the
point of view of the logical layer structure of the devices themselves.
Nevertheless this document would not be complete without such a layer structure
the computer field is so full of, so I will include it here as an introduction
to how it works.<br>
           <br>
           </blockquote>
           <textarea name="STRUCTURE" rows="4" cols="72"></textarea><br>
           <br>
           <br>

          <h2>3. Technologies</h2>
<input type="text" name="TECHNOTITLE" value="Technologies" size="50">
Chapter type: <input type="radio" name="TECHNOLEVEL" value="0" checked="checked">Section  <input type="radio" name="TECHNOLEVEL" value="1">Subsection  <input type="radio" name="TECHNOLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLETECHNO" CHECKED>Enable this chapter<br></div>

Introduction of technology for the newbie with a few references to detailled
works. Remember that not everyone has Internet access so you have to explain
in sufficient details so even the newbie can get by.<br>
           <textarea name="TECHNO" rows="4" cols="72"></textarea><br>

          <h2>4. Implementation</h2>
<input type="text" name="IMPLTITLE" value="Implementation" size="50">
Chapter type: <input type="radio" name="IMPLLEVEL" value="0" checked="checked">Section  <input type="radio" name="IMPLLEVEL" value="1">Subsection  <input type="radio" name="IMPLLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLEIMPL" CHECKED>Enable this chapter<br></div>

Now your readers should have a sufficient knowledge of what this is about
and now we come to the hands on of implementing your clever scheme.<br>
           <textarea name="IMPL" rows="4" cols="72"></textarea><br>

          <h2>5. Maintenance</h2>
<input type="text" name="MAINTTITLE" value="Maintenance" size="50">
Chapter type: <input type="radio" name="MAINTLEVEL" value="0" checked="checked">Section  <input type="radio" name="MAINTLEVEL" value="1">Subsection  <input type="radio" name="MAINTLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLEMAINT" CHECKED>Enable this chapter<br></div>

Few systems and designs are maintenance free, here you explain how to keep
the system running.<br>
           <textarea name="MAINT" rows="4" cols="72"></textarea><br>
           <br>

          <h2>6. Advanced Issues</h2>
<input type="text" name="ADVISSTITLE" value="Advanced Issues" size="50">
Chapter type: <input type="radio" name="ADVISSLEVEL" value="0" checked="checked">Section  <input type="radio" name="ADVISSLEVEL" value="1">Subsection  <input type="radio" name="ADVISSLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLEADVISS" CHECKED>Enable this chapter<br></div>

You can get most things up and running in a quick and dirty fashion, useful
for testing and getting used to how things work. For more serious use you
would need to be a little more advanced. This is the place to explain it
all, if applicable.<br>
           <textarea name="ADVISS" rows="4" cols="72"></textarea><br>

          <h2>7. Troubleshooting</h2>
<input type="text" name="TROUBLESHTITLE" value="Troubleshooting" size="50">
Chapter type: <input type="radio" name="TROUBLESHLEVEL" value="0" checked="checked">Section  <input type="radio" name="TROUBLESHLEVEL" value="1">Subsection  <input type="radio" name="TROUBLESHLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLETROUBLESH" CHECKED>Enable this chapter<br></div>

Many problems can be solved by a simple structured approach, analysing the
symptoms, finding the cause and determining the solution.<br>
           <textarea name="TROUBLESH" rows="4" cols="72"></textarea><br>
           <br>

          <h2>8. Further Information</h2>
<input type="text" name="FURTHERTITLE" value="Further Information" size="50">
Chapter type: <input type="radio" name="FURTHERLEVEL" value="0" checked="checked">Section  <input type="radio" name="FURTHERLEVEL" value="1">Subsection  <input type="radio" name="FURTHERLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLEFURTHER" CHECKED>Enable this chapter<br></div>

A HOWTO cannot describe everything, some times the user has to venture out
on the net to get more information or just updates. Here is the place to
tell where and how. Some suggestions are:<br>

          <ul>
             <li>Usenet Newsgroups and related FAQs where appropriate</li>
             <li>Mailing lists</li>
             <li>Other HOWTOs and man pages</li>
             <li>Local resources, files on disks that can be used as examples</li>
             <li>Web pages<br>
             </li>

          </ul>
           <br>
           <textarea name="FURTHER" rows="4" cols="72"></textarea><br>
           <br>

          <h2>9. Getting Help</h2>
<input type="text" name="GETHELPTITLE" value="Getting Help" size="50">
Chapter type: <input type="radio" name="GETHELPLEVEL" value="0" checked="checked">Section  <input type="radio" name="GETHELPLEVEL" value="1">Subsection  <input type="radio" name="GETHELPLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLEGETHELP" CHECKED>Enable this chapter<br></div>

Your reader might still end up in a situation where extra help is needed
from someone else, perhaps on the net. In order to get fast and efficient
help it is best first to get some details on your system. What details matter
depends on type of problem. For disk problems you need to know the disk
controllers etc, for networking problems you have to know what ethernet
card is used and version of drivers etc. Here is the place to suggest what
details to have ready when asking for help.<br>
           <textarea name="GETHELP" rows="4" cols="72"></textarea><br>
           <br>

          <h2>10. Concluding Remarks</h2>
<input type="text" name="CONCLUDETITLE" value="Concluding Remarks" size="50">
Chapter type: <input type="radio" name="CONCLUDELEVEL" value="0" checked="checked">Section  <input type="radio" name="CONCLUDELEVEL" value="1">Subsection  <input type="radio" name="CONCLUDELEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLECONCLUDE" CHECKED>Enable this chapter<br></div>

Just summing up... Also a place for general recommendations.<br>
           <textarea name="CONCLUDE" rows="4" cols="72"></textarea><br>
           <br>

          <h2>11. Questions and Answers</h2>
<input type="text" name="QNATITLE" value="Questions and Answers" size="50">
Chapter type: <input type="radio" name="QNALEVEL" value="0" checked="checked">Section  <input type="radio" name="QNALEVEL" value="1">Subsection  <input type="radio" name="QNALEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLEQNA" CHECKED>Enable this chapter<br></div>

           <br>
Check the newsgroups and try to determine some frequent problems and cover
them here. Again an example from my HOWTO:<br>
           <br>

          <blockquote>This is just a collection of what I believe are the
most common questions people might have. Give me more feedback and I will
turn this section into a proper FAQ.<br>
             <br>
  Q:How many physical disk drives (spindles) does a Linux system need?<br>
             <br>
  A: Linux can run just fine on one drive (spindle). Having enough RAM (around
32 MB, and up to 64 MB) to support swapping is a better price/performance
choice than getting a second disk. (E)IDE disk is usually cheaper (but a
little slower) than SCSI.<br>
             <br>
             </blockquote>
             <textarea name="QNA" rows="4" cols="72"></textarea><br>
             <br>

            <h2>12. Bits and Pieces</h2>
<input type="text" name="BITSNPIECESTITLE" value="Bits and Pieces" size="50">
Chapter type: <input type="radio" name="BITSNPIECESLEVEL" value="0" checked="checked">Section  <input type="radio" name="BITSNPIECESLEVEL" value="1">Subsection  <input type="radio" name="BITSNPIECESLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLEBITSNPIECES" CHECKED>Enable this chapter<br></div>

This is basically a section where I stuff all the bits I have not yet decided
where should go, yet that I feel is worth knowing about. It is a kind of
transient area.<br>
             <textarea name="BITSNPIECES" rows="4" cols="72"></textarea><br>

            <h2>13. Examples</h2>
<input type="text" name="EXAMPLESTITLE" value="Examples" size="50">
Chapter type: <input type="radio" name="EXAMPLESLEVEL" value="0" checked="checked">Section  <input type="radio" name="EXAMPLESLEVEL" value="1">Subsection  <input type="radio" name="EXAMPLESLEVEL" value="2">Subsubsection
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLEEXAMPLES" CHECKED>Enable this chapter<br></div>

Example designs and sample configuration files and other relevant details
is always handy. Keep large samples at the end to avoid breaking the flow
of the HOWTO reading. Small samples are useful within the main body of the
HOWTO.<br>
             <textarea name="EXAMPLES" rows="4" cols="72"></textarea><br>
             <br>
             <br>
<!--
            <h2>14. Test</h2>
<input type="text" name="TESTTITLE" value="Test" size="50">
Chapter type: <input type="radio" name="TESTLEVEL" value="0" checked="checked">Section  <input type="radio" name="TESTLEVEL" value="1">Subsection  <input type="radio" name="TESTLEVEL" value="2">Subsubsection 
<div align="Right"><INPUT TYPE="checkbox" VALUE="Enable" NAME="ENABLETEST" CHECKED>Enable this chapter<br></div>

This tests alternative generation style.<br>
             <textarea name="TEST" rows="4" cols="72"></textarea><br>
             <br>
-->

            <hr width="100%" size="3"><br>
            <h2>Finish</h2>
You are now ready to convert your epic HOWTO into an SGML file. The entries
in the boxes above will be compiled when pressing the compile button below
and the resulting SGML code will be outputted to the text box below that
button.
<p>
When you start the compilation the status field of your browser tracks where
in the compilation process you are. On a 1GHz Pentium it should take about
a second. When finished the status bar should display the string
<b><tt>LinuxDoc SGML Compilation Done</tt></b>. If the process hangs and does not
finish, please <a href="mailto:sgjoen@mail.nyx.net">contact the author</a>
with as much information as possible, preferrably with the information in
the JavaScript Console if available.
<p>
Your next step then will be to copy the entire content of that box
and paste it into a text editor and save the contents to a file. Filename
is suggested to be the Index word you filled in at the top of this form.<br>
            <br>




""")
        _page.append("""
<!-- Resto del formulario: llamada a mi función sin los script javascript -->
<br/>
""")
        return "".join(_page)

import string, time, urllib, sys, getopt, cgi, socket, os, ConfigParser, cStringIO, binascii, md5

_lastCacheFlushTime=time.time()

def debug(debugStr):
    if _debug:
        f=open(_debugFile, 'a')
        f.write(debugStr+'\n')
        f.close

def printUsageAndExit():
    print "Usage: server [-C configFile]"
    sys.exit(-1)

def mainInit(argv):
    global configFile, configFileName
    if not globals().has_key('hotReload'):
        if not (len(argv)==1 or (len(argv)==3 and argv[1]=="-C")): printUsageAndExit()
        if len(argv)==3: configFileName=argv[2]

    configFile=ConfigParser.ConfigParser()
    configFile.read(configFileName)
    if not globals().has_key('hotReload'):
        
        
        
        global _logToScreen, _logFile, _socketHost, _socketPort, _socketFile, _reverseDNS, _socketQueueSize
        global _processPool, _threading, _forking, _threadPool, _sslKeyFile, _sslCertificateFile
        global _typeOfRequests, _staticContentList, _flushCacheDelay, _sessionStorageType
        global _sessionTimeout, _sessionCookieName, _sessionStorageFileDir
        _logToScreen=1 # Should logs be output to screen or not
        _logFile="" # Default log file
        
        _socketHost=''
        _socketPort=0
        _socketFile='' # Used if server should listen on AF_UNIX socket
        _reverseDNS=0
        _socketQueueSize=5 # Size of the socket queue
        
        _processPool=1 # Used if we want to fork n processes at the beginning. In this case, all processes will listen on the same socket (this only works on unix)
        _threading=0 # Used if we want to create a new thread for each request
        _forking=0 # Used if we want to create a new process for each request
        _threadPool=1 # Used if we want to create a pool of threads at the beginning
        
        _sslKeyFile=""
        _sslCertificateFile=""
        
        _typeOfRequests=('web', )
        
        _staticContentList=[]
        
        _flushCacheDelay=0
        
        _sessionStorageType=""
        _sessionTimeout=60 # In minutes
        _sessionCookieName="CherryPySession"
        _sessionStorageFileDir=""
        
        try: _logToScreen=int(configFile.get('server', 'logToScreen'))
        except: pass
        try: _logFile=configFile.get('server', 'logFile')
        except: pass
        try: _socketHost=configFile.get('server', 'socketHost')
        except: pass
        try: _socketPort=int(configFile.get('server', 'socketPort'))
        except:pass
        try: _socketFile=configFile.get('server', 'socketFile')
        except: pass
        try: _reverseDNS=configFile.get('server', 'reverseDNS')
        except: pass
        try: _socketQueueSize=int(configFile.get('server', 'socketQueueSize'))
        except: pass
        try: _processPool=int(configFile.get('server', 'processPool'))
        except: pass
        try: _threadPool=int(configFile.get('server', 'threadPool'))
        except: pass
        try: _threading=int(configFile.get('server', 'threading'))
        except: pass
        try: _forking=int(configFile.get('server', 'forking'))
        except: pass
        try: _sslKeyFile=configFile.get('server', 'sslKeyFile')
        except: pass
        try: _sslCertificateFile=configFile.get('server', 'sslCertificateFile')
        except: pass
        try: _typeOfRequests=configFile.get('server', 'typeOfRequests').split(',')
        except: pass
        try: _sessionStorageType=configFile.get('session', 'storageType')
        except: pass
        try: _sessionTimeout=int(configFile.get('session', 'timeout'))
        except: pass
        try: _sessionCookieName=configFile.get('session', 'cookieName')
        except: pass
        try: _sessionStorageFileDir=configFile.get('session', 'storageFileDir')
        except: pass
        try:
            staticDirList=configFile.options('staticContent')
            for staticDir in staticDirList:
                staticDirTarget=configFile.get('staticContent', staticDir)
                _staticContentList.append((staticDir, staticDirTarget))
        except: pass
        try: _flushCacheDelay=float(configFile.get('cache', 'flushCacheDelay'))
        except: pass
        
        logMessage("Reading parameters from %s ..."%configFileName)
        logMessage("Server parameters:")
        logMessage("  logToScreen: %s"%_logToScreen)
        logMessage("  logFile: %s"%_logFile)
        logMessage("  socketHost: %s"%_socketHost)
        logMessage("  socketPort: %s"%_socketPort)
        logMessage("  socketFile: %s"%_socketFile)
        logMessage("  reverseDNS: %s"%_reverseDNS)
        logMessage("  socketQueueSize: %s"%_socketQueueSize)
        if _processPool!=1: _processPoolStr=_processPool
        else: _processPoolStr='0'
        logMessage("  processPool: %s"%_processPoolStr)
        if _threadPool!=1: _threadPoolStr=_threadPool
        else: _threadPoolStr='0'
        logMessage("  threadPool: %s"%_threadPoolStr)
        logMessage("  threading: %s"%_threading)
        logMessage("  forking: %s"%_forking)
        logMessage("  sslKeyFile: %s"%_sslKeyFile)
        logMessage("  sslCertificateFile: %s"%_sslCertificateFile)
        logMessage("  typeOfRequests: %s"%str(_typeOfRequests))
        logMessage("  flushCacheDelay: %s min"%_flushCacheDelay)
        logMessage("  sessionStorageType: %s"%_sessionStorageType)
        if _sessionStorageType: logMessage("  sessionTimeout: %s min"%_sessionTimeout)
        if _sessionStorageType: logMessage("  sessionCookieName: %s"%_sessionCookieName)
        if _sessionStorageType=="file": logMessage("  sessionStorageFileDir: %s"%_sessionStorageFileDir)
        logMessage("  staticContent: %s"%_staticContentList)
        
        if _socketFile and not hasattr(socket, 'AF_UNIX'): raise "CherryError: Configuration file has socketFile, but this is only available on Unix machines"
        if _processPool!=1 and not hasattr(os, 'fork'): raise "CherryError: Configuration file has processPool, but forking is not available on this operating system"
        if _forking and not hasattr(os, 'fork'): raise "CherryError: Configuration file has forking, but forking is not available on this operating system"
        if _sslKeyFile:
            try:
                global SSL
                from OpenSSL import SSL
            except: raise "CherryError: PyOpenSSL 0.5.1 or later must be installed to use SSL. You can get it from http://pyopenssl.sourceforge.net"
        if 'xmlRpc' in _typeOfRequests:
            try:
                global xmlrpclib
                import xmlrpclib
            except: raise "CherryError: xmlrpclib must be installed to use XML-RPC. It is included in Python-2.2 and higher, or else you can get it from http://www.pythonware.com"
        if _socketPort and _socketFile: raise "CherryError: In configuration file: socketPort and socketFile conflict with each other"
        if not _socketFile and not _socketPort: _socketPort=8000 # Default port
        if _processPool==1: severalProcs=0
        else: severalProcs=1
        if _threadPool==1: severalThreads=0
        else: severalThreads=1
        if severalThreads+severalProcs+_threading+_forking>1: raise "CherryError: In configuration file: threadPool, processPool, threading and forking conflict with each other"
        if _sslKeyFile and not _sslCertificateFile: raise "CherryError: Configuration file has sslKeyFile but no sslCertificateFile"
        if _sslCertificateFile and not _sslKeyFile: raise "CherryError: Configuration file has sslCertificateFile but no sslKeyFile"
        try: sys.stdout.flush()
        except: pass
        
        for typeOfRequest in _typeOfRequests:
            if typeOfRequest not in ('xmlRpc', 'web'): raise "CherryError: Configuration file an invalid typeOfRequest: '%s'"%typeOfRequest
        
        if _sessionStorageType not in ('', 'custom', 'ram', 'file', 'cookie'): raise "CherryError: Configuration file an invalid sessionStorageType: '%s'"%_sessionStorageType
        if _sessionStorageType in ('custom', 'ram', 'cookie') and _sessionStorageFileDir!='': raise "CherryError: Configuration file has sessionStorageType set to 'custom, 'ram' or 'cookie' but a sessionStorageFileDir is specified"
        if _sessionStorageType=='file' and _sessionStorageFileDir=='': raise "CherryError: Configuration file has sessionStorageType set to 'file' but no sessionStorageFileDir"
        if _sessionStorageType=='ram' and (_forking or severalProcs):
            print "CherryWarning: 'ram' sessions might be buggy when using several processes"
        
    global root
    root = Root()

    if not globals().has_key('hotReload'):
        # Call initServer function
        # logMessage("Calling initServer() ...")
        initServer()
    else:
        # Call hotReloadInitServer function
        # logMessage("Calling hotReloadInitServer() ...")
        hotReloadInitServer()
        logMessage("Hot reload finished")

    # Create request and response instances (the same will be used all the time)
    global request, response
    if not _threading and _threadPool==1:
        # If we don't use threading, we don't care about concurrency issues among different requests
        class _emptyClass: pass
        request=_emptyClass()
        response=_emptyClass()
    else:
        # If we use threading, we have to store request informations in thread-aware classes
        global _myThread
        import thread as _myThread # Ugly hack because CherryForum uses the keyword "thread" ... TBC
        class _threadAwareClass:
            def __init__(self, name):
                self.__dict__['threadMap']={} # Used to store variables. Keys are thread identifier
                self.__dict__['name']=name
            def __setattr__(self, name, value):
                if self.__dict__['name'] == 'request' and name == 'sessionMap' and not _sessionStorageType:
                    raise "You are trying to use sessions but sessions are not enabled in the config file. Check out the HowTo about sessions on the cherrypy.org website to learn how to use sessions."
                _myId=_myThread.get_ident()
                if not self.__dict__['threadMap'].has_key(_myId): self.__dict__['threadMap'][_myId]={}
                self.threadMap[_myId][name]=value
            def __getattr__(self, name):
                if self.__dict__['name'] == 'request' and name == 'sessionMap' and not _sessionStorageType:
                    raise "You are trying to use sessions but sessions are not enabled in the config file. Check out the HowTo about sessions on the cherrypy.org website to learn how to use sessions."
                _myId=_myThread.get_ident()
                return self.__dict__['threadMap'][_myId][name]
        request=_threadAwareClass('request')
        response=_threadAwareClass('response')

    # Create sessionMap if needed
    if _sessionStorageType=="ram":
        global _sessionMap
        _sessionMap={} # Map of "cookie" -> ("session object", "expiration time")

    global _weekdayname, _monthname
    _weekdayname=['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    _monthname=[None, 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

    sys.stdout.flush()

def initRequestBeforeParse():
    pass
def initRequest():
    pass
def initNonStaticRequest():
    pass
def initResponse():
    pass
def initNonStaticResponse():
    pass
def initServer():
    pass
def initThread(threadIndex):
    pass
def initProcess(processIndex):
    pass
def initAfterBind():
    pass
def hotReloadInitServer():
    pass
def onError():
    import traceback, cStringIO
    bodyFile=cStringIO.StringIO()
    traceback.print_exc(file=bodyFile)
    errorBody=bodyFile.getvalue()
    print errorBody
    bodyFile.close()
    response.body="<html><body><br><br><center>"
    response.body+="Sorry, an error occured<br>"
    response.body+="An email has been sent to the webmaster"
    response.body+="</center></body></html>"

def logMessage(message):
    if _logToScreen: print message
    if _logFile:
        f=open(_logFile, "a")
        f.write(message+"\n")
        f.close()
def saveSessionData(sessionId, sessionData):
    pass
def loadSessionData(sessionId):
    pass

def ramOrFileOrCookieSaveSessionData(sessionId, sessionData):
    # Save session to file if needed
    if _sessionStorageType=='file':
        fname=os.path.join(_sessionStorageFileDir,sessionId)
        if _threadPool>1 or _threading:
            _sessionFileLock.acquire()
        f=open(fname,"wb")
        cPickle.dump(sessionData, f)
        f.close()
        if _threadPool>1 or _threading:
            _sessionFileLock.release()
    elif _sessionStorageType=="ram":
        # Update expiration time
        _mySessionMap = sessionData[0]
        _sessionMap[sessionId]=(_mySessionMap, time.time()+_sessionTimeout*60)
    elif _sessionStorageType == "cookie":
        global _SITE_KEY_
        if not globals().has_key('_SITE_KEY_'):
            # Get site key from config file or compute it
            try: _SITE_KEY_ = configFile.get('server','siteKey')
            except:
                _SITE_KEY_ = ''
                for i in range(30):
                    _SITE_KEY_ += whrandom.choice(string.letters)
        # Update expiration time
        _mySessionMap = sessionData[0]
        _sessionData = (_mySessionMap, time.time()+_sessionTimeout*60)
        _dumpStr = cPickle.dumps(_sessionData)
        try: _dumpStr = zlib.compress(_dumpStr)
        except: pass # zlib is not available in all python distros
        _dumpStr = binascii.hexlify(_dumpStr) # Need to hexlify it because it will be stored in a cookie
        response.simpleCookie['CSession']=_dumpStr
        response.simpleCookie['CSession-sig']=md5.md5(_dumpStr+_SITE_KEY_).hexdigest()
        response.simpleCookie['CSession']['path']='/'
        response.simpleCookie['CSession']['max-age']=3600
        response.simpleCookie['CSession-sig']['path']='/'
        response.simpleCookie['CSession-sig']['max-age']=3600

def ramOrFileOrCookieLoadSessionData(sessionId):
    _now=time.time()
    # Check if this sessionId is valid (it exists and has not expired)
    if _sessionStorageType=="ram":
        if _sessionMap.has_key(sessionId):
            return _sessionMap[sessionId]
        else: return None

    elif _sessionStorageType=="file":
        _fname=os.path.join(_sessionStorageFileDir,sessionId)
        if os.path.exists(_fname):
            if _threadPool>1 or _threading:
                _sessionFileLock.acquire()
            _f=open(_fname,"rb")
            _sessionData = cPickle.load(_f)
            _f.close()
            if _threadPool>1 or _threading:
                _sessionFileLock.release()
            return _sessionData
        else: return None
    elif _sessionStorageType == "cookie":
        global _SITE_KEY_
        if not globals().has_key('_SITE_KEY_'):
            try: _SITE_KEY_ = configFile.get('server','siteKey')
            except:
                return None
        if request.simpleCookie.has_key('CSession') and request.simpleCookie.has_key('CSession-sig'):
            _data = request.simpleCookie['CSession'].value
            _sig  = request.simpleCookie['CSession-sig'].value
            if md5.md5(_data + _SITE_KEY_).hexdigest() == _sig:
                try:
                    _dumpStr = binascii.unhexlify(_data)
                    try: _dumpStr = zlib.decompress(_dumpStr)
                    except: pass # zlib is not available in all python distros
                    _dumpStr = cPickle.loads(_dumpStr)
                    return _dumpStr
                except: pass
        return None

maskAndViewMap={'root': {'index': 1, 'mainHeader': 1, 'creaDoc': 1, 'footer': 1, 'postFile': 1, 'uploadFile': 1, 'about': 1, 'cuerpo': 1, 'modelPage': 1, 'navBarX': 1, 'navBar1': 1, 'navBar2': 1}}
xmlrpcMaskAndViewMap={}
if not globals().has_key('hotReload'):
    
    import mimetypes, sha
    mimetypes.types_map['.dwg']='image/x-dwg'
    
    def _parseFirstLine(data):
        data = str(data) # Get rid of unicode
        request.path=data.split()[1]
        if request.path and request.path[0]=='/': request.path=request.path[1:] # Remove starting '/' if any
        request.path=request.path.replace('&amp;', '&') # This case happens for some reason ...
        request.browserUrl=request.path
        request.paramMap={}
        request.filenameMap={}
        request.paramTuple=()
        request.isXmlRpc=0
        i=request.path.find('?')
        if i!=-1:
            if request.path[i+1:]:
                k=request.path[i+1:].find('?')
                if k!=-1:
                    j=request.path[:k].rfind('=')
                    if j!=-1: request.path=request.path[:j+1] + urllib.quote_plus(request.path[j+1:])
                for _paramStr in request.path[i+1:].split('&'):
                    _sp=_paramStr.split('=')
                    if len(_sp) > 2:
                        j=_paramStr.find('=')
                        _sp=(_paramStr[:j],_paramStr[j+1:])
                    if len(_sp)==2:
                        _key, _value=_sp
                        _value=urllib.unquote_plus(_value)
                        if request.paramMap.has_key(_key):
                            # Already has a value: make a list out of it
                            if type(request.paramMap[_key])==type([]):
                                # Already is a list: append the new value to it
                                request.paramMap[_key].append(_value)
                            else:
                                # Only had one value so far: start a list
                                request.paramMap[_key]=[request.paramMap[_key], _value]
                        else:
                            request.paramMap[_key]=_value
            request.path=request.path[:i]
    
        if request.path and request.path[-1]=='/': request.path=request.path[:-1] # Remove trailing '/' if any
        
    def _parsePostData(_rfile):
        # Read request body and put it in _data
        _len = int(request.headerMap.get("content-length","0"))
        if _len: _data=_rfile.read(_len)
        else: _data=""
    
        request.isXmlRpc=0
        # Try to parse request body as an XML-RPC call
        if 'xmlRpc' in _typeOfRequests and _data and request.headerMap.get("content-type","") == "text/xml":
            _xmlRpcPathList = []
            if request.path == 'RPC2': pass
            elif request.path.find('/') > -1: _xmlRpcPathList = request.path.split('/')
            elif not request.path: pass
            else: _xmlRpcPathList = [request.path]
            try:
                try: request.paramTuple,_thisXmlRpcMethod=xmlrpclib.loads(_data)
                except: raise "XML-RPC ERROR"
                _thisXmlRpcMethod = str(_thisXmlRpcMethod) # Get rid of unicode
                request.isXmlRpc=1 # If parsing worked, it is an XML-RPC request
                _xmlRpcPathList += _thisXmlRpcMethod.split('.')
            except "XML-RPC ERROR":
                # error reading data; must not have been an xmlrpc file
                pass
    
        if request.isXmlRpc:
            request.path = '/'.join(_xmlRpcPathList)
        else:
            # It's a normal browser call
            # Put _data in a StringIO so FieldStorage can read it
            _newRfile=cStringIO.StringIO(_data)
            _forms=cgi.FieldStorage(fp=_newRfile, headers=request.headerMap, environ={'REQUEST_METHOD':'POST'}, keep_blank_values=1)
            for _key in _forms.keys():
                # Check if it's a list or not
                _valueList=_forms[_key]
                if type(_valueList)==type([]):
                    # It's a list of values
                    request.paramMap[_key]=[]
                    for item in _valueList: request.paramMap[_key].append(item.value)
                else:
                    # It's a single value
                    # In case it's a file being uploaded, we save the filename in a map (user might need it)
                    if _valueList.filename:
                        request.filenameMap[_key]=_valueList.filename
                    request.paramMap[_key]=_valueList.value
    
    def _insertIntoHeaderMap(key,value):
        request.headerMap[key.lower()]=value
        if key.lower()=='cookie': request.simpleCookie.load(value)
    
    def _doRequest(_wfile):
        try:
            _handleRequest(_wfile)
        except:
            _err=""
            _exc_info_1=sys.exc_info()[1]
            if hasattr(_exc_info_1,'args') and len(_exc_info_1.args)>=1:
                _err=_exc_info_1.args[0]
            if _err=='global name \'sessionMap\' is not defined':
                _error="CherryError:\n"
                _error+="    Session data is now manipulated through \"request.sessionMap\" instead of just \"sessionMap\".\n"
                _error+="    Check out the HowTo about sessions on the cherrypy.org website to learn how to use sessions.\n"
                _wfile.write('HTTP/1.1 200 OK\r\n')
                _wfile.write('Content-Type: text/plain\r\n')
                _wfile.write('Content-Length: %s\r\n'%len(_error))
                _wfile.write('\r\n')
                _wfile.write(_error)
                return
            elif _err=="_emptyClass instance has no attribute 'sessionMap'":
                _error="CherryError:\n"
                _error+="    You are trying to use sessions but sessions are not enabled in the config file.\n"
                _error+="    Check out the HowTo about sessions on the cherrypy.org website to learn how to use sessions.\n"
                _wfile.write('HTTP/1.1 200 OK\r\n')
                _wfile.write('Content-Type: text/plain\r\n')
                _wfile.write('Content-Length: %s\r\n'%len(_error))
                _wfile.write('\r\n')
                _wfile.write(_error)
                return
    
            try:
                onError()
                _wfile.write('HTTP/1.1 %s\r\n'%response.headerMap['status'])
                if response.headerMap.has_key('content-length') and response.headerMap['content-length']==0:
                    response.headerMap['content-length']=len(response.body)
                for _key, _valueList in response.headerMap.items():
                    if _key!='status':
                        if type(_valueList)!=type([]): _valueList=[_valueList]
                        for _value in _valueList:
                            _wfile.write('%s: %s\r\n'%(_key, _value))
                _wfile.write('\r\n')
                _wfile.write(response.body)
            except:
                import traceback, StringIO
                _bodyFile=StringIO.StringIO()
                traceback.print_exc(file=_bodyFile)
                _body=_bodyFile.getvalue()
                _bodyFile.close()
                _wfile.write('HTTP/1.1 200 OK\r\n')
                _wfile.write('Content-Type: text/plain\r\n')
                _wfile.write('Content-Length: %s\r\n'%len(_body))
                _wfile.write('\r\n')
                _wfile.write(_body)
    
    def _sendResponse(_wfile):
        # Save page in the cache if needed
        _cacheKey=""
        try: _cacheKey=request.cacheKey # Cannot use "hasattr", because it fails under jython when threading is turned on
        except: pass
        if _cacheKey:
            _cacheMap[request.cacheKey]=(request.cacheExpire, response.headerMap, response.body)
    
        # Save session data
        if _sessionStorageType and not request.isStaticFile:
            _sessionId=response.simpleCookie[_sessionCookieName].value
            _expirationTime=time.time()+_sessionTimeout*60
            _obj=(request.sessionMap, _expirationTime)
            if _sessionStorageType != 'custom': ramOrFileOrCookieSaveSessionData(_sessionId, _obj)
            else: saveSessionData(_sessionId, _obj)
    
        _wfile.write('HTTP/1.1 %s\r\n'%response.headerMap['status'])
        for _key, _valueList in response.headerMap.items():
            if _key!='status':
                if type(_valueList)!=type([]): _valueList=[_valueList]
                for _value in _valueList:
                    _wfile.write('%s: %s\r\n'%(_key, _value))
        # Send response cookies
        _cookie=response.simpleCookie.output()
        # print "Sending back cookie:", _cookie
        if _cookie:
            _wfile.write(_cookie+'\r\n')
        _wfile.write('\r\n')
        _wfile.write(response.body)
    
    def _sendCachedPageIfPossible(_now,_wfile):
        _cacheKey=""
        try: _cacheKey=request.cacheKey # Cannot use "hasattr", because it fails under jython when threading is turned on
        except: pass
        if _cacheKey:
            # Use caching for this page
            if _cacheMap.has_key(request.cacheKey) and _cacheMap[request.cacheKey][0]>=_now:
                # This page is already in the cache and it hasn't expired yet: use the cached version
                dummy, response.headerMap, response.body=_cacheMap[request.cacheKey]
                initResponse()
                request.cacheKey='' # No need to save the page in the cache again
                _sendResponse(_wfile)
                return 1
            # else:
            #     Either the page has never been cached, or the cached version expired
            #     In the case, we build the page normally and it will be saved in the cache
            #    in the _sendResponse function
        return 0
    
    def _handleRequest(_wfile):
        _now = time.time()
        _year, _month, _day, _hh, _mm, _ss, _wd, _y, _z = time.gmtime(_now)
        _date="%s, %02d %3s %4d %02d:%02d:%02d GMT"%(_weekdayname[_wd],_day,_monthname[_month],_year,_hh,_mm,_ss)
        response.headerMap={"status": "200 OK", "content-type": "text/html", "server": "CherryPy 0.10-beta", "date": _date, "set-cookie": [], "content-length": 0}
    
        # Two variables used for streaming
        response.wfile = _wfile
        response.sendResponse = 1
    
        if _sslKeyFile:
            request.base="https://"+request.headerMap['host']
        else:
            request.base="http://"+request.headerMap['host']
        request.browserUrl=request.base+'/'+request.browserUrl
        request.isStaticFile = 0
    
        # Flush the cache if needed:
        global _lastCacheFlushTime
        if _flushCacheDelay and _cacheMap and _lastCacheFlushTime+_flushCacheDelay*60<=_now:
            _lastCacheFlushTime=_now
            for key, (expire, dummy, dummy) in _cacheMap.items():
                if expire<=_now:
                    del _cacheMap[key]
    
        # Perform some initial operations (such as rewriting url ...)
        request.originalPath=request.path
        request.originalParamMap=request.paramMap
        request.originalParamTuple=request.paramTuple
    
        initRequest()
    
        _path=request.path
    
        # Handle static directories
        for urlDir, fsDir in _staticContentList:
            if _path[:len(urlDir)+1]==urlDir+'/':
    
                request.isStaticFile = 1
    
                if _sendCachedPageIfPossible(_now, _wfile): return
    
                _fname = fsDir+_path[len(urlDir):] 
                _stat = os.stat(_fname)
                if type(_stat) == type(()): # Python2.1
                    _modifTime = _stat[9]
                else:
                    _modifTime = _stat.st_mtime
                    
                _strModifTime = time.strftime("%a, %d %b %Y %H:%M:%S GMT", time.gmtime(_modifTime))
    
                # Check if browser sent "if-modified-since" in request header
                if request.headerMap.has_key('if-modified-since'):
                    # Check if if-modified-since date is the same as _strModifTime
                    if request.headerMap['if-modified-since'] == _strModifTime:
                        response.headerMap = {'status': 304, 'date': _date}
                        response.body = ''
                        initResponse()
                        _sendResponse(_wfile)
                        return
    
                response.headerMap['last-modified'] = _strModifTime
                _f=open(_fname, 'rb')
                response.body=_f.read()
                response.headerMap['content-length']=len(response.body)
                _f.close()
                # Set content-type based on filename extension
                _i=_path.rfind('.')
                if _i!=-1: _ext=_path[_i:]
                else: _ext=""
                _contentType=mimetypes.types_map.get(_ext, "text/plain")
                response.headerMap['content-type']=_contentType
                initResponse()
                _sendResponse(_wfile)
                return
    
        # Get session data
        if _sessionStorageType and not request.isStaticFile:
            _now=time.time()
            # First, get sessionId from cookie
            try: _sessionId=request.simpleCookie[_sessionCookieName].value
            except: _sessionId=None
            if _sessionId:
                # Load session data from wherever it was stored
                if _sessionStorageType != 'custom': _sessionData = ramOrFileOrCookieLoadSessionData(_sessionId)
                else: _sessionData = loadSessionData(_sessionId)
                if _sessionData == None: _sessionId = None
                else:
                    request.sessionMap, _expirationTime = _sessionData
                    # Check that is hasn't expired
                    if _now > _expirationTime:
                        # Session expired
                        _sessionId = None
    
            # Create a new sessionId if needed
            if not _sessionId:
                request.sessionMap={}
                _sessionId=_generateSessionId()
                request.sessionMap['_sessionId'] = _sessionId
    
            response.simpleCookie[_sessionCookieName]=_sessionId
            response.simpleCookie[_sessionCookieName]['path']='/'
            response.simpleCookie[_sessionCookieName]['version']=1
    
        initNonStaticRequest()
    
        if _sendCachedPageIfPossible(_now, _wfile): return
    
        _path=request.path
        # Special case when url is just the host name
        if not _path: _path='index'
    
        # Work on path:
        # a/b/c/d -> a_b_c.d()
        # c -> root.c()
    
        #if request.isXmlRpc: _pathList=_path.split('.')
        #else:
        _pathList=_path.split('/')
        #print "_path:", _path
        if len(_pathList)==1: _pathList=['root']+_pathList
        _function=None
        _myClass='_'.join(_pathList)
        if _myClass[:5] == 'root_': _myClass = _myClass[5:]
        _myClass2='_'.join(_pathList[:-1])
        # If both mask/view and class have same name, make the mask/view default.
        if maskAndViewMap.has_key(_myClass) and maskAndViewMap.has_key(_myClass2) and _myClass in maskAndViewMap[_myClass2].keys(): _myClass = _myClass2
        # If the path leads to a class, call index by default.
        elif maskAndViewMap.has_key(_myClass): _function = 'index'
        if _function == None:
            _myClass=_myClass2
            _function=_pathList[-1]
    
        _myClass=str(_myClass) # For some reason, _myClass was sometimes unicode (when using XML-RPC)
        # print "_myClass:", `_myClass`, "__function:", _function
    
        # Check that class/method exist
        if not maskAndViewMap.has_key(_myClass): raise str('CherryError: CherryClass "%s" doesn\'t exist'%_myClass)
        elif not maskAndViewMap[_myClass].has_key(_function): raise str('CherryError: CherryClass "%s" doesn\'t have any view or mask method called "%s"'%(_myClass, _function))
    
        # Check that it is not a browser call to an XML-RPC method:
        if xmlrpcMaskAndViewMap and not request.isXmlRpc and xmlrpcMaskAndViewMap.has_key(_myClass) and xmlrpcMaskAndViewMap[_myClass].has_key(_function):
            raise str('CherryError: Method "%s" of CherryClass "%s" is an XML-RPC method'%(_function, _myClass))
    
        # Check that it is not an XML-RPC call to a regular metohd:
        if request.isXmlRpc and (not xmlrpcMaskAndViewMap.has_key(_myClass) or not xmlrpcMaskAndViewMap[_myClass].has_key(_function)):
            raise str('CherryError: method "%s" of CherryClass "%s" is not an xmlrpc method'%(_function, _myClass))
    
        # Get result by calling class method
        _theObj=globals()[_myClass]
        _theMethod=getattr(_theObj,_function)
        if request.isXmlRpc:
            response.body=_theMethod(*(request.paramTuple))
        else:
            response.body=_theMethod(**(request.paramMap))
    
        initResponse()
        initNonStaticResponse()
    
        if request.isXmlRpc:
            # Marshall the result if it's an XML-RPC call
            # Wrap the response into a singleton tuple
            response.body=(response.body,)
            response.body=xmlrpclib.dumps(response.body, methodresponse=1)
            # Response type is text/xml for an XML-RPC call
            response.headerMap["content-type"]="text/xml"
    
        # Check response.body and set content-length if needed
        if type(response.body) != type(""):
            if type(response.body) == type(u""): # Potential gotcha: on jython, type("") == type(u"") !!
                raise "CherryError: The mask or view returned a unicode string instead of a regular string !"
            else:
                raise "CherryError: The mask or view didn't return a string !"
        if response.headerMap.has_key('content-length') and response.headerMap['content-length']==0:
            response.headerMap['content-length']=len(response.body)
    
        if response.sendResponse: _sendResponse(_wfile)
    
    def _generateSessionId():
        s=''
        for i in range(50):
            s+=whrandom.choice(string.letters+string.digits)
        s+='%s'%time.time()
        return sha.sha(s).hexdigest()
    
    
    
    import SocketServer
    import socket
    import threading
    import Queue
    import sys
    import threading
    
    _SHUTDOWNREQUEST = (0,0)
    
    class ServerThread(threading.Thread):
        def __init__(self, RequestHandlerClass, requestQueue, threadIndex):
            threading.Thread.__init__(self)
            self._RequestHandlerClass = RequestHandlerClass
            self._requestQueue = requestQueue
            self._threadIndex = threadIndex
            self.setName("RUNNING")
            
        def run(self):
            initThread(self._threadIndex)
            #print "ServerThread %s running..." % threading.currentThread()
            while 1:
                request, client_address = self._requestQueue.get()
                if (request, client_address) == _SHUTDOWNREQUEST:
                    #print "ServerThread %s got SHUTDOWN token" % threading.currentThread()
                    return
                #print "ServerThread %s got request from %s" % (threading.currentThread(), client_address )
                if self.verify_request(request, client_address):            
                    try:
                        self.process_request(request, client_address)
                    except:
                        self.handle_error(request, client_address)
                        self.close_request(request)
                else:
                    self.close_request(request)
    
        def verify_request(self, request, client_address):
            """Verify the request.  May be overridden.
            Return 1 if we should proceed with this request."""
            return 1
    
        def process_request(self, request, client_address):
            self._RequestHandlerClass(request, client_address, self)        
            self.close_request(request)
    
        def close_request(self, request):
            """Called to clean up an individual request."""
            request.close()
    
        def handle_error(self, request, client_address):
            """Handle an error gracefully.  May be overridden.
            The default is to print a traceback and continue.
            """
            import traceback, StringIO
            bodyFile=StringIO.StringIO()
            traceback.print_exc(file=bodyFile)
            errorBody=bodyFile.getvalue()
            bodyFile.close()
            logMessage(errorBody)
            
    
    class PooledThreadServer(SocketServer.TCPServer):
    
        allow_reuse_address = 1
    
        """A TCP Server using a pool of worker threads. This is superior to the
           alternatives provided by the Python standard library, which only offer
           (1) handling a single request at a time, (2) handling each request in
           a separate thread (via ThreadingMixIn), or (3) handling each request in
           a separate process (via ForkingMixIn). It's also superior in some ways
           to the pure async approach used by Twisted because it allows a more
           straightforward and simple programming model in the face of blocking
           requests (i.e. you don't have to bother with Deferreds).""" 
        def __init__(self, serverAddress, numThreads, RequestHandlerClass, ThreadClass=ServerThread):
            assert(numThreads > 0)
    
            # I know it says "do not override", but I have to in order to implement SSL support !
            SocketServer.BaseServer.__init__(self, serverAddress, RequestHandlerClass)
            if _sslKeyFile:
                self.socket=SSL.Connection(_sslCtx, socket.socket(self.address_family, self.socket_type))
            else:
                self.socket=socket.socket(self.address_family, self.socket_type)
            self.server_bind()
            self.server_activate()
            initAfterBind()
    
            self._numThreads = numThreads        
            self._RequestHandlerClass = RequestHandlerClass
            self._ThreadClass = ThreadClass
            self._requestQueue = Queue.Queue()
            self._workerThreads = []
                
        def createThread(self, threadIndex):
            return self._ThreadClass(self._RequestHandlerClass, self._requestQueue, threadIndex)
                
        def start(self):
            if self._workerThreads != []:
                return
            for i in xrange(self._numThreads):
                self._workerThreads.append(self.createThread(i))        
            for worker in self._workerThreads:
                worker.start()
                
        def server_close(self):
            """Override server_close to shutdown thread pool"""
            #print "%s shutting down..." % str(self)
            SocketServer.TCPServer.server_close(self)
            for worker in self._workerThreads:
                self._requestQueue.put(_SHUTDOWNREQUEST)
            for worker in self._workerThreads:
                #print "waiting for %s to exit..." % str(worker)
                worker.join()
            self._workerThreads = []
            #print "%s was shutdown gracefully" % str(self)
    
        def server_activate(self):
            """Override server_activate to set timeout on our listener socket"""
            if hasattr(self.socket, 'settimeout'): self.socket.settimeout(2)
            elif hasattr(self.socket, 'set_timeout'): self.socket.set_timeout(2)
            SocketServer.TCPServer.server_activate(self)
    
        def server_bind(self):
            """Override server_bind to store the server name."""
            SocketServer.TCPServer.server_bind(self)
            host, port = self.socket.getsockname()
            if _reverseDNS: self._serverName = socket.getfqdn(host)
            else: self._serverName = host
            self._serverPort = port
            #print "PooledThreadServer bound to %s:%s" % (self._serverName, self._serverPort)
    
        def shutdown(self):
            """Gracefully shutdown a server that is serve_forever()ing."""
            self.__running = 0
    
        def shutdownCtrlC(self):
            self.server_close()
    
        def serve_forever(self):
            """Handle one request at a time until doomsday (or shutdown is called)."""
            if self._workerThreads == []:
                self.start()
            self.__running = 1
            while self.__running:
                if not self.handle_request():
                    break
            self.server_close()            
            
        def handle_request(self):
            """Override handle_request to enqueue requests rather than handle
               them synchronously. Return 1 by default, 0 to shutdown the
               server."""
            try:
                if _debug:
                    for t in threading.enumerate():
                        if t.getName()=="NOT RUNNING": return 0
                request, client_address = self.get_request()
                if hasattr(request,'setblocking'): # Jython doesn't have setblocking
                    request.setblocking(1)
            except _timeoutError:
                # The only reason for the timeout is so we can notice keyboard
                # interrupts on Win32, which don't interrupt accept() by default
                return 1
            except KeyboardInterrupt:
                print "<Ctrl-C> hit: shutting down"
                return 0
            except socket.error, e:
                return 1
            self._requestQueue.put((request, client_address))
            return 1
    
    
    """CherryPy HTTP Server.
    
    This module builds on BaseHTTPServer in a fashion similar to SimpleHTTPServer 
    by implementing the standard GET and HEAD requests in a fairly straightforward manner.
    
    """
    
    try:
        import timeoutsocket
        _timeoutError = timeoutsocket.Timeout
    except:
        _timeoutError = ''
    
    __all__ = ["CherryHTTPRequestHandler"]
    
    import BaseHTTPServer, mimetypes, Cookie, whrandom, os.path, cPickle
    
    
    class CherryHTTPRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    
        """CherryPy HTTP request handler with the following commands:
    
            o  GET
            o  HEAD
            o  POST
            o  HOTRELOAD
    
        """
    
        def address_string(self):
            """ Try to do a reverse DNS based on [server]reverseDNS in the config file """
            if _reverseDNS: return BaseHTTPServer.BaseHTTPRequestHandler.address_string(self)
            else: return self.client_address[0]
    
        def cook_headers(self):
            """Process the headers in self.headers into the request.headerMap"""
            request.headerMap={}
            request.simpleCookie=Cookie.SimpleCookie()
            response.simpleCookie=Cookie.SimpleCookie()
            for item in self.headers.items():
                # print "Header:", str(item[0]), str(item[1])
                _insertIntoHeaderMap(item[0],item[1])
            if not request.headerMap.has_key('remote-addr'):
                try:
                    request.headerMap['remote-addr']=self.client_address[0]
                    request.headerMap['remote-host']=self.address_string()
                except: pass
            logMessage("[%s] %s - %s"%((time.strftime("%Y/%m/%d %H:%M:%S")), request.headerMap.get('remote-addr', ''), self.raw_requestline[:-2]))
    
        def do_GET(self):
            """Serve a GET request."""
            request.method = 'GET'
            _parseFirstLine(self.raw_requestline)
            self.cook_headers()
            _doRequest(self.wfile)
    
        def do_HEAD(self): # Head is not implemented
            """Serve a HEAD request."""
            request.method = 'HEAD'
            _parseFirstLine(self.raw_requestline)
            self.cook_headers()
            _doRequest(self.wfile)
    
        def do_POST(self):
            """Serve a POST request."""
            request.method = 'POST'
            _parseFirstLine(self.raw_requestline)
            self.cook_headers()
            _parseIt = 1
            request.parsePostData = 1
            initRequestBeforeParse()
            if request.parsePostData: _parsePostData(self.rfile)
            request.rfile = self.rfile
            _doRequest(self.wfile)
    
        def do_HOTRELOAD(self):
            """Serve a HOTRELOAD request."""
            if _debug:
                logMessage("Starting hot reload ...")
                sys.stdout.flush()
                global hotReload
                hotReload=1
                try: execfile(_outputFile)
                except SystemExit, e: pass
            else:
                logMessage("Hot reload disabled when not in debug mode ...")
    
        if sys.platform[:4]!="java":
            # Don't use this for jython
            def setup(self):
                """ We have to override this to handle SSL (socket object from the OpenSSL package don't have the makefile method) """
                self.connection=self.request
                #self.rfile=self.connection.makefile('rb', self.rbufsize)
                #self.wfile=self.connection.makefile('wb', self.wbufsize)
                self.rfile=CherryFileObject(self.connection, 'rb', self.rbufsize)
                self.wfile=CherryFileObject(self.connection, 'wb', self.wbufsize)
    
        def log_message(self, format, *args):
            """ We have to override this to use our own logging mechanism """
            logMessage("%s - - [%s] %s\n" %
                             (self.address_string(),
                                self.log_date_time_string(),
                                format%args))
    
    
    if sys.platform[:4]!="java":
        # Don't use this for jython
        class CherryFileObject(socket._fileobject):
            def flush(self):
                if self._wbuf:
                    if hasattr(self._sock, "sendall"):
                        if type(self._wbuf)==type([]): # python2.3
                            self._sock.sendall("".join(self._wbuf))
                            self._wbuf=[]
                        else:
                            self._sock.sendall(self._wbuf)
                            self._wbuf=""
                    else:
                        while self._wbuf:
                            _sentChar=self._sock.send(self._wbuf)
                            self._wbuf=self._wbuf[_sentChar:]
            def __del__(self):
                try: self.close()
                except: pass
    
    class CherryThreadingMixIn(SocketServer.ThreadingMixIn):
        def process_request_thread(self, request, client_address):
            """Same as in BaseServer but as a thread.
            In addition, exception handling is done here.
            """
            try:
                self.finish_request(request, client_address)
                self.close_request(request)
            except:
                self.handle_error(request, client_address)
                self.close_request(request)
    
        def process_request(self, request, client_address):
            """Start a new thread to process the request."""
            if _debug:
                for t in threading.enumerate():
                    if t.getName() == "NOT RUNNING":
                        os._exit(-1)
            t = threading.Thread(target = self.process_request_thread, args = (request, client_address))
            if _debug: t.setName("RUNNING")
            t.start()
    
    class CherryHTTPServer(BaseHTTPServer.HTTPServer):
        def __init__(self, server_address, RequestHandlerClass):
            # I know it says "do not override", but I have to in order to implement SSL support !
            SocketServer.BaseServer.__init__(self, server_address, RequestHandlerClass)
            if _sslKeyFile:
                self.socket=SSL.Connection(_sslCtx, socket.socket(self.address_family, self.socket_type))
            else:
                self.socket=socket.socket(self.address_family, self.socket_type)
            self.server_bind()
            self.server_activate()
            initAfterBind()
    
        def server_activate(self):
            """Override server_activate to set timeout on our listener socket"""
            if hasattr(self.socket, 'settimeout'): self.socket.settimeout(2)
            elif hasattr(self.socket, 'set_timeout'): self.socket.set_timeout(2)
            BaseHTTPServer.HTTPServer.server_activate(self)
    
        def server_bind(self):
            # Removed getfqdn call because it was timing out on localhost when calling gethostbyaddr
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.socket.bind(self.server_address)
    
        def get_request(self):
            # With Python 2.3 it seems that an accept socket in timeout (nonblocking) mode
            #  results in request sockets that are also set in nonblocking mode. Since that doesn't play
            #  well with makefile() (where wfile and rfile are set in SocketServer.py) we explicitly set
            #  the request socket to nonblocking
            request, client_address = self.socket.accept()
            if hasattr(request,'setblocking'): # Jython doesn't have setblocking
                request.setblocking(1)
            return request, client_address
    
        def handle_request(self):
            """Override handle_request to trap timeout exception."""
            try:
                BaseHTTPServer.HTTPServer.handle_request(self)
            except _timeoutError:
                # The only reason for the timeout is so we can notice keyboard
                # interrupts on Win32, which don't interrupt accept() by default
                return 1
            except KeyboardInterrupt:
                print "<Ctrl-C> hit: shutting down"
                sys.exit(0)
    
        def shutdownCtrlC(self):
            self.shutdown()
    
    def run_server(HandlerClass, ServerClass, server_address, _socketFile):
        """Run the HTTP request handler class."""
        global __myCherryHTTPServer
        if _socketFile:
            try: os.unlink(_socketFile) # So we can reuse the socket
            except: pass
            server_address=_socketFile
        if _threadPool>1:
            __myCherryHTTPServer = ServerClass(server_address, _threadPool, HandlerClass)
        else:
            __myCherryHTTPServer = ServerClass(server_address, HandlerClass)
        if _socketFile:
            try: os.chmod(_socketFile, 0777) # So everyone can access the socket
            except: pass
    
        if _sslKeyFile: servingWhat="HTTPS"
        else: servingWhat="HTTP"
        if _socketPort: onWhat="socket: ('%s', %s)" % (_socketHost, _socketPort)
        else: onWhat="socket file: %s"%_socketFile
        logMessage("Serving %s on %s"%(servingWhat, onWhat))
    
        # If _processPool is more than one, create new processes
        if _processPool>1:
            for i in range(_processPool):
                logMessage("Forking a kid")
                if not os.fork():
                    # Kid
                    initProcess(i)
                    try: __myCherryHTTPServer.serve_forever()
                    except KeyboardInterrupt:
                        print "<Ctrl-C> hit: shutting down"
                        __myCherryHTTPServer.shutdownCtrlC()
        else:
            try: __myCherryHTTPServer.serve_forever()
            except KeyboardInterrupt:
                print "<Ctrl-C> hit: shutting down"
                __myCherryHTTPServer.shutdownCtrlC()
    
    def run(argv):
        mainInit(argv)
        if not globals().has_key('hotReload'):
            # If SSL is used, perform some initialization
            if _sslKeyFile:
                # Setup SSL mode
                global _sslCtx
                _sslCtx=SSL.Context(SSL.SSLv23_METHOD)
                # _sslCtx.set_options(SSL.OP_NO_SSLv2) # Doesn't work on Windows
                _sslCtx.use_privatekey_file(_sslKeyFile)
                _sslCtx.use_certificate_file(_sslCertificateFile)
            
            # If sessions are stored in files and we use threading, we need a lock on the file
            if (_threadPool>1 or _threading) and _sessionStorageType == 'file':
                global _sessionFileLock
                import threading
                _sessionFileLock = threading.RLock()
            
            import SocketServer
            if _socketFile:
                # AF_UNIX socket
                if _forking:
                    class MyCherryHTTPServer(SocketServer.ForkingMixIn,CherryHTTPServer): address_family=socket.AF_UNIX
                elif _threading:
                    import threading
                    class MyCherryHTTPServer(CherryThreadingMixIn,CherryHTTPServer): address_family=socket.AF_UNIX
                else:
                    class MyCherryHTTPServer(CherryHTTPServer): address_family=socket.AF_UNIX
            else:
                # AF_INET socket
                if _forking:
                    class MyCherryHTTPServer(SocketServer.ForkingMixIn,CherryHTTPServer): pass
                elif _threading:
                    class MyCherryHTTPServer(CherryThreadingMixIn,CherryHTTPServer):pass
                elif _threadPool>1:
                    MyCherryHTTPServer=PooledThreadServer
                else:
                    MyCherryHTTPServer=CherryHTTPServer
        
            MyCherryHTTPServer.request_queue_size = _socketQueueSize
            run_server(CherryHTTPRequestHandler, MyCherryHTTPServer, (_socketHost, _socketPort), _socketFile)
    
    def shutdown():
        __myCherryHTTPServer.shutdown()
    
    

if __name__ == '__main__':
    import sys
    run(sys.argv)
