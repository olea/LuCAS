  <chapter id="testing">
    <title>Pruebas de conformidad de escritura</title>

    <para>
      Nota: Esta parte de la documentación aún está en desarrollo
      por lo que no está completa.
    </para>

    <sect1 id="testing-intro">
      <title>Introducción</title>
      <para>
        El API de windows no sigue ningún estándard, de hecho él
	mismo lo es, y las desviaciones de este estándard, incluso
	las más pequeñas a menudo originan el cuelgue de la aplicación
	o de alguna manera su mal funcionamiento. Además una prueba
	de conformidad apropiada es lo más fiel (si no necesariamente lo
	más completo) y se puede usar para completar la documentación
	del API de windows.
      </para>
      <para>
        No es tarea fácil escribir una prueba de conformidad adecuada
	para más de 10000 APIs. Afortunadamente puede demostrar su utilidad
	para el desarrollo de Wine antes de que se termine.
        <itemizedlist>
          <listitem>
            <para>
              La oportuna prueba de conformidad se debe de ejecutar en windows.
	      Esto es necesario para demostrar de una forma razonable su exactitud.
	      Además las pruebas deben de superar con éxito todas las plataformas
	      de windows (Se deben de saltar las pruebas no relevantes de una
	      plataforma concreta).
            </para>
            <para>
              Una consecuencia de esto es que la prueba oportuna suministrará
	      una buena forma de detectar variaciones en la API entre las
	      diferentes versiones de Windows. Por ejemplo, esto puede
	      profundizar en las diferencias entre las familias Win9x y
	      Windows NT, a menudo indocumentadas.
            </para>
            <para>
              No obstante, debemos recordar que el objetivo de Wine es ejecutar
	      aplicaciones de windows en Linux, no ser un clon de una versión
	      concreta de windows. Así que tales variaciones han de ser probadas
	      solo cuando resulten relevantes para este objetivo.
            </para>
          </listitem>
          <listitem>
            <para>
              La prueba de conformidad de escritura es también una manera
	      fácil de descubrir fallos en Wine. Por supuesto, antes de
	      fijar los fallos descubiertos de esta forma, nos debemos de
	      asegurar primero que las nuevas pruebas pasarán con éxito
	      al menos una versión Windows 9x y una versión NT.
            </para>
            <para>
              Los errores descubiertos de esta manera deben de ser faciles
	      de corregir. Por el contrario si alguna aplicación se cuelga
	      misteriosamente, cuando falla un prueba de conformidad,
	      así se sabe los APIs probados y su comportamiento,
	      simplificando bastante el diagnóstico.
            </para>
          </listitem>
          <listitem>
            <para>
              Para detectar retrocesos. Sencillamente haga una prueba
	      con Wine transformandolo en una gran herramienta para
	      detectar retrocesos. Cuando la prueba falla, inmediatamente
	      se sabe cual era la conducta esperada y que APIs estaban
	      implicados. Haciéndolo de esta manera, tales retrocesos
	      se deben detectar antes, ya que es fácil ejecutar todas
	      las pruebas en una base regular, y más fácil de fijar por
	      el reducido trabajo de diagnosis.
            </para>
          </listitem>
          <listitem>
            <para>
              Las pruebas escritas con antelación al desarrollo de
	      Wine (incluso por desarrolladores que no sean de Wine)
	      pueden simplificar también el trabajo de un futuro
	      implementador al hacerle más fácil probar la corrección
	      de su código.
            </para>
          </listitem>
          <listitem>
            <para>
              La prueba de conformidad también viene bien cuando se
	      prueba Wine en nuevas arquitécturas (no tan ampliamente
	      utilizadas) tales como FreeBSD, Solaris x86 e incluso
	      sistemas no x-86. Incluso cuando la adaptación no implica
	      un cambio significativo en el manejo de la ejecución del
	      programa, la manipulación excepcional u otros aspectos de
	      bajo nivel de Wine, las nuevas arquitecturas pueden revelar
	      errores soterrados que resulten difícil de diagnosticar al
	      corregir aplicaciones regulares (complejas).
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect1>


    <sect1 id="testing-what">
      <title>¿Qué probar?</title>
      <para>
        Lo primero a probar es la documentación sobre el comportamiento
	de los APIs y otros como CreateFile. Por ejemplo se puede
	crear un archivo usando un nombre de trayectoria larga,
	comprobar que el comportamiento es correto cuando el archivo
	existe, intentar abrir el archivo utilizando el correspondiente
	nombre corto, convierta el archivo a Unicode e intente abrirlo
	usando CreateFileW, y todas las otras cosas que están documentadas
	y aquellas aplicaciones relacionadas.
      </para>
      <para>
        Lo primero a probar es la documentación sobre el comportamiento
	de los APIs y otros como CreateFile. Por ejemplo se puede
	crear un archivo usando un nombre de trayectoria larga,
	comprobar que el comportamiento es correto cuando el archivo
	existe, intentar abrir el archivo utilizando el correspondiente
	nombre corto, convierta el archivo a Unicode e intente abrirlo
	usando CreateFileW, y todas las otras cosas que están documentadas
	y aquellas aplicaciones relacionadas.
      </para>
      <para>
        Por ejemplo, usted puede crear un control de edición y utilizar
	WM_SETTEXT para ajustar sus contenidos, posiblemente revisar las
	restricciones de longitud, y verificar los resultados utilizando
	WM_GETTEXT. Igualmente usted puede crear una "caja de lista" y
	probar el resultado de LB_DELETESTRING en el número de lista de
	los elementos, seleccionar la lista de elementos, subrayando
	elementos, etc,
      </para>
      <para>
        No obstante, el comportamiento no documentado no se deberá de
	probar a menos que haya una aplicación que dependa de dicho
	comportamiento, en ese caso la prueba debe de mencionar esa
	aplicación, o al menos se pueden esperar aplicaciones que
	dependan de esta conducta, normalmente APIs que devuelven el
	tamaño de la memoria requerida cuando el indicador de memorias
	es NULO.
      </para>
    </sect1>

 
    <sect1 id="testing-wine">
      <title>Ejecutando las pruebas en Wine</title>
      <para>
        La manera más sencilla de ejecutar las pruebas en Wine es
	escribir "make test" en el directorio principal de las fuentes
	de Wine. Esto ejecutará todas las pruebas de conformidad de Wine..
      </para>
      <para>
        Las pruebas para una librería concreta de Wine están situadas
	en un directorio de "pruebas" en este directorio de librerías.
	Cada prueba está en un archivo (por ejemplo
	<filename>dlls/kernel/tests/thread.c</>. Cada archivo
	contiene algunos controles relacionados con uno o más APIs.
      </para>
      <para>
        Así que para ejecutar todas las pruebas relativas a una
	librería dada de Wine, vaya al correspondiente directorio
	de pruebas y escriba "make test". Esto compilará las
	pruebas, las ejecutará, y creará un archivo '<replaceable>xxx</>.ok'
	por cada prueba que pase correctamente. Y si usted solo desea
	ejecutar las pruebas que están en el archivo <filename>thread.c</>
	de la librearia del núcleo, deberá hacer:
<screen>
<prompt>$ </>cd dlls/kernel/tests
<prompt>$ </>make thread.ok
</screen>
      </para>
      <para>
        Advierta que si la prueba ya se ha ejecutado y está al día
	(por ejemplo, si ni la librería del núcleo ni el archivo
	<filename>thread.c</> han cambiado desde que se creó el
	archivo <filename>thread.ok</>), entonces make lo dirá.
	Para obligar a que se ejecute de nuevo la prueba, borre
	el archivo <filename>thread.ok</>, y ejecute el comando
	de nuevo.
      </para>
      <para>
        También puede ejecutar manualmente la prueba
	utilizando una orden similar a la siguiente:
<screen>
<prompt>$ </>../../../tools/runtest -q -M kernel32.dll -p kernel32_test.exe.so thread.c
<prompt>$ </>../../../tools/runtest -p kernel32_test.exe.so thread.c
thread.c: 86 tests executed, 5 marked as todo, 0 failures.
</screen>
        La opción '-P wine' define la plataforma que se está
	probando. Quite la opción '-q' si desea el marco
	probado para presentar estadísticas sobre el número
	de pruebas correctas y falladas. Para más detalles
	ejecutar <command>runtest -h</>.
      </para>
    </sect1>


    <sect1 id="testing-windows">
      <title>Construyendo y ejecutando las pruebas de Windows</title>
      <sect2>
        <title>Usando binarios precompilados</title>
        <para>
          Desgraciadamente todavía no existen binarios
	  precompilados. No obstante si envía un correo
	  electrónico a la lista de desarrollo de Wine
	  posiblemente encuentre a alquien que se lo
	  envíe, y posiblemente anime a poner un mecanismo
	  para publicar tales binarios en una base regular.
        </para>
      </sect2>
      <sect2>
        <title>Con Visual C++</title>
        <itemizedlist>
          <listitem><para>
            consiga las fuentes de Wine
          </para></listitem>
          <listitem><para>
            Ejecute msvcmaker para generar los archivos de
	    Visual C++ project para las pruebas. 'msvcmaker'
	    es un script de perl así que ha de ser capaz de
	    ejecutarse en Windows.
<screen>
<prompt>$ </>./tools/winapi/msvcmaker --no-wine
</screen>
          </para></listitem>
          <listitem><para>
            Si los pasos anteriores fueran dados en su
	    máquina de desarrollo de linux, haga accesible
	    las fuentes de Wine a la máquina de windows en
	    donde va a compilarlas. Normalmente puede hacer
	    esto con Samba pero si copia todo junto también
	    funcionará.
          </para></listitem>
          <listitem><para>
            Abra en la máquina con Windows, el espacio de trabajo
	    <filename>winetest.dsw</>. Esto cargará el proyecto
	    de prueba. Para cada prueba hay dos configuraciones:
	    una compila la prueba con las cabeceras de wine,
	    y la otra utiliza las cabeceras de Visual C++.
	    Algunas pruebas se compilaran con el primero,
	    pero la mayoria requerirán el segundo.
          </para></listitem>
          <listitem><para>
            Abra el menú <menuchoice><guimenu>Build</>
	    <guimenu>Batch build...</></> y seleccione
	    las pruebas y cree las configuraciones que
	    desee. A continuación haga clic en
	    <guibutton>Build</>.
          </para></listitem>
          <listitem><para>
            Para ejecutar una prueba específica desde
	    visual C++, vaya a <menuchoice><guimenu>Project</>
	    <guimenu>Settings...</></>. Allí seleccione
	    el proyecto de prueba y haga la configuración
	    y vaya al menú  <guilabel>Debug</>. Entonces
	    escriba el nombre de la prueba concreta a
	    ejecutar (e.g. 'thread') en el campo
	    <guilabel>Program arguments</>. Valide
	    sus cambios pulsando <guibutton>Ok</>
	    y comience la prueba pulsando la señal
	    de exclamación roja (o pulsando 'F5'
	    o cualquier otro método corriente).
          </para></listitem>
          <listitem><para>
            También puede ejecutar las pruebas desde
	    la línea de comandos. La encontrará tanto
	    en <filename>Output\Win32_Wine_Headers</>
	    como en <filename>Output\Win32_MSVC_Headers</>
	    según el método de construcción. Así para
	    ejecutar las pruebas de "trayectoria" del
	    núcleo, deberá hacer:
<screen>
<prompt>C:\&gt;</>cd dlls\kernel\tests\Output\Win32_MSVC_Headers
<prompt>C:\dlls\kernel\tests\Output\Win32_MSVC_Headers&gt;</>kernel32_test thread
</screen>
          </para></listitem>
        </itemizedlist>
      </sect2>
      <sect2>
        <title>With MinGW</title>
        <para>
          Esto necesita documentarse. Lo mejor sería
	  preguntar en las listas de correo de desarrollo
	  de Wine y actualizar esta documentación
	  con los resultados de sus pesquisas.
        </para>
      </sect2>
      <sect2>
        <title>Compilador cruzado con MinGW en Linux</title>
        <para>
          Aqui se muestra como generar ejecutables
	  para las pruebas de Windows directamente
	  desde la comodidad de Linux.
        </para>
        <itemizedlist>
          <listitem><para>
            Primero tiene que conseguir el compilador
	    cruzado MinGW. En debian todo lo que
	    tiene que hacer es escribir
	    <command>apt-get install mingw32</>.
          </para></listitem>
          <listitem><para>
            Si ya ha ejecutado <command>configure</>,
	    entonces borre  <filename>config.cache</>
	    y vuelva a ejecutar<command>configure</>.
	    Entonces puede ejecutar <command>make crosstest</>
	    Para resumir:
<screen>
<prompt>$ </><userinput>rm config.cache</>
<prompt>$ </><userinput>./configure</>
<prompt>$ </><userinput>make crosstest</>
</screen>
          </para></listitem>
          <listitem><para>
            Si le da error al compilar <filename>winsock.h</> entonces
	    necesitará indicar la siguiente ruta:
            <ulink url="http://www.winehq.com/hypermail/wine-patches/2002/12/0157.html">http://www.winehq.com/hypermail/wine-patches/2002/12/0157.html</>
          </para></listitem>
        </itemizedlist>
      </sect2>
    </sect1>


    <sect1 id="testing-test">
      <title>Dentro de una prueba</title>

      <para>
        Cuando escriba nuevas verificaciones también puede modificar un archivo
	de texto existente o añadir uno nuevo. Si sus pruebas están relacionadas
	con las pruebas realizadas por un archivo existente, entonces añadalas
	a dicho archivo. De otra manera cree un nuevo archivo .c en el directorio
	de texto y añada dicho archivo a la variable <varname>CTESTS</> en
	<filename>Makefile.in</>.
      </para>
      <para>
        Un nuevo archivo de prueba se parecerá a lo que sigue:
<screen>
#include &lt;wine/test.h&gt;
#include &lt;winbase.h&gt;

/* Posiblemente aquí funciones auxiliares y definiciones */

START_TEST(paths)
{
   /* Ahí escriba sus pruebas o póngala en funciones que llamará desde
    * ahí
    */
}
</screen>
      </para>
      <para>
        El punto de entrada de la prueba es la sección START_TEST. Aquí
	es donde comienza la ejecución. Puede poner todas sus pruebas
	en esta sección pero sería mejor dividir las pruebas relacionadas
	en funciones que pudiera llamar desde la sección START_TEST.
	El parámetro de START_TEST debe coincidir con el nombre del
	archivo C. Así que en el ejemplo anterior el archivo C se
	debería llamar <filename>paths.c</>.
      </para>
      <para>
        Las pruebas deben comenzar incluyendo en la cabecera
	<filename>wine/test.h</>. Esta cabecera le proporcionará
	acceso a todas las funciones de las estructuras de las
	pruebas. Entonces puede incluir la cabecera de windows
	que necesita, pero asegurese de no incluir ninguna cabecera
	específica de Unix o Wine: las pruebas se deben compilar en
	Windows.
      </para>
<!-- FIXME: FIXME: ¿Podemos incluir ahora windows.h? Nosotros debemos de ser capaces
pero generalmente _WINE_ está definido así haciéndolo imposible..-->
<!-- FIXME: Añada recomendaciones sobre qué imprimir en caso de fallo: infórmese -->
      <para>
        Usted puede utilizar <function>trace</> para imprimir mensajes
	informativos. Observe que estos mensajes solo se imprimirán si
	se está usando 'runtest -v'.
<screen>
  trace("testing GlobalAddAtomA");
  trace("foo=%d",foo);
</screen>
      </para>
      <para>
        A continuación llame a las funciones y utilice <function>ok</>
	para asegurarse de que se comportan como es de esperar:
<screen>
  ATOM atom = GlobalAddAtomA( "foobar" );
  ok( GlobalFindAtomA( "foobar" ) == atom, "could not find atom foobar" );
  ok( GlobalFindAtomA( "FOOBAR" ) == atom, "could not find atom FOOBAR" );
</screen>
        El primer parámetro de <function>ok</> es una expresión que debe
	evaluar para verificar si la prueba tuvo éxito. El siguiente parámetro
	es una secuencia de formato compatible printf que se visualiza en
	caso de que falle la prueba, y los siguientes parámetros opcionales
	dependen de la secuencia del formato.
      </para>
      <para>
        Es importante visualizar5 un mensaje informativo cuando falle una prueba:
	un buen mensaje de error ayudará a un desarrollador de Wine a identificar
	con exactitud què fallò sin tener que añadir muchas más printfs. Por
	ejemplo puede resultar ùtil imprimir el còdigo de error si resulta
	oportuno, o el valor esperado y el valor efectivo. En relación a esto
	usted puede desear definir una macro para algunas pruebas como la
	siguiente:
<screen>
#define eq(received, expected, label, type) \
        ok((received) == (expected), "%s: got " type " instead of " type, (label),(received),(expected))

...

eq( b, curr_val, "SPI_{GET,SET}BEEP", "%d" );
</screen>
       </para>
       <para>
         Note
       </para>
    </sect1>


    <sect1 id="testing-platforms">
      <title>Manipulación de problemas de plataforma</title>
      <para>
        Algunas correcciones se pueden escribir antes de que funcione
	con éxito en Wine. Sin un cierto mecanismo, tales correcciones
	generarían potencialmente cientos de fallos durante meses cada
	vez que se ejecutasen las pruebas. Esto haría difìcil detectar
	nuevos fallos causados por una regresiòn, o detectar que un
	parche corrige un problema de larga duraciòn.
      </para>
      <para>
        Asì el marco de pruebas de Wine tiene el concepto de plataformas
	y los grupos de correcciones se pueden declarar como fallos
	esperados en algunas de ellas. En el caso màs corriente, se
	declararìa un grupo de pruebas como que se espera que fallen
	en Wine. Para hacer asì, utilice la siguiente construcciòn:
<screen>
todo_wine {
    SetLastError( 0xdeadbeef );
    ok( GlobalAddAtomA(0) == 0 && GetLastError() == 0xdeadbeef, "failed to add atom 0" );
}
</screen>
        Rn Windows se ejecutaría la correcciòn citada sin problemas,
	pero en Wine es de esperar que falle, y no motive el fallo de
	toda la prueba. No obstante, si esta correcciòn tuviera èxito
	en Wine, provocarìa el fallo de la prueba, asì que facilitar
	la detección cuando se haya cambiado algo para fijar un error.
	Nòtese tambièn que las correcciones imprevistas se cuentan a
	parte de las correcciones regulares y asì las estadìsticas
	siguen significativas. Para terminar nòtese que las secciones
	imprevistas se pueden anidar y así si una prueba falla solo en
	cygwin y en plataformas reactos, se puede escribir:
<screen>
todo("cygwin") {
    todo("reactos") {
        ...
    }
}
</screen>
        <!-- FIXME: ¿Tendremos plataformas tales como reactos, cygwin, freebsd y co? -->
        Pero las plataformas específicas no deben de ser conectadas dentro
	de una sección todo_wine ya que resultaría redundante.
      </para>
      <para>
        Cuando escriba pruebas encontrarà diferencias entre las plataformas
	Windows 9x y Windows NT. Tales diferencias se tratarán de manera
	distinta en las versiones de las plataformas ya mencionadas. Se debe
	recordar en particular que el objetivo de Wine no es ser un clon de
	ninguna versión de Windows concreta sino ejecutar programas de windows
	en Unix.
      </para>
      <para>
        Asì si un API devulve un còdigo de error diferente en las plataformas
	Windows 9x y NT, su comprobaciòn debe verificar que Wine devuelve
	según sea uno u otro:
<screen>
ok ( GetLastError() == WIN9X_ERROR || GetLastError() == NT_ERROR, ...);
</screen>
      </para>
      <para>
        Si un API está presente sàlo en algunas plataformas de Windows,
	entonces utilice LoadLibrary y GedProcAddress para comprobar que
	está cargado y ejecútelo. Recuerde, las pruebas se deben de
	ejecutar en todas las plataformas de Windows. De igual manera,
	las pruebas de conformidad no deben de tratar de relacionar la
	versión de Windows devuelta por GetVersion con cualquier API
	dado estè instalado o no. De nuevo, el objetivo de Wine es
	ejecutar aplicaciones de Windows (que no necesitan tales pruebas)
	y no ser un clon de una versión concreta de Windows.
      </para>
      <para>
        FIXME: ¿Qué sucede con las correcciones que hacen que se cuelgue un proceso por un error?
      </para>
    </sect1>


<!-- FIXME: Estrategias para comprobar los hilos, comprobar el material
de la red, manejo de archivos, eq macro....>

  </chapter>

<!-- Conserve este comentario al final del archivo.
Local variables:
mode: sgml
sgml-parent-document:("wine-doc.sgml" "set" "book" "part" "chapter" "")
End:
-->

