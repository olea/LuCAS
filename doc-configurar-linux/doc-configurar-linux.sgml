<!doctype linuxdoc system>

<article>

<title>Configurando Nuestro Sistema
<author>Francisco José Avila Bermejo 
<htmlurl url="mailto:x2042949@turing.ugr.es" name="x2042949@turing.ugr.es">
<date>$Id: doc-configurar-linux.sgml,v 1.1.1.1 2002/06/11 11:52:05 olea Exp $
<abstract>Intentaré explicar como se configuran las aplicaciones más
comunes en Linux, de forma que se adapten a nuestro entorno de trabajo
e idioma.  

Recuerda que para pasar este documento de este formato a otro legible,
como HTML, hay que ejecutar <tt>'sgml2html --language=es
configurando.sgml'</tt>. O mejor aún, ejecutar <tt>'make'</tt> y ya se
encargará de generar los ficheros correspondientes. 


<sect>Lo principal
<p>

<sect1>bash, less y ls<label id="less"> <label id="bash_profile">
<p>
Tienes que añadir las siguientes lineas a <tt>~/.bash_profile</tt>:

<tscreen><code>
# Para españolizar Linux. 
export LANG=es
export LESSCHARSET=latin1
</code></tscreen>

Con esto conseguimos decirle a Linux que usamos los caracteres
españoles (ISO-8859-1 o Latin1) y que estamos en España. También
indicamos a <tt>less</tt> que muestre correctamente esto caracteres
latinos. 

Pero si tu distribucion no te instala bien las locales,
junto a esas lineas puedes añadir:

<tscreen><code>
export LC_CTYPE=ISO-8859-1
export LC_ALL=ES_es
</code></tscreen>

De todas formas, si aún no funcionan bien, deberemos ejecutar como
root lo siguiente: 

<tscreen><verb>
$ localedef -f ISO-8859-1 -i es_ES es
</verb></tscreen>

Lo primero es obligatorio, mientras que lo segundo y lo tercero habrá
que hacerlo si con lo primero no va bien.

Para ver los ficheros que nos muestra <tt>ls</tt> de colores según el
tipo del que sea, añadiremos las siguientes líneas a nuestro
<tt>~/.bashrc</tt>: 

<tscreen><code>
# Algunos alias mios.
alias ls='ls -F -N --color=tty'
</code></tscreen>

También podemos hacer que se coloreen otros fichero por otro tipo de
extensión, por ejemplo, añadiremos al fichero <tt>~/.bash_profile</tt>:

<tscreen><code>
# Para colorear ficheros con cierta extensión.
export LS_COLORS="*.tgz=31":"*.gz=31":"*.tar=31"
</code></tscreen>

Con lo que los fichero con extensión <tt>.tgz</tt> saldrán rojos.

Añade las siguientes líneas a <tt>~/.bashrc</tt> para poner un prompt
más útil:

<tscreen><code>
# Ponemos un prompt guays.
PS1='(\u:\#) \w>\\$ ' 
</code></tscreen>

Otro prompt más requetechulo lo pones así:

<tscreen><verb>
PS1='\[\033[36m\][\u:\#] \[\033[33m\][\w]\$\[\033[0m\] '
</verb></tscreen>

Para poner negritas se usa la cadena <tt>\033[1m</tt> y cuando acabas y
quieres volver a "normal" <tt>\033[0m</tt>.

Para que funcionen las teclas Inicio y Fin, crea el fichero
<tt>~/.inputrc</tt>: 

<tscreen><code>
# Algunas opciones para caracteres españoles. 
set horizontal-scroll-mode on
# Lo podemos poner 'audible' o 'visible'.
set bell-style audible
set meta-flag on
set output-meta on
set convert-meta off
set horizontal-scroll-mode on

# Para que funcionen las teclas Inicio - Fin - ...
"\e[1~" beginning-of-line
"\e[2~"
"\e[3~" delete-char
"\e[4~" end-of-line
"\e[5~"
"\e[6~"

# Algunas para rxvt.
"\e[7~":beginning-of-line
"\e[8~":end-of-line

# También en las xterms.
"\e[H" beginning-of-line
"\e[F" end-of-line 
</code></tscreen>

Para que además se puedan ver algunos caracteres como la A acentuada
(Á) en la terminal en modo texto, habra que añadir en el fichero 
<tt>/etc/rc.d/rc.local</tt> la siguiente línea:

<tscreen><code>
/usr/bin/setfont lat1u-16.psf 
</code></tscreen>

En la terminal gráfica (xterm) no hace falta hacer esto.


<sect1>Ponerle un nombre a nuestro ordenador
<p>
En el <tt>control-panel</tt> ejecutamos la utilidad 
<tt>Network Configurator</tt>. Primero configuraremos los nombres. En 
<tt>Hostname</tt> cambiamos <tt>localhost.localdomain</tt> por algún
otro nombre como <tt>antares.linux.es</tt>. Ahora 
configuraremos los hosts. Para ello pulsamos el boton
<tt>Hosts</tt>. La idea es que la cosa quede así:

<tscreen><verb>
         IP            Name              Nicknames
  -----------------------------------------------------------
    127.0.0.1       localhost	        localhost.localdomain
    127.0.0.2	    antares.linux.es	antares
</verb></tscreen>



<sect>Las X Windows 
<p>

<sect1>Color en las <tt>XTerm</tt>s
<p>
Debemos añadir al fichero <ref id="bash_profile" name="~/.bash_profile"> 
las siguientes líneas:

<tscreen><code>
# Para que salgan la cosas en color en las terminales X.
export COLORTERM=1
</code></tscreen>

Ahora al ejecutar el Midnight Commander o el Lynx, por ejemplo, habrá
color en la pantalla.


<sect1>Las tildes y las X
<p>
Antes de nada, decir que el KDE 1.0 y el Netscape 4.05 ya funcionan bien
con los acentos sin parches ni nada.

<itemize>
<item>Tenemos dos posibilidades, o componemos las vocales acentudas con con
AltGr + <it>vocal</it>, como se detalla a continuación:

Yo he creado el fichero <tt>~/.Xmodmap</tt>:

<tscreen><code>
! [F12] = Compose (Componer carácter)
keycode 0x60 = Multi_key
! AltGr + <vocal> = <vocal con acento agudo>; 
keycode 26 = e E eacute Eacute
keycode 30 = u U uacute Uacute
keycode 31 = i I iacute Iacute
keycode 32 = o O oacute Oacute
keycode 38 = a A aacute Aacute
keycode 55 = v V udiaeresis Udiaeresis
</code></tscreen>

También deberemos agregar la línea 

<tscreen><verb>
xmodmap ~/.Xmodmap
</verb></tscreen>

al fichero <tt>~/.xinitrc</tt>.

Arranco las X y para escribir <tt>á</tt> hago <tt>AltGr + a</tt>, por
ejemplo. Para poner símbolo de © pulso F12+c+o. Simple, ¿verdad?.

<item>O instalamos las bibliotecas parcheadas de Tomas Quinot. Para
ello primeramente habría que sacar una copia de las bibliotecas
originales, por lo que pueda pasar. 

El fichero con la biblioteca parcheada para la libc6 (o glibc) se
encuentra en 
<htmlurl url="http://web.fdn.fr/~tquinot/libX11-RH5.tar.gz"
name="http://web.fdn.fr/~tquinot/libX11-RH5.tar.gz">. La
descomprimimos en un directorio temporal y el fichero resultante que
será <tt>libX11.so.6.1</tt> lo ponemos en
<tt>/usr/X11R6/lib</tt>. Este parche es necesario para los programas
basados en la nueva biblioteca glibc (libc6).

El fichero con la biblioteca parcheada para la libc5 se encuentra en 
<htmlurl url="http://web.fdn.fr/~tquinot/libX11-XF3.3.1.tar.gz"
name="http://web.fdn.fr/~tquinot/libX11-XF3.3.1.tar.gz">. La
descomprimimos en otro directorio temporal y el fichero resultante que
será también uno con el mombre <tt>libX11.so.6.1</tt> lo ponemos en
<tt>/usr/i486-linux-libc5/lib</tt>. Este otro parche es necesario para
los programas basados en la biblioteca libc5, más antigua, pero
utilizada por Netscape 4.04 y StarOffice 4.0-2.

Una vez copiadas, se han de actualizar las bibliotecas:

<tscreen><verb>
# ldconfig
</verb></tscreen>

Ahora tendremos que modificar el fichero
<tt>/etc/X11/XF86Config</tt>. En la sección <tt>Keyboard</tt> hay que
dejarlo de la siguiente manera:

<tscreen><code>
# To set the LeftAlt to Meta, RightAlt key to ModeShift, 
# RightCtl key to Compose, and ScrollLock key to ModeLock:

    LeftAlt        Meta
   RightAlt        ModeShift
   ScrollLock      ModeLock
   RightCtl        Control

# To disable the XKEYBOARD extension, uncomment XkbDisable.

    XkbDisable
</code></tscreen>

Es muy importante sobre todo descomentar esta última línea para poder
hacer uso de las teclas muertas. Debemos asegurarnos que tenemos el
<tt>XkbLayout</tt> como <tt>"es"</tt>. 

Una vez hecho esto hay que crear un fichero de configuración del
teclado español <tt>/etc/X11/Xmodmap</tt> (ámbito global), o como
<tt>~/.Xmodmap</tt> (ámbito local). Si lo hacemos de esta última
manera, deberemos agregar la línea 

<tscreen><verb>
xmodmap ~/.Xmodmap
</verb></tscreen>

al fichero <tt>~/.xinitrc</tt>. El contenido del fichero
<tt>.Xmodmap</tt> lo podeis ver <htmlurl url="Xmodmap" name="aquí">
mismo. Pero si al poner el parche teneis problemas con la tecla
BackSpace (la de borrar) en las X, lo podeis solucinar añadir a
nuestro <tt>~/.xinitrc</tt> la siguiente línea: 

<tscreen><verb>
xmodmap -e "keycode 22 = BackSpace"
</verb></tscreen>

</itemize>

Pues nada, ya no teneis excusa para poner las tildes donde
correspondan ;-)


<sect1>Arrancando el KDE<label id="kde">
<p>
Después de haberlo instalado, en mi fichero <tt>~/.xinitrc</tt> tengo
lo siguiente:

<tscreen><code>
xmodmap .Xmodmap
startkde
</code></tscreen>

Además, en el fichero <ref id="bash_profile" name="~/.bash_profile">
debemos añadir lo siguiente:

<tscreen><code>
# Para el KDE.
export KDEDIR=/opt/kde
export PATH=$PATH:/opt/kde/bin   
</code></tscreen>




<sect>Editores, Procesadores y Formateadores de Texto
<p>

<sect1>Emacs <label id="emacs">
<p>
Crea el fichero <tt>~/.emacs</tt> con:

<tscreen><code>
;; No ignora el 8-bit en la introducción de caracteres.
(set-input-mode nil nil 1)

;; No imprime los caracteres no ASCII como secuencia de escape.
(standard-display-european t)

;; Establece el modo de acentuación ISO-8859-1.
(iso-accents-mode)

;; En X-Window...
(cond (window-system
  ;; ... cargar un paquete para resaltado según sintaxis
  (add-hook 'find-file-hooks 'turn-on-font-lock)
  (global-font-lock-mode t)
)) 
</code></tscreen>

Con esto se consigue que cuando edites un fichero de C, por ejemplo, la
sintaxis salga coloreada. Pero además podréis poner acentos y leer escritos
con acentos. De todas formas, si habeis puesto lo de los locales en 
<ref id="bash_profile" name="~/.bash_profile">, deberíais poder poner
y leer caracteres acentuados, eñes y demás ya, pero si ejecutas Emacs desde
la terminal de texto, no sale bien, de modo que los pones y ya está. Funcionará
desde la terminal de texto y desde X Windows.

Si quieres que Emacs cambie de línea solo (lo del wrap-word), tenemos que
teclear lo siguiente:

<tscreen><code>
M-x auto-fill-mode
</code></tscreen>

Pero si quiere que esté activo por defecto, pon en <tt>~/.emacs</tt>:

<tscreen><code>
;; Establece el "wrap word" por defecto. 
(set 'text-mode-hook 'turn-on-auto-fill)
</code></tscreen>

Si vamos a utilizar TeX o LaTeX es buena idea instalar el paquete AUC TeX,
que nos permite mejorar Emacs para este fin. Después de haber instalado dicho
paquete (que está disponible en formato RPM), tenemos que añadir al fichero
<tt>~/.emacs</tt> la siguiente línea:

<tscreen><code>
;; Para utilizar el paquete AUX TeX.
(require 'tex-site)
</code></tscreen>

Ahora al editar un fichero de TeX/LaTeX tendremos nuevos y poderosos
menús.

Para que te funcione la tecla <tt>Supr</tt> (suprimir) y las de
<tt>Inicio</tt> y <tt>Fin</tt> en Emacs, añade
lo siguiente al <tt>~/.emacs</tt>:

<tscreen><code>
;; Para que funcione algunas teclas de la forma que nos gusta.
(global-set-key [delete] 'delete-char)
(global-set-key [home] 'beginning-of-line)
(global-set-key [end] 'end-of-line)
</code></tscreen>

De esta misma forma podemos programar las teclas de funcion, por
ejemplo, para que F2 guarde un documento, F3 lea un fichero, etc.

Si lo que deseamos es que el scroll no sea a saltos, sino linea a
linea:

<tscreen><code>
;; Para que el scroll del texto sea línea a línea.
(custom-set-variables '(scroll-conservatively 1 t))
</code></tscreen>

Si programamos en Java, tenemos un paquete de funciones para Emacs que
nos puede facilitar mucho la vida. Se llama JDE y la última versión es
la 2.0 y corrige algunos errores molestos de la versón 1.9.9. Para
instalar este paquete, que lo podemos encontrar en 
<htmlurl url="http://sunsite.auc.dk/jde/"
name="http://sunsite.auc.dk/jde/">. Lo podemos instalar en el
directorio <tt>/usr/local/jde</tt>. Debemos añadir las siguientes
líneas al fichero <tt>~/.emacs</tt>:

<tscreen><code>
;; Configuración del paquete JDE.
(setq load-path (nconc '("/opt/jde-2.0") load-path))
(require 'jde)

(custom-set-variables
'(jde-jdk-doc-url "file:/opt/jdk1.1.6/docs/index.html"))
</code></tscreen>

Donde indicaremos la localización del paquete JDE y la de la
documentación del JDK. Hay que saber que para visualizar la
documentación dell JDK debe de estar previamente abierto
Netscape. Ignoro si funciona con otro navegador.

Para decirle al lector de news que lleva Emacs, llamado Gnus, la
dirección del servidor de NNTP:

<tscreen><code>
; Configuramos el servidor del lector de news Gnus.
(setq gnus-select-method '(nntp "servidor-de-NNTP"))
</code></tscreen>

Para establece Emacs como nuestro editor por defecto, pondremos lo
siguiente en nuestro <ref id="bash_profile" name="~/.bash_profile">:

<tscreen><code>
# Para poner Emacs como editor por defecto.
export EDITOR=emacs
</code></tscreen>


<sect1>teTeX
<p>
Nada más fácil que ejcutar <tt>texconfig</tt>. Lo primero es ir a 
<tt>PREF</tt>, después a <tt>EDITOR</tt> y poner <tt>emacs</tt>. Ahora
vamos a <tt>PAGER</tt> y ponemos <tt>less</tt>. Con esto conseguimos
que use <ref id="emacs" name="Emacs"> como editor de los ficheros de 
configuración y <ref id="less" name="less"> como paginador. Hacemos un
<tt>REHASH</tt>. Me parece que esto último no es necesario, pero no
hace daño ;-)

Escogemos la opción <tt>HYPHEN</tt>. Nos saldrá un fichero de
configuración en el que tendermos que hacer unos cambios. Ponemos un 
<tt>%</tt> delante de <tt>german</tt> y quitamos el <tt>%</tt> que
está delante de <tt>spanish</tt>. El caracter <tt>%</tt> hace
que lo que vaya detra lo tome como un comentario. Salimos del editor y
se ejecutaran unos programas que configurarán nuestro sistema teTeX.

Vamos la opcion <tt>MODE</tt> y seleccionamos de la lista el modo que
se ajuste a nuestra impresora, de acuerdo con el modelo y la resolución.

Escogemos <tt>XDVI</tt> y podremos elegir el tamaño del papel. 
Normalmente <tt>a4</tt>.

Ahora <tt>DVIPS</tt>, y si sólo tenemos una impresora, vamos a 
<tt>GLOBAL</tt>. Nos pregunta el tamaño del papel (otra vez a4). Vamos a 
<tt>MODE</tt> y nos preguntará si debe usar el modo escogido
anteriormente para la impresora por defecto. Le diremos que sí. En
<tt>CMD</tt> ponemos <tt>lpr</tt>

Pues ya está hecho la cosa. Las primeras veces que trabajemos com
LaTeX, nos creará los tipos de letras que le hace falta. Esto tarda un
poquito, pero sólo lo hace la primera vez.


<sect1>Ispell <label id="ispell">
<p>
Como el diccionario de español no suele formar parte de las distribuciones
de Linux, nos lo bajaremos de 
<htmlurl url="ftp://ftp.fi.upm.es/pub/unix/espa~nol.tar.gz"
name="ftp://ftp.fi.upm.es/pub/unix/espa~nol.tar.gz">. Una vez descomprimido
y dando por hecho que ya tenemos instalado <tt>Ispell</tt>, hay que
ejecutar las siguientes instrucciones (en el directorio que se crea al
descomprimir el fichero):

<tscreen><verb>
$ make build
$ mv espa~nol.aff /usr/lib/ispell/español.aff
$ mv espa~nol.hash /usr/lib/ispell/español.hash 
</verb></tscreen>

A partir de este momento dispondremos de un potente diccionario con todas
las entradas de la última edición del Diccionario de la Real Academia 
Española, más un buen número de lexemas informáticos (entre los que se 
encuentra "Linux").

La forma de usar Ispell es muy sencilla. Con 

<tscreen><verb>
ispell nombre-fichero
</verb></tscreen>

utilizaremos el diccionario inglés para revisar
<tt>nombre-fichero</tt>, mientras que con 

<tscreen><verb>
ispell -d español -T latin1 nombre-fichero
</verb></tscreen>

invocaremos al diccionario con la lengua de Cervantes. Hay opciones 
específicas para corregir documentos escritos en LaTeX. 


<sect1>StarOffice 4.0
<p>
Debemos instalar primero las libc versión 5.4.33 por lo menos. Yo he
instalado la versión 5.4.44 y funciona bien. Toda esta pirula sólo
hace falta para el programa de instalación. Podemos crear un
directorio llamado <tt>/opt/Office40</tt> dentro del cual se instalará
el programa. Por lo pronto descomprimiremos ahí mismo los archivos de
la biblioteca libc. Se creará, por tanto, el directorio
<tt>/opt/Office40/lib</tt>. Dentro de éste habrá los ficheros
<tt>libc.so.5.4.44</tt> y <tt>libm.so.5.0.9</tt>. El otro directorio
<tt>/opt/Office40/usr</tt> lo podemos borrar. 

Ahora ejecutamos desde el directorio <tt>/opt/Office40/lib</tt>:

<tscreen><verb>
$ ln -s libc.so.5.4.44 libc.so.5
</verb></tscreen>

También deberemos ejecutar:

<tscreen><verb>
$ export LD_LIBRARY_PATH=/opt/Office40/lib:$LD_LIBRARY_PATH
</verb></tscreen>

Por fin podemos ejecutar ya el programa de instalación como root:

<tscreen><verb>
$ ./setup /net
</verb></tscreen>

Para poder utilizar este programa por cada usuario, cada uno deberá
ejecutar:

<tscreen><verb>
$ export LD_LIBRARY_PATH=/opt/Office40/lib:$LD_LIBRARY_PATH
$ /opt/Office40/bin/setup
</verb></tscreen>

Y elegimos 'Installation from Net or CD'. Se creará un directorio
<tt>~/Office40</tt> donde se copiarán algunos ficheros. No nos queda
más que añadir a nuestro 
<ref id="bash_profile" name="~/.bash_profile"> 
las siguientes líneas:

<tscreen><code>
# Para el StarOffice.
export PATH=$PATH:~/Office40/bin
</code></tscreen>

El programa se ejecuta como:

<tscreen><verb>
$ soffice
</verb></tscreen>


<sect1>a2ps
<p>
Este programa nos es muy útil a la hora de imprimir texto, y sobre
todo si son códigos de programas. Genera un documentos Postscript que
puede contener varias páginas por folio y las palabras reservadas del
lenguaje se imprimen resaltadas. Por ejemplo, la siguiente orden:

<tscreen><verb>
$ a2ps prog.c --media=A4dj -2 --pretty-print=c -o prog.ps
</verb></tscreen>

crea un fichero <tt>prog.ps</tt> con el código fuente de
<tt>prog.c</tt>, imprimiendo 2 páginas por folio. Se indica
explícitamente que el fichero fuentes está en lenguaje C. Las palabras
reservadas de este lenguaje aparecen resaltadas. Si no le indicamos
explícitamente el lenguaje, el programa lo puede deducir a partir de
la extensión del fichero fuente. Si no le ponemos el modificador
"<tt>-o &lt;fichero&gt;</tt>", mandará la salida del programa directamente a
la impresora por defecto. 

No tiene mayor complicación, pero lo verdaderamente útil de esto es el
modificador <tt>--media=A4dj</tt>, que le indica que el fichero 
Postcript se genere para un tipo de folio determinado. Si ponemos que
lo genere para <it>A4</it>, en algunas impresoras de chorro de tinta,
como las HP o las Epson, se come parte de lo que debe imprimir por
caer fuera del área imprimible del folio. Poniendo que se genere para
<it>A4dj</it>, se consigue que todo lo que se imprime caiga dentro del
área imprimible del folio y no corta nada.

<sect1>mpage
<p>
Hace que se impriman múltiples páginas por folio. Trabaja con ficheros
Postcript. Con la orden:

<tscreen><verb>
$ mpage -2 -bA4 -m45b30r tab.ps > pepe.ps 
</verb></tscreen>

se consigue que se genere una salida en formato Postscript que la
redireccionamos al fichero <it>pepe.ps</it>. Toma como entrada el
fichero <it>tab.ps</it> y hace que haya dos páginas por folio. La
salida se genera para un A4. Y ahora viene también lo importante: los
márgenes. Por defecto hay un margen entre el borde del folio y el
marco del texto de 20 puntos. En el caso de las impresoras de chorro
de tinta como las HP y las Epson, hay que ajustar esos márgenes para
que caigan dentro del área imprimible del folio. Poniendo un margen
inferior de 45 puntos y el derecho de 30, se consigue que no salga
nada cortado.




<sect>El correo
<p>

<sect1>Pine<label id="pine"> 
<p>
La primera vez que ejecutamos <tt>Pine</tt>, nos creará los
directorios necesarios de forma automática. El correo se guardará en
el directorio <tt>&tilde;/mail</tt>. Para hacer las modificaciones en
la configuración, en la pantalla principal escogemos <tt>SETUP</tt> y 
después pulsamos la letra <tt>C</tt>. Cuando hayamos hecho las
modificaciones pulsamos la letra <tt>E</tt> y después la letra
<tt>Y</tt> para validar los cambios. 

Para poder usar acentos y demás, en <tt>character-set</tt> ponemos 
<tt>ISO-8859-1</tt>.

Para poder usar el ratón desde X Windows, en <tt>feature-list</tt>, 
seleccionamos <tt>enable-mouse-in-xterm</tt>. Lo malo es que no vamos
a poder cortar y pegar el texto con el ratón :-(

Para que el correo ya leido lo ponga en otro lado, en
<tt>feature-list</tt>, seleccionamos <tt>auto-move-read-msgs</tt> y en
<tt>read-message-folder</tt> ponemos <tt>correo-leido</tt>, por
ejemplo, como nombre de la carpeta. Lo que hace es poner ahí los
mensajes leidos y los borra de la carpeta <tt>INBOX</tt>.

Para usar <ref id="ispell" name="Ispell"> como corrector ortográfico, hay
que poner en la opción <tt>speller</tt>, pues 
<tt>ispell -d español -T latin1</tt>.

<label id="from">
Si queremos poder modificar la cabecera <tt>From</tt> de los mensajes,
el Pine que trae Red Hat 5.0 no viene compilado con esa opción, por lo
que deberemos recompilarlo habilitando dicha opción. Nada más fácil
que instalar los fuentes y hacer un par de cosillas. Todo esto lo
haremos en modo root. Al instalar los fuentes los podemos encontrar en
<tt>/usr/src/redhat/SOURCES</tt>. Vienen empaquetados en un fichero
tar comprimido (*.tar.gz). Lo descomprimimos con:

<tscreen><verb>
$ tar zxvf pineX.XX.tar.gz
</verb></tscreen>

Aplicamos los parches:

<tscreen><verb>
$ patch < pineX.XX-glibc.patch
$ patch < pineX.XX-lock.patch
$ patch < pineX.XX-termios.patch
</verb></tscreen>

Vamos al recién creado directorio <tt>pineX.XX/pine</tt> y editamos el 
fichero <tt>send.c</tt>. Tenemos que añadir la siguiente línea por el 
principio del fichero, en la zona de los <tt>define</tt>. Si sabes
algo de <tt>C</tt> ya sabrás donde ponerla.

<tscreen><code>
#define ALLOW_CHANGING_FROM
</code></tscreen>

Vamos al directorio anterior y ejecutamos:

<tscreen><verb>
$ ./build lnx
</verb></tscreen>

Si todo ha ido bien, en el directorio <tt>pineX.XX/bin</tt> estarán
los ejecutables. El único que hace falta coger es <tt>pine</tt>, por
lo que lo copiaremos al directorio <tt>/usr/bin</tt>. Ahora cuando
utilicemos Pine ya será la nueva versión.

Para modificar la cebecera <tt>From</tt> de los mensajes, en la opción
de configuración <tt>customized-hdrs</tt> ponemos por ejemplo 
<tt>From:mi@direccion.de.correo</tt>, o sea, nuestra dirección de correo.


<sect1>Fetchmail<label id="fetchmail">
<p>
Como no siempre estamos conectados a Internet, 
<ref id="sendmail" name="Sendmail"> no es capaz 
de recibir al correo automáticamente, de modo que usamos este programa 
que recoge el correo de donde le digamos y se lo pasa a Sendmail. Crea
el fichero <tt>~/.fetchmailrc</tt>:

<tscreen><code>
# Recogemos el correo del servidor.
poll <servidor-de-correo>
proto pop3
user <usuario>
pass <password> 
</code></tscreen>

Donde:

<descrip>
<tag>servidor-de-correo,</tag>
es la dirección de nuestro servidor POP3 de correo.
<tag>usuario,</tag>
es el nombre de la cuenta POP3. 
<tag>password,</tag>
es nuestro password de acceso al servidor. 
</descrip>

Lo bueno que tiene es que podemos bajarnos el correo de varias cuentas
a la vez poniendo varias veces lo de:

<tscreen><code>
poll <servidor_de_correo>
proto pop3
user <usuario>
pass <password> 
</code></tscreen>

Este fichero <tt>~/fetchmailrc</tt> tiene que tener los permisos 0600.

Para bajarse el correo hay que ejecutar:

<tscreen><verb>
$ fetchmail
</verb></tscreen>

Esto es la forma más fácil rápida y sin problemas (y la que yo
uso). Pero si somos más guays podemos hacer que fetchmail corra como un 
demonio (no es que vaya a correr un montón de rápido ;-). Para ello 
incluimos al principio del fichero <tt>&tilde;/.fetchmailrc</tt>,
por ejemplo, antes del primer <tt>poll</tt> la orden:

<tscreen><code>
set daemon 300
</code></tscreen>

Lo del 300 es el tiempo (en segundos) entre cada búsqueda de nuevo correo.

Aquí podemos plantearnos la cosa de dos manera:

<itemize>
<item>
El demonio se va a crear cuando entremos en nuestra cuenta, y va
a morir cuando salgamos de ella. Pero puedes pensar ``y si abro dos 
sesiones a la vez''. ¡No pasa nada!, añade estas líneas al fichero 
<tt>~/.bash_profile</tt>:

<tscreen><code>
# Activamos al demonio fetchmail si ya no está activo.
if [ -f ~/.fetchmail.LOCK ]; then
  echo
  echo "El \`·_·' Fetchmail ya está activo."
  echo

  typeset -i NUMERO 

  read -r NUMERO < ~/.fetchmail.LOCK 

  NUMERO=NUMERO+1 

  echo $NUMERO > ~/.fetchmail.LOCK
else
  echo
  echo "Creando el \`·_·' Fetchmail."
  echo 

  fetchmail -v
  echo 1 > ~/.fetchmail.LOCK
fi
</code></tscreen>

Y estas a <tt>~/.bash_logout</tt>:

<tscreen><code>
# Decidimos si el demonio fetchmail debe morir ahora o no.
if [ -f ~/.fetchmail.LOCK ]; then
  typeset -i NUMERO

  read -r NUMERO < ~/.fetchmail.LOCK

  if [ $NUMERO -eq 1 ]; then
    echo
    echo "Matando al \`·_·' Fetchmail."
    echo

    fetchmail -q

    rm ~/.fetchmail.LOCK
  else
    echo
    echo "El \`·_·' Fetchmail aún tiene que vivir."
    echo 

    NUMERO=NUMERO-1
    echo $NUMERO > ~/.fetchmail.LOCK
  fi
fi 
</code></tscreen>

Las podemos añadir al final mismo de los ficheros.

<item>
O podemos hacer que se cree el demonio en un momento dado, por 
ejemplo, cuando nos conectamos a la red y matarlo cuando vayamos a 
desconectarnos. En este caso al conectarnos ejecutaremos 
<tt>fetchmail</tt> como demonio y cuando nos vayamos a deconectar, 
ejecutamos <tt>fetchmail -q</tt>.
</itemize>

<quote><em>
Este código fue desarrollado por mi menda y se distribuye bajo 
licencia GPL ;-) Lo he hecho en un rato y hace un montón de tiempo que 
no programaba shell scripts, de modo que no me los critiqueis
mucho. De todas formas son bienvenidos los comentarios al
respecto.</em></quote>

Pero lo realmete ideal sería que desde <tt>root</tt> se recogiera y se
enviara el correo, de modo que lo mejor es hacer lo del
<tt>fetchmail</tt> desde la cuenta del superusuario. En el fichero
<tt>.fetchmailrc</tt> del directorio raiz de root escribimos lo siguiente: 

<tscreen><code>
defaults   # Comandos comunes a todos los servidores.
fetchall   # Recoger todos los mensajes.
flush      # Borra todos los mensajes ya recogidos.
pass8bits  # Indica que el cuerpo del mensaje usa el juego de
           # caracteres de 8 bits, fundamenta para nuestra lengua.

poll <servidor_de_correo> # Indica el servidor a llamar.
  proto pop3              # Protocolo que usa el servidor IMAP, POP2, ...
  user <usuario>          # Nombre del usuario (cuenta) en este servidor.
  pass <password>         # Password para esta cuenta de correo.
  to <usuario_local>      # A que cuenta de usuario local han de entregarse los
			  # mensajes.
</code></tscreen>

Al ejecutar 

<tscreen><verb>
$ fetchmail
</verb></tscreen>

como <tt>root</tt> se recogerá el correo y se lo enviará a
<tt>usuario_local</tt>.

Como puedes comprobar, las cuatro primera instrucciones no están en el
otro fichero <tt>.fetchmailrc</tt>. Si bien no son necesarias, es
bueno ponerlas, de modo que se ponen y ya está. Por lo visto la del
<tt>pass8bits</tt> hay que ponerla relmente, pero yo he estado un
montón de tiempo recogiendo el correo sin esas cuatro líneas del
principio y no he tenido ningún problema, al menos eso creo. Como se
ve, la primera línea indica que las tres
siguientes se tienen que considerar como las opciones por defecto en
cada conexión que pongamos (lo del <tt>poll</tt>). Se supone que las
opciones <tt>fetchall</tt> y <tt>flush</tt> son las que vienen por
defecto y no haría falta ponerlas. Si alguien tiene algún comentario
al respecto, agradecería un e-mail.


<sect1>Sendmail <label id="sendmail">
<p>
Podemos hacer la cosa de dos manera. Primero expongo la parte común. 
Debemos hacer unas pequeñas modificaciones en el fichero 
<tt>/etc/sendmail.cf</tt>. Buscamos la línea:

<tscreen><code>
# "Smart" relay host (may be null)
DS
</code></tscreen>

y cambiarla de forma que aparezca nuestro servidor SMTP de correo, que
en mi caso es <tt>smtp.ctv.es</tt>:

<tscreen><code>
# "Smart" relay host (may be null)
DSsmtp.ctv.es
</code></tscreen>

Con esto hacemos que el correo saliente vaya a nuestro servidor SMTP y
éste se encargará de enviarlo a donde corresponda.

Si tiene problemas para encontrar el servidor SMTP, prueba a añadirlo
junto con su dirección IP al fichero <tt>/etc/hosts</tt>. Para saber
la dirección IP no hay más que hacer un <tt>ping</tt> al nombre de la
máquina y nos dirá su IP.

Ahora elegimos estre dos opciones: podemos simplemente cambiar la
cabecera <tt>From</tt> de nuestro correo en el MUA (programa para
escribir y leer el correo) que utilicemos o enmascarar nuestro
dominio. En el primer caso, si utilizamos <ref id="pine" name="Pine">
se explica un poco <ref id="from" name="más arriba">. En el segundo
caso, el nombre de nuestra cuenta en nuestro ordenador (el login) debe 
coincidir con el nombre que tengamos en el ISP (el de nuestra
dirección de correo). Por ejemplo, si nuestra dirección de correo es
<tt>kuko@isp.es</tt>, el login de nuestra cuenta debe ser
<tt>kuko</tt>. Si cambiamos dirección de correo, deberemos cambiar de
login, cosa que si bien no es difícil, molesta si lo tenemos que hacer
a menudo. Esto se puede hacer más fácil con el primer método.

Para el segundo método buscamos también:

<tscreen><code>
# Who I masquerade as (null for no masquerading)
DM
</code></tscreen>

y ponemos el dominio de nuestra dirección de correo, que en mi caso es
<tt>ctv.es</tt>:

<tscreen><code>
# Who I masquerade as (null for no masquerading)
DMctv.es
</code></tscreen>

Con esto, lo que hemos hecho es enmascarar nuestra dirección de la 
máquina propia. Si nuestra máquina se llama <tt>ordenador.mio</tt> y 
enviamos un mensaje sin la modificacion anterior, el mensaje llegará 
correctamente a su destino, pero no podrá ser respondido, ya que la 
dirección <tt>monkiki@ordenador.mio</tt> no existirá. Lo acertado es
que aparezca <tt>monkiki@ctv.es</tt>, que si es una 
dirección válida. 

A partir de aquí es común para los dos métodos. 

Para que Sendmail no intente continuamente enviar el correo que haya en
la cola debemos modificar la llamada al demonio sendmail, que se hace 
desde <tt>/etc/rc.d/init.d/sendmail</tt> por una como esta:

<tscreen><code>
daemon /usr/sbin/sendmail -bd -oDeliveryMode=d
</code></tscreen>

Para enviar los mensajes de la cola, deberemos poner:

<tscreen><verb>
$ sendmail -q 
</verb></tscreen>

Para los mensajes que están en la cola pondremos:

<tscreen><verb>
$ mailq
</verb></tscreen>

Y si queremos borrar un mensaje de la cola, hay que borrar el mensaje 
de los los ficheros que están en <tt>/var/spool/mqueue</tt>. Pero 
cuidado con lo que borras ;-)

Si no quieres recibir un warning cada vez que un mensaje lleve más de 
cuatro horas sin ser enviado (cosa normal en mi caso), podemos
comentar la siguiente línea de <tt>/etc/sendmail.cf</tt>:

<tscreen><code>
O Timeout.queuewarn=4h
</code></tscreen>




<sect>Las News
<p>

<sect1>HY-News
<p>
Se trata de un lector de noticias off-line. Para instalarlo vamos al
directorio raiz y descomprimimos el archivo. Claro está que en modo
<tt>root</tt>. Aún no lo he visto en formato RPM. Si alguno se
anima... Creamos el directorio <tt>~/news</tt> donde guardará por
defecto los grupos a los que estamos suscritos junto con las cabeceras
de los mensajes. 

Nos conectamos a la red y lo ejecutamos y creará un directorio oculto
con sus cosas de la configuración. En la opción <tt>Configurar</tt>
del menú <tt>Archivo</tt> nos permite configurar cosas tales como
nuestra dirección de correo, nuestro nombre, el servidor NNTP y los colores.
 
Una vez elegido el servidor de noticias (aunque ya viene uno por
defecto) seleccionamos la opción <tt>`Leer lista de Areas'</tt> del
menú <tt>Servidor</tt>. Con esto conseguimos traernos todas las áreas
de noticias que haya en nuestro servidor. La cosa tarda un poquito, natural.
Al acabar, vamos otra vez al menú <tt>Servidor</tt> y escojemos la
opción <tt>`Configurar Areas'</tt>, suscribiéndonos a las áreas que
nos interesen. Para bajarnos las cabaceras de los mensajes de los grupos
a los que nos hemos suscrito pulsamos el botón <tt>Nuevos</tt>. Otro
ratito después acaba la cosa. Hacemos doble click sobre las cabeceras
de los mensajes que queramos para marcarlas. Y pulsamos el botón
<tt>Bajar</tt> y se bajarán los cuerpos de los mensajes seleccionados
previamente. Los mensajes bajados se ponen al final de la lista. Si
todo ha funcionado bien, ya te puedes desconectar de la red. 

Cuando arranque el programa desconetado marcas los mensajes a bajarte
y escribes lo que vaya a subir. Y para bajar/subir te tienes que
conectar antes (¡qué cosas digo!).

Como nota final, he de decir que he experimentado ciertos problemillas
con este lector de forma que algunas veces no bajaba los mensajes
marcados. De modo que si no te funciona bien, te recomiendo el
siguiente método.


<sect1>Leafnode
<p>
Se trata de un servidor de news, de modo que nos bajamos los artículos
de los grupos a los que estamos suscritos y podemos leerlos con
cualquier lector, como Netscape, por ejemplo. También es muy
rápido. La parte mala (o buena, según se mire) es que nos bajamos
todos los artículos del grupos, y no sólo los que nos interesan. Pero
igual otro dia nos interesa uno de los otros y ya lo tenemos aquí para
leerlo ;-)

La explicación de cómo usarlo es de Jano (espero que esto no llege a
los tribunales ;-)

Te bajas el programa en cuestion, yo me baje la version en RPM para la
Red Hat 5.0, y lo instalas. Después una vez bajado he instalado, editas el
fichero de configuración del programa (que está en 
<tt>/usr/lib/leafnode/config</tt>) y le dices cual es tu servidor de
news, en donde pone <tt>server</tt>. En mi caso pongo 

<tscreen><code>
server = news.ctv.es
</code></tscreen>

seguidamente pones 

<tscreen><verb>
$ fetch -v 
</verb></tscreen>

(lo del -v es para ver que ocurre con el programa) y el programa te
bajar todos los grupos de noticias, pero solo el nombre de los grupos
sin ningún articulo. Después una vez que haya acabado de bajar los
grupos, vuelves a arrancar el inetd

<tscreen><verb>
$ /etc/rc.d/init.d/inet restart 
</verb></tscreen>

para que así se active tu servidor de news (vamos, el Leafnode). 

Te vas al <ref id="netscape" name="Netscape">
o a cualquier programa de news para Linux como el
Krn que viene con las <ref id="kde" name="KDE">
y le dices que tu servidor de
news es tu ordenador (localhost), y después sacas la lista de grupos
posibles para ese servidor de news (vamos, tu ordenador). De esta lista
te suscribes a los grupos que quieras, por ejemplo <tt>es.comp.os.linux</tt>,
y verás que te aparece como que estás suscrito, le das dos veces al
grupo y verás que no te aparece ningun mensaje. Realmente lo que haces
con esto es decirle al Leafnode que grupos de noticias quieres que te
gestione. 

Seguidamente cierras el <ref id="netscape" name="Netscape">
o el programa de noticias que
utilices y vete a <tt>/var/spool/news/interesting.groups</tt> y alli
verás como aparece un fichero con el nombre <tt>es.comp.os.linux</tt>,
si te aperecen algunos más y no son de los que te has suscrito
sencillamente bórralos ya que si no, te bajará los artículos de esos
grupos también. Si utilizas el Netscape, al suscribirte
a un grupo nuevo, te mete grupos a los que no te has
suscrito. No se trata de un fallo del Netscape ni del Leafnode, lo que
pasa es al suscribirte a un grupo, Netscape va mostrándote cuántos
artículos hay en los grupos que vas recorriendo, como para ello hace
llamadas al servidor de noticias, que en nuestro caso es el Leafnode,
y no están esos grupos en el ordenador local, pues Leafnode apunta
esos grupos para bajárselos la próxima vez. No sé si me explico. 

Por último lo que te queda por hacer es volver a ejectuar

<tscreen><verb>
$ fetch -v 
</verb></tscreen>

y esta vez te bajará los artículos del grupo de noticas
<tt>es.comp.os.linux</tt>, la siguiente vez que ejecutes lo del
<tt>fetch -v</tt> sólo te bajará los artículos nuevos. Desconectas, te 
aseguras de tener activado el inetd y ya puedes leer los articulos 
tranquilamente. Al instalarse Leafnode modifica el fichero 
<tt>/etc/inetd.conf</tt>, de modo que arrancará automáticamente al
volver a iniciar el equipo. 

Espero que esto te sirva, sinceramente te recomeindo que te instales 
Leafnode, ya que te convierte cualquier cliente de news en un cliente
off-line. además es muy facil de manejar y baja los mensajes muy rápido.




<sect>Cosas de la Web
<p>

<sect1>Netscape Navigator 3.01
<p>
Ejecutando 

<tscreen><verb>
$ netscape
</verb></tscreen>

la primera vez te dará unos tiernos
mensajillos de error, que no lo son tanto. Te dirá que está creando el 
directorio <tt>~/.netscape</tt> donde guardará la configuración
personal y el directorio de caché. 

Podemos elegir entre que Netscape se encarge de recoger y enviar el
correo directamente a nuestro ISP, o hacer uso de otra
aplicación para recoger el correo como 
<ref id="fetchmail" name="Fetchmail">
y que <ref id="sendmail" name="Sendmail"> se encargue
de enviarlo:

<itemize>
<item>El primer caso (simple y cutre, pero efectivo),
en el grupo <tt>`Outgoing Mail'</tt> deberemos especifiar el servidor
SMTP de nuestro servidor. Y en el grupo <tt>`Incoming Mail'</tt>
marcaremos la opción <tt>POP3</tt> y pondremos los datos de nuestro
servidor POP3 y el usuario de POP3.

<item>El segundo caso (elaborado y para impresionar a nuestros colegas),
en el grupo <tt>`Outgoing Mail'</tt> deberemos especifiar el servidor
SMTP que en este caso será <tt>localhost</tt>. Y en el grupo <tt>`Incoming
Mail'</tt> marcaremos la opción <tt>`External Movemail'</tt>.
No hay que olvidarse que tanto 
<ref id="fetchmail" name="Fetchmail">
como <ref id="sendmail" name="Sendmail"> deben estar
correctamente configurados. 
</itemize>

(SIN TERMINAR - ver la configuración del Netscape Communicator 4.04
para más información) 

El correo lo guardará por defecto en el directorio <tt>~/nsmail</tt>.

Si te no te gusta que te inunden con `cookies', puedes pedir al navegador
que te avise entes de aceptarla por la cara. Para ello, del menú 
<tt>Options</tt> escojemos la opcion <tt>`Network
Preferences...'</tt>. Selecciono la solapa <tt>Protocols</tt> y del
grupo <tt>`Show an Alert before'</tt> marco la opción <tt>`Accepting a 
cookie'</tt>.

<sect1>Netscape Communicator 4.04 y 4.05 <label id="netscape">
<p>
La cosa es muy parecida al caso anterior, si bien haremos hincapié en
la configuración del correo. En este caso utilizaremos Netscape como
lector de correo simplemente y no como agente de transporte, ya que de
eso se van a encargar
<ref id="fetchmail" name="Fetchmail">
y <ref id="sendmail" name="Sendmail">.
Vamos a la parte en la que modificamos
las preferencias del correo. En <tt>`Outgoing mail (SMTP) server'</tt>
ponemos <tt>localhost</tt> ya que será 
<ref id="sendmail" name="Sendmail"> 
quien gestione el envio del correo. En <tt>`Mail server type'</tt>
activamos la opción <tt>`Movemail application'</tt>, y 
<tt>`External application'</tt>. Esta aplicación ya le trae Netscape y
la podemos encontrar en
<tt>/usr/X11R6/lib/X11/netscape/4.04/movemail</tt>. Si no está ahí,
siempre lo podemos buscar:

<tscreen><verb>
$ find / -name "movemail"
</verb></tscreen>

Y ahora viene el truco final: dicha aplicación tiene que tener el bit
`setgid' activado, por lo que vamos al directorio donde se encuantra
la aplicación y en modo root escribimos:

<tscreen><verb>
$ chown root:root movemail
$ chmod +s movemail
</verb></tscreen>

Sin embargo, lo del <tt>movemail</tt> me parece una chapucilla y hay
otra forma más "seria" de recoger el correo: para ello necesitaremos
un servidor <tt>POP</tt> instalado en nuestra máquina. Pero que no
cunda el pánico, que esto es fácil, fácil (como diría Arguiñano). En 
Red Hat 5.0 no aparece por defecto este servicio, pero sólo hace falta
instalar el paquete <tt>imap</tt> y todo solucionado. ¡Para que
después digan que Linux es complicado!. El siguiente paso es indicarle
a Netscape que recoja el correo del servidor POP3 que será
<tt>localhost</tt> y decirle la cuenta POP, que será el nombre de
nuestro login.

Ahora podremos leer y enviar el correo desde Netscape.


<sect1>Lynx <label id="lynx">
<p>
Este maravilloso navegador en modo texto también tiene parte en este
documento. Para hacer que al arrancar el programa, lea una página por
defecto, deberemos añadir a nuestro 
<ref id="bash_profile" name="/.bash_profile">:

<tscreen><code>
# Para especificar una página por defecto al iniciar el Lynx.
export WWW_HOME=file://antares.linux.es/home/paco/web/index.html
</code></tscreen>

Para que Lynx haga uso del caché-proxy que nos ofrece
<ref id="squid" name="Squid"> o
<ref id="wwwoffle" name="WWWOFFLE">, tendremos
que añadir esta líneas al fichero 
<ref id="bash_profile" name="/.bash_profile">:

<tscreen><code>
# Para que Lynx utilice el caché-proxy.
export http_proxy=http://localhost:3128/
export ftp_proxy=http://localhost:3128/
</code></tscreen>


<sect1>Squid <label id="squid">
<p>
Este bonito programa hace de caché-proxy,
de modo que todo las páginas que veas durante tu conexción a la red, luego
las podrás ver off-line. Todo se hace de forma transparente para el usuario.
Cuando lo hayas instalado (como root) reinicia el sistema o activas el
demonio manualmente:

<tscreen><verb>
$ /etc/rc.d/init.d/squid
</verb></tscreen>

y creará los directorios necesarios. 

Pero tienes que hacer uno pequeñísimos cambios en la configuración de 
<ref id="netscape" name="Netscape">,
por ejemplo. Le tienes que indicar que el la dirección del proxy FTP
es <tt>localhost:3128</tt> y la de HTML la misma. Tienes que saber que 
<tt>localhost</tt> es el host y <tt>3128</tt> es el puerto. No digo
nada nuevo.

Para ver como hacer esto mismo pero para el <ref id="lynx"
name="Lynx">, mira en su correspondiente sección.

Para ver si funciona busca (desconectado) un dirección cualquiera. Te 
saldrá una página diciendo que no la encuentra y tal. Si sale eso es
que ya está activo el demonio squid.

Ahora vamos a ver cómo funciona de verdad. Te conectas a la red y vas a
varias direcciones (tus preferidas). Cuando termines, te
desconectas. La próxima ves que intentes acceder a esas página
off-line, saldrán como si estuvieras conectado realmente. Esto
funciona aunque vacies la caché de memoria y de disco del navegador ;-)


<sect1>WWWOFFLE <label id="wwwoffle">
<p>
Este programa es la caña. También es un caché-proxy, pero te da muchas
ventajas si utilizas una conexión intermitente a Internet, que será el
caso de casi todos ;-) Una cosa que tiene buena es que se puede
configurar desde el propio navegador apuntando hacia 
<htmlurl url="http://localhost:8080"
name="http://localhost:8080">. Para empezar vamos a esa dirección y
debería salirnos una página de bienvenida, si no es así es que igual
no está activo el programa. Podemos reiniciar el sistema o ejecutar:

<tscreen><verb>
$ /etc/rc.d/init.d/wwwoffle.init start
</verb></tscreen>

Si ahora ya no aparece, pues la cosa está chunga. Bueno, el caso es
que vamos a configurar el programita. Vamos a la opción <tt>'[Control
Program]'</tt> y saltaremos a <tt>'WWWOFFLE Interactive
Control'</tt>. Ahí pulsamos en <tt>'/control/'</tt>. Aquí podemos
poner el programa en varios modos:

<descrip>
<tag/Online/ Las páginas ahora las buscará en la red y las almacenará
en la caché por si las necesitamos luego. Es equivalente a poner:

<tscreen><verb>
$ /usr/local/bin/wwwoffle -online -c /etc/wwwoffle.conf
</verb></tscreen>

<tag/Autodial/ Si tenemos configurado nuestro esquipo para
dial-on-demand, iniciará una conexión cuando sea necesario localizar
una página.

<tag/Offline/ Ahora todas las peticiones a páginas que no se
encuentran en la caché se marcarán para traérselas en una futura
conexión. Si la página está en la caché, la lee y punto.

<tscreen><verb>
$ /usr/local/bin/wwwoffle -offline -c /etc/wwwoffle.conf
</verb></tscreen>

<tag/Fetch/ Recoge todas las peticiones hechas fuera de línea.

<tscreen><verb>
$ /usr/local/bin/wwwoffle -fetch -c /etc/wwwoffle.conf
</verb></tscreen>

<tag/Purge/ Purga la caché. Según los criterios establecidos, cuando
por ejemplo configuro que dedique sólo 10 Mb a la caché, cuando se
ocupa más expacio y purgo, se eliminan las que sobren.
</descrip>

Si tenemos una dirección IP en una red, en 'LocalHost Section'
deberíamos especificar también la dirección en la red de la máquina
que se usará como proxy. 

En 'Proxy Section' pondremos la dirección del servidor proxy de
nuestro ISP.

Tampoco es mala idea poner en 'AllowedConnect' las direcciones de las
máquinas que van a tener acceso a este proxy.

Para que Lynx haga uso del caché-proxy que nos ofrece WWWOFFLE, tendremos
que añadir esta líneas al fichero 
<ref id="bash_profile" name="/.bash_profile">:

<tscreen><code>
# Para que Lynx utilice el caché-proxy.
export http_proxy=http://localhost:8080/
export ftp_proxy=http://localhost:8080/
</code></tscreen>




<sect>Emuladores
<p>

<sect1>Wine
<p>
Para que este emulador de Windows funcione de forma correcta,
deberemos editar el fichero <tt>/etc/wine.conf</tt>.
Tenemos que cambiar los <tt>Paths</tt> de las distintas unidades
para que las encuentre.


<sect1>Dosemu y xdosemu
<p>
Desde DOS Tenemos que formatear un disco con sistema, un disco de
arranque. Además debe tener el FDISK y el SYS.

Metemos el disco de arranque de DOS en la unidad A: y ejecutamos como root:

<tscreen><verb>
$ dos -A
</verb></tscreen>

para ver si funciona. Ahora ejecutamos desde la unidad A:

<tscreen><verb>
A:\>FDISK /MBR
A:\>SYS C:
</verb></tscreen>

Con esto transferiremos al la unidad C (unidad virtual creada por
Dosemu) el sistema. Vamos a la unidad C: y salimos del emulador:

<tscreen><verb>
C:\>EXITEMU
</verb></tscreen>

Ahora ya arrancará el dosemu si tener que poner un disco en la unidad.

Si esto no te funciona bien, prueba con este otro procedimiento:

<enum>
<item> Prepara un diskette de arranque, igual que antes, incluyendo
<tt>FDISK</tt> y <tt>SYS</tt>.
<item> Siguiendo las instrucciones del fichero QuickStart (situado en
<tt>/usr/doc/packages/dosemu</tt>. Esto supongo que será de la SuSe,
porque ese directorio no se encuentra en la Red Hat) , desde el
directorio del dosemu 
(<tt>/var/lib/dosemu</tt>), se ejecuta, como root: 

<tscreen><verb>
$ ./setup-hdimage.
</verb></tscreen>

<item> Primero pregunta por el dispositivo donde puede encontrar los
ficheros de arranque, a lo que se responde <tt>/dev/fd0</tt> (con el
diskette metido, obviamente). 
<item>Luego pregunta por un lugar donde encontrar el
<tt>COMMAND.COM</tt>, a lo que se responde con Enter (para la misma
ubicación). En este momento empieza a copiar todos los archivos
internos a la unidad <tt>C:</tt> 
<item>Y ya está. Ya se puede arrancar tecleando "dos" desde la línea
de comandos. 
</enum>

Para que funcione bien el teclado hay que editar el fichero
<tt>/etc/dosemu.conf</tt> y en la sección que pone <tt>"other then
guest"</tt> comentar la línea de <tt>"keyboard"</tt> y poner
esta: 

<tscreen><code>
keyboard {  layout es-latin1  keybint on  rawkeyboard on  }
</code></tscreen>

Además, donde pone <tt>"bootA"</tt> debes poner
<tt>"bootC"</tt> para que no te pida un disquete cada vez que ejecutes
el emulador. 

Miran también la línea <tt>"vga"</tt> e intenta ponerla según tu
tarjeta gráfica, aunque esto no es muy importante si no vas a utilizar
programas gráficos.

Es buena idea configurar el contenido del CONFIG.SYS y el AUTOEXEC.BAT
que están en la unidad C (la unidad virtual). Veamos el contenido de
mi CONFIG.SYS: 

<tscreen><code>
rem this sets up the redirector to look at the Linux root directory.
rem this is probably not a good idea once you have dosemu installed
rem device=c:\emufs.sys /
device=c:\ems.sys

lastdrive=Z      
</code></tscreen>

Y el de mi AUTOEXEC.BAT:

<tscreen><code>
@echo off

lredir e: linux\fs
lredir f: linux\fs/mnt/dosc
lredir g: linux\fs/mnt/cdrom

set TEMP=e:\tmp
set PATH=c:\;f:\dos;f:\windows\command

echo "¡Bienvenido a dosemu!"  
</code></tscreen>

Probamos el emulador como root, y si todo va bien, ahora podemos
editar el fichero 
<tt>/etc/dosemu.conf</tt> y añadimos nuestro nombre de login después
del de root (yo soy <tt>paco</tt>):

<tscreen><code>
root c_all		# root is allowed to do all weird things
paco c_all              # Este soy yo ;-)
nobody guest		# variable 'guest' is checked in /etc/dosemu.conf
</code></tscreen>

Entramos con nuestro login habitual y
volvemos a ejecutar <tt>dos</tt>. Eso debería funcionar.

Con esto los acentos (perdón, tildes) y las eñes se ven en modo
terminal de texto. Si ejecutais el xdosemu, pues la cosa de los
acentos funcionrán igual de mal que siempre :-(




<sect>Otros
<p>

<sect1>Midnight Commander (mc)
<p>
La primera vez que ejecutamos 

<tscreen><verb>
$ mc
</verb></tscreen> 

creará unos ficheros
propios. Para hacer que utilice bien los acentos y cosas de esas,
tanto en el nombre de los ficheros como en  el editor que trae, del
menú <tt>`Options'</tt> elegimos la opción <tt>`Display
bits...'</tt>. Deberemos seleccionar la opcion ISO-8859-1.

También seleccionamos la opcion <tt>`Full 8 bits input'</tt>. Para
que se guarde esta configuracion, en <tt>`Options'</tt> elegimos
<tt>`Save setup'</tt>.


<sect1>Java
<p>
Pues resulta que en el JDK-1.1.3 no me salían los acentos y borrando
(o renombrando, por si las moscas) el fichero <tt>font.properties</tt>
que en mi caso está en <tt>/usr/local/jdk1.1.3/lib</tt> la cosa se
arregla. Impresionante, ¿verdad?. Ahora estoy en lucha con el
JDK-1.1.5 que me hace cositas raras con los caracteres como acentos y
eñes. Cuando tenga algo lo pondré por aquí.

Bueno, ahora esto ya está resuelto con el JDK-1.1.6 y con Swing, que
es la mejor forma de que no den por sacos los acentos. Además, puede
suceder que al compilar algo de Java el sistema nos suelte un "Core
Dumped", pero la forma de arreglarlo es actualizando la biblioteca
glibc de nuestro sistema. Con la <tt>glibc-2.0.7-13</tt> todo va
estupendamente. 

<sect1>Kppp
<p>
Después de mucho batallear con los parámetros de configuración del
Kppp he conseguido que funcione, ¡Eureka!. Muestro aquí la
configuración que tengo y que me funciona.

Antes de nada supongo que habeis sido buenos chicos y hebeis leido las
instrucciones del programa. ¿Qué no?, bueno os lo resumo en dos puntos:

<itemize>
<item>Hay que quitar la opción <tt>lock</tt> de los ficheros
<tt>/etc/ppp/options</tt> y <tt>~/.ppprc</tt> (este último no tiene
por qué existir).

<item>Para que el programa funcione desde un usuario normal, el
propietario y el grupo del programa deben ser root, y el ejecutable
debe tener el bit SETUID activado, para que pueda acceder al modem. Lo
normal es que el usuario y el grupo sean root, pero si no lo son, se
pone con la orden:

<tscreen><verb>
$ chown root:root kppp
</verb></tscreen>

Lo del bit de SETUID tendrás que ponerlo tu, desde la cuenta de root,
por supuesto:

<tscreen><verb>
$ chmod +s kppp
</verb></tscreen>
</itemize>

Vamos al lio:

<itemize>
<item><bf>Conexiones</bf>
  <itemize>
  <item>Tenemos que ver los parámetros de una conexión:
   
    <itemize>
    <item><bf>Marcado</bf>
      <itemize>
      <item><it>Nombre de la Conexión</it>: ctv (en mi caso ;-)

      <item><it>Número de Teléfono</it>: 055

      <item><it>Autentificación</it>: Mediante PAP

      <item><it>Almacenar Contraseña</it>: activado

      <item><it>Ejecutar programa al establecer la conexión</it>:
      vacio. No hace falta explicar para lo que vale, ¿no?.

      <item><it>Ejecutar programa al finalizar la conexión</it>:
      vacio. Lo mismo que lo anterior.

      <item><it>Editar opciones del pppd</it>: Las opciones que yo
      tengo puestas son: 
      
        <itemize>
	<item>-detach 
	<item>defaultroute
	<item>asyncmap a0000
	<item>noipdefault
	<item>ipcp-accept-local
	<item>:172.16.5.5 ipcp-accept-remote
	</itemize>
      </itemize>

   <item><bf>Dirección IP</bf>
     <itemize>
     <item><it>Dirección IP asignada por el Servidor</it>: activado
     <item><it>Dirección IP asignada por el Usuario</it>: desactivado
     <item><it>Dirección IP</it>: desactivado
     <item><it>Máscara de SubRed</it>: desactivado
     <item><it>Autoconfigurar el nombre del Host desde esta Dirección
     IP</it>: desactivado
     </itemize>
   <item><bf>Servidor Nombres</bf>
     <itemize>
     <item><it>Nombre de Dominio</it>: ctv.es
     <item><it>Dirección IP de los Servidores de Nombres</it>: Aquí
     iremos poniendo las direcciones IP del DNS primario y el
     secundario. Le damos a Añadir y las pondrá en la lista de abajo.
     <item><it>Lista de Direcciones de Servidores de Nombres</it>: 
       <itemize>
       <item>194.179.52.2 (DNS primaria)
       <item>195.57.143.21 (DNS secundaria)
       </itemize>
     <item><it>Deshabilitar Servidores de Nombres durante la
     Conexión</it>: desactivado
     </itemize>
   <item><bf>Puerta de Enlace</bf>
     <itemize>
       <item><it>Puerta de Enlace por defecto</it>: activado
       <item><it>Puerta de Enlace asignada por el Usuario</it>:
       desactivado
       <item><it>Dirección IP de la Puerta de Enlace</it>: desactivado
       <item><it>Asignar la Ruta por Defecto hacia esta Puerta de
       Enlace</it>: activado
     </itemize>
   <item><bf>Script de Conexión</bf>
     <itemize>
     <item><it>Usar Script genérico</it>: activado
     <item>Lo demás está vacío.
     </itemize>
   <item><bf>Coste</bf>
     <itemize>
     <item><it>activar Seguimiento de Costes</it>: activado
     <item><it>Tarifa Seleccionada</it>: Spain/Infovía
     <item><it>Volume accounting</it>: No accounting
     </itemize>
   </itemize>

  </itemize>
<item><bf>Dispositivo Serie</bf>
  <itemize>
  <item><it>Dispositivo del Modem</it>: normalmente será
  <tt>/dev/modem</tt>. Este dispositivo es un enlace a
  <tt>/dev/ttySx</tt>. 

  <item><it>Control de Flujo</it>: CRTSCTS (por hardware).

  <item><it>Terminación de Línea</it>: CR. Si se te corta la conexión, puedes
  probar otras opciones aquí.

  <item><it>Velocidad de Conexión</it>: 115200. Esta es la máxima permitida
  para mi modem de 33.6 bps. Para empezar las pruebas no sería mala
  idea probar primero con velocidades inferiores.

  <item><it>Fichero de bloqueo del Modem</it>:
  <tt>/var/lock/LCK..modem</tt>. No hay que tocar nada.

  <item><it>Timeout del Modem</it>: 60 segundos. Yo lo tengo puesto a 75 y me
  va bien, lo que no quiere decir que con 60 baste.
  </itemize>

<item><bf>Modem</bf>
  <itemize>
  <item><it>Espera por línea ocupada</it>: 0 segundos.
  
  <item><it>El Modem sostiene la línea CD</it>: desactivado.
  
  <item><it>Cadenas del Modem</it>: especificaremos las cadenas que
  entiende el modem. Normalmente todos los modem son compatibles con
  el estandar Hayes, y estas cadenas funcionarán bien. Yo no cambié
  nada. 

  <item><it>Consultar el Modem</it>: Permite comprobar si el modem
  está funcionando correctamente, o lo por lo menos que responde a
  nuestras peticiones. 
  
  <item><it>Terminal</it>: Es una terminal que nos permitirá enviar cadenas
  al modem. Muy útil.
  </itemize>
<item><bf>Opciones Varias</bf>
  <itemize>
  <item><it>Localización del ejecutable pppd</it>: <tt>/usr/sbin/pppd</tt>.
  
  <item><it>Timeout del pppd</it>: 60 segundos.
  
  <item><it>Visor de Logs</it>: kedit.
  
  <item><it>Reestablecer la Conexión automáticamente si se
  pierde</it>: desactivado.
  
  <item><it>Mostrar Reloj en la barra de Título</it>: activado.
  
  <item><it>Desconectar al apagar el Servidor X</it>: activado.
  
  <item><it>Minimizar Ventana al Conectar</it>: activado.

  <item><it>Iconizar en el Panel al Conectar</it>: activado.
  </itemize>
<item><bf>Acerca de</bf>
  <itemize>
  <item>Interesante, ¿verdad?
  </itemize>
</itemize>

Para ver si todo lo has hecho bien, primero ejecuta Kppp como root y
si funciona bien, pues prueba como un usuario normal.



<sect>Hardware
<p>

<sect1>
Nuestra Tarjeta de Sonido
<p>
Si tienes una Sound Blaster, no hace falta tener que recompilar el
kernel ni nada. Ejecutamos la utilidad 

<tscreen><verb>
$ sndconfig
</verb></tscreen>

y ya está. A mi personalmente me da un error al intentar detectar 
automaticamente mi Sound Blaster Pro, de modo que lo ejecuto con la
opcion <tt>--noprobe</tt> y yo le digo lo
que quiera saber, o sea, el modelo de tarjeta, el puerto, la IRQ, el canal
de DMA y ya está. Curiosamente los parámetro están bien pruestos, de
modo que sí que hace algún tipo de detección. Ese error ocurre con la
versión 0.19-1 del programa, pero en la nueva versión 0.20-1 ya se
corrige este fallo.

El programa hará una prueba de sonido y si lo escuchas, ya está. 


<sect1>El modem
<p>
Deberemos crear el fichero <tt>/etc/rc.d/rc.serial</tt> que contenga
lo siguiente:

<tscreen><code>
/bin/setserial /dev/ttyS2 port 0x03e8 auto_irq skip_test autoconfig spd_vhi

/bin/stty crtscts < /dev/ttyS2

echo "Estado del modem:"
/bin/setserial -bag /dev/ttyS2
</code></tscreen>

Cambiando el dispositivo serie y su dirección por el que tengamos
nosotros instalado. En mi caso es en el <tt>COM3</tt>, que en Linux es
el dispositivo <tt>ttyS2</tt>. El puerto es el mismo en cualquier
caso. La segunda línea habilita el control de flujo por hardware, que
es muy importante si el modem soporta compresión de datos.


<sect>
El acceso a Internet por Infobirria
<p>
Esto son mis ficheros de configuración de la conexión a mi proveedor
de Internet:

<itemize>
<item><tt>/etc/ppp/options</tt>: 
<tscreen><code>
connect /etc/ppp/infovia.chat
crtscts
modem
passive
noipdefault
ipcp-accept-local
:172.16.5.5 ipcp-accept-remote
debug 
defaultroute
asyncmap a0000
lock
/dev/ttyS2
115200
</code></tscreen>

<item><tt>/etc/ppp/infovia.chat</tt> (es un script, por lo que debe ser ejecutable)
<tscreen><code> 
#!/bin/sh

/usr/sbin/chat -v "" ATZ OK ATDT055 ABORT "NO CARRIER" ABORT BUSY ABORT "NO DIALTONE" CONNECT ""
</code></tscreen>

<item><tt>/etc/ppp/inet</tt> (es un script, por lo que debe ser ejecutable)
<tscreen><code>
#!/bin/sh

# Creamos el fichero resolv.conf adecuado para la conexión a Internet.
cat > /etc/resolv.conf << fin_de_resolv_conf
domain linux.es
nameserver 195.5.64.2
naemserver 195.5.64.6
fin_de_resolv_conf

# Llamamos a pppd con los parámetros para una conexión a Internet.
# pppd(8) usará los mismos valores de configuración para la conexión 
# autentificada por el ISP que para la no autentificada (Infovía). 
/usr/sbin/pppd user monkiki@arrakis remotename arrakis
</code></tscreen>

<item><tt>pap-secrets</tt>
<tscreen><code>
# Secrets for authentication using PAP
# client        server  secret                  IP addresses
monkiki@arrakis	arrakis	no_te_la_digo
</code></tscreen>

</itemize>

Para conectar ejecutamos:

<tscreen><verb>
$ /etc/ppp/inet
</verb></tscreen>

y para desconectar:

<tscreen><verb>
$ killall pppd
</verb></tscreen>

También hay que tener en cuenta que al establecerse la conexión, se
ejecuta automáticamente el script <tt>/etc/ppp/ip-up</tt>. Podemos
poner ahí programas que necesitemos que se ejecuten al tener
habilitada la conexión, como recogida del correo. Pero en Red Hat se
recomienda utilizar el fichero <tt>/etc/ppp/ip-up.local</tt> para ese
uso. Habrá que crearlo si no está y hacerlo ejecutable. Este script es
llamado desde el propio <tt>/etc/ppp/ip-up</tt>.

De forma análoga, están los scripts <tt>/etc/ppp/ip-down</tt> y
<tt>/etc/ppp/ip-down.local</tt>, que se ejecutan al finalizar la conexión.

</article>
