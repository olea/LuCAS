<?xml version="1.0" encoding="ISO-8859-1" ?><!-- -*- xml -*- -->
 
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
       "file:///usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd">
 
<!--
\porcion{Compilación del núcleo}
\autor{\LDP}
\colaborador{\NC}
\revisor{}
\traductor{}
-->

<section>
  <title>Compilación del núcleo</title>

  <para>Habiendo enumerado los pasos para la actualización del núcleo
    en el sistema, vamos a abocarnos a una de las etapas quizás mas
    complicadas del proceso.</para>

  <para>Un detalle muy importante a tener en cuenta a la hora de
    compilar un núcleo, es que se deben tener instalados en el sistema
    los paquetes de desarrollo. El núcleo Linux está programado en
    casi su totalidad en C, por lo tanto se debe tener instalados la
    biblioteca C de desarrollo y el compilador de dicho
    lenguaje.</para>

  <para>Dependiendo de la distribución que se utiliza, el método de
    instalación de los paquetes difiere un poco. Dejando de lado el
    formato de paquetes y la distribución, se debe revisar si los
    paquetes <emphasis>gcc</emphasis> y <emphasis>libc6-dev</emphasis>
    se encuentran instalados, estos paquetes siempre tienen un nombre
    similar en cualquier distribución.</para>

  <para>Existen 3 formas de configurar las opciones y características
    a incluir en el núcleo, una es usando un programa de línea de
    comandos, que línea a línea va preguntando las diferentes
    opciones, este método era el que se utilizaba hace algunos años,
    los demás métodos son mas agradables. El segundo método es
    mediante el uso de una interfaz de texto, pero a pantalla
    completa, con uso de la biblioteca <emphasis>ncurses</emphasis>,
    si se quiere utilizar este método, se deben tener instalados en el
    sistema dicha biblioteca (normalmente se instala por defecto),
    cuyo paquete generalmente se denomina
    <emphasis>libncurses</emphasis>.  El tercer y último método es
    mediante el uso de una interfaz gráfica en las X; este método
    utiliza las bibliotecas <emphasis>Tcl/Tk</emphasis>, que también
    normalmente se instalan por defecto en el sistema.</para>

  <para>El primer método es el que se utilizaba con las primeras
    versiones del núcleo, como se puede observar en <olink
    targetdoc="contenido/PersonalizandoElKernel/CompilacionDelNucleo"
    targetptr="fig:CompilandoNucleo-MakeConfig"/>, no es muy amigable
    pero a veces puede resultar útil cuando no se tiene disponible una
    interfaz gráfica ni las bibliotecas
    <emphasis>ncurses</emphasis>. Estando en el directorio del código
    fuente del núcleo, se ejecuta el siguiente comando:</para>

<screen>
<prompt>root@maquina:/usr/src/linux#</prompt> <userinput>make config</userinput>
</screen>

  <figure id="fig:CompilandoNucleo-MakeConfig">
    <title>Configurando el núcleo con la interfaz de línea de comandos.</title>
    <graphic
      fileref="imagenes/PersonalizandoElKernel/CompilandoNucleo-MakeConfig.png"
      scale="100"/>
  </figure>

  <para>Siempre hay que tener en cuenta el usuario que se está
    utilizando en esta tarea, si bien el compilar un núcleo no
    requiere de utilizar el usuario administrador, dependiendo del
    directorio donde esté alojado el árbol de fuentes será o no
    necesario usar la cuenta <emphasis>root</emphasis>.  Como
    generalmente el directorio donde se aloja el código fuente del
    núcleo es <filename class="directory">/usr/src/</filename>, se
    necesitará usar la cuenta de administrador, a menos que dicho
    directorio posea permisos especiales para algún otro usuario del
    sistema.</para>

  <para>El segundo método mencionado corresponde al uso de la interfaz
    de texto a pantalla completa, como se ve en <olink
    targetdoc="contenido/PersonalizandoElKernel/CompilacionDelNucleo"
    targetptr="fig:CompilandoNucleo-MakeMenuConfig" />. Este método se
    usará de ahora en adelante.</para>

  <para>Esto se obtiene ejecutando el siguiente comando:</para>

<screen>
<prompt>root@maquina:/usr/src/linux#</prompt> <userinput>make menuconfig</userinput>
</screen>

%% REVISAR
%\figura{Interfaz de texto a pantalla completa}{CompilandoNucleo-MakeMenuConfig}
  <figure id="fig:CompilandoNucleo-MakeMenuConfig">
    <title>Interfaz de texto a pantalla completa.</title> <graphic
    fileref="imagenes/PersonalizandoElKernel/CompilandoNucleo-MakeMenuConfig.png"
    scale="100"/>
  </figure>

  <para>El tercer método utiliza una interfaz gráfica en las X (<olink
    targetdoc="contenido/PersonalizandoElKernel/CompilacionDelNucleo"
    targetptr="fig:CompilandoNucleo-MakeXConfig"/>). Es el método mas
    práctico, siempre y cuando se disponga de las X, claro está. Por
    esa razón hemos seleccionado el anterior método para las demás
    figuras, aunque se debe saber que los tres métodos poseen los
    mismos contenidos, solo cambia la manera de desplegar la
    información.</para>

  <para>Este tercer método se obtiene ejecutando desde una terminal X
  lo siguiente:</para>

<screen>
<prompt>root@maquina:/usr/src/linux#</prompt> <userinput>make xconfig</userinput>
</screen>

  <figure id="fig:CompilandoNucleo-MakeXConfig">
    <title>Interfaz gráfica para configurar el núcleo.</title>
    <graphic
    fileref="imagenes/PersonalizandoElKernel/CompilandoNucleo-MakeXConfig.png"
    scale="100"/>
  </figure>

  <para>Una vez presentados los métodos de configuración del núcleo,
    nos toca seleccionar las opciones y características que el nuevo
    núcleo incluirá. Lo que siempre se recomienda al agregar opciones
    en el núcleo, es que aquellas opciones que tengan la posibilidad
    de ir como módulos, que lo hagan. Con esto, obtendremos un núcleo
    mas pequeño, y los módulos que se han compilado se irán cargando y
    descargando automáticamente, a medida que se necesiten activar
    ciertas funcionalidades, y luego ya no se necesiten. Al tener
    menos cantidad de código en memoria, no sólo se produce un ahorro
    de RAM (que es prácticamente insignificante en estos días ahorrar
    unos 100k de RAM), sino que lo mas importante es el tener menos
    posibilidades que algo falle. El sentido común dice que un núcleo
    de 400Kb en memoria mas 200Kb de módulos no cargados tendrá menos
    posibilidades de falla que el mismo núcleo, pero con sus 600Kb
    completos en memoria.</para>

  <para>¿Cómo saber cual función debería ir en módulo y cual en el
    núcleo? Lo que se recomienda es tener en cuenta la necesidad del
    uso de cada funcionalidad del núcleo para realizar esta
    decisión. Por ejemplo, una máquina que posee discos rígidos IDE,
    los va a necesitar usar en todo el tiempo que esté encendido el
    equipo (salvo raras ocasiones), entonces el soporte para discos
    IDE debería ir en el núcleo y no como un módulo, ya que de ir como
    módulo, estaría siempre cargado. Un servidor de red necesitará el
    manejador de la tarjeta de red siempre activo, entonces conviene
    compilarlo en el núcleo, pero el uso del módem de dicho equipo es
    muy esporádico, en este caso el manejador del módem o los puertos
    serie podría ir como módulos. También hay que tener en cuenta algo
    importante: el núcleo necesita saber como manejar un disco rígido
    para poder iniciar todo el sistema (si el sistema está almacenado
    en un disco rígido, como normalmente ocurre), si se compila el
    soporte de discos rígidos (cualquiera sea el tipo) como módulo, el
    núcleo necesitará poder manejar el disco rígido al iniciar el
    equipo para poder cargar el módulo para poder manejar el disco
    rígido<footnote> <para>La recursión es algo muy interesante, pero
    en estos casos no aporta nada útil.</para></footnote>, y
    obviamente este tipo de casos causan problemas.</para>

  <para>Resumiendo, hay dos casos en los cuales una funcionalidad del
    núcleo no debería ser compilada como núcleo:</para>

  <itemizedlist>
    <listitem>
      <para>La funcionalidad en cuestión es esencial para el correcto
      arranque del sistema.</para>
    </listitem>
    <listitem>
      <para>Dicha funcionalidad va a utilizarse en todo momento del
      funcionamiento del sistema.</para>
    </listitem>
  </itemizedlist>

  <para>Para los demás casos es conveniente compilar como módulo. El
    sistema se encargará de cargar el módulo cuando se necesite, y
    cuando ya no se use, se descargará para liberar memoria.</para>

  <para>Cuando se ejecuta el comando <command>make
    menuconfig</command> se presenta una serie de secciones donde se
    agrupan las diferentes capacidades del núcleo, esta lista que
    sigue proporciona una breve explicación de los contenidos de cada
    una de estas secciones<footnote> <para>Se toma la versión 2.4.2
    del núcleo para las explicaciones, pero se supone que durante toda
    la serie 2.4.x estas secciones y sus contenidos no cambiarán
    demasiado</para></footnote>:</para>

  <variablelist>
    <varlistentry>
      <term>Code maturity level options</term>
      <listitem>
	<para>Se presenta una única opción, al activarla, será posible
	  activar aquellas funcionalidades experimentales que tenga el
	  núcleo, generalmente esto no es recomendable cuando se está
	  compilando un núcleo para algún servidor de producción, a
	  menos que se tenga la certeza de que tal o cual opción es
	  estable y funciona bien (o sea imprescindible).</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Loadable module support</term>
      <listitem>
	<para>Las opciones que se incluyen en esta sección tienen que
	  ver con el manejo de los módulos del núcleo. En algunos
	  casos no será necesario o no se podrá tener módulos,
	  entonces se pueden desactivar. En este método de
	  configuración del núcleo, aquellas opciones del mismo que
	  sea posible compilar como módulo tendrán la casilla de
	  selección a la izquierda de esta forma: &lt; &gt;, cuando se
	  llega a alguna opción con este tipo de casilla de selección,
	  oprimiendo <keycap>Y</keycap> se la selecciona para
	  compilarse dentro del núcleo, si se presiona
	  <keycap>M</keycap> se la seleccionará para compilarse como
	  un módulo.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Processor type and features</term>
      <listitem>
	<para>Dentro de esta sección encontraremos opciones de
	  optimización del núcleo para el tipo de procesador que se
	  posea. Con cada nueva serie de procesadores, características
	  nuevas van siendo disponibles para ciertas funciones, lo que
	  aprovecharlas es interesante para aumentar el desempeño
	  general del sistema. El núcleo Linux soporta también equipos
	  con mas de un procesador, en caso de estar compilando el
	  núcleo para un equipo de este tipo, en esta sección se debe
	  activar la opción <emphasis>Symmetric multi-processing
	  support</emphasis> para sacar el máximo provecho.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>General setup</term>
      <listitem>
	<para>Como su nombre lo indica, esta sección contiene opciones
	  de configuración general del núcleo, entre ellas se
	  encuentran opciones especificando la marca y el modelo del
	  <foreignphrase lang="en">chipset</foreignphrase> de la placa
	  madre del equipo, así como también si el núcleo utilizará el
	  sistema de administración de energía que provee el BIOS, el
	  formato en el cual el núcleo será compilado, si se
	  soportarán dispositivos PCMCIA, etc.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Memory Technology Devices (MTD)</term>
      <listitem>
	<para>Esta sección en nueva de los núcleos de la serie 2.4.x,
	  posee una opción para dar soporte a los dispositivos de
	  discos en memoria, para poder manejar sistemas de archivos
	  de estado sólido en dispositivos embebidos. Normalmente esta
	  opción no se utilizará.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Parallel port support</term>
      <listitem>
	<para>Dentro de esta sección se encuentra la opción que activa
	  el soporte para el puerto paralelo. Generalmente
	  utilizaremos el puerto paralelo si en la máquina se tendrá
	  alguna impresora de puerto paralelo instalada, alguna unidad
	  de disco Zip, o cualquier otra unidad de disco por puerto
	  paralelo (grabadoras de CD-R, por ejemplo) o en el caso de
	  utilizar un cable paralelo para conectarse con otra
	  máquina. Se debe tener en cuenta que esta opción se refiere
	  solamente al soporte de base para todos aquellos
	  dispositivos que utilicen el puerto paralelo, en otras
	  secciones se debe después confirmar el soporte individual
	  para aquellos dispositivos específicos.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Plug and Play configuration</term>
      <listitem>
	<para>Hace unos años se ha impuesto como estándar una norma
	  para periféricos de tal modo que no tengan que ser
	  configurados sus parámetros (IRQs, direcciones de E/S, etc.)
	  manualmente, sino que el sistema lo pueda manejar lo mas
	  convenientemente posible, de esta forma, el sistema
	  operativo podría lidiar con los conflictos y solucionar los
	  problemas que puedan surgir, liberando al usuario de estas
	  tareas que a veces suelen ser complicadas de
	  solucionar. Este estándar se conoce como
	  <emphasis>Plug&amp;Play</emphasis> (o abreviado, PnP), y
	  aunque inicialmente los dispositivos PnP no funcionaban muy
	  bien, hoy en día es mas común ver este tipo de periféricos
	  que los otros. El núcleo Linux tiene soporte para estos
	  dispositivos mediante la opción dentro de esta
	  sección. Además, se cuenta con un paquete de software
	  llamado <emphasis>isapnptools</emphasis> que es muy útil para
	  configurar los antiguos dispositivos PnP ISA (normalmente,
	  los módems).</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Block devices</term>
      <listitem>
	<para>En esta sección se presentan opciones para dar soporte a
	  varios tipos dispositivos de bloques, incluyendo unidades de
	  discos flexibles, discos IDE por puerto paralelo, discos en
	  memoria RAM, y otros mas.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Multi-device support (RAID and LVM)</term>
      <listitem>
	<para>Esta sección contiene opciones de configuración que
	  muchas veces se utilizan en equipos servidores. RAID es una
	  norma que sirve para generar arreglos de múltiples discos de
	  manera de obtener redundancia de información y evitar
	  problemas de corrupción de datos en el caso de que algún
	  disco del arreglo tenga una falla. RAID tiene varios modos
	  de funcionamiento, generalmente en los servidores se
	  utilizan placas controladoras de discos RAID (soporte de
	  hardware) que funcionan en forma transparente y el sistema
	  operativo no se da cuenta, sin embargo el núcleo Linux da la
	  posibilidad de poder utiliza discos comunes como discos RAID
	  (soporte por software) teniendo de esta manera un elemento
	  mas de seguridad a bajo costo. LVM es otro método de
	  combinación de discos, pero para la generación de volúmenes
	  o grupos de volúmenes de lógicos, cuyo tamaño puede variar
	  en tiempo de corrida del sistema, sin tener que reiniciar ni
	  parar servicios.  LVM no se utiliza para dar redundancia de
	  datos, sino para combinar varios discos (de distintos tipos)
	  y utilizarlos como si fuera un gran disco grande.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Networking options</term>
      <listitem>
	<para>En esta sección se encuentran las opciones de soporte
	  base de redes. Se podrán activar los soportes de varios
	  protocolos, con sus opciones específicas, el mas común en
	  estos días es el protocolo <emphasis>TCP/IP</emphasis>, uno
	  de los protocolos que se utiliza en Internet. Otra opción
	  bastante novedosa en los núcleos, es la opción QoS
	  (<foreignphrase lang="en">Quality of
	  Service</foreignphrase>) la cual se utiliza para definir los
	  algoritmos de planificación de paquetes de red, pudiendo
	  partir un enlace en varios sub-canales por decirlo de alguna
	  manera, y de esta forma poder asignar cierto ancho de banda
	  a diferentes clientes.  Tener en cuenta que esta sección no
	  se trata acerca de soporte a periféricos de red, sino a
	  protocolos, para tener soporte de una placa de red en
	  especial, se debe activar en otra sección.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Telephony Support</term>
      <listitem>
	<para>En esta sección se da soporte a los dispositivos VoIP
	  (<foreignphrase lang="en">Voice over IP</foreignphrase>),
	  que se utilizan para hablar por teléfono a través de redes
	  de datos, en vez de redes de telefonía.  Estos dispositivos
	  cada vez se están viendo con mas frecuencia, quien sabe, en
	  unos años quizás podremos hablar al otro lado del mundo sin
	  tener que pagar altísimos costos.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>ATA/IDE/MFM/RLL support</term>
      <listitem>
	<para>Aquí se da soporte a los discos <acronym>IDE</acronym>,
	  sean discos rígidos, flexibles, CD-ROMs, etc. También hay
	  varias opciones para especificar la marca de controladora de
	  disco que se posee, y otros detalles para mejorar la
	  performance. El núcleo Linux puede manejar sin problemas los
	  nuevos discos con <acronym>UDMA</acronym>.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SCSI support</term>
      <listitem>
	<para>También existe soporte para los dispositivos
	  <acronym>SCSI</acronym>, en esta sección están las opciones
	  para definir los tipos de dispositivos
	  <acronym>SCSI</acronym> que se dará soporte, mas otras
	  opciones de control. Un ejemplo común para esta sección es
	  el soporte para las unidades de discos Zip por puerto
	  paralelo, En realidad estas unidades trabajan con la norma
	  <acronym>SCSI</acronym>, y es por eso que parte de las
	  opciones que se necesitan para poder hacer funcionar estos
	  periféricos, se encuentran en esta sección.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>IEEE 1394 (FireWire) support</term>
      <listitem>
	<para>FireWire es una nueva clase de bus de datos, de alta
	  velocidad que normalmente se utiliza para transmitir
	  vídeo. Originariamente en las Macintosh, esta clase de
	  conexiones se las utiliza para conectar una cámara de vídeo
	  al equipo y capturar vídeo sin problemas de
	  lentitud. Actualmente existen placas con puertos FireWire
	  para PCs compatibles con IBM.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>I2O device support</term>
      <listitem>
	<para>La arquitectura <emphasis>I2O</emphasis> se ha pensado
	  para dividir los manejadores de dispositivos I2O en dos
	  partes: una dependiente del sistema operativo y otra no, de
	  manera de que el fabricante del dispositivo en cuestión
	  solamente deba hacer un solo manejador (la parte no
	  dependiente del sistema operativo) y de esta forma poder
	  utilizarlo en cualquier sistema operativo compatible con
	  I2O. El autor<footnote><para>En realidad, uno de los
	  autores (Lucas Di Pentima)</para></footnote> no conoce
	  actualmente ningún dispositivo de esta clase, seguramente
	  con el tiempo irán siendo mas comunes.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Network device support</term>
      <listitem>
	<para>Esta sección engloba a todas las opciones de soporte de
	  interfaces de red, desde ethernet de 10, 100 y 1000 Mbps,
	  pasando por <acronym>SLIP</acronym>, <acronym>PPP</acronym>,
	  <acronym>PLIP</acronym>, hasta interfaces
	  <acronym>WAN</acronym>, Token Ring y otras. Normalmente se
	  deberán activar las opciones de soporte para placas ethernet
	  e interfaces <acronym>PPP</acronym> (si es que se utilizará
	  módem).</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Amateur Radio support</term>
      <listitem>
	<para>Los aficionados a las comunicaciones radiales no quedan
	  de lado en lo que respecta a soporte en el núcleo. Linux
	  tiene soporte para varios <acronym>TNCs</acronym>, o para
	  simular un <acronym>TNC</acronym> usando una placa de
	  sonido, de tal forma de poder conectarse con otros equipos
	  mediante el protocolo AX.25.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>IrDA (infrared) support</term>
      <listitem>
	<para>Esta sección generalmente es para las notebooks, que
	  poseen un puerto infrarrojo. IrDA es un protocolo de
	  transferencia de datos vía infrarrojo que se encuentra
	  normalmente en <acronym>PDAs</acronym> (como las Palm)
	  permitiendo así sincronizar los datos de la
	  <acronym>PDA</acronym> en una notebook sin necesidad de
	  conectarla con un cable serie o
	  <acronym>USB</acronym>.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>ISDN subsystem</term>
      <listitem>
	<para><acronym>ISDN</acronym> (o <acronym>RDSI</acronym>, como
	  se lo llama en España) es un tipo especial de servicios
	  digitales de telefonía. Normalmente se lo utiliza para
	  conectarse a Internet, teniendo una velocidad mucho mayor
	  que conectando se con módem. Actualmente se está dejando de
	  lado <acronym>ISDN</acronym> en favor de
	  <acronym>ADSL</acronym>, en Argentina por ejemplo,
	  <acronym>ISDN</acronym> no se ha visto, por su alto
	  costo.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Old CD-ROM drivers (not SCSI, not IDE)</term>
      <listitem>
	<para>En esta sección se da soporte a aquellas unidades de
	  CD-ROMs antiguas que no eran compatibles con las normas
	  <acronym>IDE</acronym> ni
	  <acronym>SCSI</acronym>. Generalmente eran unidades que
	  había que conectar a placas de sonido, actualmente no se ven
	  esta clase de unidades de CD-ROM.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Input core support</term>
      <listitem>
	<para>Las opciones que esta sección provee, permiten la
	  configuración de dispositivos de entrada del tipo
	  <acronym>USB</acronym>, tales como teclados, mouses,
	  etc.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Multimedia devices</term>
      <listitem>
	<para>Esta sección contiene las opciones necesarias para dar
	  soporte a dispositivos de captura de vídeo y tarjetas de
	  radio.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>File systems</term>
      <listitem>
	<para>Los sistemas de archivos son los formatos que se le dan
	  a las particiones para poder almacenar archivos, administrar
	  los atributos de cada archivo, etc. Esta sección posee las
	  opciones de soporte de sistemas de archivos tanto nativos de
	  GNU/Linux como de otros sistemas operativos, como por
	  ejemplo FAT32. Es importante tener en cuenta que el soporte
	  para el sistema de archivo que se esté utilizando en el
	  sistema debe estar compilado dentro del núcleo y no como
	  módulo, normalmente este sistema es el <emphasis>Second
	  extended filesystem</emphasis> (e2fs). En los últimos
	  núcleos se puede configurar el soporte para un nuevo sistema
	  de archivos nativo de GNU/Linux: el <emphasis>Reiser
	  filesystem</emphasis> (reiserfs), el cual es un sistema de
	  archivos jornalizado, que provee ciertas características que
	  lo hacen mas seguro que el e2fs. Además se provee opciones
	  para dar soporte a varios sistemas de archivos de red, que
	  permiten utilizar discos remotos como si fueran locales al
	  equipo, como por ejemplo <acronym>NFS</acronym>
	  (generalmente se utiliza en los UN*X),
	  <acronym>SMB</acronym> (plataformas Windows) y
	  <acronym>NCP</acronym> (volúmenes NetWare).</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Console drivers</term>
      <listitem>
	<para>Aquí se encuentran las opciones para configurar el tipo
	  de consola que se usará en el sistema. Dependiendo de la
	  tarjeta de vídeo que se posea, se puede configurar para que
	  la consola tenga el típico formato de 80x25 caracteres, o
	  mas resolución. También se puede configurar el núcleo para
	  soportar mas de una placa de vídeo, pudiendo tener dos
	  monitores, uno como consola de texto y otro como consola
	  gráfica.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Sound</term>
      <listitem>
	<para>Esta sección contiene las opciones de sonido, pudiendo
	  configurar una gama de tarjetas de sonido bastante
	  amplia.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>USB support</term>
      <listitem>
	<para>Esta sección provee soporte para distintos dispositivos
	  <acronym>USB</acronym>, desde escáneres, dispositivos de
	  almacenamiento de datos, reproductores de MP3, módems,
	  impresoras hasta adaptadores de red.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Kernel hacking</term>
      <listitem>
	<para>Esta sección contiene una opción que se utiliza cuando
	  se prueban núcleos en desarrollo, generalmente no se
	  necesitará (ni tampoco será muy seguro) activar esta opción,
	  a menos que se esté colaborando con el desarrollo del
	  núcleo.</para>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>Una vez seleccionadas todas las opciones, se debe salir del
    sistema de configuración del núcleo y salvar los cambios. Las
    opciones seleccionadas del núcleo se guardarán en el un archivo
    llamado <filename>.config</filename> dentro del árbol de fuentes
    del núcleo. Esto es interesante saberlo para poder copiarlo en
    algún sitio como respaldo y no perder las configuraciones del
    núcleo si necesitamos alguna vez borrar todos los archivos (por
    cuestión de espacio, por ejemplo).</para>

  <para>Una vez que se ha salido del sistema de configuración del
    núcleo, antes de compilar se deben generar las dependencias con el
    siguiente comando:</para>

<screen>
<prompt>root@maquina:/usr/src/linux#</prompt> <userinput>make dep</userinput>
</screen>

  <para>Luego se compila el núcleo:</para>

<screen>
<prompt>root@maquina:/usr/src/linux#</prompt> <userinput>make bzImage</userinput>
</screen>

  <para>Esto puede tardar algunos minutos, dependiendo de la potencia
    del procesador y la cantidad de memoria RAM del equipo.</para>

  <para>La opción <option>bzImage</option> (tener en cuenta las
    mayúsculas) le dice al compilador que genere el archivo del núcleo
    y lo comprima con <command>bzip2</command>.  Antes se utilizaba la
    opción <option>zImage</option> que generaba un núcleo comprimido
    con <command>gzip</command>, pero tenía un límite de tamaño que
    actualmente se ha sobrepasado por la cantidad de opciones que
    posee el núcleo. <command>bzip2</command> comprime mejor que
    <command>gzip</command>.</para>

  <para>Luego de generar el núcleo, se deben generar los módulos, con
    el comando:</para>

<screen>
<prompt>root@maquina:/usr/src/linux#</prompt> <userinput>make modules</userinput>
</screen>

  <para>Esta etapa quizás tome mas tiempo que la anterior, dependiendo
    de la cantidad de opciones que se hayan elegido como
    módulos.</para>

  <para>Una vez finalizado, se deben instalar los módulos de la
    siguiente manera:</para>

<screen>
<prompt>root@maquina:/usr/src/linux#</prompt> <userinput>make modules_install</userinput>
</screen>

  <para>Y por último, se debe copiar el archivo del núcleo a algún
    sitio donde estén alojados normalmente los núcleos, como por
    ejemplo el directorio <filename
    class="directory">/boot/</filename>. El archivo del núcleo,
    suponiendo que el conjunto de archivos fuente del núcleo se haya
    almacenado en el directorio <filename
    class="directory">/usr/src/linux/</filename>, se encuentra en
    <filename>/usr/src/linux/arch/i386/boot/bzImage</filename>.</para>

  <para>Como último paso, se debe configurar el
    <command>LILO</command> para poder probar el nuevo núcleo, pero
    esto se ve en <olink
    targetdoc="contenido/PersonalizandoElKernel/LILO"
    targetptr="subseccion:LILO"/>.</para>

  <para>A modo de información, es conveniente comentar el uso de una
    utilidad bastante práctica. El comando <command>dmesg</command> imprime en
    pantalla los diferentes mensajes de inicio que el núcleo muestra
    cuando se arranca el sistema. Esto puede ser muy útil cuando se
    necesita chequear mensajes de error que no se han podido leer bien
    en el arranque.</para>
</section>
