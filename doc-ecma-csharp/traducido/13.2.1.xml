<?xml version="1.0"?>
<clause number="13.2.1" title="Conversiones numéricas explícitas">
  <paragraph>Las conversiones numérica explícitas son conversiones desde <non_terminal where="11.1">tipo-numérico</non_terminal> a otro <non_terminal where="11.1">tipo-numérico</non_terminal> para las que no existe una conversión numérica implícita (<hyperlink>13.1.2</hyperlink>): <list><list_item> De <keyword>sbyte</keyword> a <keyword>byte</keyword>, <keyword>ushort</keyword>, <keyword>uint</keyword>, <keyword>ulong</keyword>, o <keyword>char</keyword>. </list_item><list_item> De <keyword>byte</keyword> a <keyword>sbyte</keyword> y <keyword>char</keyword>. </list_item><list_item> De <keyword>short</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>ushort</keyword>, <keyword>uint</keyword>, <keyword>ulong</keyword>, o <keyword>char</keyword>. </list_item><list_item> De <keyword>ushort</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, o <keyword>char</keyword>. </list_item><list_item> De <keyword>int</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, <keyword>ushort</keyword>, <keyword>uint</keyword>, <keyword>ulong</keyword>, o <keyword>char</keyword>. </list_item><list_item> De <keyword>uint</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, <keyword>ushort</keyword>, <keyword>int</keyword>, o <keyword>char</keyword>. </list_item><list_item> De <keyword>long</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, <keyword>ushort</keyword>, <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>ulong</keyword>, o <keyword>char</keyword>. </list_item><list_item> De <keyword>ulong</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, <keyword>ushort</keyword>, <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, o <keyword>char</keyword>. </list_item><list_item> De <keyword>char</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, o <keyword>short</keyword>. </list_item><list_item> De <keyword>float</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, <keyword>ushort</keyword>, <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, <keyword>ulong</keyword>, <keyword>char</keyword>, o <keyword>decimal</keyword>. </list_item><list_item> De <keyword>double</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, <keyword>ushort</keyword>, <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, <keyword>ulong</keyword>, <keyword>char</keyword>, <keyword>float</keyword>, a <keyword>decimal</keyword>. </list_item><list_item> De <keyword>decimal</keyword> a <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, <keyword>ushort</keyword>, <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, <keyword>ulong</keyword>, <keyword>char</keyword>, <keyword>float</keyword>, o <keyword>double</keyword>. </list_item></list></paragraph>
  <paragraph>Debido a que las conversiones explícitas incluyen todas las conversiones numéricas implícitas y explícitas siempre es posible convertir de cualquier <non_terminal where="11.1">tipo-numérico</non_terminal> a cualquier otro <non_terminal where="11.1">tipo-numérico</non_terminal> usando expresiones de plantilla (<hyperlink>14.6.6</hyperlink>). </paragraph>
  <paragraph>Es posible que las conversiones numéricas explícitas provoquen pérdida de información o excepciones. Las conversiones numéricas explícitas se procesan de la siguiente manera: <list><list_item> Para las conversiones de un tipo integral a otro el procesado depende del contexto de chequeo de desbordamiento (<hyperlink>14.5.12</hyperlink>) en el que se realiza: </list_item><list><list_item> En un contexto de chequeo de desbordamiento, la conversión funciona si el valor del operando origen está dentro del rango válido del tipo destino, pero produce la excepción System.OverflowException si el valor está fuera del rango. </list_item><list_item> En un contexto de no chequeo de desbordamiento, la conversión siempre funciona y procede de la siguiente manera: </list_item><list><list_item> Si el tipo origen es mayor que el tipo destino, el valor se trunca descartando sus bits más significativos &quot;extra&quot;. El resultado, entonces, es tratado como un valor del tipo destino. </list_item><list_item> Si el tipo origen es más pequeño que el tipo destino, el valor de origen se extiende "por signo" o "por ceros" para que tenga el mismo tamaño que el tipo destino. Se extiende por signo si el tipo origen tiene signo; si no tiene signo se extiende con ceros. Entonces el resultado es tratado como un valor del tipo destino. </list_item><list_item> Si el tipo origen es del mismo tamaño que el tipo destino, el valor es tratado como un valor del tipo destino. </list_item></list></list><list_item> Para una conversión de <keyword>decimal</keyword> a un tipo integral, el valor es redondeado hacia cero hasta el valor integral más cercano. Si el resultado está fuera del rango del tipo destino, se produce una excepción System.OverflowException. </list_item><list_item> Para una conversión de <keyword>float</keyword> o <keyword>double</keyword> a un tipo integral, el procesado depende del contexto de chequeo de desbordamiento (<hyperlink>14.5.12</hyperlink>) en el que se encuentre: </list_item><list><list_item> En un contexto de chequeo de desbordamiento, la conversión procede de la siguiente manera: </list_item><list><list_item> El valor es redondeado hacia cero hasta el valor integral más cercano. Si el valor está dentro del rango del tipo destino, este será el resultado de la conversión. </list_item><list_item> En otro caso, se producirá una excepción System.OverflowException. </list_item></list><list_item> En un contexto de no chequeo de desbordamiento, la conversión siempre funciona y procede de la siguiente forma: </list_item><list><list_item> El valor es redondeado hacia cero hasta el valor integral más cercano. Si este valor está dentro del rango del tipo destino, este será el resultado de la conversión. </list_item><list_item> En otro caso, el resultado es un valor indeterminado del tipo destino. </list_item></list></list><list_item> Para una conversión de <keyword>double</keyword> a <keyword>float</keyword>, se redondea el valor al <keyword>float</keyword> más cercano. Si el <keyword>double</keyword> es demasiado pequeño el resultado será cero. Si el <keyword>double</keyword> es demasiado grande el resultado sera infinito positivo o infinito negativo. Si el <keyword>double</keyword> es NaN el resultado será también NaN. </list_item><list_item> Para una conversión de <keyword>float</keyword> o <keyword>double</keyword> a <keyword>decimal</keyword>, el valor es convertido a la representación del tipo <keyword>decimal</keyword> y redondeado al número más cercano después de la vigésimo octava (28ª) posición de un <keyword>decimal</keyword> si es necesario (<hyperlink>11.1.6</hyperlink>). Si el valor es demasiado pequeño el resultado será cero. Si el valor es NaN, infinito, o demasiado grande se producirá una excepción System.OverflowException. </list_item><list_item> Para una conversión de <keyword>decimal</keyword> a <keyword>float</keyword> o <keyword>double</keyword>, el valor es redondeado hasta el <keyword>double</keyword> o <keyword>float</keyword> más cercano. Mientras que esta conversión puede perder precisión nunca producirá una excepción. </list_item></list></paragraph>
</clause>

    <!-- traducción Carlos Prado, carlos.prado@hispalinux.es -->