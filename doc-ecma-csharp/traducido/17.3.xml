<?xml version="1.0"?>
<clause number="17.3" title="Constantes">
  <paragraph>Una constantes es un miembro de clase que representa un valor constante: un valor que puede ser computado en tiempo de compilación. Una <non_terminal where="17.3">declaración-de-constante</non_terminal> introduce uno o mas constantes del tipo dado. <grammar_production><name><non_terminal where="17.3">declaración-de-constante</non_terminal></name> : <rhs><non_terminal where="24.2">atributos</non_terminal><opt/><non_terminal where="17.3">modificadores-de-constante</non_terminal><opt/><keyword>const</keyword><non_terminal where="11">tipo</non_terminal><non_terminal where="17.3">declaradores-de-constante</non_terminal><terminal>;</terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.3">modificador-de-constante</non_terminal>s</name> : <rhs><non_terminal where="17.3">modificador-de-constante</non_terminal></rhs><rhs><non_terminal where="17.3">modificadores-de-constante</non_terminal><non_terminal where="17.3">modificador-de-constante</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.3">modificador-de-constante</non_terminal></name> : <rhs><keyword>new</keyword></rhs><rhs><keyword>public</keyword></rhs><rhs><keyword>protected</keyword></rhs><rhs><keyword>internal</keyword></rhs><rhs><keyword>private</keyword></rhs></grammar_production><grammar_production><name><non_terminal where="17.3">declaradores-de-constante</non_terminal></name> : <rhs><non_terminal where="17.3">declarador-de-constante</non_terminal></rhs><rhs><non_terminal where="17.3">declaradores-de-constante</non_terminal><terminal>,</terminal><non_terminal where="17.3">declarador-de-constante</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.3">declarador-de-constante</non_terminal></name> : <rhs><non_terminal where="9.4.2">identificador</non_terminal><terminal>=</terminal><non_terminal where="14.15">expresión-constante</non_terminal></rhs></grammar_production></paragraph>
  <paragraph>Una <non_terminal where="17.3">declaración-de-constante</non_terminal> puede incluir un juego de atributos (<hyperlink>24</hyperlink>), un modificador new (<hyperlink>17.2.2</hyperlink>), y una combinación valida de cuatro modificadores de acceso (<hyperlink>17.2.3</hyperlink>). Los atributos y modificadores aplican a todos los miembros declarados por la <non_terminal where="17.3">declaración-de-constante</non_terminal>. Inclusive aunque constantes son consideradas miembros estáticos, una <non_terminal where="17.3">declaración-de-constante</non_terminal> no requiere ni permite un modificador static. Es un error para el mismo modificador aparecer múltiples ocasiones en una declaración de constante. </paragraph>
  <paragraph>El tipo de una <non_terminal where="17.3">declaración-de-constante</non_terminal> especifica el tipo de los miembros introducidos por la declaración. El tipo es seguido por una lista de <non_terminal where="17.3">declaradores-de-constantes</non_terminal>, cada uno de los cuales introduce un nuevo miembro. Un <non_terminal where="17.3">declarador-de-constante</non_terminal> consiste de un identificador que nombra al miembro, seguido por un símbolo &quot;=&quot;, seguido por una <non_terminal where="14.15">expresión-constante</non_terminal> (<hyperlink>14.15</hyperlink>) que da el valor del miembro. </paragraph>
  <paragraph>El tipo especificado en una declaración constante debe ser <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, <keyword>ushort</keyword>, <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, <keyword>ulong</keyword>, <keyword>char</keyword>, <keyword>float</keyword>, <keyword>double</keyword>, <keyword>decimal</keyword>, <keyword>bool</keyword>, string, un <non_terminal where="11.1">tipo-enumeración</non_terminal>, o un <non_terminal where="11.2">tipo-por-referencia</non_terminal>. Cada <non_terminal where="14.15">expresión-constante</non_terminal> debe producir un valor del tipo apunto o de un tipo que puede ser convertido al tipo apuntado por una conversión implícita (<hyperlink>13.1</hyperlink>). </paragraph>
  <paragraph>El tipo de una constante debe ser al menos accesible como la constante misma (<hyperlink>10.5.4</hyperlink>). </paragraph>
  <paragraph>El valor de una constante es obtenida en una expresión usando un <non_terminal where="14.5.2">nombre-simple</non_terminal> (<hyperlink>14.5.2</hyperlink>) o un <non_terminal where="14.5.4">acceso-al-miembro</non_terminal> (<hyperlink>14.5.4</hyperlink>). </paragraph>
  <paragraph>Una constante puede en si misma participar en una <non_terminal where="14.15">expresión-constante</non_terminal>. De esta forma, una constante puede ser usada en cualquier construcción que requiera una <non_terminal where="14.15">expresión-constante</non_terminal>. <note>[Nota: Ejemplo de dichas construcciones incluyen etiquetas case, sentencias goto case, declaraciones de miembros enumeración, atributo, y otras declaraciones constantes. fin nota]</note> </paragraph>
  <paragraph>
    <note>[Nota: Como esta descrito en <hyperlink>14.15</hyperlink>, una <non_terminal where="14.15">expresión-constante</non_terminal> es una expresión que puede ser totalmente evaluada en tiempo de compilación. Debido a que la única forma de crear un valor no-nulo de un <non_terminal where="11.2">tipo-por-referencia</non_terminal> otro que una cadena es aplicar el operador new, y debido a que el operador new no esta permitido una <non_terminal where="14.15">expresión-constante</non_terminal>, el único valor posible de constantes de <non_terminal where="11.2">tipos-por-referencia</non_terminal> otros que la cadena es null. fin nota]</note>
  </paragraph>
  <paragraph>Cuando un nombre simbólico para un valor constate es deseado, pero cuando el tipo de ese valor no esta permitido en una declaración constante, o cuando el valor no puede ser computado en tiempo de compilación por una <non_terminal where="14.15">expresión-constante</non_terminal>, un campo de solo lectura (<hyperlink>17.4.2</hyperlink>) puede ser usado. <note>[Nota: La semántica de las versiones de constantes y solo lectura difieren (<hyperlink>17.4.2.2</hyperlink>). fin nota]</note> </paragraph>
  <paragraph>Una declaración de constante que declara múltiples constantes es equivalente a múltiples declaraciones de constantes sencillas con los mismos atributos, modificadores, y tipo. <example>[Ejemplo: Por ejemplo <code_example><![CDATA[
class A  
{  
   public const double X = 1.0, Y = 2.0, Z = 3.0;  
}  
]]></code_example>es equivalente a <code_example><![CDATA[
class A  
{  
   public const double X = 1.0;  
   public const double Y = 2.0;  
   public const double Z = 3.0;  
}  
]]></code_example>fin ejemplo]</example> </paragraph>
  <paragraph>Constantes permiten depender de otras constantes dentro del mismo programa como <keyword>long</keyword> como esas dependencias que no son de una naturaleza circular. El compilador automáticamente organiza para evaluar las declaraciones de constantes en el orden apropiado. <example>[Ejemplo: En el ejemplo<code_example><![CDATA[
class A  
{  
   public const int X = B.Z + 1;  
   public const int Y = 10;  
}  
class B  
{  
   public const int Z = A.Y + 1;  
}  
]]></code_example>el compilador primero evalúa A.Y, después evalúa B.Z, y finalmente evalúa A.X, produciendo los valores 10, 11, y 12. fin ejemplo] </example> Declaraciones constantes pueden depender de constantes de otros programas, pero dichas dependencias son únicamente posibles en una dirección. <example>[Ejemplo: Refiriéndose al ejemplo anterior, si A y B fueron declaradas en programas separados, podría ser posible para A.X depender de B.Z, pero B.Z no podría depender simultáneamente de A.Y. fin ejemplo]</example> </paragraph>
</clause>
<!-- Traducido por Mario Carrión, marioc@unixmexico.org -->
