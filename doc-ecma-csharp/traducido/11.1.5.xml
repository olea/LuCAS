<?xml version="1.0"?>
<clause number="11.1.5" title="Tipos de punto flotante">
  <paragraph>C# soporta dos tipos de punto flotante: <keyword>float</keyword> y <keyword>double</keyword>. Los tipos <keyword>float</keyword> y <keyword>double</keyword> son representados usando la precisión sencilla de 32-bits y la precisión doble con formato IEEE 754, el cual provee los siguientes juegos de valores: <list><list_item> Cero positivo y cero negativo. En mucha situaciones, cero positivo o cero negativo se comportan idénticamente como el valor simple cero, pero en algunas operaciones se distinguen entre los dos (<hyperlink>14.7.2</hyperlink>). </list_item><list_item> Infinito positivo e infinito negativo. Infinitos son producidos por operaciones como dividir un valor que no sea cero entre cero. <example>[Ejemplo: Por ejemplo, 1.0 / 0.0 produce un infinito positivo, y -1.0 / 0.0 produce un infinito negativo. fin ejemplo]</example> </list_item><list_item> El valor No-un-Numero, a menudo abreviado como NaN. NaNs son producidos por operaciones de punto flotante invalidas, como dividir cero entre cero. </list_item><list_item> El juego finito de valores no-cero de la forma s <unicode>215</unicode> m <unicode>215</unicode> 2<super>e</super>, donde s es 1 o <unicode>8722</unicode>1, y m y e son determinado por el tipo de punto flotante particular: Para <keyword>float</keyword>, 0 &lt; m &lt; 2<super>24</super> and <unicode>8722</unicode>149 <unicode>8804</unicode> e <unicode>8804</unicode> 104, y para <keyword>double</keyword>, 0 &lt; m &lt; 2<super>53</super> y <unicode>8722</unicode>1075 <unicode>8804</unicode> e <unicode>8804</unicode> 970. Números de punto flotante desnormalizados son considerados como valores no-cero validos. </list_item></list></paragraph>
  <paragraph>El tipo <keyword>float</keyword> puede representar valores en el rango aproximado de 1.5 <unicode>215</unicode> 10<super>-45</super> a 3.4 <unicode>215</unicode> 10<super>38</super> con una precisión de 7 dígitos. </paragraph>
  <paragraph>El tipo <keyword>double</keyword> puede representar valores en el rango aproximado de 5.0 <unicode>215</unicode> 10<super>-324</super> a 1.7 <unicode>215</unicode> 10<super>308</super> con una precisión de 15-16 dígitos. </paragraph>
  <paragraph>Si uno de los operandos de un operador binario es de tipo punto flotante, entonces el otro operando debe ser un tipo entero o un tipo punto flotante, y la operación es evaluada como sigue: <list><list_item> Si uno de los operandos es de un tipo entero, entonces ese operando es convertido a un tipo de punto flotante del otro operando. </list_item><list_item> Después, si cualquiera de los operandos es de tipo <keyword>double</keyword>, el otro operador es convertido a <keyword>double</keyword>, la operación es realizada usando al menos un rango y precisión de <keyword>double</keyword>, y el tipo del resultado es <keyword>double</keyword> (o <keyword>bool</keyword> para operadores relacionales). </list_item><list_item> De otra forma, la operación es realizada usando al menos un rango y precisión <keyword>float</keyword>, y el tipo del resultado es <keyword>float</keyword> (o <keyword>bool</keyword> para operadores relacionales). </list_item></list></paragraph>
  <paragraph>Los operadores de punto flotante, incluyen los operadores de asignación, nunca producen excepciones. En cambio, en situaciones excepcional, los operaciones de punto flotante producen cero, infinito, o NaN, como los describe: <list><list_item> Si el resultado de una operación de punto flotante es muy pequeña para el formato destino, el resultado de la operación se convierte  un cero positivo o cero negativo. </list_item><list_item> Si el resultado de la operación de punto-flotante es muy larga para el formato de destino, el resultado de la operación se convierte en un infinito positivo o infinito negativo. </list_item><list_item> Si la operación de punto flotante es invalida, el resultado de las operaciones convierte a NaN. </list_item><list_item> Si uno o los dos operandos de una operación de punto flotante es NaN, el resultado se convierte a NaN. </list_item></list></paragraph>
  <paragraph>Las operaciones de punto flotante, pueden ser realizadas con mayor precisión que el tipo del resultado de la operación. <example>[Ejemplo: Por ejemplo, algunas arquitecturas de hardware soportan un tipo de punto flotante &quot;extendido&quot; o &quot;long double&quot; con mayor rango y precisión que el tipo <keyword>double</keyword>, e implícitamente permiten realizar operaciones de punto flotante usando este tipo de precisión mayor. Solo como costo excesivo en desempeño puede que en dichas arquitecturas de hardware sea hecho para realizar operaciones de punto flotante con menor precisión, y mejor dicho que requieran una implementación para perder desempeño y precisión, C# permite un tipo de precisión tiene resultados medibles. De cualquier modo, en expresiones de la forma x * y / z, donde la multiplicación produce un resultado fuera del rango de <keyword>double</keyword>, pero la división subsecuente trae el resultado temporal de regreso al valor del <keyword>double</keyword>, el hecho de que la expresión es evaluada en un forma de rango mayor puede causar un resultado finito en vez de infinito. fin ejemplo]</example> </paragraph>
</clause>
<!-- Traducido por Mario Carrión, marioc@unixmexico.org -->
