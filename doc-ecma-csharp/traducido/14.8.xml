<?xml version="1.0"?>
<clause number="14.8" title="Operadores de movimiento">
  <paragraph>Los operadores &lt;&lt; y &gt;&gt; son usados para realizar operaciones de movimiento a nivel de bit. <grammar_production><name><non_terminal where="14.8">expresión-de-movimiento</non_terminal></name> : <rhs><non_terminal where="14.7">expresión-aditiva</non_terminal></rhs><rhs><non_terminal where="14.8">expresión-de-movimiento</non_terminal><terminal>&lt;&lt;</terminal><non_terminal where="14.7">expresión-aditiva</non_terminal></rhs><rhs><non_terminal where="14.8">expresión-de-movimiento</non_terminal><terminal>&gt;&gt;</terminal><non_terminal where="14.7">expresión-aditiva</non_terminal></rhs></grammar_production></paragraph>
  <paragraph>Para una operación de la forma conteo x &lt;&lt; o conteo x &gt;&gt;, resolución de sobrecarga de operador binario (<hyperlink>14.2.4</hyperlink>) es aplicada para seleccionar una implementación de operador específico. Los operandos son convertidos a los tipos de parámetros del operador seleccionado, y el tipo del resultado es regresado al tipo del operador. </paragraph>
  <paragraph>Cuando se declara un operador de movimiento sobrecargado, el tipo del primer operando debe ser siempre la clase o estructura conteniendo la declaración del coperador, y el tipo del segundo operando debe ser siempre <keyword>int</keyword>. </paragraph>
  <paragraph>Los operadores de movimiento predifinidos son listados a continuación. <list><list_item> Movimiento a la izquierda: <code_example><![CDATA[
int operator <<(int x, int count);  
uint operator <<(uint x, int count);  
long operator <<(long x, int count);  
ulong operator <<(ulong x, int count);  
]]></code_example>El operador &lt;&lt; mueve x a la izquierda por un número de bits computados como se describe antes. Los bits de altor orden fuera del rango del tipo de resultado son descartados, los bits resultantes son movidos la izquierda, y las posiciones de orden bajos vacios son establecidos a cero. </list_item><list_item> Movimiento a la derecha: <code_example><![CDATA[
int operator >>(int x, int count);  
uint operator >>(uint x, int count);  
long operator >>(long x, int count);  
ulong operator >>(ulong x, int count);  
]]></code_example>El operador &gt;&gt; mueve x a la derecha por un número de bits computados como se describe antes. Cuando x es del tipo <keyword>int</keyword> o <keyword>long</keyword>, los bits de orden bajo son descartados, los bits faltantes son movidos a la derecha, y las posiciones vacias de orden alto son establecidos a cero si x no es negativo y establecido a uno si x es negativo. Cuando x es de tipo <keyword>uint</keyword> o <keyword>ulong</keyword>, los bits de orden bajo de x son descartados, los bits faltantes son movidos a la derecha, y las posiciones de bit de orden alto vacios son establecidos a cero. </list_item></list></paragraph>
  <paragraph>Para los operadores predefinidos, el número de bits para mover es computado como sigue: <list><list_item> Cuando el tipo de x es <keyword>int</keyword> o <keyword>uint</keyword>, el conteo de movimiento es dado por los cinco bits de orden bajo del conteo. En otras palabras, el conteo del movimiento es computado del conteo &amp; 0x1F. </list_item><list_item> Cuando el tipo de x es <keyword>long</keyword> o <keyword>ulong</keyword>, el movimiento del conteo es dado por los seis bits más bajos del conteo. En otras palabras, el conteo del movimiento es computado desde el conteo &amp; 0x3F. </list_item></list></paragraph>
  <paragraph>Si el conteo de movimiento es cero, los operadores de movimiento simplemente retornan el valor de x. </paragraph>
  <paragraph>Operaciones de movimiento nunca causan sobreflujos y producen los mismos resultados en contextos checados (checked) y sin checar (unchecked). </paragraph>
  <paragraph>Cuando el operando de la izquierda del operador &gt;&gt; es un tipo entero con signo, el operador realiza un movimiento aritmético a la derecha en donde el bit más significante (el signo del bit) del operando es propagado a las posiciones de orden más alto vacias. cuando el operador de la izquierda del operador &gt;&gt; es un tipo entero sin signo, el operador realiza un movimiento lógico en donde las posiciones de bit de alto orden vacias son siempre establecidas a cero. Para realizar la operación opuesta de esa inferencia del tipo de operando, casts explícitos pueden ser usados. Por ejemplo, si x es un variable de tipo <keyword>int</keyword>, la operación sin checar (unchecked)((<keyword>int</keyword>)((<keyword>uint</keyword>)x &gt;&gt; y)) realiza un movimiento lógico a la derecha de x. </paragraph>
</clause>
<!-- Traducido por Mario Carrión, mario.carrion@gmail.com -->
