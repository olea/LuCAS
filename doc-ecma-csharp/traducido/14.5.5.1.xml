<?xml version="1.0"?>
<clause number="14.5.5.1" title="Invocaciones de métodos">
  <paragraph>Para una invocación de método, la <non_terminal where="14.5">expresión-primaria</non_terminal> de la <non_terminal where="14.5.5">expresión-de-invocación</non_terminal> debe ser un grupo de método. El grupo de método identifica el método uno para invocar o el juego método sobrecargado del cual se debe escoger un método específico para invocar. En éste caso, la determinación del método específico a invocar esta basado en el contexto provisto por los tipos de los argumentos en la <non_terminal where="14.4.1">lista-de-argumentos</non_terminal>. </paragraph>
  <paragraph>El procesamiento de tiempo de compilación del método de invocación de la forma M(A), donde M es un grupo método y A es una <non_terminal where="14.4.1">lista-de-argumentos</non_terminal> opcional, consiste de los siguientes pasos: <list><list_item> l juego de métodos candidatos para la invocación de métodos es construido. Iniciando con el juego de métodos asociados con M, donde fueron fue encontrado por una búsqueda de miembro previa (<hyperlink>14.3</hyperlink>), el juego es reducido para esos métodos que son aplicables con respecto a lista de argumentos A. La reducción del juego consiste en aplicar las siguientes reglas para cada método T.N en el juego, donde T es el tipo en el cual método N es declarado: </list_item><list><list_item> Si N no es aplicable con respecto a   (<hyperlink>14.4.2.1</hyperlink>), entonces N es removido del juego. </list_item><list_item> Si N es aplicable con respecto a A (<hyperlink>14.4.2.1</hyperlink>), entonces todos los métodos declarados en un tipo base de T son removidos del juego. </list_item></list><list_item> Si el juego resultando de los métodos candidatos esta vacío, entonces no existen métodos aplicables, y un error en tiempo de compilación ocurre. Si los métodos candidatos no son declarados en la misma forma, la invocación de métodos es ambigua, un error en tiempo de compilación ocurre (esto ultima  situación puede únicamente ocurrir para una invocación de método en una interfaz que tiene múltiples interfaces base directas, como descrito en <hyperlink>20.2.5</hyperlink>). </list_item><list_item> El mejor método del juego candidato es identificado usando las reglas de resolución de sobrecarga de <hyperlink>14.4.2</hyperlink>. Si un método sencillo no puede ser identificado, la invocación del método es ambigua, y un error en tiempo de compilación ocurre. </list_item><list_item> Dado el mejor método, la invocación del método es validado en el contexto del grupo de métodos: Si el mejor método es un método estático, el grupo de métodos debe haber resultado de un <non_terminal where="14.5.2">nombre-simple</non_terminal> o un  <non_terminal where="14.5.4">acceso-a-miembro</non_terminal> a través de un tipo. SI el mejor método es una instancia de método, el grupo de método debe haber resultado de un <non_terminal where="14.5.2">nombre-simple</non_terminal>, un <non_terminal where="14.5.4">acceso-a-miembro</non_terminal> a través de una variable o valor, o un <non_terminal where="14.5.8">acceso-base</non_terminal>. Si ninguno de esos requerimiento son verdaderos, un error en tiempo de compilación ocurre. </list_item></list></paragraph>
  <paragraph>Una vez que un método ha sido seleccionado y validado en tiempo de compilación por los pasos anteriores, la invocación actual en tiempo de ejecución es procesada de acuerdo a las reglas de invocación de miembro función descritas en <hyperlink>14.4.3</hyperlink>. </paragraph>
  <paragraph>
    <note>[Nota: El efecto intuitivo de las reglas de resolución descritas antes como sigue: Para localizar el método particular invocado por una invocación de método, inicie con el tipo indicado por una invocación de método y prosiga la cadena de herencia hasta que al menos un  método aplicable, accesible y no-override sea encontrado. </note>
  </paragraph>
  <paragraph>
    <note>Entonces reemplace la resolución en el juego de métodos aplicables, accesibles, no-override declarados en ese tipo e invoque el método de esta manera seleccionado. fin nota]</note>
  </paragraph>
</clause>
<!-- Traducido por Mario Carrión, marioc@unixmexico.org -->
