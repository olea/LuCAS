<?xml version="1.0"?>
<clause number="13.4.2" title="Evaluación de conversiones definidas por el usuario">
  <paragraph>una conversión definida por el usuario convierte un valor de su tipo, llamado tipo origen, a otro tipo, llamado tipo destino. La evaluación de una conversión definida por el usuario se centra en encontrar la conversión definida por el usuario más especifica para los tipos origen y destino en particular. Esta operación se divide en muchos pasos: <list><list_item> Encontrar el conjunto de clases y estructuras cuyos operadores definidos por el usuario pueden aplicarse. Este conjunto consiste en el tipo origen y sus clases base y el tipo destino y sus clases base (asumiendo implícitamente que sólo las clases y estructuras pueden declarar operadores definidos por el usuario, y que tipos que no sean clases no tienen clases base). </list_item><list_item> De este conjunto de tipos, determina que operadores de conversión definidos por el usuario son aplicables. Para que un operador de conversión sea aplicable, debe ser posible realizar una conversión estándar (<hyperlink>13.3</hyperlink>) del tipo origen al tipo del operando del operador, y debe ser posible realizar una conversión estándar del tipo resultante del operador al tipo destino. </list_item><list_item> Del conjunto de operadores definidos por el usuario aplicables, determina el operador no ambiguo más específico. En general, el operador más específico es el operador con el operando más cercano al tipo origen y cuyo tipo resultante está más próximo al tipo destino. Las reglas exactas para establecer el operador definido por el usuario más específico están definidas en la siguiente sección. </list_item></list></paragraph>
  <paragraph>Una ver identificado el operador de conversión definido por el usuario más específico, la ejecución de la conversión definida por el usuario involucra los siguientes pasos: <list><list_item> Primero, si es necesario, realiza una conversión estándar del tipo origen al tipo del operando del operador de conversión. </list_item><list_item> Después, invoca al operador de conversión definido por el usuario para realizar la conversión. </list_item><list_item> Finalmente, si es necesario, realiza una conversión estándar del tipo resultado del operador de conversión definido por el usuario al tipo destino. </list_item></list></paragraph>
  <paragraph>La evaluación de conversiones definidas por el usuario nunca involucra más de un operador de conversión definido por el usuario. Es decir, una conversión del tipo S al tipo T nunca empezará ejecutando una conversión definida por el usuario del tipo S a X y después ejecuta la conversión definida por el usuario de X a T. </paragraph>
  <paragraph>La definición exacta de la evaluación de las conversiones, implícitas o explícitas, definidas por el usuario se discuten en las siguientes secciones. Las definiciones hacen uso de los siguientes términos: <list><list_item> Si una conversión implícita estándar (<hyperlink>13.3.1</hyperlink>) existe del tipo A al tipo B, y si ni A ni B son <non_terminal where="11.2">tipos-interfaz</non_terminal>, entonces se puede decir que A está contenida por B y B contiene a A. </list_item><list_item> The most encompassing type in a set of types is the one type that encompasses all other types in the set. If no single type encompasses all other types, then the set has no most encompassing type. In more intuitive terms, the most encompassing type is the &quot;largest&quot; type in the set-the one type to which each of the other types can be implicitly converted. </list_item><list_item> The most encompassed type in a set of types is the one type that is encompassed by all other types in the set. If no single type is encompassed by all other types, then the set has no most encompassed type. In more intuitive terms, the most encompassed type is the &quot;smallest&quot; type in the set-the one type that can be implicitly converted to each of the other types. </list_item></list></paragraph>
</clause>

    <!-- traducción Carlos Prado, carlos.prado@hispalinux.es -->