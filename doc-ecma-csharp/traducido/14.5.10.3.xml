<?xml version="1.0"?>
<clause number="14.5.10.3" title="Expresiones de creación de delegados">
  <paragraph>Una <non_terminal where="14.5.10.3">expresión-de-creación-de-delegado</non_terminal> es usado para crear una nueva instancia de un <non_terminal where="11.2">tipo-delegado</non_terminal>. <grammar_production><name><non_terminal where="14.5.10.3">expresión-de-creación-de-delegado</non_terminal></name> : <rhs><keyword>new</keyword><non_terminal where="11.2">tipo-delegado</non_terminal><terminal>(</terminal><non_terminal where="14.14">expresión</non_terminal><terminal>)</terminal></rhs></grammar_production></paragraph>
  <paragraph>El argumento de una expresión de creación de delegado debe ser un grupo de métodos (<hyperlink>14.1</hyperlink>) o un valor de un <non_terminal where="11.2">tipo-delegado</non_terminal>. Si el argumento es un grupo método, identifica al método y, para un método de instancia, el objeto para el cual crear un delegado. Si el argumento es un valor de un <non_terminal where="11.2">tipo-delegado</non_terminal>, identifica una instancia de delegado del cual crear una copia. </paragraph>
  <paragraph>El procesamiento en tiempo de compilación de una <non_terminal where="14.5.10.3">expresión-de-creación-de-delegado</non_terminal> de la forma new D(E), donde D es un <non_terminal where="11.2">tipo-delegado</non_terminal> y E es una expresión, consiste de los siguientes pasos: <list><list_item> Si E es un grupo de métodos: </list_item><list><list_item> El juego de métodos identificados por E debe incluir exactamente un método que es compatible (<hyperlink>22.1</hyperlink>) con D, y este método se convierte en uno el cual el recientemente delegado creado se refiere. Si no existe un método que concuerde, o si más de un método concuerde existe, un error en tiempo de compilación. Si el método seleccionado es un método de instancia, la expresión de instancia asociada con E determina el objeto objetivo del delegado. </list_item><list_item> Como en una invocación de método, el método seleccionado debe ser compatible con el contexto del grupo de métodos: Si método es método estático, el grupo de métodos debe haber resultado de un <non_terminal where="14.5.2">nombre-simple</non_terminal> o un <non_terminal where="14.5.4">acceso-a-miembro</non_terminal> a través de un tipo. Si el método es un método de instancia, el grupo de método debe haber resultado de un <non_terminal where="14.5.2">nombre-simple</non_terminal> o un <non_terminal where="14.5.4">acceso-a-miembro</non_terminal> a través de una variable o valor. Si el método seleccionado no concuerda al contexto del grupo de método, un error en tiempo de compilación ocurre. </list_item><list_item> El resultado es un valor de tipo D, es decir un recién delegado creado que se referie al método seleccionado y al objecto objectivo. </list_item></list><list_item> De otra forma, si E es un valor de tipo-delegado: </list_item><list><list_item> D y E deben ser compatibles (<hyperlink>22.1</hyperlink>); de otra forma, un error en tiempo de compilación ocurre. </list_item><list_item> El resultado de un valor de tipo D, es decir un recién delegado creado que se refiere a la misma lista de invocación como E. </list_item></list><list_item> De otra foram, la expresión de creación de delegado es invalido, y un error en tiempo de compilación ocurre. </list_item></list></paragraph>
  <paragraph>El procesamiento en tiempo de ejecución de una <non_terminal where="14.5.10.3">expresión-de-creación-de-delegado</non_terminal> de la forma new D(E), donde D es un <non_terminal where="11.2">tipo-delegado</non_terminal> y E es una expresión, consiste de los siguientes pasos: <list><list_item> Si E es un grupo de métodos: </list_item><list><list_item> Si el método seleccionado en tiempo de compilación es un método estático, el objeto objetivo del delegado es null. De otra forma, el método seleccionado es un método de instancia , y el objeto objetivo del delegado esta determinado de la expresión de instancia asociada con E: </list_item><list><list_item> La expresión de instancia es evaluado. Si la evaluación causa una excepción, no se ejecutan más pasos. </list_item><list_item> Si la expresión de instancia es de un <non_terminal where="11.2">tipo-referencia</non_terminal>, el valor computado por la expresión de instancia se convierte en el objeto objetivo. Si el objeto objetivo es null, una System.NullReferenceException es lanzada y no se ejecutan más pasos. </list_item><list_item> Si la expresión de instancia es de un <non_terminal where="11.1">tipo-por-valor</non_terminal>, una operación de empaquetado (<hyperlink>11.3.1</hyperlink>) es realizada para convertir el valor a un objeto, y este objeto se convierte en el objeto objetivo. </list_item></list><list_item>Una nueva instancia del tipo delegado D es asignada. Si no hay suficiente memoria disponible para asignar la nueva instancia, una System.OutOfMemoryException es lanzada y no se ejecutan más pasos. </list_item><list_item> La nueva instancia del delegado es inicializado con una referencia al método que fue determinado en tiempo de compilación y una referencia al objeto objetivo computado antes. </list_item></list><list_item> Si E es un valor de tipo-delegado: </list_item><list><list_item> E es evaluado. Si esa evaluación causa una excepción, no se ejecutan más pasos. </list_item><list_item> Si el valor de E es null, una System.NullReferenceException es lanzada y no se ejecutan más pasos. </list_item><list_item> Una nueva instancia del tipo delegado D es asignado. Si no hay suficiente memoria disponible para asignar la nueva instancia, una System.OutOfMemoryException es lanzada y no se ejecutan más pasos. </list_item><list_item> La nueva instancia de delegado es inicializada con ferencias a la misma lista de invocación como la instancia de delegado dada por E. </list_item></list></list></paragraph>
  <paragraph>El método y objeto para el cual el delegado se refiere esta determinado cuando el delegado es instanciado y luego permanece constante para el tiempo de vida completo del delegado. En otras palabras, no es posible cambiar el método u objeto objetivo del delegado una vez que ha sido creado. <note>[Nota: Recuerda, cuando dos delegados son combinados o uno es removido de otro, un nuevo delegado resulta; ningún delegado existenten ha cambiado en su contenido. fin nota]</note> </paragraph>
  <paragraph>No es posible crear un delegado que se refiera a una propiedad, indexador, operador definido por el usuario, constructor de instancia, destructor, o constructor estático. </paragraph>
  <paragraph>
    <example>[Ejemplo: Como descrito anteriormente, cuando un delegado es creado desde un grupo de métodos, la lista de parámetros formales y el tipo de retorno del delegado determina cual de los métodos sobrecargados seleccionar. En el ejemplo <code_example><![CDATA[
delegate double DoubleFunc(double x);  
class A  
{  
   DoubleFunc f = new DoubleFunc(Square);  
   static float Square(float x) {  
      return x * x;  
   }  
   static double Square(double x) {  
      return x * x;  
   }  
}  
]]></code_example>el campo A.f es inicializado con un delegado que se refiere al segundo método de Square porque este método exactamente concuerda con la lista de parámetros formales y el tipo de retorno de DoubleFunc. No tener el segundo método de Square presente, un error en tiempo de compilación el segundo podría ocurrir. fin ejemplo]</example>
  </paragraph>
</clause>
<!-- Traducido por Mario Carrión, mario.carrion@gmail.com -->
