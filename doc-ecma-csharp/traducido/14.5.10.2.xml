<?xml version="1.0"?>
<clause number="14.5.10.2" title="Expresiones de creación de arreglos">
  <paragraph>Una <non_terminal where="14.5.10.2">expresión-de-creación-de-arreglo</non_terminal> es usada para crear una nueva instancia de un <non_terminal where="19.1">tipo-arreglo</non_terminal>. <grammar_production><name><non_terminal where="14.5.10.2">expresión-de-creación-de-arreglo</non_terminal></name> : <rhs><keyword>new</keyword><non_terminal where="19.1">no-tipo-arreglo</non_terminal><terminal>[</terminal><non_terminal where="14.5.6">lista-de-expresiones</non_terminal><terminal>]</terminal><non_terminal where="19.1">especificadores-de-rango</non_terminal><opt/><non_terminal where="19.6">inicializador-de-arreglo</non_terminal><opt/></rhs><rhs><keyword>new</keyword><non_terminal where="19.1">tipo-arreglo</non_terminal><non_terminal where="19.6">inicializador-de-arreglo</non_terminal></rhs></grammar_production></paragraph>
  <paragraph>Una expresión de creación de arreglo de esta primera forma asigna una instancia de arreglo del tipo que resultado de borrar cada expresión individual de la lista de expresiones. Por ejemplo, la expresión de creación de arrego new int[10,20] produce una instancia de arreglo de tipo int[,], y la expresión de creación de arreglo new int[10][,] produce un arreglo de tipo int[][,]. Cada expresión en la lista de expresiones debe ser de tipo <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, o <keyword>ulong</keyword>, o de un tipo que pueda ser implícitamente convertido a uno más de esos tipos. El valor de cada expresión determina la longitud de la dimensión correspondiente en la recién instancia de arreglo asignada. Debido a que la longitud de una dimensión de arreglo debe ser no-negativa, es un error en tiempo de compilación tener una expresión constanten con un valor negativo, en la lista de expresiones. </paragraph>
  <paragraph>Excepto si esta en un contexto inseguro (<hyperlink>25.1</hyperlink>), la distribución de los arreglos no esta especificado. </paragraph>
  <paragraph>Si una expresión de creación de arreglo de la primera forma incluye un inicializador de arreglo, cada expresión en la lista de expresiones debe ser una constante y el rango y longitudes de dimensiones especificadas por la lista de expresiones debe concordar con esas del inicializador de arreglo. </paragraph>
  <paragraph>En una expresión de creación de arreglo de la segunda forma, el rango del tipo de arreglo especificado debe concordar con la del inicializador de arreglo. Las longitudes de dimensión individual son inferidas de el número de elementos en cada nivel anidado correspondiente del inicializador de arreglo. De esta forma, la expresión <code_example><![CDATA[
new int[,] {{0, 1}, {2, 3}, {4, 5}}  
]]></code_example>exactamente corresponde a <code_example><![CDATA[
new int[3, 2] {{0, 1}, {2, 3}, {4, 5}}  
]]></code_example></paragraph>
  <paragraph>Los inicializadores de arreglo son descritos más adelante en <hyperlink>19.6</hyperlink>. </paragraph>
  <paragraph>El resultado de evaluar una expresión de creación de arreglo esta clasificado como un valor, es decir una referencia a la recién instancia asignada. El procesamiento en tiempo de ejecución de una expresión de creación de arreglo consiste de los siguientes pasos: <list><list_item> La expresiones de longitud de dimensiones de la <non_terminal where="14.5.6">lista-de-expresiones</non_terminal> son evaluadas en orden, de izquierda a derecha. Después de la evaluación de cada expresión, una conversión implícita (<hyperlink>13.1</hyperlink>) a uno de los siguientes tipos es realizado: <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, <keyword>ulong</keyword>. El primer tipo en esta lista para el cual una conversión implícita existe es escogida. Si la evaluación de una expresión o la conversión implícita subsecuente causa una excepción, entonces ninguna otra expresión es evaluada y no se realizan más pasos. </list_item><list_item> Los valores computados para las longitudes de dimensión son validados, como sigue: Si uno o más de los valores es menor a cero, una System.OverflowException es lanzada y no se ejecutan más pasos. </list_item><list_item>Una instancia de arreglo con las longitudes de dimensión dadas es asignada. Si no existe memoria disponible para asignar la nueva instancia, una System.OutOfMemoryException es lanzada y no se ejecutan más pasos. </list_item><list_item> Todos los elementos de la nueva instancia de arreglo son inicializadas a sus valores por defecto (<hyperlink>12.2</hyperlink>). </list_item><list_item> Si la expresión de creación de arreglo contiene un inicializador de arreglo, entonces cada expresión en el inicializador de arreglo es evaluado y asignado a su elemento de arreglo correspondiente. Las evaluaciones y asignaciones son realizadas en el orden la expresiones son escritas en el inicializador de arreglo en otras palabras, elementos son inicializados en orden de índice incremental, con la dimensión más a la derecha incrementándose primero. Si la evaluación de una expresión dada o asignación subsecuente al correspondiente elemento del arreglo causa una excepción, entonces no se inicialización más elementos (y los elementos faltantes tendrán así sus valores por defecto). </list_item></list></paragraph>
  <paragraph>Una expresión de creación de arreglo permite instanciación de un arreglo con elementos de un tipo arreglo, pero los elementos como un arreglo deben ser inicializados manualmente. <example>[Ejemplo: Por ejemplo, la sentencia <code_example><![CDATA[
int[][] a = new int[100][];  
]]></code_example>crea un arreglo de dimensión-simple con 100 elementos de tipo int[]. El valor inicial de cada elemento es null. fin ejemplo]</example> No es posible que para la misma creación de arreglo también instancie los sub-arreglos, y la sentencia <code_example><![CDATA[
int[][] a = new int[100][5];    // Error  
]]></code_example>resulta en un error en tiempo de compilación. Instanciación de sub-arreglo debe ser realizada manualmente, como en <code_example><![CDATA[
int[][] a = new int[100][];  
for (int i = 0; i < 100; i++) a[i] = new int[5];  
]]></code_example></paragraph>
  <paragraph>Cuando un arreglo de arreglos tiene una forma &quot;rectangular&quot;, que es cuando todos los sub-arreglos son de la misma longitud, es más eficiente que usar un arreglo multi-dimensional. En el ejemplo anterior, la instanciación de los arreglos crea 101 objetos one fuera del arreglo y los 100 sub-arreglos. En contraste, <code_example><![CDATA[
int[,] = new int[100, 5];  
]]></code_example>crea un único objeto, y dos arreglos dimensionales, y cumple la asignación en una sola sentencia. </paragraph>
</clause>
<!-- Traducido por Mario Carrión, mario.carrion@gmail.com -->
