<?xml version="1.0"?>
<clause number="14.4.3" title="Invocación de miembros función">
  <paragraph>Esta sección describe el proceso que toma lugar en tiempo de ejecución para invocar un miembro función particular. Se asume que un proceso en tiempo de compilación ha determinado el miembro en particular para invocar, posiblemente al aplicar resolución de sobrecarga de operadores a un juego de miembros de función candidatos. </paragraph>
  <paragraph>Para propósitos de describir el proceso de invocación, miembros función son divididos en dos categorías: <list><list_item>Miembros función estáticos. Esos son métodos estáticos, constructores de instancia, accesores de propiedad estáticos, operadores definidos por el usuario. Miembros de función estáticos son siempre no virtuales. </list_item><list_item> Miembros de función de instancia. Esos son métodos de instancia, accesores de propiedad de instancia, y accesores de indexadores. Miembros de función de instancia son no-virtuales o virtuales, y siempre son invocados en una instancia en particular. La instancia es computada por una expresión de instancia, y se convierte accesible dentro de un miembro función como this (<hyperlink>14.5.7</hyperlink>). </list_item></list></paragraph>
  <paragraph>El procesamiento en tiempo de ejecución de una invocación de miembro función consiste de los siguientes pasos, donde M es la función miembro y, si M es un miembro de instancia, E es una expresión de instancia: <list><list_item> Si M es un miembro de función estática: </list_item><list><list_item> La lista de argumentos es evaluada como esta descrito en <hyperlink>14.4.1</hyperlink>. </list_item><list_item> M es invocado. </list_item></list><list_item> Si M es un miembro de función de instancia declarado en un tipo-valor: </list_item><list><list_item> E es evaluado. Si esta evaluación causa una excepción, no se ejecutan más pasos. </list_item><list_item> Si E no es clasificado como una variable, entonces una variable local temporal del tipo de E es creada y el valor de E es asignada a esa variable. E es entonces reclasificada como una referencia para esa variable local temporal. La variable temporal es accesible como this dentro de M, pero no de otra forma. Así, únicamente cuando E es una variable cierta es posible para quien le llama observar los cambios que M hace a this. </list_item><list_item> La lista de argumentos es evaluada como esta descrito en <hyperlink>14.4.1</hyperlink>. </list_item><list_item> M es invocado. La variable referenciada por E se convierte en la variable referenciada por this.</list_item></list><list_item>Si M es un miembro de función de instancia declarado en un tipo-por-referencia: </list_item><list><list_item> E es evaluado. Si esta evaluación causa una excepción, entonces no se realizan más pasos. </list_item><list_item> La lista de argumentos es evaluado como esta descrito en <hyperlink>14.4.1</hyperlink>. </list_item><list_item> Si el tipo de E es un <non_terminal where="11.1">tipo-por-valor</non_terminal>, una conversión de empacado (<hyperlink>11.3.1</hyperlink>) es realizada para convertir E al tipo object, y E es considerado ser de tupo object en los siguientes pasos.<note>[Nota: EN este caso, M puede únicamente ser un miembro de System.Object, fin nota]</note> </list_item><list_item> El valor de E es quedado para ser valido. Si el valor de E es null, una System.NullReferenceException es lanzada y no se realizan más pasos. </list_item><list_item> La implementación del miembro función para invocar es determinada: </list_item><list><list_item> Si un error en tiempo de compilación de E es una interfaz, el miembro función para invocar es la implementación de M provista por el tipo en tiempo de ejecución de la instancia referenciada por E. Este miembro función es determinado al aplicar reglas de mapeo de la interfaz (<hyperlink>20.4.2</hyperlink>) para determinar la implementación de M provista por el tipo en tiempo de ejecución de la instancia referenciada por E.</list_item><list_item>De otra forma, si M es un miembro función virtual, la función miembro para invocar es la implementación de M es provista por el tipo en tiempo de ejecución de la instancia referenciada por E.</list_item><list_item> De otra forma, M es un miembro de función no virtual, y el miembro función para invocar es en si M. </list_item></list><list_item> La implementación de miembro de función determinada en el paso anterior es invocado. El objeto referenciado por E se convierte en el objeto referenciado por this. </list_item></list></list></paragraph>
</clause>
<!-- Traducido por Mario Carrión, marioc@unixmexico.org -->
