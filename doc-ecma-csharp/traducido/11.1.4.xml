<?xml version="1.0"?>
<clause number="11.1.4" title="Tipos entero">
  <paragraph>C# soporta nueve tipos entero: <keyword>sbyte</keyword>, <keyword>byte</keyword>, <keyword>short</keyword>, <keyword>ushort</keyword>, <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, <keyword>ulong</keyword>, y <keyword>char</keyword>. Los tipos entero tienen los siguientes y rangos de valores: <list><list_item> El tipo <keyword>sbyte</keyword> representa enteros de 8-bits con signo con valores entre -128 y 127. </list_item><list_item>El tipo <keyword>byte</keyword> representa enteros de 8-bits sin signo con valores entre 0 y 255. </list_item><list_item> El tipo <keyword>short</keyword> representa enteros de 16-bits con signo  con valores entre -32768 y 32767. </list_item><list_item>El tipo <keyword>ushort</keyword> representa enteros de 16-bits sin signo con valores entre 0 y 65535. </list_item><list_item>El tipo <keyword>int</keyword> representa enteros de 32-bits con signo con valores entre -2147483648 y 2147483647. </list_item><list_item> El tipo <keyword>uint</keyword> representa enteros de 32-bits sin signo con valores entre 0 y 4294967295. </list_item><list_item>El tipo <keyword>long</keyword> representa enteros de 64-bits con valores entre -9223372036854775808 y 9223372036854775807. </list_item><list_item>El tipo <keyword>ulong</keyword> representa enteros de 64-bits sin signo con valores entre 0 y 18446744073709551615. </list_item><list_item> El tipo <keyword>char</keyword> representa enteros de 16-bits sin signo con valores entre 0 y 65535. El juego de posibles valores para el tipo <keyword>char</keyword> corresponde al juego de caracteres Unicode. <note>[Nota: Aunque <keyword>char</keyword> tiene la misma representación que  <keyword>ushort</keyword>, no todas las operaciones permitidas en un tipo son permitidas en el otro. fin nota]</note> </list_item></list></paragraph>
  <paragraph>El tipo de operadores <non_terminal where="11.1">tipo-entero</non_terminal> unario y binario siempre operan con precisión de 32-bits, precisión de 32-bits sin signo, precisión de 64-bits con signo, o precision de 64-bits sin signo: <list><list_item> Para los operadores unarios + y ~, el operando es convertido al tipo T, donde T es el primero de <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, y <keyword>ulong</keyword> que puede totalmente representar todos los valores posibles del operando. La operación es después realizada usando la precisión de tipo T, y el tipo del resultado es T. </list_item><list_item> Para el operador unario -, el operando es convertido al tipo T, donde T es el primero de <keyword>int</keyword> y <keyword>long</keyword> que puede totalmente representar todos los valores posibles del operando. La operación es después realizada usando el tipo de precisión T, y el tipo del resultado es T. El operador unario T no puede ser aplicado a operandos del tipo <keyword>ulong</keyword>. </list_item><list_item> Para los operadores binarios +, -, *, /, %, &amp;, ^, |, ==, !=, &gt;, &lt;, &gt;=, y &lt;=, los operandos son convertidos al tipo T, donde T es el primero de <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, y <keyword>ulong</keyword> que represente totalmente todos los valores posibles de ambos operandos. La operación es después realizada usando el tipo de precisión T, y el tipo del resultado es T (o <keyword>bool</keyword> para operadores relacionales). No esta permitido para un operando ser del tipo <keyword>long</keyword> y el otro ser del tipo <keyword>ulong</keyword> con operadores binarios. </list_item><list_item> Para los operadores binarios &lt;&lt; y &gt;&gt;, el operando izquierdo es convertido al tipo T, donde T es el primero de <keyword>int</keyword>, <keyword>uint</keyword>, <keyword>long</keyword>, y <keyword>ulong</keyword> que puede totalmente representar todos los valores posibles del operando. La operación es después realizada usando el tipo de precisión T, y el tipo del resultado es T. </list_item></list></paragraph>
  <paragraph>El tipo <keyword>char</keyword> es clasificado como un tipo entero, pero se diferencia de otros tipos enteros en dos formas: <list><list_item> Donde no hay conversiones implícitas de otros tipos hacia el tipo <keyword>char</keyword>. En particular, a pesar que los tipos <keyword>sbyte</keyword>, <keyword>byte</keyword>, y <keyword>ushort</keyword> tienen rangos de valores que son totalmente representables usando el tipo <keyword>char</keyword>, conversiones implícitas desde <keyword>sbyte</keyword>, <keyword>byte</keyword>, o <keyword>ushort</keyword> a <keyword>char</keyword> no existen. </list_item><list_item> Constantes de tipo <keyword>char</keyword> deben ser escritas como <non_terminal where="9.4.4.4">literales-de-caracter</non_terminal> o como <non_terminal where="9.4.4.2">literales-enteras</non_terminal> en combinación  con un molde de tipo <keyword>char</keyword>. <example>[Ejemplo: Por ejemplo, (<keyword>char</keyword>)10 es lo mismo que '\x000A'. fin ejemplo]</example> </list_item></list></paragraph>
  <paragraph>El operador checked y unchecked son sentencias usadas para controlar el checado del sobreflujo de <non_terminal where="11.1">tipo-entero</non_terminal> operaciones aritméticas y conversiones (<hyperlink>14.5.12</hyperlink>). En un contexto de checked, un sobreflujo produce un error en tiempo de compilación o causa que se lance un System.OverflowException. En un contexto unchecked, los sobreflujos son ignorados y cualquier bit de orden alto que no llene en el tipo de destino es descartado. </paragraph>
</clause>
<!-- Traducido por Mario Carrión, marioc@unixmexico.org -->
