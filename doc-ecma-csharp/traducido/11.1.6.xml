<?xml version="1.0"?>
<clause number="11.1.6" title="Tipo decimal">
  <paragraph>El tipo <keyword>decimal</keyword> es un tipo de datos de 128-bits utilizable para cálculos financieros y monetarios. El tipo  <keyword>decimal</keyword> puede representar valores en en el rango 1.0 <unicode>215</unicode> 10<super>-28</super> a aproximadamente 7.9 <unicode>215</unicode> 10<super>28</super> con 28-29 dígitos significantes. </paragraph>
  <paragraph>El juego finito de valores de tipo <keyword>decimal</keyword> son de la forma -1<super>s</super> <unicode>215</unicode> c <unicode>215</unicode> 10<super>-e</super>, donde el signo s es 0 o 1, el coeficiente c es dado por 0 <unicode>8804</unicode> c &lt; 2<super>96</super>, y la escala es la dicha 0 <unicode>8804</unicode> e <unicode>8804</unicode> 28. El tipo <keyword>decimal</keyword> no soporta valores cero con signo, infinitos o NaNs. </paragraph>
  <paragraph>Un <keyword>decimal</keyword> es representado como un entero de 96-bits escalado por 10. Para decimales con un valor absoluto menor que 1.0m, el valor es exacto a 28<super>avo</super> <keyword>decimal</keyword>, pero no mayor. Para decimales con valor absoluto mayor o igual a 1.0m, el valor es exacto a 28 o 29 dìgitos. Contrario a los tipos de datos de números fraccionales <keyword>float</keyword> y <keyword>double</keyword>, <keyword>decimal</keyword> como 0.1 puede ser representado exactamente en la representación <keyword>decimal</keyword>. En las representaciones <keyword>float</keyword> y <keyword>double</keyword>, los números son a menudo fracciones infinitas, haciendo esas representación mas propensas a errores de redondeo. </paragraph>
  <paragraph>Si uno de los operandos de un operador es del tipo
  <keyword>decimal</keyword>, entonces el otro operador debe ser un tipo entero
  o tipo <keyword>decimal</keyword>. Si un operando de tipo entero esta presente, es convertido a <keyword>decimal</keyword> antes que la operación sea realizada. </paragraph>
  <paragraph>El resultado de una operación en valores de tipo <keyword>decimal</keyword> es esa en la cual el resultado de calcular un resultado exacto (preservando la escala, como esta definido por cada operador) y después redondeando para que llene la representación.
  Resultados son redondeados al valor representable mas cercano, y, cuando un resultado es igualmente cercano a los dos valores representables, el valor que tiene el numero en la posición del dígito menos significativo (esta es conocida como &quot;redondeo del banquero&quot;). Esto es, resultados son exactamente de 28 o 29 dígitos, pero no mas de 28 lugares de <keyword>decimal</keyword>. Un resultado cero siempre tiene un signo de 0 y una escala de 0. </paragraph>
  <paragraph>Si una operación aritmética <keyword>decimal</keyword> produce un valor muy pequeño para el formato <keyword>decimal</keyword> después del redondeo, el resultado de la operación se convierte a cero. Si una operación aritmética de <keyword>decimal</keyword> produce un resultado muy largo para el formato <keyword>decimal</keyword>, una excepción System.OverflowException es lanzada. </paragraph>
  <paragraph>El tipo <keyword>decimal</keyword> tiene mayor precisión pero rango menor que los tipos de punto flotante. De esta forma, conversiones de tipo <keyword>decimal</keyword> puede producir excepciones de sobreflujo, y conversiones de tipo <keyword>decimal</keyword> a tipos de punto flotante puede causar perdida de precisión. Por estas razones, no existen conversiones implícitas entre tipos de punto flotante y el tipo <keyword>decimal</keyword>, y sin casts explícitos, no es posible mezclar operandos de punto flotante y  <keyword>decimal</keyword> en la misma expresión. </paragraph>
</clause>
<!-- Traducido por Mario Carrión, marioc@unixmexico.org -->
