<?xml version="1.0"?>
<clause number="14.5.6.2" title="Acceso de indexadores">
  <paragraph>Para un acceso de indexador, la <non_terminal where="14.5">expresión-primaria-de-creación-de-no-arreglo</non_terminal> del acceso a elemento debe ser una variable o un valor de un tipo clase, estructura o interfaz, y este tipo debe implementar uno o más indexadores que son aplicables con respecto a la <non_terminal where="14.5.6">lista-de-expresiones</non_terminal> del <non_terminal where="14.5.6">acceso-de-elemento</non_terminal>. </paragraph>
  <paragraph>El procesamiento de tiempo de compilación de un acceso de indexador de la forma P[A], donde P es una <non_terminal where="14.5">expresión-primaria-de-creación-de-no-arreglo</non_terminal> de tipo clase, estructura, o interfaz T, y A es una <non_terminal where="14.5.6">lista-de-expresiones</non_terminal>, consiste de un los siguientes pasos: <list><list_item> El juego de indexadores provistos por T es construido. El juego consiste de todos los indexadores declarados en T o un tipo base de T que no son declaraciones de reemplazado (override) y son accesibles en el contexto actual (<hyperlink>10.5</hyperlink>). </list_item><list_item> El juego es reducido por esos indexadores que son aplicables y no ocultos por otros indexadores. Las siguientes reglas son aplicadas a cada indexadores S.I en el juego, donde S es del tipo en el cual el indexador I es declarado: </list_item><list><list_item> Si I no es aplicable con respecto a A (<hyperlink>14.4.2.1</hyperlink>), entonces I es removido del juego. </list_item><list_item>Si I es aplicable con respecto a A (<hyperlink>14.4.2.1</hyperlink>), entonces todos los indexadores declarados en un tipo base de S son removidos del juego. </list_item></list><list_item> Si el juego resultante de indexadores candidatos esta vacío, entonces no existen indexadores aplicables, y un error en tiempo de compilación ocurre. Si todos los indexadores candidatos no son declarados del mismo tipo, el acceso a indexador es ambiguo, y un error en tiempo de compilación ocurre (esta última situación puede únicamente ocurrir para un acceso a indexador en una instancia de una interfaz que tiene múltiples interfaces base directas). </list_item><list_item> El mejor indexador del juego de indexadores candidatos es identificado usando las reglas de resolución de sobrecarga de <hyperlink>14.4.2</hyperlink>. Si el mejor indexador sencillo no puede ser identificado, el acceso a indexador es ambiguo, y un error en tiempo de compilación ocurre. </list_item><list_item> La expresión de índice de la <non_terminal where="14.5.6">lista-de-expresiones</non_terminal> son evaluadas en orden, de izquierda a derecha. El resultado de procesar el acceso a indexador es una expresión clasificada en una acceso a indexador. La expresión de acceso a indexador referencia al indexador determinado en el paso anterior, y tiene una expresión de instancia asociada de P y una lista de argumentos asociados de A. </list_item></list></paragraph>
  <paragraph>Dependiendo del contexto en el cual es usado, un acceso a indexador causa ya sea una invocación al accesor-get o al accesor-set. Si el acceso a indexador es el objetivo de la asignación, el acceso-set es invocado para asignar un nuevo valor (<hyperlink>14.13.1</hyperlink>). En todos los otros casos, el accesor-get es invocado para obtener el valor actual (<hyperlink>14.1.1</hyperlink>). </paragraph>
</clause>
<!-- Traducido por Mario Carrión, marioc@unixmexico.org -->
