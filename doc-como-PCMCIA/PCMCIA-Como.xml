<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>

<articleinfo>

<title>Linux PCMCIA COMO </title>

<author>
<firstname>David Hinds, <ulink
url="mailto:dhinds@hyper.stanford.edu"
>dhinds@hyper.stanford.edu</ulink
>
 Traducido por David Limón
Romero, <ulink
url="mailto:dlr@cuates.pue.upaep.mx"
>dlr@cuates.pue.upaep.mx</ulink
></firstname>
</author>

<pubdate>Original: v2.40, 10 Septiembre 1999</pubdate>

<abstract>

<para>
 Este documento describe cómo instalar y usar los servicios de las tarjetas
PCMCIA con Linux. Las últimas versiones de este documento puede
encontrarlas siempre en <literal remap="tt"><ulink
url="ftp://hyper.stanford.edu/pub/pcmcia/doc"
>ftp://hyper.stanford.edu/pub/pcmcia/doc</ulink
></literal>. La versión en HTML
está en <literal remap="tt"><ulink
url="http://hyper.stanford.edu/HyperNews/get/pcmcia/home.html"
>http://hyper.stanford.edu/HyperNews/get/pcmcia/home.html</ulink
></literal>
</para>

</abstract>

</articleinfo>

<sect1 id="general">
<title>Información general y requerimientos de hardware </title>

<sect2 id="introduccion">
<title>Introducción </title>

<para>
Los Servicios de Tarjeta para Linux son un paquete de soporte completo
para PCMCIA o <emphasis remap="it">PC Card</emphasis>. Incluye un conjunto de módulos cargables en el
kernel que implementan una versión de la interface del programa de
aplicación de Servicios de Tarjetas, un conjunto de controladores de
clientes para tarjetas específicas, y un demonio controlador de tarjetas
que responde a los eventos de inserción y extracción de tarjetas, el cual
carga y descarga los controladores según sea necesario. Soporta
«extracción en caliente» de la mayoría de tarjetas, por lo que pueden ser
insertadas y extraídas de forma segura en cualquier momento.
</para>

<para>
Este software está en continuo desarrollo. Probablemente contenga
<emphasis remap="it">bugs</emphasis>, y debe ser usado con precaución. Haré lo que esté en mi mano
para resolver los problemas que me son comunicados, pero si no me los
dice, nunca lo sabré. Si usa este código, espero que me envíe sus
experiencias, ¡buenas o malas!
</para>

<para>
Si tiene sugerencias de cómo puede mejorarse este documento, por favor
hágamelo saber (<literal remap="tt"><ulink
url="mailto:dhinds@hyper.stanford.edu"
>dhinds@hyper.stanford.edu</ulink
></literal>).
</para>

</sect2>

<sect2 id="licencia">
<title>Licencia y renuncia de responsabilidad </title>

<para>
Derechos Reservados &copy; 1998 David A. Hinds 
</para>

<para>
Este documento puede ser reproducido o distribuido en cualquier forma sin
mi permiso previo. Las versiones modificadas de este documento, incluyendo
traducciones a otros idiomas, pueden ser distribuidos libremente, si son
claramente identificados como tales, y siempre que este copyright se
incluya intacto.
</para>

<para>
Este documento puede ser incluído en distribuciones comerciales sin mi
previo consentimiento. Aunque no suponga requisito, me gustaría estar
informado de su uso. Si pretende incorporar este documento en un trabajo
para ser publicado, por favor contacte conmigo para asegurarme que tiene
la última versión disponible. 
</para>

<para>
Este documento se proporciona «TAL CUAL», sin garantías expresas o
implícitas. Utilice la información en este documento bajo su propio
riesgo. 
</para>

</sect2>

<sect2 id="ultima">
<title>¿Cuál es la última versión, y dónde puedo obtenerla? </title>

<para>
La versión actual de los Servicios de Tarjetas es la <literal remap="tt">3.0</literal>, y las
actualizaciones menores o reparaciones de <emphasis remap="it">bugs</emphasis> se numeran <literal remap="tt">3.0.1</literal>,
<literal remap="tt">3.0.2</literal>, y así sucesivamente.
</para>

<para>
El código fuente de la última versión está disponible en <literal remap="tt"><ulink
url="ftp://hyper.stanford.edu"
>ftp://hyper.stanford.edu</ulink
></literal> en
el directorio <literal remap="tt">/pub/pcmcia</literal> como <literal remap="tt">pcmcia-cs-3.0.?.tar.gz.</literal>
Habrá usualmente varias versiones ahí.  Por lo general, solo conservo la
última versión menor para dar origen a una versión mayor. 
</para>

<para>
Las nuevas versiones pueden contener código relativamente sin probar, así
que también conservo la última versión de la última mayor como «colchón»
relativamente estable; el retraso actual es <literal remap="tt">2.9.12</literal>. Vd. decide qué
versión es más apropiada, el archivo <literal remap="tt">CHANGES</literal> mostrará las diferencias
más importantes. 
</para>

<para>
<literal remap="tt"><ulink
url="ftp://hyper.stanford.edu"
>ftp://hyper.stanford.edu</ulink
></literal> es replicado en <literal remap="tt"><ulink
url="ftp://sunsite.unc.edu"
>ftp://sunsite.unc.edu</ulink
></literal> (y todos
los servidores réplica de <emphasis remap="it">Sunsite</emphasis>) en
<literal remap="tt">/pub/Linux/kernel/pcmcia</literal>. 
</para>

<para>
Si no se siente Vd. a gusto compilando controladores, hay controladores
precompilados incluidos con las versiones actuales de la mayoría de las
distribuciones principales de Linux, incluyendo <emphasis remap="it">Slackware</emphasis>,
<emphasis remap="it">Debian</emphasis>, <emphasis remap="it">Red Hat</emphasis>, <emphasis remap="it">Caldera</emphasis>, <emphasis remap="it">SuSE</emphasis>, e <emphasis remap="it">Yggdrasil</emphasis>,
entre otros. 
</para>

</sect2>

<sect2 id="sistemas">
<title>¿Qué sistemas están soportados? </title>

<para>
Este paquete debería correr en la mayoría de portátiles basados en Intel y
que sean «Linuxizables». También corre en plataformas basadas en Alpha
(<emphasis remap="it">DEC Multia</emphasis>, por ejemplo). Se programa para hacer al paquete
completamente <emphasis remap="it">dual-endian</emphasis>, así que también soporta plataformas
basadas en <emphasis remap="it">PowerPC</emphasis> (<emphasis remap="it">Apple Powerbooks</emphasis>, por ejemplo). Los
controladores de <emphasis remap="it">sockets</emphasis> más comunes están soportados. Las bahías de
tarjetas PCMCIA para sistemas de escritorio deben funcionar si usan un
controlador soportado, y se conectan directamente al bus ISA o PCI, lo
opuesto a los adaptadores SCSI-a-PCMCIA o IDE-a-PCMCIA.
</para>

<para>
Están soportados los siguientes controladores:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Cirrus Logic PD6710, PD6720, PD6722, PD6729, PD6730, PD6732, PD6832

</para>
</listitem>
<listitem>

<para>
Intel i82365sl B, C, y secuencias DF, 82092AA

</para>
</listitem>
<listitem>

<para>
O2Micro OZ6729, OZ6730, OZ6832, OZ6833, OZ6836, OZ6860

</para>
</listitem>
<listitem>

<para>
Omega Micro 82C092G

</para>
</listitem>
<listitem>

<para>
Ricoh RF5C296, RF5C396, RL5C465, RL5C466, RL5C475, RL5C476, RL5C478

</para>
</listitem>
<listitem>

<para>
SMC 34C90

</para>
</listitem>
<listitem>

<para>
Texas Instruments PCI1130, PCI1131, PCI1210, PCI1220, PCI1221,
PCI1250A, PCI1251A, PCI1251B, PCI1450

</para>
</listitem>
<listitem>

<para>
Toshiba ToPIC95, ToPIC97 (experimental)

</para>
</listitem>
<listitem>

<para>
Vadem VG465, VG468, VG469

</para>
</listitem>
<listitem>

<para>
VLSI Technologies 82C146, VCF94365

</para>
</listitem>
<listitem>

<para>
VIA VT83C469

</para>
</listitem>
<listitem>

<para>
Databook DB86082, DB86082A, DB86084, DB86084A, DB86072, DB86082B

</para>
</listitem>

</itemizedlist>

</para>

<para>
Otros controladores que están registrados como compatibles con el Intel
<emphasis remap="it">i82365sl</emphasis>, funcionarán también como norma general.
</para>

<para>
El soporte para tarjetas <emphasis remap="it">CardBus</emphasis> de 32 bits es todavía experimental. 
Los manejadores previos a la versión <literal remap="tt">3.0</literal> sólo soportan tarjetas de 16
bits en sockets <emphasis remap="it">CardBus</emphasis>. Debido al paso tan rápido en el cambio de la
tecnología para el hardware de portátiles, aparecen nuevos controladores
frecuentemente, y puede producirse cierto estancamiento entre el momento
en que aparece un nuevo modelo en el mercado, y el que haya soporte para
ese controlador.
</para>

<para>
Toshiba ha dispuesto parcialmente documentación sobre sus chipsets
<emphasis remap="it">ToPIC95</emphasis> y <emphasis remap="it">ToPIC97</emphasis>, sin embargo, la información que han liberado
no ha sido la realmente adecuada. A pesar de los informes de conflictos,
Toshiba no ha hecho algún esfuerzo efectivo para remediar esta situación. 
Hay problemas serios en el soporte de Linux para los chipsets ToPIC, que
no pueden ser resueltos hasta que esté disponible una documentación mejor,
o la ayuda adecuada por parte de Toshiba. No recomiendo el uso de
portátiles Toshiba por el momento. Para el uso de tarjetas de 16 bits,
recomiendo establecer el modo de puente a <emphasis remap="it">PCIC</emphasis> en la configuración de
la BIOS; para tarjetas <emphasis remap="it">CardBus</emphasis>, la decisión es suya. 
</para>

<para>
El controlador Motorola <emphasis remap="it">6AHC05GA</emphasis> usado en portátiles Hyundai, no
está soportado. El controlador en la <emphasis remap="it">HP Omnibook 600</emphasis> tampoco. 
</para>

</sect2>

<sect2 id="tarjetas">
<title>¿Qué tarjetas están soportadas? </title>

<para>
La versión actual incluye controladores para una variedad de tarjetas
ethernet, para tarjetas módem y puertos serie, varios controladores para
adaptadores SCSI, un controlador para tarjetas de unidades ATA/IDE, y
controladores para tarjetas de memoria que sólo soportan la mayoría de
tarjetas SRAM y algunas tarjetas flash. El archivo <literal remap="tt">SUPPORTED.CARDS</literal>
incluído en cada versión de Servicios de Tarjetas lista todas las tarjetas
que se sabe que funcionan al menos en un sistema. 
</para>

<para>
La probabilidad de que funcione una tarjeta que no está en la lista de
soportados depende del tipo. Esencialmente todos los módems deberían
funcionar con el controlador provisto. Algunas tarjetas de red pueden
funcionar si hay versiones OEM de las tarjetas soportadas. Otro tipo de
tarjetas de E/S (<emphasis remap="it">frame buffers</emphasis>, tarjetas de sonido, etc) no
funcionarán hasta que alguien escriba los controladores apropiados. 
</para>

</sect2>

<sect2 id="cuando">
<title>¿Cuándo estará soportada mi tarjeta favorita (no soportada)? </title>

<para>
Desafortunadamente, no me pagan por escribir controladores para
dispositivos, así que si quiere tener un controlador para su tarjeta
favorita, probablemente tendrá trabajar un poco.  Idealmente, me gustaría
trabajar hacia un modelo como el del kernel de Linux, donde yo sea el
responsable principalmente del código del núcleo y otros autores puedan
contribuir y mantener los controladores para tarjetas específicas. El
archivo <literal remap="tt">SUPPORTED.CARDS</literal> menciona algunas tarjetas para las cuales
los controladores están actualmente en progreso. Trataré de ayudar donde
pueda, pero tenga en cuenta que depurar controladores de dispositivo del
kernel por email no es particularmente efectivo.
</para>

<para>
Los fabricantes interesados en ayudar a proveer soporte Linux para sus
productos pueden contactar conmigo a fin de acordar consultorías.
</para>

</sect2>

<sect2 id="listas">
<title>Listas de correo y otras fuentes de información </title>

<para>
Solía mantener una base de datos y una lista de correo de usuarios de
Linux PCMCIA. Recientemente he convertido mi página web para información
de Linux PCMCIA en un sitio <emphasis remap="it">HyperNews</emphasis>, con un conjunto de listas de
mensajes de temas de Linux PCMCIA. Hay listas para instalación y
configuración, para diferentes tipos de tarjetas, para programar y
depurar. La página de información de Linux PCMCIA está en <literal remap="tt"><ulink
url="http://hyper.stanford.edu/HyperNews/get/pcmcia/home.html"
>http://hyper.stanford.edu/HyperNews/get/pcmcia/home.html</ulink
></literal>. Los
usuarios pueden solicitar otificación por email de nuevas respuestas a
preguntas particulares, o notificación para todos los mensajes nuevos en
una categoría dada. Espero que esto sea un repositorio útil de
información, para cuestiones que van más allá del enfoque del COMO.
</para>

<para>
Hay una lista de Linux dedicada a asuntos de portátiles, la lista
<literal remap="tt">linux-laptop</literal>. Para más información, envíe un mensaje con la palabra
<literal remap="tt">help</literal> a <literal remap="tt"><ulink
url="mailto:majordomo@vger.rutgers.edu?subject=help"
>majordomo@vger.rutgers.edu</ulink
></literal>. Para suscribirse, envíe un email
que contenga el mensaje <literal remap="tt">subscribe linux-laptop</literal> a la misma dirección.
Esta lista de correo puede ser un buen foro de discusión de asuntos de
Linux PCMCIA. 
</para>

<para>
La página de Linux Laptop está en <literal remap="tt"><ulink
url="http://www.cs.utexas.edu/users/kharker/linux-laptop"
>http://www.cs.utexas.edu/users/kharker/linux-laptop</ulink
></literal> tiene
enlaces a muchos sitios que tienen información acerca de la configuración
de tipos específicos de portátiles para Linux. Hay también una base de
datos para buscar información acerca de configuración de sistemas. 
</para>

</sect2>

<sect2 id="porqueno">
<title>¿Por qué no distribuyen binarios? </title>

<para>
Para mi, distribuir los binarios puede suponer una molestia importante.
Esto es complicado porque algunas características solo pueden ser
seleccionadas al momento de compilar, y porque los módulos dependen mucho
de contar con una configuración «correcta» del kernel. Así, probablemente
necesite distribuir módulos precompilados junto con los kernels
correspondientes.  Más que esto, la necesidad más grande de los módulos
precompilados es cuando se instala Linux en un sistema limpio. Esto
típicamente requiere configurar los controladores para que puedan ser
utilizados en el proceso de instalación, para una distribución de Linux en
particular. Cada distribución de Linux tiene su propia idiosincrasia, y no
me resulta factible el proveer discos <literal remap="tt">boot</literal> y <literal remap="tt">root</literal> para cada una
de las combinaciones de controladores y distribuciones. 
</para>

<para>
PCMCIA forma parte ahora de las principales distribuciones de Linux,
incluyendo <emphasis remap="it">RedHat</emphasis>, <emphasis remap="it">Caldera</emphasis>, <emphasis remap="it">Slackware</emphasis>, <emphasis remap="it">Yggdrasil</emphasis>,
<emphasis remap="it">Craftworks</emphasis> y <emphasis remap="it">Nascent Technology</emphasis>. 
</para>

</sect2>

<sect2 id="tangrande">
<title>¿Por qué el paquete es tan grande? </title>

<para>
Bueno, no es realmente tan grande al fin y al cabo. Todos los módulos
controladores ocupan alrededor de 500K de espacio en disco. Los programas
de utilidades añaden unos 70K, y los scripts en <literal remap="tt">/etc/pcmcia</literal> son
de 50K. Los controladores principales ocupan unos 55K de la memoria del
sistema. El demonio <literal remap="tt">cardmgr</literal> será generalmente intercambiado excepto
cuando cuando las tarjetas sean insertadas o extraídas. El tamaño total
del paquete es comparable a las implementaciones de servicios de tarjetas
de DOS/Windows.
</para>

</sect2>

</sect1>

<sect1 id="compilacion">
<title>Compilación e instalación
</title>

<para>
 
</para>

<sect2 id="requisitos">
<title>Prerequisitos y configuración del kernel </title>

<para>
Antes de empezar, debería pensar si realmente necesita compilar el paquete
por sí mismo. Todas las distribuciones comunes de Linux vienen con
paquetes de controladores precompilados. Generalmente, sólo necesita
instalar los controladores si necesita una característica nueva de los más
actuales, o si ha actualizado y/o reconfigurado su kernel de forma que es
incompatible con los incluidos en su distribución de Linux. A pesar de que
compilar el paquete no es técnicamente difícil, requiere algo de
familiaridad general con Linux. 
</para>

<para>
Las siguientes cosas deben estar instaladas en su sistema antes de
comenzar: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
El árbol de fuentes del kernel, serie <literal remap="tt">2.0.*</literal>,
<literal remap="tt">2.1.*</literal>, o <literal remap="tt">2.2.*</literal>

</para>
</listitem>
<listitem>

<para>
Un conjunto apropiado de utilidades de módulos.

</para>
</listitem>
<listitem>

<para>
La interface de utilidades <literal remap="tt">XForms</literal> para X11 (Opcional).

</para>
</listitem>

</itemizedlist>

</para>

<para>
Necesita tener la estructura completa del código fuente del kernel, no
sólo una imagen actualizada del kernel. Los módulos de los controladores
contienen algunas referencias a los archivos fuentes del kernel. Mientras
que Vd. busca compilar un kernel nuevo para eliminar manejadores
innecesarios, instalar PCMCIA no requiere que lo haga así. 
</para>

<para>
Los fuentes y parches «estables» actuales del kernel están disponibles en

<literal remap="tt"><ulink
url="ftp://sunsite.unc.edu/pub/Linux/kernel/v2.0"
>ftp://sunsite.unc.edu/pub/Linux/kernel/v2.0</ulink
></literal>, o en 

<literal remap="tt"><ulink
url=" ftp://tsx-11.mit.edu/pub/linux/sources/system/v2.0"
>ftp://tsx-11.mit.edu/pub/linux/sources/system/v2.0</ulink
></literal> Los
kernels en desarrollo los puede encontrar en los subdirectorios <literal remap="tt">v2.1</literal>. 
las utilidades de módulos actuales puede encontrarlas en la misma
ubicación.
</para>

<para>
En los fuentes del kernel de Linux, el archivo
<literal remap="tt">Documentation/Changes</literal> describe las versiones de todas las clases
de otros componentes del sistema que son requeridas por esa versión del
kernel. Probablemente quiera revisarlo y verificar que su sistema está
actualizado, especialmente si tiene actualizado el kernel. Si está usando
un kernel en desarrollo, asegúrese de estar usando la combinación correcta
de bibliotecas compartidas y herramientas de módulos. 
</para>

<para>
Cuando configure su kernel, si planea usar una tarjeta ethernet PCMCIA,
debe activar el soporte para red, y desactivar los controladores normales
de tarjetas de red de Linux, incluyendo <literal remap="tt">pocket and portable adapters</literal>. 
Todos los controladores para tarjetas de red PCMCIA están compilados como
módulos cargables. Cualquiera de los controladores compilados dentro de su
kernel sólo desperdiciará espacio. 
</para>

<para>
Si quiere usar SLIP, PPP o PLIP, necesitará ya sea configurar el kernel
con ese soporte activado, o usar la versión de los módulos cargables de
esos controladores. Hay una desafortunada deficiencia en el proceso de
configuración de los kernels <literal remap="tt">1.2.X</literal>, en el que no es posible
establecer opciones de configuración (como compresión SLIP) para un módulo
cargable, así que es probablemente mejor enlazar SLIP dentro del kernel si
es que lo necesita. 
</para>

<para>
Para usar un adaptador token ring PCMCIA, el kernel debe estar configurado
con la opción <literal remap="tt">Token Ring driver support</literal> (<literal remap="tt">CONFIG_TR</literal>) activada,
aunque debe dejar <literal remap="tt">CONFIG_IBMTR</literal> desactivado.
</para>

<para>
Si requiere usar un adaptador IDE PCMCIA, su kernel debe estar configurado
con la opción <literal remap="tt">CONFIG_BLK_DEV_IDE_PCMCIA</literal> activada, para los kernels
desde <literal remap="tt">2.0.*</literal> hasta <literal remap="tt">2.1.*</literal>. Los kernels antiguos no soportan
dispositivos IDE extraíbles; los nuevos no requieren una configuración
especial.
</para>

<para>
Si va a usar un adaptador SCSI PCMCIA, debe habilitar <literal remap="tt">CONFIG_SCSI</literal>
cuando configure el kernel. Debe activar también cualquier controlador de
alto nivel (disco SCSI, cinta, cdrom, genérico) que espere usar. Debe
desactivar todos los controladores de bajo nivel para adaptadores en
particular, porque sólo le quitarán espacio. 
</para>

<para>
Si busca modularizar un controlador que se necesita para un dispositivo
PCMCIA, debe modificar <literal remap="tt">/etc/pcmcia/config</literal> para especificar qué
módulos necesitan ser cargados para qué tipos de tarjetas. Por ejemplo, si
el controlador serie está modularizado, entonces la definición del
dispositivo serie debería ser: 
</para>

<para>

<screen>
       device "serial_cs"
         class "serial" module "misc/serial", "serial_cs"  
</screen>

</para>

<para>
Este paquete incluye una utilidad llamada <literal remap="tt">cardinfo</literal> que está basada en
X para monitorizar el estado de la tarjeta. Está basada en un <emphasis remap="it">toolkit</emphasis>
de libre distribución, la biblioteca <emphasis remap="it">XForms</emphasis>. Esta librería está
disponible como un paquete separado de la mayoría de distribuciones de
Linux. Si desea compilar <literal remap="tt">cardinfo</literal>, deberá instalar <literal remap="tt">XForms</literal> y
todas las cabeceras y bibliotecas de desarrollo habituales para X antes de
configurar el paquete PCMCIA. 
</para>

</sect2>

<sect2 id="instalacion">
<title>Instalación </title>

<para>
He aquí una sinopsis del proceso de instalación: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
Descomprima <literal remap="tt">pcmcia-cs-3.0.?.tar.gz</literal> en <literal remap="tt">/usr/src</literal>

</para>
</listitem>
<listitem>

<para>
Ejecute <literal remap="tt">make config</literal> en el nuevo directorio 
<literal remap="tt">pcmcia-cs-3.0.?</literal>

</para>
</listitem>
<listitem>

<para>
Ejecute <literal remap="tt">make all</literal>, y luego <literal remap="tt">make install</literal>.

</para>
</listitem>
<listitem>

<para>
Configure el script de inicio y los archivos de opciones en <literal remap="tt">/etc/pcmcia</literal> para su sistema.

</para>
</listitem>

</itemizedlist>

</para>

<para>
Si planea instalar cualquier controlador que sea una contribución y que no
esté incluído en la distribución principal de PCMCIA, descomprima cada uno
de ellos en el directorio raíz del árbol PCMCIA. Luego siga las
instrucciones normales de compilación. Los controladores extras se
compilarán e instalarán automáticamente.
</para>

<para>
Cuando ejecute <literal remap="tt">make config</literal>, se le preguntarán algunas opciones de
configuración y se comprobará su sistema para verificar que se satisfagan
todos los prerequisitos para instalar soporte PCMCIA. En la mayoría de los
casos, sólo tendrá que aceptar todas las opciones de configuración que
vienen por omisión. Asegúrese de comprobar cuidadosamente la salida de
éste comando en caso de que hubiera problemas. Están disponibles las
siguientes opciones: 
</para>

<para>
<variablelist>

<varlistentry>
<term>¿Hay un directorio de instalación alternativo?</term>
<listitem>
<para>
Si está compilando el
paquete para instalarlo en otro equipo, especifique un directorio destino
alternativo cuando se le pregunte. Debe ser una ruta absoluta. Todos los
archivos serán instalados relativos a este directorio. Entonces estará
listo para aplicar <literal remap="tt">tar</literal> a este directorio y copiarlo a su equipo
destino, y desempaquetarlo relativo a su directorio raíz para instalar
todo en los lugares apropiados.
</para>
</listitem></varlistentry>
<varlistentry>
<term>¿Necesita indicadores de compilación para depurar?</term>
<listitem>
<para>
Vea la sección
<xref linkend="aux"/> para mayor
información acerca de esta opción. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>¿Necesita compilar versiones «trusting» de las utilidades de
tarjetas?</term>
<listitem>
<para>
Algunas de las utilidades de soporte (<literal remap="tt">cardctl</literal> y
<literal remap="tt">cardinfo</literal>) pueden ser compiladas ya sea de forma <literal remap="tt">safe</literal> o
<literal remap="tt">trusting</literal>. La forma <literal remap="tt">safe</literal> previene a los usuarios no-root de
modificar configuraciones de tarjetas. La forma <literal remap="tt">trusting</literal> permite a
los usuarios ordinarios ejecutar comandos para suspender y reactivar
tarjetas, resetear tarjetas, y cambiar el esquema de configuración actual. 
La forma configurada por omisión es <literal remap="tt">safe</literal>. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>¿Necesita incluir soporte para tarjetas de 32-bits (<emphasis remap="it">CardBus</emphasis>)?</term>
<listitem>
<para>
Deberá seleccionar esta opción si desea usar tarjetas <emphasis remap="it">CardBus</emphasis> de
32-bits.  No se requiere para tener soporte con puentes <emphasis remap="it">CardBus</emphasis> si
sólo planea usar tarjetas PC de 16-bits.
</para>
</listitem></varlistentry>
<varlistentry>
<term>¿Necesita incluir chequeo de recursos para BIOS PnP?</term>
<listitem>
<para>
Esto compila
código adicional en el módulo principal PCMCIA para comunicarse con el
BIOS PnP de un sistema para obtener información de los recursos que están
incluidos en la «placa madre» (puertos serie y paralelos, sonido, etc),
para ayudar a prevenir conflictos de recursos. Si se habilita, se crearán
algunos archivos extra de recursos bajo <literal remap="tt">/proc/bus/pccard</literal>, y las
herramientas <literal remap="tt">lspnp</literal> y <literal remap="tt">setpnp</literal> se pueden usar para visualizar y
manipular los dispositivos PnP del BIOS. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>¿Cómo configurar opciones específicas del kernel?</term>
<listitem>
<para>
Hay algunas
opciones de configuración del kernel que afectan a las herramientas
PCMCIA. El script de configuración puede deducirlo desde el kernel actual
(el caso por omisión y más común).  Alternativamente, si está compilando
para instalar en otro equipo, puede leer la configuración del árbol de los
fuentes del kernel, o cada opción se puede establecer interactivamente.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
El script de configuración se puede ejecutar de forma no-interactiva, para
compilar automáticamente o para reconfigurar rápidamente después de una
actualización del kernel. Algunas opciones adicionales no utilizadas con
frecuencia sólo pueden ser establecidas desde la línea de comandos.
Ejecutando: <literal remap="tt">Configure --help</literal> se listarán todas las opciones
disponibles. 
</para>

<para>
Al ejecutar <literal remap="tt">make all</literal> seguido de <literal remap="tt">make install</literal> compilará y luego
instalará los módulos del kernel y los programas de utilidades.  Los
módulos del kernel serán instalados en
<literal remap="tt">/lib/modules/&lt;version&gt;/pcmcia</literal>. Los programas <literal remap="tt">cardctl</literal> y
<literal remap="tt">cardmgr</literal> serán instalados en <literal remap="tt">/sbin</literal>. Si <literal remap="tt">cardinfo</literal> se
compila, será instalado en <literal remap="tt">/usr/bin/X11</literal>.
</para>

<para>
Los archivos de configuración serán instalados en el directorio
<literal remap="tt">/etc/pcmcia</literal>. Si está instalando sobre una versión antigua, sus
scripts de configuración anteriores se respaldarán antes de ser
reemplazados. Los scripts guardados tendrán la extensión de tipo <literal remap="tt">*.O</literal>. 
</para>

<para>
Si no sabe qué tipo de controlador usa su sistema, puede utilizar la
utilidad <literal remap="tt">probe</literal> en el subdirectorio <literal remap="tt">cardmgr/</literal> para
determinarlo.  Hay dos tipos principales: el tipo <emphasis remap="it">Databook TCIC-2</emphasis> y
el tipo compatible con Intel <emphasis remap="it">i82365SL</emphasis>.
</para>

<para>
En raras ocasiones, el comando <literal remap="tt">probe</literal> será incapaz de determinar su
tipo de controlador automáticamente. Si tiene un sistema <emphasis remap="it">Halikan NBD
486</emphasis>, tiene un controlador <emphasis remap="it">TCIC-2</emphasis> en una localización inusual:
necesitará editar <literal remap="tt">rc.pcmcia</literal> para cargar el módulo <literal remap="tt">tcic</literal>, y
también especificar el parámetro <literal remap="tt">PCIC_OPTS</literal> a <literal remap="tt">tcic_base=0x02c0</literal>. 
</para>

<para>
En algunos sistemas que usan controladores Cirrus, incluyendo el <emphasis remap="it">Nec
Versa M</emphasis>, la bios pone el controlador en un estado especial de suspensión
al iniciar el sistema. En esos sistemas, el comando <literal remap="tt">probe</literal> fallará al
encontrar cualquier controlador conocido. Si esto pasa, edite <literal remap="tt">rc.pcmcia</literal> y especifica <literal remap="tt">PCIC</literal> a <literal remap="tt">i82365</literal>, y <literal remap="tt">PCIC_OPTS</literal> a
<literal remap="tt">wakeup=1</literal>. 
</para>

</sect2>

<sect2 id="inicio">
<title>Opciones de inicio
</title>

<para>
El script de inicio de PCMCIA reconoce varios grupos de opciones de
inicio, establecidas por medio de variables de entorno. Se pueden separar
múltiples opciones por medio de espacios y encerradas en comillas. La
colocación de las opciones de inicio depende de la distribución de Linux
que se esté usando. Pueden ser colocados directamente en el script de
inicio, o pueden mantenerse en un archivo de opciones separado. Revise la
sección <xref linkend="distribuciones"/> para más detalles. Se pueden establecer las siguientes
variables: 
</para>

<para>
<variablelist>

<varlistentry>
<term>PCMCIA</term>
<listitem>
<para>
Esta variable especifica si el soporte PCMCIA debe ser
iniciado o no. Si está especificado de forma diferente a <literal remap="tt">yes</literal>, el
script de inicio será desactivado. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>PCIC</term>
<listitem>
<para>
Esto identifica el módulo controlador de <emphasis remap="it">PC Card Interface
Controller</emphasis>. Hay dos opciones: <literal remap="tt">tcic</literal> o <literal remap="tt">i82365</literal>. Virtualmente todos
los controladores actuales están en el grupo <emphasis remap="it">i82365</emphasis>. Esta es la única
opción obligatoria a establecer. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>PCIC_OPTS</term>
<listitem>
<para>
Esto especifica las opciones para el módulo PCIC. Algunos
controladores tienen características opcionales que pueden o no ser
implementadas en un sistema en particular. En algunos casos, es imposible
para el socket controlador detectar si esas características están
implementadas. Revise la página del manual correspondiente para una
descripción completa de las opciones disponibles. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>CORE_OPTS</term>
<listitem>
<para>
Esto especifica las opciones para el módulo
<literal remap="tt">pcmcia_core</literal>, el cual implementa los servicios principales del
controlador PC Card. Es conveniente echar un vistazo a <literal remap="tt">man
pcmcia_core</literal> para más información.
</para>
</listitem></varlistentry>
<varlistentry>
<term>CARDMGR_OPTS</term>
<listitem>
<para>
Esto especifica las opciones que se pasarán al demonio
<literal remap="tt">cardmgr</literal>. Revise <literal remap="tt">man cardmgr</literal> para más información. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>SCHEME</term>
<listitem>
<para>
Si está activado, el esquema de configuración de PC Card será
inicializado a este modo en el momento de arrancar. Revise la sección <xref linkend="configuracion"/> para ver la discusión de esquemas. 
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Los controladores de sockets de bajo nivel, <literal remap="tt">tcic</literal> e <literal remap="tt">i82365</literal>,
tienen varios parámetros de sincronización de bus que pueden necesitar ser
ajustados para sistemas con velocidades de bus no muy usuales. Los
síntomas de los problemas de sincronización incluyen problemas al
reconocer las tarjetas, congelamiento bajo carga pesada, tasas de error
altas, o rendimiento pobre de dispositivos. Sólo ciertos puentes tienen
parámetros de sincronización ajustables, revise la página correspondiente
del manual para ver qué opciones existen para su controlador. He aquí un
pequeño resumen:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Los controladores Cirrus tienen muchos parámetros de sincronización. 
Lo más importante parece ser el indicador <literal remap="tt">cmd_time</literal>, la cual determina
la longitud de los ciclos de bus PCMCIA. En los sistemas rápidos 486
(DX4-100, por ejemplo) parece ser beneficioso el incrementar esto de
<literal remap="tt">6</literal> (por omisión) a <literal remap="tt">12</literal> o <literal remap="tt">16</literal>. 

</para>
</listitem>
<listitem>

<para>
El controlador Cirrus <emphasis remap="it">PD6729 PCI</emphasis> tiene el indicador
<literal remap="tt">fast_pci</literal>, la cual debe establecerse si la velocidad del bus PCI es
mayor a 25 Mhz.

</para>
</listitem>
<listitem>

<para>
Para controladores <emphasis remap="it">Vadem VG-468</emphasis> y <emphasis remap="it">Databook TCIC-2</emphasis>, el
indicador <literal remap="tt">async_clock</literal> cambia la velocidad relativa del bus PCMCIA y
los ciclos de bus del equipo. Activar este indicador añade estados de
espera extra a algunas operaciones. Sin embargo, todavía no he sabido de
ningún portátil que necesite esto.
</para>
</listitem>
<listitem>

<para>
El módulo <literal remap="tt">pcmcia_core</literal> tiene el parámetro <literal remap="tt">cis_speed</literal> para
cambiar la velocidad de la memoria, la cual se usa para acceder a la
<emphasis remap="it">Estructura de Información de Tarjeta</emphasis> (<emphasis remap="it">Card Information
Structure</emphasis>) (<emphasis remap="it">CIS</emphasis>) de una tarjeta. En algunos sistemas con pulsos de
bus rápidos, incrementar este parámetro (por ejemplo, reducir la velocidad
de los accesos a tarjeta) puede resultar beneficioso para quien tenga
problemas al reconocerlas.

</para>
</listitem>
<listitem>

<para>
Esto no es cuestión de sincronización, pero si Vd. tiene más de un
controlador ISA-a-PCMCIA en su sistema o tiene bahías extra en una
estación, el módulo <literal remap="tt">i82365</literal> debe ser cargado con el parámetro
<literal remap="tt">extra_sockets</literal> establecido a <literal remap="tt">1</literal>. Esto no deberá ser necesario para
detección de puentes PCI-a-PCMCIA y PCI-a-CardBus.

</para>
</listitem>

</itemizedlist>

</para>

<para>
He aquí algunas configuraciones de sincronización para algunos sistemas
específicos:
</para>

<para>

<itemizedlist>
<listitem>

<para>
En un <emphasis remap="it">ARM Pentium-90</emphasis> o en un <emphasis remap="it">Midwest Micro Soundbook Plus</emphasis>,
use <literal remap="tt">freq_bypass=1 cmd_time=8</literal>. 

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">Midwest Micro Soundbook Elite</emphasis>, use <literal remap="tt">cmd_time=12</literal>.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">Gateway Liberty</emphasis>, pruebe con <literal remap="tt">cmd_time=16</literal>.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">Samsung SENS 810</emphasis>, use <literal remap="tt">fast_pci=1</literal>.

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="confrec">
<title>Configuración de recursos del sistema </title>

<para>
Los servicios de tarjetas deben evitar automáticamente el ocupar puertos e
interrupciones que ya estén en uso por otros dispositivos estándar. 
Intentará así mismo detectar conflictos con dispositivos desconocidos,
pero esto no es del todo fiable, y en algunos casos puede que necesite
excluir explícitamente recursos para un dispositivo en
<literal remap="tt">/etc/pcmcia/config.opts.</literal>
</para>

<para>
He aquí algunas configuraciones de recursos para tipos específicos de
portátiles. Revíselas con cuidado: pueden darle información necesaria para
resolver problemas, pero algunas están (inevitablemente) obsoletas y
ciertamente contienen errores. Las correcciones y adiciones serán
bienvenidas.
</para>

<para>

<itemizedlist>
<listitem>

<para>
En un <emphasis remap="it">AMS SoundPro</emphasis>, excluya la irq 10.

</para>
</listitem>
<listitem>

<para>
En algunos modelos <emphasis remap="it">AMS TravelPro 5300</emphasis>, use el rango de memoria
<literal remap="tt">0xc8000-0xcffff</literal>. 

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">BMX 486DX2-66</emphasis>, excluya irq 5, irq 9.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">Chicony NB5</emphasis>, use el rango de memoria <literal remap="tt">0xda000-0xdffff</literal>.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">Compaq Presario 1020</emphasis>, excluya el puerto <literal remap="tt">0x2f8-0x2ff</literal>,
irq 3, irq 5. 

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">HP Omnibook 4000C</emphasis>, excluya el puerto <literal remap="tt">0x300-0x30f</literal>.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">IBM ThinkPad 380</emphasis>, y posiblemente en las series 385 y 600,
excluya el puerto <literal remap="tt">0x230-0x233</literal>, e irq 5. 

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">IBM ThinkPad 600</emphasis>, excluya el puerto <literal remap="tt">0x2f8-0x2ff</literal>.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">Micron Millenia Transport</emphasis>, excluya irq 5, irq 9.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">NEC Versa M</emphasis>, excluya irq 9, y el puerto <literal remap="tt">0x2e0-2ff</literal>.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">NEC Versa P/75</emphasis>, excluya irq 5, irq 9.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">NEC Versa S</emphasis>, excluya irq 9, irq 12.

</para>
</listitem>
<listitem>

<para>
En las series <emphasis remap="it">NEC Versa 6000</emphasis>, excluya el puerto
<literal remap="tt">0x2f8-0x33f</literal>, irq 9, irq 10

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">ProStar 9200</emphasis>, <emphasis remap="it">Altima Virage</emphasis>, y <emphasis remap="it">Acquiline
Hurricane DX4-100</emphasis>, excluya irq 5, y el puerto <literal remap="tt">0x330-0x35f</literal>.  Puede
usar el rango de memoria <literal remap="tt">0xd8000-0xdffff</literal>. 

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">Siemens Nixdorf SIMATIC PG 720C</emphasis>, use el rango de memoria
<literal remap="tt">0xc0000-0xcffff</literal>, y el puerto <literal remap="tt">0x300-0x3bf</literal>. 

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">TI TravelMate 5000</emphasis>, use el rango de memoria
<literal remap="tt">0xd4000-0xdffff</literal>. 

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">Toshiba T4900 CT</emphasis>, excluya irq 5, y los puertos
<literal remap="tt">0x2e0-0x2e8</literal>, <literal remap="tt">0x330-0x338</literal>.

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">Twinhead 5100</emphasis>, HP 4000, <emphasis remap="it">Sharp PC-8700</emphasis> and PC-8900,
excluya irq 9 (sonido), irq 12. 

</para>
</listitem>
<listitem>

<para>
En un <emphasis remap="it">MPC 800 Series</emphasis>, excluya irq 5, y el puerto
<literal remap="tt">0x300-0x30f</literal> para el CD-ROM. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="distribuciones">
<title>Notas acerca de distribuciones de Linux específicas
</title>

<para>
Esta sección está incompleta. Todas las correcciones y adiciones serán
bienvenidas. 
</para>

<sect3 id="debian">
<title>Debian </title>

<para>
Debian usa el conjunto de scripts de arranque de tipo System V. El script
de inicio PCMCIA está instalado en <literal remap="tt">/etc/init.d/pcmcia</literal>, y las
opciones de inicio se especifican en <literal remap="tt">/etc/pcmcia.conf</literal>. La
configuración de <literal remap="tt">syslog</literal> de Debian colocará los mensajes del kernel en
<literal remap="tt">/var/log/messages</literal> y los mensajes del demonio <literal remap="tt">cardmgr</literal> en
<literal remap="tt">/var/log/daemon.log</literal>. 
</para>

<para>
Debian distribuye el sistema PCMCIA en dos paquetes: el paquete
<literal remap="tt">pcmcia-cs</literal> que contiene <literal remap="tt">cardmgr</literal> y otras herramientas, páginas del
manual, y los scripts de configuración; y el paquete <literal remap="tt">pcmcia-modules</literal>
que contiene los módulos controladores del kernel. 
</para>

</sect3>

<sect3 id="rh">
<title>Red Hat, Caldera, Mandrake </title>

<para>
Estas distribuciones usan la organización de scripts System V. El script
de inicio de PCMCIA está instalado en <literal remap="tt">/etc/rc.d/init.d/pcmcia</literal>, y
las opciones de arranque se guardan en <literal remap="tt">/etc/sysconfig/pcmcia</literal>. 
Observe que al instalar el paquete de Red Hat puede instalar un archivo de
opciones de inicio por omisión que tiene PCMCIA desactivado.  Para
habilitar PCMCIA, la variable <literal remap="tt">PCMCIA</literal> debe establecerse en <literal remap="tt">yes</literal>.
La configuración por omisión del <literal remap="tt">syslogd</literal> de Red Hat grabará todos los
mensajes interesantes en <literal remap="tt">/var/log/messages</literal>. 
</para>

<para>
El paquete PCMCIA de Red Hat contiene un reemplazo para el script de
inicio de red, <literal remap="tt">/etc/pcmcia/network</literal>, el cual se acopla al panel de
control de red de Red Hat. Esto es conveniente para el caso donde sólo se
usa un adaptador de red, con un conjunto de parámetros de red, pero no
tiene la flexibilidad completa del script regular de red PCMCIA. Compilar
e instalar una distribución fuente de PCMCIA nueva, sobreescribirá el
script de red, rompiendo el enlace con el panel de control. Si prefiere el
script de Red Hat, puede evitarlo bien usando únicamente RPMS de Red Hat,
o creando <literal remap="tt">/etc/pcmcia/network.opts</literal> que contenga lo siguiente: 
</para>

<para>

<screen>
       if [ -f /etc/sysconfig/network-scripts/ifcfg-eth0 ] ; then
           start_fn () {
               /sbin/ifup $1
           }
           stop_fn () {
               /sbin/ifdown $1
           }
       fi
</screen>

</para>

<para>
Red Hat maneja su distribución de los fuentes de PCMCIA con pocas
modificaciones dentro de su SRPM del kernel, en lugar de gestionarlo como
un paquete separado. 
</para>

</sect3>

<sect3 id="slack">
<title>Slackware </title>

<para>
Slackware usa el conjunto de scripts de inicio de BSD. El script de inicio
de PCMCIA está instalado en <literal remap="tt">/etc/rc.d/rc.pcmcia</literal>, y las opciones
de inicio se especifican en el mismo <literal remap="tt">rc.pcmcia</literal>. El script de inicio
de PCMCIA se invoca desde <literal remap="tt">/etc/rc.d/rc.S.</literal>
</para>

</sect3>

<sect3 id="suse">
<title>SuSE </title>

<para>
SuSE usa el conjunto de scripts System V, con los scripts de inicio
almacenados en <literal remap="tt">/sbin/init.d</literal>. El script de inicio de PCMCIA está
instalado en <literal remap="tt">/sbin/init.d/pcmcia</literal>, y las opciones de arranque se
guardan en <literal remap="tt">/etc/rc.config</literal>. El script de inicio de SuSE está algo
limitado y no permite que las variables de inicio de PCMCIA sean
invalidados desde el prompt de inicio de <literal remap="tt">lilo</literal>.
</para>

</sect3>

</sect2>

</sect1>

<sect1 id="problemas">
<title>Resolución de problemas de instalación y configuración </title>

<para>
Esta sección describe algunos de los errores más comunes del subsistema
PCMCIA. Compare sus síntomas con los ejemplos. Esta sección sólo describe
fallos generales que no son específicas de un controlador o tipo de
tarjeta en particular.
</para>

<para>
Antes de diagnosticar un problema, debe saber dónde se almacena el
registro del sistema (revise la sección <xref linkend="distribuciones"/>). Debe estar
familiarizado con las herramientas básicas de diagnóstico como <literal remap="tt">dmesg</literal>
y <literal remap="tt">lsmod</literal>.  Preste especial atención al hecho de que muchos componentes
de los controladores (incluyendo todos los módulos del kernel) tienen sus
propias páginas individuales en el manual. 
</para>

<para>
Intente definir su problema lo más ampliamente posible. Si tiene varias
tarjetas, pruebe cada tarjeta de forma aislada, y en diferentes
combinaciones. Intente arranques de Linux en frío y arranques en caliente
de Windows. Compare el arrancar con tarjetas insertadas, o insertar las
tarjetas después de iniciar. Si normalmente usa su portátil ensamblado con
una <emphasis remap="it">dockstation</emphasis>, prúebelo aparte. Algunas veces, dos bahías se
comportarán de forma diferente.
</para>

<para>
Es casi imposible depurar problemas de un controlador cuando se intenta
instalar Linux por medio de un dispositivo PCMCIA. En lugar de eso, si
puede identificar el problema basándose en los síntomas, los discos de
instalación son difíciles de modificar, especialmente sin tener acceso a
un sistema Linux ya funcionando. La personalización e instalación de los
discos de instalación es completamente dependiente de la distribución de
Linux que elija, y más allá del enfoque de este documento. En general, el
mejor curso de acción es instalar Linux usando otros medios, obteniendo
los controladores más recientes, y depurando el problema entonces, si es
que persiste.
</para>

<sect2 id="modbase">
<title>No se cargan los módulos básicos de PCMCIA.
</title>

<para>
Síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Aparecen errores acerca de que la versión del kernel difiere cuando
se ejecuta el script de inicio de PCMCIA.

</para>
</listitem>
<listitem>

<para>
Después de iniciar, <literal remap="tt">lsmod</literal> no muestra algún módulo PCMCIA.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">cardmgr</literal> informa <literal remap="tt">no pcmcia driver in /proc/devices</literal>
en el registro del sistema.

</para>
</listitem>

</itemizedlist>

</para>

<para>
Los módulos del kernel contienen información de la versión, la cual se
comprueba con el kernel actual cuando se carga un módulo. El tipo de
chequeo depende de la opción del kernel <literal remap="tt">CONFIG_MODVERSIONS</literal>. Si es
falso, entonces el número de versión del kernel se compila dentro de cada
módulo y el programa <literal remap="tt">insmod</literal> comprueba esto para compararlo con el
kernel actual. Si <literal remap="tt">CONFIG_MODVERSIONS</literal> es verdadero, entonces cada
símbolo exportado por el kernel tiene un «checksum». Esos códigos se
comparan con los códigos correspondientes compilados dentro de un módulo. 
</para>

<para>
La idea de esto fue crear módulos menos dependientes de la versión, porque
los checksums sólo pueden cambiar si la interface del kernel cambia, y
podría generalmente permanecer a lo largo de actualizaciones menores del
kernel. En esencia, los «checksums» se han desactivado para ser mas
restrictivos, porque muchas interfaces del kernel dependen de las opciones
pasadas al momento de compilarse. También, los checksums han resultado ser
jueces excesivamente pesimistas respecto a compatibilidad.
</para>

<para>
El enfoque práctico de esto es que los módulos del kernel están muy atados
a tanto la versión del kernel, como a muchas opciones de configuración del
mismo. Generalmente, un grupo de módulos compilados para un kernel
<literal remap="tt">2.0.31</literal> no cargará con otros kernels <literal remap="tt">2.0.31</literal> a menos que se tome
un cuidado especial asegurándose que los dos fueron compilados con
configuraciones similares. Esto resulta ser un asunto difícil para la
distribución de módulos precompilados del kernel.
</para>

<para>
Tiene Vd. varias opciones:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Si obtuvo controladores precompilados como parte de una distribución
de Linux, verifique que esté usando el mismo kernel que venía con su
distribución, sin modificaciones. Si pretende usar los módulos
precompilados que venían con su distribución, deberá permanecer con el
mismo kernel que trajera ésta. 

</para>
</listitem>
<listitem>

<para>
Si ha reconfigurado o actualizado su kernel, probablemente
necesitará compilar e instalar el paquete PCMCIA desde cero. Esto se hace
fácilmente si ya tiene instalada la estructura fuente del kernel. Revise
la sección <xref linkend="compilacion"/> para
instrucciones más detalladas. 

</para>
</listitem>
<listitem>

<para>
En algunos casos, las incompatibilidades en otros componentes del
sistema pueden prevenir la carga correcta de los módulos del kernel. Si ha
actualizado su propio kernel, ponga atención a la sección <xref linkend="requisitos"/> acerca de utilidades para módulos y
<literal remap="tt">binutils</literal> que se listan en el archivo <literal remap="tt">Documentation/Changes</literal>
del árbol de directorios de los fuentes del kernel. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="nocargan">
<title>Algunos módulos controladores no cargan </title>

<para>
Síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Los módulos base (<literal remap="tt">pcmcia_core</literal>, <literal remap="tt">ds</literal>, <literal remap="tt">i82365</literal>) cargan
correctamente. 

</para>
</listitem>
<listitem>

<para>
Al insertar una tarjeta, emite un pitido agudo + un pitido grave.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">cardmgr</literal> informa de errores de versiones diferentes en el
registro del sistema. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
Algunos de los módulos controladores requieren servicios del kernel que
pueden o no estar presentes, dependiendo de la configuración del kernel. 
Por ejemplo, los controladores de tarjetas SCSI requieren que el kernel
sea compilado con soporte SCSI, y los controladores de red requieren un
kernel de red. Si a un kernel le falta una característica necesaria,
<literal remap="tt">insmod</literal> puede avisar acerca de símbolos indefinidos y rechazar la
carga de un módulo en particular. Note que los mensajes de error de
<literal remap="tt">insmod</literal> no distinguen entre errores por diferencias de versiones y
errores por falta de símbolos. 
</para>

<para>
Específicamente:
</para>

<para>

<itemizedlist>
<listitem>

<para>
El controlador serie <literal remap="tt">serial_cs</literal> requiere que el soporte en el
kernel esté activado con <literal remap="tt">CONFIG_SERIAL</literal>. Este controlador se debe
compilar como módulo. 

</para>
</listitem>
<listitem>

<para>
El soporte para tarjetas serie multipuerto o tarjetas multifunción
que incluyen dispositivos serie o módems, requieren que se active
<literal remap="tt">CONFIG_SERIAL_SHARE_IRQ</literal>. 

</para>
</listitem>
<listitem>

<para>
Los clientes SCSI requieren que <literal remap="tt">CONFIG_SCSI</literal> esté activada,
junto con las opciones apropiadas para los controladores de alto nivel
(<literal remap="tt">CONFIG_BLK_DEV_SD, CONFIG_BLK_DEV_SR</literal> etc. para kernels <literal remap="tt">2.1</literal>) 
que pueden ser compilados como módulos. 

</para>
</listitem>
<listitem>

<para>
Los controladores de red requieren que se habilite <literal remap="tt">CONFIG_INET</literal>
El soporte para red del kernel no se puede compilar como módulo. 

</para>
</listitem>
<listitem>

<para>
El cliente token-ring requiere que el kernel se compile con la
opción <literal remap="tt">CONFIG_TR</literal> activada.

</para>
</listitem>

</itemizedlist>

</para>

<para>
Hay dos formas de proceder:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Recompile el kernel con las características necesarias activadas.

</para>
</listitem>
<listitem>

<para>
Si las características han sido compiladas como módulos, entonces
modifique <literal remap="tt">/etc/pcmcia/config</literal> para precargar esos módulos. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
El archivo <literal remap="tt">/etc/pcmcia/config</literal> puede especificar qué módulos
adicionales necesitan cargarse para un cliente en particular. Por ejemplo,
para el controlador serial, uno puede ser:
</para>

<para>

<screen>
       device "serial_cs"
         class "serial" module "misc/serial", "serial_cs"
</screen>

</para>

<para>
Las rutas hacia los módulos se especifican relativas al nivel más alto del
directorio de módulos para la versión actual del kernel; si no se
especifica la ruta relativa, entonces la ruta por omisión será hacia el
subdirectorio <literal remap="tt">pcmcia</literal>. 
</para>

</sect2>

<sect2 id="irqscan">
<title>fallos en la búsqueda de interrupciones
</title>

<para>
Síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
El sistema se congela cuando se cargan los controladores PCMCIA,
incluso cuando no hay tarjetas presentes. 

</para>
</listitem>
<listitem>

<para>
El registro del sistema muestra que el sondeo tuvo éxito, justo
antes de que se congele, pero no muestra resultados de las pruebas de
interrupciones. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
 
</para>

<para>
Después de identificar el tipo de controlador, el controlador del socket
sondea las interrupciones libres. Este «sondeo» o «tanteo» consiste en
programar el controlador para cada interrupción aparentemente libre,
generando una interrupción <emphasis remap="it">soft</emphasis> (suave), para ver si la interrupción
puede ser detectada correctamente. En algunos casos, el sondear una
interrupción en particular puede interferir con otro dispositivo del
sistema.
</para>

<para>
La razón de este «tanteo» es identificar interrupciones que parezcan estar
libres (es decir, aquellas que no están reservadas por otro controlador de
dispositivo), ya sea porque no esté conectado físicamente a la
controladora, o que esté conectado a otro dispositivo que no tiene un
controlador. 
</para>

<para>
En el registro del sistema, un sondeo realizado con éxito tiene este
aspecto: 
</para>

<para>

<screen>
       Intel PCIC probe:
         TI 1130 CardBus at mem 0x10211000, 2 sockets
         ...
	 ISA irqs (scanned) = 5,7,9,10 status change on irq 10
</screen>

</para>

<para>
Hay dos formas de proceder:
</para>

<para>

<itemizedlist>
<listitem>

<para>
El sondeo de interrupciones puede estar restringida a una lista de
interrupciones utilizando el parámetro <literal remap="tt">irq_list</literal> para los
controladores. Por ejemplo, <literal remap="tt">irq_list=5,9,10</literal> limitará la búsqueda a
tres interrupciones. Todos los dispositivos PCMCIA estarán restringidos a
usar esas interrupciones (asumiendo que pasen el tanteo). Puede ser que
necesite determinar qué interrupciones son tanteables de forma segura a
base de ensayo y error. 

</para>
</listitem>
<listitem>

<para>
El sondeo de interrupciones puede desactivarse completamente al
cargar el controlador del socket con la opción <literal remap="tt">do_scan=0</literal>. En este
caso, se usará una interrupción por omisión, la cual evita interrupciones
ya utilizadas por otros dispositivos.

</para>
</listitem>

</itemizedlist>

</para>

<para>
En cualquier caso, las opciones de tanteo pueden especificarse en el
script de inicio de PCMCIA utilizando la definición <literal remap="tt">PCIC_OPTS</literal>, por
ejemplo:
</para>

<para>

<screen>
	PCIC_OPTS="irq_list=5,9,10"
</screen>

</para>

<para>
Como podrá notar, <literal remap="tt">/proc/interrupts</literal> es absolutamente inútil cuando
se van a diagnosticar problemas en el sondeo de interrupciones. El tanteo
es lo suficientemente sensible como para nunca intentar usar una
interrupción que ya está en uso por otro controlador de Linux. Los
controladores PCMCIA están ya teniendo en cuenta toda la información de
<literal remap="tt">/proc/interrupts</literal>. Dependiendo del diseño del sistema, un
dispositivo inactivo puede todavía ocupar una interrupción y causar
problemas si es probado por PCMCIA.
</para>

</sect2>

<sect2 id="ioscan">
<title>Fallos en la búsqueda de puertos de E/S
</title>

<para>
Síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
El sistema se congela cuando <literal remap="tt">cardmgr</literal> se inicia por primera vez,
incluso cuando no hay tarjetas presentes.

</para>
</listitem>
<listitem>

<para>
El registro del sistema muestra un tanteo positivo del controlador
del host, incluyendo resultados de sondeos de interrupción, pero no
muestra resultados de sondeos de E/S.

</para>
</listitem>
<listitem>

<para>
En algunos casos, el tanteo de E/S será positivo, pero avisa de un
gran número de de exclusiones aleatorias. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
Cuando <literal remap="tt">cardmgr</literal> procesa los rangos de puertos de E/S listados en
<literal remap="tt">/etc/pcmcia/config.opts</literal>, el kernel tantea esos rangos para
detectar los dispositivos latentes que ocupan espacio de E/S pero que no
están asociados con un controlador de Linux. El tanteo es de sólo lectura,
pero en algunos casos extraños, leer desde un dispositivo puede interferir
con una función importante del sistema, resultando en «congelamiento».
</para>

<para>
La guía de usuario de su sistema debe traer un mapa de los dispositivos
del sistema, mostrando sus rangos de E/S y de memoria. Esos pueden ser
excluidos explícitamente en <literal remap="tt">config.opts</literal>. 
</para>

<para>
Por otra parte, si el sondeo no resulta fiable en su sistema, puede ser
desactivado estableciendo <literal remap="tt">CORE_OPTS</literal> a <literal remap="tt">probe_io=0</literal>. En este caso,
deberá ser muy cuidadoso al especificar solamente rangos de puertos
genuinamente disponibles en <literal remap="tt">config.opts</literal>, en lugar de usar las
configuraciones por omisión.
</para>

</sect2>

<sect2 id="memscan">
<title>Fallos durante la comprobación de la memoria </title>

<para>
Síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Los controladores principales cargan correctamente cuando no hay
tarjetas presentes, sin errores en el registro del sistema.

</para>
</listitem>
<listitem>

<para>
El sistema se congela y/o reinicia tan pronto como se inserte una
tarjeta antes de que se escuche algún pitido.

</para>
</listitem>

</itemizedlist>

</para>

<para>
O alternativamente:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Todas las inserciones de tarjetas generan un pitido agudo seguido de
un pitido grave.

</para>
</listitem>
<listitem>

<para>
Todas las tarjetas son identificadas como <emphasis remap="it">anonymous memory
cards</emphasis>

</para>
</listitem>
<listitem>

<para>
El registro del sistema avisa que varios rangos de memoria han
sido excluidos.

</para>
</listitem>

</itemizedlist>

</para>

<para>
Los módulos principales realizan un chequeo de los primeros 16 bits de
memoria en el momento en que se inserta la tarjeta. Esta exploración puede
interferir potencialmente con otros dispositivos de memoria mapeados. Así
mismo, los paquetes de controladores pre-3.0.0 realizan una exploración
más agresiva que los controladores más recientes. La ventana de memoria se
define en <literal remap="tt">/etc/pcmcia/config.opts</literal>. La ventana por omisión es
grande, así que puede ayudar a restringir la exploración a un rango más
reducido. Los rangos razonables para incluir son: <literal remap="tt">0xd0000-0xdffff</literal>,
<literal remap="tt">0xc0000-0xcffff</literal>, <literal remap="tt">0xc8000-0xcffff</literal>, o <literal remap="tt">0xd8000-0xdffff</literal>.
</para>

<para>
Si tiene controladores PCMCIA DOS o Windows, puede deducir que región de
memoria usan esos controladores. Tenga en cuenta que las direcciones de
memoria de DOS se especifican normalmente en forma de «segmentos», los
cuales dejan el último dígito hexadecimal (así una dirección absoluta de
<literal remap="tt">0xd0000</literal> puede darse como <literal remap="tt">0xd000</literal>). Asegúrese de añadir el dígito
extra de cuando haga los cambios a <literal remap="tt">config.opts</literal>. 
</para>

<para>
En casos no muy usuales, un fallo en el sondeo de memoria puede indicar un
problema de configuración en la sincronización con el controlador.  Revise
la sección <xref linkend="inicio"/> para más
información acerca de cómo combatir los problemas comunes de
sincronización. 
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">cs: warning: no high memory space available!</literal>

</para>
</listitem>

</itemizedlist>

</para>

<para>
Los puentes <emphasis remap="it">CardBus</emphasis> pueden reservar ventanas de memoria fuera del
«agujero de memoria» de 640KB-1MB en la arquitectura de bus ISA. 
Generalmente es buena idea el configurar puentes <emphasis remap="it">CardBus</emphasis> para usar
ventanas de memoria alta, porque es muy difícil que existan conflictos con
otros dispositivos.  También, las tarjetas <emphasis remap="it">CardBus</emphasis> pueden requerir
grandes ventanas de memoria, las cuales puede ser difícil o imposible que
coincidan en memoria baja.  Los servicios de tarjetas preferentemente
localizarán las ventanas en memoria alta para puentes <emphasis remap="it">CardBus</emphasis>, si
ambas ventanas de memoria (alta y baja) se definen en <literal remap="tt">config.opts</literal>. El
archivo <literal remap="tt">config.opts</literal> por omisión ahora incluye una ventana de memoria
alta de <literal remap="tt">0xa0000000-0xa0ffffff</literal>. Si tiene un puente <emphasis remap="it">CardBus</emphasis> y ha
actualizado de una versión de PCMCIA anterior, añada esta ventana de
memoria si no está ya definido. 
</para>

<para>
En algunos casos, la ventana de memoria alta por omisión no se utiliza.
</para>

<para>
En algunos modelos <emphasis remap="it">IBM Thinkpad</emphasis>, una ventana de
<literal remap="tt">0x60000000-0x60ffffff</literal> funcionará en lugar de la ventana por omisión.
</para>

</sect2>

<sect2>
<title>Fallo al detectar cuando se inserta o se extrae la tarjeta</title>

<para>
Síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Las tarjetas se detectan y configuran apropiadamente si están
presentes al momento de iniciar. 

</para>
</listitem>
<listitem>

<para>
Los controladores no responden a los eventos de inserción y
extracción, ya sea registrando los eventos en el registro del sistema, o
emitiendo pitidos. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
En muchos casos, el controlador del socket (<literal remap="tt">i82365</literal> o <literal remap="tt">tcic</literal>) 
probará automáticamente y seleccionará la interrupción apropiada para
señalar cambios en el estado de la tarjeta. El tanteo automático de
interrupciones no funciona con algunos controladores compatibles con
Intel, incluyendo los chips Cirrus y los chips usados en IBM Thinkpads. Si
un dispositivo está inactivo en el momento del sondeo, su interrupción
puede parecer estar disponible. En esos casos, el controlador del socket
puede usar una interrupción que es usada por otro dispositivo.
</para>

<para>
Con los controladores <literal remap="tt">i82365</literal> y <literal remap="tt">tcic</literal> la opción <literal remap="tt">list_irq</literal>
puede usarse para limitar las interrupciones que serán tanteadas. Esta
lista limita el conjunto de interrupciones que pueden ser utilizadas por
las tarjetas PCMCIA así como para monitorizar los cambios en el estado de
la tarjeta. La opción <literal remap="tt">cs_irq</literal> puede usarse también para establecer
explícitamente la interrupción que será utilizada para monitorizar dichos
cambios. 
</para>

<para>
Si no puede encontrar un número de interrupción que funcione, hay también
un estado en modo de búsqueda: ambos, <literal remap="tt">i82365</literal> y <literal remap="tt">tcic</literal> aceptarán
una opción <literal remap="tt">poll_interval=100</literal>, para buscar cambios en el estado de la
tarjeta una vez por segundo. Esta opción puede usarse también si su
sistema tiene un rango corto de interrupciones disponibles para utilizarse
con tarjetas PCMCIA. Especialmente para sistemas con más de un controlador
de host, hay un pequeño punto para dedicar interrupciones para monitorizar
cambios de estado de la tarjeta. 
</para>

<para>
Todas esas opciones deberían establecerse en la línea <literal remap="tt">PCIC_OPTS=</literal> ya
sea en <literal remap="tt">/etc/rc.d/rc.pcmcia</literal> o en <literal remap="tt">/etc/sysconfig/pcmcia</literal>,
dependiendo de la configuración de su sistema. 
</para>

</sect2>

<sect2 id="faltan">
<title>Faltan recursos del sistema </title>

<para>
Síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Cuando se inserta una tarjeta, es identificada correctamente, pero
no puede ser configurada (secuencia de pitidos agudos/graves).

</para>
</listitem>
<listitem>

<para>
Aparecen en el registro del sistema alguno de los siguientes
mensajes:


<screen>
       RequestIO: Resource in use
       RequestIRQ: Resource in use
       RequestWindow: Resource in use
       GetNextTuple: No more items
       could not allocate nn IO ports for CardBus socket n
       could not allocate nnK memory for CardBus socket n
       could not allocate interrupt for CardBus socket n
</screen>


</para>
</listitem>

</itemizedlist>

</para>

<para>
La reserva de interrupciones indica generalmente un problema con el sondeo
de interrupciones, véase la sección <xref linkend="irqscan"/>. 
</para>

<para>
En algunos casos, el tanteo parece funcionar, pero únicamente aparecen una
o dos interrupciones disponibles. Revise el registro de su sistema para
ver si los resultados de la exploración son plausibles. Desactivar el
tanteo y seleccionar las interrupciones manualmente puede ayudar.
</para>

<para>
Si el sondeo de interrupciones no está funcionando adecuadamente, el
controlador del socket puede reservar una interrupción para monitorizar
inserciones de tarjetas, incluso cuando las interrupciones sean demasiado
escasas para esto, constituye una buena idea. En este caso, puede Vd. 
cambiar el controlador a modo de búsqueda estableciendo <literal remap="tt">PCIC_OPTS</literal> a
<literal remap="tt">poll_interval=100</literal>. O, si tiene un controlador <emphasis remap="it">CardBus</emphasis>, intente
con <literal remap="tt">pci_csc=1</literal>, el cual selecciona una interrupción PCI (si está
disponible) para cambios de estado en la tarjeta. 
</para>

<para>
La reserva de puertos de E/S no es muy común, pero algunas veces tiene
lugar con tarjetas que requieren regiones de espacio de E/S grandes,
contiguas y alineadas, o que sólo reconocen pocas posiciones específicas
de puertos.  Los rangos de puertos de E/S por omisión en
<literal remap="tt">/etc/pcmcia/config.opts</literal> normalmente son suficientes, pero pueden
ser extendidos. En casos extraños, la reserva puede indicar que falló el
sondeo de puertos de E/S; revise la sección <xref linkend="ioscan"/>. 
</para>

<para>
La reserva de memoria no es común tampoco con las configuraciones de la
ventana de memoria que vienen por omisión en <literal remap="tt">config.opts</literal>. Las
tarjetas <emphasis remap="it">CardBus</emphasis> pueden requerir regiones de memoria más grandes que
las tarjetas típicas de 16-bits. Dado que de que las ventanas de memoria
de las tarjetas <emphasis remap="it">CardBus</emphasis> pueden ser mapeadas a cualquier parte del
espacio de la dirección PCI del host (en lugar de sólo mapearlo al
«agujero» de 640K-1MB en sistemas PC), es de utilidad especificar ventanas
de memoria amplias en la memoria alta, tales como
<literal remap="tt">0xa0000000-0xa0ffffff</literal>. 
</para>

</sect2>

<sect2 id="conflicto">
<title>Conflicto de recursos entre dos tarjetas </title>

<para>
Síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Dos tarjetas funcionan bien cuando se usan separadamente.

</para>
</listitem>
<listitem>

<para>
Cuando ambas tarjetas se insertan, sólo funciona una.

</para>
</listitem>

</itemizedlist>

</para>

<para>
Esto usualmente indica un conflicto de recursos con un dispositivo del
sistema que Linux no conoce. Los dispositivos PCMCIA son configurados
dinámicamente, así, por ejemplo, las interrupciones son reservadas
conforme se vayan necesitando, en lugar de ser asignadas específicamente a
tarjetas o sockets en particular. Dada una lista de recursos que parecen
estar disponibles, las tarjetas son recursos asignados en el orden en que
son configurados. En este caso, a la tarjeta configurada en último lugar
se le está asignando un recurso que en efecto, no está libre.
</para>

<para>
Revise el registro del sistema para ver qué recursos están usados por la
tarjeta que no funciona. Exclúyalos de <literal remap="tt">/etc/pcmcia/config.opts</literal>, y
reinicie el demonio <literal remap="tt">cardmgr</literal> para recargar la base de datos de
recursos.
</para>

</sect2>

<sect2 id="noconf">
<title>No se completa la configuración de dispositivos </title>

<para>
Síntomas:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Cuando se inserta una tarjeta, se escucha un pitido agudo.

</para>
</listitem>
<listitem>

<para>
Las inserciones y extracciones posteriores de tarjetas son
ignoradas. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
Esto indica que la tarjeta fue identificada con éxito, sin embargo,
<literal remap="tt">cardmgr</literal> fue incapaz de completar el proceso de configuración por
alguna razón. La más común es que un paso en el script de configuración se
ha bloqueado. Un buen ejemplo podría ser el script de red bloqueándose si
una tarjeta de red se inserta sin tener presente una conexión a la red.
</para>

<para>
Para verificar el problema, puede ejecutar manualmente un script de
configuración para ver dónde se está bloqueando. Los scripts están en el
directorio <literal remap="tt">/etc/pcmcia</literal>. Toman dos parámetros: un nombre de
dispositivo, y una acción. El demonio <literal remap="tt">cardmgr</literal> graba los comandos de
configuración en el registro del sistema. Por ejemplo, si el registro del
sistema muestra que el comando <literal remap="tt">./network start eth0</literal> fue el último
comando ejecutado por <literal remap="tt">cardmgr</literal>, el siguiente comando puede rastrear el
script: 
</para>

<para>

<screen>
       sh -x /etc/pcmcia/network start eth0
</screen>

</para>

</sect2>

</sect1>

<sect1 id="usoycar">
<title>Uso y características </title>

<sect2>
<title>Herramientas para configurar y monitorizar dispositivos PCMCIA</title>

<para>
Si los módulos son todos cargados correctamente, la salida del comando
<literal remap="tt">lsmod</literal> debería verse como sigue, cuando no hay tarjetas insertadas:
</para>

<para>

<screen>
  Module                  Size  Used by
  ds                      5640   2
  i82365                 15452   2
  pcmcia_core            30012   3  [ds i82365]
</screen>

</para>

<para>
El registro del sistema deberá también incluir la salida del controlador
del socket, describiendo el(los) controlador(es) del host encontrado(s) y
el número de sockets detectados. 
</para>

<sect3 id="cardmgr">
<title>El demonio de configuración <literal remap="tt">cardmgr</literal> </title>

<para>
El demonio <literal remap="tt">cardmgr</literal> es responsable de monitorizar los sockets PCMCIA,
cargando los controladores cuando se necesita, y corriendo scripts a nivel
de usuario en respuesta a las inserciones y extracciones de tarjetas. 
Graba sus acciones en el registro del sistema, y también usa pitidos para
señalar cambios en el estado de las tarjetas.  Los tonos de los pitidos
indican el éxito o fracaso de un paso de la configuración en particular.
Dos pitidos agudos indican que la tarjeta fue identificada y configurada
correctamente. Un pitido agudo seguido de un pitido grave indica que la
tarjeta fue identificada, pero no pudo ser configurada por alguna razón.
Un pitido grave indica que la tarjeta no pudo ser identificada. 
</para>

<para>
<literal remap="tt">cardmgr</literal> registra información del dispositivo para cada socket en <literal remap="tt">/var/run/stab</literal>
</para>

<para>
He aquí el contenido de un ejemplo de <literal remap="tt">/var/run/stab:</literal>
</para>

<para>

<screen>
       Socket 0: Adaptec APA-1460 SlimSCSI
       0       scsi    aha152x_cs      0       sda     8       0
       0       scsi    aha152x_cs      1       scd0    11      0
       Socket 1: Serial or Modem Card
       1       serial  serial_cs       0       ttyS1   5       65
</screen>

</para>

<para>
Para las líneas que describen dispositivos, el primer campo es el socket,
el segundo es la clase del dispositivo, el tercero es nombre del
controlador, el cuarto se usa para numerar múltiples dispositivos
asociados con el mismo controlador, el quinto es el nombre del
dispositivo, y los dos campos finales son los números mayor y menor para
este dispositivo (si es aplicable). 
</para>

<para>
El demonio <literal remap="tt">cardmgr</literal> configura tarjetas basadas en una base de datos de
tipos de tarjetas conocidas almacenadas en <literal remap="tt">/etc/pcmcia/config</literal>. 
Este archivo describe una variedad de controladores, describe cómo
identificar esas tarjetas, y cual(es) controlador(es) pertenecen a cada
tarjeta. El formato de este archivo se describe en la página del manual de
<literal remap="tt">pcmcia(5)</literal>.
</para>

</sect3>

<sect3 id="cc">
<title>Las utilidades <literal remap="tt">cardctl</literal> y <literal remap="tt">cardinfo</literal>
</title>

<para>
El comando <literal remap="tt">cardctl</literal> puede ser usado para comprobar el estado de un
socket, o para ver cómo está configurado. También puede ser usado para
alterar el estado de configuración de una tarjeta. He aquí un ejemplo de
la salida del comando <literal remap="tt">cardctl config</literal>:
</para>

<para>

<screen>
  Socket 0:
    not configured
  Socket 1:
    Vcc = 5.0, Vpp1 = 0.0, Vpp2 = 0.0
    Card type is memory and I/O
    IRQ 3 is dynamic shared, level mode, enabled
    Speaker output is enabled
    Function 0:
      Config register base = 0x0800
        Option = 0x63, status = 0x08
      I/O window 1: 0x0280 to 0x02bf, auto sized
      I/O window 2: 0x02f8 to 0x02ff, 8 bit
</screen>

</para>

<para>
O <literal remap="tt">cardctl ident</literal>, para obtener información de la identificación de la
tarjeta: 
</para>

<para>

<screen>
       Socket 0:
         no product info available
       Socket 1:
         product info: "LINKSYS", "PCMLM336", "A", "0040052D6400"
         manfid: 0x0143, 0xc0ab
         function: 0 (multifunction)
</screen>

</para>

<para>
Los comandos <literal remap="tt">cardctl suspend</literal> y <literal remap="tt">cardctl resume</literal> pueden usarse para
desactivar una tarjeta sin descargar sus controladores asociados. El
comando <literal remap="tt">cardctl reset</literal> intenta resetear y reconfigurar una tarjeta.
<literal remap="tt">cardctl insert</literal> y <literal remap="tt">cardctl eject</literal> emulan las acciones realizadas
cuando una tarjeta es insertada o expulsada, incluyendo la carga y
descarga de los controladores, y configurando o desactivando los
dispositivos. 
</para>

<para>
Si está Vd. corriendo X, <literal remap="tt">cardinfo</literal> produce de forma gráfica el estado
actual de todos los sockets PCMCIA, similar en contenido a <literal remap="tt">cardctl
config</literal>. También proporciona una interfaz gráfica para la mayoría de las
otras funciones de <literal remap="tt">cardctl</literal>. 
</para>

</sect3>

<sect3 id="insexp">
<title>Inserción y extracción de tarjetas </title>

<para>
En teoría, puede insertar y extraer tarjetas PCMCIA en cualquier momento. 
Sin embargo, es una buena idea no expulsar una tarjeta que está siendo
utilizada por algún programa de aplicación. Los kernels anteriores al
<literal remap="tt">1.1.77</literal> solían congelarse cuando las tarjetas serie/módem eran
expulsadas, aunque esto parece estar ya solucionado.
</para>

</sect3>

<sect3 id="aae">
<title>Servicios de Tarjetas y Administración Avanzada de Energía
</title>

<para>
Los servicios de tarjetas pueden ser compilados con soporte para APM
(<emphasis remap="it">Advanced Power Management</emphasis>) (En castellano: <emphasis remap="it">Administración
Avanzada de Energía</emphasis>), si configuró su kernel con soporte APM. APM está
actualmente a cargo de Stephen Rothwell, <literal remap="tt"><ulink
url="mailto:Stephen.Rothwell@canb.auug.org.au"
>Stephen.Rothwell@canb.auug.org.au</ulink
></literal>. El demonio <literal remap="tt">apmd</literal> es
mantenido por Avery Pennarun, <literal remap="tt"><ulink
url="mailto:apenwarr@worldvisions.ca"
>apenwarr@worldvisions.ca</ulink
></literal>), con más información disponible en
<literal remap="tt"><ulink
url="http://www.worldvisions.ca/~apenwarr/apmd/"
>http://www.worldvisions.ca/~apenwarr/apmd/</ulink
></literal>. Los módulos
PCMCIA serán configurados automáticamente para APM si es detectada una
versión compatible en el sistema. 
</para>

<para>
Esté APM configurado o no, puede usar <literal remap="tt">cardctl suspend</literal> antes de
suspender su portátil, y <literal remap="tt">cardctl resume</literal> después de «despertarlo»,
para apagar y reactivar sus tarjetas PCMCIA. No funcionará con un módem
que esté en uso, porque el controlador serie no puede guardar y
restablecer los parámetros operativos del módem.
</para>

<para>
APM parece ser inestable en algunos sistemas. Si experimenta problemas con
APM y PCMCIA en su sistema, intente localizar el problema en un paquete u
otro antes de informar de un <emphasis remap="it">bug</emphasis>. 
</para>

<para>
Algunos controladores, notablemente los controladores PCMCIA SCSI, no
pueden recuperarse de un ciclo de suspender/despertar. Cuando se usa una
tarjeta PCMCIA SCSI, use siempre <literal remap="tt">cardctl eject</literal> antes de suspender el
sistema.
</para>

</sect3>

<sect3 id="apagar">
<title>Apagado del sistema PCMCIA </title>

<para>
Para descargar el paquete PCMCIA completo, invoque <literal remap="tt">rc.pcmcia</literal> con:
</para>

<para>

<screen>
	/etc/rc.d/rc.pcmcia stop
</screen>

</para>

<para>
Este script tomará algunos segundos para ejecutarse, para darle tiempo a
todos los controladores a desactivarse correctamente. Si un dispositivo
está en uso actualmente, el proceso de desactivación será incompleto, y
puede que algunos módulos del kernel no sean descargados. Para prevenir
esto, use <literal remap="tt">cardctl eject</literal> para desactivar todos los sockets antes de
invocar <literal remap="tt">rc.pcmcia</literal>. El estado de salida del comando <literal remap="tt">cardctl</literal>
indicará si alguno de los sockets no pudo ser desactivado.
</para>

</sect3>

</sect2>

<sect2 id="configuracion">
<title>Un vistazo a los scripts de configuración de PCMCIA </title>

<para>
Cada dispositivo PCMCIA tiene una «clase» asociada que describe cómo debe
ser configurado y manejado. Las clases están asociadas con los
controladores de dispositivos en <literal remap="tt">/etc/pcmcia/config</literal>. Actualmente
hay cinco clases de dispositivos de E/S (red, SCSI, cdrom, disco, y serie) 
y dos clases de dispositivos de memoria (memoria y FTL).  Para cada clase,
hay dos scripts en <literal remap="tt">/etc/pcmcia</literal>: un script principal de
configuración (por ejemplo, <literal remap="tt">/etc/pcmcia/scsi</literal> para dispositivos
SCSI), y un script de opciones (por ejemplo,
<literal remap="tt">/etc/pcmcia/scsi.options</literal>). El script principal de un dispositivo
será invocado para configurarlo cuando se inserte una tarjeta, y para
desactivar el dispositivo cuando sea extraída.  Para tarjetas con varios
dispositivos asociados, el script será invocado para cada dispositivo.
</para>

<para>
Los scripts de configuración inician al extraer algo de información acerca
del dispositivo de <literal remap="tt">/var/run/stab</literal>. Cada script construye una
«dirección de dispositivo», que únicamente describe el dispositivo que ha
sido solicitado para configurar, en la variable de shell ADDRESS. Esto es
pasado al script <literal remap="tt">*.opts</literal>, el cual debe proporcionar información
acerca de cómo debe ser configurado un dispositivo en esta dirección. Para
algunos, la dirección del dispositivo es sólo el número de socket. Para
otros, se incluye información extra que puede ser útil para decidir cómo
configurar el dispositivo. Por ejemplo, los dispositivos de red pasan su
dirección ethernet de hardware como parte de la dirección del dispositivo,
así, el script <literal remap="tt">network.opts</literal> puede usar esto para seleccionar
diversas configuraciones.
</para>

<para>
La primera parte de todas las direcciones de dispositivos es el «esquema»
PCMCIA actual. Ese parámetro es usado para soportar múltiples conjuntos de
configuraciones de dispositivos basadas en una simple variable externa
definida por el usuario. Una uso de los esquemas puede ser el tener un
esquema de «casa», y un esquema de «trabajo», el cual puede incluir
diferentes conjuntos de parámetros de configuración de red.  El esquema
actual se selecciona usando el comando <literal remap="tt">cardctl scheme</literal>. Si no se
define un esquema, por omisión se establece el esquema <literal remap="tt">default</literal>.
</para>

<para>
Como regla general, cuando se configura Linux para un equipo portátil, los
dispositivos PCMCIA deben ser configurados desde los scripts para
dispositivos PCMCIA. No intente configurar un dispositivo PCMCIA de la
misma forma en que configuraría un dispositivo conectado de forma
permanente. No obstante, algunas distribuciones de Linux suministran
paquetes PCMCIA que están relacionadas con las herramientas de
configuración de dispositivos propios de la misma distribución. En ese
caso, alguna de las siguientes secciones puede o no aplicar; idealmente,
esto sería documentado por los encargados de la distribución.
</para>

</sect2>

<sect2 id="net">
<title>Adaptadores de red PCMCIA </title>

<para>
Las interfaces de red tipo ethernet normalmente tienen nombres como
<literal remap="tt">eth0</literal>, <literal remap="tt">eth1</literal>, y así sucesivamente. Los adaptadores Token-Ring se
manejan de forma similar, sin embargo, son llamadas comúnmente
<literal remap="tt">tr0</literal>, <literal remap="tt">tr1</literal> y así sucesivamente. El comando
<literal remap="tt">ifconfig</literal> se usa para ver o modificar el estado de una interface
de red. Una peculiaridad de Linux es que las interfaces de red no tienen
archivos de dispositivo correspondientes en <literal remap="tt">/dev/</literal>, así que no se
sorprenda si no los encuentra. 
</para>

<para>
Cuando se detecta una tarjeta ethernet, le será asignado el primer nombre
de interface que esté libre, normalmente <literal remap="tt">eth0</literal>. <literal remap="tt">cardmgr</literal> ejecutará
el script <literal remap="tt">/etc/pcmcia/network</literal> para configurar la interface, la
cual normalmente lee las configuraciones de red de
<literal remap="tt">/etc/pcmcia/network.opts</literal>. Los scripts <literal remap="tt">network</literal>, y
<literal remap="tt">network.opts</literal> serán ejecutados sólo cuando su tarjeta ethernet
esté presente. Si su sistema tiene la facilidad de configuración de red
automática, puede o no ser PCMCIA. Consulte la documentación de su
distribución de Linux y la sección <xref linkend="distribuciones"/> para determinar si los
dispositivos de red PCMCIA deben ser configurados con herramientas
automáticas, o editando <literal remap="tt">network.opts</literal>. 
</para>

<para>
La dirección de dispositivo pasada a <literal remap="tt">network.opts</literal> consiste en
cuatro campos separados por comas: el esquema, el número de socket, la
instancia de dispositivo, y la dirección ethernet de hardware de la
tarjeta, La instancia de dispositivo es usada para numerar dispositivos
para tarjetas que tienen varias interfaces de red, así que normalmente
será <literal remap="tt">0</literal>.  Si tiene varias tarjetas de red usadas para propósitos
diferentes, una opción puede ser el configurar las tarjetas basadas en la
posición del socket, como en:
</para>

<para>

<screen>
       case "$ADDRESS" in
       *,0,*,*)
           # definiciones para tarjeta de red en el socket 0
           ;;
       *,1,*,*)
           # definiciones para tarjeta de red en el socket 1
           ;;
       esac
</screen>

</para>

<para>
Alternatívamente, pueden ser configuradas usando su dirección de hardware,
como en:
</para>

<para>

<screen>
  case "$ADDRESS" in
  *,*,*,00:80:C8:76:00:B1)
      # definiciones para una tarjeta D-Link
      ;;
  *,*,*,08:00:5A:44:80:01)
      # definiciones para una tarjeta IBM
  esac
</screen>

</para>

<sect3 id="netpar">
<title>Parámetros de dispositivos de red </title>

<para>
Los siguientes parámetros se pueden definir en <literal remap="tt">network.opts</literal>:
</para>

<para>
<variablelist>

<varlistentry>
<term>IF_PORT</term>
<listitem>
<para>
Especifica el tipo de transceptor ethernet, para tarjetas que
no sean autodetectadas. Consulte <literal remap="tt">man ifport</literal> para ver los nombres
de los transceptores. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>PUMP</term>
<listitem>
<para>
Una opción booleana (y/n): indica si la dirección IP e
información de rutado del host se puede obtener ya sea por BOOTP o DHCP,
con el demonio <literal remap="tt">pump</literal>. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>BOOTP</term>
<listitem>
<para>
Una opción booleana (y/n): indica si la dirección IP del host y
su información de rutado se obtendrán usando el protocolo BOOTP, con <literal remap="tt">bootpc</literal>. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>DHCP</term>
<listitem>
<para>
Un opción booleana (y/n): indica si la dirección IP del host y
su información de rutado se obtendrán de un servidor DHCP, con
<literal remap="tt">dhcpcd</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>IPADDR</term>
<listitem>
<para>
La dirección IP para esta interface.
</para>
</listitem></varlistentry>
<varlistentry>
<term>NETMASK, BROADCAST, NETWORK</term>
<listitem>
<para>
Parámetros básicos de red: revise el COMO
de red para más información.
</para>
</listitem></varlistentry>
<varlistentry>
<term>GATEWAY</term>
<listitem>
<para>
La dirección IP de una máquina pasarela para la subred de
este host.  Los paquetes con destinos hacia afuera de esta subred serán
destinados a dicha pasarela. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>DOMAIN</term>
<listitem>
<para>
El nombre de dominio de la red local para este host, es usado
al crear <literal remap="tt">/etc/resolv.conf</literal>. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>SEARCH</term>
<listitem>
<para>
Una lista de búsqueda para búsqueda de nombres, es añadida a
<literal remap="tt">/etc/resolv.conf</literal>. DOMAIN y SEARCH son mutuamente exclusivos:
revise <literal remap="tt">man resolver</literal> para más información. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>DNS_1,DNS_2,DNS_3</term>
<listitem>
<para>
Nombres de host o direcciones IP para servidores de
nombres para esta interface, para ser añadidos a <literal remap="tt">/etc/resolv.conf</literal>
</para>
</listitem></varlistentry>
<varlistentry>
<term>MOUNTS</term>
<listitem>
<para>
Una lista de puntos de montaje NFS para ser montados por esta
interface. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>IPX_FRAME, IPX_NETNUM</term>
<listitem>
<para>
Para redes IPX: el tipo de <emphasis remap="it">frame</emphasis> y número
de red, pasado al comando <literal remap="tt">ipx_interface</literal>. 
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Por ejemplo:
</para>

<para>

<screen>
  case "$ADDRESS" in
  *,*,*,*)
      IF_PORT="10base2"
      BOOTP="n"
      IPADDR="10.0.0.1"
      NETMASK="255.255.255.0"
      NETWORK="10.0.0.0"
      BROADCAST="10.0.0.255"
      GATEWAY="10.0.0.1"
      DOMAIN="dominio.org"
      DNS_1="dns1.dominio.org"
      ;;
  esac
</screen>

</para>

<para>
Para montar y desmontar automáticamente sistemas de archivos NFS, primero
añada todos esos sistemas de archivos a <literal remap="tt">/etc/fstab</literal>, incluyendo
<literal remap="tt">noauto</literal> en las opciones de montaje. En <literal remap="tt">network.opts</literal>,
liste los puntos de montaje de los sistemas de archivos en la variable
MOUNTS. Es especialmente importante usar ya sea <literal remap="tt">cardctl</literal> o
<literal remap="tt">cardinfo</literal> para apagar una tarjeta de red cuando NFS se encuentre
activo. No es posible desmontar limpiamente los sistemas de archivos NFS
si una tarjeta de red es símplemente expulsada sin precaución. 
</para>

<para>
En adición a los parámetros usuales de configuración de red, el script
<literal remap="tt">network.opts</literal> puede especificar acciones extra a tomar después de
que una interface es configurada, o antes de que se apague la interface. 
Si <literal remap="tt">network.opts</literal> define una función de shell llamada
<literal remap="tt">start_fn</literal>, será invocada por el script de red después de que la
interface sea configurada, y el nombre de interface se pasará a la función
como su primer (y único)  argumento. Similarmente, si es definido,
<literal remap="tt">stop_fn</literal> se invocará antes de apagar una interfaz. 
</para>

<para>
El tipo de transceptor se puede seleccionar usando la configuración
<literal remap="tt">IF_PORT</literal>. Esto puede ser, ya sea un valor numérico como en las
versiones anteriores de PCMCIA, o una palabra clave que identifique el
tipo de transceptor. Todos los controladores de red están configurados por
omisión para autodetectar la interface si es posible, o bien, utilizar
10baseT. El comando <literal remap="tt">ifport</literal> se puede utilizar para comprobar el tipo
de transceptor actual. Por ejemplo: 
</para>

<para>

<screen>
       # ifport eth0 10base2
       #
       # ifport eth0
       eth0    2 (10base2)
</screen>

</para>

<para>
El controlador actual (<literal remap="tt">3.0.10</literal> o posterior) de <literal remap="tt">3c589</literal> debe
autodetectar rápidamente los cambios de transceptor en cualquier momento. 
Las primeras versiones del controlador 3x589 tenían un algoritmo de
autodetección de transceptores algo lento y no muy amistoso. Para esas
versiones, el cable de red apropiado debe ser conectado a la tarjeta
cuando la tarjeta es configurada, o se puede forzar la autodetección con:
</para>

<para>

<screen>
       ifconfig eth0 down up
</screen>

</para>

</sect3>

<sect3 id="netcom">
<title>Comentarios acerca de tarjetas específicas </title>

<para>

<itemizedlist>
<listitem>

<para>
Con las tarjetas <emphasis remap="it">IBM CCAE</emphasis> y <emphasis remap="it">Socket EA</emphasis>, el tipo de
transceptor (10base2, 10baseT, AUI), necesita configurarse cuando el
dispositivo de red está configurado. Asegúrese de que el tipo de
transceptor que aparece en el registro del sistema concuerda con su
conexión.

</para>
</listitem>
<listitem>

<para>
Los controladores para tarjetas SMC, Megahertz, Ositech, y 3Com
deben autodetectar el tipo de red conectada (10base2 o 10baseT). 
Establecer el tipo de transceptor cuando se carga el controlador sirve
para definir la «primera búsqueda» de la tarjeta. 

</para>
</listitem>
<listitem>

<para>
La <emphasis remap="it">Farallon EtherWave</emphasis> actualmente está basada en la <emphasis remap="it">3Com
3c589</emphasis>, con un transceptor especial. Aunque la EtherWave usa conexiones al
estilo 10baseT, su transceptor requiere que la 3c589 sea configurada en
modo 10base2.

</para>
</listitem>
<listitem>

<para>
Si tiene problemas con un adaptador <emphasis remap="it">IBM CCAE</emphasis>, <emphasis remap="it">NE4100</emphasis>,
<emphasis remap="it">Thomas Conrad</emphasis>, o Kingston, pruebe a incrementar el tiempo de acceso
con la opción <literal remap="tt">mem_speed=#</literal> al módulo <literal remap="tt">pcnet_cs</literal>. Un ejemplo de
cómo hacer esto se muestra en el archivo <literal remap="tt">config.opts</literal>. Pruebe con
velocidades por encima de <literal remap="tt">1000</literal> (en nanosegundos).

</para>
</listitem>
<listitem>

<para>
Para el adaptador <emphasis remap="it">New Media Ethernet</emphasis>, en algunos sistemas,
puede ser necesario incrementar el tiempo de acceso al puerto de E/S con
la opción <literal remap="tt">io_speed=#</literal> cuando se cargue el módulo <literal remap="tt">pcmcia_core</literal>.
Edite <literal remap="tt">CORE_OPTS</literal> en el script de inicio para activar esta opción.

</para>
</listitem>
<listitem>

<para>
El soporte multicast en el controlador <emphasis remap="it">New Media Ethernet</emphasis> está
incompleto. El último controlador funcionará con kernels multicast, pero
ignorará los paquetes multicast. El modo promiscuo debe funcionar
apropiadamente. 

</para>
</listitem>
<listitem>

<para>
El controlador usado por los controladores token ring IBM y 3Com
parecen comportarse bastante mal si las tarjetas no están conectadas
cuando son inicializadas. Conecte siempre esas tarjetas a la red antes de
activarlas. Si <literal remap="tt">ifconfig</literal> informa que la dirección de harware como todo
<literal remap="tt">0</literal>, esto debe ser debido a un problema de configuración de la ventana
de memoria. 

</para>
</listitem>
<listitem>

<para>
Algunas tarjetas Linksys, D-Link, e IC-Card 10baseT/10base2 tienen
una forma única de seleccionar el tipo de transceptor que no es manejado
por los controladores de Linux. Una solución es arrancar DOS y utilizar la
utilidad proporcionada por el fabricante para seleccionar el transceptor,
haciendo entonces un arranque «en caliente» de Linux. Alternativamente,
hay una utilidad Linux para realizar esta función, que está disponible en
<literal remap="tt"> <ulink
url="ftp://hyper.stanford.edu/pub/pcmcia/extras/dlport.c"
>ftp://hyper.stanford.edu/pub/pcmcia/extras/dlport.c</ulink
></literal>.

</para>
</listitem>
<listitem>

<para>
Para adaptadores de red inalámbricos WaveLAN, Jean Tourrilhes,
<literal remap="tt"><ulink
url="mailto:jt@hpl.hp.com"
>jt@hpl.hp.com</ulink
></literal>)  tiene
disponible el <emphasis remap="it">Wireless HOWTO</emphasis> (Cómo inalámbrico) en <literal remap="tt"><ulink
url="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/"
>http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/</ulink
></literal>

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

<sect3 id="diagnet">
<title>Diagnóstico de problemas con adaptadores de red </title>

<para>

<itemizedlist>
<listitem>

<para>
¿Es reconocida su tarjeta como una tarjeta ethernet? Revise el
registro del sistema y asegúrese de que <literal remap="tt">cardmgr</literal> identifique la
tarjeta correctamente e inicia uno de los controladores de red. Si no lo
hace, su tarjeta puede ser utilizable todavía si es compatible con una
tarjeta soportada. Esto es posible hacerlo fácilmente si la tarjeta dice
ser <emphasis remap="it">NE2000 compatible</emphasis>. 

</para>
</listitem>
<listitem>

<para>
¿Está configurada la tarjeta apropiadamente? Si está usando una
tarjeta soportada, y fue reconocida por <literal remap="tt">cardmgr</literal>, pero todavía no
funciona, pudo ser un conflicto de interrupción o puerto con otro
dispositivo. Determine qué recursos está utilizando la tarjeta (en el
registro del sistema), e intente de nuevo excluyéndolos en
<literal remap="tt">/etc/pcmcia/config.opts</literal> para forzar a la tarjeta a usar otros. 

</para>
</listitem>
<listitem>

<para>
Si su tarjeta parece estar configurada adecuadamente, pero a veces
se congela, particularmente bajo carga alta, puede ser que necesite
intentar cambiar los parámetros de sincronización de su controlador del
socket. Revise la sección <xref linkend="inicio"/> para
más información.

</para>
</listitem>
<listitem>

<para>
Si obtiene mensajes de <literal remap="tt">network unreachable</literal> cuando intenta
acceder a la red, la información especificada en
<literal remap="tt">/etc/pcmcia/network.opts</literal> es incorrecta. Este mensaje es una
indicación absolutamente a prueba de tontos de que hay un error de rutado.
Por otra parte, las tarjetas mal configuradas normalmente fallarán
silenciosamente. 

</para>
</listitem>
<listitem>

<para>
Para diagnosticar problemas en <literal remap="tt">/etc/pcmcia/network.opts</literal>,
empiece tratando de hacer <literal remap="tt">ping</literal> a otros sistemas en la misma subred
usando sus direcciones IP. Trate entonces de hacer <literal remap="tt">ping</literal> a su puerta
de enlace o «pasarela» (<emphasis remap="it">gateway</emphasis>), y a máquinas en otras subredes.
Debe ser posible hacer <literal remap="tt">ping</literal> a las máquinas por su nombre si lleva a
cabo dichas pruebas con éxito. 

</para>
</listitem>
<listitem>

<para>
Asegúrese que su problema sea PCMCIA. Puede ser muy útil comprobar
si la tarjeta funciona correctamente bajo DOS con los controladores del
fabricante.  Verifique bien sus modificaciones al script
<literal remap="tt">/etc/pcmcia/network.opts</literal>. Asegúrese que su cable, conector «T»,
terminador, etc. estén funcionando. 

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<sect2 id="serie">
<title>Dispositivos serie PCMCIA y módems </title>

<para>
Los dispositivos serie de Linux son gestionados por medio de los archivos
de dispositivo especiales <literal remap="tt">/dev/ttyS*</literal> y <literal remap="tt">/dev/cua*</literal>. En los
kernels <literal remap="tt">pre-2.2</literal> los dispositivos <literal remap="tt">ttyS*</literal> eran para conexiones
entrantes, como módems. El uso de dispositivos <literal remap="tt">cua*</literal> se desaprueba
en los kernels actuales, y se puede usar <literal remap="tt">ttyS*</literal> para todas las
aplicaciones. La configuración de un dispositivo serie se puede examinar y
modificar con el comando <literal remap="tt">setserial</literal>.
</para>

<para>
Cuando se detecta una tarjeta serie o módem, se le asignará el primer slot
de dispositivo serie que se encuentre disponible. Este será usualmente
<literal remap="tt">/dev/ttyS1 (cua1)</literal> o <literal remap="tt">/dev/ttyS2 (cua2)</literal>, dependiendo del
número de puertos serie que tenga. El dispositivo <literal remap="tt">ttyS*</literal> es el que
aparecerá en <literal remap="tt">/var/run/stab</literal>. El script de opciones por omisión
para dispositivos serie, <literal remap="tt">/etc/pcmcia/serial.opts</literal>, enlazará el
dispositivo a <literal remap="tt">/dev/modem</literal> por conveniencia. Para los kernels
<literal remap="tt">pre-2.2</literal>, el enlace se hace al dispositivo <literal remap="tt">cua*</literal>.
</para>

<para>
No intente usar <literal remap="tt">/etc/rc.d/rc.serial</literal> para configurar un módem
PCMCIA. Este script sólo debería ser utilizado para configurar
dispositivos no extraíbles. Modifique <literal remap="tt">/etc/pcmcia/serial.opts</literal> si
quiere hacer algo especial para configurar su módem. No intente tampoco
cambiar las configuraciones de E/S y puerto de un dispositivo serie
utilizando <literal remap="tt">setserial</literal>. Esto podría decir al controlador serie que
busque al dispositivo en un lugar diferente, pero no cambiar cómo el
hardware de la tarjeta está configurado actualmente. El script de
configuración serie le permite especificar otras opciones para
<literal remap="tt">setserial</literal>, así como si se debe añadir una línea a
<literal remap="tt">/etc/inittab</literal> para este puerto. 
</para>

<para>
La dirección del dispositivo pasada a <literal remap="tt">serial.opts</literal> tiene tres campos
separados por comas: el primero es el esquema, el segundo es el número de
socket, y el tercero es la instancia del dispositivo. La instancia del
dispositivo puede tomar varios valores para tarjetas que soporten
múltiples puertos serie, pero para tarjetas de un sólo puerto, siempre
será <literal remap="tt">0</literal>. Si comunmente usa más de un módem, puede especificar
diferentes configuraciones basadas en la posición del socket, como en:
</para>

<para>

<screen>
       case "$ADDRESS" in
       *,0,*)
           # Opciones para un modem en el socket 0
           LINK=/dev/modem0
           ;;
       *,1,*)
           # Opciones para un modem en el socket 1
           LINK=/dev/modem1
           ;;
       esac
</screen>

</para>

<para>
Si un módem PCMCIA ya está configurado cuando Linux arranca, puede ser
identificado incorrectamente como un puerto serie ordinario. Esto es
inofensivo, sin embargo, cuando los controladores PCMCIA toman el control
del módem, se le asignará un slot de dispositivo diferente.  Por ello es
mejor, ya sea analizar <literal remap="tt"> /var/run/stab</literal> o usar <literal remap="tt">/dev/modem</literal>,
en lugar de indicar que este módulo debe recargarse. Edite la entrada del
dispositivo serie, de modo que se lea:
</para>

<para>

<screen>
       device "serial_cs"
         class "serial" module "misc/serial", "serial_cs"
</screen>

</para>

<sect3 id="seriepar">
<title>Parámetros de dispositivos serie </title>

<para>
Los siguientes parámetros se pueden definir en <literal remap="tt">serial.opts</literal>:
</para>

<para>
<variablelist>

<varlistentry>
<term>LINK</term>
<listitem>
<para>
Especifica una ruta para un enlace simbólico a crear al
dispositivo <emphasis remap="it">callout</emphasis> (para llamar hacia el exterior) (ejemplo,
<literal remap="tt">/dev/cua*</literal> para kernels pre-2.2 o <literal remap="tt">/dev/ttyS*</literal> para kernels
<literal remap="tt">2.2.x</literal>). 
</para>
</listitem></varlistentry>
<varlistentry>
<term>SERIAL_OPTS</term>
<listitem>
<para>
Especifica las opciones que se pasan al comando
<literal remap="tt">setserial</literal>. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>INITTAB</term>
<listitem>
<para>
Si se especifica, se usará para añadir una entrada
<literal remap="tt">inittab</literal> para el dispositivo.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Por ejemplo:
</para>

<para>

<screen>
       case "$ADDRESS" in
       *,*,*,*)
           LINK="/dev/modem"
           SERIAL_OPTS=""
           INITTAB="/sbin/getty"
</screen>

</para>

</sect3>

<sect3 id="seriediag">
<title>Diagnóstico de problemas con dispositivos serie </title>

<para>

<itemizedlist>
<listitem>

<para>
¿Se reconoce su tarjeta como un módem? Revise el registro del
sistema y asegúrese que <literal remap="tt">cardmgr</literal> identifica la tarjeta correctamente e
inicia el controlador <literal remap="tt">serial_cs</literal>. Si no, necesitará añadir una nueva
entrada en el fichero <literal remap="tt">/etc/pcmcia/config</literal> para que pueda ser
identificado apropiadamente. Consulte la sección <xref linkend="configurando"/> para más detalles. 

</para>
</listitem>
<listitem>

<para>
¿Es el módem configurado satisfactoriamente por <literal remap="tt">serial_cs</literal>? 
Nuevamente, revise el registro del sistema y busque los mensajes del
controlador <literal remap="tt">serial_cs</literal>. Si ve mensajes como <literal remap="tt">register_serial() failed</literal> debe tener un conflicto de puerto de E/S con otro dispositivo.
Otra causa de conflictos tiene lugar cuando el dispositivo es reconocido
como una <emphasis remap="it">UART 8250</emphasis>;  la mayoría de módems modernos deben
identificarse como UART 16550A. Si piensa que está viendo un conflicto de
puertos, edite <literal remap="tt">/etc/pcmcia/config.opts</literal> y excluya el rango de
puertos que fue reservado para el módem. 

</para>
</listitem>
<listitem>

<para>
¿Hay un conflicto de interrupciones? Si el registro del sistema se
parece normal, pero el módem no funciona, pruebe a cambiar la irq a <literal remap="tt">0</literal>
usando <literal remap="tt">setserial</literal> y comprobar si el módem funciona. Esto causa que el
controlador serie use un modo de búsqueda más bajo en lugar de usar
interrupciones. Si esto parece solucionar el problema, es probable que
otro dispositivo del sistema esté usando la interrupción seleccionada por
<literal remap="tt">serial_cs</literal>. Deberá añadir una línea a <literal remap="tt">/etc/pcmcia/config.opts</literal>
para excluir esta interrupción. 

</para>
</listitem>
<listitem>

<para>
Si el módem parece funcionar muy, muy lento, esto es casi un
indicador seguro de un conflicto de interrupciones. Asegúrese que su
problema sea realmente PCMCIA. Puede ayudarle comprobar si la tarjeta
funciona bajo DOS con los controladores del fabricante. Así mismo, evite
probar la tarjeta con algo complicado como SLIP o PPP hasta que esté
seguro que haga conexiones simples. Si es capaz de establecer «conexiones
simples», pero no con SLIP, su problema es más probable que tenga que ver
con SLIP, y no con PCMCIA.

</para>
</listitem>
<listitem>

<para>
Si obtiene mensajes del kernel indicando que el módulo
<literal remap="tt">serial_cs</literal> no puede cargarse, significa que su kernel no tiene soporte
para dispositivo serie. Si ha compilado el controlador serie como módulo,
debe modificar <literal remap="tt">/etc/pcmcia/config</literal> para indicar que el módulo
serie debe cargarse antes de <literal remap="tt">serial_cs</literal>. 

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<sect2 id="parport">
<title>Dispositivos PCMCIA de puerto paralelo </title>

<para>
El controlador de puerto paralelo de Linux está estructurado por capas,
así que varios tipos de dispositivos de alto nivel pueden compartir el
mismo controlador de puerto de bajo nivel. Los dispositivos se gestionan a
través de los archivos especiales de dispositivo <literal remap="tt">/dev/lp*</literal>. La
configuración de un dispositivo de impresora puede examinarse y
modificarse con el comando <literal remap="tt">tunelp</literal>.
</para>

<para>
El módulo <literal remap="tt">parport_cs</literal> depende de los controladores <literal remap="tt">parport</literal> y
<literal remap="tt">parport_pc</literal>, los cuales pueden ser compilados dentro del kernel o bien
compilados como módulos. La estructura del controlador por capas significa
que cualquiera de los controladores paralelos de alto nivel (tales como el
controlador <literal remap="tt">plip</literal>, el controlador de impresora, etc.) deben ser
compilados como módulos. Estos controladores sólo reconocen dispositivos
de puerto paralelo en el momento de iniciar el módulo, así que pueden
cargarse después de que cualquier dispositivo paralelo PC Card sea
configurado.
</para>

<para>
La dirección del dispositivo pasada a <literal remap="tt">parport.opts</literal> tiene tres campos
separados por comas: el primero es el esquema, el segundo es el número de
socket, y el tercero es la instancia del dispositivo. La instancia del
dispositivo puede tomar varios valores para tarjetas que soportan
múltiples puertos paralelos, pero para tarjetas de un solo puerto, siempre
será <literal remap="tt">0</literal>. Si usa habitualmente más de una tarjeta, necesitará
especificar diferentes configuraciones basadas en la posición del socket,
como en: 
</para>

<para>

<screen>
       case "$ADDRESS" in
       *,0,*)
           # Opciones para una tarjeta en el socket 0
           LINK=/dev/printer0
           ;;
       *,1,*)
           # Opciones para una tarjeta en el socket 1
           LINK=/dev/printer1
           ;;
       esac
</screen>

</para>

<para>
Si configura el kernel para cargar el controlador básico de puerto
paralelo como módulo, debe editar <literal remap="tt">/etc/pcmcia/config</literal> para indicar
qué módulos necesitan cargarse. Edite la entrada para el dispositivo
paralelo de modo que se lea: 
</para>

<para>

<screen>
       device "parport_cs"
         class "parport" module "misc/parport", "misc/parport_pc", "parport_cs"
</screen>

</para>

<sect3 id="parportpar">
<title>Parámetros de dispositivos paralelos </title>

<para>
Los siguientes parámetros pueden especificarse en <literal remap="tt">parport.opts</literal>:
</para>

<para>
<variablelist>

<varlistentry>
<term>LINK</term>
<listitem>
<para>
Especifica la ruta del enlace simbólico a crear hacia el puerto
de impresora. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>LP_OPTS</term>
<listitem>
<para>
Especifica las opciones a pasar al comando <literal remap="tt">tunelp</literal>.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Por ejemplo:
</para>

<para>

<screen>
       case "$ADDRESS" in
       *,*,*,*)
           LINK="/dev/printer"
           LP_OPTS=""
</screen>

</para>

</sect3>

<sect3 id="parportdiag">
<title>Diagnóstico de problemas con dispositivos de puertos paralelos </title>

<para>

<itemizedlist>
<listitem>

<para>
¿Hay un conflicto de interrupciones? Si el registro del sistema
parece estar bien, pero el puerto no funciona, cambie la irq a <literal remap="tt">0</literal>
usando <literal remap="tt">tunelp</literal>, y compruebe si las cosas mejoran.  Esto cambia el
controlador a modo de búsqueda. Si parece solucionar el problema, es
probable que otro dispositivo en su sistema esté utilizando la
interrupción seleccionada por <literal remap="tt">parport_cs</literal>. Deberá añadir una línea a
<literal remap="tt">/etc/pcmcia/config.opts</literal> para excluir esta interrupción. 

</para>
</listitem>
<listitem>

<para>
Si su kernel genera mensajes indicando que el módulo <literal remap="tt">parport_cs</literal>
no puede cargarse, significa que el kernel no tiene soporte para
dispositivos paralelos. Si tiene compilado el controlador paralelo como
módulo, necesita modificar <literal remap="tt">/etc/pcmcia/config</literal> para indicar que
los módulos <literal remap="tt">parport</literal> y <literal remap="tt">parport_pc</literal> deben cargarse antes que
<literal remap="tt">parport_cs</literal>.

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<sect2 id="scsi">
<title>Adaptadores SCSI PCMCIA </title>

<para>
Todos los controladores que dan soporte actualmente a tarjetas SCSI PCMCIA
son trabajos basados en alguna de las siguientes tarjetas bus ISA:
<emphasis remap="it">Qlogic</emphasis>, <emphasis remap="it">Adaptec AHA-152X</emphasis>, o <emphasis remap="it">Future Domain TMC-16x0</emphasis>. Los
controladores PCMCIA son compilados enlazando parcialmente código
específico PCMCIA (en <literal remap="tt">qlogic_cs.c</literal>, <literal remap="tt">toaster_cs.c</literal>, o
<literal remap="tt">fdomain_cs.c</literal>) con el controlador SCSI normal de Linux. Debido a las
limitaciones en el modelo del controlador SCSI de Linux, sólo se soporta
una tarjeta extraíble por controlador.
</para>

<para>
Cuando se detecta un nuevo adaptador SCSI, los controladores SCSI
sondearán la presencia de dispositivos. Revise el registro del sistema
para asegurar que los dispositivos sean detectado apropiadamente. Los
nuevos dispositivos SCSI se asignarán a los primeros archivos de
dispositivo SCSI disponibles. El primer disco SCSI será <literal remap="tt">/dev/sda</literal>,
la primera cinta SCSI será <literal remap="tt">/dev/st0</literal>, y el primer CD-ROM será
<literal remap="tt">/dev/scd0</literal>. 
</para>

<para>
En <literal remap="tt">/var/run/stab</literal> se muestra una lista de los dispositivos
conectados a este adaptador, y el script de configuración
<literal remap="tt">/etc/pcmcia/scsi</literal> se llamará una vez para cada dispositivo
conectado, ya sea para configurar o apagar ese dispositivo. El script por
omisión no toma ninguna acción para configurar dispositivos SCSI, pero
desmontará apropiadamente los sistemas de archivos en dispositivos SCSI
cuando se extraiga la tarjeta. 
</para>

<para>
Las direcciones de dispositivo que se pasan a <literal remap="tt">scsi.opts</literal> son
complicadas, debido a la variedad de cosas que pueden conectarse a un
adaptador SCSI. Las direcciones consisten de de seis o siete campos
separados por comas: el esquema actual, el tipo de dispositivo, el número
de socket, el canal SCSI, ID, y el número lógico de unidad, y
opcionalmente, el número de partición. El tipo de dispositivo será <literal remap="tt">sd</literal>
para discos, <literal remap="tt">st</literal> para cintas, <literal remap="tt">sr</literal> para unidades de CD-ROM, y
<literal remap="tt">sg</literal> para dispositivos SCSI genéricos. Para la mayoría de
configuraciones, la unidad lógica y el canal SCSI serán <literal remap="tt">0</literal>. Para
unidades de disco con varias particiones, <literal remap="tt">scsi.opts</literal> se llamará
primero para toda la unidad, con direcciones de cinco campos. El script
deberá establecer la variable PARTS una lista de particiones.  Entonces,
<literal remap="tt">scsi.opts</literal> será llamado para cada partición, con las direcciones más
largas, de siete campos. 
</para>

<para>
Si su kernel no tiene un controlador de alto nivel (disco, cinta, etc) 
para un dispositivo SCSI en particular, entonces no será configurado por
los controladores PCMCIA. Como efecto lateral, el nombre del dispositivo
en <literal remap="tt">/var/run/stab</literal> será algo como <literal remap="tt">sd#nnnn</literal> donde <literal remap="tt">nnnn</literal>
es un número hexadecimal de cuatro dígitos. Esto pasa cuando <literal remap="tt">cardmgr</literal>
no puede traducir una ID de un dispositivo SCSI a su nombre de dispositivo
correspondiente en Linux.
</para>

<para>
Es posible modularizar los controladores SCSI de alto nivel para que
puedan cargarse según demanda. Para hacerlo, necesita editar
<literal remap="tt">/etc/pcmcia/config</literal> para decirle a <literal remap="tt">cardmgr</literal> qué módulos extra
necesitan ser cargados cuando sea configurado su adaptador. Por ejemplo:
</para>

<para>

<screen>
       device "aha152x_cs"
         class "scsi" module "scsi/scsi_mod", "scsi/sd_mod", "aha152x_cs"
</screen>

</para>

<para>
Especificaría que se cargase el módulo principal SCSI y el módulo
controlador de disco antes de cargar el módulo controlador PCMCIA normal.
El script <literal remap="tt">Configure</literal> de PCMCIA no detectará automáticamente módulos
SCSI modularizados, así que necesitará usar la opción de configuración
manual para habilitar el soporte SCSI. 
</para>

<para>
Encienda siempre los dispositivos SCSI antes de encender su portátil, o
antes de insertar la tarjeta adaptadora, para que el bus SCSI esté listo
cuando el adaptador se configure. También hay que ser muy cuidadoso al
expulsar un adaptador SCSI. Asegúrese que todos los dispositivos SCSI
asociados sean desmontados y cerrados antes de expulsar la tarjeta. La
mejor forma de asegurar esto es usar <literal remap="tt">cardctl</literal> o <literal remap="tt">cardinfo</literal> para
solicitar que se desactive la tarjeta antes de expulsarla físicamente. Por
ahora, todos los dispositivos SCSI deberán encenderse antes de conectar un
adaptador SCSI, y deberán permanecer conectados hasta que desconecte el
adaptador y/o apague su portátil. 
</para>

<para>
Hay una complicación potencial cuando se usan tarjetas que no se presentan
con adaptadores de bus ISA ordinarios. El bus SCSI transporta una señal
<emphasis remap="it">termination power</emphasis> (corriente de terminación) que se necesita para que
los terminadores pasivos SCSI ordinarios funcionen apropiadamente. Los
adaptadores PCMCIA SCSI no suministran corriente de terminación, así que
si se requiere, deberá proporcionarlo el dispositivo externo. Algunos
dispositivos externos SCSI deben configurarse para suministrarlo. Otros,
como el <emphasis remap="it">Iomega Zip</emphasis> y el <emphasis remap="it">Syquest EZ</emphasis>, usan terminadores activos
que no dependen de ello. En algunos casos, puede ser necesario usar un
bloque terminador especial como el <emphasis remap="it">APS SCSI Sentry 2</emphasis>, el cual tiene
una fuente de alimentación externa. Cuando configure la entrada para el
dispositivo SCSI, hágalo teniendo en cuenta si alguno de sus dispositivos
requieren o pueden suministrar corriente de terminación o no.
</para>

<sect3 id="scsipar">
<title>Parámetros de dispositivos SCSI </title>

<para>
Los siguientes parámetros pueden ser especificados en <literal remap="tt">scsi.opts</literal>:
</para>

<para>
<variablelist>

<varlistentry>
<term>DO_FSTAB</term>
<listitem>
<para>
Es una opción booleana (y/n): Especifica si se debe añadir
una entrada <literal remap="tt">/etc/fstab</literal> para este dispositivo. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>DO_FSCK</term>
<listitem>
<para>
Es una opción booleana (y/n): Especifica si se debe comprobar
este dispositivo antes de ser montado, con <literal remap="tt">fsck -Ta</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>DO_MOUNT</term>
<listitem>
<para>
Es una opción booleana (y/n): Especifica si este dispositivo
debe montarse automáticamente al momento de insertar la tarjeta. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>FSTYPE, OPTS, MOUNTPT</term>
<listitem>
<para>
El tipo de sistema de archivos, opciones de
montaje, y punto de montaje que se utilizarán para la entrada en
<literal remap="tt">fstab</literal> y/o para montar el dispositivo. 
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
Por ejemplo, un script para configurar una unidad de disco en SCSI ID 3,
con dos particiones, y un CD-ROM en SCSI ID 6:
</para>

<para>

<screen>
  case "$ADDRESS" in
  *,sd,*,0,3,0)
      # Este dispositivo tiene dos particiones...
      PARTS="1 2"
      ;;
  *,sd,*,0,3,0,1)
      # Opciones para la particion 1:
      #  actualizar /etc/fstab, y montar un sistema de archivos ext2 en /usr1
      DO_FSTAB="y" ; DO_FSCK="y" ; DO_MOUNT="y"
      FSTYPE="ext2"
      OPTS=""
      MOUNTPT="/usr1"
      ;;
  *,sd,*,0,3,0,2)
      # Opciones para la partición 2:
      #  actualizar /etc/fstab, y montar un sistema de archivos MS-DOS en /usr2
      DO_FSTAB="y" ; DO_FSCK="y" ; DO_MOUNT="y"
      FSTYPE="msdos"
      OPTS=""
      MOUNTPT="/usr2"
      ;;
  *,sr,*,0,6,0)
      # Opciones para un CD-ROM en SCSI ID 6
      PARTS=""
      DO_FSTAB="y" ; DO_FSCK="n" ; DO_MOUNT="y"
      FSTYPE="iso9660"
      OPTS="ro"
      MOUNTPT="/cdrom"
      ;;
  esac
</screen>

</para>

</sect3>

<sect3 id="scsicom">
<title>Comentarios acerca de tarjetas específicas </title>

<para>

<itemizedlist>
<listitem>

<para>
La tarjeta <emphasis remap="it">Adaptec APA-1480 CardBus</emphasis> necesita una ventana de
puerto de E/S grande (256 puertos contiguos alineados en un límite de 256
puertos). Puede que sea necesario incluir las regiones de los puertos de
E/S en <literal remap="tt">/etc/pcmcia/config.opts</literal> para garantizar que cada ventana
pueda encontrarse.

</para>
</listitem>
<listitem>

<para>
No está soportado el adaptador <emphasis remap="it">Adaptec APA-460 SlimSCSI</emphasis>. Esta
tarjeta se vendió originalmente bajo el nombre de Trantor, y cuando
Adaptec se unió a Trantor, continuaron vendiendo la tarjeta Trantor con
etiqueta Adaptec. La <emphasis remap="it">APA-460</emphasis> no es compatible con ningún controlador
de Linux existente.

</para>
</listitem>
<listitem>

<para>
He sido informado de la mala interacción entre la tarjeta <emphasis remap="it">New
Media Bus Toaster</emphasis> y un scanner <emphasis remap="it">UMAX Astra 1200s</emphasis>. Debido a la
complejidad del protocolo SCSI, cuando se diagnostican problemas con
dispositivos SCSI, es digno de considerar que combinaciones incompatibles
como esta pueden existir y no pueden documentarse. 

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

<sect3 id="scsidiag">
<title>Diagnóstico de problemas con adaptadores SCSI </title>

<para>

<itemizedlist>
<listitem>

<para>
Con el controlador <literal remap="tt">aha152x_cs</literal> (usado por Adaptec, New Media, y
algunos más), parece que el soporte SCSI de conexión/reconexión constituye
una fuente de problemas frecuentes con dispositivos de cinta. Para
desactivar esta «característica», añada lo siguiente a
<literal remap="tt">/etc/pcmcia/config.opts</literal>: 


<screen>
  module "aha152x_cs" opts "reconnect=0"
</screen>


</para>
</listitem>
<listitem>

<para>
Con el controlador <literal remap="tt">aha152x_cs</literal>, ciertos dispositivos parecen
requerir un tiempo de espera de inicio más grande, controlado con el
parámetro <literal remap="tt">reset_delay</literal> del módulo. La unidad CDR <emphasis remap="it">Yamaha 4416S</emphasis> es
uno de esos dispositivos. El resultado es que el dispositivo es
identificado sin problemas, y luego se congela el sistema. En esos casos,
pruebe:


<screen>
       module "aha152x_cs" opts "reset_delay=500"
</screen>


</para>
</listitem>
<listitem>

<para>
Otra fuente potencial de problemas en el sondeo de dispositivos SCSI
es el tanteo de LUNs múltiples. Si ve que la detección de un dispositivo
es realizada sin problemas, seguida de «timeouts» del bus SCSI cuando se
sondea el LUN 1 para ese dispositivo, debe desactivar la opción
<literal remap="tt">CONFIG_SCSI_MULTI_LUN</literal> del kernel. 

</para>
</listitem>
<listitem>

<para>
Si tiene compilado el soporte SCSI modularmente (<literal remap="tt">CONFIG_SCSI</literal> es
<literal remap="tt">m</literal>), debe modificar <literal remap="tt">/etc/pcmcia/config</literal> para cargar los
módulos SCSI antes de que se cargue el controlador <literal remap="tt">*_cs</literal> apropiado. 

</para>
</listitem>
<listitem>

<para>
Si obtiene mensajes de tipo <literal remap="tt">aborting command due to timeout</literal>
(abortando el comando debido a timeout), cuando se sondea el bus SCSI, es
muy probable que tenga un conflicto de interrupciones.

</para>
</listitem>
<listitem>

<para>
Si el controlador del host avisa <literal remap="tt">no SCSI devices found</literal> (no se
han encontrado dispositivos SCSI), verifique que el kernel fue compilado
con los controladores SCSI de alto nivel apropiados para sus dispositivos
(por ejemplo, disco, cinta, CD-ROM, y/o genéricos). Si falta un
controlador de alto nivel, los dispositivos de ese tipo se ignorarán. 

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<sect2 id="mem">
<title>Tarjetas de memoria PCMCIA </title>

<para>
El controlador <literal remap="tt">memory_cs</literal> maneja todos los tipos de tarjetas de
memoria, y también proporciona acceso directo al espacio de la dirección
de memoria PCMCIA para tarjetas que tienen otras funciones. Cuando se
carga, crea una combinación de dispositivos de caracteres y de bloques.
Revise la página del manual del módulo para ver una descripción completa
del esquema de nombres de estos dispositivos. Los dispositivos de bloques
se usan para tener acceso a disco (creando y montando sistemas de
archivos, etc.).  Los dispositivos de caracteres son para lecturas en
bruto (que no se procesan) que no se guardan en el buffer y son escritas
en posiciones arbitrarias. 
</para>

<para>
La dirección de dispositivo que se pasa a <literal remap="tt">memory.opts</literal> consiste de dos
campos: el esquema, y el número de socket. Las opciones se aplican a la
primera partición de memoria común en la tarjeta correspondiente.
</para>

<para>
Algunas tarjetas de memoria antiguas, y la mayoría de las tarjetas de RAM
simple estática, carecen de <emphasis remap="it">Card Information Structure, CIS</emphasis>
(Estructura de Información de Tarjeta), que es el esquema que las tarjetas
PCMCIA usan para identificarse a si mismas. Normalmente, <literal remap="tt">cardmgr</literal>
asumirá que una tarjeta que carece de CIS es una tarjeta de memoria
simple, y cargará el controlador <literal remap="tt">memory_cs</literal>. Por tanto, un efecto
lateral es que otros tipos de tarjetas pueden detectarse erróneamente como
tarjetas de memoria. 
</para>

<para>
El controlador <literal remap="tt">memory_cs</literal> usa un algoritmo heurístico para determinar
la capacidad de esas tarjetas. Este algoritmo no funciona con tarjetas
protegidas contra escritura, y puede cometer errores en algunos otros
casos. Si una tarjeta se configura de forma errónea, su tamaño puede
especificarse explícitamente cuando se haga uso de los comandos <literal remap="tt">dd</literal> o
<literal remap="tt">mkfs</literal>. 
</para>

<sect3 id="mempar">
<title>Parámetros de dispositivos de memoria </title>

<para>
<variablelist>

<varlistentry>
<term>DO_FSTAB</term>
<listitem>
<para>
Es una opción booleana (y/n): Especifica si se debe añadir
una entrada <literal remap="tt">/etc/fstab</literal> para este dispositivo. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>DO_FSCK</term>
<listitem>
<para>
Es una opción booleana (y/n): Especifica si se debe comprobar
este dispositivo antes de ser montado, con <literal remap="tt">fsck -Ta</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>DO_MOUNT</term>
<listitem>
<para>
Es una opción booleana (y/n): Especifica si este dispositivo
debe montarse automáticamente en el momento de insertar la tarjeta. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>FSTYPE, OPTS, MOUNTPT</term>
<listitem>
<para>
El tipo de sistema de archivos, opciones de
montaje, y punto de montaje que se utilizarán para la entrada en
<literal remap="tt">fstab</literal> y/o para montar el dispositivo.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
He aquí un ejemplo de un script que montará automáticamente las tarjetas
de memoria basándose en el socket en que estén insertadas:
</para>

<para>

<screen>
       case "$ADDRESS" in
       *,0,0)
           # Montar sistema de archivos, pero no actualizar /etc/fstab
           DO_FSTAB="n" ; DO_FSCK="y" ; DO_MOUNT="y"
           FSTYPE="ext2" ; OPTS=""
           MOUNTPT="/mem0"
           ;;
       *,1,0)
           # Montar sistema de archivos, pero no actualizar /etc/fstab
           DO_FSTAB="n" ; DO_FSCK="y" ; DO_MOUNT="y"
           FSTYPE="ext2" ; OPTS=""
           MOUNTPT="/mem1"
           ;;
       esac
</screen>

</para>

</sect3>

<sect3 id="flash">
<title>Uso de tarjetas de memoria flash </title>

<para>
La dirección de dispositivo que se pasa a <literal remap="tt">ftl.opts</literal> consiste en tres o
cuatro campos: el esquema, el número de socket, el número de región, y
opcionalmente, el número de partición. La mayoría de tarjetas flash tienen
sólo una región de memoria flash, así que el número de región será
generalmente cero siempre. 
</para>

<para>
Para usar una tarjeta de memoria flash como un dispositivo de bloques del
tipo de un disco ordinario, primero se crea una partición FTL, o <emphasis remap="it">flash
translation layer</emphasis>, en el dispositivo por medio del comando
<literal remap="tt">ftl_format</literal>. Esta capa oculta los detalles específicos de dispositivo
de la programación de la memoria flash y hace que la tarjeta se vea como
un simple dispositivo de bloques. Por ejemplo:
</para>

<para>

<screen>
       ftl_format -i /dev/mem0c0c
</screen>

</para>

<para>
Nótese que este comando accede a la tarjeta por medio de la interface
<emphasis remap="it">raw</emphasis> de la tarjeta de memoria. Una vez formateada, la tarjeta puede
tratarse como un dispositivo de bloques ordinario por medio del
controlador <literal remap="tt">ftl_cs</literal>. Por ejemplo:
</para>

<para>

<screen>
       mke2fs /dev/ftl0c0
       mount -t ext2 /dev/ftl0c0 /mnt
</screen>

</para>

<para>
La nomenclatura de dispositivos FTL es difícil. Los números menores de los
dispositivos tienen tres partes: el número de tarjeta, el número de región
en esa tarjeta, y opcionalmente, la partición dentro de esa región. Una
región puede ser tratada como un simple dispositivo de bloques sin tabla
de partición (como un disquete), o puede particionarse como un disco duro.
El dispositivo <literal remap="tt">ftl0c0</literal> es la tarjeta <literal remap="tt">0</literal>, región de memoria común
<literal remap="tt">0</literal>, la región entera. Los dispositivos de <literal remap="tt">ftl0c0p1</literal> a
<literal remap="tt">ftl0c0p4</literal> son primariamente las particiones de <literal remap="tt">1</literal> a <literal remap="tt">4</literal> si la
región ha sido particionada.
</para>

<para>
Hay dos formatos mayores para tarjetas de memoria flash: el estilo
<emphasis remap="it">FTL</emphasis>, y el sistema de archivos <emphasis remap="it">Microsoft Flash</emphasis>. El formato FTL es
generalmente más flexible porque permite que pueda utilizarse cualquier
sistema de archivos de alto nivel en una tarjeta flash como si fuera un
dispositivo de disco ordinario. El <emphasis remap="it">FFS</emphasis> es un tipo sistema de archivos
completamente diferente. Linux no puede manejar actualmente tarjetas
formateadas con <emphasis remap="it">FFS</emphasis>. 
</para>

<para>
Las tarjetas flash <emphasis remap="it">Intel Series 100</emphasis> usan el primer bloque flash de
128k para almacenar la información de la configuración de la tarjeta. Para
prevenir el borrado accidental de esta información, <literal remap="tt">ftl_format</literal>
automáticamente detectará esto y saltará al primer bloque cuando se cree
una partición FTL. 
</para>

</sect3>

</sect2>

<sect2>
<title>Tarjetas PCMCIA para unidades ATA/IDE</title>

<para>
El soporte para unidades ATA/IDE se basa en el controlador IDE regular del
kernel. La parte específica PCMCIA del controlador es <literal remap="tt">ide_cs</literal>.
Asegúrese de usar <literal remap="tt">cardctl</literal> o <literal remap="tt">cardinfo</literal> para apagar la tarjeta
ATA/IDE antes de expulsarla, porque el controlador no fue programado a
prueba de extracción en caliente. 
</para>

<para>
La dirección de dispositivo que se pasa a <literal remap="tt">ide.opts</literal> consiste de tres o
cuatro campos: el esquema actual, el número de socket, el número de serie
de la unidad, y un número opcional de partición. El comando <literal remap="tt">ide_info</literal>
puede usarse para obtener el número de serie del dispositivo IDE. Tal y
como sucede con los dispositivos SCSI, <literal remap="tt">ide.opts</literal> se llama primero para
el dispositivo entero. Si <literal remap="tt">ide.opts</literal> retorna una lista de particiones
en la variable <literal remap="tt">PARTS</literal>, el script entonces se llamará para cada
partición.
</para>

<sect3 id="ide">
<title>Parámetros para discos ATA/IDE </title>

<para>
Los siguientes parámetros se pueden especificar en <literal remap="tt">ide.opts</literal>:
</para>

<para>
<variablelist>

<varlistentry>
<term>DO_FSTAB</term>
<listitem>
<para>
Es una opción booleana (y/n): Especifica si se debe añadir
una entrada <literal remap="tt">/etc/fstab</literal> para este dispositivo. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>DO_FSCK</term>
<listitem>
<para>
Es una opción booleana (y/n): Especifica si se debe comprobar
este dispositivo antes de ser montado, con <literal remap="tt">fsck -Ta</literal>.
</para>
</listitem></varlistentry>
<varlistentry>
<term>DO_MOUNT</term>
<listitem>
<para>
Es una opción booleana (y/n): Especifica si este dispositivo
debe montarse automáticamente al momento de insertar la tarjeta. 
</para>
</listitem></varlistentry>
<varlistentry>
<term>FSTYPE, OPTS, MOUNTPT</term>
<listitem>
<para>
El tipo de sistema de archivos, opciones de
montaje, y punto de montaje que se utilizarán para la entrada en
<literal remap="tt">fstab</literal> y/o para montar el dispositivo.
</para>
</listitem></varlistentry>
</variablelist>
</para>

<para>
He aqui un ejemplo del archivo <literal remap="tt">ide.opts</literal> para montar la primera
partición de cualquier tarjeta ATA/IDE en <literal remap="tt">/mnt</literal>. 
</para>

<para>

<screen>
       case "$ADDRESS" in
       *,*,*,1)
           DO_FSTAB="y" ; DO_FSCK="y" ; DO_MOUNT="y"
           FSTYPE="msdos"
           OPTS=""
           MOUNTPT="/mnt"
           ;;
       *,*,*)
           PARTS="1"
           ;;
       esac
</screen>

</para>

</sect3>

<sect3 id="idediag">
<title>Diagnóstico de problemas con adaptadores ATA/IDE </title>

<para>

<itemizedlist>
<listitem>

<para>
Algunas unidades IDE violan la especificación PCMCIA al requerir un
tiempo mayor para iniciar que el máximo permitido para la configuración de
la tarjeta. Desde la versión <literal remap="tt">3.0.6</literal>, el controlador <literal remap="tt">ide_cs</literal>
automáticamente intentará sondear el dispositivo para darle tiempo de
iniciarlos. Con los controladores antiguos, necesita cargar el módulo
<literal remap="tt">pcmcia_core</literal> con:


<screen>
       CORE_OPTS="unreset_delay=400"
</screen>


</para>
</listitem>
<listitem>

<para>
Para usar una unidad de CD-ROM ATA/IDE, el kernel debe compilarse
con <literal remap="tt">CONFIG_BLK_DEV_IDECD</literal> activado. Normalmente será el caso para los
kernels estándar, sin embargo es bueno estar enterado por si compila un
kernel personalizado. 

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<sect2 id="multi">
<title>Tarjetas multifunción </title>

<para>
Se puede compartir una simple interrupción entre varios controladores,
como el controlador serie y el controlador ethernet: en efecto: la
especificación PCMCIA requiere que todas las funciones de las tarjetas
compartan la misma interrupción. Normalmente, todas las funciones de las
tarjetas están disponibles sin tener que intercambiar controladores. 
</para>

<para>
El uso simultáneo de dos funciones de tarjetas es algo «difícil» y varios
fabricantes de hardware han implementado el compartir interrupciones en
sus propias formas incompatibles (y a veces propietarias). Los
controladores para algunas tarjetas (Ositech Jack de Diamond, 3Com 3c562,
Linksys) soportan de forma apropiada el acceso simultáneo, pero otras
(Megahertz en particular) no.
</para>

<para>
Los kernels antiguos no soportan el compartir interrupciones entre
diferentes controladores de dispositivos, así que no es posible para los
controladores PCMCIA el configurar esta tarjeta para acceso simultáneo
ethernet y módem. Los controladores ethernet y serie se cargan
automáticamente. Sin embargo, el controlador ethernet por omisión «posee»
la interrupción de la tarjeta. Para usar el módem, puede descargar el
controlador ethernet y reconfigurar el puerto serie haciendo algo como:
</para>

<para>

<screen>
       ifconfig eth0 down
       rmmod 3c589_cs
       setserial /dev/modem autoconfig auto_irq
       setserial /dev/modem
</screen>

</para>

<para>
El segundo <literal remap="tt">setserial</literal> debe verificar que el puerto ha sido configurado
para usar la interrupción que previamente utilizaba el controlador
ethernet. 
</para>

</sect2>

</sect1>

<sect1 id="avan">
<title>Temas avanzados </title>

<sect2>
<title>Apartado de recursos para dispositivos PCMCIA</title>

<para>
En teoría, no debe importar qué interrupción se reserva para cada
dispositivo, mientras dos dispositivos no sean configurados para usar la
misma interrupción.
</para>

<para>
En <literal remap="tt">/etc/pcmcia/config.opts</literal> encontrará un lugar para excluir las
interrupciones que son usadas por dispositivos no PCMCIA. 
</para>

<para>
De igual modo, no hay forma de especificar directamente las direcciones de
E/S que va a utilizar una tarjeta. El archivo
<literal remap="tt">/etc/pcmcia/config.opts</literal> permite especificar rangos de puertos
disponibles para ser usados por una tarjeta cualquiera, o para excluir
rangos que causan conflictos con otros dispositivos.
</para>

<para>
Después de modificar <literal remap="tt">/etc/pcmcia/config.opts</literal>, puede reiniciar
<literal remap="tt">cardmgr</literal> con <literal remap="tt">kill -HUP</literal>.
</para>

<para>
La interrupción que se utiliza para monitorizar el estado de la tarjeta se
determina por el módulo controlador de bajo nivel del socket (<literal remap="tt">i82365</literal>
o <literal remap="tt">tcic</literal>) antes de que <literal remap="tt">cardmgr</literal> pase a <literal remap="tt">/etc/pcmcia/config</literal>,
así no se ve afectado con los cambios a este archivo. Para establecer esta
interrupción, use la opción <literal remap="tt">cs_irq=</literal> cuando se cargue el controlador
del socket, estableciendo la variable <literal remap="tt">PCIC_OPTS</literal> en
<literal remap="tt">/etc/rc.d/rc.pcmcia</literal>
</para>

<para>
Todos los controladores de tarjetas tienen un parámetro llamado
<literal remap="tt">irq_list</literal> para especificar qué interrupciones pueden intentar
reservar. Dichas opciones deben establecerse en el archivo
<literal remap="tt">/etc/pcmcia/config</literal>. Por ejemplo: 
</para>

<para>

<screen>
       device "serial_cs"
         module "serial_cs" opts "irq_list=8,12"
         ...
</screen>

</para>

<para>
debe especificarse que el controlador serie debe utilizar sólo la irq 8 o
la 12. Sin importar las configuraciones de <literal remap="tt">irq_list</literal>, los Servicios de
Tarjetas nunca reservarán una interrupción que ya esté siendo usada por
otro dispositivo, o una interrupción que esté excluida en el archivo de
configuración. 
</para>

</sect2>

<sect2 id="casa">
<title>Cómo puedo separar configuraciones de los dispositivos para casa y el
trabajo? </title>

<para>
Esto es bastante fácil con el soporte de «esquemas». Usando dos esquemas
de configuración, llamados <literal remap="tt">casa</literal> y <literal remap="tt">trabajo</literal>. He aquí un ejemplo
del script <literal remap="tt">network.opts</literal> con configuraciones específicas de esquemas:
</para>

<para>

<screen>
       case "$ADDRESS" in
       trabajo,*,*,*)
           # definiciones para la tarjeta de red en el esquema trabajo
           ...
           ;;
       casa,*,*,*|default,*,*,*)
           # definiciones para la tarjeta de red en el esquema casa
           ...
           ;;
       esac
</screen>

</para>

<para>
La primera parte de una dirección de dispositivo siempre es la
configuración del esquema. En este ejemplo, la segunda cláusula <literal remap="tt">case</literal>
aplicará para ambos esquemas. Así, si un esquema no está establecido por
cualquier razón, se tomará por omisión la configuración <literal remap="tt">casa</literal>.
</para>

<para>
Ahora, para seleccionar entre dos conjuntos de configuraciones, ejecute:
</para>

<para>

<screen>
       cardctl scheme casa
</screen>

</para>

<para>
o bien
</para>

<para>

<screen>
       cardctl scheme trabajo
</screen>

</para>

<para>
El comando <literal remap="tt">cardctl</literal> hace el equivalente a apagar todas sus tarjetas y
luego reiniciarlas. Este comando puede ejecutarse de forma segura estando
el sistema PCMCIA cargado o no, pero el comando puede fallar si está
usando otros dispositivos PCMCIA en ese momento (incluso si sus
configuracion no es explícitamente dependiente de la configuración del
esquema).
</para>

<para>
Para mostrar la configuración del esquema, ejecute:
</para>

<para>

<screen>
       cardctl scheme
</screen>

</para>

<para>
Por omisión, la configuración del esquema es persistente a través de los
inicios del equipo. Esto puede tener efectos no deseados si la red se
inicializa para el ambiente equivocado. Opcionalmente, puede establecer el
valor inicial del esquema con la opción de inicio <literal remap="tt">SCHEME</literal>; consulte la
sección <xref linkend="inicio"/> para más detalles. 
También es posible establecer el esquema desde el prompt de inicio de
<literal remap="tt">lilo</literal>.  Debido a que <literal remap="tt">lilo</literal> pasa opciones desconocidas a <literal remap="tt">init</literal>
como variables de entorno, un valor destinado a <literal remap="tt">SCHEME</literal> (o cualquier
otra opción de inicio de PCMCIA) en el prompt de inicio se propagará al
script de inicio PCMCIA. 
</para>

<para>
Para ahorrarse tecleo, los esquemas pueden ser especificados en el archivo
de configuración de <literal remap="tt">lilo</literal>. Por ejemplo, puede tener: 
</para>

<para>

<screen>
       root = /dev/hda1
       read-only
       image = /boot/vmlinuz
         label  = casa
         append = "SCHEME=casa"
       image = /boot/vmlinuz
         label  = trabajo
         append = "SCHEME=trabajo"
</screen>

</para>

<para>
Así, al teclear <literal remap="tt">casa</literal> o <literal remap="tt">trabajo</literal> en el prompt de inicio arrancará
con el esquema PCMCIA apropiado.
</para>

</sect2>

<sect2 id="boot">
<title>Arranque desde un dispositivo PCMCIA </title>

<para>
Tener el sistema de archivos raíz en un dispositivo PCMCIA es algo difícil
porque el sistema PCMCIA de Linux no está diseñado para ser enlazado
dentro del kernel. Sus componentes principales, los módulos cargables del
kernel y el demonio <literal remap="tt">cardmgr</literal> dependen de un sistema que ya está
ejecutándose. La funcionalidad <literal remap="tt">initrd</literal> del kernel sortea esta
limitación permitiendo a Linux iniciar utilizando un disco ram temporal
como una imagen raíz mínima, cargar los controladores, y remontar entonces
un sistema de archivos raíz diferente. La raíz temporal puede configurar
dispositivos PCMCIA y luego remontar un dispositivo PCMCIA como raíz.
</para>

<para>
La imagen <literal remap="tt">initrd</literal> de residir en un dispositivo arrancable
obligatoriamente;  lo que implica no puede tratarse de un dispositivo
PCMCIA. Esta es una limitación de BIOS, no del kernel. Aqui es útil
distinguir entre dispositivos «arrancables» (es decir, dispositivos desde
los que se puede iniciar), y dispositivos <emphasis remap="it">root-able</emphasis>s (es decir,
dispositivos origen, que son montados como raíz). Los dispositivos
«arrancables» se determinan por BIOS, y están limitados generalmente a
discos flexibles internos y unidades de disco duro. La funcionalidad
<literal remap="tt">initrd</literal> permite disponer de más dispositivos origen, no de más
dispositivos «arrancables».
</para>

<para>
Algunas distribuciones de Linux permitirán la instalación a un dispositivo
conectado a un adaptador SCSI PCMCIA, como un efecto lateral involuntario
de su soporte para instalar desde unidades de CD-ROM SCSI PCMCIA. Sin
embargo, en la actualidad, no hay herramientas de instalación de Linux que
soporten el configurar una imagen <literal remap="tt">initrd</literal> apropiada para iniciar Linux
con un sistema de archivos raíz PCMCIA. Configurar un sistema con raíz
PCMCIA de este modo requiere que se use otro sistema Linux para crear la
imagen <literal remap="tt">initrd</literal>. Si no tiene otro sistema Linux disponible, una opción
podría ser instalar temporalmente una configuración mínima en una unidad
no PCMCIA, crear una imagen <literal remap="tt">initrd</literal>, y luego reinstalar en el
dispositivo PCMCIA destino. 
</para>

<para>
El <emphasis remap="it">Linux Bootdisk-HOWTO</emphasis> contiene información general acerca de la
configuración de discos de inicio pero nada específico de <literal remap="tt">initrd</literal>.  El
documento principal de <literal remap="tt">initrd</literal> se incluye con las distribuciones
recientes del código fuente del kernel, en
<literal remap="tt">linux/Documentation/initrd.txt</literal>. Antes de empezar, debería leer
este documento. Es de utilidad estar familiarizado con <literal remap="tt">lilo</literal>. El uso
de <literal remap="tt">initrd</literal> también requiere que tenga un kernel compilado con
<literal remap="tt">CONFIG_BLK_DEV_RAM</literal> y <literal remap="tt">CONFIG_BLK_DEV_INITRD</literal> activados.
</para>

<para>
Esta es una técnica de configuración avanzada, y requiere un alto nivel de
familiaridad con Linux y el sistema PCMCIA. Asegúrese de leer toda la
documentación relevante antes de empezar. Las siguientes recetas deberían
funcionar, pero las derivaciones de los ejemplos le pondrán rápidamente en
un territorio desconocido y «no soportado»; y estará solo.
</para>

<para>
Este método requiere obligatoriamente que se use una versión del
controlador PCMCIA <literal remap="tt">2.9.5</literal> o posterior. Los paquetes PCMCIA antiguos o
los componentes individuales no funcionarán en el contexto <literal remap="tt">initrd</literal>. No
mezcle componentes de diferentes versiones. 
</para>

<sect3 id="pcinitrd">
<title>El script <literal remap="tt">pcinitrd</literal> </title>

<para>
El script <literal remap="tt">pcinitrd</literal> crea una imagen básica para iniciar con una
partición raíz PCMCIA. La imagen incluye una jerarquía de directorios
mínima, algunos archivos de dispositivos, unos cuantos binarios,
bibliotecas compartidas, y un conjunto de módulos controladores PCMCIA.
Cuando se invoca <literal remap="tt">pcinitrd</literal>, especifique los módulos controladores que
busca que se incluyan en la imagen. Los componentes principales de PCMCIA,
<literal remap="tt">pcmcia_core</literal> y <literal remap="tt">ds</literal>, se incluyen automáticamente.
</para>

<para>
Como ejemplo, digamos que su portátil usa un controlador compatible con
<literal remap="tt">i82365</literal>, y quiere iniciar Linux con el sistema de archivos raíz en un
disco duro conectado a un adaptador <emphasis remap="it">Adaptec SlimSCSI</emphasis>. Podría crear
una imagen <literal remap="tt">initrd</literal> apropiada con:
</para>

<para>

<screen>
       pcinitrd -v initrd pcmcia/i82365.o pcmcia/aha152x_cs.o
</screen>

</para>

<para>
Para personalizar la secuencia de inicio de <literal remap="tt">initrd</literal>, podría montar la
imagen usando el dispositivo <emphasis remap="it">loopback</emphasis> con un comando como: 
</para>

<para>

<screen>
       mount -o loop -t ext2 initrd /mnt
</screen>

</para>

<para>
y luego editar el script <literal remap="tt">linuxrc</literal>. Los archivos de configuración se
instalarán bajo <literal remap="tt">/etc</literal> en la imagen, y también puede
personalizarse. Consulte la página del manual de <literal remap="tt">pcinitrd</literal> para mayor
información.
</para>

</sect3>

<sect3 id="initrddsk">
<title>Creación de un disquete de inicio <literal remap="tt">initrd</literal>
</title>

<para>
Después de crear una imagen con <literal remap="tt">pcinitrd</literal>, puede crear un disquete de
inicio copiando el kernel, la imagen initrd comprimida, y algunos archivos
de soporte para <literal remap="tt">lilo</literal> a un disquete limpio. En el ejemplo siguiente,
asumimos que el dispositivo raíz PCMCIA deseado es <literal remap="tt">/dev/sda1</literal>:
</para>

<para>

<screen>
       mke2fs /dev/fd0
       mount /dev/fd0 /mnt
       mkdir /mnt/etc /mnt/boot /mnt/dev
       cp -a /dev/fd0 /dev/sda1 /mnt/dev
       cp [kernel-image] /mnt/vmlinuz
       cp /boot/boot.b /mnt/boot/boot.b
       gzip &#60; [initrd-image] &#62; /mnt/initrd
</screen>

</para>

<para>
Genere un fichero <literal remap="tt">/mnt/etc/lilo.conf</literal> que contenga:
</para>

<para>

<screen>
       boot=/dev/fd0
       compact
       image=/vmlinuz
           label=linux
           initrd=/initrd
           read-only
           root=/dev/sda1
</screen>

</para>

<para>
Finalmente, invoque a lilo con:
</para>

<para>

<screen>
       lilo -r /mnt
</screen>

</para>

<para>
Cuando <literal remap="tt">lilo</literal> es invocado con <literal remap="tt">-r</literal>, realiza todas las acciones
tomando como directorio raíz el especificado. La razón para crear los
archivos de dispositivo bajo <literal remap="tt">/mnt/dev</literal> es que <literal remap="tt">lilo</literal> no podrá
usar esos archivos en <literal remap="tt">/dev</literal> cuando se ejecute con este directorio
raíz alternativo.
</para>

</sect3>

<sect3 id="nolinux">
<title>Instalación de una imagen <literal remap="tt">initrd</literal> en una unidad no-Linux </title>

<para>
Un uso común de la funcionalidad <literal remap="tt">initrd</literal> puede darse en sistemas donde
el disco duro interno está dedicado a otro sistema operativo. El kernel de
Linux y la imagen <literal remap="tt">initrd</literal> pueden ponerse en una partición no-Linux, y
<literal remap="tt">lilo</literal> o <literal remap="tt">LOADLIN</literal> pueden configurarse para iniciar Linux desde esas
imágenes. 
</para>

<para>
Asumiendo que tiene un kernel que se ha configurado para el dispositivo
raíz apropiado, y una imagen <literal remap="tt">initrd</literal> creada en otro sistema, la forma
más fácil de iniciar Linux es utilizando <literal remap="tt">LOADLIN</literal>, como:
</para>

<para>

<screen>
       LOADLIN &#60;kernel&#62; initrd=&#60;imagen-initrd&#62;
</screen>

</para>

<para>
Una vez que pueda iniciar Linux en su máquina destino, puede instalar
<literal remap="tt">lilo</literal> para permitir que Linux se inicie directamente. Por ejemplo,
digamos que <literal remap="tt">/dev/hda1</literal> es la partición no-Linux destino y
<literal remap="tt">/mnt</literal> puede usarse como un punto de montaje. Primero, genere un
subdirectorio en el destino para los archivos de Linux:
</para>

<para>

<screen>
       mount /dev/hda1 /mnt
       mkdir /mnt/linux
       cp [imagen-del-kernel] /mnt/linux/vmlinuz
       cp [imagen-initrd] /mnt/linux/initrd
</screen>

</para>

<para>
En este ejemplo, digamos que <literal remap="tt">/dev/sda1</literal> es la partición raíz de
Linux deseada, en un disco duro SCSI montado vía un adaptador PCMCIA SCSI.
Para instalar <literal remap="tt">lilo</literal>, genere un archivo <literal remap="tt">lilo.conf</literal> que contenga: 
</para>

<para>

<screen>
       boot=/dev/hda
       map=/mnt/linux/map
       compact
       image=/mnt/linux/vmlinuz
               label=linux
               root=/dev/sda1
               initrd=/mnt/linux/initrd
               read-only
       other=/dev/hda1
               table=/dev/hda
               label=windows
</screen>

</para>

<para>
La línea <literal remap="tt">boot=</literal> dice que se instale el cargador de inicio en el MBR
(<emphasis remap="it">master boot record</emphasis>) del dispositivo especificado. La línea
<literal remap="tt">root=</literal> identifica el sistema de archivos raíz deseado a usar después
de cargar la imagen <literal remap="tt">initrd</literal>, que puede resultar innecesario si la
imagen del kernel ya se encuentra configurada de esta forma. La sección
<literal remap="tt">other=</literal> se usa para describir el otro sistema operativo instalado en
<literal remap="tt">/dev/hda1</literal>. 
</para>

<para>
Para instalar <literal remap="tt">lilo</literal> en este caso, teclee:
</para>

<para>

<screen>
       lilo -C lilo.conf
</screen>

</para>

<para>
Nótese que en este caso, el archivo <literal remap="tt">lilo.conf</literal> usa rutas absolutas que
incluyen <literal remap="tt">/mnt</literal>. Hice esto en el ejemplo porque el sistema de
archivos destino puede no soportar la creación de archivos de dispositivos
para las opciones <literal remap="tt">boot=</literal> y <literal remap="tt">root=</literal>.
</para>

</sect3>

</sect2>

</sect1>

<sect1 id="unsupp">
<title>Problemas con tarjetas no soportadas </title>

<sect2 id="configurando">
<title>Configuración de tarjetas no reconocidas
</title>

<para>
Asumiendo que su tarjeta está soportada por algún controlador existente,
todo lo que se necesita hacer es añadir una entrada a
<literal remap="tt">/etc/pcmcia/config</literal> para decirle a <literal remap="tt">cardmgr</literal> cómo identificar
la tarjeta, y qué controlador(es) necesitan ser asociados a esta tarjeta. 
Consulte la página del manual de <literal remap="tt">pcmcia</literal> para más información acerca
del formato del archivo de configuración. Si inserta una tarjeta
desconocida, <literal remap="tt">cardmgr</literal> normalmente almacenará parte de información de
la identificación en el registro del sistema, lo cual puede usarse para
elaborar la entrada de configuración. Esta información puede mostrarse
también con el comando <literal remap="tt">cardctl ident</literal>. 
</para>

<para>
He aquí un ejemplo de cómo avisa <literal remap="tt">cardmgr</literal> de una tarjeta no soportada
en <literal remap="tt">/usr/adm/messages</literal>
</para>

<para>

<screen>
  cardmgr[460]: unsupported card in socket 1
  cardmgr[460]: product info: "MEGAHERTZ", "XJ2288", "V.34 PCMCIA MODEM"
  cardmgr[460]: manfid: 0x0101, 0x1234  function: 2 (serial)
</screen>

</para>

<para>
La entrada correspondiente en <literal remap="tt">/etc/pcmcia/config</literal> podría ser:
</para>

<para>

<screen>
       card "Megahertz XJ2288 V.34 Fax Modem"
         version "MEGAHERTZ", "XJ2288", "V.34 PCMCIA MODEM"
         bind "serial_cs"
</screen>

</para>

<para>
o usar los códigos de ID más compactos del producto:
</para>

<para>

<screen>
       card "Megahertz XJ2288 V.34 Fax Modem"
         manfid 0x0101, 0x1234
         bind "serial_cs"
</screen>

</para>

<para>
Puede usar <literal remap="tt">*</literal> para comparar cadenas que no necesiten concordar
exactamente, como los números de versión. Cuando haga nuevas entradas en
la configuración, hay que ser cuidadosos para copiar las cadenas
exactamente, preservando mayúsculas y minúsculas, y espacios en blanco.
Asegúrese también de que la entrada en la configuración tiene el mísmo
número de cadenas que aparecen en el archivo de registro.
</para>

<para>
Tenga en cuenta que puede especificar cualquier controlador para una
tarjeta, pero si sólo está dando palos de ciego, no hay mucha razón para
esperar que esto resulte productivo. Puede tener suerte y encontrar que su
tarjeta está soportada por un controlador existente. Sin embargo, el
resultado más probable es que el controlador no funcione, y puede tener
efectos laterales desafortunados como el congelamiento de su sistema. A
diferencia de la mayoría de los controladores de dispositivos, los cuales
comprueban la pressencia de la tarjeta apropiada, el sondeo para un
dispositivo PCMCIA se hace con <literal remap="tt">cardmgr</literal>, y el controlador por sí mismo
puede no verificar antes de intentar comunicarse con el dispositivo. 
</para>

<para>
Después de editar <literal remap="tt">/etc/pcmcia/config</literal>, envíe una señal a
<literal remap="tt">cardmgr</literal> para recargar el archivo con:
</para>

<para>

<screen>
       kill -HUP `cat /var/run/cardmgr.pid`
</screen>

</para>

<para>
Si configura una entrada para una tarjeta nueva, por favor, envíeme una
copia para que pueda incluirla en el archivo de configuración estándar.
</para>

</sect2>

<sect2 id="ne2000">
<title>Soporte para una tarjeta ethernet compatible con NE2000
</title>

<para>
Antes de empezar: este procedimiento sólo funcionará para tarjetas
ethernet simples. Las tarjetas multifunción (por ejemplo, las tarjetas
«combo» ethernet/módem) tienen una capa extra de complejidad en relación a
cómo están integradas las dos funciones, y generalmente no pueden
soportarse sin obtener algo de información de la configuración provista
por el fabricante de la tarjeta. Usar el procedimiento siguiente con una
tarjeta multifunción no resultará productivo en absoluto. 
</para>

<para>
Primero, compruebe si la tarjeta es reconocida por <literal remap="tt">cardmgr</literal>. Algunas
tarjetas que no están listadas en <literal remap="tt">SUPPORTED.CARDS</literal> son realmente
versiones OEM de tarjetas que sí están soportadas. Si encuentra una
tarjeta como ésta, hágamelo saber para que pueda añadirla a la lista. 
</para>

<para>
Si su tarjeta no es reconocida, siga las instrucciones en la sección <xref linkend="configurando"/> para
crear una entrada en la configuración para su tarjeta, y relacionar la
tarjeta con el controlador <literal remap="tt">pcnet_cs</literal>. Reinicie <literal remap="tt">cardmgr</literal> para
utilizar el archivo de configuración actualizado.
</para>

<para>
Si el controlador <literal remap="tt">pcnet_cs</literal> dice que no puede determinar la dirección
ethernet del hardware de la tarjeta, edite su nueva entrada en la
configuración para relacionar la tarjeta con el controlador de memoria
<literal remap="tt">memory_cs</literal>. Reinicie <literal remap="tt">cardmgr</literal> para utilizar el nuevo archivo de
configuración actualizado. Necesitará conocer la dirección ethernet del
hardware de la tarjeta. Esta dirección es una serie de seis números
hexadecimales de dos dígitos, impresos normalmente en la misma tarjeta. Si
no están impresos en la tarjeta, puede usar un controlador de DOS para
mostrar la dirección. En cualquier caso, una vez que la sepa, ejecute:
</para>

<para>

<screen>
       dd if=/dev/mem0a count=20 | od -Ax -t x1
</screen>

</para>

<para>
y busque el volcado de información de su tarjeta. Sólo los bytes pares
están definidos, así que ignore los bytes impares del volcado. Anote el
desplazamiento hexadecimal del primer byte de la dirección. Ahora, edite
<literal remap="tt">clients/pcnet_cs.c</literal> y busque la estructura <literal remap="tt">hw_info</literal>. 
Necesitará crear una nueva entrada para la tarjeta. El primer campo es el
desplazamiento de memoria. Los siguientes tres campos son los primeros
tres bytes de la dirección de hardware. El campo final contiene algunos
indicadores de características especiales de la tarjeta; para empezar,
pruebe estableciéndola a <literal remap="tt">0</literal>. 
</para>

<para>
Después de editar <literal remap="tt">pcnet_cs.c</literal>, compile e instale el nuevo módulo. 
Edite nuevamente <literal remap="tt">/etc/pcmcia/config/</literal>, y cambie la relación de
<literal remap="tt">memory_cs</literal> con <literal remap="tt">pcnet_cs</literal>. Siga las instrucciones para recargar el
archivo de configuración, y habrá terminado. Por favor mándeme copias de
sus nuevas entradas de configuración a <literal remap="tt">hw_info</literal>.
</para>

<para>
Si no puede encontrar la dirección hardware de su tarjeta en el vaciado
hexadecimal, como un último recurso, puede «forzar» la dirección cuando se
inicializa el módulo <literal remap="tt">pcnet_cs</literal>. Edite <literal remap="tt">/etc/pcmcia/config.opts</literal>
y añada una opción <literal remap="tt">hw_addr</literal>, como esta: 
</para>

<para>

<screen>
       module "pcnet_cs" opts "hw_addr=0x00,0x80,0xc8,0x01,0x02,0x03"
</screen>

</para>

<para>
Por supuesto, sustituya su propia dirección de hardware de la tarjeta en
el punto apropiado. Tenga en cuenta que si ha tenido que hacer esto, es
muy difícil que su tarjeta sea genuinamente compatible con NE2000. De
hecho, no estoy seguro de la existencia de tarjetas que no sean manejadas
por alguno de los dos primeros métodos. 
</para>

</sect2>

<sect2 id="floppy">
<title>Tarjetas PCMCIA para unidades de disquete </title>

<para>
La interfaz para disquete PCMCIA que se usa en los <emphasis remap="it">Compaq Aero</emphasis> y
otros equipos todavía no está soportada por este paquete. La dificultad
para soportar el disquete Aero radica en que el Aero parece usar un
controlador PCMCIA personalizado para soportar DMA en el disquete. Sin
saber exáctamente cómo se hace esto, no hay forma de implementar soporte
bajo Linux. 
</para>

<para>
Si la tarjeta del adaptador de disquete está presente cuando se inicia, la
BIOS configurará la tarjeta, y Linux la identificará como una unidad de
disquete normal. Cuando se cargan los controladores PCMCIA de Linux,
notarán que la tarjeta ya está configurada y conectada al controlador de
Linux, y este socket se dejará solo. Así que, la unidad puede usarse si
está presente al momento de iniciar, pero la tarjeta no se puede
intercambiar en caliente.
</para>

</sect2>

<sect2 id="xircom">
<title>¿Qué hay de las tarjetas Xircom? </title>

<para>
El paquete actual PCMCIA incluye un controlador para las tarjetas ethernet
y ethernet/modem de Xircom, gracias al trabajo de Werner Koch. He
dispuesto un foro especialmente para la discusión del desarrollo del
controlador Xircom, en <literal remap="tt"><ulink
url="http://hyper.stanford.edu/HyperNews/get/pcmcia/xircom.html"
>http://hyper.stanford.edu/HyperNews/get/pcmcia/xircom.html</ulink
></literal>. 
</para>

<para>
Durante mucho tiempo, las tarjetas Xircom no fueron soportadas porque
Xircom tenía como política de la compañía no divulgar información técnica
acerca de sus tarjetas. Sin embargo, han modificado sus reglas, y ahora,
distribuyen información de los controladores... 
</para>

</sect2>

</sect1>

<sect1 id="tips">
<title>Trucos para depurar e información de programación
</title>

<sect2 id="bugs">
<title>Envío de informes de <emphasis remap="it">bugs</emphasis> que son de utilidad </title>

<para>
La mejor forma de informar de <emphasis remap="it">bugs</emphasis> es usar las listas de mensajes de
HyperNews en el servidor web de Linux PCMCIA. De este modo, otras personas
podrán ver los problemas actuales (y reparaciones o trabajos relacionados,
si están disponibles). He aqui algunas cosas que se deben incluir en los
informes de <emphasis remap="it">bugs</emphasis>: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
El tipo de sistema, y la salida del comando <literal remap="tt">probe</literal>.

</para>
</listitem>
<listitem>

<para>
Qué tarjetas PCMCIA está usando.

</para>
</listitem>
<listitem>

<para>
Su versión del kernel de Linux, y la versión del controlador PCMCIA.

</para>
</listitem>
<listitem>

<para>
Cualquier cambio que haya hecho a los archivos de inicio en
<literal remap="tt">/etc/pcmcia</literal>, o al script de inicio de PCMCIA. 

</para>
</listitem>
<listitem>

<para>
Todos los mensajes relacionados con PCMCIA en el registro de su
sistema. 

</para>
</listitem>

</itemizedlist>

</para>

<para>
Todos los módulos PCMCIA y el demonio <literal remap="tt">cardmgr</literal> envían mensajes de
estado al registro del sistema, que estará normalmente en sitios como
<literal remap="tt">/var/log/messages</literal> o <literal remap="tt">/usr/adm/messages</literal>. Este archivo debe
ser el primer lugar a comprobar cuando se esté rastreando un problema.
Cuando envíe una notificación de bug, incluya siempre el contenido de este
archivo. Si tiene problemas para encontrar los mensajes de su sistema,
revise <literal remap="tt">/etc/syslog.conf</literal> para ver cuantas clases diferentes de
mensajes se manejan.
</para>

<para>
Antes de enviar una notificación de bug, por favor asegúrese que no esté
usando una copia obsoleta del paquete de controladores. Aunque resulte
gratificante leer informes sobre un bug que ya he reparado, no supone un
uso particularmente constructivo de mi tiempo. 
</para>

<para>
Si no tiene acceso a web, puede enviarme los informes de <emphasis remap="it">bugs</emphasis> a
<literal remap="tt"><ulink
url="mailto:dhinds@hyper.stanford.edu"
>dhinds@hyper.stanford.edu</ulink
></literal>. Sin embargo, prefiero que sean
introducidos en mi servidor web, así pueden ser vistos por otros. 
</para>

</sect2>

<sect2 id="trampas">
<title>Interpretación de los informes generados por los <emphasis remap="it">traps</emphasis> del kernel </title>

<para>
Si su problema incluye un fallo del kernel, el vaciado del registro del
fallo sólo es útil si puede traducir la dirección del error, EIP, o algo
semejante. Las versiones recientes de <literal remap="tt">klogd</literal> intentan traducir las
direcciones de fallos basándose en el mapa actual de símbolos del kernel,
pero puede que no funcione si el error se produce en un módulo, o si el
problema es lo bastante severo como para que que <literal remap="tt">klogd</literal> no pueda
terminar de escribir la información del fallo en el registro del sistema.
</para>

<para>
Si se localiza en el kernel principal, la dirección de fallo puede
encontrarse en el archivo <literal remap="tt">System.map</literal>. El cual puede estar instalado
en <literal remap="tt">/System.map</literal> o en <literal remap="tt">/boot/System.map</literal>. Si está en un
módulo, el comando <literal remap="tt">nm</literal> proporciona la misma información; sin embargo,
la dirección del fallo necesita ajustarse basándose en la dirección de
carga del módulo. Digamos que experimenta el siguiente fallo del kernel:
</para>

<para>

<screen>
       Unable to handle kernel NULL pointer dereference
       current-&#62;tss.cr3 = 014c9000, %cr3 = 014c9000
       *pde = 00000000
       Oops: 0002
       CPU:    0
       EIP:    0010:[&#60;c2026081&#62;]
       EFLAGS: 00010282
</screen>

</para>

<para>
La dirección de fallo es <literal remap="tt">0xc2026081</literal>. Si buscamos en <literal remap="tt">System.map</literal>,
vemos que esto está más allá de los límites del kernel, por ejemplo, es un
módulo del kernel. Para determinar qué módulo, revise la salida de
<literal remap="tt">ksyms -m | sort</literal>
</para>

<para>

<screen>
       Address   Symbol                            Defined by
       c200d000  (35k)                             [pcmcia_core]
       c200d10c  register_ss_entry                 [pcmcia_core]
       c200d230  unregister_ss_entry               [pcmcia_core]
                 ...
       c2026000  (9k)                              [3c574_cs]
       c202a000  (4k)                              [serial_cs]
</screen>

</para>

<para>
Así, <literal remap="tt">0xc2026081</literal> está en el módulo <literal remap="tt">3c574_cs</literal> con un desplazamiento
de <literal remap="tt">0x0081</literal> desde el inicio del módulo. Todavía no podemos ver más allá
de este desplazamiento en <literal remap="tt">3c574_cs.o</literal>: cuando el kernel carga un
módulo, inserta un encabezado en la dirección de carga del mismo, así el
inicio real se desplaza desde la dirección mostrada en <literal remap="tt">ksyms</literal>.  El
tamaño del encabezado varía con la versión del kernel:  para encontrar el
tamaño en su kernel, busque un módulo que exporte símbolos (como
<literal remap="tt">pcmcia_core</literal>), y compare la dirección del símbolo con la salida de
<literal remap="tt">nm</literal> para ese mismo símbolo. En este ejemplo, <literal remap="tt">register_ss_entry</literal> se
carga con un desplazamiento de <literal remap="tt">0xc200d10c - 0xc200d000 = 0x010c</literal>,
mientras que <literal remap="tt">nm pcmcia_core.o</literal> muestra el desplazamiento como
<literal remap="tt">0x00c0</literal>, así que el tamaño del encabezado es <literal remap="tt">0x010c - 0x00c0 =
0x004c</literal> bytes. 
</para>

<para>
Regresando a <literal remap="tt">3c574_cs.o</literal>, nuestro desplazamiento de fallo es
<literal remap="tt">0x0081</literal>, y restando el encabezado <literal remap="tt">0x004c</literal>, el desplazamiento real
del módulo es <literal remap="tt">0x0035</literal>. Ahora comprobando el resultado de un <literal remap="tt">nm
3c574_cs.o | sort</literal>, observamos: 
</para>

<para>

<screen>
  0000002c d if_names
  0000002c t tc574_attach
  00000040 d mii_preamble_required
  00000041 d dev_info
</screen>

</para>

<para>
El fallo se localiza en <literal remap="tt">tc574_attach()</literal>.
</para>

<para>
En este ejemplo, el fallo no causó un congelamiento total del sistema, así
que <literal remap="tt">ksyms</literal> puede ejecutarse después de haber tenido lugar el fallo. En
otros casos, puede que tenga que deducir indirectamente las direcciones de
carga del módulo. La misma secuencia de eventos cargará normalmente los
módulos en el mismo orden y en las mismas direcciones. Si se produce un
fallo cuando se inserta cierta tarjeta, obtenga la salida de <literal remap="tt">ksyms</literal>
antes de insertar la tarjeta, o con una tarjeta diferente insertada. Puede
cargar manualmente los módulos controladores de la tarjeta con <literal remap="tt">insmod</literal>
y ejecutar <literal remap="tt">ksyms</literal> antes de insertarla. 
</para>

<para>
Para profundizar, consulte <literal remap="tt">man insmod</literal>, <literal remap="tt">man ksyms</literal>, y <literal remap="tt">man
klogd</literal>. En el árbol de los fuentes del kernel,
<literal remap="tt">Documentation/oops-tracing.txt</literal> también es relevante. He aquí unas
cuantas pistas para depurar el kernel:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Dependiendo del error, puede ser útil traducir direcciones en el
<emphasis remap="it">Trazado de llamadas</emphasis>, usando el mismo procedimiento para la dirección
de error principal.

</para>
</listitem>
<listitem>

<para>
Para diagnosticar un congelamiento silencioso, pruebe provocar el
problema con X desactivado, porque los mensajes del kernel se envían a la
consola en texto, y no serán visibles bajo X. 

</para>
</listitem>
<listitem>

<para>
Si mata a <literal remap="tt">klogd</literal> muchos de los mensajes del kernel harán eco
directamente a la consola de texto, el cual puede ser útil si el problema
impide a <literal remap="tt">klogd</literal> escribir en el registro del sistema.

</para>
</listitem>
<listitem>

<para>
Para hacer que todos los mensajes del kernel se envíen a la consola,
para kernels <literal remap="tt">2.1.x</literal>, si existe <literal remap="tt">/proc/sys/kernel/printk</literal>,
hacer: 


<screen>
       echo 8 &#62; /proc/sys/kernel/printk
</screen>


</para>
</listitem>
<listitem>

<para>
La combinación de teclas <literal remap="tt">&lt;RightAlt&gt;&lt;ScrLk&gt;</literal> imprime
un vaciado del registro en la consola de texto. Esto puede funcionar en
caso de que el sistema esté o no completamente sin responder, y la
dirección EIP puede interpretarse como fallo del kernel.

</para>
</listitem>
<listitem>

<para>
Para los kernels <literal remap="tt">2.1.x</literal> configurados con <literal remap="tt">CONFIG_MAGIC_SYSRQ</literal>
activado, se pueden activar varias funciones de emergencia por medio de
las combinaciones especiales de las teclas <literal remap="tt">&lt;Alt&gt;&lt;SysRq&gt;</literal>,
que están documentadas en <literal remap="tt">Documentation/sysrq.txt</literal> dentro del
árbol de los fuentes del kernel. 

</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="aux">
<title>Primeros auxilios al depurar a bajo nivel </title>

<para>
Los módulos PCMCIA contienen bastante código de depuración compilado de
forma condicional. La mayor parte de este código está bajo el control de
las definiciones del preprocesador de <literal remap="tt">PCMCIA_DEBUG</literal>. Si no está
definido, el código de depuración no se compilará. Si se establece a
<literal remap="tt">0</literal>, se compilará pero no estará activo. Los números mayores
especifican el incremento del nivel de detalle del registro. Cada módulo
compilado con <literal remap="tt">PCMCIA_DEBUG</literal> definido tendrá un parámetro entero,
<literal remap="tt">pc_debug</literal>, que controla el nivel de detalle de su salida. Esto puede
ajustarse cuando se carga el módulo, así la salida puede controlarse en
base a cada módulo sin necesidad de recompilar. 
</para>

<para>
Su configuración por omisión para <literal remap="tt">syslogd</literal> puede descartar los
mensajes de depuración del kernel. Para asegurarse de que se están
registrando, edite <literal remap="tt">/etc/syslog.conf</literal> y compruebe que los mensajes
<literal remap="tt">kern.debug</literal> se registren en algún lugar. Consulte <literal remap="tt">man syslog.conf</literal>
para más detalles. 
</para>

<para>
Hay algunas herramientas de depuración en el subdirectorio
<literal remap="tt">debug_tools</literal> dentro de la distribución de PCMCIA. Las utilidades
<literal remap="tt">dump_tcic</literal> y <literal remap="tt">dump_i365</literal> generan volcados completos de los
controladores PCMCIA, y decodifican mucha de la información del registro. 
Son útiles si tiene acceso a una hoja con los datos del chip controlador
correspondiente. El comando <literal remap="tt">dump_cis</literal> (<literal remap="tt">dump_tuples</literal> en las
distribuciones <literal remap="tt">pre-3.0.2</literal>) lista el contenido de la CIS (<emphasis remap="it">Card
Information Structure</emphasis>) (Estructura de Información de Tarjeta), y
decodifica algunos bits importantes. <literal remap="tt">dump_cisreg</literal> muestra los
registros de configuración local de una tarjeta. 
</para>

<para>
El controlador de tarjetas de memoria <literal remap="tt">memory_cs</literal> a veces también es
útil para depurar problemas con PC Cards de 16 bits. Puede utilizarse con
cualquier tarjeta, y no interfiere con otros controladores. Puede usarse
para acceder directamente a los atributos de memoria o memoria común de
cualquier tarjeta. De igual modo, con las tarjetas <emphasis remap="it">CardBus</emphasis>, el
controlador <literal remap="tt">memory_cb</literal> puede utilizarse con cualquier tarjeta de 32
bits, para dar acceso directo a los espacios de direcciones de esa
tarjeta. Revise las páginas del manual para más información.
</para>

</sect2>

<sect2 id="pccard">
<title><literal remap="tt">/proc/bus/pccard</literal> </title>

<para>
A partir de los kernels <literal remap="tt">2.1.103</literal>, el paquete PCMCIA crea un árbol de
información de estado bajo <literal remap="tt">/proc/bus/pccard</literal>. La entrada
<literal remap="tt">memory</literal> muestra las posiciones de memoria para dispositivos PC Card en
un formato similar a <literal remap="tt">/proc/ioports</literal>. Cada socket tiene también su
propio subdirectorio de entradas de estado. La entrada <literal remap="tt">info</literal>
identifica el controlador del host y describe sus características. La
entrada <literal remap="tt">exca</literal> es un volcado del registro <literal remap="tt">ExCA</literal> compatible con
<emphasis remap="it">Intel i82365sl</emphasis> que se configura para ese socket. Para los puentes
<emphasis remap="it">CardBus</emphasis>, la entrada <literal remap="tt">pci</literal> es el volcado del espacio de la
configuración PCI del puente, y la entrada <literal remap="tt">cardbus</literal> es el vaciado de
los registros de configuración de <emphasis remap="it">CardBus</emphasis>.
</para>

</sect2>

<sect2 id="escribiendo">
<title>Programación de controladores de servicios PCMCIA para nuevas tarjetas
</title>

<para>
El <emphasis remap="it">Linux PCMCIA Programmer's Guide</emphasis> constituye la mejor documentación
acerca de la interfaz de los controladores. La última versión estará
siempre disponible en <literal remap="tt">hyper.stanford.edu</literal> en <literal remap="tt">/pub/pcmcia/doc</literal>,
o vía WWW en <literal remap="tt"><ulink
url="http://hyper.stanford.edu/HyperNews/get/pcmcia/home.html"
>http://hyper.stanford.edu/HyperNews/get/pcmcia/home.html</ulink
></literal>. 
</para>

<para>
Con los dispositivos relativamente similares a los dispositivos ISA
normales, probablemente pueda Vd. usar parcialmente controladores Linux
existentes. En algunos casos, el tropiezo más grande será modificar un
controlador existente que pueda manejar la inserción y extracción de
dispositivos después del momento de iniciar. De los controladores
actuales, el controlador de tarjeta de memoria es el único controlador
autónomo, que no depende de otras partes del kernel de Linux para hacer la
mayor parte del trabajo sucio. 
</para>

<para>
En muchos casos, el mayor impedimento para soportar un nuevo tipo de
tarjeta es el obtener información técnica por parte del fabricante. Puede
ser difícil el encontrar a quién preguntar, o a quien explicar que
información se necesita. Sin embargo, con pocas excepciones, es muy
difícil, si no imposible, el implementar un controlador para una tarjeta
sin información técnica por parte del fabricante.
</para>

<para>
He escrito un controlador modelo con muchos comentarios que explican
bastante cómo el controlador se comunica con los Servicios de Tarjetas; lo
encontrará en la distribución fuente de PCMCIA en
<literal remap="tt">clients/dummy_cs.c</literal>.
</para>

</sect2>

<sect2 id="sugerencias">
<title>Sugerencias para los autores de controladores PCMCIA
</title>

<para>
He decidido que no es realmente factible para mi el distribuir todos los
controladores de PCMCIA como parte del paquete PCMCIA. Cada controlador
nuevo hace que el paquete principal sea incrementalmente más dificil de
mantener, e incluir un controlador inevitablemente transfiere algo del
trabajo de mantenimiento del autor del controlador hacia mí. En lugar de
ello, decidiré caso por caso si se incluyen o no los controladores que
sean contribuciones, basándome en la demanda de los usuarios y también en
la facilidad de mantenerlos. Para los controladores que no se incluyen en
el paquete principal, sugiero que los autores de los controladores adopten
el esquema siguiente para empaquetar sus controladores de cara a su
distribución.
</para>

<para>
Los archivos controladores deben acomodarse en el mismo esquema del
directorio que utiliza la distribución fuente de PCMCIA, así el
controlador puede ser desempaquetado en la parte más alta del árbol de los
fuentes de PCMCIA. Debe incluir los archivos fuentes (en
<literal remap="tt">./modules/</literal>), una página del manual (en <literal remap="tt">./man/</literal>), y los
archivos de configuración (en <literal remap="tt">./etc/ </literal>). El directorio más alto
debe incluir también un archivo <literal remap="tt">README</literal>.
</para>

<para>
El directorio de más alto nivel debe incluir un <emphasis remap="it">makefile</emphasis>, configurado
para que <literal remap="tt">make -f ... all</literal> y <literal remap="tt">make -f ... install</literal> compilen el
controlador e instalen los archivos apropiados. Si este archivo tiene una
extensión <literal remap="tt">.mk</literal>, será invocado automáticamente por el <literal remap="tt">Makefile</literal> de
más alto nivel para los destinos <literal remap="tt">all</literal> e <literal remap="tt">install</literal>. He aquí un
ejemplo de cómo debe elaborarse un <literal remap="tt">Makefile</literal>:
</para>

<para>

<screen>
       # Un simple Makefile para un controlador de contribución
       FILES = sample_cs.mk README.sample_cs \
               modules/sample_cs.c modules/sample_cs.h \
               etc/sample etc/sample.opts man/sample_cs.4
       all:
               $(MAKE) -C modules MODULES=sample_cs.o
       install:
               $(MAKE) -C modules install-modules MODULES=sample_cs.o
               $(MAKE) -C etc install-clients CLIENTS=sample
               $(MAKE) -C man install-man4 MAN4=sample_cs.4
       dist:
               tar czvf sample_cs.tar.gz $(FILES)
</screen>

</para>

<para>
Este <literal remap="tt">Makefile</literal> usa los destinos de instalación que se definen en la
versión <literal remap="tt">2.9.10</literal> y versiones posteriores del paquete PCMCIA. Este
makefile también incluye un destino <literal remap="tt">dist</literal> para conveniencia del autor
del controlador.  Probablemente desee añadir un número de versión al final
del nombre del paquete (por ejemplo, <literal remap="tt">sample_cs-1.5.tar.gz</literal>). Una
distribución completa puede ser similar a: 
</para>

<para>

<screen>
       sample_cs.mk
       README.sample_cs
       modules/sample_cs.c
       modules/sample_cs.h
       etc/sample
       etc/sample.opts
       man/sample_cs.4
</screen>

</para>

<para>
De esta forma, cuando un controlador de contribución se desempaquete, se
convierte en parte esencial del árbol de los fuentes de PCMCIA. Puede
hacer uso de los archivos de encabezados de PCMCIA, así como también de la
maquinaria para comprobar la configuración del sistema del usuario, y
chequeo automático de dependencias, tal y como un controlador «normal». 
</para>

<para>
Aceptaré controladores preparados de acuerdo a esta especificación y los
colocaré en el directorio <literal remap="tt">/etc/pcmcia/contrib</literal> en mi servidor FTP,
<literal remap="tt">hyper.stanford.edu</literal>. El archivo <literal remap="tt">README</literal> en este directorio
describirá cómo desempaquetar un controlador de contribución.
</para>

<para>
La interface de controlador no ha cambiado mucho a pesar del tiempo, y ha
preservado casi siempre su compatibilidad con las versiones anteriores. Un
controlador normalmente no necesitará actualizarse para revisiones menores
en el paquete principal. Trataré de notificar a los autores de los
controladores «externos» de los cambios que se requiera realizar a sus
controladores.
</para>

</sect2>

<sect2 id="encargados">
<title>Sugerencias para encargados de las distribuciones de Linux
</title>

<para>
Si su distribución tiene herramientas para configuración del sistema que
quiera que sean compatibles PCMCIA, por favor, use los archivos
<literal remap="tt">*.opts</literal> en <literal remap="tt">/etc/pcmcia</literal> para su «integración». Dichos archivos
no serán modificados si un usuario compila e instala una nueva versión del
paquete PCMCIA. Si modifica los scripts principales de configuración, una
instalación fresca sobreescribirá silenciosamente sus scripts
personalizados y romperá la conexión con sus herramientas de
configuración. Contacte conmigo si no está seguro de cómo escribir un
script de opciones apropiado, o si necesita características adicionales.
</para>

<para>
Resulta muy útil para los usuarios (y para mi) que documente cómo deriva
su distribución del paquete PCMCIA que se describe en este documento. En
particular, por favor documente los cambios al script de inicio y a los
scripts de configuración. Si me manda la información apropiada, la
incluiré en la sección <xref linkend="distribuciones"/>.
</para>

<para>
Cuando construya una distribución PCMCIA, considere el incluir los
controladores aportados, que no son parte del paquete PCMCIA principal. 
Por razones de mantenimiento, estoy tratando de limitar el tamaño del
paquete principal, añadiendo solamente controladores nuevos si considero
que son de interés general. Los demás controladores se distribuirán por
separado, como se describe en la sección anterior. La división entre
controladores generales y separados es algo arbitraria y en parte
histórica, y no debería implicar diferencia alguna en cuanto a calidad. 
</para>

</sect2>

</sect1>

<sect1 id="Insflug">
<title>Anexo: El INSFLUG </title>

<para>
El <emphasis remap="it">INSFLUG</emphasis> forma parte del grupo internacional <emphasis remap="it">Linux Documentation
Project</emphasis>, encargándose de las traducciones al castellano de los Howtos,
así como de la producción de documentos originales en aquellos casos en los
que no existe análogo en inglés, centrándose, preferentemente, en documentos
breves, como los <emphasis>COMOs</emphasis> y <emphasis>PUFs</emphasis> (<emphasis remap="bf">P</emphasis>reguntas de <emphasis remap="bf">U</emphasis>so
<emphasis remap="bf">F</emphasis>recuente, las <emphasis remap="it">FAQs</emphasis>. <literal remap="tt">:)</literal> ), etc.
</para>

<para>
Diríjase a la sede del Insflug para más información al respecto.
</para>

<para>
En élla encontrará siempre las <emphasis remap="bf">últimas</emphasis> versiones de las traducciones
«oficiales»:  <literal remap="tt"><ulink
url="http://www.insflug.org"
>www.insflug.org</ulink
></literal>. Asegúrese de comprobar cuál es la última
versión disponible en el Insflug antes de bajar un documento de un
servidor réplica. 
</para>

<para>
Además, cuenta con un sistema interactivo de gestión de fe de erratas y
sugerencias en línea, motor de búsqueda específico, y más servicios en los
que estamos trabajando incesantemente.
</para>

<para>
Se proporciona también una lista de los servidores réplica (<emphasis remap="it">mirror</emphasis>)
del Insflug más cercanos a Vd., e información relativa a otros recursos en
castellano.
</para>

<para>
En <literal remap="tt"><ulink
url="http://www.insflug.org/insflug/creditos.php3"
>http://www.insflug.org/insflug/creditos.php3</ulink
></literal> cuenta con una
detallada relación de las personas que hacen posible tanto esto como las
traducciones.
</para>

<para>
¡Diríjase a <literal remap="tt"><ulink
url="http://www.insflug.org/colaboracion/index.php3"
>http://www.insflug.org/colaboracion/index.php3</ulink
></literal> si desea
unirse a nosotros!.
</para>

<para>
«Cartel» Insflug, <literal remap="tt"><ulink
url="mailto:cartel@insflug.org"
>cartel@insflug.org</ulink
></literal>. 
</para>

</sect1>

</article>
