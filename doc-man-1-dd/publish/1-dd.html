<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>DD</title><meta name="generator" content="DocBook XSL Stylesheets V1.66.1"><link rel="start" href="index.html" title="DD"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">DD</th></tr></table><hr></div><div class="refentry" lang="en"><a name="dd1"></a><div class="titlepage"></div><div class="refnamediv"><a name="name"></a><h2>Name</h2><p>dd — convertir y copiar un fichero</p></div><div class="refsynopsisdiv"><a name="synopsis"></a><h2>Synopsis</h2><div class="cmdsynopsis"><p><tt class="command">dd</tt>  [--help] [--version] [<i class="replaceable"><tt>if=fichero</tt></i>] [<i class="replaceable"><tt>of=fichero</tt></i>] [<i class="replaceable"><tt>ibs=bytes</tt></i>] [<i class="replaceable"><tt>obs=bytes</tt></i>] [<i class="replaceable"><tt>bs=bytes</tt></i>] [<i class="replaceable"><tt>cbs=bytes</tt></i>] [<i class="replaceable"><tt>skip=bloques</tt></i>] [<i class="replaceable"><tt>seek=bloques</tt></i>] [<i class="replaceable"><tt>count=bloques</tt></i>] [ <i class="replaceable"><tt>conv=</tt></i>  [<i class="replaceable"><tt>ascii,ebcdic,ibm,block,unblock,lcase,ucase,swab,noerror,notrunc,sync</tt></i>]]</p></div></div><div class="refsect1" lang="en"><a name="description"></a><h2>DESCRIPCIÓN</h2><p><span><b class="command">dd</b></span> copia un fichero (de la entrada estándar a la salida estándar, por omisión) con un tamaño de bloque seleccionable por el usuario, a la par que, opcionalmente, realiza sobre él ciertas conversiones.</p><p>Lee la entrada un bloque cada vez, usando el tamaño de bloque de entrada especificado (el valor predeterminado es 512 bytes). Si se dio la opción <span class="emphasis"><em>bs=</em></span><span class="emphasis"><em>bytes</em></span> y no se especificó otra conversión aparte de <span class="emphasis"><em>sync</em></span>, <span class="emphasis"><em>noerror</em></span>, o  <span class="emphasis"><em>notrunc</em></span>, escribe la cantidad de datos leídos (que puede ser menor que la solicitada) en un bloque de salida separado. Este bloque de salida tiene precisamente la misma longitud que fue leída a menos que se especificara la conversión <span class="emphasis"><em>sync</em></span>, en cuyo caso, los datos se rellenan con NULos (o espacios, véase debajo).</p><p>De otro modo, la entrada, leída un bloque de cada vez, se procesa t la salida resultante es recogida y escrita en bloques del tamaño de bloque de salida especificado. El último bloque de salida puede ser más corto.</p><p>Las opciones de más abajo con valores numéricos (bytes y bloques) pueden ir seguidas por un factor multiplicador: ‘k’=1024, ‘b’=512, ‘w’=2, ‘c’=1 (‘w’ y ‘c’ son extensiones de GNU; ‘w’ nunca debería utilizarse: significa 2 en System V y 4 en 4.2BSD). Dos o más de tales expresiones numéricas pueden multiplicarse poniendo una ‘x’ (equis minúscula) entre ellas. La versión fileutils‐4.0 de GNU también permite los siguientes sufijos multiplicativos al especificar tamaños de bloque (en bs=, cbs=, ibs=, obs=): M=1048576, G=1073741824, y así para T, P, E, Z, Y. Un sufijo ‘D’ los convierte en decimal: kD=1000, MD=1000000, GD=1000000000, etc. (Dese cuenta que para ls, df, du, el tamaño de M, etc., viene determinado por variables de entorno, pero para dd es fijo.)</p></div><div class="refsect1" lang="en"><a name="options"></a><h2>OPCIONES</h2><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>if= </em></span><span class="emphasis"><em>fichero</em></span></span></dt><dd><p>Lee desde <span class="emphasis"><em>fichero</em></span> en lugar de desde la entrada estándar.</p></dd><dt><span class="term"><span class="emphasis"><em>of=</em></span><span class="emphasis"><em>fichero</em></span></span></dt><dd><p>Write to
<span class="emphasis"><em>file</em></span>
instead of standard output.  Unless
<span class="emphasis"><em>conv=notrunc</em></span>
is given,
<span><b class="command">dd</b></span>
truncates
<span class="emphasis"><em>file</em></span>
to zero bytes (or the size specified with
<span class="emphasis"><em>seek=</em></span>).</p></dd><dt><span class="term"><span class="emphasis"><em>ibs=</em></span><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>Lee <span class="emphasis"><em>bytes</em></span> bytes de una vez. El valor predeterminado es 512.</p></dd><dt><span class="term"><span class="emphasis"><em>obs=</em></span><span class="emphasis"><em>bytes</em></span></span></dt><dd><p> Escribe <span class="emphasis"><em>bytes</em></span> bytes de una vez. El valor predeterminado es 512.</p></dd><dt><span class="term"><span class="emphasis"><em>bs=</em></span><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>Lee y escribe <span class="emphasis"><em>bytes</em></span> bytes cada vez. Esto sustituye a <span class="emphasis"><em>ibs</em></span> y <span class="emphasis"><em>obs</em></span>. (Y poner <span class="emphasis"><em>bs</em></span> no es equivalente a poner <span class="emphasis"><em>ibs</em></span> y <span class="emphasis"><em>obs</em></span> al mismo valor, al menos si no se ha especificado una conversión aparte de <span class="emphasis"><em>sync</em></span>, <span class="emphasis"><em>noerror</em></span> y <span class="emphasis"><em>notrunc</em></span>, puesto que se estipula que cada bloque de entrada será copiado en la salida como un único bloque, sin agregar bloques cortos.)</p></dd><dt><span class="term"><span class="emphasis"><em>cbs=</em></span><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>Especifica el tamaño de bloque de conversión para <span class="emphasis"><em>block</em></span> y <span class="emphasis"><em>unblock</em></span>.</p></dd><dt><span class="term"><span class="emphasis"><em>skip=</em></span><span class="emphasis"><em>bloques</em></span></span></dt><dd><p>Salta <span class="emphasis"><em>bloques</em></span> bloques de tamaño en bytes determinado por <span class="emphasis"><em>ibs</em></span> del fichero de entrada antes de la copia.</p></dd><dt><span class="term"><span class="emphasis"><em>seek=</em></span><span class="emphasis"><em>bloques</em></span></span></dt><dd><p>Salta <span class="emphasis"><em>bloques</em></span> bloques de tamaño en bytes determinado por <span class="emphasis"><em>obs</em></span> en el fichero de salida antes de la copia.</p></dd><dt><span class="term"><span class="emphasis"><em>count=</em></span><span class="emphasis"><em>bloques</em></span></span></dt><dd><p>Copia <span class="emphasis"><em>bloques</em></span> bloques de tamaño en bytes determinado por <span class="emphasis"><em>ibs</em></span> del fichero de entrada, en vez de todo hasta el final del fichero.</p></dd><dt><span class="term"><span class="emphasis"><em>conv=</em></span><span class="emphasis"><em>CONVERSIÓN</em></span><span class="emphasis"><em>[,</em></span><span class="emphasis"><em>CONVERSIÓN</em></span><span class="emphasis"><em>]...</em></span></span></dt><dd><p>Convierte el fichero según se haya especificado en el o los argumentos <span class="emphasis"><em>CONVERSIÓN</em></span>. (No se permite ningún espacio al lado de ninguna coma.)</p><p>Conversiones:</p><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ascii</em></span></span></dt><dd><p>Convierte EBCDIC a ASCII.</p></dd><dt><span class="term"><span class="emphasis"><em>ebcdic</em></span></span></dt><dd><p>Convierte ASCII a EBCDIC.</p></dd><dt><span class="term"><span class="emphasis"><em>ibm</em></span></span></dt><dd><p>Convierte ASCII a un EBCDIC alternativo.</p></dd><dt><span class="term"><span class="emphasis"><em>block</em></span></span></dt><dd><p>Para cada línea de la entrada, saca <span class="emphasis"><em>cbs</em></span> bytes, reemplazando el salto de línea de la entrada con un espacio y rellenando con más espacios si fuera necesario.</p></dd><dt><span class="term"><span class="emphasis"><em>unblock</em></span></span></dt><dd><p>Reemplaza espacios del final en cada bloque de entrada de tamaño determinado por <span class="emphasis"><em>cbs</em></span> por un salto de línea.</p></dd><dt><span class="term"><span class="emphasis"><em>lcase</em></span></span></dt><dd><p>Cambia las letras mayúsculas por minúsculas.</p></dd><dt><span class="term"><span class="emphasis"><em>ucase</em></span></span></dt><dd><p>Cambia las letras minúsculas por mayúsculas.</p></dd><dt><span class="term"><span class="emphasis"><em>swab</em></span></span></dt><dd><p>Intercambia cada par de bytes de la entrada. Si se lee un número impar de bytes el último byte se copia tal cual (ya que no tiene con quién intercambiarse). [POSIX 1003.2b, PASC interpretaciones 1003.2 nº 3 y nº 4]</p></dd><dt><span class="term"><span class="emphasis"><em>noerror</em></span></span></dt><dd><p>Continúa despues de producirse errores de lectura.</p></dd><dt><span class="term"><span class="emphasis"><em>notrunc</em></span></span></dt><dd><p>No trunca el fichero de salida.</p></dd><dt><span class="term"><span class="emphasis"><em>sync</em></span></span></dt><dd><p>Rellena cada bloque de entrada hasta el tamaño determinado por <span class="emphasis"><em>ibs</em></span> con bytes cero al final.</p></dd></dl></div></dd></dl></div></div><div class="refsect1" lang="en"><a name="gnu_standard_options"></a><h2>OPCIONES ESTÁNDAR DE GNU</h2><div class="variablelist"><dl><dt><span class="term"><tt class="option">--help</tt></span></dt><dd><p>Muestra un mensaje en la salida estándar sobre el modo de empleo y acaba con código de éxito.</p></dd><dt><span class="term"><tt class="option">--version</tt></span></dt><dd><p>Muestra en la salida estándar información sobre la versión y luego acaba con código de éxito.</p></dd><dt><span class="term"><tt class="option">--</tt></span></dt><dd><p>Termina la lista de opciones.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="environment"></a><h2>ENTORNO</h2><p>Las variables LANG, LC_ALL, LC_TYPE y LC_MESSAGES tienen el significado habitual.</p></div><div class="refsect1" lang="en"><a name="conforming_to"></a><h2>CONFORME A</h2><p>POSIX 1003.2</p></div><div class="refsect1" lang="en"><a name="example"></a><h2>EJEMPLO</h2><p>A menudo, una unidad de cinta no aceptará bloques de tamaño arbitrario y <span><b class="command">dd</b></span> obtendrá un error de E/S en el último fragmento de datos que no ocupe un bloque entero. Use ‘dd if=mifichero of=/dev/miunidaddecinta conv=sync’ para asegurarse de que todo se ha grabado en la cinta. Naturalmente, leerla de nuevo producirá ahora un fichero ligeramente más grande, con caracteres nulos añadidos al final.</p></div><div class="refsect1" lang="en"><a name="bugs"></a><h2>ERRORES</h2><p>Comandos como `dd if=mifichero of=/dev/fd0 bs=1k seek=172' fallan en algunos sistemas porque <span><b class="command">dd</b></span> intenta truncar el fichero de salida, pero el truncado de un dispositivo de bloques no es posible. En dichos casos, añádase la opción `conv=notrunc'.</p></div><div class="refsect1" lang="en"><a name="notes"></a><h2>NOTAS</h2><p>Esta página describe <span><b class="command">dd</b></span> como se encuentra en el paquete fileutils-4.0; otras versiones pueden diferir ligeramente.</p></div></div><div class="navfooter"><hr></div></body></html>
