\chapter{Linux}
\section{Introducci\'on}
A mediados de 1991 un estudiante finland\'es llamado Linus Torvalds trabajaba
en el dise\~no de un sistema operativo similar a Minix, que pudiera ejecutarse 
sobre plataformas Intel y compatibles, y sobre todo que fuera peque\~no y 
barato; a ra\'{\i}z de un mensaje de este estudiante en {\tt comp.os.minix}, 
algunas personas comenzaron a interesarse por el proyecto, y finalmente el 5 de 
octubre de ese a\~no Linus Torvals hizo p\'ublica la versi\'on 0.02 -- la 
primera funcional -- de lo que ya se denominaba Linux ({\it Linus\'{} Unix}). En
esa versi\'on, que aproximadamente utilizaron un centenar de usuarios, apenas
se ofrec\'{\i}a soporte a {\it hardware} (excepto el que Linus ten\'{\i}a en
su ordenador), no dispon\'{\i}a de subsistema de red ni de sistema de ficheros
propio, y las utilidades de espacio de usuario se pod\'{\i}an contar con 
los dedos de las manos (un {\it shell}, un compilador, y poco m\'as). Sin 
embargo, y a pesar de las duras cr\'{\i}ticas de pesos pesados en el mundo de 
los sistemas operativos como Andrew Tanenbaum, el proyecto era muy interesante, 
y poco a poco programadores de todo el mundo fueron aportando mejoras a este 
nuevo sistema.\\
\\A principios de 1994 apareci\'o Linux 1.0, considerada la primera versi\'on
del operativo utilizable no s\'olo por {\it hackers} y programadores, sino por
usuarios `normales'; de las aproximadamente 10000 l\'{\i}neas de la versi\'on
inicial se hab\'{\i}a pasado a unas 170000, y el centenar de usuarios se 
hab\'{\i}a multiplicado por mil. Linux 1.0 incorporaba subsistema de red (sin
duda uno de los cambios que m\'as ha contribuido a la expansi\'on del 
operativo), entorno gr\'afico (arrastrado de versiones anteriores) y soporte a
una gama de {\it hardware} relativamente amplia. La popularidad del operativo
crec\'{\i}a mes a mes -- especialmente en entornos universitarios y de 
investigaci\'on -- gracias sobre todo a su filosof\'{\i}a: cualquiera 
pod\'{\i}a (y puede) modificar una parte del n\'ucleo, adaptarla, mejorarla, o
incorporar nuevas l\'{\i}neas, con la \'unica obligaci\'on de compartir el nuevo
c\'odigo fuente con el resto del mundo.\\
\\Sin embargo, no fu\'e hasta 1996, con la aparici\'on de Linux 2.0 (que 
incorporaba casi medio mill\'on de l\'{\i}neas de c\'odigo), cuando se produjo
el gran {\it boom} de Linux que perdura hasta la actualidad. Esta nueva 
versi\'on convert\'{\i}a a Linux en un sistema libre que, en algunos aspectos, 
no ten\'{\i}a nada que envidiar a entornos Unix comerciales; m\'as de un 
mill\'on de usuarios contribu\'{\i}an sin descanso a mejorar el sistema, y 
quiz\'as por primera vez la arquitectura PC no era un mercado reservado casi en
exclusiva a Microsoft. Muchas personas vieron que Linux pod\'{\i}a llegar a ser 
rentable (a pesar de su filosof\'{\i}a {\it free}), y se comenz\'o a trabajar 
mucho en la facilidad de instalaci\'on y manejo para usuarios sin elevados 
conocimientos de inform\'atica; incluso llegaba a desbancar en muchas ocasiones
al inamovible Minix a la hora de estudiar dise\~no de sistemas operativos en las
universidades (algo poco comprensible, por otra parte, ya que cualquiera que 
le haya pegado un vistazo al c\'odigo del {\it kernel} de Linux podr\'a 
comprobar que a diferencia de Minix no est\'a dise\~nado para ser legible y
did\'actico, sino para ser r\'apido).\\
\\En la actualidad Linux cuenta con varios millones de usuarios, y se ha 
convertido en el Unix m\'as {\it user--friendly} de todos los existentes, ya que
no hacen falta conocimientos avanzados para instalarlo y manejarlo 
m\'{\i}nimamente; reconoce multitud de {\it hardware} (algo que siempre ayuda
en el mercado de los ordenadores de sobremesa), y se puede utilizar para 
funciones tan diversas como servidores {\it web}, de bases de datos, de correo
electr\'onico, o como una sencilla {\it workstation}. En muchas empresas 
medianas y peque\~nas ha desplazado por completo a los sistemas Unix 
comerciales (caros y que generalmente corren sobre {\it hardware} que tampoco 
es barato), e incluso en grandes servidores se utiliza Linux como sistema 
operativo; aunque -- y esto es una cr\'{\i}tica, por si no queda claro -- en
algunas ocasiones se echan de menos mecanismos de seguridad que s\'{\i} est\'an
disponibles en otros Unices, podemos decir que Linux proporciona un nivel de
seguridad, fiabilidad y estabilidad adecuado a la mayor parte de aplicaciones
gen\'ericas que nos podamos imaginar (es decir, no es un operativo apto para
controlar una central nuclear, pero s\'{\i} para cualquier aplicaci\'on de
criticidad baja o media que podamos utilizar d\'{\i}a a d\'{\i}a).\\
\\Al igual que hemos hecho en el cap\'{\i}tulo anterior con Solaris, vamos a
hablar en este de aspectos de seguridad espec\'{\i}ficos de Linux, aunque como
siempre lo que hemos comentado para Unix en general es casi siempre aplicable a
este clon. Sobre temas propios de Linux podemos obtener informaci\'on adicional 
y gratuita a trav\'es de Internet, en cualquier documento del proyecto LDP 
({\it Linux Documentation Project}); tambi\'en existen numerosos libros sobre
aspectos espec\'{\i}ficos de este operativo, desde la implementaci\'on de su
n\'ucleo (\cite{kn:bec96}, \cite{kn:car97}\ldots) hasta su seguridad 
(\cite{kn:tox00}, \cite{kn:ano01}\ldots), pasando por supuesto por temas de 
administraci\'on gen\'erica (\cite{kn:ha99}, \cite{kn:bal00}\ldots).
\section{Seguridad f\'{\i}sica en x86}
Si cuando hemos hablado de Solaris hac\'{\i}amos referencia al nivel de
seguridad m\'as bajo que ofrece una m\'aquina {\sc sparc}, el correspondiente a
su {\sc eeprom}, parece obligatorio comentar, en el cap\'{\i}tulo dedicado a
Linux, de la seguridad de m\'as bajo nivel que ofrece este operativo 
ejecut\'andose sobre su principal plataforma: el PC.\\
\\Cuando arranca un ordenador personal se ejecuta un {\it software} denominado 
{\sc bios} ({\it Basic I/O System}) cuya funci\'on principal es determinar una 
serie de par\'ametros de la m\'aquina y proporcionar un sistema b\'asico de 
control de dispositivos, como el teclado o los puertos de comunicaciones; este
{\it software} se aloja t\'{\i}picamente en una memoria {\sc rom} ({\it 
Read--Only Memory}) o {\it flash} (estos \'ultimos permiten actualizar la 
versi\'on de la {\sc bios} sin necesidad de cambiar el {\it chip} 
correspondiente), de forma que se permita autoarrancar a la m\'aquina aunque 
el subsistema de almacenamiento tenga problemas y no se pueda iniciar el 
operativo. En el arranque de un PC se puede acceder a la configuraci\'on de
su {\sc bios} mediante la pulsaci\'on de una tecla o una secuencia de escape 
dependiente de cada modelo de {\it chip}; desde ese entorno de configuraci\'on 
se pueden asignar par\'ametros como la fecha y hora del sistema, la 
arquitectura de los discos duros, o la habilitaci\'on de memorias cach\'e. Por 
supuesto, la {\sc bios} de un PC es completamente independiente del operativo 
que se arranque despu\'es; esto implica que cuando a continuaci\'on comentemos 
la protecci\'on que ofrece una {\sc bios}, lo que digamos ser\'a aplicable {\bf 
sin importar qu\'e operativo se ejecute} en la m\'aquina: servir\'a tanto para 
Linux como para Solaris, FreeBSD, NetBSD\ldots e incluso para las diferentes 
versiones de Windows. Si lo comentamos en este cap\'{\i}tulo dedicado a Linux
y no en otro, es \'unicamente porque la mayor parte de plataformas sobre las
que se ejecuta este operativo son ordenadores personales.\\
\\Generalmente la mayor parte de las {\sc bios} ofrecen la posibilidad de 
establecer dos contrase\~nas independientes. La primera de ellas es una clave
que evita a usuarios que no la conozcan acceder a la configuraci\'on de la {\sc
bios}, ya que se solicitar\'a al pulsar la secuencia de escape de la que hemos 
hablado antes para entrar en el entorno de configuraci\'on durante el arranque
de una m\'aquina. El esquema de esta contrase\~na en muchas ocasiones no es 
todo lo robusto que debiera, y en funci\'on del modelo y versi\'on de cada
{\it chip} de memoria -- especialmente en los m\'as antiguos -- es posible que 
incluso se pueda romper ejecutando un simple programa desde l\'{\i}nea de 
\'ordenes; a pesar de ello, puede ser \'util en entornos de muy baja seguridad
para prevenir que cualquiera se dedique a cambiar la configuraci\'on de la {\sc 
bios}, pero m\'as por comodidad (el administrador de la m\'aquina deber\'{\i}a
restaurar dicha configuraci\'on de nuevo, algo bastante molesto sobre todo si
el n\'umero de ordenadores es elevado, como en un laboratorio o un aula) que
por seguridad.\\
\\La segunda de estas claves ofrece un nivel de protecci\'on algo m\'as elevado;
se trata de una contrase\~na que evita el arranque del PC sin que se teclee el
{\it password} (en local, por supuesto, recordemos que el operativo a\'un no se
ha inicializado). Con ella se consigue que nadie que no conozca la clave pueda
arrancar un ordenador, pero una vez arrancado no sirve para nada m\'as; puede
ser \'util para evitar que usuarios no autorizados puedan sentarse delante de
una m\'aquina y arrancar desde un {\it diskette}, aunque seguramente una
soluci\'on menos agresiva es configurar la {\sc bios} para que s\'olo arranque
desde disco duro, o al menos no trate de hacerlo desde {\it floppy} antes que
desde el disco primario. No obstante, poner una contrase\~na para arrancar el
sistema, como muchas medidas de seguridad, puede tener efectos negativos en la 
funcionalidad o en la comodidad de administraci\'on: no podremos realizar 
{\it reboots} autom\'aticos ni remotos de Unix, ya que cada vez que el sistema 
reinicie alguien deber\'a estar f\'{\i}sicamente al lado de la m\'aquina para 
teclear la clave correspondiente.\\
\\Antes de finalizar este punto dedicado a la seguridad f\'{\i}sica dentro de
Linux debemos hablar de la protecci\'on ofrecida por {\sc lilo}; ahora ya no
se trata de algo gen\'erico de los PCs, sino de mecanismos implantados en el
cargador de Linux que s\'olo son aplicables a sistemas arrancados desde dicho 
cargador. {\sc lilo} ({\it LInux LOader}) es un {\it software} que se instala
en un sector de arranque -- de una partici\'on o de un {\it diskette} -- o en 
el {\it Master Boot Record} ({\sc mbr}) del disco duro y que permite de esta
forma arrancar tanto Linux como otros sistemas operativos instalados en el PC.\\
\\{\sc lilo} toma su configuraci\'on del archivo {\tt /etc/lilo.conf} del 
sistema Linux; cada vez que modifiquemos ese archivo ser\'a necesario ejecutar
la orden {\tt /sbin/lilo} si queremos que los cambios tengan efecto en el
siguiente encendido de la m\'aquina:
\begin{quote}
\begin{verbatim}
luisa:~# /sbin/lilo
Added linux *
luisa:~# 
\end{verbatim}
\end{quote}
Al arrancar el PC, {\sc lilo} permite elegir una imagen para ser arrancada, 
as\'{\i} como especificar pa\-r\'a\-me\-tros para el n\'ucleo; aunque esto sea
necesario para inicializar el sistema en ciertas ocasiones -- principalmente
cuando hay errores graves en un arranque normal --, el hecho es que los 
par\'ametros pasados a un {\it kernel} antes de ser arrancado pueden facilitar
a un atacante un control total sobre la m\'aquina, ya que algunos de ellos
llegan incluso a ejecutar un {\it shell} con privilegios de {\tt root} sin 
necesidad de ninguna contrase\~na.\\
\\En determinadas ocasiones, quiz\'as nos interese proteger el arranque de una
m\'aquina, tanto a nivel de la elecci\'on de n\'ucleo a arrancar como a nivel
de las opciones que se pasan a dicho n\'ucleo. Podemos habilitar desde {\sc
lilo} el uso de una contrase\~na que se solicitar\'a antes de que {\sc lilo} 
cargue cualquier sistema operativo instalado en el ordenador; para ello debemos
hacer uso de la directiva {\tt `password'} en {\tt /etc/lilo.conf}:
\begin{quote}
\begin{verbatim}
luisa:~# cat /etc/lilo.conf
boot = /dev/hda
delay = 50
vga = normal
password = P,e+bqa
image = /vmlinuz
  root = /dev/hda1
  label = linux
  read-only 
luisa:~#
\end{verbatim}
\end{quote}
Tras ejecutar {\tt /sbin/lilo}, en el siguiente arranque de la m\'aquina se
solicitar\'a la contrase\~na especificada antes de arrancar cualquier sistema
operativo; es importante que {\tt /etc/lilo.conf} tenga un permiso de lectura
s\'olo para el {\tt root}, ya que como podemos ver contiene contrase\~nas sin
cifrar.\\
\\Evidentemente, si elegimos este tipo de protecci\'on nos podemos olvidar de
cualquier cosa que implique un reinicio autom\'atico del ordenador, ya que
como acabamos de decir {\bf siempre} se solicitar\'a una clave en el arranque;
podemos relajar esta restricci\'on de una forma muy \'util: forzando el uso de 
un {\it password} {\bf s\'olo} si se especifican par\'ametros adicionales para 
el n\'ucleo que se quiere arrancar. Esto permite un equilibrio m\'as que 
razonable entre seguridad y usabilidad, ya que cualquiera -- con los 
privilegios necesarios -- puede reiniciar el sistema, e incluso se pueden 
programar rearranques autom\'aticos, pero siempre ser\'a necesaria una clave si 
alguien desea especificar par\'ametros adicionales al {\it kernel}.\\
\\Para conseguir esto utilizaremos la directiva {\tt `restricted'} en
conjunci\'on con {\tt `password'} en el archivo de configuraci\'on de {\sc 
lilo}; bas\'andonos en el ejemplo anterior, el contenido del nuevo fichero 
ser\'{\i}a el siguiente:
\begin{quote}
\begin{verbatim}
luisa:~# cat /etc/lilo.conf
boot = /dev/hda
delay = 50
vga = normal
password = P,e+bqa
restricted
image = /vmlinuz
  root = /dev/hda1
  label = linux
  read-only
luisa:~#
\end{verbatim}
\end{quote}
Los dos par\'ametros que acabamos de ver ({\tt `password'} y {\tt `restricted'}
se pueden utilizar y combinar bien en la configuraci\'on general de {\sc lilo}
-- como lo hemos visto aqu\'{\i} -- o bien en la configuraci\'on particular de 
cada uno de los sistemas operativos a arrancar; si queremos esto \'ultimo no
tenemos m\'as que incluir las directivas dentro de la configuraci\'on de las
entradas {\tt `image'} (im\'agenes del {\it kernel} de Linux) u {\tt `other'} 
(arranque de otros sistemas operativos) en lugar de hacerlo antes de estas
entradas:
\begin{quote}
\begin{verbatim}
luisa:~# cat /etc/lilo.conf
boot = /dev/hda
delay = 50
vga = normal
image = /vmlinuz
  root = /dev/hda1
  label = linux
  read-only
  password = 66n4k
  restricted
luisa:~#
\end{verbatim}
\end{quote}
De esta forma podemos particularizar claves para cada sistema o n\'ucleo, 
definir entradas en las que se necesitar\'a la clave s\'olo si pasamos 
par\'ametros en el arranque, entradas en las que se necesitar\'a siempre, 
entradas en las que no se necesitar\'a nunca, etc.\\
\\Para finalizar este punto, es necesario recordar una vez m\'as que una 
correcta configuraci\'on del arranque en la {\sc bios} es imprescindible para
garantizar la seguridad f\'{\i}sica de la m\'aquina; sin ir m\'as lejos, si un
pirata consigue arrancar el ordenador desde un {\it diskette}, poseer\'a un
control total del sistema sin importar las claves que tengamos definidas en
{\tt /etc/lilo.conf}.
\section{Usuarios y accesos al sistema}
En un sistema Linux es posible controlar ciertos par\'ametros referentes al
acceso de los usuarios a trav\'es de {\it telnet} o {\it r-$\ast$} mediante
el fichero {\tt /etc/login.defs}; sus directivas no afectan directamente --
aunque algunas de ellas s\'{\i} de una forma indirecta -- a las conexiones a 
trav\'es de otros mecanismos como {\sc ssh}, que poseen sus propios ficheros de
configuraci\'on. Como siempre, insistimos en la necesidad de sustituir
todos los protocolos en claro por equivalentes cifrados, con lo que ni {\it
telnet} ni {\it r-$\ast$} deber\'{\i}an existir como servicio en una m\'aquina
Unix, pero de cualquier forma vamos a comentar algunas directivas del fichero
anterior que pueden resultar interesantes para nuestra seguridad, tanto si
afectan a las conexiones remotas como si no; para obtener informaci\'on acerca
del resto de directivas -- y tambi\'en de las comentadas aqu\'{\i} -- podemos
consultar la p\'agina del manual de {\tt login.defs(5)}.\\
\\La primera de las directivas que encontramos en {\tt /etc/login.defs} es
{\sc fail$\_$delay}, que marca el n\'umero de segundos (por defecto, 3) que el 
sistema introduce como retardo desde que se introduce un nombre de usuario o 
contrase\~na incorrectos hasta que se vuelve a solicitar el {\it login} de 
entrada al sistema; el n\'umero m\'aximo de intentos antes de que se cierre
la conexi\'on viene determinado por el valor de {\sc login$\_$retries}, por
defecto a 5, y el tiempo m\'aximo durante el que se permite la entrada antes
de cerrar la conexi\'on se especifica mediante la directiva {\sc 
login$\_$timeout} (60 segundos por defecto).\\
\\Cuando un usuario se equivoca en su nombre de entrada o su clave entran en 
juego un par de directivas
m\'as: {\sc faillog$\_$enab} y {\sc log$\_$unkfail$\_$enab}. La primera de 
ellas, con un valor por defecto a {\tt `yes'} (el adecuado para nuestra 
seguridad), se encarga de registrar los intentos fallidos de acceso al sistema
en {\tt /var/log/faillog}, as\'{\i} como de mostrar un mensaje con 
informaci\'on acerca del \'ultimo intento de acceso fallido cuando un usuario 
accede a la m\'aquina. Por su parte, {\sc log$\_$unkfail$\_$enab} habilita o
deshabilita el registro del nombre de usuario que ha fallado al tratar de
entrar al sistema; es importante que su valor sea {\tt `no'} (es decir, que 
ese nombre de usuario no se registre) por una sencilla raz\'on: en muchas
ocasiones los usuarios teclean su {\it password} en lugar de su {\it login} 
cuando tratan de acceder a la m\'aquina, con lo que si el nombre de usuario
incorrecto -- la clave -- se registra en un fichero en texto plano, y ese 
fichero tiene unos permisos inadecuados, cualquiera con acceso de lectura sobre
el archivo de {\it log} podr\'{\i}a deducir f\'acilmente el nombre y la clave 
del usuario. Adicionalmente, si la directiva {\sc ftmp$\_$file} define un
archivo (por defecto, {\tt /var/log/btmp}), en el mismo se registra cada 
intento de acceso fallido en formato {\tt utmp(5)}; dicha informaci\'on se 
puede consultar mediante la orden {\tt lastb}.\\
\\Si se produce la situaci\'on contraria a la que acabamos de comentar (es
decir, el usuario teclea correctamente tanto su nombre como su contrase\~na),
la directiva {\sc log$\_$ok$\_$logins} habilita o deshabilita el registro de 
este hecho en funci\'on de si su valor es {\tt `yes'} o {\tt `no'}; adem\'as,
si {\sc lastlog$\_$enab} tiene un valor {\tt `yes'} se registra la entrada en
{\tt /var/log/lastlog} y se muestra al usuario informaci\'on acerca de su 
\'ultima conexi\'on. En caso de que el usuario no pueda acceder a su directorio 
{\it \$HOME} (bien porque no existe, bien por los permisos del mismo) entra en
juego {\sc default$\_$home}, y en caso de que su valor sea {\tt `no'} no se
permite el acceso; por el contrario, si su valor es {\tt `yes'}, el usuario 
entra al directorio raiz de la m\'aquina.\\
\\En {\tt /etc/login.defs} tambi\'en se pueden definir l\'{\i}neas para las que
no es necesaria ninguna contrase\~na, mediante la directiva {\sc 
no$\_$password$\_$console}: si alguien trata de conectar al sistema
a trav\'es de ellas, se le solicitar\'a su nombre de usuario pero no su clave;
esto es aplicable para todos los usuarios de la m\'aquina {\bf excepto} para
el administrador, al que siempre se le pide su {\it password}. Evidentemente,
para incrementar la seguridad de nuestro sistema la directiva correspondiente 
ha de estar comentada.\\
\\El acceso a la cuenta del superusuario tambi\'en viene determinado por 
ciertas directivas del archivo {\tt /etc/login.defs}. En primer lugar, s\'olo
se permiten accesos directos como {\tt root} desde las l\'{\i}neas definidas
en la entrada {\sc console}, que puede ser bien un archivo que contiene los
nombres de dispositivos desde los que permitimos la entrada del administrador, o
bien una relaci\'on de esos dispositivos separados por el car\'acter {\tt `:'}; 
por defecto, en un sistema Linux esta entrada referencia al archivo {\tt 
/etc/securetty}, que es un listado de terminales de la forma siguiente:
\begin{quote}
\begin{verbatim}
luisa:~# cat /etc/securetty
console
tty1
tty2
tty3
tty4
tty5
tty6
luisa:~#
\end{verbatim}
\end{quote}
Como hemos dicho, la funci\'on del anterior archivo es muy similar a la de la 
directiva {\sc `console'} en el fichero {\tt /etc/default/login} de Solaris; 
si no existe, el administrador puede conectar en remoto desde cualquier lugar, 
mientras que si existe pero est\'a vac\'{\i}o s\'olo se pueden alcanzar 
privilegios de {\tt root} a trav\'es de la ejecuci\'on de {\tt `su'}. En 
cualquier caso, el fichero no evita ni controla las conexiones remotas como 
superusuario a trav\'es de mecanismos como {\sc ssh} o {\it X Window}, que 
poseen sus propios ficheros de configuraci\'on.\\
\\El contenido o la existencia de {\tt /etc/securetty} tampoco evita de ninguna
forma la ejecuci\'on de {\tt `su'}; para ello existen otras directivas que 
controlan el acceso y el comportamiento de esta orden en el sistema. La primera
de ellas es {\sc su$\_$wheel$\_$only}, que si posee un valor {\tt `yes'} 
indica que s\'olo los usuarios miembros del grupo {\tt 
`root'}\footnote{Realmente, del primer grupo con {\sc gid} 0 en {\tt 
/etc/group}, que corresponde al grupo {\tt `root'} en la mayor\'{\i}a de
sistemas Linux.} van a ser capaces de cambiar su identidad mediante {\tt `su'} 
a un usuario con privilegios de administrador ({\sc uid} 0); si este grupo no 
existe o est\'a vacio, nadie podr\'a ejecutar {\tt `su'} para convertirse en 
superusuario.\\
\\En el archivo {\tt /etc/suauth} (completamente independiente de {\tt 
/etc/login.defs}) se puede realizar un control m\'as minucioso de la ejecuci\'on
de {\tt `su'}, no s\'olo para acceder a cuentas con privilegios de 
administraci\'on, sino tambi\'en para permitir o denegar cambios de identidad
entre dos usuarios cualesquiera del sistema. Se trata de un fichero en el que
cada l\'{\i}nea es de la forma
\begin{verbatim}
                             to-id:from-id:ACCION
\end{verbatim}
donde {\tt ACCION} puede ser {\sc deny} (se deniega el cambio de identidad),
{\sc nopass} (se permite el cambio sin necesidad de ninguna clave) u {\sc 
ownpass} (se solicita el {\it password} del usuario que ejecuta la orden en 
lugar del correspondiente al usuario al que se quiere acceder); se puede 
consultar la p\'agina del manual {\tt suauth(5)} para conocer la sintaxis 
exacta del archivo. Por ejemplo,
si queremos que el usuario {\tt `toni'} no pueda ejecutar {\tt `su'} para 
cambiar su identidad a {\tt `root'}, pero que para convertirse en {\tt
`prova'} s\'olo tenga que teclear su propia contrase\~na, tendremos un fichero
similar al siguiente:
\begin{quote}
\begin{verbatim}
luisa:~# cat /etc/suauth 
root:toni:DENY
prova:toni:OWNPASS
luisa:~# 
\end{verbatim}
\end{quote}
Cuando {\tt toni} trate de hacer {\tt `su'} a las cuentas anteriores, ver\'a
algo similar a:
\begin{quote}
\begin{verbatim}
luisa:~$ id
uid=1000(toni) gid=100(users) groups=100(users)
luisa:~$ su 
Access to su to that account DENIED.
You are not authorized to su root
luisa:~$ luisa:~$ su prova
Please enter your OWN password as authentication.
(Enter your own password.)
Password: 
luisa:/home/toni$ id
uid=1006(prova) gid=100(users) groups=100(users)
luisa:/home/toni$
\end{verbatim}
\end{quote}
Es importante destacar que el contenido del fichero {\tt /etc/suauth} {\bf 
s\'olo} afecta a usuarios regulares, no al {\tt root}: no podemos definir 
reglas que eviten que el administrador de un sistema cambie su identidad a 
cualquier usuario del mismo. Esto es algo evidente, ya que si no se permitiera 
al {\tt root} cambiar su identidad, este no tendr\'{\i}a m\'as que modificar el
fichero para eliminar la regla que se lo impide.\\
\\Volviendo a {\tt /etc/login.defs}, el registro de las ejecuciones de {\tt 
`su'} tambi\'en se controla desde este fichero; la directiva {\sc 
sulog$\_$file} define el archivo donde
se registran las ejecuciones de esta orden, tanto si son exitosas como si no.
Adem\'as, si el valor de {\sc syslog$\_$su$\_$enab} es {\tt `yes'} se guarda
un registro adicional a trav\'es de {\tt syslogd} en el archivo 
correspondiente; existe una directiva an\'aloga a esta \'ultima denominada {\sc 
syslog$\_$sg$\_$enab}, que registra tambi\'en a trav\'es de {\tt syslogd} los 
cambios de grupo que se producen en el sistema (por ejemplo, mediante la 
ejecuci\'on de la orden {\tt newgrp}).\\
\\Antes de dejar de lado los aspectos relacionados con {\tt `su'} vamos a 
comentar una directiva muy interesante: se trata de {\sc su$\_$name}, que 
define el nombre de programa que un {\tt `ps'} muestra cuando alguien ejecuta 
la orden {\tt `su -'} (un cambio de identidad emulando un proceso de {\it 
login} directo) en el sistema. Su valor por defecto es {\tt `su'}, lo que
indica que si alguien cambia su identidad de la forma que acabamos de ver, un
listado de procesos mostrar\'a algo similar a lo siguiente:
\begin{quote}
\begin{verbatim}
luisa:~$ su - prova
Password: 

Famous, adj.:
        Conspicuously miserable.
                -- Ambrose Bierce

luisa:~$ ps xuw
prova    19990  0.8  0.3  1708  984 pts/8    S    07:04   0:00 -su
prova    20001  0.0  0.2  2548  908 pts/8    R    07:04   0:00 ps xuw
luisa:~$ 
\end{verbatim}
\end{quote}
Como vemos, en lugar del {\it shell} que el usuario est\'e utilizando, aparece
el nombre de programa {\tt `-su'} en la \'ultima columna del listado; si la
directiva no estuviera definida s\'{\i} que aparecer\'{\i}a el nombre del {\it 
shell} correspondiente. Puede resultar interesante redefinir la directiva {\sc 
su$\_$name} para asignarle un valor que pueda resaltar m\'as en el listado, de
forma que el administrador pueda ver quien ha ejecutado la orden {\tt `su -'}
de una forma m\'as directa:
\begin{quote}
\begin{verbatim}
luisa:~# grep ^SU_NAME /etc/login.defs 
SU_NAME         ***SU***
luisa:~# su - prova

f u cn rd ths, u cn gt a gd jb n cmptr prgrmmng.

luisa:~$ ps xuw
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
prova    20083  7.0  0.3  1712  988 pts/8    S    07:11   0:00 -***SU***
prova    20094  0.0  0.2  2548  912 pts/8    R    07:11   0:00 ps xuw
luisa:~$ 
\end{verbatim}
\end{quote}
A la hora de definir nuevos usuarios en el sistema tambi\'en entran en juego
ciertas directivas del archivo {\tt /etc/login.defs}. Por ejemplo, el {\sc uid}
y {\sc gid} m\'aximo y m\'{\i}nimo para los usuarios regulares viene determinado
por {\sc uid$\_$max}, {\sc gid$\_$max}, {\sc uid$\_$min} y {\sc gid$\_$min}.
Tambi\'en existen entradas para especificar ciertas caracter\'{\i}sticas 
relacionadas con las claves de los nuevos usuarios del sistema: se trata de {\sc
pass$\_$max$\_$days}, {\sc pass$\_$min$\_$days}, {\sc pass$\_$min$\_$len} y {\sc
pass$\_$warn$\_$age}. Como sus nombres indican, estas directivas marcan los
n\'umeros m\'aximo y m\'{\i}nimo de d\'{\i}as que una contrase\~na puede ser 
usada, la longitud m\'{\i}nima que todo {\it password} ha de tener, y el 
n\'umero de d\'{\i}as de antelaci\'on con que se avisar\'a a los usuarios antes 
de que sus claves caduquen, respectivamente. Cada vez que se crea a un usuario
nuevo en el sistema, se toman estos valores por defecto, aunque despu\'es es
habitual particularizar para cada caso concreto.\\
\\Cuando un usuario ejecuta la orden {\tt passwd} para cambiar su contrase\~na
en el sistema entra en juego la directiva {\sc obscure$\_$checks$\_$enab} 
(cuyo valor ha de ser {\tt `yes'}) para impedir que se elijan claves d\'ebiles
(por ejemplo, las formadas \'unicamente por letras min\'usculas); 
adicionalmente, si la orden est\'a enlazada a {\tt cracklib} (esto se realiza
en tiempo de compilaci\'on) y la directiva {\sc cracklib$\_$dictpath} est\'a
definida y tiene como valor la ruta de un directorio, se buscan en el mismo
ficheros de diccionario contra los que comparar la nueva contrase\~na, 
rechaz\'andola si se encuentra en alguno de ellos. En cualquier caso, se 
permiten tantos intentos de cambio como indica {\sc pass$\_$change$\_$tries}, y
si se supera este n\'umero se devuelve al usuario a su {\it shell} y la clave
permanece inalterada; si el usuario que trata de cambiar el {\it password} es 
el {\tt root} -- tanto la propia clave como la de cualquier usuario -- se le
permite elegir cualquier contrase\~na, sin importar su robustez, pero se le
advierte de que la clave elegida es d\'ebil si el valor de directiva {\sc
pass$\_$always$\_$warn} es {\tt `yes'}.\\
\\Al ejecutar {\tt passwd} para modificar valores del campo {\sc gecos} o para
cambiar el {\it shell} de entrada al sistema (o equivalentemente, al ejecutar
{\tt chfn} o {\tt chsh}) se solicita al usuario su clave si el valor de la 
directiva {\tt chfn$\_$auth} es {\tt `yes'}. Adem\'as, la entrada {\sc 
chfn$\_$restrict} define los campos concretos que un usuario puede modificar: 
{\it Full Name}, {\it Room Number}, {\it Work Phone} y {\it Home Phone} ({\tt 
`frwh'} si permitimos que modifique todos ellos); si la directiva no est\'a
definida, no se permite ning\'un tipo de cambio.\\
\\Relacionada tambi\'en con las contrase\~nas de los usuarios, la directiva {\sc
pass$\_$max$\_$len} marca el n\'umero de caracteres significativos en una clave
(8 por defecto); no obstante, esta entrada es ignorada si el valor de {\sc
md5$\_$crypt$\_$enab} es {\tt `yes'}, lo que indica que el sistema acepta {\it
passwords} basados en {\sc md5}, que proporcionan una longitud para las claves
ilimitada y {\it salts} m\'as largos que el esquema cl\'asico de Unix. La 
\'unica raz\'on para asignarle a esta \'ultima directiva un valor {\tt `no'} en
los Linux modernos es por razones de compatibilidad, ya que la seguridad que
proporciona este tipo de claves es mucho mayor que la proporcionada por los
mecanismos habituales de Unix.\\
\\Dejando ya de lado el archivo {\tt /etc/login.defs}, pero siguiendo con la
gesti\'on de las contrase\~nas de usuario, para consultar el estado de las 
mismas en un sistema Linux 
hemos de ejecutar la orden {\tt `passwd -S'} seguida del nombre del usuario 
correspondiente; por desgracia, en Linux no existe un par\'ametro {\tt `-a'} 
similar al de Solaris, que muestre informaci\'on de todos los usuarios, por lo
que hemos de hacer la consulta uno a uno:
\begin{quote}
\begin{verbatim}
luisa:~# for i in `awk -F: '{print $1}' /etc/passwd`
> do
> passwd -S $i
> done
root P 12/28/2000 0 -1 -1 -1
bin L 10/28/1996 0 -1 -1 -1
daemon L 10/28/1996 0 -1 -1 -1
adm L 10/28/1996 0 -1 -1 -1
lp L 10/28/1996 0 -1 -1 -1
sync L 10/28/1996 0 -1 -1 -1
shutdown L 10/28/1996 0 -1 -1 -1
halt L 10/28/1996 0 -1 -1 -1
mail L 10/28/1996 0 -1 -1 -1
news L 10/28/1996 0 -1 -1 -1
uucp L 10/28/1996 0 -1 -1 -1
operator L 10/28/1996 0 -1 -1 -1
games L 10/28/1996 0 -1 -1 -1
ftp L 10/28/1996 0 -1 -1 -1
gdm L 10/28/1996 0 -1 -1 -1
nobody L 10/28/1996 0 -1 -1 -1
toni P 12/29/2000 0 99999 7 -1
prova NP 10/23/2001 0 99999 7 -1
luisa:~# 
\end{verbatim}
\end{quote}
El segundo campo de cada l\'{\i}nea del listado anterior proporciona el estado 
de la clave correspondiente: {\tt `P'} si el usuario tiene contrase\~na, {\tt 
`L'} si la cuenta est\'a bloqueada, y {\tt `NP'} si el usuario no tiene clave 
asignada; en este \'ultimo caso es muy importante poner un {\it password} al 
usuario o bien bloquear su acceso:
\begin{quote}
\begin{verbatim}
luisa:~# passwd -S prova
prova NP 10/23/2001 0 99999 7 -1
luisa:~# passwd -l prova
Password changed.
luisa:~# passwd -S prova
prova L 10/23/2001 0 99999 7 -1
luisa:~# 
\end{verbatim}
\end{quote}
El resto de campos del listado hacen referencia propiedades de envejecimiento
de las claves: cuando se cambi\'o la contrase\~na de cada usuario por \'ultima
vez, cuales son sus periodos de validez m\'aximo y m\'{\i}nimo, el periodo de
aviso y el periodo de inactividad antes de bloquear el acceso de forma
autom\'atica; tambi\'en mediante {\tt passwd} (o equivalentemente mediante
{\tt chage}) podemos -- como {\tt root} -- modificar esta informaci\'on para 
cada uno de nuestros usuarios. Por ejemplo, si queremos que la clave del 
usuario {\tt `prova'} tenga un periodo de validez m\'aximo de un mes y 
m\'{\i}nimo de 10 d\'{\i}as, que se avise al usuario de que su clave va a 
caducar con una antelaci\'on de una semana, y que si una vez la clave ha 
caducado el usuario no entra al sistema en cinco d\'{\i}as se bloquee su cuenta
podemos conseguirlo con la siguiente orden:
\begin{quote}
\begin{verbatim}
luisa:~# passwd -S prova
prova L 10/23/2001 0 99999 7 -1
luisa:~# passwd -x 30 -n 10 -w 7 -i 5 prova
Password changed.
luisa:~# passwd -S prova
prova L 10/23/2001 10 30 7 5
luisa:~# 
\end{verbatim}
\end{quote}
Como en este caso la cuenta est\'a bloqueada, los cambios tendr\'an efecto 
cuando
esta se desbloquee (o directamente se le asigne una nueva clave) y comience a 
ser utilizada; a diferencia de otros sistemas Unix, el desbloqueo de un acceso 
en Linux guarda una especie de estado: conserva la contrase\~na que el usuario 
ten\'{\i}a antes de que su cuenta fuera bloqueada.
\section{El sistema de parcheado}
A la hora de hablar de actualizaciones en Linux debemos distinguir entre la 
actualizaci\'on del n\'ucleo del operativo y la de las diferentes aplicaciones 
del sistema. Esta \'ultima no es en ning\'un momento algo tan est\'andar como 
lo pueda ser en Unices comerciales como Solaris o AIX debido a que no hay un 
\'unico modelo de Linux en el mercado, sino que existen diferentes clones de 
este operativo, y a pesar de que todos son `Linux' en cada uno de ellos se 
trabaja de forma diferente. Por contra, si lo que se va a actualizar es el 
n\'ucleo de Linux en cualquiera de ellos se procede de la misma forma, ya que
el {\it kernel} es com\'un a todas las distribuciones. Vamos a hablar primero
brevemente de los diferentes m\'etodos de actualizaci\'on de aplicaciones en
funci\'on del Linux utilizado y despu\'es comentaremos aspectos de 
actualizaci\'on y parcheado del n\'ucleo.\\
\\En Red Hat, y en todos los Linux basados en esta distribuci\'on (Mandrake, 
Caldera\ldots) el {\it software} se suele descargar precompilado desde Internet
en un formato especial denominado {\sc rpm} ({\it Red Hat Package Manager}),
que permite al administrador de un sistema instalar y desinstalar programas,
as\'{\i} como verificar versiones del {\it software} instalado en la 
m\'aquina; podemos encontrar una extensa descripci\'on de este formato en 
\cite{kn:bai97}, aunque la idea m\'as elemental acerca del mismo es que se trata
de un sistema de gesti\'on (instalaci\'on, actualizaci\'on, borrado\ldots) de
{\it software} capaz de hacer comprobaciones de dependencia entre paquetes, 
ejecutar programas de pre y postinstalaci\'on y detectar y solventar cierto tipo
de conflictos entre diferentes paquetes o diferentes versiones del mismo.\\
\\Actualizar versiones de {\it software} mediante {\tt rpm} es una tarea 
sencilla: normalmente el administrador no tiene m\'as que ejecutar {\tt `rpm 
-U'}, orden 
que se encargar\'a de instalar la nueva versi\'on y eliminar la antigua (si 
existe); es equivalente a ejecutar primero una instalaci\'on ({\tt `rpm -i'}) 
del {\it paquete} actualizado y despu\'es un borrado ({\tt `rpm -e'}) de la
versi\'on anteriormente instalada en la m\'aquina. Lo m\'as habitual es ver en 
primer lugar
la versi\'on concreta de un paquete {\it soft} instalado en la m\'aquina, 
mediante {\tt `rpm -q'} ({\tt `rpm -qa'} nos mostrar\'a un listado de todos y
cada uno de los paquetes instalados):
\begin{quote}
\begin{verbatim}
rosita:~# rpm -q libpcap
libpcap-0.4-10
rosita:~#
\end{verbatim}
\end{quote}
Tras esto podemos conseguir una versi\'on actualizada (el paquete en formato 
{\sc rpm} del {\it software} que nos interese) e instalarla mediante las
\'ordenes vistas anteriormente:
\begin{quote}
\begin{verbatim}
rosita:~# ls -l libpcap-0.4-19.i386.rpm 
-rw-r--r--   1 root    root      56554 Feb 18 03:54 libpcap-0.4-19.i386.rpm
rosita:~# rpm -U libpcap-0.4-19.i386.rpm 
rosita:~# rpm -q libpcap
libpcap-0.4-19
rosita:~#
\end{verbatim}
\end{quote}
Por su parte, en Debian y derivados, la actualizaci\'on de {\it software} se
puede llevar a cabo mediante {\tt `dpkg'}, que permite instalar, configurar y
eliminar paquetes; no obstante, su uso -- al menos de forma 
directa -- hoy en d\'{\i}a es poco habitual debido a la existencia de otra
herramienta denominada {\sc apt} ({\it Advanced Package Tool}), 
posiblemente el mecanismo de instalaci\'on y actualizaci\'on de {\it software} 
m\'as c\'omodo de cuantos existen en Linux. La principal interfaz entre este 
sistema y el usuario es {\tt `apt-get'}, herramienta de l\'{\i}nea de
\'ordenes cuyo funcionamiento se basa especialmente en el fichero {\tt 
/etc/apt/sources.list}, que como su nombre indica es un registro de las fuentes 
desde las que se pueden obtener paquetes actualizados.\\
\\Los paquetes de {\it software} en Debian suelen tener un nombre finalizado
en {\tt `.deb'}, que realmente es un {\tt `.ar'} con algunas modificaciones; 
para obtener un listado actualizado de los paquetes disponibles en las
diferentes ubicaciones indicadas en {\tt /etc/apt/sources.list} no tenemos
m\'as que ejecutar la orden {\tt `apt-get update'} (algo recomendable cada vez
que se modifique el fichero de fuentes), que conectar\'a a cada una 
de dichas ubicaciones y descargar\'a la lista de paquetes actualizados; esta
orden no instala esos paquetes, por lo que a continuaci\'on deberemos ejecutar 
{\tt `apt-get install'} o, directamente {\tt `apt-get upgrade'} para actualizar 
las versiones del {\it software} ya instalado: 
\begin{quote}
\begin{verbatim}
rosita:~# apt-get upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
0 packages upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
rosita:~# 
\end{verbatim}
\end{quote}
Tanto Red Hat como Debian proporcionan mecanismos para verificar -- hasta
cierto punto -- la integridad de cada paquete instalado; realmente, m\'as que
la integridad, podr\'{\i}amos hablar de las modificaciones sufridas por 
archivos instalados a partir de un paquete con respecto a los originales (qu\'e
ficheros han sido modificados desde la instalaci\'on), ya que no se trata de
comprobaciones de integridad que nos permitan decir si un paquete ha sido 
troyanizado o no, sino simples verificaciones de presencia de ficheros 
modificados. Como casi siempre, para comprobar realmente la autenticidad del 
{\it software} debemos recurrir a funciones resumen tipo {\sc md5}.\\
\\El Linux m\'as arcaico (pero no por ello el peor, ni mucho menos) a
la hora de actualizar {\it software} es Slackware; en esta distribuci\'on de
Linux el formato de paquete es sin duda el m\'as est\'andar de todos: el 
{\it software} se distribuye en ficheros {\tt .tgz}, que no son m\'as que
archivos {\tt .tar.gz} compatibles con cualquier Unix, con unas peque\~nas
modificaciones para poderlos instalar mediante {\tt installpkg}, un sencillo
{\it shellscript}. En cualquier caso, ni siquiera suele ser necesaria esta
utilidad para instalar ficheros {\tt .tgz}: es suficiente con desempaquetarlos
y descomprimirlos desde el directorio ra\'{\i}z de la m\'aquina.\\
\\En Slackware podemos utilizar el comando {\tt upgradepkg} para actualizar un
paquete de {\it software} determinado; esta orden no es m\'as que otro {\it 
shellscript} que instala el paquete nuevo y
elimina los ficheros de la versi\'on antigua que no existan en la nueva. Sin
embargo, entre los administradores de Slackware -- me incluyo en el grupo -- es
mucho m\'as habitual descargar el c\'odigo fuente de la aplicaci\'on a 
actualizar, compilarlo e instalarlo por encima de la versi\'on antigua (o
eliminar esta primero, de forma manual).\\
\\En cuanto al {\it kernel} de Linux y su actualizaci\'on, como antes hemos 
comentado, si lo que queremos es actualizar o parchear el
n\'ucleo del sistema operativo la forma de hacerlo ya no es tan dependiente de 
la versi\'on de Linux utilizada. Para actualizar la versi\'on del {\it kernel}
tenemos dos opciones: o descargamos el c\'odigo fuente de la nueva versi\'on,
de forma completamente independiente de la que tengamos en estos momentos, o
descargamos un parche que al ser aplicado nos modificar\'a el c\'odigo 
instalado ya en nuestro sistema para convertirlo en la nueva versi\'on; en ambos
casos debemos compilar y arrancar con la imagen generada si queremos que el 
sistema quede actualizado.\\
\\Si hemos descargado un nuevo {\it kernel} completo (generalmente un fichero
{\tt .tar.gz}) no tenemos m\'as que descomprimirlo, desempaquetarlo y 
compilarlo para generar una nueva imagen con el nuevo n\'ucleo; evidentemente
no vamos a entrar ahora en como configurar o compilar el {\it kernel} de Linux:
para eso hay excelentes documentos disponibles en la red.\\
\\M\'as interesante es la aplicaci\'on de parches al c\'odigo fuente, bien para
incrementar la versi\'on del n\'ucleo, como ya hemos dicho, o bien para aplicar
una modificaci\'on `no oficial' distribuida como parche; en este \'ultimo caso
-- cada vez menos utilizado, debido al desarrollo de los m\'odulos cargables
en tiempo de ejecuci\'on -- hemos de tener cuidado, ya que al aplicar un parche
no oficial es muy probable que si posteriormente deseamos incrementar la
versi\'on de nuestro {\it kernel} tambi\'en mediante parcheado del c\'odigo, 
este \'ultimo no funcione correctamente.\\
\\Lo m\'as habitual es que cualquier parche para el c\'odigo fuente del 
n\'ucleo, tanto oficial como `no oficial', se distribuya como un simple fichero
de texto (en muchos casos comprimido con gzip) que contiene las diferencias 
entre el c\'odigo actual y el modificado, generadas con {\tt diff}; podemos 
verificarlo simplemente echando un vistazo al fichero que acabamos de descargar:
\begin{quote}
\begin{verbatim}
luisa:/usr/src# gzip -dc patch-2.2.14.gz|head -4
diff -u --recursive --new-file v2.2.13/linux/CREDITS linux/CREDITS
--- v2.2.13/linux/CREDITS       Tue Jan  4 11:24:09 2000
+++ linux/CREDITS       Tue Jan  4 10:12:10 2000
@@ -137,12 +137,9 @@
luisa:/usr/src# 
\end{verbatim}
\end{quote}
Si este es nuestro caso, para aplicar el parche no tenemos m\'as que utilizar
la orden {\tt `patch'}:
\begin{quote}
\begin{verbatim}
luisa:/usr/src# gzip -dc patch-2.2.14.gz | /usr/bin/patch -p0
\end{verbatim}
\end{quote}
Si el proceso ha sido correcto, el c\'odigo fuente que en nuestro ejemplo antes 
correspond\'{\i}a al n\'ucleo 2.2.13 ahora corresponde al 2.2.14; como antes, 
no tenemos m\'as que recompilar ese c\'odigo y arrancar con la imagen generada
para que nuestro {\it kernel} sea el nuevo:
\begin{quote}
\begin{verbatim}
luisa:~# uname -a
Linux luisa 2.2.14 #9 Sat Dec 30 03:34:32 CET 2000 i686 unknown
luisa:~#
\end{verbatim}
\end{quote}
\section{El subsistema de red}
\label{linux_netsys}
Lamentablemente en Linux no existe una orden similar a {\tt ndd} en Solaris o a
{\tt no} en AIX, que como hemos visto o veremos m\'as adelante se utilizan para
configurar en tiempo de ejecuci\'on, y de una forma sencilla, par\'ametros del 
operativo relativos al subsistema de red. En este caso necesitamos recurrir, en
la mayor\'{\i}a de ocasiones, a escribir directamente en ficheros del directorio
{\tt /proc/}, un sistema de archivos `virtual' que en Linux y otros entornos 
Unix act\'ua como interfaz ente el espacio de usuario y el n\'ucleo.\\
\\Con relaci\'on a la tabla {\sc arp} y sus {\it timeouts} (como ya dijimos al
hablar de Solaris, importantes en nuestra seguridad para prevenir cierto tipo de
ataques), su funcionamiento en Linux es quiz\'as algo engorroso: en los
directorios {\tt /proc/sys/net/ipv4/neigh/$\ast$/} tenemos ciertos ficheros que
indican par\'ametros de configuraci\'on de {\sc arp}; uno de ellos, {\tt
gc$\_$stale$\_$time}, define el tiempo (60 segundos por defecto) que una entrada
de la tabla {\sc arp} se considera `viva'. Cuando este {\it timeout} ha vencido
para cierta entrada, entra en juego el par\'ametro {\tt gc$\_$interval}, que
marca la frecuencia de actuaci\'on del recolector de basura ({\it garbage 
collector}) en el sistema; este, que se ejecuta cada 30 segundos, es realmente 
el encargado de eliminar las entradas `caducadas' de nuestra tabla.\\
\\Respecto al protocolo {\sc icmp}, una buena idea -- como en cualquier Unix --
es ignorar las peticiones {\sc icmp$\_$echo} dirigidas a direcciones de {\it
broadcast}; esto lo conseguimos escribiendo un valor diferente de 0 en el 
archivo {\tt /proc/sys/net/ipv4/icmp$\_$echo$\_$ignore$\_$broadcasts}. Si no nos
conformamos con esto, y queremos ignorar todas las peticiones {\sc 
icmp$\_$echo}, no tenemos m\'as que hacer lo mismo en el archivo {\tt 
/proc/sys/net/ipv4/icmp$\_$echo$\_$ignore$\_$all}.\\
\\La gesti\'on de tramas {\sc icmp$\_$redirect} tambi\'en puede presentar 
ciertos riesgos para nuestra seguridad. Si en {\tt 
/proc/sys/net/ipv4/conf/*/accept$\_$redirects} indicamos un valor diferente de
0 estamos dici\'endole al n\'ucleo de Linux que haga caso de este tipo de 
paquetes que en principio nos puede enviar un enrutador; su valor por defecto
(0, desactivado) es el correcto. An\'alogamente, en {\tt 
/proc/sys/net/ipv4/conf/*/send$\_$redirects} permitimos la emisi\'on de estas
tramas desde nuestra m\'aquina escribiendo un valor diferente de 0; como s\'olo
un {\it router} deber\'{\i}a enviar estos paquetes, la opci\'on m\'as segura 
es especificar un 0 para este par\'ametro (su valor por defecto es 1). Una
opci\'on intermedia entre bloquear todas las tramas {\sc icmp$\_$redirect} y
permitirlas puede ser el escribir en el archivo {\tt secure$\_$redirects} un
valor diferente de 0, logrando que se acepten este tipo de paquetes pero {\bf
s\'olo} desde la lista de {\it gateways} v\'alidos definida en {\tt 
/etc/gateways}.\\
\\Pasando ya a hablar del protocolo {\sc ip}, uno de los par\'ametros que m\'as 
nos va a interesar es la habilitaci\'on o
deshabilitaci\'on del {\it IP Forwarding} en el n\'ucleo de Linux; como hemos
dicho antes, el sistema de filtrado de paquetes s\'olo funciona cuando esta
opci\'on est\'a habilitada, lo que se consigue con la orden
\begin{quote}
\begin{verbatim}
luisa:~# echo 1 > /proc/sys/net/ipv4/ip_forward
luisa:~# 
\end{verbatim}
\end{quote}
Sin embargo, si no utilizamos las facilidades de {\it firewalling} del n\'ucleo
de Linux esta opci\'on ha de estar desabilitada (introducir\'{\i}amos un `0' en
lugar de un `1' en el fichero anterior), ya que de lo contrario corremos el
peligro de que nuestra m\'aquina se convierta en un {\it router}.\\
\\Antes hemos hablado de las {\it `SYN Cookies'}, y hemos comentado que aunque
el soporte para esta caracter\'{\i}stica se introduce al compilar el n\'ucleo,
realmente el mecanismo se ha de activar desde espacio de usuario, por ejemplo
con una orden como la siguiente:
\begin{quote}
\begin{verbatim}
luisa:~# echo 1 >/proc/sys/net/ipv4/tcp_syncookies
luisa:~# 
\end{verbatim}
\end{quote}
Tambi\'en es muy recomendable que el
subsistema de red del {\it kernel} descarte las tramas con {\it Source Routing}
o encaminamiento en origen activado. Este tipo de paquetes contienen el camino
que han de seguir hasta su destino, de forma que los {\it routers} por los que
pasa no han de examinar su contenido sino simplemente reenviarlo, hecho que
puede causar la llegada de datos que constituyan una amenaza a nuestras
pol\'{\i}ticas de seguridad. En los n\'ucleos 2.0 esto se consegu\'{\i}a
activando la opci\'on {\sc config\_ip\_nosr} a la hora de compilar el {\it 
kernel}, mientras que en los 2.2 la forma
m\'as sencilla de ignorar estos paquetes es introduciendo un `0' en los
diferentes ficheros {\tt accept\_source\_route} del directorio {\tt
/proc/sys/net/ipv4/}; por ejemplo la siguiente orden descarta las tramas con
encaminamiento en origen que llegan al dispositivo de red {\tt eth0}:
\begin{quote}
\begin{verbatim}
luisa:~# echo 0 >/proc/sys/net/ipv4/conf/eth0/accept_source_route
luisa:~# 
\end{verbatim}
\end{quote}
Hemos de recordar que las modificaciones que hacemos sobre el interfaz {\tt
sysctl} son din\'amicas: se pueden efectuar con el sistema funcionando, sin
necesidad de reiniciarlo, pero se pierden cuando la m\'aquina se apaga para
establecerse a unos valores por defecto al arrancar de nuevo el sistema
operativo; seguramente nos interesar\'a mantener los cambios realizados, por lo
que en alguno de los ficheros de inicializaci\'on de la m\'aquina hemos de
incluir las \'ordenes que acabamos de explicar, obviamente despu\'es de haber
montado el sistema de ficheros {\tt /proc/}.
\section{El n\'ucleo de Linux}
\label{linkernel}
\subsection{Opciones de compilaci\'on}
A la hora de recompilar un nuevo n\'ucleo de Linux hemos de tener en cuenta
algunas opciones dentro del grupo {\tt `Networking Options'} que pueden afectar
a la seguridad de nuestra m\'aquina (algunos de estos aspectos, para n\'ucleos
2.0, pueden encontrarse en \cite{kn:wre98}). Sin embargo, antes de entrar en
detalles con opciones concretas, es {\bf muy} conveniente que introduzcamos
soporte para sistemas de ficheros {\tt proc} en {\tt `Filesystems'} ({\sc 
config\_proc\_fs}) y activemos el interfaz {\tt sysctl} en {\tt `General
Setup'} ({\sc config\_sysctl}); con estos pasos habilitamos la capacidad de 
Linux para modificar ciertos par\'ametros del n\'ucleo (en {\tt /proc/sys/}) 
sin necesidad de reiniciar el sistema o recompilar el {\it kernel}.\\
\\Pasando ya a comentar algunas opciones que nos ofrece Linux, es bastante 
interesante para la seguridad configurar nuestro sistema como un cortafuegos
a la hora de compilar el n\'ucleo ({\sc config\_ip\_firewall}). Linux ofrece
en su {\it kernel} facilidades para definir un {\it firewall} de paquetes en
el sistema, que adem\'as permitir\'a el {\it IP-Masquerading}. Para que el
subsistema de filtrado funcione es necesario que el {\it IP-Forwarding} est\'e
activado de la forma que m\'as tarde veremos.\\
\\Otra opci\'on que nos puede ayudar a incrementar la seguridad de nuestro
equipo es la defragmentaci\'on de paquetes ({\sc config\_ip\_always\_defrag})
que llegan a trav\'es de la red. Cuando un equipo situado entre el origen y el 
destino de los datos 
decide que los paquetes a enviar son demasiado grandes, los divide en fragmentos
de longitud menor; sin embargo, los n\'umeros de puerto s\'olamente viajan
en el primer fragmento, lo que implica que un atacante puede insertar 
informaci\'on en el resto de tramas que en teor\'{\i}a no debe viajar en ellas.
Activando esta opci\'on, en nuestra m\'aquina estos fragmentos se reagrupar\'an
de nuevo incluso si van a ser reenviados a otro {\it host}.\\
\\Siguiendo con las diferentes opciones del subsistema de red, podemos habilitar
el soporte para {\it `SYN Cookies'} ({\sc config\_syn\_cookies}) en el n\'ucleo 
que estamos configurando.
Una red TCP/IP habitual no puede soportar un ataque de negaci\'on de servicio
conocido como {\it `SYN Flooding'}, consistente b\'asicamente en enviar una
gran cantidad de tramas con el bit SYN activado para as\'{\i} saturar los
recursos de una m\'aquina determinada hasta que los usuarios no pueden ni
siquiera conectar a ella. Las {\it `SYN Cookies'} proporcionan
cierta protecci\'on contra este tipo de ataques, ya que la pila TCP/IP utiliza
un protocolo criptogr\'afico para permitir que un usuario leg\'{\i}timo pueda
seguir accediendo al sistema incluso si este est\'a siendo atacado. Aunque
configuremos y ejecutemos un n\'ucleo con esta opci\'on soportada, hemos de
activar las {\it `SYN Cookies'} cada vez que el sistema arranca (como veremos
luego), ya que por defecto est\'an deshabilitadas.\\
\\En ciertas situaciones es interesante analizar en espacio de usuario -- es
decir, sin sobrecargar al n\'ucleo m\'as de lo estrictamente necesario -- un
paquete o parte de \'el (t\'{\i}picamente, los 128 primeros bytes) que llega a 
trav\'es de la red hasta nuestra m\'aquina; de esta forma, un analizador simple
puede tomar ciertas decisiones en funci\'on del contenido del paquete recibido,
como enviar un correo al administrador en caso de sospecha o grabar un mensaje
mediante {\tt syslog}. Justamente esto es lo que conseguimos si habilitamos
la opci\'on {\it Firewall Packet Netlink Device} ({\sc 
config\_ip\_firewall\_netlink}).\\
\\Hasta ahora hemos hablado de la posibilidad que tiene Linux para modificar
par\'ametros del n\'ucleo sin necesidad de recompilarlo o de reiniciar el
equipo, mediante el interfaz {\tt sysctl}; esto implica por ejemplo que podemos
modificar el comportamiento del subsistema de red simplemente modificando 
determinados ficheros de {\tt /proc/sys/} (recordemos que el sistema de
ficheros {\tt /proc/} de algunos Unix es una interfaz entre estructuras de
datos del n\'ucleo y el espacio de usuario). Veremos en el punto 
\ref{linux_netsys} algunos de estos par\'ametros configurables que tienen 
mucho que ver con la seguridad Linux, en especial con el subsistema de red.
\subsection{Dispositivos}
Linux (no as\'{\i} otros Unices) proporciona dos dispositivos virtuales 
denominados {\tt /dev/random} y {\tt /dev/urandom} que pueden utilizarse para
generar n\'umeros pseudoaleatorios, necesarios para aplicaciones 
criptogr\'aficas. El primero de estos ficheros, {\tt /dev/random}, utiliza lo
que su autor denomina {\it `ruido ambiental'} (por ejemplo, temporizadores de
IRQs, accesos a disco o tiempos entre pulsaciones de teclas) para crear 
una fuente de entrop\'{\i}a aceptable y -- muy importante -- que apenas 
introduce sobrecarga en el sistema. El segundo archivo, {\tt /dev/urandom},
crea un resumen de la entrop\'{\i}a de {\tt /dev/random} utilizando la 
funci\'on {\it hash} SHA ({\it Secure Hash Algorithm}), dise\~nada por el 
NIST y la NSA para su {\it Digital Signature Standard} (\cite{kn:nist186}). Por
tanto, tenemos una fuente de entrop\'{\i}a aceptable, {\tt /dev/urandom}, y
otra incluso mejor, pero de capacidad limitada, {\tt /dev/random}. Para detalles
concretos sobre su funcionamiento se puede consultar el fichero que las 
implementa dentro del n\'ucleo de Linux, {\tt drivers/char/random.c}.\\
\\Como en el propio c\'odigo se explica, cuando un sistema operativo arranca
ejecuta una serie de acciones que pueden ser predecidas con mucha facilidad
por un potencial atacante (especialmente si en el arranque no interactua 
ninguna persona, como es el caso habitual en Unix). Para mantener el nivel de
entrop\'{\i}a en el sistema se puede almacenar el desorden que exist\'{\i}a
en la parada de la m\'aquina para restaurarlo en el arranque; esto se consigue
modificando los {\it scripts} de inicializaci\'on del sistema. En el fichero
apropiado que se ejecute al arrancar (por ejemplo, {\tt /etc/rc.d/rc.M}) 
debemos a\~nadir las siguientes l\'{\i}neas:
\tt
\begin{quote}
\begin{verbatim}
echo "Initializing random number generator..."
random_seed=/var/run/random-seed
# Carry a random seed from start-up to start-up
# Load and then save 512 bytes, which is the size of the entropy pool
if [ -f $random_seed ]; then
      cat $random_seed >/dev/urandom
fi
dd if=/dev/urandom of=$random_seed count=1
chmod 600 $random_seed
\end{verbatim}
\end{quote}
\rm
Mientras que en un fichero que se ejecute al parar el sistema a\~nadiremos lo
siguiente:
\tt
\begin{quote}
\begin{verbatim}
# Carry a random seed from shut-down to start-up
# Save 512 bytes, which is the size of the entropy pool
echo "Saving random seed..."
random_seed=/var/run/random-seed
dd if=/dev/urandom of=$random_seed count=1
chmod 600 $random_seed
\end{verbatim}
\end{quote}
\rm
Con estas peque\~nas modificaciones de los archivos de arranque y parada del
sistema conseguimos mantener un nivel de entrop\'{\i}a aceptable durante todo
el tiempo que el sistema permanezca encendido.
Si de todas formas no consideramos suficiente la entrop\'{\i}a proporcionada 
por estos dispositivos de Linux, podemos conseguir otra excelente fuente de
desorden en el mismo sistema operativo a partir de una simple tarjeta de sonido y unas modificaciones en el n\'ucleo (\cite{kn:phrack54}), o utilizar alguno de
los generadores -- algo m\'as complejos -- citados en \cite{kn:sch94}.
\subsection{Algunas mejoras de la seguridad}
En esta secci\'on vamos a comentar algunos aspectos de modificaciones del 
n\'ucleo que se distribuyen libremente en forma de parches, y que contribuyen
a aumentar la seguridad de un sistema Linux; para obtener referencias 
actualizadas de estos c\'odigos -- y otros no comentados aqu\'{\i} -- es 
re\-co\-men\-da\-ble consultar \cite{kn:sei99}; para informaci\'on de 
estructuras de datos, ficheros o l\'{\i}mites del n\'ucleo de Linux se puede
consultar \cite{kn:bec96} o \cite{kn:car97}.
\subsubsection{L\'{\i}mites del n\'ucleo}
En {\tt include/asm/resource.h} tenemos la inicializaci\'on de algunas 
estructuras de datos del n\'ucleo relacionadas con l\'{\i}mites a la cantidad de
recursos consumida por un determinado proceso; por ejemplo, el m\'aximo n\'umero
de procesos por usuario ({\sc rlimit$\_$nproc}) se inicializa a {\sc \\
max$\_$tasks$\_$per$\_$user}, valor que en {\tt include/linux/tasks.h} podemos
comprobar que se corresponde con la mitad de {\sc nr$\_$tasks} (n\'umero 
m\'aximo de procesos en el sistema); en arquitecturas {\tt i86} el valor del
l\'{\i}mite de procesos por usuario se fija a 256. 
De la misma forma, el n\'umero m\'aximo de ficheros abiertos por un proceso
({\sc rlimit$\_$nofile}) se inicializa al valor {\sc nr$\_$open}, que en
el archivo {\tt include/asm/limits.h} se define como 1024.\\
\\Estos l\'{\i}mites se pueden consultar desde espacio de usuario con la llamada
{\tt getrlimit()}; esta funci\'on utiliza una estructura de datos {\tt rlimit},
definida en {\tt include/linux/resource.h}, que contiene dos datos enteros para
representar lo que se conoce como l\'{\i}mite {\it soft} o blando y l\'{\i}mite
{\it hard} o duro. El l\'{\i}mite blando de un recurso puede ser modificado
por cualquier proceso sin privilegios que llame a {\tt setrlimit()}, ya sea
para aumentar o para disminuir su valor; por el contrario, el l\'{\i}mite {\it
hard} define un valor m\'aximo para la utilizaci\'on de un recurso, y s\'olo
puede ser sobrepasado por procesos que se ejecuten con privilegios de
administrador.\\
\\En el fichero {\tt include/linux/nfs.h} podemos definir el puerto m\'aximo
que los clientes {\sc nfs} pueden utilizar ({\sc nfs$\_$port}); si le asignamos
un valor inferior a 1024 (puertos privilegiados), s\'olo el administrador de 
otro sistema Unix podr\'a utilizar nuestros servicios {\sc nfs}, de forma 
similar a la variable {\tt nfs$\_$portmon} de algunos Unices.\\
\\Para cambiar los l\'{\i}mites de los par\'ametros vistos aqu\'{\i} la
soluci\'on m\'as r\'apida pasa por modificar los ficheros de cabecera del {\it
kernel}, recompilarlo y arrancar la m\'aquina con el nuevo n\'ucleo; sin 
embargo, a continuaci\'on vamos a hablar brevemente de {\it Fork Bomb Defuser},
un m\'odulo que permite al administrador modificar algunos de estos par\'ametros
sin reiniciar el sistema. M\'as adelante hablaremos tambi\'en de los 
l\'{\i}mites a recursos ofrecidos por {\sc pam} ({\it Pluggable Authentication
Modules}), un sistema de autenticaci\'on incorporado en la actualidad a la 
mayor\'{\i}a de Linux, as\'{\i} como en otros Unices. 
\subsubsection{Fork Bomb Defuser}
El {\it kernel} de Linux no permite por defecto limitar el n\'umero m\'aximo de 
usuarios y el n\'umero m\'aximo de procesos por usuario que se pueden ejecutar
en el sistema sin tener que modificar el c\'odigo del n\'ucleo; si no queremos 
modificarlo, casi no hay m\'as remedio que utilizar un poco de programaci\'on 
(unos simples {\it shellscripts} suelen ser suficientes) y las herramientas de
planificaci\'on de tareas para evitar que un usuario lance demasiados procesos
o que conecte cuando el sistema ya ha sobrepasado un cierto umbral de usuarios
conectados a \'el.\\
\\Mediante el m\'odulo {\it Fork Bomb Defuser} se permite al administrador 
controlar todos estos pa\-r\'a\-me\-tros del sistema operativo, incrementando 
de forma flexible la seguridad de la m\'aquina. El c\'odigo est\'a disponible 
en {\tt http://rexgrep.tripod.com/rexfbdmain.htm}.
\subsubsection{Secure Linux}
Por {\it Secure Linux} se conoce a una colecci\'on de parches para el n\'ucleo 
de Linux programados por {\it Solar Designer}, uno de los {\it hackers} m\'as
reconocidos a nivel mundial en la actualidad (entendiendo {\it hacker} en el
buen -- y \'unico -- sentido de la palabra). Este {\it software}, disponible
libremente desde {\tt http://www.false.com/security/linux/}\footnote{Esta
URL ya no existe, ahora los trabajos de Solar Designer se encuentran en
{\tt http://www.openwall.com/}; gracias, David :).}, incrementa
la seguridad que el n\'ucleo proporciona por defecto, ofreciendo cuatro 
importantes diferencias con respecto a un {\it kernel} normal:
\begin{itemize}
\item \'Area de pila no ejecutable\\
En un sistema con el \'area de la pila no ejecutable los ataques de {\it buffer 
overflow} son m\'as dif\'{\i}ciles de realizar que en los sistemas habituales,
ya que muchos de estos ataques se basan en sobreescribir la direcci\'on de 
retorno de una funci\'on en la pila para que apunte a c\'odigo malicioso, 
tambi\'en depositado en la pila. Aunque {\it Secure Linux} no es una soluci\'on
completa, s\'{\i} que a\~nade un nivel extra de seguridad en este sentido,
haciendo que un atacante que pretenda utilizar un {\it buffer overflow} contra
nuestro sistema tenga que utilizar c\'odigo m\'as complicado para hacerlo.
\item Enlaces restringidos en {\tt /tmp}\\
Con esta caracter\'{\i}stica, {\it Secure Linux} intenta que los usuarios sin
privilegios puedan crear enlaces en {\tt /tmp/} sobre ficheros que no les
pertenecen, eliminando as\'{\i} ciertos problemas de seguridad que afectan a
algunos sistemas Linux, relacionados principalmente con condiciones de carrera 
en el acceso a ficheros.
\item Tuber\'{\i}as restringidas en {\tt /tmp}\\
Esta opci\'on no permite a los usuarios escribir en tuber\'{\i}as ({\it fifos})
que no le pertenezcan a \'el o al {\it root} en directorios con el bit de
permanencia activo, como {\tt /tmp}. De esta forma se evitan ciertos ataques de 
{\it Data Spoofing}.
\item {\tt /proc} restringido\\
Esta es quiz\'as la caracter\'{\i}stica m\'as \'util de este parche, aparte de
la m\'as visible para el usuario normal. Permite que los usuarios no tengan un
acceso completo al directorio {\tt /proc/} (que recordemos permite un acceso
a estructuras de datos del n\'ucleo, como la tabla de procesos, desde el 
espacio de usuario) a no ser que se encuentren en un determinado grupo con el
nivel de privilegio suficiente. De esta forma se consigue un aumento 
espectacular en la privacidad del sistema, ya que por ejemplo los usuarios 
s\'olo podr\'an ver sus procesos al ejecutar un {\tt ps aux}, y tampoco 
tendr\'an acceso al estado de las conexiones de red v\'{\i}a {\tt netstat}; 
as\'{\i}, \'ordenes como {\tt ps} o {\tt top} s\'olo muestran informaci\'on 
relativa a los procesos de qui\'en las ejecuta, a no ser que esta persona sea 
el administrador o un usuario perteneciente al grupo 0.
\end{itemize}
\subsubsection{Auditd}
El demonio {\tt auditd} permite al administrador de un sistema Linux recibir
la informaci\'on de auditor\'{\i}a de seguridad que el n\'ucleo genera, a 
trav\'es del fichero {\tt /proc/audit}, filtrarla y almacenarla en ficheros.
Esta informaci\'on tiene el siguiente formato:
\begin{quote}
{\tt AUDIT\_CONNECT pid ruid shost sport dhost dport}\\
Conexi\'on desde la m\'aquina al {\it host} remoto {\tt dhost}.\\
{\tt AUDIT\_ACCEPT pid ruid shost sport dhost dport}\\
Conexi\'on desde el {\it host} remoto {\tt dhost} a la m\'aquina.\\
{\tt AUDIT\_LISTEN pid ruid shost sport}\\
El puerto indicado est\'a esperando peticiones de servicio.\\
{\tt AUDIT\_OPEN pid ruid file}\\
Se ha abierto el fichero {\tt file}.\\
{\tt AUDIT\_SETUID pid old\_ruid ruid euid}\\
Se ha llamado con \'exito a {\tt setuid()}, modificando el {\sc UID} de {\tt 
ruid} a {\tt euid}.\\
{\tt AUDIT\_EXEC pid ruid file}\\
Se ha ejecutado el fichero {\tt file}.\\
{\tt AUDIT\_MODINIT pid ruid file}\\
Se ha insertado en el {\it kernel} el m\'odulo {\tt file}.
\end{quote}
Al leer la informaci\'on de {\tt /proc/audit}, el demonio {\tt auditd} lee las
reglas de filtrado del fichero {\tt /etc/security/audit.conf}, comparando los
{\it flags}, {\sc pid} y {\sc ruid} ({\it Real User IDentifier}) recibidos con
cada una de las reglas del archivo de configuraci\'on hasta encontrar la
apropiada para tratar el evento. Una vez que el demonio {\tt auditd} ha 
encontrado el fichero donde almacenar la informaci\'on recibida, la guarda
en \'el con un formato legible.
