\chapter{Copias de seguridad}
\section{Introducci\'on}
Las copias de seguridad del sistema son con frecuencia el \'unico mecanismo
de recuperaci\'on que poseen los administradores para restaurar una m\'aquina
que por cualquier motivo -- no siempre se ha de tratar de un pirata que borra
los discos -- ha perdido datos. Por tanto, una correcta pol\'{\i}tica para 
realizar, almacenar y, en caso de ser necesario, restaurar los {\it backups} es
vital en la planificaci\'on de seguridad de todo sistema.\\
\\Asociados a los {\it backups} suelen existir unos problemas de seguridad 
t\'{\i}picos en muchas organizaciones. Por ejemplo, uno de estos problemas es la
no verificaci\'on de las copias realizadas: el administrador ha dise\~nado una
pol\'{\i}tica de copias de seguridad correcta, incluso exhaustiva en muchas
ocasiones, pero nadie se encarga de verificar estas copias\ldots hasta que es
necesario restaurar ficheros de ellas. Evidentemente, cuando llega ese momento
el responsable del sistema se encuentra ante un gran problema, problema que se
podr\'{\i}a haber evitado simplemente teniendo la precauci\'on de verificar el
correcto funcionamiento de los {\it backups}; por supuesto, restaurar una 
copia completa para comprobar que todo es correcto puede ser demasiado trabajo
para los m\'etodos habituales de operaci\'on, por lo que lo que se suele hacer
es tratar de recuperar varios ficheros aleatorios del {\it backup}, asumiendo
que si esta recuperaci\'on funciona, toda la copia es correcta.\\
\\Otro problema cl\'asico de las copias de seguridad es la pol\'{\i}tica de 
etiquetado a seguir. Son pocos los administradores que no etiquetan los 
dispositivos de {\it backup}, algo que evidentemente no es muy \'util: si llega
el momento de recuperar ficheros, el operador ha de ir cinta por cinta (o
disco por disco, o CD-ROM por CD-ROM\ldots) tratando de averiguar d\'onde se
encuentran las \'ultimas versiones de tales archivos. No obstante, muchos 
administradores siguen una pol\'{\i}tica de etiquetado exhaustiva, 
proporcionando todo tipo de detalles sobre el contenido exacto de cada medio;
esto, que en principio puede parecer una posici\'on correcta, no lo es tanto:
si por cualquier motivo un atacante consigue sustraer una cinta, no tiene que
investigar mucho para conocer su contenido exacto, lo que le proporciona 
acceso a informaci\'on muy concreta (y muy valiosa) de nuestros sistemas sin ni 
siquiera penetrar en ellos. La pol\'{\i}tica correcta para etiquetar los {\it
backups} ha de ser tal que un administrador pueda conocer la situaci\'on exacta 
de cada fichero, pero que no suceda lo mismo con un atacante que roba el medio
de almacenamiento; esto se consigue, por ejemplo, con c\'odigos impresos en 
cada etiqueta, c\'odigos cuyo significado sea conocido por los operadores de
copias de seguridad pero no por un potencial atacante.\\
\\La ubicaci\'on final de las copias de seguridad tambi\'en suele ser err\'onea
en muchos entornos; generalmente, los operadores tienden a almacenar los {\it
backups} muy cerca de los sistemas, cuando no en la misma sala. Esto, que se
realiza para una mayor comodidad de los t\'ecnicos y para recuperar ficheros
f\'acilmente, es un grave error: no hay m\'as que imaginar cualquier desastre
del entorno, como un incendio o una inundaci\'on, para hacerse una idea de lo
que les suceder\'{\i}a a los {\it backups} en esos casos. Evidentemente, se
destruir\'{\i}an junto a los sistemas, por lo que nuestra organizaci\'on
perder\'{\i}a toda su informaci\'on; no obstante, existen voces que reivindican
como correcto el almacenaje de las copias de seguridad junto a los propios 
equipos, ya que as\'{\i} se consigue centralizar un poco la seguridad 
(protegiendo una \'unica estancia se salvaguarda tanto las m\'aquinas como las
copias). Lo habitual en cualquier organizaci\'on suele ser un t\'ermino 
medio entre ambas aproximaciones: por ejemplo, podemos tener un juego de copias
de seguridad completas en un lugar diferente a la sala de operaciones, pero
protegido y aislado como esta, y un juego para uso diario en la propia sala,
de forma que los operadores tengan f\'acil la tarea de recuperar ficheros;
tambi\'en podemos utilizar armarios ign\'{\i}fugos que requieran de ciertas 
combinaciones para su apertura (combinaciones que s\'olo determinado personal 
ha de conocer), si decidimos almacenar todos los {\it backups} en la misma 
estancia que los equipos.\\
\\Por \'ultimo, >qu\'e almacenar? Obviamente debemos realizar copias de 
seguridad de los
archivos que sean \'unicos a nuestro sistema; esto suele incluir directorios
como {\tt /etc/}, {\tt /usr/local/} o la ubicaci\'on de los directorios de
usuario (dependiendo del Unix utilizado, {\tt /export/home/}, {\tt /users/}, 
{\tt /home/}\ldots). Por supuesto, realizar una copia de seguridad de
directorios como {\tt /dev/} o {\tt /proc/} no tiene ninguna utilidad, de la
misma forma que no la tiene realizar {\it backups} de directorios del sistema
como {\tt /bin/} o {\tt /lib/}: su contenido est\'a almacenado en la 
distribuci\'on original del sistema operativo (por ejemplo, los CD-ROMs que 
utilizamos para instalarlo).
\section{Dispositivos de almacenamiento}
Existen multitud de dispositivos diferentes donde almacenar nuestras copias de
seguridad, desde un simple disco flexible hasta unidades de cinta de \'ultima
generaci\'on. Evidentemente, cada uno tiene sus ventajas y sus inconvenientes,
pero utilicemos el medio que utilicemos, \'este ha de cumplir una norma
b\'asica: ha de ser {\bf est\'andar}. Con toda probabilidad muchos 
administradores pueden presumir de poseer los {\it streamers} m\'as modernos,
con unidades de cinta del tama\~no de una cajetilla de tabaco que son capaces
de almacenar gigas y m\'as gigas de informaci\'on; no obstante, utilizar 
dispositivos de \'ultima generaci\'on para guardar los {\it backups} de nuestros
sistemas puede convertirse en un problema: >qu\'e sucede si necesitamos 
recuperar datos y no disponemos de esa unidad lectora tan avanzada? Imaginemos
simplemente que se produce un incendio y desaparece una m\'aquina, y con ella
el dispositivo que utilizamos para realizar copias de seguridad. En esta 
situaci\'on, o disponemos de otra unidad id\'entica a la perdida, o recuperar
nuestra informaci\'on va a ser algo dif\'{\i}cil. Si en lugar de un dispositivo
moderno, r\'apido y seguramente muy fiable, pero incompatible con el resto,
hubi\'eramos utilizado algo m\'as habitual (una cinta de 8mm., un CD-ROM, o 
incluso un disco duro) no tendr\'{\i}amos problemas en leerlo desde cualquier
sistema Unix, sin importar el {\it hardware} sobre el que trabaja.\\
\\Aqu\'{\i} vamos a comentar algunos de los dispositivos de copia de seguridad
m\'as utilizados hoy en d\'{\i}a; de todos ellos (o de otros, no listados
aqu\'{\i}) cada administrador ha de elegir el que m\'as se adapte a sus 
necesidades. En la tabla \ref{devices} se muestra una comparativa de todos
ellos.\\
\\{\bf Discos flexibles}\\
S\'{\i}, aunque los cl\'asicos {\it diskettes} cada d\'{\i}a se utilicen menos,
a\'un se pueden considerar un dispositivo donde almacenar copias de seguridad.
Se trata de un medio muy barato y portable entre diferentes operativos 
(evidentemente, esta portabilidad existe si utilizamos el disco como un 
dispositivo secuencial, sin crear sistemas de ficheros). Por contra, su 
fiabilidad es muy baja: la informaci\'on almacenada se puede borrar f\'acilmente
si el disco se aproxima a aparatos que emiten cualquier tipo de radiaci\'on,
como un tel\'efono m\'ovil o un detector de metales. Adem\'as, la capacidad de
almacenamiento de los {\it floppies} es muy baja, de poco m\'as de 1 MB por
unidad; esto hace que sea casi imposible utilizarlos como medio de 
{\it backup} de grandes cantidades de datos, restringiendo su uso a ficheros
individuales.\\
\\Un {\it diskette} puede utilizarse creando en \'el un sistema de ficheros,
mont\'andolo bajo un directorio, y copiando en los archivos a guardar. Por
ejemplo, podemos hacer un {\it backup} de nuestro fichero de claves en un disco 
flexible de esta forma.
\begin{quote}
\begin{verbatim}
luisa:~# mkfs -t ext2 /dev/fd0
mke2fs 1.14, 9-Jan-1999 for EXT2 FS 0.5b, 95/08/09
Linux ext2 filesystem format
Filesystem label=
360 inodes, 1440 blocks
72 blocks (5.00%) reserved for the super user
First data block=1
Block size=1024 (log=0)
Fragment size=1024 (log=0)
1 block group
8192 blocks per group, 8192 fragments per group
360 inodes per group

Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done
luisa:~# mount -t ext2 /dev/fd0 /mnt/
luisa:~# cp /etc/passwd /mnt/
luisa:~# umount /mnt/
luisa:~# 
\end{verbatim}
\end{quote}
Si quisi\'eramos recuperar el archivo, no tendr\'{\i}amos m\'as que montar de
nuevo el {\it diskette} y copiar el fichero en su ubicaci\'on original. No 
obstante, este uso de los discos flexibles es minoritario; es m\'as habitual
utilizarlo como un dispositivo secuencial (como una cinta), sin crear en \'el
sistemas de ficheros -- que quiz\'as son incompatibles entre diferentes clones
de Unix -- sino accediendo directamente al dispositivo. Por ejemplo, si de
nuevo queremos hacer un {\it backup} de nuestro fichero de {\it passwords}, pero
siguiendo este modelo de trabajo, podemos utilizar la orden {\tt tar} 
(comentada m\'as adelante) para conseguirlo:
\begin{quote}
\begin{verbatim}
luisa:~# tar cvf /dev/fd0 /etc/passwd
tar: Removing leading `/' from absolute path names in the archive
etc/passwd
luisa:~#
\end{verbatim}
\end{quote}
Para recuperar ahora el archivo guardado, volvemos a utilizar la orden {\tt
tar} indicando como contenedor la unidad de disco correspondiente:
\begin{quote}
\begin{verbatim}
luisa:~# tar xvf /dev/fd0 
etc/passwd
luisa:~#
\end{verbatim}
\end{quote}
{\bf Discos duros}\\
Es posible utilizar una unidad de disco duro completa (o una partici\'on) 
para realizar copias de seguridad; como suced\'{\i}a con los discos flexibles,
podemos crear un sistema de ficheros sobre la unidad o la partici\'on 
correspondiente, montarla, y copiar los ficheros que nos interese guardar en 
ella (o recuperarlos). De la misma forma, tambi\'en podemos usar la unidad como
un dispositivo secuencial y convertirlo en un contenedor {\tt tar} o {\tt cpio};
en este caso hemos de estar muy atentos a la hora de especificar la unidad, ya
que es muy f\'acil equivocarse de dispositivo y machacar completamente la
informaci\'on de un disco completo (antes tambi\'en pod\'{\i}a suceder, pero
ahora la probabilidad de error es m\'as alta). Por ejemplo, si en lugar del
nombre del dispositivo correcto (supongamos {\tt /dev/hdc}) especificamos otro
(como {\tt /dev/hdd}), estaremos destruyendo la informaci\'on guardada en 
este \'ultimo.\\
\\Algo muy interesante en algunas situaciones es utilizar como dispositivo de
copia un disco duro id\'entico al que est\'a instalado en nuestro sistema, y 
del que deseamos hacer el {\it backup}; en este caso es muy sencillo hacer una
copia de seguridad completa. Imaginemos por ejemplo que {\tt /dev/hda} y {\tt 
/dev/hdc} son
dos discos exactamente iguales; en este caso, si queremos conseguir una
imagen especular del primero sobre el segundo, no tenemos m\'as que utilizar
la orden {\tt dd} con los par\'ametros adecuados:
\begin{quote}
\begin{verbatim}
luisa:~# dd if=/dev/hda of=/dev/hdc bs=2048
1523+0 records in
1523+0 records out
luisa:~#
\end{verbatim}
\end{quote}
{\bf Cintas magn\'eticas}\\
Las cintas magn\'eticas han sido durante a\~nos (y siguen siendo en la 
actualidad) el dispositivo de {\it backup} por excelencia. Las m\'as antiguas,
las cintas de nueve pistas, son las que mucha gente imagina al hablar de este
medio: un elemento circular con la cinta enrollada en \'el; este tipo de 
dispositivos se utiliz\'o durante mucho tiempo, pero en la actualidad est\'a en
desuso, ya que a pesar de su alta fiabilidad y su relativa velocidad de trabajo,
la capacidad de este medio es muy limitada (de hecho, las m\'as avanzadas son 
capaces de almacenar menos de 300 MB., algo que no es suficiente en la mayor
parte de sistemas actuales).\\
\\Despu\'es de las cintas de 9 pistas aparecieron las cintas de un cuarto de
pulgada (denominadas {\sc qic}), mucho m\'as peque\~nas en tama\~no que las
anteriores y con una capacidad m\'axima de varios {\it Gigabytes} (aunque la
mayor parte de ellas almacenan menos de un {\it Giga}); se trata de cintas
m\'as baratas que las de 9 pistas, pero tambi\'en m\'as lentas. El medio ya no
va descubierto, sino que va cubierto de una envoltura de pl\'astico.\\
\\A finales de los ochenta aparece un nuevo modelo de cinta que releg\'o a las
cintas {\sc qic} a un segundo plano y que se ha convertido en el medio m\'as
utilizado en la actualidad: se trata de las cintas de 8mm., dise\~nadas en su
origen para almacenar v\'{\i}deo. Estas cintas, del tama\~no de una {\it 
cassette} de audio, tienen una capacidad de hasta cinco {\it Gigabytes}, lo que
las hace perfectas para la mayor\'{\i}a de sistemas: como toda la informaci\'on
a salvaguardar cabe en un mismo dispositivo, el operador puede introducir la
cinta en la unidad del sistema, ejecutar un sencillo {\it shellscript}, y dejar
que el {\it backup} se realice durante toda la noche; al d\'{\i}a siguiente no
tiene m\'as que verificar que no ha habido errores, retirar la cinta de la 
unidad, y etiquetarla correctamente antes de guardarla. De esta forma se
consigue que el proceso de copia de seguridad sea sencillo y efectivo.\\
\\No obstante, este tipo de cintas tiene un grave inconveniente: como hemos 
dicho, originalmente estaban dise\~nadas para almacenar v\'{\i}deo, y se basan
en la misma tecnolog\'{\i}a para registrar la informaci\'on. Pero con una 
importante diferencia (\cite{kn:pep94}): mientras que perder unos {\it bits} de
la cinta donde hemos grabado los mejores momentos de nuestra \'ultima fiesta no 
tiene mucha importancia, si esos mismos {\it bits} los perdemos de una cinta de
{\it backup} el resto de su contenido puede resultar inservible. Es m\'as, es
probable que despu\'es de unos cuantos usos (incluidas las lecturas) la cinta
se da\~ne irreversiblemente. Para intentar solucionar estos problemas 
aparecieron las cintas {\sc dat}, de 4mm., dise\~nadas ya en origen para 
almacenar datos; estos dispositivos, algo m\'as peque\~nos que las cintas de
8mm. pero con una capacidad similar, son el mejor sustituto de las cintas
antiguas: son mucho m\'as resistentes que \'estas, y adem\'as relativamente
baratas (aunque algo m\'as caras que las de 8mm.).\\
\\Hemos dicho que en las cintas de 8mm. (y en las de 4mm.) se pueden almacenar 
hasta 5 GB. de informaci\'on. No obstante, algunos fabricantes 
anuncian capacidades de hasta 14 GB. utilizando compresi\'on {\it hardware}, 
sin dejar muy claro si las cintas utilizadas son est\'andar o no 
(\cite{kn:fri95}); evidentemente, esto puede llevarnos a problemas de los que
antes hemos comentado: >qu\'e sucede si necesitamos recuperar datos y no 
disponemos de la unidad lectora original? Es algo vital que nos aseguremos la
capacidad de una f\'acil recuperaci\'on en caso de p\'erdida de nuestros datos
(este es el objetivo de los {\it backups} al fin y al cabo), por lo que 
quiz\'as no es conveniente utilizar esta compresi\'on {\it hardware} a no ser 
que sea estrictamente necesario y no hayamos podido aplicar otra soluci\'on.\\
\\{\bf CD-ROMs}\\
En la actualidad s\'olo se utilizan cintas magn\'eticas en equipos antiguos
o a la hora de almacenar grandes cantidades de datos -- del orden de {\it
Gigabytes}. Hoy en d\'{\i}a, muchas m\'aquinas Unix poseen unidades grabadoras
de CD-ROM, un {\it hardware} barato y, lo que es m\'as importante, que utiliza
dispositivos de muy bajo coste y con una capacidad de almacenamiento suficiente
para muchos sistemas: con una unidad grabadora, podemos almacenar m\'as de 650
{\it Megabytes} en un CD-ROM que cuesta menos de 150 pesetas. Por estos motivos,
muchos administradores se decantan por realizar sus copias de seguridad en uno
o varios CD-ROMs; esto es especialmente habitual en estaciones de trabajo o en
PCs de sobremesa corriendo alg\'un clon de Unix (Linux, Solaris o FreeBSD por
regla general), donde la cantidad de datos a salvaguardar no es muy elevada y
se ajusta a un par de unidades de CD, cuando no a una sola.\\
\\En el punto \ref{cdrom} se comenta el mecanismo para poder grabar en un
CD-ROM; aunque los ejemplos que comentaremos son b\'asicos, existen multitud
de posibilidades para trabajar con este medio. Por ejemplo, podemos utilizar
dispositivos CD-RW, similares a los anteriores pero que permiten borrar la
informaci\'on almacenada y volver a utilizar el dispositivo (algo muy \'util en 
situaciones donde reutilizamos uno o varios juegos de copias), o
utilizar medios con una mayor capacidad de almacenamiento (CD-ROMs de 80 
minutos, capaces de almacenar hasta 700 MB.); tambi\'en es muy \'util lo
que se conoce como la grabaci\'on multisesi\'on, algo que nos va a permitir
ir actualizando nuestras copias de seguridad con nuevos archivos sin perder la
informaci\'on que hab\'{\i}amos guardado previamente.
\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Dispositivo & Fiabilidad & Capacidad & Coste/MB\\
\hline\hline
{\it Diskette} & Baja & Baja & Alto\\
\hline
CD-ROM & Media & Media & Bajo\\
\hline
Disco duro & Alta & Media/Alta & Medio.\\
\hline
Cinta 8mm. & Media & Alta & Medio.\\
\hline
Cinta DAT & Alta & Alta & Medio.\\
\hline
\end{tabular}
\caption{Comparaci\'on de diferentes medios de almacenamiento secundario.}
\label{devices}
\end{center}
\end{table}
\section{Algunas \'ordenes para realizar copias de seguridad}
Aunque muchos clones de Unix ofrecen sus propias herramientas para realizar
copias de seguridad de todo tipo (por ejemplo, tenemos {\tt mksysb} y {\tt 
savevg/restvg} en AIX, {\tt fbackup} y {\tt frecover} en HP-UX, {\tt bru} en
IRIX, {\tt fsphoto} en SCO Unix, {\tt ufsdump/ufsrestore} en Solaris\ldots), 
casi todas estas herramientas suelen presentar un
grave problema a la hora de recuperar archivos: se trata de {\it software}
propietario, por lo que si queremos restaurar total o parcialmente archivos 
almacenados con este tipo de programas, necesitamos el propio programa para 
hacerlo. En determinadas situaciones, esto no es posible o es muy dif\'{\i}cil: 
imaginemos un departamento que dispone de s\'olo una estaci\'on Silicon 
Graphics corriendo IRIX y pierde todos los datos de un disco, incluida la 
utilidad {\tt bru}; si ha utilizado esta herramienta para realizar {\it 
backups}, necesitar\'a otra estaci\'on con el mismo operativo para poder 
restaurar estas copias, lo que obviamente puede ser problem\'atico.\\
\\Por este motivo, muchos administradores utilizan herramientas est\'andar para
realizar las copias de seguridad de sus m\'aquinas; estas herramientas suelen
ser tan simples como un {\it shellscript} que se planifica para que 
autom\'aticamente haga {\it backups} utilizando \'ordenes como {\tt tar} o {\tt 
cpio}, programas habituales en cualquier clon de Unix y que no presentan 
problemas de interoperabilidad entre diferentes operativos. De esta forma, si en
la estaci\'on Silicon Graphics del ejemplo anterior se hubiera utilizado {\tt
tar} para realizar las copias de seguridad, \'estas se podr\'{\i}an restaurar
sin problemas desde una m\'aquina {\sc sparc} corriendo Solaris, y transferir
los ficheros de nuevo a la Silicon.
\subsection{{\tt dump}/{\tt restore}}
La herramienta cl\'asica para realizar {\it backups} en entornos Unix es desde
hace a\~nos {\tt dump}, que vuelca sistemas de ficheros completos (una 
partici\'on o una partici\'on virtual en los sistemas que las soportan, como
Solaris); {\tt restore} se utiliza para recuperar archivos de
esas copias. Se trata de una utilidad disponible en la mayor\'{\i}a de clones
del sistema operativo\footnote{HP-UX, IRIX, SunOS, Linux\ldots en Solaris se 
llama {\tt ufsdump} y en AIX {\tt backup}.}, potente (no diremos `sencilla') y 
lo m\'as importante: las 
copias son completamente compatibles entre Unices, de forma que por ejemplo 
podemos restaurar un {\it backup} realizado en IRIX en un sistema HP-UX. 
Adem\'as, como veremos luego, la mayor parte de las versiones de {\tt dump} 
permiten realizar copias
de seguridad sobre m\'aquinas remotas directamente desde l\'{\i}nea de \'ordenes
(en el caso que la variante de nuestro sistema no lo permita, podemos utilizar
{\tt rdump}/{\tt rrestore}) sin m\'as que indicar el nombre de m\'aquina 
precediendo al dispositivo donde se ha de realizar la copia.\\
\\La sintaxis general de la orden {\tt dump} es
\tt
\begin{center}
dump opciones argumentos fs
\end{center}
\rm
donde {\tt `opciones'} son las opciones de la copia de seguridad, {\tt 
`argumentos'} son los argumentos de dichas opciones, y {\tt `fs'} es el sistema 
de ficheros a salvaguardar. Se trata de una sintaxis algo peculiar: mientras
que lo habitual en Unix es especificar cada argumento a continuaci\'on de
la opci\'on adecuada (por ejemplo, {\tt `find . -perm 700 -type f'} indica un
argumento {\tt `700'} para la opci\'on {\tt `perm'} y uno {\tt `f'} para {\tt
`type'}), en la orden {\tt dump} primero especificamos toda la lista de
opciones y a continuaci\'on todos sus argumentos; no todas las opciones 
necesitan un argumento, y adem\'as la lista de argumentos tiene que
corresponderse exactamente, en orden y n\'umero, con las opciones que los
necesitan (por ejemplo, si {\tt `find'} tuviera una sintaxis similar, la orden 
anterior se habr\'{\i}a tecleado como {\tt `find . -perm -type 700 f'}). AIX
y Linux son los \'unicos Unices donde la sintaxis de {\tt dump} (recordemos que en el primero se denomina {\tt backup}) es la habitual.\\
\\Las opciones de {\tt `dump'} m\'as utilizadas son las que se muestran en la
tabla \ref{dumpops}; en las p\'aginas {\tt man} de cada clon de Unix se suelen
incluir recomendaciones sobre par\'ametros espec\'{\i}ficos para modelos de
cintas determinados, por lo que como siempre es m\'as que recomendable su
consulta. Fij\'andonos en la tabla, podemos ver que la opci\'on {\tt `u'}
actualiza el archivo {\tt /etc/dumpdates} tras realizar una copia de seguridad
con \'exito; es conveniente que este archivo exista antes de utilizar {\tt dump}
por primera vez (podemos crearlo con la orden {\tt touch}), ya que si no existe
no se almacenar\'a informaci\'on sobre las copias de seguridad de cada sistema
de ficheros (informaci\'on necesaria, por ejemplo, para poder realizar {\it
backups} progresivos). En este archivo {\tt dump} -- la propia orden lo hace,
el administrador no necesita modificar el archivo a mano\ldots y no debe 
hacerlo -- registra informaci\'on de las copias de cada sistema de archivos, su 
nivel, y la fecha de realizaci\'on, de forma que su aspecto puede ser similar 
al siguiente:
\begin{quote}
\begin{verbatim}
anita:~# cat /etc/dumpdates
/dev/dsk/c0d0s6   0 Thu Jun 22 05:34:20 CEST 2000
/dev/dsk/c0d0s7   2 Wed Jun 21 02:53:03 CEST 2000
anita:~#
\end{verbatim}
\end{quote}
\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Opci\'on & Acci\'on realizada & Argumento\\
\hline\hline
0--9 & Nivel de la copia de seguridad & NO\\
\hline
u & Actualiza {\tt /etc/dumpdates} al finalizar el {\it backup} & NO\\
\hline
f & Indica una cinta diferente de la usada por defecto & S\'I\\
\hline
b & Tama\~no de bloque & S\'I\\
\hline
c & Indica que la cinta destino es un cartucho & NO\\
\hline
W & Ignora todas las opciones excepto el nivel del {\it backup} & NO\\
\hline
\end{tabular}
\caption{Opciones de la orden {\tt dump}}
\label{dumpops}
\end{center}
\end{table}
El uso de {\tt dump} puede ser excesivamente complejo, especialmente en sistemas
antiguos donde es incluso necesario especificar la densidad de la cinta en
{\it bytes} por pulgada o su longitud en pies; no obstante, hoy en d\'{\i}a la 
forma m\'as habitual
de invocar a esta orden es {\tt `dump [1-9]ucf cinta fs'}, es decir, una
copia de seguridad del sistema de ficheros recibido como argumento, de un 
determinado nivel y sobre la unidad de cinta especificada. Por ejemplo para
realizar una copia de seguridad completa sobre la unidad de cinta {\tt 
/dev/rmt} de la partici\'on l\'ogica {\tt /dev/dsk/c0d0s7}, en Solaris podemos
utilizar la orden siguiente (podemos ver que nos muestra mucha informaci\'on
sobre el progreso de nuestra copia de seguridad en cada momento):
\begin{quote}
\begin{verbatim}
anita:~# ufsdump 0cuf /dev/rmt /dev/dsk/c0d0s7
DUMP: Date of this level 0 dump: Thu Jun 22 10:03:28 2000
DUMP: Date of last level 0 dump: the epoch
DUMP: Dumping /dev/dsk/c0d0s7 (/export/home) to /dev/rmt
DUMP: mapping (Pass I) [regular files]
DUMP: mapping (Pass II) [directories]
DUMP: estimated 24523 blocks (118796KB)
DUMP: Writing 63 Kilobyte records
DUMP: dumping (Pass III) [directories]
DUMP: dumping (Pass IV) [regular files]
DUMP: level 0 dump on Thu Jun 22 10:05:31 CEST 2000
DUMP: 24550 blocks (118927KB) on 1 volume
DUMP: DUMP IS DONE
anita:~#
\end{verbatim}
\end{quote}
Para realizar copias remotas, como hemos dicho antes, no tenemos m\'as que
anteponer el nombre del sistema donde deseemos realizar el volcado al nombre
del dispositivo donde se va a almacenar, separado de \'este por el car\'acter
{\tt `:'}; opcionalmente se puede indicar el nombre de usuario en el sistema
remoto, separ\'andolo del nombre de m\'aquina por {\tt `@'}:
\begin{quote}
\begin{verbatim}
anita:~# ufsdump 0cuf toni@luisa:/dev/st0 /dev/dsk/c0d0s7
\end{verbatim}
\end{quote}
Si estamos utilizando {\tt rdump}, hemos de tener definido un nombre de 
m\'aquina denominado {\tt \\`dumphost'} en nuestro archivo {\tt /etc/hosts}, que
ser\'a el sistema donde se almacene la copia remota. De cualquier forma (usemos
{\tt dump}, {\tt ufsdump} o {\tt rdump}), el {\it host} remoto ha de 
considerarnos como una m\'aquina de confianza (a trav\'es de {\tt 
/etc/hosts.equiv} o {\tt .rhosts}), con las consideraciones de seguridad que 
esto implica.\\
\\>C\'omo restaurar los {\it backups} realizados con {\tt dump}? Para esta
tarea se utiliza la utilidad {\tt restore} ({\tt ufsrestore} en Solaris), capaz
de extraer ficheros individuales, directorios o sistemas de archivos completos.
La sintaxis de esta orden es 
\tt
\begin{center}
restore opciones argumentos archivos
\end{center}
\rm
donde {\tt `opciones'} y {\tt `argumentos'} tienen una forma similar a
{\tt `dump'} (es decir, toda la lista de opciones seguida de toda la lista de
argumentos de las mismas, excepto en AIX y Linux, donde la notaci\'on es la
habitual), y {\tt `archivos'} evidentemente representa una
lista de directorios y ficheros para restaurar. En la tabla \ref{restoreops}
se muestra un resumen de las opciones m\'as utilizadas.
\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Opci\'on & Acci\'on realizada & Argumento\\
\hline\hline
r & Restaura la cinta completa & NO\\
\hline
f & Indica el dispositivo o archivo donde est\'a el {\it backup} & S\'I\\
\hline
i & Modo interactivo & NO\\
\hline
x & Extrae los archivos y directorios desde el directorio actual & NO\\
\hline
t & Imprime los nombres de los archivos de la cinta & NO\\
\hline
\end{tabular}
\caption{Opciones de la orden {\tt restore}}
\label{restoreops}
\end{center}
\end{table}
Por ejemplo, imaginemos que deseamos restaurar varios archivos de un {\it 
backup} guardado en el fichero {\tt `backup'}; en primer lugar podemos consultar
el contenido de la cinta con una orden como la siguiente (en Linux):
\begin{quote}
\begin{verbatim}
luisa:~# restore -t -f backup>contenido
Level 0 dump of /home on luisa:/dev/hda3
Label: none
luisa:~# cat contenido|more
Dump   date: Fri Jun 23 06:01:26 2000
Dumped from: the epoch
         2      .
        11      ./lost+found
     30761      ./lost+found/#30761
     30762      ./lost+found/#30762
     30763      ./lost+found/#30763
     30764      ./lost+found/#30764
     30765      ./lost+found/#30765
     30766      ./lost+found/#30766
     30767      ./lost+found/#30767
      4097      ./ftp
      8193      ./ftp/bin
      8194      ./ftp/bin/compress
      8195      ./ftp/bin/cpio
      8196      ./ftp/bin/gzip
      8197      ./ftp/bin/ls
      8198      ./ftp/bin/sh
      8199      ./ftp/bin/tar
      8200      ./ftp/bin/zcat
     12289      ./ftp/etc
     12290      ./ftp/etc/group
Broken pipe
luisa:~#
\end{verbatim}
\end{quote}
Una vez que conocemos el contenido de la copia de seguridad -- y por tanto el
nombre del archivo o archivos a restaurar -- podemos extraer el fichero que nos
interese con una orden como
\begin{quote}
\begin{verbatim}
luisa:~# restore -x -f backup ./ftp/bin/tar     
You have not read any tapes yet.
Unless you know which volume your file(s) are on you should start
with the last volume and work towards the first.
Specify next volume #: 1
set owner/mode for '.'? [yn] n
luisa:~# ls -l ftp/bin/tar 
---x--x--x   1 root     root       110668 Mar 21  1999 ftp/bin/tar
luisa:~#
\end{verbatim}
\end{quote}
Como podemos ver, la extracci\'on se ha realizado a partir del directorio 
de trabajo actual; si quisi\'eramos extraer archivos en su ubicaci\'on original
deber\'{\i}amos hacerlo desde el directorio adecuado, o, en algunas versiones
de {\tt restore}, especificar dicho directorio en la l\'{\i}nea de \'ordenes.\\
\\Una opci\'on muy interesante ofrecida por {\tt restore} es la posibilidad de
trabajar en modo interactivo, mediante la opci\'on {\tt `i'}; en este modo, al
usuario se le ofrece un {\it prompt} desde el cual puede, por ejemplo, listar
el contenido de una cinta, cambiar de directorio de trabajo o extraer archivos.
El siguiente ejemplo (tambi\'en sobre Linux) ilustra esta opci\'on:
\begin{quote}
\begin{verbatim}
luisa:~# restore -i -f backup
restore > help
Available commands are:
        ls [arg] - list directory
        cd arg - change directory
        pwd - print current directory
        add [arg] - add `arg' to list of files to be extracted
        delete [arg] - delete `arg' from list of files to be extracted
        extract - extract requested files
        setmodes - set modes of requested directories
        quit - immediately exit program
        what - list dump header information
        verbose - toggle verbose flag (useful with ``ls'')
        help or `?' - print this list
If no `arg' is supplied, the current directory is used
restore > ls
.:
ftp/        httpd/      httpsd/     lost+found/ samba/      toni/

restore > add httpd
restore > extract
You have not read any tapes yet.
Unless you know which volume your file(s) are on you should start
with the last volume and work towards the first.
Specify next volume #: 1
set owner/mode for '.'? [yn] n
restore > quit
luisa:~# 
\end{verbatim}
\end{quote}
Como podemos ver, hemos consultado el contenido de la copia de seguridad, 
a\~nadido el directorio {\tt httpd/} a la lista de ficheros a extraer 
(inicialmente vacia), y extra\'{\i}do dicho directorio a partir del actual. 
Este uso de {\tt restore} proporciona una gran comodidad y facilidad de uso, ya 
que las \'ordenes en modo interactivo son muy sencillas.
\subsection{La orden {\tt tar}}
La utilidad {\tt tar} ({\it Tape Archiver}) es una herramienta de f\'acil 
manejo disponible en todas las versiones de Unix que permite volcar ficheros
individuales o directorios completos en un \'unico fichero; inicialmente fu\'e 
dise\~nada para crear archivos de cinta (esto es, para transferir archivos de 
un disco a una cinta magn\'etica y viceversa), aunque en la actualidad casi 
todas sus versiones pueden utilizarse para copiar a cualquier dipositivo o
fichero, denominado `contenedor'. Su principal desventaja es que, bajo ciertas 
condiciones,
si falla una porci\'on del medio (por ejemplo, una cinta) se puede perder toda
la copia de seguridad; adem\'as, {\tt tar} no es capaz de realizar por s\'{\i}
mismo m\'as que copias de seguridad completas, por lo que hace falta un poco
de programaci\'on {\it shellscripts} para realizar copias progresivas o 
diferenciales.\\
\\En la tabla \ref{tarops} se muestran las opciones de {\tt tar} m\'as 
habituales; algunas de ellas no est\'an disponibles en todas las 
versiones de {\tt tar}, por lo que es recomendable consultar la p\'agina 
del manual de esta orden antes de utilizarla. Si la implementaci\'on de {\tt
tar} que existe en nuestro sistema no se ajusta a nuestras necesidades, siempre
podemos utilizar la versi\'on de {\sc gnu} ({\tt http://www.gnu.org/}), quiz\'as
la m\'as completa hoy en d\'{\i}a.
\begin{table}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Opci\'on & Acci\'on realizada\\
\hline\hline
c & Crea un contenedor\\
\hline
x & Extrae archivos de un contenedor\\
\hline
t & Testea los archivos almacenados en un contenedor\\
\hline
r & A\~nade archivos al final de un contenedor\\
\hline
v & Modo {\it verbose}\\
\hline
f & Especifica el nombre del contenedor\\
\hline
Z & Comprime o descomprime mediante {\tt compress/uncompress}\\
\hline
z & Comprime o descomprime mediante {\tt gzip}\\
\hline
p & Conserva los permisos de los ficheros\\
\hline
\end{tabular}
\caption{Opciones de la orden {\tt tar}}
\label{tarops}
\end{center}
\end{table}
En primer lugar debemos saber c\'omo crear contenedores con los archivos 
deseados; por ejemplo, imaginemos que deseamos volcar todo el directorio
{\tt /export/home/} a la unidad de cinta {\tt /dev/rmt/0}. Esto lo conseguimos
con la siguiente orden:
\begin{quote}
\begin{verbatim}
anita:~# tar cvf /dev/rmt/0 /export/home/
\end{verbatim}
\end{quote}
Como podemos ver, estamos especificando juntas las diferentes opciones
necesarias para hacer la copia de seguridad de los directorios de usuario; la
opci\'on {\tt `v'} no ser\'{\i}a necesaria, pero es \'util para ver un listado
de lo que estamos almacenando en la cinta. En muchas situaciones tambi\'en
resulta \'util comprimir la informaci\'on guardada ({\tt tar} no
comprime, s\'olo empaqueta); esto lo conseguir\'{\i}amos con las opciones
{\tt `cvzf'}.\\
\\Si en lugar de (o aparte de) un \'unico directorio con todos sus ficheros y 
subdirectorios quisi\'eramos especificar m\'ultiples archivos (o directorios),
podemos indic\'arselos uno a uno a {\tt tar} en la l\'{\i}nea de comandos; 
as\'{\i} mismo, podemos indicar un nombre de archivo contenedor en lugar de
un dispositivo. Por ejemplo, la siguiente orden crear\'a el fichero {\tt 
/tmp/backup.tar}, que contendr\'a {\tt /etc/passwd} y {\tt /etc/hosts*}: 
\begin{quote}
\begin{verbatim}
anita:~# tar cvf /tmp/backup.tar /etc/passwd /etc/hosts*
tar: Removing leading `/' from absolute path names in the archive
etc/passwd
etc/hosts
etc/hosts.allow
etc/hosts.deny
etc/hosts.equiv
anita:~# 
\end{verbatim}
\end{quote}
Una vez creado el contenedor podemos testear su contenido con la opci\'on
{\tt `t'} para comprobar la integridad del archivo, y tambi\'en para ver qu\'e
ficheros se encuentran en su interior:
\begin{quote}
\begin{verbatim}
anita:~# tar tvf /tmp/backup.tar
-rw-r--r-- root/other      965 2000-03-11 03:41 etc/passwd
-rw-r--r-- root/other      704 2000-03-14 00:56 etc/hosts
-rw-r--r-- root/other      449 2000-02-17 01:48 etc/hosts.allow
-rw-r--r-- root/other      305 1998-04-18 07:05 etc/hosts.deny
-rw-r--r-- root/other      313 1994-03-16 03:30 etc/hosts.equiv
-rw-r--r-- root/other      345 1999-10-13 03:31 etc/hosts.lpd
anita:~# 
\end{verbatim}
\end{quote}
Si lo que queremos es recuperar ficheros guardados en un contenedor 
utilizaremos las opciones {\tt `xvf'} (o {\tt `xvzf'} si hemos utilizado 
compresi\'on con {\tt gzip} a la hora de crearlo). Podemos indicar el archivo
o archivos que queremos extraer; si no lo hacemos, se extraer\'an todos:
\begin{quote}
\begin{verbatim}
anita:~# tar xvf /tmp/backup.tar etc/passwd
etc/passwd
anita:~# tar xvf /tmp/backup.tar
etc/passwd
etc/hosts
etc/hosts.allow
etc/hosts.deny
etc/hosts.equiv
etc/hosts.lpd
anita:~#
\end{verbatim}
\end{quote}
La restauraci\'on se habr\'a realizado desde el directorio de trabajo, creando
en \'el un subdirectorio {\tt etc} con los ficheros correspondientes en su
interior. Si queremos que los ficheros del contenedor sobreescriban a los que ya
existen en el sistema hemos de desempaquetarlo en el directorio adecuado, en
este caso el ra\'{\i}z.
\subsection{La orden {\tt cpio}}
{\tt cpio} ({\it Copy In/Out}) es una utilidad que permite copiar archivos a 
o desde un contenedor {\it cpio}, que no es m\'as que un fichero que almacena
otros archivos e informaci\'on sobre ellos (permisos, nombres, 
propietario\ldots). Este contenedor puede ser un disco, otro archivo, una
cinta o incluso una tuber\'{\i}a, mientras que los ficheros a copiar pueden
ser archivos normales, pero tambi\'en dispositivos o sistemas de ficheros
completos.\\
\\En la tabla \ref{cpioops} se muestran las opciones de {\tt cpio} m\'as
utilizadas; la sintaxis de esta orden es bastante m\'as confusa que la de {\tt 
tar} debido a la interpretaci\'on de lo que {\tt cpio} entiende por {\it 
`dentro'} y {\it `fuera'}: copiar {\it `fuera'} es generar un contenedor en
salida est\'andar (que con toda probabilidad desearemos redireccionar), 
mientras que copiar {\it `dentro'} es lo contrario, es decir, extraer archivos
de la entrada est\'andar (tambi\'en es seguro que deberemos redireccionarla).\\
\begin{table}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Opci\'on & Acci\'on realizada\\
\hline\hline
o & Copiar `fuera' ({\it out})\\
\hline
i & Copiar `dentro' ({\it in})\\
\hline
m & Conserva fecha y hora de los ficheros\\
\hline
t & Crea tabla de contenidos\\
\hline
A & A\~nade ficheros a un contenedor existente\\
\hline
v & Modo {\it verbose}\\
\hline
\end{tabular}
\caption{Opciones de la orden {\tt cpio}.}
\label{cpioops}
\end{center}
\end{table}
\\Por ejemplo, si deseamos copiar los archivos de {\tt /export/home/} en el 
fichero contenedor\\ {\tt /tmp/backup.cpio}
podemos utilizar la siguiente sintaxis:
\begin{quote}
\begin{verbatim}
anita:~# find /export/home/ |cpio -o > /tmp/backup.cpio
\end{verbatim}
\end{quote}
Como podemos ver, {\tt cpio} lee la entrada est\'andar esperando los nombres
de ficheros a guardar, por lo que es conveniente utilizarlo tras una 
tuber\'{\i}a pas\'andole esos nombres de archivo. Adem\'as, hemos de redirigir
su salida al nombre que queramos asignarle al contenedor, ya que de lo 
contrario se mostrar\'{\i}a el resultado en salida est\'andar (lo que 
evidentemente no es muy utilizado para realizar {\it backups}). Podemos fijarnos
tambi\'en en que estamos usando la orden {\tt `find'} en lugar de un simple
{\tt `ls'}: esto es debido a que {\tt `ls'} mostrar\'{\i}a s\'olo el nombre de
cada fichero (por ejemplo, {\tt `passwd'}) en lugar de su ruta completa ({\tt
`/etc/passwd'}), por lo que {\tt cpio} buscar\'{\i}a dichos ficheros a partir
del directorio actual.\\
\\Una vez creado el fichero contenedor quiz\'as resulte interesante chequear su
contenido, con la opci\'on {\tt `t'}. Por ejemplo, la siguiente orden mostrar\'a
en pantalla el contenido de {\tt /tmp/backup.cpio}:
\begin{quote}
\begin{verbatim}
anita:~# cpio -t < /tmp/backup.cpio
\end{verbatim}
\end{quote}
Igual que para almacenar ficheros en un contenedor hemos de pasarle a {\tt cpio}
la ruta de los mismos, para extraerlos hemos de hacer lo mismo; si no indicamos
lo contrario, {\tt cpio -i} extraer\'a todos los archivos de un contenedor, pero
si s\'olo nos interesan algunos de ellos podemos especificar su nombre de la
siguiente forma:
\begin{quote}
\begin{verbatim}
anita:~# echo "/export/home/toni/hola.tex" |cpio -i </tmp/backup.cpio
\end{verbatim}
\end{quote}
Para conocer m\'as profundamente el funcionamiento de {\tt cpio}, as\'{\i}
como opciones propias de cada implementaci\'on, es indispensable consultar la
p\'agina del manual de esta orden en cada clon de Unix donde vayamos a 
utilizarla.
\subsection{{\it Backups} sobre CD-ROM} 
\label{cdrom}
Como antes hemos dicho, cada vez es m\'as com\'un que se realicen copias de
seguridad sobre discos compactos; en estos casos no se suelen utilizar las
aplicaciones vistas hasta ahora ({\tt tar} o {\tt cpio}), sino que se necesita
un {\it software} dedicado: aqu\'{\i} vamos a comentar las nociones 
m\'as b\'asicas para poder crear {\it backups} sobre este medio.
Para poder grabar una copia de seguridad en un CD-ROM necesitamos en primer
lugar que el n\'ucleo del sistema operativo reconozca nuestra grabadora como 
tal; si se trata
de una IDE, y dependiendo del clon de Unix utilizado, quiz\'as sea necesario
modificar el {\it kernel}, ya que el acceso que los diferentes programas 
realizan al dispositivo se efectua a trav\'es de un interfaz SCSI del n\'ucleo.
Es necesario consultar la documentaci\'on y la lista de compatibilidad {\it
hardware} para cada Unix particular.\\
\\Si asumimos que el reconocimiento del dispositivo es correcto, lo que 
necesitamos a continuaci\'on es {\it software} capaz de grabar un CD-ROM. Por
un lado es necesario un programa para crear im\'agenes ISO, el `molde' de lo
que ser\'a el futuro CD-ROM; el m\'as conocido es sin duda {\tt mkisofs}. 
Adem\'as necesitaremos un programa para realizar lo que es la grabaci\'on en
s\'{\i}, como {\tt cdrecord}. De esta forma lo primero que generaremos es una
imagen de los ficheros a grabar, imagen que a continuaci\'on pasaremos al
CD-ROM; por ejemplo, si queremos hacer un {\it backup} de {\tt /export/home/},
en primer lugar utilizaremos {\tt mkisofs} para crear una imagen con todos
los ficheros y subdirectorios de los usuarios:
\begin{quote}
\begin{verbatim}
anita:~# mkisofs -a -R -l -o /mnt/imagen.iso /export/home/
\end{verbatim}
\end{quote}
Con esta orden hemos creado una imagen ISO denominada {\tt /mnt/imagen.iso} y
que contiene toda la estructura de directorios por debajo de {\tt 
/export/home/}; con las diferentes opciones hemos indicado que se almacenen
todos los ficheros, que se sigan los enlaces simb\'olicos y que se registre
adem\'as informaci\'on sobre los permisos de cada archivo. Una vez que tenemos
esta imagen (que en los Unices con soporte para sistemas de ficheros {\it loop}
podremos montar como si se tratara de una partici\'on, para a\~nadir, borrar,
modificar\ldots ficheros antes de la grabaci\'on) hemos de pasarla a un CD-ROM,
por ejemplo mediante {\tt cdrecord}:
\begin{quote}
\begin{verbatim}
anita:~# cdrecord dev=0,1,0 fs=16m /mnt/imagen.iso
\end{verbatim}
\end{quote}
Con esta orden le hemos indicado al sistema la ubicaci\'on de nuestra grabadora,
as\'{\i} como un {\it buffer} de grabaci\'on de 16MB y tambi\'en la ubicaci\'on
de la imagen ISO.\\
\\Algo muy interesante es la posibilidad de grabar sin necesidad de crear 
primero im\'agenes con los ficheros que queremos meter en un CD-ROM; esto nos
ahorrar\'a tiempo (y sobre todo, espacio en disco) a la hora de realizar 
copias de seguridad, adem\'as de permitir una mayor automatizaci\'on del 
proceso. Para ello, debemos calcular con {\tt mkisofs} el espacio que ocupan los
ficheros a grabar (con la opci\'on {\tt `-print-size'}), y posteriormente
pasarle este valor a {\tt cdrecord}; podemos hacerlo de forma autom\'atica,
por ejemplo tal y como muestra el siguiente programa:
\begin{quote}
\begin{verbatim}
anita:~# cat `which graba-cd`
#!/bin/sh
# Vuelca el directorio pasado como parametro, y todos sus descendientes,
# en un CD-ROM
MKISOFS=/usr/local/bin/mkisofs
CDRECORD=/usr/local/bin/cdrecord
if (test $# -lt 1); then
        echo "Usage: $0 /files"
        exit
fi
size=`$MKISOFS -r -J -l -print-size -f $1 2>&1|tail -1|awk '{print $8}'` 
nice --20 $MKISOFS -r -J -l -f $1 | nice --20 $CDRECORD dev=0,1,0 fs=16m\
 tsize=$size*2048 -eject -
anita:~#
\end{verbatim}
\end{quote}
Como vemos, se asigna el tama\~no de los datos a grabar a la variable {\tt 
`size'}, y despu\'es se pasa este n\'umero a {\tt cdrecord}; de esta forma, 
para 
realizar una copia de seguridad de un directorio como {\tt /export/home/toni/},
no tenemos m\'as que ejecutar el {\it shellscript} pas\'andole el nombre de
este directorio como par\'ametro.
\section{Pol\'{\i}ticas de copias de seguridad}
% Copias completas, incrementales o progresivas, y diferenciales
% Hablar de como recuperar, tiempo empleado y tal...
La forma m\'as elemental de realizar una copia de seguridad consiste simplemente
en volcar los archivos a salvaguardar a un dispositivo de {\it backup}, con
el procedimiento que sea; por ejemplo, si deseamos guardar todo el contenido
del directorio {\tt /export/home/}, podemos empaquetarlo en un archivo, 
comprimirlo y a continuaci\'on almacenarlo en una cinta:
\tt
\begin{quote}
\begin{verbatim}
anita:~# tar cf backup.tar /export/home/ 
anita:~# compress backup.tar
anita:~# dd if=backup.tar.Z of=/dev/rmt/0
\end{verbatim}
\end{quote}
\rm
Si en lugar de una cinta quisi\'eramos utilizar otro disco duro, por ejemplo
montado en {\tt /mnt/}, podemos simplemente copiar los ficheros deseados:
\tt
\begin{quote}
\begin{verbatim}
anita:~# cp -rp /export/home/  /mnt/
\end{verbatim}
\end{quote}
\rm
Esta forma de realizar {\it backups} volcando en el dispositivo de copia los
archivos o directorios deseados se denomina copia de seguridad {\bf completa} o
de nivel 0. Unix utiliza el concepto de {\bf nivel de copia de seguridad} para
distinguir diferentes tipos de {\it backups}: una copia de cierto nivel 
almacena los archivos modificados desde el \'ultimo {\it backup} de nivel 
inferior. As\'{\i}, las copias completas son, por definici\'on, las de nivel 0;
las copias de nivel 1 guardan los archivos modificados desde la \'ultima copia
de nivel 0 (es decir, desde el \'ultimo {\it backup} completo), mientras que
las de nivel 2 guardan los archivos modificados desde la \'ultima copia de
nivel 1, y as\'{\i} sucesivamente (en realidad, el nivel m\'aximo utilizado en
la pr\'actica es el 2).\\
\\Como hemos dicho, las copias completas constituyen la pol\'{\i}tica m\'as 
b\'asica para realizar {\it 
backups}, y como todas las pol\'{\i}ticas tiene ventajas e inconvenientes;
la principal ventaja de las copias completas es su facilidad de realizaci\'on
y, dependiendo del mecanismo utilizado, la facilidad que ofrecen para restaurar
ficheros en algunas situaciones: si nos hemos limitado a copiar una serie de 
directorios a otro disco
y necesitamos restaurar cierto archivo, no tenemos m\'as que montar el disco
de {\it backup} y copiar el fichero solicitado a su ubicaci\'on original.\\
\\Sin embargo, las copias completas presentan graves inconvenientes; uno de 
ellos es la dificultad para restaurar ficheros si utilizamos m\'ultiples 
dispositivos de copia de seguridad (por ejemplo, varias cintas). Otro 
inconveniente, m\'as importante, de las copias de nivel 0 es la cantidad de 
recursos que consumen, tanto en tiempo como en {\it hardware}; para solucionar
el problema de la cantidad de recursos utilizados aparece el concepto de
copia de seguridad incremental. Un {\it backup} {\bf incremental} o {\bf 
progresivo} consiste en
copiar s\'olamente los archivos que han cambiado desde la realizaci\'on de 
otra copia (incremental o total). Por ejemplo, si hace una semana realizamos un
{\it backup} de nivel 0 en nuestro sistema y deseamos una copia incremental
con respecto a \'el, hemos de guardar los ficheros modificados en los \'ultimos
siete d\'{\i}as (copia de nivel 1); podemos localizar estos ficheros con 
la orden {\tt find}:
\tt
\begin{quote}
\begin{verbatim}
anita:~# find /export/home/ -mtime 7 -print
\end{verbatim}
\end{quote}
\rm
Si hace un d\'{\i}a ya realizamos una 
copia incremental y ahora queremos hacer otra copia progresiva con respecto a 
ella, hemos de almacenar \'unicamente los archivos modificados en las \'ultimas 
24 horas (copia de nivel 2); como antes, podemos utilizar {\tt find} para 
localizar los archivos modificados en este intervalo de tiempo:
\tt
\begin{quote}
\begin{verbatim}
anita:~# find /export/home/ -mtime 1 -print
\end{verbatim}
\end{quote}
\rm
Esta pol\'{\i}tica de realizar copias de seguridad sobre la \'ultima progresiva 
se denomina de copia de seguridad {\bf diferencial}.\\
\\La principal ventaja de las copias progresivas es que requieren menos tiempo
para ser realizadas y menos capacidad de almacenamiento que las completas; sin
embargo, como desventajas tenemos que la restauraci\'on de ficheros puede ser
m\'as compleja que con las copias de nivel 0, y tambi\'en que un solo fallo en 
uno de los dispositivos de almacenamiento puede provocar la p\'erdida de gran 
cantidad de archivos; para restaurar completamente un sistema, debemos restaurar
la copia m\'as reciente de {\bf cada} nivel, en orden, comenzando por la de
nivel 0. De esta forma, parece l\'ogico que la estrategia seguida 
sea un t\'ermino medio entre las vistas aqu\'{\i}, una pol\'{\i}tica de copias 
de seguridad que mezcle el enfoque completo y el progresivo: una estrategia
muy habitual, tanto por su simpleza como porque no requiere mucho {\it 
hardware} consiste en realizar peri\'odicamente copias de seguridad de nivel
0, y entre ellas realizar ciertas copias progresivas de nivel 1. Por ejemplo,
imaginemos un departamento que decide realizar cada domingo una copia de 
seguridad completa de sus directorios de usuario y de {\tt /etc/}, y una 
progresiva sobre ella, pero s\'olo de los directorios de usuario, cada d\'{\i}a 
lectivo de la semana. Un {\it shellscript} que realize esta tarea puede ser el 
siguiente:
\tt
\begin{quote}
\begin{verbatim}
#!/bin/sh
DIA=`date +%a`    # Dia de la semana
DIREC="/tmp/backup/"  # Un directorio para hacer el backup

hazback () {
    cd $DIREC
    tar cf backup.tar $FILES
    compress backup.tar
    dd if=backup.tar.Z of=/dev/rmt/0
    rm -f backup.tar.Z
}

if [ ! -d $DIREC ]; 
    then
        # No existe $DIREC
        mkdir -p $DIREC
        chmod 700 $DIREC  # Por seguridad
    else 
        rm -rf $DIREC
        mkdir -p $DIREC
        chmod 700 $DIREC
    fi;
case $DIA in
    "Mon") 
        # Lunes, progresiva
        FILES=`find /export/home/ -mtime 1 -print`
        hazback
        ;;	
    "Tue") 
        # Martes, progresiva
        FILES=`find /export/home/ -mtime 2 -print`
        hazback
        ;;	
    "Wed") 
        # Miercoles, progresiva
        FILES=`find /export/home/ -mtime 3 -print`
        hazback
        ;;	
    "Thu") 
        # Jueves, progresiva
        FILES=`find /export/home/ -mtime 4 -print`
        hazback
        ;;	
    "Fri") 
        # Viernes, progresiva
        FILES=`find /export/home/ -mtime 5 -print`
        hazback
        ;;	
    "Sat")
        # Sabado, descansamos...
        ;;
    "Sun")
        # Domingo, copia completa de /export/home y /etc
        FILES="/export/home/ /etc/"
        hazback
        ;;
esac
\end{verbatim}
\end{quote}
\rm
Este programa determina el d\'{\i}a de la semana y en funci\'on de \'el realiza
-- o no, si es s\'abado -- una copia de los ficheros correspondientes (n\'otese
el uso de las comillas inversas en la orden {\tt find}). Podr\'{\i}amos 
automatizarlo mediante la facilidad {\tt cron} de nuestro sistema para que
se ejecute, por ejemplo, cada d\'{\i}a a las tres del mediod\'{\i}a (una hora
en la que la actividad del sistema no ser\'a muy alta); de esta forma, como
administradores, s\'olo deber\'{\i}amos preocuparnos por cambiar las cintas
cada d\'{\i}a, y dejar una preparada para el fin de semana. Si decidimos
planificarlo para que se ejecute de madrugada, hemos de tener en cuenta que el
{\it backup} de un lunes de madrugada, antes de llegar al trabajo, puede 
sobreescribir el completo, realizado el domingo de madrugada, por lo que 
habr\'{\i}a que modificar el {\it shellscript}; tambi\'en hemos de estar atentos
a situaciones inesperadas, como que no existan archivos a copiar o que nuestro
sistema no disponga del suficiente disco duro para almacenar temporalmente la
copia.\\
\\El medio de almacenamiento tambi\'en es importante a la hora de dise\~nar una
pol\'{\i}tica de copias de seguridad correcta. Si se trata de dispositivos 
baratos, como los CD-ROMs, no suele haber muchos problemas: para cada volcado
(sea del tipo que sea) se utiliza una unidad diferente, unidad que adem\'as no
se suele volver a utilizar a no ser que se necesite recuperar los datos; el
uso de unidades regrabables en este caso es minoritario y poco recomendable, por
lo que no vamos a entrar en \'el. No obstante, algo muy diferente son los medios
de almacenamiento m\'as caros, generalmente las cintas magn\'eticas; al ser
ahora el precio algo a tener m\'as en cuenta, lo habitual es reutilizar 
unidades, sobreescribir las copias de seguridad m\'as antiguas con otras m\'as
actualizadas. Esto puede llegar a convertirse en un grave problema si por
cualquier motivo reutilizamos cintas de las que necesitamos recuperar 
informaci\'on; aparte del desgaste f\'{\i}sico del medio, podemos llegar a 
extremos en los que se pierda toda la informaci\'on guardada: imaginemos, por
ejemplo, que s\'olo utilizamos una cinta de 8mm. para crear {\it backups} del
sistema: aunque habitualmente todo funcione correctamente (se cumple de forma
estricta la pol\'{\i}tica de copias, se verifican, se almacenan en un lugar
seguro\ldots), puede darse el caso de que durante el proceso de copia se 
produzca un incendio en la sala de operaciones, incendio que destruir\'a tanto
nuestro sistema como la cinta donde guardamos su {\it backup}, con lo que 
habremos perdido {\bf toda} nuestra informaci\'on. Aunque este es un ejemplo
quiz\'as algo extremo, podemos pensar en lugares donde se utilicen de forma
incorrecta varios juegos de copias o en situaciones en las que el sistema se
corrompe (no ha de tratarse necesariamente de algo tan poco frecuente como un
incendio, sino que se puede tratar de un simple corte de fluido el\'ectrico que
da\~ne los discos); debemos asegurarnos siempre de que podremos recuperar con
una probabilidad alta la \'ultima copia de seguridad realizada sobre cada 
archivo importante de nuestro sistema, especialmente sobre las bases de datos.
