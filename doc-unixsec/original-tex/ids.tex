\chapter{Sistemas de detecci\'on de intrusos}
\section{Introducci\'on}
A pesar de que un enfoque cl\'asico de la seguridad de un sistema inform\'atico
siempre define como principal defensa del mismo sus controles de acceso (desde
una pol\'{\i}tica implantada en un cortafuegos hasta unas listas de control de 
acceso en un {\it router} o en el propio sistema de ficheros de una m\'aquina),
esta visi\'on es extremadamente simplista si no tenemos en cuenta que en muchos
casos esos controles no pueden protegernos ante un ataque (\cite{kn:lun90}). 
Por poner un ejemplo sencillo, pensemos en un {\it firewall} donde hemos
implantado una pol\'{\i}tica que deje acceder al puerto 80 de nuestros 
servidores {\it web} desde cualquier m\'aquina de Internet; ese cortafuegos
s\'olo comprobar\'a si el puerto destino de una trama es el que hemos decidido
para el servicio {\sc http}, pero seguramente no tendr\'a en cuenta si ese
tr\'afico representa o no un ataque o una violaci\'on de nuestra pol\'{\i}tica
de seguridad: por ejemplo, no detendr\'a a un pirata que trate de acceder al
archivo de contrase\~nas de una m\'aquina aprovechando un {\it bug} del servidor
{\it web}. Desde un pirata inform\'atico externo a nuestra organizaci\'on a un 
usuario autorizado que intenta obtener privilegios que no le corresponden en un 
sistema, nuestro entorno de trabajo no va a estar nunca a salvo de 
intrusiones.\\
\\Llamaremos {\bf intrusi\'on} a un conjunto de acciones que intentan 
comprometer la integridad, confidencialidad o disponibilidad de un recurso 
(\cite{kn:hea90}); analizando esta definici\'on, podemos darnos cuenta de que
una intrusi\'on no tiene por qu\'e consistir en un acceso no autorizado a una 
m\'aquina: tambi\'en puede ser una negaci\'on de servicio. A los sistemas 
utilizados para detectar las intrusiones o los intentos de intrusi\'on
se les denomina {\bf sistemas de detecci\'on de intrusiones} ({\it Intrusion 
Detection Systems}, IDS) o, m\'as habitualmente -- y aunque no sea la 
traducci\'on literal -- {\bf sistemas de detecci\'on de intrusos}; cualquier 
mecanismo de seguridad con este prop\'osito puede ser considerado un IDS, pero
generalmente s\'olo se aplica esta denominaci\'on a los sistemas autom\'aticos
({\it software} o {\it hardware}): es decir, aunque un guardia de seguridad 
que vigila en la puerta de la sala de operaciones pueda considerarse en 
principio como un sistema de detecci\'on de intrusos, como veremos a 
continuaci\'on lo habitual (y l\'ogico) es que a la hora de hablar de IDSes no
se contemplen estos casos.\\
\\Una de las primeras cosas que deber\'{\i}amos plantearnos a la hora de hablar
de IDSes es si realmente necesitamos uno de ellos en nuestro entorno de trabajo;
a fin de cuentas, debemos tener ya un sistema de protecci\'on perimetral basado
en cortafuegos, y por si nuestro {\it firewall} fallara, cada sistema 
habr\'{\i}a de estar configurado de una manera correcta, de forma que incluso 
sin cortafuegos cualquier m\'aquina pudiera seguirse considerando relativamente 
segura. La
respuesta es, sin duda, {\bf s\'{\i}}; debemos esperar que en cualquier momento
alguien consiga romper la seguridad de nuestro entorno inform\'atico, y por 
tanto hemos de ser capaces de detectar ese problema tan pronto como sea posible
(incluso antes de que se produzca, cuando el potencial atacante se limite a
probar suerte contra nuestras m\'aquinas). Ning\'un sistema inform\'atico puede
considerarse completamente seguro, pero incluso aunque nadie consiga 
violar nuestras pol\'{\i}ticas de seguridad, los sistemas de detecci\'on de 
intrusos se encargar\'an de mostrarnos todos los intentos de multitud 
de piratas para penetrar en nuestro entorno, no dej\'andonos caer en ninguna 
falsa sensaci\'on de seguridad: si somos conscientes de que a diario hay gente
que trata de romper nuestros sistemas, no caeremos en la tentaci\'on de pensar
que nuestras m\'aquinas est\'an seguras porque nadie sabe de su existencia o
porque no son interesantes para un pirata.\\
\\Los sistemas de detecci\'on de intrusos no son precisamente nuevos: el primer 
trabajo sobre esta materia (\cite{kn:and80}) data de 1980; no obstante, este 
es uno de los campos m\'as en auge desde hace ya unos a\~nos dentro de la 
seguridad inform\'atica. Y no es extra\~no: la capacidad para detectar y
responder ante los intentos de ataque contra nuestros sistemas es realmente
muy interesante. Durante estos veinte a\~nos, cientos de investigadores de
todo el mundo han desarrollado, con mayor o menor \'exito, sistemas de 
detecci\'on de todo tipo, desde simples procesadores de {\it logs} hasta 
complejos sistemas distribuidos, especialmente vigentes con el auge de las 
redes de computadores en los \'ultimos a\~nos; una excelente perspectiva 
hist\'orica de algunos de ellos puede encontrarse en \cite{kn:jay95} o 
\cite{kn:axe98b}.
\section{Clasificaci\'on de los IDSes}
Generalmente existen dos grandes enfoques a la hora de clasificar a los sistemas
de detecci\'on de intrusos: o bien en funci\'on de {\bf qu\'e} sistemas vigilan,
o bien en funci\'on de {\bf c\'omo} lo hacen.\\ 
\\Si elegimos la primera de estas aproximaciones tenemos dos grupos de sistemas
de detecci\'on de intrusos: los que analizan actividades de una \'unica 
m\'aquina en busca de posibles ataques, y los que lo hacen de una subred 
(generalmente, de un mismo dominio de colisi\'on) aunque se emplazen en uno 
s\'olo de los {\it hosts} de la misma. Esta \'ultima puntualizaci\'on es 
importante: un IDS que detecta actividades sospechosas en una red no tiene 
porqu\'e (y de hecho en la mayor parte de casos no suele ser as\'{\i}) ubicarse 
en todas las m\'aquinas de esa red.
\begin{itemize}
\item IDSes basados en red.\\
Un IDS basado en red monitoriza los paquetes que circulan por nuestra red en
busca de elementos que denoten un ataque contra alguno de los sistemas ubicados
en ella; el IDS puede situarse en cualquiera de los {\it hosts} o en un
elemento que analice todo el tr\'afico (como un HUB o un enrutador). Est\'e
donde est\'e, monitorizar\'a diversas m\'aquinas y no una sola: esta es la
principal diferencia con los sistemas de detecci\'on de intrusos basados en 
{\it host}.
\item IDSes basados en m\'aquina.\\
Mientras que los sistemas de detecci\'on de intrusos basados en red operan
bajo todo un dominio de colisi\'on, los basados en m\'aquina realizan su
funci\'on protegiendo un \'unico sistema; de una forma similar -- guardando las
distancias, por supuesto -- a como act\'ua un escudo antivirus residente en
MS-DOS, el IDS es un proceso que trabaja en {\it background} (o que despierta
peri\'odicamente) buscando patrones que puedan denotar un intento de intrusi\'on
y alertando o tomando las medidas oportunas en caso de que uno de estos 
intentos sea detectado.
\end{itemize}
Algunos autores (\cite{kn:gra00}) dividen el segundo grupo, el de los sistemas 
de detecci\'on de intrusos basados en m\'aquina, en tres subcategor\'{\i}as:
\begin{itemize}
\item Verificadores de integridad del sistema (SIV).\\
Un verificador de integridad no es m\'as que un mecanismo encargado de 
monitorizar archivos de una m\'aquina en busca de posibles modificaciones no
autorizadas, por norma general {\it backdoors} dejadas por un intruso (por
ejemplo, una entrada adicional en el fichero de contrase\~nas o un {\tt 
/bin/login} que permite el acceso ante cierto nombre de usuario no registrado).
El SIV m\'as conocido es sin duda Tripwire, comentado en este mismo trabajo;
la importancia de estos mecanismos es tal que en la actualidad algunos sistemas 
Unix integran `de serie' verificadores de integridad, como Solaris y su ASET 
({\it Automated Security Enhancement Tools}).
\item Monitores de registros (LFM).\\
Estos sistemas monitorizan los archivos de {\it log} generados por los programas
-- generalmente demonios de red -- de una m\'aquina en busca de patrones que
puedan indicar un ataque o una intrusi\'on. Un ejemplo de monitor puede ser
{\tt swatch}, pero m\'as habituales que \'el son los peque\~nos {\it 
shellscripts} que casi todos los administradores realizan para comprobar
peri\'odicamente sus archivos de {\it log} en busca de entradas sospechosas
(por ejemplo, conexiones rechazadas en varios puertos provenientes de un
determinado {\it host}, intentos de entrada remota como {\tt root}\ldots).
\item Sistemas de decepci\'on.\\
Los sistemas de decepci\'on o tarros de miel ({\it honeypots}), como {\it 
Deception Toolkit} (DTK), son mecanismos
encargados de simular servicios con problemas de seguridad de forma que un 
pirata piense que realmente el problema se puede aprovechar para acceder a un
sistema, cuando realmente se est\'a aprovechando para registrar todas sus
actividades. Se trata de un mecanismo \'util en muchas ocasiones -- por ejemplo,
para conseguir `entretener' al atacante mientras se tracea su conexi\'on --
pero que puede resultar peligroso: >qu\'e sucede si el propio sistema de 
decepci\'on tiene un {\it bug} que desconocemos, y el atacante lo aprovecha para
acceder realmente a nuestra m\'aquina?
\end{itemize}
Realmente esta divisi\'on queda algo pobre, ya que cada d\'{\i}a se avanza m\'as
en la construcci\'on de sistemas de detecci\'on de intrusos basados en {\it 
host} que no podr\'{\i}an englobarse en ninguna de las subcategor\'{\i}as 
anteriores.\\
\\La segunda gran clasificaci\'on de los IDSes se realiza en funci\'on de c\'omo
act\'uan estos sistemas; actualmente existen dos grandes t\'ecnicas de 
detecci\'on de intrusos (\cite{kn:sun96}): las basadas en la detecci\'on de 
anomal\'{\i}as ({\it anomaly detection}) y las basadas en la detecci\'on de 
usos indebidos del sistema ({\it misuse detection}). Aunque m\'as tarde 
hablaremos con mayor profundidad de cada uno de estos modelos, la idea b\'asica
de los mismos es la siguiente:
\begin{itemize}
\item Detecci\'on de anomal\'{\i}as.\\
La base del funcionamiento de estos sistemas es suponer que una intrusi\'on se
puede ver como una anomal\'{\i}a de nuestro sistema, por lo que si fu\'eramos
capaces de establecer un perfil del comportamiento habitual de los sistemas 
ser\'{\i}amos capaces de detectar las intrusiones por pura estad\'{\i}stica: 
probablemente una intrusi\'on ser\'{\i}a una desviaci\'on excesiva de la media 
de nuestro perfil de comportamiento.
\item Detecci\'on de usos indebidos.\\
El funcionamiento de los IDSes basados en la detecci\'on de usos indebidos 
presupone que podemos establecer patrones para los diferentes ataques conocidos
y algunas de sus variaciones; mientras que la detecci\'on de anomal\'{\i}as
conoce lo normal (en ocasiones se dice que tienen un `conocimiento positivo', 
{\it positive knowledge}) y detecta lo que no lo es, este esquema se limita a 
conocer lo anormal para poderlo detectar (conocimiento negativo, {\it negative
knowledge}).
\end{itemize}
Para ver m\'as claramente la diferencia entre ambos esquemas, imaginemos un 
sistema de detecci\'on basado en monitorizar las m\'aquinas origen desde las 
que un usuario sospechoso conecta a nuestro sistema: si se tratara de un modelo
basado en la detecci\'on de anomal\'{\i}as, seguramente mantendr\'{\i}a una
lista de las dos o tres direcciones m\'as utilizadas por el usuario 
leg\'{\i}timo, alertando al responsable de seguridad en caso de que el usuario
conecte desde otro lugar; por contra, si se tratara de un modelo basado en la
detecci\'on de usos indebidos, mantendr\'{\i}a una lista mucho m\'as amplia que
la anterior, pero formada por las direcciones desde las sabemos con una alta
probabilidad que ese usuario no va a conectar, de forma que si detectara un 
acceso desde una de esas m\'aquinas, entonces es cuando el sistema tomar\'{\i}a 
las acciones oportunas.\\
\\En muchos trabajos (\cite{kn:esc98}, \cite{kn:thu00}\ldots) aparece una 
tercera clasificaci\'on de los IDSes; se trata de la diferenciaci\'on entre los 
sistemas que trabajan peri\'odicamente (denominados `pasivos') y los que operan 
en tiempo real (activos). Nosotros no 
contemplaremos, aunque la citemos, esta clasificaci\'on, ya que es totalmente
minoritaria en comparaci\'on con las otras dos que hemos comentado. De
cualquier forma, la idea es muy simple: un IDS de tiempo real (los denominados
{\it Real--Time Intrusion Detection Systems}) trabaja cont\'{\i}nuamente en
busca de posibles ataques, mientras que los sistemas que se ejecutan a 
intervalos ({\it Vulnerability Scanners}) son analizadores de vulnerabilidades
que cualquier administrador ha de ejecutar regularmente (ya sea de forma 
manual o autom\'atica) contra sus sistemas para verificar que no presentan 
problemas de seguridad.
\section{Requisitos de un IDS}
Sin importar qu\'e sistemas vigile o su forma de trabajar, cualquier
sistema de detecci\'on de intrusos ha de cumplir algunas propiedades para
poder desarrollar su trabajo correctamente. En primer lugar, y quiz\'as como
caracter\'{\i}stica m\'as importante, el IDS ha de ejecutarse 
cont\'{\i}nuamente sin nadie que est\'e obligado a supervisarlo; 
independientemente de que al detectar un problema se informe a un operador o se 
lance una respuesta autom\'atica, el funcionamiento habitual no debe implicar 
interacci\'on con un humano. Podemos fijarnos en que esto parece algo evidente:
muy pocas empresas estar\'{\i}an dispuestas a contratar a una o varias personas
simplemente para analizar {\it logs} o controlar los patrones del tr\'afico de  
una red. Sin entrar a juzgar la superioridad de los humanos frente a las 
m\'aquinas (>puede un algoritmo determinar perfectamente si un uso del sistema 
est\'a correctamente autorizado?) o viceversa (>ser\'{\i}a capaz una persona de 
analizar en tiempo real todo el tr\'afico que llega a un servidor {\it web} 
mediano?), hemos de tener presente que los sistemas de detecci\'on son 
mecanismos automatizados que se instalan y configuran de forma que su 
trabajo habitual sea transparente a los operadores del entorno inform\'atico.\\
\\Otra propiedad, y tambi\'en como una caracter\'{\i}stica a tener siempre en
cuenta, es la {\bf aceptabilidad} o grado de aceptaci\'on del IDS; al igual que
suced\'{\i}a con cualquier modelo de autenticaci\'on, los mecanismos de
detecci\'on de intrusos han de ser aceptables para las personas que trabajan 
ha\-bi\-tual\-men\-te en el entorno. Por ejemplo, no ha de introducir una 
sobrecarga 
considerable en el sistema (si un IDS ralentiza demasiado una m\'aquina, 
simplemente no se utilizar\'a) ni generar una cantidad elevada de falsos 
positivos (detecci\'on de intrusiones que realmente no lo son) o de 
{\it logs}, ya que entonces llegar\'a un momento en que nadie se preocupe de 
comprobar las alertas emitidas por el detector. Por supuesto (y esto puede 
parecer una tonter\'{\i}a, pero es algo que se hace m\'as a menudo de lo que 
podamos imaginar), si para evitar problemas con las intrusiones simplemente 
apagamos el equipo o lo desconectamos de la red, tenemos un sistema bastante 
seguro\ldots pero inaceptable.\\
\\Una tercera caracter\'{\i}stica a evaluar a la hora de hablar de sistemas de
detecci\'on de intrusos es la {\bf adaptabilidad} del mismo a cambios en el 
entorno de trabajo. Como todos sabemos, ning\'un sistema inform\'atico puede
considerarse est\'atico: desde la aplicaci\'on m\'as peque\~na hasta el
propio {\it kernel} de Unix, pasando por supuesto por la forma de trabajar de
los usuarios (>qui\'en nos asegura que ese engorroso procedimiento desde una
`desfasada' l\'{\i}nea de \'ordenes ma\~nana no se realizar\'a desde una 
aplicaci\'on gr\'afica, que realmente hace el mismo trabajo pero que genera
unos patrones completamente diferentes en nuestro sistema?), todo cambia 
con una periodicidad m\'as o menos elevada. Si nuestros mecanismos de 
detecci\'on de intrusos no son capaces de adaptarse r\'apidamente a esos 
cambios, est\'an condenados al fracaso.\\
\\Todo IDS debe adem\'as presentar cierta tolerancia a fallos o capacidad de 
respuesta ante situaciones inesperadas; insistiendo en lo que coment\'abamos
antes sobre el car\'acter altamente din\'amico de un entorno inform\'atico, 
algunos -- o muchos -- de los cambios que se pueden producir en dicho entorno 
no son graduales sino bruscos, y un IDS ha de ser capaz de responder siempre
adecuadamente ante los mismos. Podemos contemplar, por ejemplo, un reinicio 
inesperado de varias m\'aquinas o un intento de 
enga\~no hacia el IDS; esto \'ultimo es especialmente cr\'{\i}tico: s\'olo 
hemos de pararnos a pensar que si un atacante consigue modificar el 
comportamiento del sistema de detecci\'on y el propio sistema no se da cuenta 
de ello, la intrusi\'on nunca ser\'a notificada, con los dos graves problemas
que eso implica: aparte de la intrusi\'on en s\'{\i}, la falsa sensaci\'on de
seguridad que produce un IDS que no genera ninguna alarma es un grave 
inconveniente de cara a lograr sistemas seguros.
\section{IDSes basados en m\'aquina}
Como antes hemos comentado, un sistema de detecci\'on de intrusos basado en
m\'aquina ({\it host--based IDS}) es un mecanismo que permite detectar ataques
o intrusiones contra la m\'aquina sobre la que se ejecuta.\\
\\Tradicionalmente, los modelos de detecci\'on basados en m\'aquina han 
consistido por una parte en la utilizaci\'on de herramientas autom\'aticas de
an\'alisis de {\it logs} generados por diferentes aplicaciones o por el propio 
{\it kernel} del sistema operativo, prestando siempre especial atenci\'on a los
registros relativos a demonios de red, como un servidor {\it web} o el propio
{\tt inetd}, y por otra -- quiz\'as no tan habitual como la anterior -- en el
uso de verificadores de integridad de determinados ficheros vitales para el
sistema, como el de contrase\~nas; no obstante, desde hace unos a\~nos un
tercer esquema de detecci\'on se est\'a implantando con cierta fuerza: se
trata de los sistemas de detecci\'on, {\it honeypots} o tarros de miel.\\
\\El an\'alisis de {\it logs} generados por el sistema (entendiendo como tales 
no s\'olo a los relativos al n\'ucleo, sino tambi\'en a aquellos de aplicaciones
nativas de cada Unix, como {\tt syslogd}) var\'{\i}a entre diferentes clones de 
Unix por una sencilla raz\'on: cada uno de ellos guarda la informaci\'on con
un cierto formato, y en determinados ficheros, aunque todos -- o casi todos --
sean capaces de registrar los mismos datos, que son aquellos que pueden ser 
indicativos de un ataque. La mayor parte de Unices son capaces de registrar con
una granularidad lo suficientemente fina casi todas las actividades que se
llevan a cabo en el sistema, en especial aquellas que pueden suponer -- aunque
sea remotamente -- una vulneraci\'on de su seguridad; sin embargo, el problema
radica en que pocos administradores se preocupan de revisar con un m\'{\i}nimo
de atenci\'on esos {\it logs}, por lo que muchos ataques contra la m\'aquina,
tanto externos como internos, y tanto fallidos como exitosos, pasan 
finalmente desapercibidos. Aqu\'{\i} es donde entran en juego las herramientas
autom\'aticas de an\'alisis, como {\tt swatch} o {\tt logcheck}; a grandes 
rasgos, realizan la misma actividad que podr\'{\i}a ejecutar un {\it 
shellscript} convenientemente planificado que incluyera entre sus l\'{\i}neas
algunos {\tt grep} de registros sospechosos en los archivos de {\it log}.\\
\\>A qu\'e entradas de estos ficheros debemos estar atentos? Evidentemente, esto
depende de cada sistema y de lo que sea `normal' en \'el, aunque suelen existir
registros que en cualquier m\'aquina denotan una actividad cuanto menos 
sospechosa. Esto incluye ejecuciones fallidas o exitosas de la orden {\tt su},
peticiones no habituales al servicio {\sc smtp} (como {\tt vrfy} o {\tt expn}),
conexiones a diferentes puertos rechazadas por {\it TCP Wrappers}, intentos de
acceso remotos como superusuario, etc; si en la propia m\'aquina tenemos 
instalado un cortafuegos independiente del corporativo, o cualquier otro {\it
software} de seguridad -- uno que quiz\'as es especialmente recomendable es 
{\it PortSentry} --, tambi\'en conviene estar atentos a los {\it logs} 
generados por los mismos, que habitualmente se registran en los ficheros 
normales de auditor\'{\i}a del sistema ({\tt syslog}, {\tt messages}\ldots) y
que suelen contener informaci\'on que con una probabilidad elevada denotan un
ataque real.\\
\\Por otra parte, la verificaci\'on de integridad de archivos se puede realizar 
a diferentes
niveles, cada uno de los cuales ofrece un mayor o menor grado de seguridad. Por
ejemplo, un administrador puede programar y planificar un sencillo {\it 
shellscript} para que se ejecute peri\'odicamente y compruebe el propietario y
el tama\~no de ciertos ficheros como {\tt /etc/passwd} o {\tt /etc/shadow}; 
evidentemente, este esquema es extremadamente d\'ebil, ya que si un usuario se
limita a cambiar en el archivo correspondiente su UID de 100 a 000, este modelo
no descubrir\'{\i}a el ataque a pesar de su gravedad. Por tanto, parece obvio
que se necesita un esquema de detecci\'on mucho m\'as robusto, que compruebe 
aparte de la integridad de la informaci\'on registrada en el inodo asociado a
cada fichero (fecha de \'ultima modificaci\'on, propietario, grupo 
propietario\ldots) la integridad de la informaci\'on contenida en dicho archivo;
y esto se consigue muy f\'acilmente utilizando funciones resumen sobre cada
uno de los ficheros a monitorizar, funciones capaces de generar un {\it hash}
\'unico para cada contenido de los archivos. De esta forma, cualquier 
modificaci\'on en su contenido generar\'a un resumen diferente, que al ser 
comparado con el original dar\'a la voz de alarma; esta es la forma de trabajar
de {\it Tripwire}, el m\'as conocido y utilizado de todos los verificadores de
integridad disponibles para entornos Unix.\\
\\Sea cual sea nuestro modelo de verificaci\'on, en cualquiera de ellos debemos
llevar a cabo inicialmente un paso com\'un: generar una base de datos de 
referencia contra la que posteriormente compararemos la informaci\'on de cada 
archivo. Por ejemplo, si nos limitamos a comprobar el tama\~no de ciertos 
ficheros debemos, nada m\'as configurar el sistema, registrar todos los nombres
y tama\~nos de los ficheros que deseemos, para despu\'es comparar la 
informaci\'on que peri\'odicamente registraremos en nuestra m\'aquina con la
que hemos almacenado en dicha base de datos; si existen diferencias, podemos
encontrarnos ante un indicio de ataque. Lo mismo suceder\'a si registramos 
funciones resumen: debemos generar un {\it hash} inicial de cada archivo contra
el que comparar despu\'es la informaci\'on obtenida en la m\'aquina. 
Independientemente de los contenidos que deseemos registrar en esa base de datos
inicial, siempre hemos de tener presente una cosa: si un pirata consigue 
modificarla de forma no autorizada, habr\'a burlado por completo a nuestro 
sistema de verificaci\'on. As\'{\i}, es {\bf vital} mantener su integridad;
incluso es recomendable utilizar medios de s\'olo lectura, como un CD-ROM, o
incluso unidades extra\'{\i}bles -- discos o disquetes -- que habitualmente no
estar\'an disponibles en el sistema, y s\'olo se utilizar\'an cuando tengamos
que comprobar la integridad de los archivos de la m\'aquina.\\
\\Por \'ultimo, aunque su utilizaci\'on no est\'e tan extendida como la de los
analizadores de {\it logs} o la de los verificadores de integridad, es necesario
hablar, dentro de la categor\'{\i}a de los sistemas de detecci\'on de intrusos
basados en m\'aquina, de los sistemas de decepci\'on o {\it honeypots}. 
B\'asicamente, estos `tarros de miel' son sistemas completos o parte de los
mismos (aplicaciones, servicios, subentornos\ldots) dise\~nados para recibir
ciertos tipos de ataques; cuando sufren uno, los {\it honeypots} detectan la
actividad hostil y aplican una estrategia de respuesta. Dicha estrategia puede
consistir desde un simple correo electr\'onico al responsable de la seguridad 
de la m\'aquina hasta un bloqueo autom\'atico de la direcci\'on atacante;
incluso muchos de los sistemas -- la mayor\'{\i}a -- son capaces de simular 
vulnerabilidades conocidas de forma que el atacante piense que ha tenido 
\'exito y prosiga con su actividad, mientras es monitorizado por el detector de
intrusos.\\
\\El concepto te\'orico que est\'a detr\'as de los tarros de miel es el 
denominado `conocimiento ne\-ga\-ti\-vo': proporcionar deliveradamente a un 
intruso 
informaci\'on falsa -- pero que \'el considerar\'a real -- de nuestros sistemas,
con diferentes fines: desde poder monitorizar durante m\'as tiempo sus 
actividades, hasta despistarlo, pasando por supuesto por la simple 
diversi\'on. Evidentemente, para lograr enga\~nar a un pirata medianamente
experimentado la simulaci\'on de vulnerabilidades ha de ser muy `real', 
dedicando a tal efecto incluso sistemas completos (denominados 'm\'aquinas de
sacrificio'), pero con atacantes de nivel medio o bajo dicho enga\~no es 
much\'{\i}simo m\'as sencillo: en muchos casos basta simular la existencia de 
un troyano como {\it BackOrifice} mediante {\it FakeBO} ({\tt 
http://cvs.linux.hr/fakebo/}) para que el pirata determine que realmente 
estamos infectados e intente utilizar ese camino en su ataque contra nuestro 
sistema.\\
\\Algunos sistemas de decepci\'on no simulan vulnerabilidades tal y como 
habitualmente se suele entender este concepto; dicho de otra forma, su objetivo
no es enga\~nar a un atacante durante mucho tiempo, proporcion\'andole un 
subentorno en el sistema que aparente de forma muy realista ser algo vulnerable,
sino que su `decepci\'on' es bastante m\'as elemental: se limitan a presentar
un aspecto (quiz\'as deber\'{\i}amos llamarle {\it interfaz}) que parece 
vulnerable, pero que cualquier aprendiz de pirata puede descubrir sin problemas 
que no es m\'as que un enga\~no. >D\'onde est\'a entonces la funci\'on de estos
sistemas, denominados en ocasiones `detectores de pruebas'? Por norma, su tarea 
es recopilar informaci\'on del atacante y del
ataque en s\'{\i}; por ejemplo, ya que antes hemos hablado de {\it FakeBO}, 
podemos imaginar un programa que se encargue de escuchar en el puerto 31337 de
nuestro sistema -- donde lo hace el troyano real -- y, cada vez que alguien 
acceda a \'el, guardar
la hora, la direcci\'on origen, y los datos enviados por el atacante. En 
realidad, no es una simulaci\'on que pueda enga\~nar ni al pirata m\'as novato,
pero hemos logrado el objetivo de cualquier sistema de detecci\'on de intrusos: 
registrar el ataque; adem\'as, tambi\'en se puede considerar un {\it honeypot},
ya que simula un entorno vulnerable, aunque s\'olo logre enga\~nar a nuestro
atacante durante unos segundos. De cualquier forma, es necesario indicar que
en algunas publicaciones (como \cite{kn:gra00}) se diferencia a los sistemas de 
decepci\'on `completos'
de estos mecanismos de enga\~no simple, aunque a todos se les englobe dentro
del conjunto denominado {\it honeypots}.\\
\\Hemos revisado en este punto las ideas m\'as generales de los sistemas de
detecci\'on de intrusos basados en {\it host}; aunque hoy en d\'{\i}a los que 
vamos a describir a continuaci\'on, los basados en red, son con diferencia los 
m\'as utilizados, como veremos m\'as adelante todos son igualmente 
ne\-ce\-sa\-rios
si deseamos crear un esquema de detecci\'on con la m\'axima efectividad. Se
trata de niveles de protecci\'on diferentes pero que tienen un mismo objetivo:
alertar de actividades sospechosas y, en algunos casos, proporcionar una 
respuesta autom\'atica a las mismas.
\section{IDSes basados en red}
Los sistemas de detecci\'on de intrusos basados en red ({\it network--based
IDS}) son aquellos capaces de detectar ataques contra diferentes sistemas de 
una misma red (en concreto, de un mismo dominio de colisi\'on), aunque 
generalmente se ejecuten en uno solo de los {\it hosts} de esa red. Para lograr
su objetivo, al menos uno de los interfaces de red de esta m\'aquina sensor 
trabaja en modo promiscuo, capturando y analizando todas las tramas que pasan 
por \'el en busca de patrones indicativos de un ataque.\\
\\>Cu\'ales pueden ser estos `patrones identificativos de un ataque' a los que
estamos haciendo re\-fe\-ren\-cia? Casi cualquiera de los diferentes campos de 
una trama de red {\sc tcp/ip} (podemos consultar \cite{kn:ste94}, 
\cite{kn:com95} o \cite{kn:tan96} para conocer en profundidad el significado y 
la utilidad de cada uno de ellos) puede tener un valor que, con mayor o menor 
probabilidad, represente un ataque real; los casos m\'as habituales incluyen:
\begin{itemize}
\item Campos de fragmentaci\'on.\\
Una cabecera {\sc ip} contiene dieciseis {\it bits} reservados a informaci\'on 
sobre el nivel de fragmentaci\'on del datagrama; de ellos, uno no se utiliza y 
trece indican el desplazamiento del fragmento que transportan. Los otros dos 
{\it bits} indican o bien que el paquete no ha de ser fragmentado por un {\it
router} intermedio ({\sc df}, {\it Don\'{}t Fragment}) o bien que el paquete ha 
sido fragmentado y no es el \'ultimo que se va a recibir ({\sc mf}, {\it More
Fragments}). Valores incorrectos de par\'ametros de fragmentaci\'on de los 
datagramas se han venido utilizando t\'{\i}picamente para causar importantes 
negaciones de servicio a los sistemas y, desde hace tambi\'en un tiempo incluso 
para obtener la versi\'on del operativo que se ejecuta en un determinado {\it 
host} (\cite{kn:fyo98}); por ejemplo, >qu\'e le suceder\'{\i}a al 
subsistema de red implantado en el n\'ucleo de una m\'aquina Unix si nunca 
recibe una trama con el {\it bit} {\sc mf} reseteado, indicando que es el 
\'ultimo de un paquete? >se quedar\'{\i}a permanentemente esper\'andola? >y 
si recibe uno que en teor\'{\i}a no est\'a fragmentado pero se le indica que no
es el \'ultimo que va a recibir? >c\'omo responder\'{\i}a el n\'ucleo del 
operativo en este caso? Como vemos, si en nuestras m\'aquinas observamos 
ciertas combinaciones de {\it bits} relacionados con la fragmentaci\'on 
realmente tenemos motivos para -- cuanto menos -- sospechar que alguien trata 
de atacarnos.
\item Direcci\'on origen y destino.\\
Las direcciones de la m\'aquina que env\'{\i}a un paquete y la de la que lo va
a recibir tambi\'en son campos interesantes de cara a detectar intrusiones en
nuestros sistemas o en nuestra red. No tenemos m\'as que pensar el tr\'afico 
proveniente de nuestra DMZ (y que no se trate de la t\'{\i}pica respuesta ante 
una petici\'on como las que se generan al visitar p\'aginas {\it web}, por 
poner un ejemplo) que tenga como destino nuestra red protegida: es muy posible 
que esos paquetes constituyan un intento de violaci\'on de nuestra 
pol\'{\i}tica de seguridad. Otros ejemplos cl\'asicos son las peticiones 
originadas desde Internet y que tienen como destino m\'aquinas de nuestra 
organizaci\'on que no est\'an ofreciendo servicios directos al exterior, como 
un servidor de bases de datos cuyo acceso est\'a restringido a sistemas de 
nuestra red.
\item Puerto origen y destino.\\
Los puertos origen y destino (especialmente este \'ultimo) son un excelente
indicativo de actividades sospechosas en nuestra red. Aparte de los intentos de
acceso no autorizado a servicios de nuestros sistemas, pueden detectar 
actividades que tambi\'en supondr\'an {\it a priori} violaciones de nuestras 
pol\'{\i}ticas de seguridad, como la existencia de troyanos, ciertos tipos de
barridos de puertos, o la presencia de servidores no autorizados dentro de 
nuestra red.
\item {\it Flags} {\sc tcp}.\\
Uno de los campos de una cabecera {\sc tcp} contiene seis {\it bits} ({\sc 
urg}, {\sc ack}, {\sc psh}, {\sc rst}, {\sc syn} y {\sc fin}), cada uno de 
ellos con una finalidad diferente (por ejemplo, el {\it bit} {\sc syn} es 
utilizado para establecer una nueva conexi\'on, mientras que {\sc fin} hace 
justo lo contrario: liberarla). Evidentemente el valor de cada uno de estos 
{\it bits} ser\'a 0 o 1, lo cual de forma aislada no suele decir mucho (ni 
bueno ni malo) de su emisor; no obstante, ciertas combinaciones de valores 
suelen ser bastante sospechosas: por ejemplo, una trama con los dos {\it bits} 
de los que hemos hablado -- {\sc syn} y {\sc fin} -- activados 
simult\'aneamente ser\'{\i}a indicativa de una conexi\'on que trata de abrirse 
y cerrarse al mismo tiempo. Para hacernos una idea de la importancia de estos
{\it bits} de control, no conviene olvidar que uno de los problemas de
seguridad m\'as conocidos de los \'ultimos a\~nos sobre plataformas Windows --
de los muchos que han tenido estos entornos -- estaba fundamentado b\'asicamente
en el manejo de paquetes {\sc oob} ({\it Out Of Band}): tramas con el {\it bit} 
{\sc urg} activado.
\item Campo de datos.\\
Seguramente, el campo de datos de un paquete que circula por la red es 
donde m\'as probabilidades tenemos de localizar un ataque contra nuestros 
sistemas; esto es debido a que con toda probabilidad nuestro cortafuegos
corporativo detendr\'a tramas cuya cabecera sea `sospechosa' (por ejemplo, 
aquellas cuyo origen no est\'e autorizado a alcanzar su destino o con campos
incorrectos), pero rara vez un {\it firewall} se parar\'a a analizar el 
contenido de los datos transportados en la trama. Por ejemplo, una petici\'on 
como {\tt `GET ../../../etc/passwd HTTP/1.0'} contra el puerto 80 del servidor 
{\it web} de nuestra empresa no se detendr\'a en el cortafuegos, pero muy
probablemente se trata de un intento de intrusi\'on contra nuestros sistemas.
\end{itemize}
Acabamos de ver {\bf s\'olo algunos} ejemplos de campos de una trama {\sc 
tcp/ip} que, 
al presentar determinados valores, pueden ser indicativos de un ataque; sin 
embargo, no todo es tan sencillo como comprobar ciertos par\'ametros de cada
paquete que circula por uno de nuestros segmentos. Tambi\'en es posible y 
necesario que un detector de intrusos basado en red sea capaz de notificar 
otros ataques que no se pueden apreciar en una \'unica trama; uno de estos
ataques es la presencia de peticiones que, aunque por s\'{\i} mismas no sean 
sospechosas, por su repetici\'on en un intervalo de tiempo m\'as o menos 
peque\~no puedan ser indicativas de un ataque (por ejemplo, barridos de puertos 
horizontales o verticales). Otros ataques dif\'{\i}ciles de detectar analizando
tramas de forma independiente son las negaciones de servicio distribuidas 
(DDoS, {\it Distributed Denial of Service}), justamente por el gran n\'umero de
or\'{\i}genes que el ataque tiene por definici\'on.\\
\\Seg\'un lo expuesto hasta ahora en este punto, puede parecer que los sistemas
de detecci\'on de intrusos basados en red funcionan \'unicamente mediante la
detecci\'on de patrones; realmente, esto no es as\'{\i}: en principio, un 
detector de intrusos basado en red puede estar basado en la detecci\'on de 
anomal\'{\i}as, igual que lo puede estar uno basado en m\'aquinas. No obstante,
esta aproximaci\'on es minoritaria; aunque una intrusi\'on generar\'a 
probablemente comportamientos anormales (por ejemplo, un tr\'afico excesivo 
entre el sistema atacante y el atacado) susceptibles de ser detectados y 
eliminados, con demasiada frecuencia estos sistemas no detectar\'an la 
intrusi\'on hasta que la misma se encuentre en un estado avanzado. Este problema
hace que la mayor parte de IDSes basados en red que existen actualmente 
funcionen siguiendo modelos de detecci\'on de usos indebidos.\\
\\Para finalizar este punto dedicado a los sistemas de detecci\'on de intrusos 
basados en red es necesario hablar de las {\it honeynets} (\cite{kn:spi01}) -- 
literalmente, `redes de miel' --. Se trata de un concepto muy parecido al de
los {\it honeypots}, de los que ya hemos hablado, pero extendido ahora a redes
completas: redes dise\~nadas para ser comprometidas, formadas por sistemas 
reales de todo tipo que, una vez penetrados, permiten capturar y analizar las
acciones que est\'a realizando el atacante para as\'{\i} poder aprender m\'as
sobre aspectos como sus t\'ecnicas o sus objetivos. Realmente, aunque la idea
general sea com\'un, existen dos grandes diferencias de dise\~no entre un 
tarro de miel y una {\it honeynet}: por un lado, esta \'ultima evidentemente es
una red completa que alberga diferentes entornos de trabajo, no se trata de una
\'unica m\'aquina; por otro, los sistemas dentro de esta red son sistemas 
reales, en el sentido de que no simulan ninguna vulnerabilidad, sino que 
ejecutan aplicaciones t\'{\i}picas (bases de datos, sistemas de 
desarrollo\ldots) similares a las que podemos encontrar en cualquier entorno de
trabajo `normal'. El objetivo de una {\it honeynet} no es la decepci\'on, sino 
principalmente conocer los movimientos de un pirata en entornos semireales, de 
forma que aspectos como sus vulnerabilidades o sus configuraciones incorrectas 
se puedan extrapolar a muchos de los sistemas que cualquier empresa posee
en la actualidad; de esta forma podemos prevenir nuevos ataques exitosos contra 
entornos reales.\\
\\En el funcionamiento de una `red de miel' existen dos aspectos fundamentales
y especialmente cr\'{\i}ticos, que son los que introducen la gran cantidad 
trabajo de administraci\'on extra que una {\it ho\-ney\-net} implica para 
cualquier organizaci\'on. Por un lado, tenemos el control del flujo de los 
datos: es {\bf vital} para nuestra seguridad garantizar que una vez que un 
sistema dentro 
de la {\it honeynet} ha sido penetrado, este no se utilice como plataforma de
salto para atacar otras m\'aquinas, ni de nuestra organizaci\'on ni de cualquier
otra; la `red de miel' ha de permanecer perfectamente controlada, y por supuesto
aislada del resto de los segmentos de nuestra organizaci\'on. En segundo lugar,
otro aspecto b\'asico es la captura de datos, la monitorizaci\'on de las
actividades que un atacante lleva a cabo en la {\it honeynet}. Recordemos que 
nuestro objetivo principal era conocer los movimientos de la comunidad pirata
para poder extrapolarlos a sistemas reales, por lo que tambi\'en es muy 
importante para el correcto funcionamiento de una {\it honeynet} una correcta
recogida de datos generados por el atacante: ha de ser capturada toda la 
informaci\'on posible de cada acci\'on, de una forma poco agresiva (esto es, 
sin tener que realizar grandes cambios en cada uno de los sistemas) y por
supuesto sin que el atacante se entere. Adem\'as (muy importante), estos datos 
recogidos {\bf nunca} se
han de mantener dentro del per\'{\i}metro de la {\it honeynet}, ya que si fuera
as\'{\i} cualquier pirata podr\'{\i}a destruirlos con una probabilidad demasiado
elevada.\\
\\El concepto de {\it honeynet} es relativamente nuevo dentro del mundo de la
seguridad y, en concreto, de los sistemas de detecci\'on de intrusos; a pesar de
ello, se trata de una idea muy interesante que presumiblemente va a extenderse
de una forma m\'as o menos r\'apida (no todo lo r\'apida que nos gustar\'{\i}a, 
ya que implantar y explotar una {\it honeynet} no es algo ni trivial, ni mucho
menos r\'apido); cada d\'{\i}a m\'as, las herramientas de seguridad no se
conforman con detectar problemas conocidos, sino que tratan de anticiparse a 
nuevas vulnerabilidades que a\'un no se han publicado pero que pueden estar -- 
y de hecho est\'an -- presentes en multitud de sistemas. Conocer cuanto antes 
cualquier avance de la comunidad {\it underground} es algo vital si queremos 
lograr este objetivo.\\
\\Como antes hemos comentado, los sistemas de detecci\'on de intrusos basados en
red, de los que hemos hablado a lo largo de este punto, son con diferencia los
m\'as utilizados actualmente en sistemas en explotaci\'on; no obstante, como
casi cualquier herramienta relacionada con la seguridad, estos sistemas no son
ninguna panacea, y su implantaci\'on ha de verse complementada con una correcta
configuraci\'on de elementos como nuestro cortafuegos corporativo o, por 
supuesto, los sistemas de detecci\'on basados en {\it host}. Veremos m\'as 
adelante, en este mismo cap\'{\i}tulo, que ambos tipos de IDSes son igualmente
necesarios en nuestro entorno de trabajo.
\section{Detecci\'on de anomal\'{\i}as}
Desde que en 1980 James P. Anderson propusiera la detecci\'on de anomal\'{\i}as
como un m\'etodo v\'alido para detectar intrusiones en sistemas inform\'aticos
(\cite{kn:and80}), la l\'{\i}nea de investigaci\'on m\'as activa (esto es, la 
m\'as estudiada, pero no por ello la m\'as extendida en entornos reales) es 
la de\-no\-mi\-na\-da {\it Anomaly Detection IDS}, IDSes basados en la 
detecci\'on de a\-no\-ma\-l\'{\i}as. La idea es {\it a priori} muy interesante: 
estos
modelos de detecci\'on conocen lo que es `normal' en nuestra red o nuestras
m\'aquinas a lo largo del tiempo, desarrollando y actualizando conjuntos de
patrones contra los que comparar los eventos que se producen en los sistemas. Si
uno de esos eventos (por ejemplo, una trama procedente de una m\'aquina 
desconocida) se sale del conjunto de normalidad, autom\'aticamente se cataloga
como sospechoso.\\
\\Los IDSes basados en detecci\'on de anomal\'{\i}as se basan en la premisa de
que cualquier ataque o intento de ataque implica un uso anormal de los sistemas
(\cite{kn:ko96}, \cite{kn:ks94}\ldots). Pero,
>c\'omo puede un sistema conocer lo que es y lo que no es `normal' en nuestro
entorno de trabajo? Para conseguirlo, existen dos grandes aproximaciones 
(\cite{kn:bus99}): o es el sistema el que es capaz de aprenderlo por s\'{\i}
mismo (bas\'andose por ejemplo en el comportamiento de los usuarios, de sus
procesos, del tr\'afico de nuestra red\ldots) o bien se le especifica al sistema
dicho comportamiento mediante un conjunto de reglas. La primera de estas 
aproximaciones utiliza b\'asicamente
m\'etodos estad\'{\i}sticos (medias, varianzas\ldots), aunque tambi\'en 
existen modelos en los que se aplican algoritmos de aprendizaje autom\'atico; la
segunda aproximaci\'on consiste en especificar mediante un conjunto de reglas
los perfiles de comportamiento habitual bas\'andose en determinados 
par\'ametros de los sistemas (con la dificultad a\~nadida de decidir cu\'ales de
esos par\'ametros que con mayor precisi\'on delimitan los comportamientos
intrusivos).\\
\\En el primero de los casos (el basado en m\'etodos estad\'{\i}sticos), el
detector observa las actividades de los elementos del sistema, activos -- 
sujetos --, pasivos -- objetos -- o ambos, y genera para cada uno de ellos un
perfil que define su comportamiento; dicho perfil es almacenado en el sistema,
y se actualiza con determinada frecuencia envejeciendo la informaci\'on m\'as 
antigua y priorizando la m\'as fresca. El comportamiento del usuario en un 
determinado momento se guarda temporalmente en otro perfil, denominado `perfil
actual' ({\it current profile}), y a intervalos regulares se compara con el
almacenado previamente en busca de desviaciones que puedan indicar una 
anomal\'{\i}a.\\
\\En \cite{kn:jv93} se definen diferentes tipos de datos o medidas que pueden
ser \'utiles en la elaboraci\'on de estos perfiles:
\begin{enumerate}
\item Intensidad de la actividad. Reflejan el ratio de progreso de la actividad
en el sistema, para lo cual recogen datos a intervalos muy peque\~nos -- 
t\'{\i}picamente entre un minuto y una hora --. Estas medidas
detectan r\'afagas de comportamiento (por ejemplo, una excesiva generaci\'on de 
peticiones de entrada/salida en un cierto intervalo) que en espacios de tiempo
m\'as amplios no podr\'{\i}an ser detectadas.
\item Num\'ericas. Se trata de medidas de la actividad cuyo resultado se puede
representar en forma de valor num\'erico, como el n\'umero de ficheros 
le\'{\i}dos por cierto usuario en una sesi\'on o la cantidad de veces que ese
usuario se ha equivocado al teclear su contrase\~na de acceso al sistema.
\item Categ\'oricas. Las medidas categ\'oricas son aquellas cuyo resultado es
una categor\'{\i}a individual, y miden la frecuencia relativa o la 
distribuci\'on de una actividad determinada con respecto a otras actividades o
categor\'{\i}as; por ejemplo, cual es la 
relaci\'on entre la frecuencia de acceso a un determinado directorio del 
sistema en comparaci\'on con la de acceso a otro. Seguramente la palabra
`categor\'{\i}a' no es la m\'as afortunada (por lo menos, no la m\'as clara),
ya que bajo este t\'ermino se pueden englobar tanto a objetos (por ejemplo, 
ficheros) como a eventos (por ejemplo, llamadas a la funci\'on {\tt crypt()}) 
del sistema; esta definici\'on gen\'erica puede resultar m\'as sencilla si 
distinguimos entre 
categor\'{\i}as globales e individuales: en castellano plano, podemos entender
las categor\'{\i}as globales como acciones muy gen\'ericas dentro de un entorno,
mientras que las categor\'{\i}as individuales ser\'{\i}an la particularizaci\'on
para un elemento determinado del sistema. As\'{\i}, una categor\'{\i}a global
puede ser la formada por el conjunto de accesos remotos a la m\'aquina, 
mientras que una individual ser\'{\i}a la formada por los accesos desde una
determinada ubicaci\'on f\'{\i}sica.
\item Distribuci\'on de registros de auditor\'{\i}a. Esta medida analiza la
distribuci\'on de las actividades generadas en un pasado reciente bas\'andose
en los {\it logs} generados por las mismas; dicho an\'alisis se realiza de forma
ponderada, teniendo m\'as peso las actividades m\'as recientes, y es comparado
con un perfil de actividades `habituales' previamente almacenado, de forma
que permite detectar si en un pasado reciente se han generado eventos
inusuales.
\end{enumerate}
La segunda aproximaci\'on a la que antes hemos hecho referencia era la 
consistente en indicar me\-dian\-te un conjunto de reglas el comportamiento 
habitual
del sistema; suele ser denominada detecci\'on de anomal\'{\i}as basada en 
especificaciones ({\it specification--based anomaly detection}), y fu\'e 
propuesta y desarrollada inicialmente por Calvin Cheuk Wang Ko y otros 
investigadores de la Universidad de California en Davis, durante la segunda 
mitad de los noventa (\cite{kn:ko96}, \cite{kn:ko97}\ldots). La idea en la que
se sustentan los sistemas de detecci\'on de anomal\'{\i}as basados en 
especificaciones es que se puede describir el comportamiento `deseable' 
(entendiendo por `deseable' el comportamiento `normal') de cualquier programa
cuya seguridad sea cr\'{\i}tica; esta descripci\'on se realiza en base a una
especificaci\'on de seguridad mediante gram\'aticas, y se considera una 
violaci\'on  de la seguridad 
-- al menos en principio -- a las ejecuciones de dichos programas que violen su 
respectiva especificaci\'on.\\
\\Para ver m\'as claramente el concepto de la detecci\'on de anomal\'{\i}as
basada en especificaciones, podemos pensar en la ejecuci\'on de un programa que
se puede considerar cr\'{\i}tico, por ser privilegiado: {\tt /bin/passwd}. Si
conseguimos diferenciar las diferentes ejecuciones de esta orden que se pueden
considerar `habituales' (por ejemplo, cuando un usuario cambia su contrase\~na
sin problemas, cuando se equivoca, cuando el sistema no le deja cambiarla por
los motivos t\'{\i}picos -- es d\'ebil, hace poco que la cambi\'o\ldots --), 
podr\'{\i}amos especificar formalmente cada una de estas secuencias de 
operaci\'on. De esta forma, cada vez que un usuario invoque a {\tt /bin/passwd},
el sistema de detecci\'on monitorizar\'a las operaciones que esa llamada genere,
y considerar\'a una intrusi\'on a cualquiera que no sea `habitual'.\\
\\La idea de los sistemas de detecci\'on de intrusos basados en la detecci\'on 
de anomal\'{\i}as es realmente atractiva; no obstante, existen numerosos 
problemas a los que estos mecanismos tratan de hacer frente. En primer lugar 
podemos pararnos a pensar en las dificultades que existen a la hora de 
`aprender' o simplemente especificar lo habitual:
si alguien piensa que por ejemplo obtener un patr\'on de tr\'afico `normal' en 
una red es f\'acil, se equivoca; quiz\'as establecer un conjunto de procesos
habituales en una \'unica m\'aquina resulte menos complicado, pero tampoco se 
trata de una tarea trivial. Adem\'as, conforme aumentan las dimensiones de los
sistemas (redes con un gran n\'umero de m\'aquinas interconectadas, equipos con
miles de usuarios\ldots) estos se hacen cada vez m\'as aleatorios e 
impredecibles.\\
\\Otro gran problema de los sistemas basados en detecci\'on de anomal\'{\i}as
radica en la pol\'{\i}tica de aprendizaje que \'estos sigan (\cite{kn:ran98}); 
si se trata de 
esquemas donde el aprendizaje es r\'apido, un intruso puede generar eventos 
para conseguir un modelo distorsionado de lo `normal' antes de que el 
responsable -- humano -- de los sistemas se percate de ello, de forma que el 
IDS no llegue a detectar un ataque porque lo considera algo `habitual'. Si por
el contrario el aprendizaje es lento, el IDS considerar\'a cualquier evento que
se aleje m\'{\i}nimamente de sus patrones como algo an\'omalo, generando un
gran n\'umero de falsos positivos (falsas alarmas), que a la larga har\'an que
los responsables de los sistemas ignoren cualquier informaci\'on proveniente del
IDS, con los evidentes riesgos que esto implica.
\section{Detecci\'on de usos indebidos}
Dentro de la clasificaci\'on de los sistemas de detecci\'on de intrusos en
base a su forma de actuar, la segunda gran familia de modelos es la formada por
los basados en la detecci\'on de usos indebidos. Este esquema se basa en 
especificar de una forma m\'as o menos formal las potenciales intrusiones que 
amenazan a un sistema y simplemente esperar a que alguna de ellas ocurra; para
conseguirlo existen cuatro grandes aproximaciones (\cite{kn:ko96}): los 
sistemas expertos, los an\'alisis de transici\'on entre estados, las reglas de
comparaci\'on y emparejamiento de patrones ({\it pattern matching}) y la 
detecci\'on basada en modelos.\\
\\Los primeros sistemas de detecci\'on de usos indebidos, como NIDES 
(\cite{kn:lu92}), se basaban en los sistemas expertos para realizar su trabajo; 
en ellos las intrusiones se codifican como reglas de la base de conocimiento 
del sistema experto, de la forma gen\'erica {\it if--then} ({\it if} {\sc 
condici\'on} {\it then} {\sc acci\'on}). Cada una de estas reglas
puede detectar eventos \'unicos o secuencias de eventos que denotan una 
potencial intrusi\'on, y se basan en el an\'alisis -- generalmente en tiempo 
real -- de los registros de auditor\'{\i}a proporcionados por cualquier sistema
Unix: esta es una de las principales ventajas de los sistemas expertos, el hecho
de que el mecanismo de registro dentro de Unix venga proporcionado `de serie',
ya que de esta forma el sistema de detecci\'on trabaja siempre por encima del
espacio del sistema operativo, algo que facilita enormemente su integraci\'on 
dentro de diferentes clones de Unix.\\
\\Podemos pensar en un caso real que nos ayude a comprender el funcionamiento de
los sistemas expertos a la hora de detectar intrusiones; el t\'{\i}pico 
ejemplo es la detecci\'on de un mismo usuario conectado simult\'aneamente desde
dos direcciones diferentes. Cada vez que un usuario se autentica correctamente
en el sistema, cualquier Unix genera una l\'{\i}nea de registro que se guarda 
en el fichero de {\it log} correspondiente; as\'{\i}, al conectar a un servidor
Linux Slackware v\'{\i}a {\sc ssh}, se registra el evento de esta forma:
\begin{center}
\begin{verbatim}
May 27 03:08:27 rosita sshd[5562]: User toni, coming from anita, authenticated.
\end{verbatim}
\end{center}
Al leer este registro, un sistema experto comprobar\'{\i}a si el usuario {\tt
toni} ya tiene una sesi\'on abierta desde una m\'aquina diferente de {\tt 
anita}; si esta condici\'on se cumple (recordemos la forma gen\'erica de las
reglas del sistema experto, {\it if--then}) se realizar\'{\i}a la acci\'on 
definida en la regla correspondiente, por norma generar una alarma dirigida al
responsable de seguridad del sistema.\\
\\La segunda implementaci\'on de los sistemas de detecci\'on de usos indebidos 
era la basada en los an\'alisis de transici\'on entre estados (\cite{kn:por92});
bajo este esquema, una intrusi\'on se puede contemplar como una secuencia de
eventos que conducen al atacante desde un conjunto de estados inicial a un 
estado determinado, representando este \'ultimo una violaci\'on
consumada de nuestra seguridad. Cada uno de esos estados no es m\'as que una
imagen de diferentes par\'ametros del sistema en un momento determinado, siendo
el estado inicial el inmediatamente posterior al inicio de la intrusi\'on, y el
\'ultimo de ellos el resultante de la completitud del ataque; la idea es que 
si conseguimos identificar los estados intermedios entre ambos, seremos capaces
de detener la intrusi\'on antes de que se haga efectiva.\\
\\Sin duda el sistema de detecci\'on basado en el an\'alisis de transici\'on
entre estados m\'as conocido es {\sc ustat} (\cite{kn:il93}), basado en {\sc 
stat} (\cite{kn:por92a}). Este modelo fu\'e desarrollado inicialmente sobre 
SunOS 4.1.1 (en la actualidad est\'a portado a Solaris 2), y utiliza los 
registros de auditor\'{\i}a ge\-ne\-ra\-dos por el {\it C2 Basic Security 
Module} de este operativo. En {\sc ustat}, estos registros del {\sc c2-bsm} son 
transformados a otros de la forma {\sc $<$s, a, o$>$}, representando cada uno 
de ellos un evento de la forma {\it `el sujeto S realiza la acci\'on A sobre el 
objeto O'}; a su vez, cada elemento de la terna anterior est\'a formado por
diferentes campos que permiten identificar un\'{\i}vocamente el evento 
representado. El sistema de detecci\'on utiliza adem\'as una base de datos --
realmente, se trata de simples ficheros planos -- formada principalmente por 
dos tablas, una donde se almacenan las descripciones de los diferentes estados 
(SDT, {\it State Description Table}) y otra en la que se almacenan las 
transiciones entre estados que denotan un potencial ataque (SAT, {\it Signature 
Action Table}). Cuando {\sc ustat} registre una sucesi\'on determinada de
eventos que representen un ataque entrar\'a en juego el motor de decisiones, que
emprender\'a la acci\'on que se le haya especificado (desde un simple mensaje
en consola informando de la situaci\'on hasta acciones de respuesta autom\'atica
capaces de interferir en tiempo real con la intrusi\'on).\\
\\La tercera implementaci\'on que hab\'{\i}amos comentado era la basada en el
uso de reglas de comparaci\'on y emparejamiento de patrones o {\it pattern 
matching} (\cite{kn:sg91}, \cite{kn:ks94}); en ella, el 
detector se basa en la premisa de que el sistema llega a un estado comprometido 
cuando recibe como entrada el patr\'on de la intrusi\'on, sin importar el 
estado en que se encuentre en ese momento. Dicho de otra forma, simplemente
especificando patrones que denoten intentos de intrusi\'on el sistema puede
ser capaz de detectar los ataques que sufre, sin importar el estado inicial en
que est\'e cuando se produzca dicha detecci\'on, lo cual suele representar una
ventaja con respecto a otros modelos de los que hemos comentado.\\
\\Actualmente muchos de los sistemas de detecci\'on de intrusos m\'as conocidos
(por poner un ejemplo, podemos citar a {\sc snort} o {\it RealSecure}) est\'an
basados en el {\it pattern matching}. Utilizando una base de datos de patrones
que denotan ataques, estos programas se dedican a examinar todo el tr\'afico 
que ven en su segmento de red y a comparar ciertas propiedades de cada trama
observada con las registradas en su base de datos como potenciales ataques; si
alguna de las tramas empareja con un patr\'on sospechoso, autom\'aticamente se
genera una alarma en el registro del sistema. En el punto \ref{snort} 
hablaremos con m\'as detalle del funcionamiento de {\sc snort}, uno de los
sistemas de detecci\'on de intrusos basados en red m\'as utilizado en entornos
con requisitos de seguridad media.\\
\\Por \'ultimo, tenemos que hablar de los sistemas de detecci\'on de intrusos
basados en modelos (\cite{kn:gl91}); se trata de una aproximaci\'on 
conceptualmente muy similar a la basada en la transici\'on entre estados, en el 
sentido que contempla los ataques como un conjunto de estados y objetivos, pero 
ahora se representa a los mismos como escenarios en lugar de hacerlo como 
transiciones entre estados. En este caso se combina la 
detecci\'on de usos indebidos con una deducci\'on o un ra\-zo\-na\-mien\-to que 
concluye la existencia o inexistencia de una intrusi\'on; para ello, el sistema
utiliza una base de datos de escenarios de ataques, cada uno de los cuales 
est\'a formado por una secuencia de eventos que conforman el ataque. En cada
momento existe un subconjunto de esos escenarios, denominado {\it de escenarios
activos}, que representa los ataques que se pueden estar presentando en el 
entorno; un proceso denominado {\it anticipador} analiza los registros de
auditor\'{\i}a generados por el sistema y obtiene los eventos a verificar en
dichos registros para determinar si la intrusi\'on se est\'a o no produciendo
(realmente, al ser esos registros dependientes de cada sistema Unix, el 
anticipador pasa su informaci\'on a otro proceso denominado {\it planner}, que
los traduce al formato de auditor\'{\i}a utilizado en cada sistema). El 
anticipador tambi\'en actualiza constantemente el conjunto de es\-ce\-na\-rios 
activos, de manera que este estar\'a siempre formado por los 
escenarios que representan ataques posibles en un determinado momento y no por 
la base de datos completa.\\
\\Hasta hace poco tiempo no exist\'{\i}an sistemas de detecci\'on de intrusos 
basados en modelos funcionando en sistemas reales (\cite{kn:ku95}), por lo que 
era dif\'{\i}cil determinar aspectos como su eficiencia a la hora de detectar 
ataques. En 1998 se present\'o {\sc nstat} (\cite{kn:ke98}), una extensi\'on de
{\sc ustat} (del cual hemos hablado antes) a entornos distribuidos y redes de
computadores, y en el que se combina el an\'alisis de transici\'on entre 
estados con la detecci\'on de intrusos basada en modelos. A pesar de todo, este
modelo es el menos utilizado a la hora de detectar ataques y efectuar respuestas
autom\'aticas ante los mismos, especialmente si lo comparamos con los basados en
la comparaci\'on y emparejamiento de patrones.\\
\\Los IDSes basados en la detecci\'on de usos indebidos son en principio m\'as
robustos que los basados en la detecci\'on de anomal\'{\i}as: al conocer la
forma de los ataques, es te\'oricamente extra\~no que generen falsos positivos 
(a no ser que se trate de un evento autorizado pero muy similar al patr\'on de 
un ataque); es necesario recalcar el matiz `te\'oricamente', porque como 
veremos m\'as adelante, la generaci\'on de falsos positivos es un problema a la
hora de implantar cualquier sistema de detecci\'on. No obstante, en este mismo 
hecho radica su debilidad: s\'olo son 
capaces de detectar lo que conocen, de forma que si alguien nos lanza un ataque
desconocido para el IDS \'este no nos notificar\'a ning\'un problema; como ya
dijimos, es algo similar a los programas antivirus, y de igual manera que cada
cierto tiempo es conveniente (en MS-DOS y derivados) actualizar la versi\'on 
del antivirus usado, tambi\'en es conveniente mantener al d\'{\i}a la base de 
datos de los IDSes basados en detecci\'on de usos indebidos. A\'un as\'{\i},
seremos vulnerables a nuevos ataques.\\
\\Otro grave problema de los IDSes basados en la detecci\'on de usos indebidos
es la incapacidad para detectar patrones de ataque convenientemente camuflados.
Volviendo al ejemplo de los antivirus, pensemos en un antivirus que base su
funcionamiento en la b\'usqueda de cadenas virales: lo que b\'asicamente har\'a
ese programa ser\'a buscar cadenas de c\'odigo hexadecimal pertenecientes a 
determinados virus en cada uno de los archivos a analizar, de forma que si 
encuentra alguna de esas cadenas el {\it software} asumir\'a que el fichero
est\'a contaminado. Y de la misma forma que un virus puede ocultar su presencia
simplemente cifrando esas cadenas (por ejemplo de forma semialeatoria utilizando
eventos del sistema, como el reloj), un atacante puede evitar al sistema de
detecci\'on de intrusos sin m\'as que insertar espacios en blanco o rotaciones 
de {\it bits} en ciertos patrones del ataque; aunque algunos IDSes son capaces
de identificar estas transformaciones en un patr\'on, otros muchos no lo hacen.
\section{Implementaci\'on real de un IDS}
\begin{figure}
\begin{center}
\setlength{\unitlength}{3947sp}%
%
\begingroup\makeatletter\ifx\SetFigFont\undefined%
\gdef\SetFigFont#1#2#3#4#5{%
  \reset@font\fontsize{#1}{#2pt}%
  \fontfamily{#3}\fontseries{#4}\fontshape{#5}%
  \selectfont}%
\fi\endgroup%
\begin{picture}(6174,3699)(589,-2923)
\thinlines
\put(1426, 14){\oval(1350,900)}
\put(5326,-1261){\oval(1500,900)}
\put(601,-2911){\framebox(6150,3675){}}
\put(2701,164){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{\rmdefault}{\bfdefault}{\updefault}Router}}}
\put(3001,-61){\oval(900,450)[bl]}
\put(3001,-61){\oval(900,450)[br]}
\put(3001,-2011){\circle{150}}
\put(3676, 89){\circle{150}}
\put(6301,-1411){\circle{150}}
\put(4426,314){\circle{150}}
\put(3751,-211){\circle{336}}
\put(3226,-2236){\circle{336}}
\put(4126,464){\circle{336}}
\put(6451,-1711){\circle{336}}
\put(3001,239){\oval(900,600)}
\put(3001,-661){\line(-3,-2){900}}
\put(2101,-1261){\line( 5,-3){893.382}}
\put(3001,-1786){\line( 3, 2){900}}
\put(3901,-1186){\line(-5, 3){893.382}}
\put(3451,164){\line( 0,-1){225}}
\put(2551,164){\line( 0,-1){225}}
\put(4651,-61){\framebox(750,525){}}
\put(4726, 14){\framebox(600,375){}}
\put(4726,-136){\line( 1, 0){600}}
\put(4576,-361){\line( 1, 0){600}}
\put(5176,-361){\line( 2, 3){150}}
\put(4576,-361){\line( 2, 3){150}}
\put(4801,-211){\line( 1, 0){225}}
\put(4726,-286){\line( 1, 0){225}}
\put(5101,-211){\line( 1, 0){ 75}}
\put(5026,-286){\line( 1, 0){ 75}}
\put(2101, 89){\vector( 1, 0){450}}
\put(3901,-1186){\vector( 1, 0){675}}
\put(5551,164){\vector(-1, 0){150}}
\put(5551,164){\line( 0,-1){975}}
\put(3001,-286){\vector( 0,-1){375}}
\put(3451, 89){\line( 1, 0){150}}
\put(3001,-1786){\line( 0,-1){150}}
\put(6076,-1411){\line( 1, 0){150}}
\put(4651,314){\line(-1, 0){150}}
\put(4651, 14){\line(-1, 0){225}}
\put(4426, 14){\line( 0,-1){225}}
\put(4426,-211){\line( 1, 0){225}}
\put(2776,-1261){\makebox(0,0)[lb]{\smash{\SetFigFont{14}{16.8}{\rmdefault}{\bfdefault}{\updefault}FW}}}
\put(3676,-286){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault} 1}}}
\put(3151,-2311){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault} 2}}}
\put(6376,-1786){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault} 3}}}
\put(4051,389){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault} 4}}}
\put(1201,-61){\makebox(0,0)[lb]{\smash{\SetFigFont{14}{16.8}{\rmdefault}{\bfdefault}{\updefault}INet}}}
\put(5101,-1336){\makebox(0,0)[lb]{\smash{\SetFigFont{14}{16.8}{\rmdefault}{\bfdefault}{\updefault}LAN}}}
\end{picture}
\end{center}
\caption{Puntos cl\'asicos de defensa entre un atacante y un objetivo.}
\label{sensores-ids}
\end{figure}
Vamos a tratar ahora de definir unas pautas para crear un sistema distribuido
de detecci\'on de intrusos, capaz de generar respuestas autom\'aticas, alarmas, 
o simplemente {\it logs} a distintos niveles de nuestra arquitectura de red, 
formando lo que se suele denominar un modelo de seguridad de c\'{\i}rculos
conc\'entricos (\cite{kn:isv95}). Para ello, imaginemos un pirata externo a 
nuestra organizaci\'on que intenta atacar una determinada m\'aquina, y 
pensemos en el primer punto en el que podemos detectar dicho ataque y actuar 
sobre \'el: ah\'{\i} es donde deberemos implantar el primer sensor, ya que se
trata de la primera barrera que estamos interponiendo entre el atacante y su
objetivo; ese primer punto no es otro que nuestro {\it router} de salida a
Internet, el marcado como `1' en la figura \ref{sensores-ids} (pido perd\'on 
por mi estilo `art\'{\i}stico'). No podemos 
entrar aqu\'{\i} a tratar detalles sobre las capacidades 
de detecci\'on de intrusos de productos como los {\it routers} Cisco y su IOS, 
o de otros elementos f\'acilmente integrables con esta electr\'onica de red, 
como NetRanger (tambi\'en de Cisco), ya que se trata de sistemas que poco tienen
que ver con Unix, y que en muchos casos no controlamos nosotros directamente
sino una tercera organizaci\'on (por ejemplo, Telef\'onica), a pesar de que
tengan incluso una direcci\'on IP perteneciente a nuestra red. En las p\'aginas
{\it web} de los distintos fabricantes se puede encontrar informaci\'on muy
\'util sobre sus productos orientados a la detecci\'on y respuesta ante 
ataques.
\subsection{IDS en el cortafuegos}
Volviendo a la figura \ref{sensores-ids}, el segundo punto que separar\'a al 
atacante de 
su objetivo (es decir, nos proteger\'a de \'el) ser\'a nuestro cortafuegos 
corporativo. Este elemento, sobre el que probablemente ya tendremos pleno 
control, estar\'a formado por uno o varios sistemas Unix con un {\it software}
de filtrado de paquetes ejecut\'andose sobre ellos, y es aqu\'{\i} donde vamos
a implantar el primer esquema de detecci\'on de intrusos y respuesta 
autom\'atica ante ataques (esta respuesta ser\'a habitualmente el bloqueo de
la direcci\'on atacante en el propio {\it firewall}).\\
\\Para decidir qu\'e tipos de ataques debemos detectar y bloquear en nuestro
cortafuegos debemos pararnos a pensar con qu\'e informaci\'on trabaja 
habitualmente este sistema; cualquier {\it firewall} lo har\'a al menos con
los cinco elementos que definen una conexi\'on bajo la pila {\sc tcp/ip}: 
direcci\'on origen, direcci\'on destino, puerto origen, puerto destino y
protocolo. De estos cinco, quiz\'as los dos menos importantes (de cara a 
detectar ataques) son quiz\'as el protocolo utilizado y el puerto origen de la
conexi\'on; por tanto, son los otros tres elementos los que nos ayudar\'an en
la constituci\'on de nuestro IDS y los que nos facilitar\'an el poder lanzar
una respuesta autom\'atica contra el atacante.\\
\\Conociendo las direcciones origen y destino y el puerto destino de una 
conexi\'on ya podemos detectar cierto tipo de ataques; quiz\'as el ejemplo
m\'as habitual son los escaneos de puertos, tanto horizontales como verticales,
que se lanzan contra nuestros sistemas. La t\'ecnica de detecci\'on de estos 
ataques se define perfectamente en \cite{kn:nor99}: est\'a basada por el 
momento en comprobar X eventos de inter\'es dentro de una ventana de tiempo Y.
As\'{\i}, podemos analizar en nuestro cortafuegos cu\'ando una misma 
direcci\'on origen accede a un determinado puerto de varios destinos en menos de
un cierto tiempo umbral (escaneo horizontal) o cuando accede a diferentes 
puertos bien conocidos de un mismo sistema tambi\'en en menos de ese tiempo 
umbral (escaneo vertical). >Por qu\'e el hecho de fijarnos s\'olo en puertos
bien conocidos en este \'ultimo caso? Muy sencillo: muchas aplicaciones abren
muchos puertos destino, generalmente altos (por encima del 1024), en una 
\'unica sesi\'on de funcionamiento, por lo que esa sesi\'on ser\'{\i}a 
identificada por el cortafuegos como un escaneo vertical cuando realmente no lo
es (y si adem\'as en nuestro esquema de respuesta autom\'atica decidimo bloquear
la IP `atacante', causar\'{\i}amos una grave negaci\'on de servicio contra
usuarios leg\'{\i}timos de nuestros sistemas).\\
\\Una t\'ecnica alternativa que con frecuencia suele ser utilizada con bastante
efectividad para detectar escaneos verticales consiste en vigilar del
acceso a determinados puertos de los sistemas protegidos por el {\it firewall}, 
acceso 
que con toda probabilidad representar\'a un intento de violaci\'on de nuestras 
pol\'{\i}ticas de seguridad. No nos enga\~nemos: si alguien trata de acceder 
desde fuera del segmento protegido a puertos como {\tt echo} (7/{\sc tcp},{\sc 
udp}), {\tt systat} (11/{\sc tcp}), {\tt netstat} (15/{\sc tcp}), {\tt tcpmux}
(1/{\tt tcp}) o el desfasado {\tt uucp} (540/{\sc tcp}), lo m\'as probable es 
que se trate de una persona que no lleva muy buena intenci\'on con respecto a 
nuestras m\'aquinas. Seguramente estar\'a lanzando un escaneo vertical contra
nosotros, aunque a veces tambi\'en se puede tratar de un simple curioso que 
trata de comprobar
nuestro grado de seguridad para lanzar un ataque posterior: evidentemente, si
alguien tiene abierto un puerto de los citados anteriormente, denota una
escasa preocupacion por su seguridad, por lo que casi con toda certeza se puede
intuir que tendr\'a agujeros importantes en alguna de sus m\'aquinas.\\
\\Otro tipo de ataques que tambi\'en son f\'acilmente detectables vigilando el
acceso a determinados puertos de nuestros sistemas protegidos son aquellos que
detectan la presencia -- o la comprobaci\'on de la presencia -- de diferentes 
troyanos como NetBus o BackOrifice: si en el {\it firewall} se detecta 
tr\'afico dirigido a puertos como 12345, 12346 o 20034 ({\sc tcp}) o como 
31337 ({\sc udp}), sin duda se trata de un atacante que est\'a tratando de
aprovechar estos troyanos; en muchos casos -- la mayor\'{\i}a -- se tratar\'a de
escaneos horizontales en busca de m\'aquinas contaminadas a lo largo de toda o
gran parte de nuestra clase C.
\begin{table}
\begin{center}
\begin{tabular}{|c|c|c||c|}
\hline
Servicio & Puerto & Protocolo & Ataque\\
\hline\hline
{\tt ttymux} & 1 & {\sc tcp} & Escaneo horizontal\\
\hline
{\tt echo} & 7 & {\sc tcp}/{\sc udp} & Escaneo horizontal\\
\hline
{\tt systat} & 7 & {\sc tcp} & Escaneo horizontal\\
\hline
{\tt daytime} & 13 & {\sc tcp}/{\sc udp} & Escaneo horizontal\\
\hline
{\tt netstat} & 15 & {\sc tcp} & Escaneo horizontal\\
\hline
{\tt finger} & 79 & {\sc tcp} & Escaneo horizontal/vertical\\
\hline
{\tt who} & 513 & {\sc udp} & Escaneo horizontal\\
\hline
{\tt uucp} & 540 & {\sc tcp} & Escaneo horizontal/vertical\\
\hline
NetBus & 12345 & {\sc tcp} & Troyano\\
\hline
NetBus & 12346 & {\sc tcp} & Troyano\\
\hline
NetBus & 20034 & {\sc tcp} & Troyano\\
\hline
BackOrifice & 31337 & {\sc udp} & Troyano\\
\hline
Hack\'{}a\'{}Tack & 31789 & {\sc udp} & Troyano\\
\hline
Hack\'{}a\'{}Tack & 31790 & {\sc udp} & Troyano\\
\hline
\end{tabular}
\end{center}
\caption{Algunos puertos a monitorizar en un {\it firewall}}
\label{puertos}
\end{table}
En la tabla \ref{puertos} se muestran algunos de los puertos a los que conviene 
estar atentos a la hora de dise\~nar una pol\'{\i}tica de detecci\'on de 
intrusos en nuestro cortafuegos; por supuesto, existen muchos m\'as que pueden 
ser considerados `sospechosos', pero en cualquier caso siempre conviene ser muy 
precavido con su monitorizaci\'on ya que algunos de ellos pueden ser usados
por usuarios l\'{\i}citos a los que causar\'{\i}amos una grave negaci\'on de
servicio si, por ejemplo, les bloque\'aramos el acceso a nuestra red a causa de
un falso positivo.\\
\\Todos sabemos que el cortafuegos es algo vital para proteger a nuestros 
sistemas, pero lamentablemente es un elemento muy limitado a la hora de 
detectar ataques. Por ejemplo, imaginemos la siguiente situaci\'on: un atacante
decide comprobar si nuestro servidor {\it web} corporativo tiene alg\'un tipo 
de vulnerabilidad que le pueda ayudar en un ataque contra la m\'aquina; algo
muy com\'un hoy en d\'{\i}a, ya que quiz\'as uno de los mayores da\~nos que 
puede sufrir la imagen de una empresa -- especialmente si est\'a relacionada 
con las nuevas tecnolog\'{\i}as -- es una modificaci\'on de su p\'agina {\it 
web} principal. Es muy probable que ese pirata lanzara en primer lugar un 
escaneo de puertos vertical contra el servidor, para comprobar si aparte del
servicio {\sc http} se est\'a ofreciendo alg\'un otro; si todo es correcto, el
puerto de {\it web} ser\'a el \'unico abierto en el cortafuegos corporativo,
cortafuegos que adem\'as detectar\'a el ataque contra la m\'aquina y 
bloquear\'a, al menos temporalmente, cualquier acceso de la direcci\'on 
atacante. Un punto a nuestro favor, pero el pirata no tiene m\'as que colgar
el m\'odem y volver a llamar a su proveedor para conseguir otra IP, con lo cual
obtiene de nuevo acceso a nuestro servicio {\sc http} y adem\'as ya sabe
que el \'unico puerto abierto en la m\'aquina es ese.\\
\\Ahora ese atacante no necesita ning\'un tipo de escaneo de puertos adicional;
puede seguir varios caminos para atacarnos, pero sin duda el m\'as l\'ogico y
f\'acil es tratar de localizar vulnerabilidades en el servidor {\it web} de 
nuestra
organizaci\'on. Para ello puede lanzar un escaneador de vulnerabilidades en 
servidores {\it web}\footnote{Generalmente se les denomina {\it CGI Scanners}, 
aunque no s\'olo comprueban la presencia de CGIs vulnerables, sino que 
tambi\'en detectan errores de configuraci\'on, versiones de los demonios, etc.}
contra la m\'aquina, escaneador que no generar\'a ninguna alerta en el 
cortafuegos; al fin y al cabo, lo \'unico que hacen estos programas es lanzar
peticiones al puerto 80 de nuestro servidor {\it web}, algo que el {\it 
firewall} no contempla como sospechoso: para \'el, no hay diferencia entre un 
analizador de CGIs y peticiones normales a nuestras p\'aginas.\\
\\Parece por tanto evidente que nuestra primera barrera de detecci\'on de
intrusos es realmente \'util, pero tambi\'en insuficiente frente a determinados
ataques; entonces entra en juego el segundo nivel de nuestro sistema de 
detecci\'on de intrusos, el ubicado en el segmento de red -- en el dominio de
colisi\'on -- en el que se encuentra el {\it host} que estamos tratando de
proteger.
\subsection{IDS en la red: {\sc snort}}
\label{snort}
{\sc snort} (\cite{kn:roe99}) es un {\it sniffer} capaz de actuar como sistema 
de detecci\'on de intrusos en redes de tr\'afico moderado; su facilidad de 
configuraci\'on, su adaptabilidad, sus requerimientos m\'{\i}nimos (funciona 
en diferentes Unices, incluyendo un simple PC con Linux, Solaris o cualquier 
BSD gratuito), 
y sobre todo su precio (se trata de un {\it software} completamente gratuito
que podemos descargar desde su p\'agina oficial en INet, {\tt 
http://www.snort.org/}) lo convierten en una \'optima elecci\'on en multitud de 
entornos, frente a otros sistemas como NFR ({\it Network Flight Recorder}) o 
ISS RealSecure que, aunque quiz\'as sean m\'as potentes, son tambi\'en mucho
m\'as pesados e infinitamente m\'as caros.\\
\\Para instalar un sistema de detecci\'on de intrusos basado en {\sc snort} 
en primer lugar necesitamos evidentemente este programa, que podemos descargar
desde su p\'agina {\it web}. Adem\'as, para compilarlo correctamente es
necesario disponer de las librer\'{\i}as {\tt libpcap}, un interfaz para
tratamiento de paquetes de red desde espacio de usuario, y es recomendable
tambi\'en (aunque no obligatorio) instalar {\tt Libnet}, librer\'{\i}a para
la construcci\'on y el manejo de paquetes de red. Con este {\it software} 
correctamente instalado en nuestro sistema, la compilaci\'on de {\sc snort} es
trivial.\\
\\Si volvemos a la clasificaci\'on de IDSes que hemos presentado al principio
de este cap\'{\i}tulo, podemos clasificar a {\sc snort} como un sistema basado
en red (se monitoriza todo un dominio de colisi\'on) y que funciona mediante
detecci\'on de usos indebidos. Estos usos indebidos -- o cuanto menos {\it
sospechosos} -- se reflejan en una base de datos formada por patrones de 
ataques; dicha base de datos se puede descargar tambi\'en desde la propia 
p\'agina {\it web} de 
{\sc snort}, donde adem\'as se pueden generar bases de patrones `a medida' de
diferentes entornos (por ejemplo, ataques contra servidores {\it web}, intentos
de negaciones de servicio, {\it exploits}\ldots). El archivo que utilicemos en
nuestro entorno ser\'a la base para el correcto funcionamiento de nuestro 
sistema de detecci\'on de intrusos.\\
\\Una vez hemos compilado e instalado correctamente el programa llega el momento
de ponerlo en funcionamiento; y es aqu\'{\i} donde se produce -- al menos
inicialmente -- uno de los errores m\'as graves en la detecci\'on de intrusos.
Por l\'ogica, uno tiende a pensar que el sensor proporcionar\'a mejores 
resultados cuantos m\'as patrones de ataques contenga en su base de datos; 
nada m\'as lejos de la realidad. En primer lugar, es muy probable que no todos 
los ataques que {\sc snort} es capaz de detectar sean susceptibles de 
producirse en el segmento de red monitorizado; si situamos el sensor en una
zona desmilitarizada donde \'unicamente ofrecemos servicio de {\it web}, >qu\'e
inter\'es tiene tratar de detectar ataques contra DNS? Lo l\'ogico es que 
las pol\'{\i}ticas implementadas en nuestro cortafuegos ni siquiera dejen
pasar tr\'afico hacia puertos que no sean los de los servidores {\it web} pero,
incluso en caso de que el potencial ataque se produjera entre m\'aquinas del 
propio segmento, hemos de evaluar con mucho cuidado si realmente vale la pena
sobrecargar la base de datos con patrones que permitan detectar estos ataques.
Evidentemente, cuanta m\'as az\'ucar m\'as dulce, pero si el sensor ha de 
analizar todo el tr\'afico, quiz\'as mientras trata de decidir si un paquete 
entre dos m\'aquinas protegidas se adapta a un patr\'on estamos dejando pasar
tramas provenientes del exterior que realmente representan ataques: hemos de
tener presente que el {\it sniffer} no detendr\'a el tr\'afico que no sea
capaz de analizar para hacerlo m\'as tarde, sino que simplemente lo dejar\'a
pasar. As\'{\i}, debemos introducir en la base de patrones de ataques los 
justos para detectar actividades sospechosas contra nuestra red.\\
\\En segundo lugar, pero no menos importante, es necesario estudiar los 
patrones de tr\'afico que circulan por el segmento donde el sensor escucha 
para detectar falsos positivos y, o bien reconfigurar la base de datos, o bien
eliminar los patrones que generan esas falsas alarmas. Aunque suene algo crudo,
si un patr\'on nos genera un n\'umero considerable de falsos positivos, debemos
plantearnos su eliminaci\'on: simplemente no podremos decidir si se trata de
verdaderas o de falsas alarmas. Esto es especialmente cr\'{\i}tico si lanzamos
respuestas autom\'aticas contra las direcciones `atacantes' (por ejemplo,
detener todo su tr\'afico en nuestro {\it firewall}): volviendo al ejemplo de
la zona desmilitarizada con servidores {\it web}, podemos llegar al extremo de 
detener a simples visitantes de nuestras p\'aginas simplemente porque han
generado falsos positivos; aunque en un entorno de alta seguridad quiz\'as
vale la pena detener muchas acciones no da\~ninas con tal de bloquear tambi\'en
algunos ataques (aunque constituir\'{\i}a una negaci\'on de servicio en toda 
regla contra los usuarios que hacen uso leg\'{\i}timo de nuestros sistemas), en 
un entorno normal de producci\'on esto es impensable. Seguramente ser\'a m\'as
provechoso detectar y detener estos ataques por otros mecanismos ajenos al
sensor.\\
\\En resumen, hemos de adaptar a nuestro entorno de trabajo, de una forma muy 
fina, la base de datos de patrones de posibles ataques. Quiz\'as valga la
pena perder tiempo el tiempo que sea necesario en esta parte de la 
implantaci\'on, ya que eso nos ahorrar\'a despu\'es muchos an\'alisis de
falsas alarmas y, por qu\'e negarlo, alg\'un que otro susto; una vez tengamos
todo configurado, podemos utilizar el siguiente {\it script} para lanzar {\sc
snort} de forma autom\'atica al arrancar el sistema (Solaris):
\begin{quote}
\begin{verbatim}
anita:~# cat /etc/init.d/snort
#!/sbin/sh
# 
# Instalacion:
#       # cp <script> /etc/init.d/snort
#       # chmod 744 /etc/init.d/snort
#       # chown root:sys /etc/init.d/snort
#       # ln /etc/init.d/snort /etc/rc2.d/S99snort
#

# Directorio de log
DIRLOG=/var/log/snort
# Fichero de reglas
RULES=/usr/local/security/snort.conf
# Ejecutable
SNORT=/usr/local/security/snort
# Interfaz
IF=hme0

case "$1" in
'start')
        if [ ! -d "$DIRLOG" ]; then
                mkdir -p "$DIRLOG"
        fi
        if [ ! -r "$RULES" ]; then
                echo "No puedo leer el fichero de patrones..."
                exit -1
        fi
        if [ ! -x "$SNORT" ]; then
                echo "No encuentro el ejecutable..."
                exit -1
        fi
        $SNORT -l $DIRLOG -c $RULES -i $IF -N -D
        ;;
'stop')
        if [ ! -r "/var/run/snort_$IF.pid" ]; then
                echo "No puedo obtener el PID..."
                exit -1
        fi
        kill -TERM `cat /var/run/snort_$IF.pid`
        ;;
*)
        echo "Usage: $0 { start | stop }"
        exit 1
esac
exit 0
anita:~# 
\end{verbatim}
\end{quote}
Con el sensor y sus patrones correctamente configurados ya estamos listos
para poner en funcionamiento nuestro sistema de detecci\'on de intrusos.
Seguramente hasta ahora no hemos tenido muchos problemas con el IDS; no 
obstante, a partir de ahora las cosas se empiezan a complicar un poco, ya que
comienza la segunda parte, la del tratamiento de la informaci\'on que nuestro
sensor nos va a proporcionar. Y es que desde este momento el sistema de
detecci\'on va a empezar a funcionar y a generar {\it logs} con notificaciones
de posibles ataques, o cuanto menos de actividades sospechosas; es hora de
decidir cosas como d\'onde situar al sensor, qu\'e hacer ante la generaci\'on 
de un evento en el mismo, c\'omo procesar la informaci\'on recibida, o 
simplemente cu\'ando rotar los {\it logs} generados.\\
\\El \'ultimo de los problemas planteados realmente tiene f\'acil soluci\'on;
>cu\'ando rotar los {\it logs} que {\sc snort} genera? La respuesta es muy 
sencilla: depende. Depende de la cantidad de informes generados en nuestro
sensor, depende de la frecuencia con la que debamos realizar informes de los
ataque sufridos, depende de la implementaci\'on elegida para ejecutar 
respuestas autom\'aticas ante un ataque (si las ejecutamos), etc. En definitiva,
la rotaci\'on correcta de unos {\it logs} es algo que se debe estudiar y 
planificar para cada entorno concreto, no se puede dar un periodo estricto que
se aplique siempre porque ser\'{\i}a sin duda err\'oneo. No obstante, una idea
que nos puede ayudar en la toma de esta decisi\'on es la siguiente: rotaremos
los {\it logs} cuando los hayamos procesado y extra\'{\i}do de ellos la 
informaci\'on que nos pueda interesar para proteger nuestro entorno.\\
\\{\sc snort} genera {\it logs} en el directorio {\tt /var/log/snort/} si no
le indicamos lo contrario (podemos hacerlo con la opci\'on {\tt `-l'} del
programa). En ese directorio encontraremos un fichero denominado {\tt alert}
con las actividades que se vayan registrando, y, si no hubi\'eramos especificado
la opci\'on {\tt `-N'} al arrancar el programa, una serie de subdirectorios 
cuyos nombres son las direcciones IP de las m\'aquinas de las que se detecta
alguna actividad (es el denominado {\it `packet logging'}). Como nosotros lo 
que buscamos es b\'asicamente la generaci\'on de alarmas, independiente del
{\it packet logging}, no necesitamos generar estos directorios (aunque nada
nos impide hacerlo).\\
\\El siguiente {\it shellscript} planificado convenientemente con {\tt crontab}
(si lo ejecutamos m\'as de una vez durante el d\'{\i}a quiz\'as nos interese
afinar la variable {\tt \$FECHA}) puede ser utilizado para realizar la 
rotaci\'on del archivo de alarmas generado por {\sc snort}:
\begin{quote}
\begin{verbatim}
anita:~# cat /usr/local/security/rotalog
#!/bin/sh
#
# Directorio de log
DIRLOG=/var/log/snort
# Fecha (DD/MM/YY)
FECHA=`date +%d.%m.%Y`
# Interfaz
IF=hme0

if [ ! -d "$DIRLOG" ]; then
        mkdir -p "$DIRLOG"
fi
cd $DIRLOG
mv alert alert-$FECHA
touch alert
chmod 600 alert
kill -HUP `cat /var/run/snort_$IF.pid`
compress alert-$FECHA
anita:~# 
\end{verbatim}
\end{quote}
Independientemente de la rotaci\'on de {\it logs} que llevemos a cabo en
cada sensor, suele resultar interesante centralizar todos los {\it logs} 
generados en un s\'olo sistema (a veces se le denomina maestro o {\it master}),
aunque s\'olo sea para realizar estad\'{\i}sticas, seguimientos de m\'aquinas
atacantes y atacadas, o simplemente un {\it `top ten'} de piratas. Para ello
podemos establecer relaciones de confianza entre los sensores y ese maestro
para que puedan conectarse entre s\'{\i} sin necesidad de contrase\~nas y,
de forma autom\'atica, transferir los {\it logs} almacenados y rotados. Por
supuesto, a estas alturas dicha relaci\'on no la estableceremos mediante la 
definici\'on de m\'aquinas confiables en archivos {\tt .rhosts} o similares, ni
con las herramientas {\tt r-$\ast$}, sino mediante {\sc ssh} y las claves 
p\'ublicas y privadas de cada m\'aquina. Aparte de una mayor seguridad (no
autenticamos a una m\'aquina simplemente por su direcci\'on o nombre, algo
f\'acilmente falseable), siguiendo un mecanismo de este estilo conseguimos que
todas las comunicaciones entre sistemas se realicen de forma cifrada, algo que
aqu\'{\i} es muy importante: cualquier informaci\'on relativa a potenciales
ataques o respuestas autom\'aticas a los mismos se ha de considerar como 
confidencial, por lo que ser\'{\i}a un grave error echar todo nuestro trabajo
a perder simplemente porque alguien sea capaz de esnifar dicho tr\'afico.\\
\\Volviendo a nuestras cuestiones iniciales, tambi\'en deb\'{\i}amos decidir 
d\'onde situar l\'ogicamente al sensor; por ejemplo, una cuesti\'on t\'{\i}pica
es si debemos emplazarlo detr\'as o delante del {\it firewall} que protege a
nuestra red. En principio, si dejamos que el sensor analice el tr\'afico antes
de que sea filtrado en el cortafuegos, estaremos en disposici\'on de detectar
todos los ataques {\it reales} que se lanzan contra nuestra red, sin ning\'un
tipo de filtrado que pueda detener las actividades de un pirata; no obstante,
probablemente lo que m\'as nos interesar\'a no es detectar todos estos intentos
de ataque (aunque nunca est\'a de m\'as permanecer informado en este sentido),
sino detectar el tr\'afico sospechoso que atraviesa nuestro {\it firewall} y
que puede comprometer a nuestros servidores. Por tanto, es recomendable 
(\cite{kn:ids99}) emplazar el sensor de nuestro sistema de detecci\'on de 
intrusos en la zona protegida; de cualquier forma, los potenciales ataques que 
no lleguen al mismo quedar\'an registrados en los {\it logs} del cortafuegos, e
incluso ser\'an neutralizados en el mismo.\\
\\Como el sensor ha de analizar todo el tr\'afico dirigido a las m\'aquinas
protegidas, si nos encontramos en un entorno donde dichas m\'aquinas se conecten
mediante un concentrador ({\it hub}) o mediante otras arquitecturas en las que 
cualquiera de
ellas vea (o pueda ver) el tr\'afico de las dem\'as, no hay muchos problemas
de decisi\'on sobre d\'onde situar al sensor: lo haremos en cualquier parte del
segmento. Sin embargo, si nuestros sistemas se conectan con un {\it switch} la
cuesti\'on se complica un poco, ya que en las bocas de este elemento se ver\'a 
\'unicamente el tr\'afico dirigido a las m\'aquinas que est\'en conectadas a
cada una de ellas; en este caso, tenemos varias opciones. Una de ellas puede
ser modificar por completo -- con todo lo que esto implica -- nuestra 
arquitectura de red para integrar un concentrador por el que pasen los paquetes
ya filtrados antes de llegar a las m\'aquinas del {\it switch}, tal y como
se muestra en la figura \ref{switch}. No obstante, suelen existir alternativas
m\'as sencillas y c\'omodas, como la replicaci\'on de puertos que se puede 
configurar en la mayor\'{\i}a de {\it switches}; la idea es muy simple: todo
el tr\'afico dirigido a determinada boca del {\it switch} se monitoriza y se
duplica en otra boca. As\'{\i}, no tenemos m\'as que configurar este {\it
port mirroring} y replicar la boca por la que se dirige el tr\'afico hacia el
segmento de m\'aquinas a monitorizar, envi\'andolo tambi\'en a una segunda boca
en la que conectaremos nuestro sensor.\\
\begin{figure}
\vspace{0.5cm}
\setlength{\unitlength}{3947sp}%
%
\begingroup\makeatletter\ifx\SetFigFont\undefined%
\gdef\SetFigFont#1#2#3#4#5{%
  \reset@font\fontsize{#1}{#2pt}%
  \fontfamily{#3}\fontseries{#4}\fontshape{#5}%
  \selectfont}%
\fi\endgroup%
\begin{picture}(7619,4019)(729,-3308)
\thinlines
\put(3001,239){\line(-3,-2){900}}
\put(2101,-361){\line( 3,-2){900}}
\put(3001,-961){\line( 3, 2){900}}
\put(3901,-361){\line(-3, 2){900}}
\put(2476,-1411){\framebox(75,75){}}
\put(2701,-1411){\framebox(75,75){}}
\put(2926,-1411){\framebox(75,75){}}
\put(3151,-1411){\framebox(75,75){}}
\put(3376,-1411){\framebox(75,75){}}
\put(2701,-1561){\vector( 0,-1){300}}
\put(2926,-1561){\vector( 0,-1){300}}
\put(3151,-1561){\vector( 0,-1){300}}
\put(3376,-1561){\vector( 0,-1){300}}
\put(5851,239){\line(-3,-2){900}}
\put(4951,-361){\line( 3,-2){900}}
\put(5851,-961){\line( 3, 2){900}}
\put(6751,-361){\line(-3, 2){900}}
\put(5251,-1561){\framebox(1200,300){}}
\put(5251,-2536){\framebox(1200,300){}}
\put(5401,-2536){\vector( 0,-1){300}}
\put(5551,-2536){\vector( 0,-1){300}}
\put(5701,-2536){\vector( 0,-1){300}}
\put(5851,-2536){\vector( 0,-1){300}}
\put(6001,-2536){\vector( 0,-1){300}}
\put(6151,-2536){\vector( 0,-1){300}}
\put(6301,-2536){\vector( 0,-1){300}}
\put(5326,-1411){\framebox(75,75){}}
\put(5476,-1411){\framebox(75,75){}}
\put(5626,-1411){\framebox(75,75){}}
\put(5776,-1411){\framebox(75,75){}}
\put(5926,-1411){\framebox(75,75){}}
\put(6076,-1411){\framebox(75,75){}}
\put(6226,-1411){\framebox(75,75){}}
\put(5326,-2386){\framebox(75,75){}}
\put(5476,-2386){\framebox(75,75){}}
\put(5626,-2386){\framebox(75,75){}}
\put(5626,-2386){\framebox(75,75){}}
\put(5776,-2386){\framebox(75,75){}}
\put(5926,-2386){\framebox(75,75){}}
\put(6076,-2386){\framebox(75,75){}}
\put(6226,-2386){\framebox(75,75){}}
\put(5851,-1561){\vector( 0,-1){675}}
\put(6226,-1561){\line( 0,-1){300}}
\put(6226,-1861){\vector( 1, 0){750}}
\put(6976,-2161){\framebox(675,600){}}
\put(7051,-2086){\framebox(525,450){}}
\put(2476,-1561){\vector( 0,-1){300}}
\put(3526,-1561){\vector( 0,-1){300}}
\put(2401,-1561){\framebox(1200,300){}}
\put(3001,-961){\vector( 0,-1){300}}
\put(5851,-961){\vector( 0,-1){300}}
\put(3001,539){\vector( 0,-1){300}}
\put(5851,539){\vector( 0,-1){300}}
\thicklines
\put(4126,-211){\vector( 1, 0){600}}
\put(4126,-361){\vector( 1, 0){600}}
\put(4126,-511){\vector( 1, 0){600}}
\put(751,-3286){\framebox(7575,3975){}}
\put(7276,-2536){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}SENSOR}}}
\put(4351,-2461){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}SWITCH}}}
\put(4651,-1486){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}HUB}}}
\put(1426,-1486){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}SWITCH}}}
\put(5626,-436){\makebox(0,0)[lb]{\smash{\SetFigFont{14}{16.8}{\rmdefault}{\mddefault}{\updefault}FW}}}
\put(2851,-436){\makebox(0,0)[lb]{\smash{\SetFigFont{14}{16.8}{\rmdefault}{\mddefault}{\updefault}FW}}}
\end{picture}
\caption{Situaci\'on del sensor}
\label{switch}
\end{figure}
\\Para acabar con los comentarios sobre d\'onde y c\'omo situar al sensor de
nuestro sistema detector de intrusos, un \'ultimo apunte: quiz\'as nos conviene
recordar que el interfaz por el que se analiza el tr\'afico (hablando claro, 
por el que se esnifan las tramas) no tiene por qu\'e tener direcci\'on IP.
Perfectamente podemos tener un interfaz levantado e inicializado pero sin 
asignarle ninguna direcci\'on. Esto nos puede resultar \'util si no nos interesa
que en el segmento protegido se detecte una nueva m\'aquina, o simplemente si 
no queremos que nuestro sensor sea alcanzable de alguna forma por el resto 
de sistemas de su dominio de colisi\'on. Para nuestra comodidad (por ejemplo,
a la hora de centralizar {\it logs} de diferentes sensores) podemos usar una 
m\'aquina con dos interfaces, una escuchando todo el tr\'afico y la otra 
configurada de forma normal, que ser\'a por la que accedamos al sistema.
\subsection{IDS en la m\'aquina}
Tras leer la secci\'on anterior seguramente habr\'a quedado claro que un 
correcto esquema de detecci\'on de intrusos basado en red es vital para 
proteger cualquier sistema; con frecuencia suele ser el punto m\'as importante,
que m\'as ataques detecta, y donde se suelen emplazar la mayor\'{\i}a de 
sistemas de detecci\'on que existen instalados en entornos reales hoy en 
d\'{\i}a. No obstante, esta enorme importancia suele degenerar en un error
bastante grave: en muchos entornos los responsables de seguridad, a la hora de
trabajar con IDSes, se limitan a instalar diversos sensores de detecci\'on 
basados en red en cada segmento a proteger, creyendo que as\'{\i} son capaces 
de detectar la mayor\'{\i}a de ataques. Y eso suele generar una falsa 
sensaci\'on de seguridad grave, ya que a la hora de lanzar ciertos ataques un
pirata puede eludir f\'acilmente a estos sensores; los sensores de detecci\'on 
en nuestros segmentos de red son importantes, pero no son la panacea. Para 
comprobarlo, volvamos a nuestro ejemplo anterior, en el que un atacante trata 
de descubrir vulnerabilidades en nuestros servidores {\sc http}: si 
recordamos d\'onde nos hab\'{\i}amos quedado, el pirata estaba lanzando un
escaneador de vulnerabilidades {\it web} contra el puerto 80 de nuestro servidor
corporativo; el esquema de detecci\'on implantado en el cortafuegos no 
percibir\'a nada extra\~no, pero el sensor ubicado en el segmento donde se
encuentra el servidor sin duda ver\'a patrones que denotan un ataque. Por 
ejemplo, en el momento en que el esc\'aner compruebe la existencia en el 
servidor de un CGI denominado {\tt phf}, {\sc snort} generar\'a una alerta
similar a esta:
\begin{quote}
\begin{verbatim}
[**] IDS128 - CVE-1999-0067 - CGI phf attempt [**]
03/10-03:29:59.834996 192.168.0.3:1032 -> 192.168.0.1:80
TCP TTL:56 TOS:0x0 ID:5040 IpLen:20 DgmLen:58 DF
***AP*** Seq: 0x91FA846  Ack: 0x5AD9A72  Win: 0x7D78  TcpLen: 20
\end{verbatim}
\end{quote}
Como veremos en el punto siguiente, es posible que al generar este aviso, el
propio sensor decida lanzar una respuesta autom\'atica contra la direcci\'on
atacante (por ejemplo, bloquearla en el cortafuegos corporativo). Pero {\sc
snort} trabaja bas\'andose en su base de datos de patrones de ataques; en dicha
base de datos habr\'a una regla como la siguiente:
\begin{quote}
\begin{verbatim}
alert tcp $EXTERNAL_NET any -> $HTTP_SERVERS 80 (msg:"WEB-CGI phf access";\
flags: A+; content:"/phf";flags: A+; nocase; reference:arachnids,128; \
reference:cve,CVE-1999-0067; )
\end{verbatim}
\end{quote}
A grandes rasgos, esta regla viene a decir que cuando el sensor detecte una 
petici\'on al puerto 80 de nuestro servidor {\it web} en cuyo contenido se 
encuentre la cadena {\tt `/phf'} levante la alerta correspondiente; de esta 
forma, cuando el atacante solicite el archivo {\tt /cgi-bin/phf} del servidor,
{\sc snort} `ver\'a' dicha cadena en la petici\'on y generar\'a una alarma. 
>Pero qu\'e sucede si el atacante solicita ese mismo fichero pero utilizando 
una petici\'on `ofuscada', formada por los c\'odigos ASCII de cada car\'acter?
Es decir, si en lugar de lanzar una petici\'on como {\tt `GET /cgi-bin/phf'} 
hace una similar a {\tt `GET \%2f\%63\%67\%69\%2d\%62\%69\%6e\%2f\%70\%68\%66'}.
La respuesta es sencilla: la petici\'on anterior se `decodifica' en el propio
servidor {\it web}, o como mucho en un {\it proxy} intermedio. Algunos 
detectores de intrusos, como RealSecure, son
en teor\'{\i}a capaces de procesar este tipo de tr\'afico y analizarlo 
normalmente en busca de patrones sospechosos, pero otros muchos ({\sc snort} en 
este caso) no; as\'{\i}, estos \'ultimos no ver\'an en ning\'un 
momento la cadena {\tt `/phf'} circulando por la red, y por tanto no 
generar\'an ninguna alarma. Parece entonces evidente que es
necesario un nivel adicional en nuestro esquema de detecci\'on: justamente el
compuesto por los sistemas basados en la propia m\'aquina a proteger.\\
\\Antes hemos hablado de los tres modelos b\'asicos de IDSes basados en 
m\'aquina: verificadores de integridad, analizadores de registros y {\it
honeypots}. Parece claro que un verificador de integridad en nuestro caso no va
a resultar muy \'util para detectar a ese atacante (esto no significa que no
se trate de modelos necesarios y \'utiles en otras muchas situaciones). 
Tendremos por tanto que recurrir a analizadores de {\it logs} o a tarros de 
miel instalados en la m\'aquina. Si optamos por los primeros, es sencillo
construir un {\it shellscript} que procese los archivos generados por el
servidor {\it web} -- en nuestro caso, aunque igualmente sencillo que procesar 
registros del sistema o de otras aplicaciones -- en busca de patrones que puedan
denotar un ataque, como el acceso a determinados archivos bajo el {\tt 
DocumentRoot}. Si analizamos cualquier {\it CGI Scanner} nos podremos hacer
una idea de a qu\'e patrones debemos estar atentos: por ejemplo, intentos de 
acceso a CGIs como {\tt phf} o {\tt printenv}, a archivos {\tt passwd}, a 
ficheros fuera del {\tt DocumentRoot}, etc.\\
\\Aunque analizar los registros generados por una aplicaci\'on en busca de 
ciertos patrones sospechosos es una tarea trivial, no lo es tanto el integrar
ese an\'alisis en un esquema de detecci\'on de intrusos. Seguramente procesar
la salida de un {\tt `tail -f'} del archivo de {\it log} correspondiente, 
enviando un correo electr\'onico al responsable de seguridad cuando se detecte
una entrada sospechosa es f\'acil, pero por poner un simple ejemplo, >qu\'e 
sucede cuando la m\'aquina se reinicia o el fichero de registros se rota? >Es 
necesario volver a entrar y lanzar de nuevo la orden correspondiente para 
analizar los {\it logs}? Seguramente alguien plantear\'a que se puede 
planificar una tarea para que peri\'odicamente compruebe que se est\'a 
procesando el archivo, y lance el an\'alisis en caso de que no sea 
as\'{\i}\ldots >pero hasta qu\'e punto es esto c\'omodo? >qu\'e sucede con las
entradas duplicadas? >y con los registros perdidos que no se llegan a procesar?
Evidentemente, no todo es tan sencillo como el simple {\tt `tail -f'} 
anterior.\\
\\El an\'alisis de registros generados por el sistema o por ciertas aplicaciones
suele ser una excelente fuente de informaci\'on de cara a la detecci\'on de
actividades sospechosas en nuestros entornos, pero no es habitual aplicar dicho
an\'alisis en un esquema de respuesta autom\'atica ante ataques. Es mucho m\'as
com\'un automatizar la revisi\'on de {\it logs} para que peri\'odicamente (por
ejemplo, cada noche) se analicen esos registros y se env\'{\i}e un mensaje de
alerta por correo electr\'onico a los responsables de seguridad en caso de que
algo anormal se detecte; evidentemente no es un modelo que trabaje en tiempo
real, pero no por ello deja de ser un esquema \'util en la detecci\'on de
intrusos; el \'unico problema que se presenta a la hora de realizar el
an\'alisis suele ser la decisi\'on de qu\'e patrones buscar en los registros,
algo que depende por completo del tipo de {\it log} que estemos analizando.\\
\\Aparte de los sistemas de detecci\'on basados en el an\'alisis de registros, 
otro esquema que podemos -- y debemos -- implantar en cada m\'aquina son los
{\it honeypots} o tarros de miel, mecanismo que nos ha de permitir detectar
ciertos ataques aunque el resto de sensores de nuestro modelo falle. Como antes
hemos comentado, hay diferentes modelos de tarros de miel, desde los simples
detectores de pruebas hasta los complejos sistemas dedicados por completo a esta
tarea; para detectar ataques rutinarios estos \'ultimos suelen ser algo 
excesivo e incluso en ocasiones dif\'{\i}cil no s\'olo desde un punto de vista
estrictamente t\'ecnico, ya que no siempre podemos dedicar
una m\'aquina entera a `enga\~nar' atacantes, aparte del tiempo necesario para
configurarla correctamente, actualizarla, revisar sus registros, etc. Esquemas
te\'oricamente m\'as simples pueden incluso resultar m\'as efectivos en la
pr\'actica.\\
\\En nuestro caso no vamos a complicarnos mucho la existencia; si recordamos
a nuestro atacante, estaba lanzando un escaneo de vulnerabilidades contra 
nuestro servidor {\it web}; nuestro IDS basado en red detectar\'a el ataque y
en consecuencia dar\'a la voz de alarma y, adicionalmente, ejecutar\'a una
respuesta autom\'atica contra el pirata, bloque\'andolo en el cortafuegos 
corporativo. Ese atacante ya puede m\'as que sospechar que tenemos un detector
de intrusos basado en red que le impide completar su escaneo, ya que en el 
momento que se detecta tr\'afico sospechoso bloquea por completo a la 
direcci\'on origen; por tanto, un paso l\'ogico para \'el es intentar un 
an\'alisis de vulnerabilidades `camuflado', bien mediante una simple 
codificaci\'on de peticiones bien mediante un complejo {\it stealth scan}. De
nuevo, buscar\'a la existencia de CGIs vulnerables, como {\tt /cgi-bin/phf} o 
{\tt /cgi-bin/printenv}, y en este caso {\sc snort} ser\'a incapaz de detectar
el ataque. Pero forzosamente a nuestro servidor {\it web} han de llegar estas
peticiones, por lo que >qu\'e mejor forma de detectar al pirata que en la 
propia m\'aquina? No tenemos m\'as que situar en el directorio donde se ubican
nuestros CGIs un programa que nos informe si alguien intenta acceder a \'el, 
tan simple como el siguiente {\it shellscript}:
\begin{quote}
\begin{verbatim}
anita:~# cat /web/cgi-bin/phf
#!/bin/sh
/bin/echo "Pirata desde "$REMOTE_ADDR""|mailx -s "Ataque PHF" root 
/bin/echo "Content-type: text/html"
/bin/echo ""
/bin/echo "<HTML><CENTER>Sonrie a la camara oculta...</CENTER></HTML>"
anita:~# 
\end{verbatim}
\end{quote}
Evidentemente la `decepci\'on' del sistema anterior en un atacante durar\'a
unos pocos segundos, ya que es inmediato para \'este detectar que se trata de
una simple trampa; si queremos algo m\'as elaborado, tampoco es dif\'{\i}cil 
conseguirlo: podemos simular el comportamiento de diferentes CGIs con 
vulnerabilidades conocidas de una forma muy sencilla. Por ejemplo, existen 
diferentes `imitaciones' de CGIs vulnerables que aparentan un problema de 
seguridad pero que en realidad se trata de sistemas de decepci\'on m\'as o 
menos eficaces; en {\tt
http://www.eng.auburn.edu/users/rayh/software/phf.html} podemos encontrar una
versi\'on muy interesante del CGI {\tt phf}, capaz de simular los ataques m\'as 
habituales contra el programa original de
una forma bastante cre\'{\i}ble -- aunque no perfecta --. Adem\'as en este
caso el c\'odigo en {\it Perl} es f\'acilmente modificable, con lo que podemos 
desde adecuarlo a nuestros sistemas hasta mejorar su simulaci\'on; si lo
hacemos, es muy posible que mantengamos `entretenidos' incluso a piratas con
conocimientos por encima de la media de atacantes (esto lo digo por 
experiencia). Tambi\'en podemos construirnos nuestros propios CGIs que 
aparenten ser vulnerables, en muchos casos simplemente con unos conocimientos 
b\'asicos de programaci\'on en {\it shell} o en {\it Perl}; por ejemplo, el
c\'odigo siguiente simula el CGI {\tt printenv}, proporcionando informaci\'on 
falsa sobre el sistema que parece \'util para un atacante, y avisando por correo
electr\'onico a los responsables de seguridad del sistema cuando alguien 
accede al programa:
\begin{quote}
\begin{verbatim}
anita:/# cat /web/cgi-bin/printenv
#!/usr/bin/perl

$SECUREADDRESS="root";
$mailprog = '/usr/lib/sendmail';

print "Content-type: text/html\n\n";
print "SERVER_SOFTWARE = Apache/1.3.12<br>";
print "GATEWAY_INTERFACE = CGI/1.2<br>";
print "DOCUMENT_ROOT = /usr/local/httpd/htdocs<br>";
print "REMOTE_ADDR = $ENV{'REMOTE_ADDR'}<br>";
print "SERVER_PROTOCOL = $ENV{'SERVER_PROTOCOL'}<br>";
print "SERVER_SIGNATURE = <br><i>Apache/1.3.9 Server at \
       $ENV{'SERVER_NAME'}</i><br><br>";
print "REQUEST_METHOD = GET<br>";
print "QUERY_STRING = $ENV{'QUERY_STRING'}<br>";
print "HTTP_USER_AGENT = $ENV{'HTTP_USER_AGENT'}<br>";
print "PATH = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:\
       /usr/local/bin<br>";
print "HTTP_ACCEPT = image/gif, image/x-xbitmap, image/jpeg<br>";
print "HTTP_CONNECTION = Keep-Alive<br>";
print "REMOTE_PORT = $ENV{'REMOTE_PORT'}<br>";
print "SERVER_ADDR = $ENV{'SERVER_ADDR'}<br>";
print "HTTP_ACCEPT_LANGUAGE = en<br>";
print "SCRIPT_NAME = /cgi-bin/printenv<br>";
print "HTTP_ACCEPT_ENCODING = gzip<br>";
print "SCRIPT_FILENAME = /usr/local/httpd/cgi-bin/printenv<br>";
print "SERVER_NAME = $ENV{'SERVER_NAME'}<br>";
print "REQUEST_URI = /cgi-bin/printenv<br>";
print "HTTP_ACCEPT_CHARSET = iso-8859-1, utf-8<br>";
print "SERVER_PORT = $ENV{'SERVER_PORT'}<br>";
print "HTTP_HOST = $ENV{'HTTP_HOST'}<br>";
print "SERVER_ADMIN = webmaster<br>";

# Enviamos correo
open (MAIL, "|$mailprog $SECUREADDRESS") or die "Can't open $mailprog!\n";
print MAIL "To: $SECUREADDRESS\n";
print MAIL "From: PRINTENV Watcher <$SECUREADDRESS>\n";
print MAIL "Subject: [/CGI-BIN/PRINTENV] $ENV{'REMOTE_HOST'} $action\n\n";
print MAIL "\n";
print MAIL  "--------------------------------------------------------\n";
print MAIL "Remote host: $ENV{'REMOTE_ADDR'}\n";
print MAIL "Server: $ENV{'SERVER_NAME'}\n";
print MAIL "Remote IP address: $ENV{'REMOTE_ADDR'}\n";
print MAIL "HTTP Referer: $ENV{'HTTP_REFERER'}\n";
print MAIL "Query String: $ENV{'QUERY_STRING'}\n";
print MAIL "\n--------------------------------------------------------\n";
close(MAIL);
exit;
anita:/#
\end{verbatim}
\end{quote}
\subsection{Estrategias de respuesta}
Una pregunta importante que nos hab\'{\i}amos realizado con respecto a nuestro 
esquema de deteccci\'on de intrusos (en concreto cuando habl\'abamos de {\sc 
snort}) era qu\'e hacer con la informaci\'on obtenida del mismo; como 
siempre, tenemos varias posibilidades. Por un lado, podemos procesarla 
manualmente de forma peri\'odica (por ejemplo cada ma\~nana) y en funci\'on de 
los datos que nuestros sensores hayan recogido tomar una determinada acci\'on:
bloquear las direcciones atacantes en el {\it firewall} corporativo, enviar un
correo de queja a los responsables de dichas direcciones (por desgracia esto no 
suele resultar muy \'util), realizar informes para nuestros superiores, o 
simplemente no hacer nada. Depender\'a casi por completo de la pol\'{\i}tica de 
seguridad que sigamos o que tengamos que seguir.\\
\\Mucho m\'as interesante que cualquiera de estas respuestas manuales es que el 
propio 
sensor sea capaz de generar respuestas autom\'aticas ante lo que \'el considere
un intento de ataque. Si elegimos esta opci\'on, lo m\'as habitual suele ser
un bloqueo total de la direcci\'on atacante en nuestro cortafuegos, unida a una
notificaci\'on de cualquier tipo (SMS, {\it e-mail}\ldots) a los responsables
de seguridad; es siempre recomendable efectuar esta notificaci\'on (si no en
tiempo real, si al menos registrando las medidas tomadas contra una determinada
direcci\'on en un {\it log}) por motivos evidentes: si bloqueamos completamente 
el acceso de alguien hacia nuestros sistemas, debemos pararnos a pensar que
es posible que se trate de un usuario autorizado que en ning\'un momento 
atacaba nuestras m\'aquinas, a pesar de que el sensor que hemos instalado opine
lo contrario. No importa lo seguros que estemos de lo que hacemos ni de las
veces que hayamos revisado nuestra base de datos de patrones: nunca podemos
garantizar por completo que lo que nuestro IDS detecta como un ataque realmente
lo sea.\\
\\Un correcto esquema de respuesta autom\'atica (asumimos que vamos a bloquear
la direcci\'on que presuntamente nos ataca) deber\'{\i}a contemplar al menos
los siguientes puntos:
\begin{itemize}
\item >Qu\'e probabilidad hay de que el ataque detectado sea realmente un falso
positivo?\\
No todos los ataques que un sensor detecta tienen la misma probabilidad de
serlo realmente: por ejemplo, alguien que busca en nuestros servidores {\it 
web} un {\sc cgi} denominado {\tt phf} (un programa que se encuentra en 
versiones antiguas -- muy antiguas -- de Apache, y que presenta graves 
problemas de seguridad) casi con toda probabilidad trata de atacar nuestros
sistemas; en cambio, una alarma generada porque el sensor detecta un paquete
ICMP de formato sospechoso no tiene por qu\'e representar (y seguramente no lo
har\'a) un verdadero ataque. Es necesario, o cuanto menos recomendable, asignar
un peso espec\'{\i}fico a cada alarma generada en el sensor, y actuar s\'olo
en el caso de que detectemos un ataque claro: o bien un evento que denote muy 
claramente un intento de intrusi\'on, o bien varios menos sospechosos, pero
cuya cantidad nos indique que no se trata de falsos positivos.
\item >Debemos contemplar direcciones `protegidas'?\\
Otro punto a tener en cuenta antes de lanzar una respuesta autom\'atica contra
un potencial atacante es su origen; si se trata de una direcci\'on externa, 
seguramente la respuesta ser\'a adecuada, pero si se trata de una interna a
nuestra red (o equivalentemente, de direcciones de empresas colaboradoras, 
aunque sean externas) la cosa no est\'a tan clara. Debemos plantearnos que
quiz\'as estamos bloqueando el acceso a alguien a quien, por los motivos que
sea, no deber\'{\i}amos hab\'erselo bloqueado. Aunque se trate de cuestiones
mas pol\'{\i}ticas que t\'ecnicas, es muy probable que en nuestro IDS debamos 
tener claro un conjunto de direcciones contra las que no se va actuar; si desde
ellas se detecta actividad sospechosa, podemos preparar un mecanismo que alerte
a los responsables de seguridad y, bajo la supervisi\'on de un humano, tomar 
las acciones que consideremos oportunas.
\item >Hay un l\'{\i}mite al n\'umero de respuestas por unidad de tiempo?\\
Seguramente la respuesta inmediata a esta pregunta ser\'{\i}a `no'; a fin de
cuentas, si me atacan diez direcciones diferentes en menos de un minuto, >qu\'e
hay de malo en actuar contra todas, bloque\'andolas? En principio esta 
ser\'{\i}a la forma correcta de actuar, pero debemos pararnos a pensar en lo que
es normal y lo que no lo es en nuestro entorno de trabajo. >Es realmente 
habitual que suframos ataques masivos y simult\'aneos desde diferentes 
direcciones de Internet? Dependiendo de nuestro entorno, se puede considerar
una casualidad que dos o tres m\'aquinas diferentes decidan atacarnos al mismo
tiempo; pero sin duda m\'as de este n\'umero resulta cuanto menos sospechoso. Un
pirata puede simular ataques desde diferentes {\it hosts} de una forma m\'as o
menos sencilla y si nos limitamos a bloquear direcciones (o redes completas), 
es f\'acil que nosotros mismos causemos una importante negaci\'on de servicio
contra potenciales usuarios leg\'{\i}timos (por ejemplo, simples visitantes de
nuestras p\'aginas {\it web} o usuarios de correo), lo cual puede representar 
un ataque a nuestra seguridad m\'as importante que el que causar\'{\i}a ese
mismo pirata si simplemente le permiti\'eramos escanear nuestras m\'aquinas. Si
nuestro sensor lanza demasiadas respuestas autom\'aticas en un periodo de tiempo
peque\~no, el propio sistema debe encargarse de avisar a una persona que se 
ocupe de verificar que todo es normal.
\end{itemize}
Teniendo en cuenta los puntos anteriores (y seguramente otros), debemos 
dise\~nar un esquema de respuestas autom\'aticas adecuado. Un pseudoalgoritmo 
del funcionamiento de nuestro esquema podr\'{\i}a ser el siguiente:
\begin{quote}
\begin{tabbing}
\=xxxxxxxx\=xxxxxxxx\=xxxxxxxx\=xxxxxxxx\=xxxxxxxx\kill
\>\>\>\>ESTADO: \{Detecci\a'on ataque\}\\
\>SI umbral de respuestas superado: FIN\\
\>SI NO\\
\>\>Comprobaci\a'on IP atacante\\
\>\>SI es IP protegida: FIN\\
\>\>SI NO\\
\>\>\>Ponderaci\a'on hist\a'orica de gravedad\\
\>\>\>SI umbral de gravedad superado: {\bf ACTUAR}\\
\>\>\>SI NO\\
\>\>\>\>{\bf REGISTRAR}\\
\>\>\>FSI\\
\>\>FSI\\
\>FSI\\
\end{tabbing}
\end{quote}
Como vemos, al detectar un ataque desde determinada direcci\'on, el modelo
comprueba que no se ha superado el n\'umero de respuestas m\'aximo por unidad
de tiempo (por ejemplo, que no se ha bloqueado ya un n\'umero determinado de
direcciones en las \'ultimas 24 horas); si este umbral ha sido sobrepasado no
actuaremos de ninguna forma autom\'atica, principalmente para no causar 
importantes negaciones de servicio, pero si no lo ha sido,
se verifica que la direcci\'on IP contra la que previsiblemente se actuar\'a no
corresponde a una de nuestras 'protegidas', por ejemplo a una m\'aquina de la
red corporativa: si es as\'{\i} se finaliza. Este `finalizar' no implica ni
mucho menos que el ataque no haya sido detectado y se haya guardado un {\it log}
del mismo, simplemente que para evitar problemas mayores no actuamos en tiempo
real contra la m\'aquina: si corresponde al grupo de `protegidas' es porque
tenemos cierta confianza -- o cierto control -- sobre la misma, por lo que un
operador puede preocuparse m\'as tarde de investigar la alerta. Si se trata de
una direcci\'on no controlada ponderamos la gravedad del ataque: un ataque con
poca posibilidad de ser un falso po\-si\-ti\-vo tendr\'a un peso elevado, 
mientras que uno que pueda ser una falsa alarma tendr\'a un peso bajo; a\'un 
as\'{\i}, {\bf diferentes} ataques de poco peso pueden llegar a sobrepasar 
nuestro 
l\'{\i}mite si se repiten en un intervalo de tiempo peque\~no. Es importante 
recalcar el `diferentes', ya que si la alarma que se genera es todo el rato la
misma debemos plantearnos algo: >es posible que un proceso que se ejecuta 
peri\'odicamente y que no se trata de un ataque est\'e todo el rato levantando
una falsa misma alarma? La respuesta es {\bf s\'{\i}}, y evidentemente no 
debemos bloquearlo sin m\'as; seguramente es m\'as recomendable revisar nuestra 
base de datos de patrones de ataques para ver por qu\'e se puede estar 
generando cont\'{\i}nuamente dicha alarma.\\
\\Por \'ultimo, si nuestro umbral no se ha superado debemos registrar el ataque,
su peso y la hora en que se produjo para poder hacer ponderaciones hist\'oricas
ante m\'as alarmas generadas desde la misma direcci\'on, y si se ha superado
el esquema debe efectuar la respuesta autom\'atica: bloquear al atacante en
el cortafuegos, enviar un correo electr\'onico al responsable de seguridad, etc.
Debemos pensar que para llegar a este \'ultimo punto, tenemos que estar bastante
seguros de que realmente hemos detectado a un pirata: no podemos permitirnos
el efectuar respuestas autom\'aticas ante cualquier patr\'on que nos parezca
sospechoso sin saber realmente -- o con una probabilidad alta -- que se trata
de algo hostil a nuestros sistemas.\\
\\Antes de finalizar este punto, es necesario que volver a
insistir una vez m\'as en algo que ya hemos comentado: es {\bf muy recomendable}
que ante cada respuesta se genere un aviso que pueda ser validado por un
administrador de sistemas o por responsables de seguridad, mejor si es en
tiempo real; por muy seguros que estemos del correcto funcionamiento de nuestro
detector de intrusos, nadie nos garantiza que no nos podamos encontrar ante 
comportamientos inesperados o indebidos, y con toda certeza es m\'as f\'acil 
para una persona que para una m\'aquina darse cuenta de un error y subsanarlo.
\subsection{Ampliaci\'on del esquema}
Las ideas que acabamos de comentar pueden resultar m\'as o menos interesantes,
pero presentan varios problemas importantes que es necesario comentar. El 
primero y m\'as importante es la descentralizaci\'on del esquema: tenemos 
implantadas varias aproximaciones a la detecci\'on de intrusos, pero hasta ahora
no hemos hablado de la relaci\'on entre ellas; cada uno de los modelos de
detecci\'on y/o respuesta de los que hemos tratado puede actuar de forma
independiente sin muchos problemas, pero en los entornos actuales esto es cada
vez menos habitual. Hoy en d\'{\i}a, lo normal es encontrarse arquitecturas de
red segmentadas, con sensores en cada segmento tanto a nivel de red como de
{\it host}, as\'{\i} como uno o varios cortafuegos corporativos en los que 
tambi\'en se lleva a cabo detecci\'on de intrusos y respuesta autom\'atica. 
Est\'a claro que tener elementos independientes no es la aproximaci\'on m\'as
adecuada, por lo que necesitamos un esquema capaz de unificar los ataques 
detectados, por ejemplo para correlar eventos y lanzar \'unicamente una 
respuesta autom\'atica ante un mismo ataque, aunque se detecte simult\'aneamente
en diferentes sensores; sin ser tan ambiciosos, la centralizaci\'on en una
\'unica consola puede ser necesaria para algo tan simple como generar 
estad\'{\i}sticas mensuales acerca del n\'umero de ataques contra nuestro 
entorno de trabajo: si un mismo ataque se detecta en varios sensores, >c\'omo
contabilizarlo? >c\'omo saber si se trata del mismo intruso o de varios? 
>qui\'en de todos decide lanzar una respuesta autom\'atica?\ldots\\ 
\\Para tratar de solucionar este importante problema, hace unos a\~nos se 
defini\'o el grupo de trabajo {\sc idwg} ({\it Intrusion Detection Exchange
Format Working Group}), englobado dentro del {\sc ietf} ({\it Internet 
Engineering Task Force}); su prop\'osito es obvio: tratar de definir 
est\'andares para el intercambio de informaci\'on entre los diferentes 
elementos de un sistema de detecci\'on de intrusos y respuesta autom\'atica,
tanto a nivel de formato de datos como de procedimientos de intercambio. 
Mediante esta aproximaci\'on se facilita enormemente tanto la integraci\'on de 
sistemas, ya que de lo \'unico que nos debemos preocupar es que todos los 
elementos (sensores, consolas, elementos de respuesta\ldots) sean capaces de 
`hablar' el est\'andar, como la escalabilidad: a\~nadir a un entorno de 
detecci\'on distribuido un nuevo IDS, comercial o desarrollo propio, es mucho
m\'as sencillo, ya que casi s\'olo hemos de conseguir que el nuevo elemento 
utilice los formatos est\'andar definidos por el {\sc idwg}.\\
\\Hasta la fecha, el grupo de trabajo ha publicado cuatro borradores que cubren
los requisitos (de alto nivel) para las comunicaciones dentro del sistema de
detecci\'on de intrusos, el modelo de datos para representar la informaci\'on
relevante para los IDSes -- incluyendo una implementaci\'on en XML --, el 
protocolo {\sc beep} ({\it Blocks Extensible Exchange Protocol}) aplicado a la
detecci\'on de intrusos, y finalmente el protocolo {\sc idxp} ({\it Intrusion
Detection eXchange Protocol}) para intercambio de informaci\'on entre entidades
de un sistema distribuido de detecci\'on de intrusos. Sin duda el primero y
el \'ultimo son especialmente importantes, ya que constituyen la base del
sistema de intercambio de datos entre los diferentes elementos del entorno: 
marcan el `lenguaje' que antes dec\'{\i}amos que ten\'{\i}an que saber hablar
todas y cada una de las entidades del sistema distribuido.\\
\\Desde {\tt http://www.ietf.org/html.charters/idwg-charter.html} pueden 
consultarse los trabajos del {\sc idwg}; se trata de un grupo activo, que 
realiza cont\'{\i}nuamente revisiones y mejoras de sus borradores para tratar 
de convertirlos en un est\'andar real. Si alg\'un d\'{\i}a esto es as\'{\i},
habremos dado un paso muy importante en el dise\~no, implantaci\'on y gesti\'on
de sistemas distribuidos de detecci\'on de intrusos; lamentablemente, muchos
de los productos actuales no parecen tener mucho inter\'es en acercarse al
est\'andar (quiz\'as por miedo a perder cota de mercado). La integraci\'on de
algunos sistemas (como {\sc snort}) es bastante inmediata, pero en cambio la
de otros -- especialmente productos comerciales, altamente cerrados -- no lo
es tanto; mientras esto no cambie, es dif\'{\i}cil que se consiga implantar el
est\'andar, as\'{\i} que \'ojala estos fabricantes se den cuenta de que su 
adaptaci\'on a los borradores del {\sc idwg} produce sin duda m\'as beneficios
que da\~nos.
\section{Algunas reflexiones}
\begin{center}
{\it NOTA: Este punto es completamente subjetivo, se trata s\'olo de opiniones 
personales, tan v\'alidas o tan err\'oneas como cualquier otra opini\'on 
personal, e igual de respetables.}
\end{center}
Por desgracia, los piratas inform\'aticos, los intrusos, est\'an cada d\'{\i}a 
m\'as de moda;
sin duda alguna los problemas de seguridad que m\'as `gustan' a la sociedad 
son los relacionados con {\it hackers}, {\it crackers} o como esta semana los 
medios hayan decidido llamar a los piratas inform\'aticos: evidentemente, es
mucho m\'as interesante y sensacionalista cualquier atacante que modifique la 
p\'agina {\it web} del Pent\'agono que las investigaciones o los 
descubrimientos de gente como Marcus Ranum, Gene Spafford o Ross Anderson, por 
poner s\'olo unos ejemplos. Es as\'{\i} de
triste: al contrario de lo que grandes expertos en seguridad han manifestado en 
repetidas ocasiones (\cite{kn:spa90}, \cite{kn:sto88}, \cite{kn:ran00}, 
\cite{kn:kru00}\ldots) 
mucha gente considera a los intrusos como h\'eroes, como j\'ovenes inteligentes 
que utilizan sus ordenadores para poner en jaque a grandes organizaciones -- 
pol\'{\i}ticas, empresariales, militares\ldots -- con un simple teclado, sin 
disparar ni un solo tiro, sin quemar autobuses o sin lanzar piedras 
desde una barricada; seguramente nadie se ha parado a pensar que ese pirata al
que hoy admira ma\~nana puede entrar en el PC de su casa y formatearle el disco 
duro simplemente porque le apetec\'{\i}a.\\ 
\\Aparte de esta presunta `demostraci\'on de inteligencia', otro argumento muy 
utilizado por los
defensores de los {\it crackers} es el derecho a la libertad de informaci\'on
de toda persona: ven a los piratas como un peque\~no David que triunfa sobre
el gran Goliat y descubre todos sus secretos simplemente con un peque\~no 
ordenador
casero; parad\'ojicamente, son estas personas las que luego ponen el grito en
el cielo y reivindican ciegamente su derecho a la privacidad cuando se enteran
de la existencia de redes como {\sc echelon}, dedicada en teor\'{\i}a al
espionaje de las telecomunicaciones (correo electr\'onico incluido) de todo el 
mundo, y puesta en marcha por los gobiernos estadounidense y brit\'anico, en
colaboraci\'on con el canadiense, australiano y neozeland\'es. >Qu\'e
diferencia hay entre un gobierno que esp\'{\i}a nuestro correo y un {\it
cracker} que esnifa nuestras claves? >Qui\'en decide qu\'e es m\'as `privado'
para m\'{\i}, si mi correo o mis contrase\~nas? >Un juez que a duras penas
conoce la diferencia entre `asterisco' y `asteroide'? Ser\'{\i}a muy interesante
plantearselo\ldots\\
\\La simpat\'{\i}a social hacia los piratas es tal que incluso existen empresas 
que se jactan de contratar a estas personas, y mucho mejor -- m\'as publicidad 
-- cuanto m\'as `malos' hayan sido en el pasado o cuanto m\'as {\it eleet} haya 
sido o sea su
apodo (muy pocos contratar\'{\i}an a un pirata que se haga llamar `Manolo', pero
si su {\it alias} era {\it `Z3roK00l'} tiene m\'as posibilidades ;-); as\'{\i}
lo pueden disfrazar de arrepentido, como alguien que cambia de bando ({\it 
`hacking \'etico'} es la palabra que a los departamentos de {\it marketing} les
gusta utilizar para hablar de esta tendencia). Seguramente, de las personas que 
dejan auditar
sus entornos inform\'aticos a piratas (ex--piratas, perd\'on), muy pocos 
dejar\'{\i}an una parcela de bosque de su propiedad al cuidado de un pir\'omano 
(de nuevo, ex--pir\'omano), y eso a pesar de que, siguiendo la teor\'{\i}a que 
han aplicado a sus redes y a sus sistemas, nadie conocer\'a mejor que un 
antiguo pir\'omano los secretos de las t\'acticas de provocaci\'on de incendios 
forestales, por lo que nadie mejor que \'el para evitar que se produzcan\ldots 
>verdad? Por supuesto, todos podemos haber cometido errores en el pasado, pero
si no existe un claro cambio de conducta por su parte, alguien que haya sido
un pirata es muy probable que lo siga siendo, aunque ahora cobre por ello.\\
\\Sin entrar a juzgar la inteligencia o la \'etica de estos individuos
-- evidentemente, habr\'a de todo en la comunidad {\it underground} --, 
desde un punto de vista t\'ecnico sus actividades no dicen nada a su favor; 
seguramente la 
actitud de estos delincuentes ser\'a m\'as interesante para un psiquiatra, un
soci\'ologo o un psic\'ologo de lo que lo pueda ser para un inform\'atico\ldots 
Las `haza\~nas' de estas personas constituyen un obvio problema de seguridad 
tanto para nuestras redes como para nuestras m\'aquinas; para evitar los 
t\'{\i}picos conflictos de denominaci\'on ({\it >hackers o crackers?}) hemos
decidido llamar a los piratas inform\'aticos {\bf intrusos} o 
simplemente {\bf piratas}. Los problemas que nos causan no son algo nuevo: como
ya dijimos en el primer punto, el primer trabajo sobre detecci\'on de intrusos 
data de 1980 (\cite{kn:and80}), y desde entonces este campo ha sido, es, y con 
toda probabilidad seguir\'a siendo, uno de los m\'as activos en la 
investigaci\'on dentro del mundo de la seguridad inform\'atica.
