\chapter{Criptolog\'{\i}a}
\section{Introducci\'on}
En el {\it mundo real}, si una universidad quiere proteger los 
expedientes de sus alumnos los guardar\'a en un armario ign\'{\i}fugo, bajo
llave y vigilado por guardias, para que s\'olo las personas autorizadas 
puedan acceder a ellos para leerlos o modificarlos; si queremos 
proteger nuestra correspondencia de curiosos, simplemente usamos un sobre; si 
no queremos que nos roben dinero, lo guardamos en una caja fuerte\ldots 
Lamentablemente, en una red no disponemos de todas estas medidas que nos 
parecen habituales: la principal (podr\'{\i}amos decir {\bf \'unica}) forma de 
protecci\'on 
va a venir de la mano de la criptograf\'{\i}a. El cifrado de los datos nos va a
permitir desde proteger nuestro correo personal para que ning\'un curioso lo 
pueda leer, hasta controlar el acceso a nuestros archivos de forma que s\'olo 
personas autorizadas puedan examinar (o lo que quiz\'as es m\'as importante, 
mo\-di\-fi\-car) su contenido, pasando por proteger nuestras claves cuando
conectamos a un sistema remoto o nuestros datos bancarios cuando realizamos
una compra a trav\'es de Internet. Hemos presentado con anterioridad algunas
aplicaciones que utilizan de una u otra forma la criptograf\'{\i}a para proteger
nuestra informaci\'on; aqu\'{\i} intentaremos dar unas bases te\'oricas 
m\'{\i}nimas sobre t\'erminos, algoritmos, funciones\ldots utilizadas en ese
tipo de aplicaciones. Para m\'as referencias es {\bf imprescindible} la obra 
\cite{kn:sch94}; otras publicaciones interesantes son \cite{kn:men96}, 
\cite{kn:den83}, \cite{kn:sal90} y, para temas de criptoan\'alisis,
\cite{kn:army}. Un texto b\'asico para aquellos que no 
disponen de mucho tiempo o que s\'olo necesitan una perspectiva general de la
criptograf\'{\i}a puede ser \cite{kn:cab96}.\\
\\La {\bf criptolog\'{\i}a} (del griego {\it krypto} y {\it logos}, estudio 
de lo oculto, lo escondido) es la ciencia\footnote{Hemos de dejar patente 
que la criptolog\'{\i}a es una {\it ciencia}, aunque en muchos lugares a\'un 
se la considera un {\it arte}; por ejemplo, en el Diccionario de la Real 
Academia de la Lengua Espa\~nola.} que trata los problemas te\'oricos
relacionados con la seguridad en el intercambio de mensajes en clave entre
un emisor y un receptor a trav\'es de un canal de comunicaciones (en
t\'erminos inform\'aticos, ese canal suele ser una red de computadoras).
Esta ciencia est\'a dividida en dos grandes ramas: la {\bf criptograf\'{\i}a},
ocupada del cifrado de mensajes en clave y del dise\~no de criptosistemas
(hablaremos de \'estos m\'as adelante), y el {\bf criptoan\'alisis},
que trata de descifrar los mensajes en clave, rompiendo as\'{\i} el 
criptosistema. En lo sucesivo nos centraremos m\'as en la criptograf\'{\i}a y 
los criptosistemas que en el criptoan\'alisis, ya que nos interesa, m\'as que 
romper sistemas de cifrado 
(lo cual es bastante complicado cuando trabajamos con criptosistemas serios), 
el saber c\'omo funcionan \'estos y conocer el dise\~no elemental de algunos 
sistemas seguros.\\
\\La criptograf\'{\i}a es una de las ciencias consideradas como m\'as
antiguas, ya que sus or\'{\i}genes se remontan al nacimiento de nuestra
civilizaci\'on. Su uso original era el proteger la confidencialidad
de informaciones militares y pol\'{\i}ticas, pero en la actualidad es una 
ciencia interesante no s\'olo en esos c\'{\i}rculos cerrados, sino para
cualquiera 
que est\'e interesado en la confidencialidad de unos determinados datos: 
actualmente existe multitud de software y hardware destinado a analizar y 
monitorizar el tr\'afico de datos en redes de computadoras; si bien estas 
herramientas constituyen un avance en t\'ecnicas de seguridad y protecci\'on,
su uso indebido es al mismo tiempo un grave problema y una enorme fuente
de ataques a la intimidad de los usuarios y a la integridad de los propios 
sistemas. Aunque el objetivo original de la criptograf\'{\i}a era mantener en 
secreto un mensaje, en la actualidad no se persigue \'unicamente la privacidad 
o {\bf confidencialidad} de los datos, sino que se busca adem\'as garantizar la 
{\bf autenticidad} de los mismos (el emisor del mensaje es quien dice ser, y 
no otro), su {\bf integridad} (el mensaje que leemos es el mismo que nos 
enviaron) y su {\bf no repudio} (el emisor no puede negar el haber enviado el 
mensaje).\\
\\Podemos dividir la historia de la criptograf\'{\i}a en tres periodos
fundamentales; hasta mediados de siglo, tenemos la criptolog\'{\i}a 
precient\'{\i}fica, considerada no una ciencia sino m\'as bien un arte. En 
1949, Shannon logr\'o cimentar la criptograf\'{\i}a sobre unas bases 
matem\'aticas (\cite{kn:sha49}), comenzando el per\'{\i}odo de la 
criptograf\'{\i}a cient\'{\i}fica. Poco m\'as de diez a\~nos despu\'es se
comenz\'o a estudiar la posibilidad de una comunicaci\'on secreta sin que ambas
partes conocieran una clave com\'un (hasta ese momento la existencia de dicha
clave era la base de toda la seguridad en el intercambio de informaci\'on),
de forma que esos estudios dieron lugar a diversos art\'{\i}culos sobre el tema 
durante la d\'ecada de los setenta (\cite{kn:ell70}, \cite{kn:coc73}, 
\cite{kn:wil74}, \cite{kn:wil76}\ldots). Finalmente, en 1976 Diffie y Hellman 
publicaron sus trabajos sobre criptograf\'{\i}a de clave p\'ublica 
(\cite{kn:dh76}), dando lugar al per\'{\i}odo de criptograf\'{\i}a de clave 
p\'ublica, que dura hasta la actualidad.
\section{Criptosistemas}
Matem\'aticamente, podemos definir un criptosistema como una cuaterna
de elementos {\it\{$\cal A,K,E,D$\}}, formada por:
\begin{itemize}
\item{}Un conjunto finito llamado {\bf alfabeto}, $\cal A$, a partir del cual, 
y utilizando ciertas normas sin\-t\'ac\-ti\-cas y sem\'anticas, podremos emitir
un mensaje en claro (\it{plain text}\rm) u obtener el texto en claro 
correspondiente a un mensaje cifrado ({\it cipher text}). Frecuentemente, este 
alfabeto es el conjunto de los enteros m\'odulo $q$, ${\cal Z}_{q}$, para un 
$q\in{\cal N}$ dado.
\item{}Otro conjunto finito denominado {\bf espacio de claves}, $\cal K$, 
formado por todas las posibles claves, tanto de cifrado como de descifrado, del 
criptosistema.
\item{}Una familia de aplicaciones del alfabeto en s\'{\i} mismo, 
$\cal E:A\rightarrow A$, llamadas {\bf transformaciones de cifrado}. El proceso 
de cifrado se suele representar como
\begin{center} 
${\cal E}(k,a)=c$
\end{center}
donde $k\in{\cal K}$, $a\in{\cal A}$ y $c\in{\cal A}$.
\item{}Otra familia de aplicaciones del alfabeto en s\'{\i} mismo, 
$\cal D:A\rightarrow A$, llamadas {\bf transformaciones de descifrado}. 
An\'alogamente al proceso de cifrado, el de descifrado se representa como
\begin{center} 
${\cal D}(k^{\prime},c)=m$,
\end{center}
donde $k^{\prime}\in {\cal K}$, $c\in{\cal A}$ y $m\in{\cal A}$.
\end{itemize}
Muchos autores dividen a su vez un miembro de esta cuaterna, el alfabeto, en 
dos espacios di\-fe\-ren\-tes: el espacio de mensajes, $\cal M$, formado por 
los textos en claro que se pueden formar con el alfabeto, y el espacio de 
cifrados, $\cal C$, formado por todos los posibles criptogramas que el cifrador 
es capaz de producir. Sin embargo, lo habitual es que tanto el texto en claro 
como el cifrado pertenecezcan al alfabeto, por lo que hemos 
preferido no hacer distinciones entre uno y otro, agrup\'andolos en el conjunto 
$\cal A$ para simplificar los conceptos que presentamos. As\'{\i}, un 
criptosistema presenta la estructura mostrada en la figura \ref{crypsys}.\\
\begin{figure}
\begin{center}
\setlength{\unitlength}{0.00083300in}%
%
\begingroup\makeatletter\ifx\SetFigFont\undefined%
\gdef\SetFigFont#1#2#3#4#5{%
  \reset@font\fontsize{#1}{#2pt}%
  \fontfamily{#3}\fontseries{#4}\fontshape{#5}%
  \selectfont}%
\fi\endgroup%
\begin{picture}(6675,2307)(1576,-2806)
\thicklines
\put(2401,-1861){\framebox(1800,1350){}}
\put(5926,-1861){\framebox(1800,1350){}}
\put(4201,-1186){\vector( 1, 0){1725}}
\put(7726,-1186){\vector( 1, 0){375}}
\put(3301,-2386){\vector( 0, 1){525}}
\put(6901,-2386){\vector( 0, 1){525}}
\put(6901,-2386){\line( 0, 1){  0}}
\put(1951,-1186){\vector( 1, 0){450}}
\put(2851,-1261){\makebox(0,0)[lb]{\smash{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}$\cal E$(k,a)}}}
\put(6376,-1261){\makebox(0,0)[lb]{\smash{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}$\cal D$(k\'{},c)}}}
\put(3151,-2761){\makebox(0,0)[lb]{\smash{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault} k }}}
\put(6751,-2761){\makebox(0,0)[lb]{\smash{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault} k\' }}}
\put(8251,-1261){\makebox(0,0)[lb]{\smash{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}a}}}
\put(1576,-1261){\makebox(0,0)[lb]{\smash{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}a}}}
\put(4951,-1036){\makebox(0,0)[lb]{\smash{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}c}}}
\end{picture}
\end{center}
\caption{Estructura de un criptosistema}
\label{crypsys}
\end{figure}
\\El emisor emite un texto en claro, que es tratado por un cifrador con la 
ayuda de una cierta clave, $k$, creando
un texto cifrado (criptograma). Este criptograma llega al descifrador a
trav\'es de un canal de comunicaciones (como hemos dicho antes, para
nosotros este canal ser\'a habitualmente alg\'un tipo de red), y este
convierte el criptograma de nuevo en texto claro, apoy\'andose ahora en otra
clave, $k^{\prime}$ (veremos m\'as adelante que esta clave puede o no ser la 
misma que la utilizada para cifrar).Este texto claro ha de coincidir con el 
emitido inicialmente para que se cumplan los principios b\'asicos de la 
criptograf\'{\i}a moderna: en este hecho radica toda la importancia 
de los criptosistemas.\\
\\Es obvio, a la vista de lo expuesto anteriormente, que el elemento m\'as 
importante de todo el criptosistema es el cifrador, que ha de utilizar el 
algoritmo de cifrado para convertir el texto claro en un criptograma.
Usualmente, para hacer esto, el cifrador depende de un par\'ametro
exterior, llamado {\bf clave de cifrado} (o de descifrado, si hablamos del
descifrador) que es aplicado a una funci\'on matem\'atica irreversible (al
menos, computacionalmente): no es posible invertir la funci\'on a
no ser que se disponga de la clave de descifrado. De esta forma, cualquier
conocedor de la clave (y, por supuesto, de la funci\'on), ser\'a
capaz de descifrar el criptograma, y nadie que no conozca dicha clave puede
ser capaz del descifrado, a\'un en el caso de que se conozca la funci\'on
utilizada.
\section{Clasificaci\'on de los criptosistemas}
La gran clasificaci\'on de los criptosistemas se hace en funci\'on
de la disponibilidad de la clave de cifrado/descifrado. Existen, por tanto,
dos grandes grupos de criptosistemas:
\subsection{Criptosistemas de clave secreta}
Denominamos criptosistema de clave secreta (de clave privada, de clave \'unica 
o sim\'etrico) a aquel criptosistema en el que la clave de cifrado, ${\cal K}$, 
puede ser calculada a partir de la de descifrado, ${\cal K}^{\prime}$, y
viceversa. En la mayor\'{\i}a de estos sistemas, ambas claves coinciden, y por
supuesto han de mantenerse como un secreto entre emisor y receptor: si un 
atacante descubre la clave utilizada en la comunicaci\'on, ha roto el 
criptosistema.\\
\\Hasta la d\'ecada de los setenta, la invulnerabilidad de todos
los sistemas depend\'{\i}a de este man\-te\-ni\-mien\-to en secreto de la clave 
de cifrado. Este hecho presentaba una gran desventaja: hab\'{\i}a que enviar, 
aparte del criptograma, la clave de cifrado del emisor al receptor, para que 
\'este fuera capaz de descifrar el mensaje. Por tanto, se incurr\'{\i}a en los
mismos peligros al enviar la clave, por un sistema que hab\'{\i}a de
ser supuestamente seguro, que al enviar el texto plano. De todos
los sistemas de clave secreta, el \'unico que se utiliza en la actualidad
es DES ({\it Data Encryption Standard}, que veremos m\'as
adelante); otros algoritmos de clave privada, como el cifrado Caesar o el 
criptosistema de Vigen\`ere (ser\'an tambi\'en brevemente comentados m\'as 
adelante) han sido criptoanalizados con \'exito, lo cual da una idea del 
porqu\'e del desuso en que han ca\'{\i}do estos sistemas (con la excepci\'on de 
DES, que es seguramente el algoritmo de cifra m\'as utilizado en la actualidad).
Por si esto no fuera suficiente, el hecho de que exista al menos una clave de 
cifrado/descifrado entre cada dos usuarios de un sistema har\'{\i}a inviable la 
existencia de criptosistemas sim\'etricos en las grandes redes de computadores
de hoy en d\'{\i}a: para un sistema de computaci\'on con $N$ usuarios,
se precisar\'{\i}an $\frac{N(N-1)}{2}$ claves diferentes, lo cual es obviamente 
imposible en grandes sistemas. Todos estos motivos han propiciado que el 
estudio de los cifradores sim\'etricos (excepto DES) quede relegado a un papel 
hist\'orico.\\
\\Los sistemas de cifrado de clave \'unica se dividen a su vez en dos grandes 
grupos de criptosistemas: por una parte tenemos los {\bf cifradores de flujo}, 
que son aquellos que pueden cifrar un s\'olo bit de texto claro al mismo 
tiempo, y por tanto su cifrado se produce bit a bit, y por otro lado tenemos 
los {\bf cifradores de bloque}, que cifran un bloque de bits (habitualmente, 
cada bloque es de 64 bits) como una \'unica unidad.

\subsection{Criptosistemas de clave p\'ublica}
Como hemos dicho en la introducci\'on, en 1976, Whitfield Diffie y Martin 
Hellman, de la Universidad de Stanford,
demostraron la posibilidad de construir criptosistemas que no precisaran
de la transferencia de una clave secreta en su trabajo \cite{kn:dh76}. Esto 
motiv\'o multitud de investigaciones y discusiones sobre la criptograf\'{\i}a 
de clave p\'ublica y su impacto, hasta el punto que
la NSA ({\it National Security Agency}) estadounidense trat\'o de controlar
el desarrollo de la criptograf\'{\i}a, ya que la consideraban una amenaza 
peligrosa para la seguridad nacional. Esta pol\'emica ha llegado incluso hasta 
nuestros d\'{\i}as, en los que el {\it affaire} Zimmermann (el autor de PGP) o 
el {\it Clipper Chip} han llenado portadas de peri\'odicos de todo el mundo.\\
\\Veamos ahora en que se basan los criptosistemas de clave p\'ublica.
En \'estos, la clave de cifrado se hace de conocimiento general (se
le llama {\bf clave p\'ublica}). Sin embargo, no ocurre lo mismo con la
clave de descifrado ({\bf clave privada}), que se ha de mantener en secreto.
Ambas claves no son independientes, pero del conocimiento de la p\'ublica
no es posible deducir la privada sin ning\'un otro dato (recordemos que en los
sistemas de clave privada suced\'{\i}a lo contrario). Tenemos pues un par 
clave p\'ublica-clave privada; la existencia de ambas claves di\-fe\-ren\-tes, para
cifrar o descifrar, hace que tambi\'en se conozca a estos criptosistemas como
{\bf asim\'etricos}.\\
\\Cuando un receptor desea recibir una informaci\'on cifrada, ha
de hacer llegar a todos los potenciales emisores su clave p\'ublica,
para que estos cifren los mensajes con dicha clave. De este modo, el \'unico
que podr\'a descifrar el mensaje ser\'a el leg\'{\i}timo receptor,
mediante su clave privada. Matem\'aticamente, si $\cal E$ es el algoritmo
cifrador y $\cal D$ el descifrador, se ha de cumplir que 
\begin{center}${\cal D}(k,{\cal E}(k^{\prime},M))=M$,
\end{center}
representando $\cal M$ un mensaje, y siendo $k$ y $k^{\prime}$ las claves de 
descifrado y cifrado, respectivamente.
\section{Criptoan\'alisis}
El criptoan\'alisis es la ciencia opuesta a la criptograf\'{\i}a (quiz\'as
no es muy afortunado hablar de ciencias {\it opuestas}, sino m\'as bien de 
ciencias {\it complementarias}), ya 
que si \'esta trata principalmente de crear y analizar criptosistemas seguros,
la primera intenta romper esos sistemas, demostrando su vulnerabilidad: dicho
de otra forma, trata de descifrar los criptogramas.
El t\'ermino {\it descifrar} siempre va acompa\~nado de discusiones de 
car\'acter t\'ecnico, aunque asumiremos que descifrar es conseguir el texto en 
claro a partir de un criptograma, sin entrar en pol\'emicas de reversibilidad y 
solidez de criptosistemas.\\
\\En el an\'alisis para establecer las posibles debilidades de un
sistema de cifrado, se han de asumir las denominadas condiciones del peor
caso: 
(1) el criptoanalista tiene acceso completo al algoritmo de encriptaci\'on,
(2) el criptoanalista tiene una cantidad considerable de texto cifrado,
y (3) el criptoanalista conoce el texto en claro de parte de ese texto
cifrado. Tambi\'en se asume generalmente el {\bf Principio de Kerckhoffs},
que establece que la seguridad del cifrado ha de residir exclusivamente
en el secreto de la clave, y no en el mecanismo de cifrado.\\
\\Aunque para validar la robustez de un criptosistema normalmente se
suponen todas las condiciones del peor caso, existen ataques m\'as
espec\'{\i}ficos, en los que no se cumplen todas estas condiciones. Cuando el
m\'etodo de ataque consiste simplemente en probar todas y cada una de las
posibles claves del espacio de claves hasta encontrar la correcta, nos 
encontramos ante un ataque de fuerza bruta o {\bf ataque exhaustivo}. Si
el atacante conoce el algoritmo de cifrado y s\'olo tiene acceso al
criptograma, se plantea un {\bf ataque s\'olo al criptograma}; un caso m\'as 
favorable
para el criptoanalista se produce cuando el ataque cumple todas las condiciones
del peor caso; en este caso, el criptoan\'alisis se denomina
{\bf de texto en claro conocido}. Si adem\'as el atacante puede cifrar una 
cantidad 
indeterminada de texto en claro al ataque se le denomina {\bf de texto en claro 
escogido}; este es el caso habitual de los ataques contra el sistema de
verificaci\'on de usuarios utilizado por Unix, donde un intruso consigue la
tabla de contrase\~nas (generalmente {\tt /etc/passwd}) y se limita a realizar
cifrados de textos en claro de su elecci\'on y a comparar los resultados con 
las claves cifradas (a este ataque tambi\'en se le llama {\bf de 
diccionario}, debido a que el atacante suele utilizar un fichero `diccionario' 
con los textos en claro que va a utilizar).  El caso m\'as favorable para un 
analista se produce cuando puede 
obtener el texto en claro correspondiente a criptogramas de su elecci\'on; en 
este caso el ataque se denomina {\bf de texto cifrado escogido}.\\
\\Cualquier algoritmo
de cifrado, para ser considerado seguro, ha de soportar todos estos ataques 
y otros no citados; sin embargo, en la criptograf\'{\i}a, como en cualquier 
aspecto de la seguridad, inform\'atica o no, no debemos olvidar un factor muy 
importante: las personas. El sistema m\'as robusto caer\'a f\'acilmente si se 
tortura al emisor o al receptor hasta que desvelen el contenido del mensaje, o 
si se le ofrece a uno de ellos una gran cantidad de dinero; este tipo de 
ataques (sobornos, amenazas, extorsi\'on, tortura\ldots) se consideran siempre 
los m\'as efectivos.\\
\section{Criptograf\'{\i}a cl\'asica}
\subsection{El sistema Caesar}
El cifrado Caesar (o C\'esar) es uno de los m\'as antiguos que se conocen.
Debe su nombre al em\-pe\-ra\-dor Julio C\'esar, que presuntamente lo utiliz\'o 
para establecer comunicaciones seguras con sus generales durante las Guerras 
G\'alicas.\\
\\Matem\'aticamente, para trabajar con el cifrado Caesar, tomamos
el alfabeto ${\cal A}={\cal Z}_{m}$ (enteros de m\'odulo $m$). Cuando $a$ y $b$ 
son primos entre s\'{\i}, la aplicaci\'on $f(x)=ax+b$, $a\neq 0$, recibe el 
nombre de {\it codificaci\'on m\'odulo m con par\'ametros a, b}, donde el par 
$(a,b)$ es la clave de este criptosistema. As\'{\i}, trabajando con el 
alfabeto ingl\'es (para nosotros resulta 
conveniente tomar este alfabeto, de uso m\'as extendido en inform\'atica que el 
espa\~nol; la \'unica diferencia radica en el uso de la letra `\~n'), podemos 
tomar el alfabeto definido por ${\cal Z}_{26}$, para lo cual asignamos a cada 
letra $(a..z)$ un entero m\'odulo 26, de la siguiente forma:
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
A=0 & B=1 & C=2 & D=3 & E=4 & F=5\\ \hline
G=6 & H=7 & I=8 & J=9 & K=10 & L=11\\ \hline
M=12& N=13 & O=14 & P=15 & Q=16 & R=17\\ \hline
S=18 & T=19 & U=20 & V=21 & W=22 & X=23\\ \hline
Y=24 & Z=25 &&&&\\
\hline
\end{tabular}
\end{center}
El cifrado Caesar siempre utiliza la clave $(1,b)$, es decir, siempre
tomaremos $a=1$. De esta forma, la anterior aplicaci\'on quedar\'a
$f(x)=x+b$, lo cual se traduce sencillamente en que para encriptar una letra
hemos de tomar su entero correspondiente y sumarle $b$ (la clave del 
criptosistema) para obtener el texto cifrado. An\'alogamente, y gracias al 
hecho de que $f(x)$ siempre ha de ser biyectiva, independientemente del valor
de $b$, para descifrar un texto tomamos la funci\'on inversa, definida
por $f^{-1}(x)=x-b$. Veamos un ejemplo sencillo, en el que se toma $b=4$:
queremos cifrar, con la clave $(1,4)$, la palabra {\it CESAR}; en primer lugar,
tomando el valor de cada letra, tenemos el equivalente num\'erico de la palabra:
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
C & E & S & A & R\\
\hline
2 & 4 & 18 & 0 & 17\\
\hline
\end{tabular}
\end{center}
A cada uno de los n\'umeros anteriores le aplicamos la funci\'on $f(x)=x+4$,
de forma que obtenemos el texto cifrado: 
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
6 & 8 & 22 & 4 & 21\\
\hline
G & I & W & E & W\\
\hline
\end{tabular}
\end{center}
Este texto ({\it GIWEV}) es el resultado de cifrar la palabra {\it CESAR} con
la clave elegida ($b=4$): es lo que enviar\'{\i}amos al receptor, que conociendo
la clave acordada ser\'{\i}a capaz de descifrarlo.\\
\\Veamos ahora el ejemplo contrario: somos los receptores de un mensaje del que 
sabemos que ha sido cifrado con la misma clave $(1,4)$, y buscamos descifrar la 
cadena que nos ha sido enviada, {\it FVYXYW}. El valor de cada letra es
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
F & V & Y & X & Y & W\\
\hline
5 & 21 & 24 & 23 & 24 & 22\\
\hline
\end{tabular}
\end{center}
Tomando $f^{-1}(x)=x-4$, tenemos el resultado
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
1 & 17 & 20 & 19 & 20& 18\\
\hline
B & R & U & T & U & S\\
\hline
\end{tabular}
\end{center}
Como vemos, retornando cada n\'umero al alfabeto ingl\'es obtenemos el texto
en claro que nuestro emisor nos ha enviado: {\it BRUTUS}, equivalente al 
cifrado {\it FVYXYW}.\\
\\Si en el cifrado de un mensaje obtuvi\'eramos que $f(x)>25$ (gen\'ericamente,
$f(x)>m-1$), como trabajamos con enteros de m\'odulo $m$, deber\'{\i}amos
dividir $f(x)$ por $m$, considerando el resto entero como la cifra adecuada.
As\'{\i}, si $f(x)=26$, tomamos $mod(26,26)=0$ (el resto de la divisi\'on
entera), por lo que situar\'{\i}amos una `A' en el texto cifrado.\\
\\Es obvio que el cifrado Caesar tiene 26 claves diferentes (utilizando
el alfabeto ingl\'es), incluyendo la clave de identidad ($b=0$), caso
en el que el texto cifrado y el texto en claro son id\'enticos. As\'{\i}
pues, no resultar\'{\i}a muy dif\'{\i}cil para un criptoanalista realizar
un ataque exhaustivo, buscando en el texto cifrado palabras en claro con
significado en el lenguaje utilizado. Por este motivo, y por otros muchos, este 
criptosistema es claramente vulnerable para un atacante, no ofreciendo una 
seguridad fiable en la transmisi\'on de datos confidenciales.
\subsection{El criptosistema de Vig\`enere}
El sistema de cifrado de Vigen\`ere (en honor al cript\'ografo
franc\'es del mismo nombre) es un sistema polialfab\'etico o
de sustituci\'on m\'ultiple. Este tipo de criptosistemas aparecieron
para sustituir a los monoalfab\'eticos o de sustituci\'on simple,
basados en el Caesar, que presentaban ciertas debilidades frente al ataque
de los criptoanalistas relativas a la frecuencia de aparici\'on de
elementos del alfabeto. El principal elemento de este sistema es la llamada
Tabla de Vigen\`ere, una matriz de caracteres cuadrada, con dimensi\'on 
$26\times26$, que se muestra en la tabla \ref{vig}.\\
% TABLEAU VIGENERE
\begin{table}
\begin{center}
\vspace{0.5cm}
\begin{sloppypar}
\begin{tabular}{|p{5pt}||p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}p{3pt}|}

\hline
 & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s
& t & u & v & w & x & y & z \\ \hline\hline
{\bf A} &a &b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z \\
{\bf B} &b &c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a\\
{\bf C} &c &d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b\\
{\bf D} &d &e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c\\
{\bf E} &e &f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d\\
{\bf F} &f &g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e\\
{\bf G} &g &h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f\\
{\bf H} &h &i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g\\
{\bf I} &i &j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h\\
{\bf J} &j &k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i\\
{\bf K} &k &l & m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j\\
{\bf L} &l &m & n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k\\
{\bf M} &m &n & o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l\\
{\bf N} &n &o & p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m\\
{\bf O} &o &p & q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n\\
{\bf P} &p &q & r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o\\
{\bf Q} &q &r & s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p\\
{\bf R} &r &s & t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q\\
{\bf S} &s &t & u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r\\
{\bf T} &t &u & v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s\\
{\bf U} &u &v & w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t\\
{\bf V} &v &w & x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u\\
{\bf W} &w &x & y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v\\
{\bf X} &x &y & z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w\\
{\bf Y} &y &z & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x\\
{\bf Z} &z &a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y\\ \hline
\end{tabular}
%{}
\end{sloppypar}
\caption{Tableau Vig\`enere}
\label{vig}
\end{center}
\end{table}
\\La clave del sistema de cifrado de Vigen\`ere es una palabra de
$k$ letras, $k\geq 1$, del alfabeto $Z_{26}$ utilizado anteriormente; esta 
palabra es un elemento del producto cartesiano 
$Z_{26}\times Z_{26}\times...\times Z_{26}$ ($k$ veces), que es justamente
el alfabeto del criptosistema de Vigen\`ere. De esta forma, el mensaje
a cifrar en texto claro ha de descomponerse en bloques de $k$ elementos --
letras --
y aplicar sucesivamente la clave empleada a cada uno de estos bloques,
utilizando la tabla anteriormente proporcionada.\\
\\Veamos un ejemplo de aplicaci\'on del criptosistema de Vigen\`ere:
queremos codificar la frase {\it La abrumadora soledad del programador}
utilizando la clave {\it prueba}. En primer lugar, nos fijamos en la longitud
de la clave: es de seis caracteres, por lo que descomponemos la frase
en bloques de longitud seis; aunque el \'ultimo bloque es de longitud tres,
esto no afecta para nada al proceso de cifrado:
\tt
\begin{center}
laabru    madora   soleda    ddelpr    ograma   dor
\end{center}
\rm
Ahora, aplicamos a cada bloque la clave {\it prueba} y buscamos los resultados
como entradas de la tabla de Vigen\`ere:
\begin{quote}
\begin{verbatim}
laabru    madora   soleda    ddelpr    ograma   dor
prueba    prueba   prueba    prueba    prueba   pru
arufsu    brxhsa   igfiea    suyoqr    exmena   sgm
\end{verbatim}
\end{quote}
Por ejemplo, la primera {\it `a'} del texto cifrado corresponde a la entrada
$(l,p)$, o, equivalentemente, $(p,l)$ de la tabla de Vigen\`ere.
Finalmente, vemos que el texto cifrado ha quedado {\it arufsu brxhsa igfiea
suyoqr exmena sgm}.\\
\\Este m\'etodo de cifrado polialfab\'etico se consideraba
invulnerable hasta que en el S.XIX se consiguieron descifrar algunos mensajes
codificados con este sistema, mediante el estudio de la repetici\'on
de bloques de letras: la distancia entre un bloque y su repetici\'on
suele ser m\'ultiplo de la palabra tomada como clave.\\
\\Una mejora sobre el cifrado de Vigen\`ere fu\'e introducida
por el sistema de Vernam, utilizando una clave aleatoria de longitud $k$
igual a la del mensaje; la confianza en este nuevo criptosistema hizo que
se utilizase en las comunciaciones confidenciales entre la Casa Blanca
y el Kremlin, hasta, por lo menos, el a\~no 1987.
\section{Un criptosistema de clave secreta: DES}
El DEA ({\it Data Encryption Algorithm}) o DES ({\it Data Encryption Standard})
es desde 1977 de uso obligatorio en el cifrado de informaciones gubernamentales
no clasificadas (anunciado por el {\it National Bureau of Standards}, USA). Este
criptosistema fue desarrollado por IBM como una variaci\'on
de un criptosistema anterior, Lucifer, y posteriormente, tras algunas 
comprobaciones llevadas a cabo por la NSA estadounidense, pas\'o
a transformarse en el que hoy conocemos como DES. DES puede ser implementado 
tanto en {\it software} como en chips con tecnolog\'{\i}a VLSI ({\it Very Large 
Scale Integration}), alcanzando en {\it hardware} una velocidad
de hasta 50 Mbs. Un ejemplo de implantaci\'on {\it hard} puede ser PC-Encryptor,
de Eracom, y un ejemplo de implantaci\'on en {\it software} es DES-LOCK,
de la empresa Oceanics.\\
\\DES es un sistema de clave privada tanto de cifrado como de descifrado;
posee una clave de entrada con una longitud de 64 {\it bits}, produciendo una
salida tambi\'en de 64 {\it bits}, con una clave de 56 {\it bits} (el octavo 
{\it bit} de cada {\it byte} es de paridad), llamada clave externa, en la que 
reside toda
la seguridad del criptosistema ya que el algoritmo es de dominio p\'ublico.
Cada trozo de 64 {\it bits} de los datos se desordena seg\'un un esquema
fijo a partir de una permutaci\'on inicial conocida como IP. A continuaci\'on,
se divide cada uno de los trozos en dos mitades de 32 {\it bits}, que se someten
a un algoritmo durante 16 iteraciones. Este algoritmo b\'asico que
se repite 16 veces (llamadas vueltas), utiliza en cada una de ellas 48 de los 
56 {\it bits} de la clave (estos 48 {\it bits} se denominan clave interna, 
diferente en cada vuelta); las claves internas se utilizan en un orden para 
cifrar texto (lla\-me\-mos\-las $K_{1}, K_{2},...,K_{16}$) y en el orden 
inverso ($K_{16},..., K_{1}$)
para descifrarlo. En cada una de las vueltas se realizan permutaciones,
sustituciones no lineales (que constituyen en s\'{\i} el n\'ucleo
del algoritmo DES) y operaciones l\'ogicas b\'asicas, como la
XOR. La mitad derecha se transfiere a la mitad izquierda sin ning\'un
cambio; tambi\'en se expande de 32 hasta 48 {\it bits}, utilizando para
ello una simple duplicaci\'on. El resultado final de una iteraci\'on
es un XOR con la clave interna de la vuelta correspondiente, y esta salida
se divide en bloques de 6 {\it bits}, cada uno de los cuales se somete a una
sustituci\'on en un bloque de 4 {\it bits} (bloque-S, con un rango 0...63)
dando una salida tambi\'en de 4 {\it bits} (rango decimal 0...15) que a
su vez se recombina con una permutaci\'on en un registro con longitud
32 {\it bits}. Con el contenido de este registro se efectua una operaci\'on
XOR sobre la mitad izquierda de los datos originales, convirti\'endose
el nuevo resultado en una salida (parte derecha) de 32 {\it bits}; transcurridas
las dieciseis vueltas, las dos mitades finales (de 32 {\it bits} cada una) se 
recombinan con una permutaci\'on contraria a la realizada al principio (IP),
y el resultado es un criptograma de 64 {\it bits}.\\
\\Aunque no ha sido posible demostrar rigurosamente la debilidad del
criptosistema DES, y actualmente es uno de los m\'as utilizados en el mundo
entero, parece claro que con las actuales computadoras y su elevada potencia
de c\'alculo una clave de 56 {\it bits} (en la que recordemos, reside toda
la seguridad del DES) es f\'acilmente vulnerable frente a un ataque
exhaustivo en el que se prueben combinaciones de esos 56 {\it bits}. Hay que
resaltar que el tama\~no inicial de la clave, en el dise\~no
de IBM, era de 128 {\it bits}; la raz\'on de la disminuci\'on no se
ha hecho p\'ublica hasta el momento. Por si esto fuera poco, otro
factor que ha aumentado las controversias y discusiones acerca de la seguridad
de DES son dos propiedades del algoritmo: la propiedad de complementaci\'on,
que reduce el tiempo necesario para un ataque exhaustivo, y la propiedad
de las claves d\'ebiles, dada cuando el proceso de cifrado es id\'entico
al de descifrado 
($K_{1}=K_{16}, K_{2}=K_{15},..., K_{8}=K_{9}$), que sucede con cuatro claves
del criptosistema. Otro {\it secreto} de IBM (a instancias de la NSA)
es la elecci\'on y dise\~no de las {\it cajas} que
DES utiliza para el cifrado; no se puede evitar el pensar que el gobierno
estadounidense precise un criptosistema con la robustez necesaria para
que nadie, excepto ellos, pueda descifrarlo.\\
\\A la vista de estos hechos, la idea de que DES no va a seguir siendo
el algoritmo de cifrado est\'andar en las instituciones estadounidenses
se va generalizando poco a poco; por tanto, va a ser necesario sustituirlo
por otro algoritmo m\'as robusto frente a los ataques.
Siguiendo esta l\'{\i}nea, Xuejia Lai y James Massey, dos prestigiosos
cript\'ografos, desarrollaron a finales de la d\'ecada de los
ochenta el algoritmo IDEA ({\it International Data Encryption Algorithm}), 
compatible con DES (para aprovechar el gran n\'umero de equipos que utilizan
este algoritmo), y con una robustez garantizada por la clave de 128 {\it bits}
que utiliza este cifrador de bloques y las complejas operaciones
utilizadas para evitar el \'exito de un posible atacante, que van
desde t\'ecnicas de difusi\'on hasta adiciones m\'odulo
$2^{16}$.\\
\\El algoritmo IDEA est\'a siendo ampliamente aceptado en diversas
aplicaciones inform\'aticas orientadas a la seguridad de los datos;
numerosos programas destinados a trabajar en red utilizan ya este algoritmo como
el principal de cifrado.
\section{Criptosistemas de clave p\'ublica}
\subsection{El criptosistema RSA}
Este sistema de clave p\'ublica fu\'e dise\~nado en
1977 por los profesores del MIT (\it{Massachusetts Institute of Technology}\rm)
Ronald R. Rivest, Adi Shamir y Leonard M. Adleman, de ah\'{\i} las siglas
con las que es conocido. Desde entonces, este algoritmo de cifrado se ha
convertido en el prototipo de los de clave p\'ublica.\\
\\La seguridad de RSA radica en la dificultad de la factorizaci\'on
de n\'umeros grandes: es f\'acil saber si un n\'umero es
primo, pero es extremadamente dif\'{\i}cil obtener la factorizaci\'on
en n\'umeros primos de un entero elevado, debido no a la dificultad
de los algoritmos existentes, sino al consumo de recursos f\'{\i}sicos
(memoria, necesidades {\it hardware}\ldots incluso tiempo de ejecuci\'on) de
tales algoritmos. Se ha demostrado que si n es el n\'umero de d\'{\i}gitos
binarios de la entrada de cualquier algoritmo de factorizaci\'on,
el coste del algoritmo es $\theta(2n)$, con un tiempo de ejecuci\'on perteneciente
a la categor\'{\i}a de los llamados problemas intratables.\\
\\Veamos el funcionamiento del algoritmo RSA: si un usuario A desea enviar
informaci\'on cifrada, en primer lugar tiene que calcular un par de claves 
(p\'ublica y privada), para lo que ha de elegir aleatoriamente dos n\'umeros
primos grandes (del orden de cien d\'{\i}gitos), $p$ y $q$, n\'umeros que
se han de mantener en secreto; si llamamos $N$ ($N$ se conoce como m\'odulo) al 
producto $p\times q$, el usuario ha de determinar otro entero, $d$, llamado 
exponente privado, que cumpla
\begin{center}
$mcd(d,(p-1)\times(q-1))=1,\: d<N$ 
\end{center}
es decir, $d$ y el producto $(p-1)\times (q-1)$, que llamaremos funci\'on de
Euler y denotaremos $\varphi(N)$, han de ser primos. Con estos datos, ya 
tenemos la clave privada
del cifrado: el par $(N,d)$; para obtener la clave p\'ublica, hallamos
el inverso multiplicativo del n\'umero $d$ respecto de $\varphi(N)$, de la forma
$e\times d=1\;mod\;\varphi(N)$. Calculado este entero $e$, llamado exponente 
p\'ublico, la clave p\'ublica ser\'a el par $(N,e)$.\\
\\Una vez el emisor A dispone de sus claves p\'ublica y privada,
podr\'{\i}a enviar un mensaje cifrado, que llamaremos $m$, a un posible
receptor, mediante la operaci\'on
\begin{center}
$c=m^{e}\,mod\,N$
\end{center}
aplicada a cada elemento del mensaje.\\
\\Cuando el receptor del criptograma desee descifrar el mensaje recibido, ha
de realizar la operaci\'on
\begin{center}
$m=c^{d}\,mod\,N$
\end{center}
para obtener el texto en claro del mensaje que acaba de recibir.\\
\\El sistema RSA ha permanecido invulnerable hasta hoy, a pesar de los
numerosos ataques de criptoanalistas; te\'oricamente es posible despejar
$d$ para obtener la clave privada, a partir de la funci\'on de descifrado,
resultando
\begin{center}
$d=log_{c} m(mod(p-1))$
\end{center}
Sin embargo, el c\'alculo de logaritmos discretos es un problema
de una complejidad desbordante, por lo que este tipo de ataque se vuelve
impracticable: la resoluci\'on de congruencias del tipo 
$a^{x}\equiv b(n)$, necesarias
para descifrar el mensaje, es algor\'{\i}tmicamente inviable sin ninguna
informaci\'on adicional, debido al elevado tiempo de ejecuci\'on
del algoritmo. Aunque cuando los factores de $(p-1)$ son peque\~nos existe
un algoritmo, desarrollado por Pohlig y Hellman de orden $O(log^{2} p)$, \'este
es otro de los algoritmos catalogados como intratables, vistos anteriormente.
\subsection{El criptosistema de ElGamal}
Durante 1984 y 1985 ElGamal desarroll\'o un nuevo criptosistema
de clave p\'ublica basado en la intratabilidad computacional del problema
del logaritmo discreto: obtener el valor de $x$ a partir de la expresi\'on
\begin{center}
$y\equiv a^{x}(mod\,p)$
\end{center}
es, como hemos comentado para RSA, computacionalemente intratable
por norma general.\\
\\Aunque generalmente no se utiliza de forma directa, ya que la velocidad
de cifrado y autenticaci\'on es inferior a la obtenida con RSA, y adem\'as
las firmas producidas son m\'as largas (<el doble de largo que el texto
original!), el algoritmo de ElGamal es de gran importancia en el desarrollo
del DSS ({\it Digital Signature Standard}), del NIST ({\it National Institute 
of Standards and Technology}) estadounidense.\\
\\En este sistema, para generar un par clave p\'ublica/privada, se
escoge un n\'umero primo grande, $p$, y dos enteros $x$ y $a$, 
$1\leq x\leq p-1$, $1\leq a\leq p-1$, y se calcula
\begin{center}
$y=a^{x}(mod\,p)$
\end{center}
La clave p\'ublica ser\'a el n\'umero $y$, y la privada el n\'umero $x$.\\
\\Para firmar un determinado mensaje, el emisor elige un entero aleatorio
$k$, $0<k<p-1$, no usado con anterioridad y con la restricci\'on
que $k$ sea relativamente primo a $(p-1)$, y computa
\begin{quote}
$r=a^{k}\,mod\,p$\\
$s=[k^{-1}(m-xr)]\,mod\,(p-1)$,
\end{quote}
donde $k^{-1}$ es el inverso de $k\, mod\, (p-1)$; as\'{\i},
\begin{center}
$k\times k^{-1}=1\, mod\, (p-1)$.
\end{center}
La firma del mensaje estar\'a entonces formada por $r$ y $s$; un potencial
receptor puede usar la clave p\'ublica y para calcular $y^{r} r^{s}\, mod\, p$
y comprobar si coincide con $a^{m}\,mod\,p$:
\begin{center}
$y^{r}r^{s}\,mod\,p= a^{m}\,mod\,p$
\end{center}
El criptosistema de ElGamal tiene una caracter\'{\i}stica determinante
que lo distingue del resto de sistemas de clave p\'ublica: en el cifrado
se utiliza aparte de la clave p\'ublica del receptor, la clave privada
del emisor.
\subsection{Criptosistema de McEliece}
En 1978 McEliece present\'o un nuevo criptosistema de clave p\'ublica,
basado en la Teor\'{\i}a de la Codificaci\'on algebraica. Dado que
esta teor\'{\i}a es muy compleja, los expertos recomiendan una 
familiarizaci\'on matem\'atica preliminar con la Teor\'{\i}a de la 
Codificaci\'on, los C\'odigos de Goppa, y los Cuerpos de Galois.\\
\\En el sistema de McEliece, cada usuario ha de elegir un polinomio irreducible
de grado $t$, y construir una matriz generadora del correspondiente c\'odigo
de Goppa, matriz $G$, de orden $k\times n$. Tambi\'en ha de calcular 
$G^{\ast}$, matriz
generadora de c\'odigo lineal tal que no exista un algoritmo computable
que corrija los errores con \'este c\'odigo en un tiempo peque\~no; esta matriz
es obtenida a partir de la expresi\'on
\begin{center}
$G^{\ast}=S\times G\times P$
\end{center}
con $S$ una matriz aleatoria no singular de orden $k\times k$, y $P$ una matriz
de permutaciones de orden $n\times n$.
Todos los usuarios del sistema mantienen sus respectivos $G^{\ast}$ y $t$ 
p\'ublicos, mientras que las matrices $G$, $S$ y $P$ ser\'an secretas.\\
\\Supongamos que un emisor A quiere enviar un mensaje al receptor B.
Para ello, representar\'a el mensaje como un conjunto de cadenas binarias,
$m$, de longitud $k_{b}$ {\it bits}, y enviar\'a el mensaje cifrado de $n$ {\it 
bits}
\begin{center}
$c=m\times G_{b}^{*}+e$,
\end{center}
siendo $e$ un vector de longitud $n_{b}$ y peso $p_{b}\leq t_{b}$ que dificulta 
el criptoan\'alisis de un potencial atacante, por razones en las que no vamos a 
entrar.\\
\\Cuando B recibe el mensaje, ha de calcular
\begin{center}
$c\times P^{-1}=m\times S\times G\times P\times P^{-1}+e\times P^{-1} =(m\times 
S)\times G+e^{\prime}$
\end{center}
utilzando sus matrices $S$, $G$ y $P$ (que recordemos son privadas). El vector
$e^{\prime}$ se calcula como
\begin{center}
$e^{\prime}=e\times P^{-1}$
\end{center}
y tiene tambi\'en un peso inferior a $t_{b}$.\\
\\Llamando $m^{\prime} = m\times S$, el receptor B puede calcular ahora el 
mensaje original, a partir de
\begin{center}
$m=m^{\prime} \times S^{-1}$
\end{center}
(<recordemos una vez m\'as que $S$ ha de ser privada para cada usuario!).
Hay que resaltar, por \'ultimo, que aunque el criptosistema de
McEliece no ha sido completamente acogido por la comunidad criptol\'ogica,
es muy importante el estudio que desde la presentaci\'on del sistema
en 1978 se est\'a haciendo para el desarrollo de sistemas de clave
p\'ublica basados en la Teor\'{\i}a de la Codificaci\'on.
\section{Funciones resumen}
Matem\'aticamente podemos definir las funciones resumen ({\it hash functions}) 
como proyecciones de un conjunto, generalmente con un n\'umero elevado de 
elementos (incluso infinitos), sobre un conjunto de tama\~no fijo y mucho m\'as 
peque\~no que el anterior; por ejemplo, podemos definir la siguiente funci\'on 
resumen, que va de un conjunto con un n\'umero infinito de elementos a otro
con \'unicamente 10:
\begin{center}
$H(x)$ $=$ $x$ $mod$ $10$, $x \in \Re$, $H(x) \in [0,9]$
\end{center}
Sin embargo, aunque la anterior sea una funci\'on resumen en sentido estricto, 
no es especialmente interesante en aplicaciones criptogr\'aficas; para serlo, 
habr\'{\i}a de cumplir los siguientes requisitos:
\begin{itemize}
\item La entrada puede ser de un tama\~no indeterminado.
\item La salida es de un tama\~no fijo, varios \'ordenes de magnitud m\'as
peque\~no que el anterior.
\item Para un cierto $x$, calcular $H(x)$ es computacionalmente barato.
\item $H(x)$ es de un solo sentido.
\item $H(x)$ no presenta colisiones.
\end{itemize}
El que una funci\'on {\it hash} sea de un solo sentido (lo que se denomina {\it
One--Way hash function}) no implica m\'as que a partir del valor de $H(x)$
no puedo obtener el de $x$: no existe $H^{-1}(x)$, o su c\'alculo es 
computacionalmente dif\'{\i}cil. Las colisiones en una funci\'on resumen se
producen cuando para dos entradas diferentes $x$ e $y$, $H(x)=H(y)$, y se habla 
de
funciones {\it hash} d\'ebilmente libres de colisiones ({\it weakly collision
free}) cuando es 
computacionalmente imposible encontrar dos elementos $x$ e $y$ tales que 
cumplan 
$H(x)=H(y)$; si aparte de computacionalmente imposible tambi\'en lo es
matem\'atimamente, se habla de funciones resumen fuertemente libres de 
colisiones ({\it strongly collision-free}).\\
\\Una de las aplicaciones criptogr\'aficas m\'as importante de las funciones 
resumen es sin duda la verificaci\'on de integridad de archivos; aunque ya
hemos hablado de los verificadores de integridad tipo Tripwire en el 
cap\'{\i}tulo dedicado a los sistemas de detecci\'on de intrusos, la idea es
sencilla: en un sistema del que tengamos constancia que est\'a `limpio' (esto
es, que no ha sido troyanizado o modificado de cualquier forma por un pirata)
podemos generar res\'umenes de todos los ficheros que consideremos clave para
el correcto funcionamiento de la m\'aquina y guardar dichos res\'umenes --
como ya indica su nombre, mucho m\'as cortos que los archivos originales -- en
un dispositivo de s\'olo lectura como un CD-ROM. Peri\'odicamente, o cuando
sospechemos que la integridad de nuestro entorno ha sido violada, podemos volver
a generar los res\'umenes y comparar su resultado con el almacenado previamente:
si no coinciden, podemos estar seguros (o casi seguros) de que el fichero ha
sido modificado.\\
\\Para este tipo de aplicaciones se suele utilizar la funci\'on resumen {\sc
md5}, dise\~nada por Ronald Rivest y que viene implementada `de serie' en 
muchos clones de Unix, como Solaris o Linux (\'ordenes {\tt `md5'} o {\tt
`md5sum'}):
\begin{quote}
\begin{verbatim}
luisa:~$ echo "Esto es una prueba" >/tmp/salida
sluisa:~$ md5sum /tmp/salida 
3f8a62a7db3b276342d4c65dba2a5adf  /tmp/salida
luisa:~$ echo "Ahora modifico el fichero" >>/tmp/salida
luisa:~$ md5sum /tmp/salida 
1f523e767e470d8f23d4378d74817825  /tmp/salida
luisa:~$ 
\end{verbatim}
\end{quote}
Otra aplicaci\'on importante de las funciones resumen es la firma digital de
mensajes -- documentos -- y su {\it timestamping}; en el primer caso, como los 
algoritmos de firma digital suelen ser lentos, o al menos
m\'as lentos que las funciones {\it hash}, es habitual calcular la firma
digital de un resumen del fichero original, en lugar de hacer el c\'alculo 
sobre el propio fichero (evidentemente, de tama\~no mayor que su resumen). Con
respecto al {\it timestamping}, las funciones {\it hash} son \'utiles porque 
permiten publicar un resumen de un documento sin publicar su contenido, lo cual
permite a una parte obtener un {\it timestamp} de un documento sin que la
autoridad de {\it timestamp} conozca el contenido del mismo, pero asegur\'andose
la validez del procedimiento en caso de repudio; en ambos casos, tanto en la
firma digital como en el {\it timestamping}, trabajar con el resumen es 
completamente equivalente a trabajar con el archivo original.
\section{Esteganograf\'{\i}a}
La esteganograf\'{\i}a (tambi\'en llamada cifra encubierta, \cite{kn:cesid}) es 
la ciencia que estudia los procedimientos encaminados a ocultar la existencia 
de un mensaje en lugar de ocultar su contenido; mientras que la 
criptograf\'{\i}a pretende que un atacante que consigue un mensaje no sea capaz
de averiguar su contenido, el objetivo de la esteganograf\'{\i}a es ocultar ese
mensaje dentro de otro sin informaci\'on importante, de forma que el atacante
ni siquiera se entere de la existencia de dicha informaci\'on oculta. No se
trata de sustituir al cifrado convencional sino de complementarlo: ocultar un
mensaje reduce las posibilidades de que sea descubierto; no obstante, si lo es,
el que ese mensaje haya sido cifrado introduce un nivel adicional de
seguridad.\\
\\A lo largo de la historia han existido multitud de m\'etodos para ocultar
informaci\'on. Quiz\'as los m\'as conocidos hayan sido la tinta invisible, muy 
utilizada durante la Segunda Guerra Mundial, o las marcas de cualquier tipo 
sobre ciertos caracteres (desde peque\~nos pinchazos de alfiler hasta trazos a 
l\'apiz que marcan un mensaje oculto en un texto), pero otros mecanismos m\'as
`extravagantes' tambi\'en han sido utilizados: por ejemplo, afeitar la cabeza
de un mensajero y tatuar en el cuero cabelludo el mensaje, dejando despu\'es
que el crecimiento del pelo lo oculte; podemos repasar algunos modelos 
esteganogr\'aficos cuanto menos curiosos en \cite{kn:kah67}.\\
\\Con el auge de la inform\'atica, el mecanismo esteganogr\'afico m\'as 
extendido est\'a basado en las im\'agenes digitales y su excelente capacidad
para ocultar informaci\'on; aunque existen varias formas de conseguirlo 
(\cite{kn:schy94}), la m\'as b\'asica consiste simplemente en 
sustituir el {\it bit} menos significativo de cada {\it byte} por los {\it bits}
del mensaje que queremos ocultar; dado que casi todos los est\'andares
gr\'aficos tienen una graduaci\'on de colores mayor de lo que el ojo humano 
puede apreciar, la imagen no cambiar\'a su apariencia de forma notable. Otros
elementos donde ocultar informaci\'on son las se\~nales de audio y video y el 
propio texto (\cite{kn:ben96}); aunque hist\'oricamente nunca han estado tan 
extendidas como la anterior, en los \'ultimos tiempos el inter\'es por los
mecanismos de ocultaci\'on de informaci\'on en formatos de audio 
(principalmente MP3) y video ha ido en aumento. Y no es de extra\~nar: a nadie 
se le escapa que con la cantidad de protocolos {\it peer to peer} de 
intercambio de archivos ({\it e-Donkey}, {\it Morpheus}\ldots) que existen en
la actualidad, y que son usados por millones de usuarios para intercambiar 
ficheros MP3 y DIVX a trav\'es de la red, el volumen de informaci\'on que puede 
viajar camuflada en los mismos es impresionante. Esto, que a la mayor parte de
los mortales nos da un poco igual, es un \'area de gran inter\'es para las 
agencias de inteligencia de todo el mundo (muy en especial desde los 
desgraciados sucesos del once de septiembre pasado), debido al peligro que 
entra\~na el intercambio de informaci\'on discreto, r\'apido y efectivo que
puede establecerse entre miembros de redes terroristas desde cualquier punto 
del planeta, sin m\'as que un PC conectado a Internet y un programa cliente de 
cualquiera de estos protocolos.
