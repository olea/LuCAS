\chapter{Solaris}
\section{Introducci\'on}
Solaris es el nombre del actual entorno de trabajo Unix desarrollado por Sun 
Microsystems; con anterioridad esta compa\~n\'{\i}a ofrec\'{\i}a SunOS, un
sistema basado en {\sc bsd}, pero a partir de su versi\'on 5 el sistema fu\'e
completamente revisado, adopt\'o el modelo {\it System V} y se pas\'o a 
denominar Solaris, que es como se conoce 
actualmente\footnote{Realmente, existi\'o un entorno llamado Solaris 1.x, que 
no era m\'as que alguna versi\'on de SunOS 4 acompa\~nada de OpenWindows 3.0 
(\cite{kn:dik99}).}. Hasta la versi\'on 6, el producto era conocido como {\it
`Solaris 2.x'} -- equivalentemente, {\it `SunOS 5.x'} --, pero desde su 
versi\'on 7 se elimin\'o el `2.x' y simplemente se pas\'o a llamar {\it 
`Solaris x'}, aunque se sigue manteniendo el nombre {\it `SunOS 5.x'}; en la
actualidad, Sun Microsystems ofrece Solaris 8, y se espera que en 2001 aparezca
en el mercado Solaris 9.\\
\\Solaris es uno de los Unix m\'as extendidos hoy en d\'{\i}a, ya que sus
posibilidades comprenden un abanico muy amplio; aunque funciona sobre 
arquitecturas x86 (lo que permite que cualquiera pueda instalar y utilizar el 
operativo en un PC casero), el principal mercado de Solaris est\'a en las 
estaciones y los servidores {\sc sparc} ({\it Scalable Processor ARChitecture}).
Dentro de esta familia de procesadores podemos encontrar todo tipo de 
m\'aquinas, desde estaciones que pueden ser equivalentes en potencia a un PC
(como la Ultra{\sc sparc} 5) a grandes servidores (por ejemplo, los Ultra 
Enterprise 10000), 
pasando por supuesto por servidores medios, como los Ultra Enterprise 3500;
esta amplia gama de m\'aquinas hace que Solaris se utilice en todo tipo de 
aplicaciones, desde equipos de sobremesa o servidores {\it web} sencillos hasta 
sistemas de bases de datos de alta disponibilidad. Su uso como plataforma de 
aplicaciones relacionadas con la seguridad (t\'{\i}picamente, sistemas 
cortafuegos funcionando con {\it Firewall--1}) tambi\'en est\'a muy extendido.\\
\\Para conocer m\'as el entorno de trabajo Solaris podemos descargar las 
im\'agenes del operativo, tanto para arquitecturas {\sc sparc} como para x86, y
de forma completamente gratuita,
desde la {\it web} corporativa de Sun Microsystems: {\tt http://www.sun.com/}.
Tambi\'en podemos obtener documentaci\'on de casi cualquier tema relacionado 
con Solaris en la direcci\'on {\tt http://docs.sun.com/}, o consultar los
{\it BluePrints} que la compa\~n\'{\i}a publica peri\'odicamente en {\tt 
http://www.sun.com/blueprints/}. Existen adem\'as numerosas publicaciones
relacionadas con diversos aspectos de Solaris: por ejemplo, de su seguridad se 
habla en \cite{kn:gre99}, y de su dise\~no interno en \cite{kn:mau00}; sus
aspectos gen\'ericos de uso o administraci\'on se pueden consultar en cualquier 
libro de Unix, aunque en muchas ocasiones uno se pregunta si vale la pena 
realmente comprar algunos libros cuando en Internet tenemos a nuestra 
disposici\'on cientos y cientos de hojas de magn\'{\i}fica documentaci\'on sobre
Solaris.\\
\\Tal y como se instala por defecto, Solaris -- como la mayor\'{\i}a de
operativos -- no es un sistema especialmente seguro; es necesario dedicar un
m\'{\i}nimo de tiempo a retocar y personalizar algunos aspectos de su
configuraci\'on: tras estos peque\~nos detalles, un servidor puede pasar a
trabajar directamente en explotaci\'on con un nivel de seguridad m\'as que
aceptable. En este cap\'{\i}tulo vamos a hablar de aspectos de configuraci\'on,
de {\it software}, de procedimientos de trabajo\ldots aplicables en Solaris; 
aunque evidentemente los aspectos de los que hemos venido hablando durante todo
el trabajo se pueden -- y deben -- aplicar en este sistema operativo, aqu\'{\i}
entraremos algo m\'as a fondo en algunos aspectos particulares de Solaris.
\section{Seguridad f\'{\i}sica en SPARC}
Los mecanismos de seguridad de m\'as bajo nivel que ofrece Solaris sobre 
estaciones y servidores {\sc sparc} son los que estos implantan en su {\sc 
eeprom}, una memoria RAM no vol\'atil ({\it NVRAM, Non--volatile RAM}) a la que 
se puede acceder pulsando las teclas {\it `Stop--A'} (teclados Sun) o {\it 
`Ctrl--Break'} 
(terminales serie). Esta memoria, tambi\'en denominada {\it OpenBoot PROM} o 
simplemente {\sc obp} es en muchos aspectos similar a la {\sc bios} de un 
simple PC, pero mucho m\'as potente y flexible; sus funciones son verificar el 
estado del {\it hardware} e inicializarlo (ofreciendo para ello una amplica 
gama de herramientas empotradas), y por supuesto arrancar el sistema 
operativo.\\
\\Como antes hemos dicho, cualquiera con acceso f\'{\i}sico a una m\'aquina
{\sc sparc} puede interactuar con su {\sc nvram} sin m\'as que pulsar la 
combinaci\'on de teclas {\it `Stop--A'}; sin importar el estado en que se 
encuentre el sistema, autom\'aticamente se detendr\'an todos los procesos en 
ejecuci\'on y se mostrar\'a en consola el {\it prompt} {\tt `ok '}, que indica
que podemos comenzar a teclear \'ordenes de la {\sc obp}. La m\'aquina no pierde
en ning\'un momento su estado a no ser que expl\'{\i}citamente la detengamos:
al salir de la {\sc obp} podemos continuar la ejecuci\'on de todos los procesos
que ten\'{\i}amos al entrar, desde el mismo punto en que los detuvimos y con
el mismo entorno que pose\'{\i}an, pero mientras estemos interactuando con la 
{\sc eeprom} ning\'un proceso avanzar\'a en su ejecuci\'on.\\
\\Al interactuar con la {\sc eeprom}, cualquier persona\footnote{Recordemos, con
acceso f\'{\i}sico a la m\'aquina.} puede interrumpir al operativo y 
rearrancarlo desde un disco, un CD--ROM, o un sistema remoto, lo que 
evidentemente le proporciona un control total sobre el sistema; podemos 
deshabilitar la funci\'on de las teclas {\it `Stop--A'} mediante la directiva 
del {\it kernel} {\tt `abort$\_$enable'} en el fichero {\tt /etc/system}, 
o -- lo que suele ser m\'as \'util -- proteger mediante contrase\~na el reinicio
de una m\'aquina desde su memoria {\sc nvram}. Para ello, las m\'aquinas {\sc 
sparc} ofrecen tres
niveles de seguridad: {\tt `none-secure'}, {\tt `command-secure'}, y {\tt 
`full-secure'}. El primero de ellos, {\tt `none-secure'} es el que est\'a
habilitado por defecto, y como su nombre indica no ofrece ning\'un tipo de 
seguridad: cualquiera que pulse {\it `Stop--A'} desde la consola del 
sistema\footnote{Si no se ha deshabilitado en {\tt /etc/system}.}
obtiene un acceso total a la {\sc eeprom} sin necesidad de conocer ning\'un
tipo de contrase\~na y puede reiniciar la m\'aquina de la forma que le plazca.\\
\\Los dos modos siguientes son los que ofrecen un nivel de seguridad algo
superior; si activamos {\tt `command-secure'} ser\'a necesaria una clave para
reiniciar el sistema de cualquier dispositivo que no sea el utilizado por 
defecto (que generalmente ser\'a el disco, {\tt disk}), y si elegimos {\tt
`full-secure'} la contrase\~na es obligatoria independientemente del 
dispositivo elegido para arrancar. En cualquier caso, esta clave es diferente 
de la utilizada para acceder a Solaris como superusuario; si olvidamos la 
contrase\~na de la {\sc eeprom} pero tenemos acceso {\it root} a la m\'aquina
podemos usar desde l\'{\i}nea de \'ordenes el comando {\tt `eeprom'} para 
modificar (o consultar) cualquier par\'ametro de la {\sc nvram}, {\it 
passwords} incluidos. Si
hemos perdido la contrase\~na de la {\sc eeprom} y no podemos arrancar la 
m\'aquina, es muy posible que necesitemos sustituir nuestra memoria {\sc nvram}
por una nueva, por lo que hemos de tener cuidado con las claves que utilicemos
para proteger la {\sc obp}; por supuesto, si utilizamos el modo {\tt 
`full-secure'} podemos ir olvid\'andonos de reinicios programados del sistema
sin un operador que teclee el {\it password} en consola: la seguridad en muchas 
ocasiones no es del todo compatible con la comodidad o la funcionalidad.\\
\\Como hemos adelantado, para consultar o modificar el modo en el que se 
encuentra nuestra memoria {\sc nvram} podemos ejecutar la orden {\tt `eeprom'};
en nuestro caso queremos conocer el estado de la variable {\tt 
`security-mode'}, por lo que desde una l\'{\i}nea de comandos teclear\'{\i}amos
lo siguiente:
\begin{quote}
\begin{verbatim}
marta:/# eeprom security-mode
security-mode=none
marta:/# 
\end{verbatim}
\end{quote}
Podemos ver que en este caso nuestra m\'aquina no tiene habilitado ning\'un
tipo de seguridad; si quisi\'eramos habilitar el modo  {\tt `command-secure'},
ejecutar\'{\i}amos:
\begin{quote}
\begin{verbatim}
marta:/# eeprom security-mode
security-mode=none
marta:/# eeprom security-mode=command
Changing PROM password:
New password:
Retype new password:
marta:/# eeprom security-mode
security-mode=command
marta:/# 
\end{verbatim}
\end{quote}
Tambi\'en es posible realizar estos cambios desde el propio {\it prompt} de la
memoria {\sc nvram}, mediante la orden {\tt `setenv'}\footnote{Esta orden 
corresponde a la {\it OpenBoot PROM}; no hay que confundirla con el comando
del mismo nombre que poseen algunos {\it shells}.}:
\begin{quote}
\begin{verbatim}
ok setenv security-mode command
security-mode =       command
ok
\end{verbatim}
\end{quote}
A partir de este momento, cuando el sistema inicie desde un dispositivo que
no sea el utilizado por defecto, se solicitar\'a la clave que acabamos de 
teclear; de forma similar podr\'{\i}amos habilitar el modo {\tt `full-secure'}.
Para eliminar cualquier clave de nuestra memoria no tenemos m\'as que restaurar
el modo {\tt `none-secure'}, de la forma habitual:
\begin{quote}
\begin{verbatim}
marta:/# eeprom security-mode=none
marta:/# eeprom security-mode
security-mode=none
marta:/#
\end{verbatim}
\end{quote}
Si en los modos {\tt `command-secure'} o {\tt `full-secure'} queremos 
cambiar la contrase\~na de la {\sc nvram} podemos utilizar de nuevo la
orden {\tt `eeprom'}, esta vez con el par\'ametro {\tt `security-password'}:
\begin{quote}
\begin{verbatim}
marta:/# eeprom security-password=
Changing PROM password:
New password:
Retype new password:
marta:/# eeprom security-password
security-password= data not available.
marta:/# 
\end{verbatim}
\end{quote}
Como podemos ver, al consultar el valor de la variable, este {\bf nunca} se
muestra en pantalla.\\
\\El tercer y \'ultimo par\'ametro relacionado con la seguridad de la memoria 
{\sc eeprom} es {\tt \\`security-\#badlogins'}, que no es m\'as que un contador 
que indica el n\'umero de contrase\~nas incorrectas que el sistema ha recibido; 
podemos resetear su valor sencillamente asign\'andole `0'\footnote{En ciertas
versiones de SunOS -- no Solaris -- tambi\'en se pod\'{\i}a resetear este 
contador pas\'andole como par\'ametro {\tt `reset'}.}:
\begin{quote}
\begin{verbatim}
marta:/# eeprom security-#badlogins
security-#badlogins=4
marta:/# eeprom security-#badlogins=0
marta:/# eeprom security-#badlogins
security-#badlogins=0
marta:/# 
\end{verbatim}
\end{quote}
Antes de finalizar este punto quiz\'as sea necesario recordar que los 
par\'ametros de seguridad de la memoria {\sc eeprom} que acabamos de ver s\'olo
existen en m\'aquinas {\sc sparc}; aunque en la versi\'on de Solaris para
arquitecturas Intel tambi\'en existe una orden denominada {\tt `eeprom'} que nos
mostrar\'a los valores de ciertos par\'ametros si la ejecutamos, \'unicamente
se trata de una simulaci\'on llevada a cabo en un fichero de texto denominado
{\tt `bootenv.rc'}. Es posible dar valor a las variables que hemos visto, pero
no tienen ning\'un efecto en m\'aquinas Intel ya que estas se suelen proteger
en el arranque mediante contrase\~nas en la BIOS, como veremos al hablar de
Linux.
\section{Servicios de red}
Probablemente el primer aspecto relacionado con la seguridad al que debemos
prestar atenci\'on en un sistema Solaris es a los servicios ofrecidos
desde {\tt inetd}; con la instalaci\'on {\it out of the box} el n\'umero de
puertos a la escucha es realmente elevado, y muchos de ellos son servidos
desde {\tt inetd} (despu\'es hablaremos de los servicios que se inician al
arrancar el sistema). Aparte de los servicios cl\'asicos ({\tt telnet}, {\tt
finger}\ldots) que -- como en el resto de Unices -- es imprescindible 
deshabilitar, en Solaris encontramos algunas entradas de {\tt /etc/inetd.conf}
algo m\'as extra\~nas, que en muchos casos no sabemos si podemos eliminar (o
comentar) si que ello afecte al funcionamiento de la m\'aquina: se trata de
ciertos servicios basados en {\sc rpc}, como {\tt cmsd} o {\tt sprayd}. En
casi todos los servidores podemos deshabilitar estos servicios sin mayores
problemas, pero evidentemente tomando ciertas precauciones: es necesario conocer
cu\'al es la funci\'on y las implicaciones de seguridad de cada uno de ellos;
en \cite{kn:fly00b} (especialmente en la segunda parte del art\'{\i}culo) se 
puede encontrar una referencia r\'apida de la funci\'on de algunos de estos 
servicios `extra\~nos', as\'{\i} como notas con respecto a su seguridad.\\
\\Realmente, de todos
los servicios ofrecidos por {\tt inetd} {\bf ninguno} es estrictamente 
necesario, aunque por supuesto alguno de ellos nos puede resultar muy \'util:
lo normal es que al menos {\tt telnet} y {\tt ftp} se dejen abiertos para 
efectuar administraci\'on remota. No obstante, algo muy recomendable es 
sustituir ambos por {\sc ssh}, que permite tanto la terminal remota como la 
transferencia de archivos de forma cifrada; si nos limitamos a este servicio y
lo ofrecemos desde {\tt inetd}, esta ser\'a la \'unica entrada no comentada
en {\tt /etc/inetd.conf}:
\begin{quote}
\begin{verbatim}
anita:/# grep -v ^\# /etc/inetd.conf
ssh     stream  tcp     nowait  root    /usr/local/sbin/sshd    sshd -i
anita:/# 
\end{verbatim}
\end{quote}
Otros de los servicios que Solaris ofrece tras su instalaci\'on son servidos
por demonios in\-de\-pen\-dien\-tes que se lanzan en el arranque del sistema 
desde {\it scripts} situados en {\tt /etc/init.d/} y enlazados desde {\tt 
/etc/rc2.d/} y {\tt /etc/rc3.d/}; al igual que suced\'{\i}a con los servidos 
desde {\tt inetd}, muchos de estos servicios no son necesarios 
para un correcto funcionamiento del sistema, y algunos de ellos 
hist\'oricamente han presentado -- y siguen presentando -- graves problemas de 
seguridad. No vamos a entrar aqu\'{\i} en cu\'ales de estos servicios son
necesarios y cu\'ales no, ya que eso depende por completo del tipo de sistema
sobre el que estemos trabajando; es necesario conocer las implicaciones de
seguridad que algunos de los demonios lanzados en el arranque presentan, y para 
ello una buena introducci\'on es \cite{kn:fly00a}.\\
\\Al arrancar una m\'aquina Solaris, por defecto el proceso {\tt init} situa al
sistema en su {\it runlevel} 3, lo cual implica que -- entre otras acciones -- 
se invoca a {\tt /sbin/rc2} y {\tt /sbin/rc3}; estos dos {\it shellscripts} se
encargan de recorrer los directorios {\tt /etc/rc2.d/} y {\tt /etc/rc3.d/}, 
ejecutando cualquier fichero cuyo nombre comience por {\tt `S'}. De esta forma,
para evitar que un determinado {\it script} se ejecute autom\'aticamente al
arrancar una m\'aquina lo m\'as recomendable es ir directamente a {\tt 
/etc/rc2.d/} o {\tt /etc/rc3.d/} y sustituir la {\tt `S'} inicial de su nombre
por otro car\'acter; esta pr\'actica suele ser m\'as habitual que eliminar el
fichero directamente, ya que as\'{\i} conseguimos que si es necesario lanzar
de nuevo el {\it script} al arrancar Solaris no tengamos m\'as que cambiarle de
nuevo el nombre. Por ejemplo, si queremos que el demonio {\tt sendmail} no se 
lance en el arranque, no tenemos m\'as que ir al directorio correspondiente y
renombrar el {\it script} que lo invoca; aparte de eso, es probable que nos 
interese detenerlo en ese momento, sin esperar al pr\'oximo reinicio del 
sistema:
\begin{quote}
\begin{verbatim}
anita:/# cd /etc/rc2.d/
anita:/etc/rc2.d# mv S88sendmail disabled.S88sendmail
anita:/etc/rc2.d# ./disabled.S88sendmail stop
anita:/etc/rc2.d# 
\end{verbatim}
\end{quote}
Podemos ver que para detener el demonio hemos invocado al mismo fichero que
lo arranca, pero pas\'andole como par\'ametro {\tt `stop'}; si quisi\'eramos
relanzar {\tt sendmail}, no tendr\'{\i}amos m\'as que volver a ejecutar el
{\it script} pero pas\'andole como argumento {\tt `start'}.
\section{Usuarios y accesos al sistema}
Durante la instalaci\'on de Solaris se crean en {\tt /etc/passwd} una serie de
entradas correspondientes a usuarios considerados `del sistema' ({\tt adm}, {\tt
bin}, {\tt nobody}\ldots); {\bf ninguno} de estos usuarios tiene por qu\'e 
acceder a la m\'aquina, de forma que una buena pol\'{\i}tica es bloquear sus 
cuentas. Podemos comprobar qu\'e usuarios tienen el acceso bloqueado consultando
el estado de su contrase\~na: si es {\sc `lk'} ({\it locked}), la cuenta est\'a
bloqueada:
\begin{quote}
\begin{verbatim}
anita:/# passwd -s -a|grep LK
daemon  LK    
bin  LK    
sys  LK    
adm  LK    
lp  LK    
uucp  LK    
nuucp  LK    
listen  LK    
nobody  LK    
noaccess  LK    
nobody4  LK    
anita:/# 
\end{verbatim}
\end{quote}
Podemos bloquear una cuenta de acceso a la m\'aquina mediante {\tt `passwd -l'},
de la forma siguiente:
\begin{quote}
\begin{verbatim}
anita:/# passwd -s  toni
toni  PS    06/15/01    7  7  
anita:/# passwd -l toni
anita:/# passwd -s  toni
toni  LK    06/27/01    7  7  
anita:/# 
\end{verbatim}
\end{quote}
A pesar de su estado, las cuentas bloqueadas son accesibles si ejecutamos la
orden {\tt `su'} como ad\-mi\-nis\-tra\-do\-res, por lo que si estamos bastante 
preocupados por
nuestra seguridad podemos asignarles un {\it shell} que no permita la 
ejecuci\'on de \'ordenes, como {\tt /bin/false}\footnote{Por supuesto, teniendo 
en cuenta que si alguien es {\tt root} no va a tener problemas para convertirse
en otro usuario, sin importar el {\it shell} que este \'ultimo tenga.}:
\begin{quote}
\begin{verbatim}
anita:/# su - adm
$ id
uid=4(adm) gid=4(adm)
$ ^d
anita:/# passwd -e adm
Old shell: /bin/sh
New shell: /bin/false
anita:/# su - adm
anita:/# id
uid=0(root) gid=1(other)
anita:/# 
\end{verbatim}
\end{quote}
Si realmente somos paranoicos, de la lista de usuarios que hemos visto antes 
incluso nos 
podemos permitir el lujo de eliminar a {\tt nobody4}, ya que se trata de una 
entrada que existe para proporcionar cierta compatibilidad entre Solaris y 
SunOS que actualmente apenas se usa. No obstante, much\'{\i}simo m\'as 
importante que esto es eliminar o bloquear a cualquier usuario sin contrase\~na
en el sistema; es recomendable comprobar de forma peri\'odica que estos usuarios
no existen, para lo cual tambi\'en podemos utilizar {\tt `passwd -s -a'} y
vigilar las claves cuyo estado sea {\tt `NP'} ({\it No Password}):
\begin{quote}
\begin{verbatim}
anita:/# passwd -s -a|grep NP
prueba  NP
anita:/# passwd -l prueba
anita:/# 
\end{verbatim}
\end{quote}
Tras estas medidas de seguridad iniciales, lo m\'as probable es que en 
nuestro sistema comencemos a dar de alta usuarios reales; sin duda, lo primero
que estos usuarios tratar\'an de hacer es conectar remotamente v\'{\i}a {\tt
telnet}:
\begin{quote}
\begin{verbatim}
rosita:~$ telnet anita
Trying 192.168.0.3...
Connected to anita.
Escape character is '^]'.


SunOS 5.8

login: toni
Password: 
Last login: Fri Jun 22 10:45:14 from luisa
anita:~$ 
\end{verbatim}
\end{quote}
A estas alturas ya debemos saber que es una locura utilizar {\tt telnet} para
nuestras conexiones remotas por el peligro que implica el tr\'afico de 
contrase\~nas en texto claro, por lo que debemos {\bf obligatoriamente} utilizar
{\sc ssh} o similar. Si de cualquier forma no tenemos m\'as remedio que 
permitir {\tt telnet} (no encuentro ning\'un motivo para ello, y personalmente 
dudo que los haya\ldots), quiz\'as nos interese modificar el {\it banner} de 
bienvenida al sistema, donde se muestra claramente que la m\'aquina tiene 
instalada una versi\'on concreta de Solaris: esto es algo que puede ayudar a un
pirata que busque informaci\'on de nuestro sistema. Para cambiar el mensaje
podemos crear el archivo {\tt /etc/default/telnetd}, en el que la entrada {\sc
`banner'} especifica dicho mensaje:
\begin{quote}
\begin{verbatim}
anita:/# cat /etc/default/telnetd 
BANNER="\nHP-UX anita A.09.05 E 9000/735 (ttyv4)\n\n" 
anita:/# telnet 0
Trying 0.0.0.0...
Connected to 0.
Escape character is '^]'.

HP-UX anita A.09.05 E 9000/735 (ttyv4)

login: 

\end{verbatim}
\end{quote}
Algo similar se puede hacer con el fichero {\tt /etc/default/ftpd} para el
servicio de {\sc ftp}, aunque de nuevo dudo que haya alg\'un motivo para 
mantenerlo abierto; estos mensajes evidentemente no van a evitar que alguien
pueda obtener datos sobre el sistema operativo que se ejecuta en una m\'aquina 
(veremos al hablar del sistema de red en Solaris como conseguir esto), pero al 
menos no le dejar\'an esa informaci\'on en bandeja.\\
\\Siguiendo con las conexiones remotas a un sistema, uno de los aspectos que 
nos puede llamar la atenci\'on si estamos comenzando a trabajar con Solaris es 
que el usuario {\tt root} s\'olo puede conectar desde la propia consola de la
m\'aquina; si lo intenta de forma remota, se le negar\'a el acceso:
\begin{quote}
\begin{verbatim}
luisa:~$ telnet anita
Trying 192.168.0.3...
Connected to anita.
Escape character is '^]'.

login: root
Password: 
Not on system console
Connection closed by foreign host.
luisa:~$ 
\end{verbatim}
\end{quote}
Esto es debido a que el par\'ametro {\sc
`console'} tiene como valor dicha consola ({\tt /dev/console}) en el fichero 
{\tt /etc/default/login}; para trabajar como superusuario de forma remota es
necesario acceder al sistema como un usuario sin privilegios y despu\'es 
ejecutar el comando {\tt su}. Esta forma de trabajo suele ser la m\'as 
recomendable, ya que ofrece un equilibrio aceptable entre seguridad y 
funcionalidad; no obstante, si nos interesara que {\tt root} pudiera conectar 
directamente de forma remota (no suele ser recomendable), podr\'{\i}amos 
comentar la entrada {\sc `console'} en el fichero anterior, mediante una 
almohadilla ({\tt `\#'}). Si por el contrario queremos que el administrador no 
pueda conectar al sistema
ni desde la propia consola, y s\'olo se puedan alcanzar privilegios de 
superusuario mediante la ejecuci\'on de {\tt su}, podemos dejar la entrada
correspondiente a {\sc `console'} en blanco:
\begin{quote}
\begin{verbatim}
anita:/# grep -i console /etc/default/login
# If CONSOLE is set, root can only login on that device.
CONSOLE=
anita:/#
\end{verbatim}
\end{quote}
En el fichero anterior ({\tt /etc/default/login}) existen otros par\'ametros
interesantes de cara a incrementar nuestra seguridad. Por ejemplo, el 
par\'ametro {\sc `timeout'} indica el n\'umero de segundos (entre 0 y 900) que
han de pasar desde que la m\'aquina solicita el {\it login} al conectar 
remotamente hasta que se cierra la conexi\'on si el usuario no lo teclea; esto
nos puede ayudar a evitar ciertos ataques de negaci\'on de servicio, pero puede
ser un problema si tenemos usuarios que conecten a trav\'es de l\'{\i}neas de
comunicaci\'on lentas o muy saturadas, ya que con un {\it timeout} 
excesivamente bajo es posible que antes de que el usuario vea en su terminal
el {\it banner} que le solicita su {\it login} la conexi\'on llegue a 
cerrarse.\\
\\Relacionada en cierta forma con el par\'ametro anterior, y tambi\'en dentro 
del archivo {\tt \\/etc/default/login}, la entrada {\sc `sleeptime'} permite
indicar el n\'umero de segundos -- entre 0 y 5 -- que han de transcurrir desde
que se teclea una contrase\~na err\'onea y el mensaje {\tt login incorrect}
aparece en pantalla. Con {\sc `retries'} podemos especificar el n\'umero de
intentos de entrada al sistema que se pueden producir hasta que un proceso de 
{\it login} finalice y la conexi\'on remota asociada se cierre: en otras 
palabras, indicamos el n\'umero de veces que un usuario puede equivocarse al
teclear su clave antes de que el sistema cierre su conexi\'on.\\
\\Otra directiva interesante de {\tt /etc/default/login} es {\sc `passreq'}: si
su valor es {\sc `yes'}, ning\'un usuario podr\'a conectar al sistema sin 
contrase\~na, y si es {\sc `no'}, s\'{\i} que se permiten este tipo de entradas.
Evidentemente, el valor recomendable es el primero, aunque el incremento que 
conseguimos en nuestra seguridad no es excesivo y s\'olo se puede encontrar
\'util en circunstancias muy concretas, ya que a los usuarios que no tengan
contrase\~na simplemente se les obligar\'a a elegir un {\it password} al 
intentar entrar al sistema:
\begin{quote}
\begin{verbatim}
anita:~$ telnet 0
Trying 0.0.0.0...
Connected to 0.
Escape character is '^]'.

login: prueba
Choose a new password.
New password: 
\end{verbatim}
\end{quote}
Si realmente queremos asegurarnos de que no tenemos usuarios sin clave podemos
ejecutar pe\-ri\'o\-di\-ca\-men\-te la orden {\tt `logins -p'}, que nos 
mostrar\'a los informaci\'on acerca de los usuarios sin contrase\~na en la
m\'aquina; si su salida es no vac\'{\i}a, tenemos un grave problema de 
seguridad:
\begin{quote}
\begin{verbatim}
anita:/# logins -p
prueba            107     staff           10      Usuari en proves
anita:/# passwd prueba
New password: 
Re-enter new password: 
passwd (SYSTEM): passwd successfully changed for prueba
anita:/# logins -p
anita:/# 
\end{verbatim}
\end{quote}
Para finalizar con {\tt /etc/default/login}, vamos a hablar de un par de
entradas en el fichero relacionadas con la auditor\'{\i}a de los accesos al
sistema: el par\'ametro {\sc `syslog'} con un valor {\sc `yes'} determina si se 
han de registrar mediante {\tt syslog} los accesos al sistema como {\tt root}, 
as\'{\i} como los intentos de {\it login} fallidos, y el par\'ametro {\sc
`syslog$\_$failed$\_$logins'} indica el n\'umero de intentos de entrada 
fallidos que se han de producir antes de emitir un mensaje de error; es 
recomendable que esta segunda variable tenga un valor {\tt `0'}, que implica
que {\tt syslog} registrar\'a {\bf todos} los intentos fallidos de {\it login}:
\begin{quote}
\begin{verbatim}
anita:/# grep -i ^syslog /etc/default/login 
SYSLOG=YES
SYSLOG_FAILED_LOGINS=0
anita:/# 
\end{verbatim}
\end{quote}
Otro archivo interesante de cara a incrementar aspectos de la seguridad 
relacionados con los u\-sua\-rios de nuestro sistema es {\tt
/etc/default/passwd}, donde se pueden definir par\'ametros para reforzar nuestra
pol\'{\i}tica de contrase\~nas; por ejemplo, podemos definir una longitud 
m\'{\i}nima para los {\it passwords} de los usuarios d\'andole un valor a la 
variable {\sc `passlength'}:
\begin{quote}
\begin{verbatim}
anita:/# grep -i passlength /etc/default/passwd 
PASSLENGTH=8
anita:/#
\end{verbatim}
\end{quote}
Por defecto, la longitud m\'{\i}nima de una clave es de seis caracteres; si le
asignamos a {\sc `passlength'} un valor menor (algo poco recomendable de 
cualquier forma), el sistema simplemente lo ignorar\'a y obligar\'a a los 
usuarios a utilizar {\it passwords} de seis o m\'as caracteres. Adem\'as, sea
cual sea la longitud de las claves que definamos, debemos tener siempre en
cuenta que Solaris s\'olo interpetar\'a {\bf los ocho primeros caracteres} de 
cada contrase\~na; el resto son ignorados, por lo que dos {\it passwords} cuyos
ocho primeros caracteres sean iguales ser\'an equivalentes por completo para el 
modelo de autenticaci\'on.\\
\\Una contrase\~na en Solaris debe poseer al menos dos letras (may\'usculas o
min\'usculas) y al menos un n\'umero o car\'acter especial. Tampoco debe 
coincidir con el nombre de usuario, ni con rotaciones del mismo (por ejemplo el 
usuario {\tt `antonio'} no podr\'a utilizar como clave {\tt `antonio'}, {\tt 
`ntonioa'}, {\tt `oinotna'}, etc.), y debe diferir del {\it password} 
anterior en al menos tres caracteres; para cualquiera de estos efectos 
comparativos, las letras may\'usculas y las min\'usculas son equivalentes. 
S\'olo el {\tt root} puede adjudicar contrase\~nas que no cumplan las normas
establecidas, pero a efectos de seguridad es recomendable que las claves que 
asigne tengan tantas restricciones como las que pueden escojer los usuarios (o
m\'as).\\
\\Volviendo de nuevo a {\tt /etc/default/passwd}, dentro de este archivo 
tenemos un par de entradas \'utiles para establecer una pol\'{\i}tica de 
envejecimiento de claves en nuestro sistema; se trata de {\sc `maxweeks'} y {\sc
`minweeks'}, que como sus nombres indican definen los tiempos de vida m\'aximo y
m\'{\i}nimo (en semanas) de una contrase\~na. Un tercer par\'ametro, {\sc 
`warnweeks'}, define el periodo de tiempo (de nuevo, en semanas) a partir del 
cual se avisar\'a a un usuario de que su {\it password} est\'a a punto de 
caducar; dicho aviso se produce cuando el usuario inicia una sesi\'on:
\begin{quote}
\begin{verbatim}
rosita:~$ telnet anita
Trying 192.168.0.3...
Connected to anita.
Escape character is '^]'.

login: toni
Password: 
Your password will expire in 5 days.
Last login: Sun Jun 24 03:10:49 from rosita
anita:~$ 
\end{verbatim}
\end{quote}
Como no todo va a ser hablar bien de Unix a cualquier precio (aunque Solaris 
tiene muchos aspectos para hablar bien del operativo), podemos hacer un par de
cr\'{\i}ticas a mecanismos relacionados con las contrase\~nas en Solaris. En
primer lugar, quiz\'as deja algo que desear la granularidad que nos ofrece para
el envejecimiento de claves: especificar los valores m\'aximo y m\'{\i}nimo en
semanas a veces no es apropiado, y seguramente si Solaris nos permitiera indicar
dichos valores en d\'{\i}as podr\'{\i}amos definir pol\'{\i}ticas m\'as 
precisas; aunque en la mayor\'{\i}a de ocasiones la especificaci\'on en semanas
es m\'as que suficiente, en casos concretos se echa de menos el poder indicar 
los d\'{\i}as de vigencia de una contrase\~na. Otro aspecto que se podr\'{\i}a
mejorar en Solaris es la robustez de las claves: limitarse a rotaciones del
nombre de usuario es en la actualidad algo pobre; un esquema como el ofrecido en
AIX, donde se pueden especificar incluso diccionarios externos al operativo 
contra los que comparar las claves que un usuario elige, ser\'{\i}a mucho m\'as
potente.\\
\\Contra el primero de estos comentarios quiz\'as se podr\'{\i}a decir, en 
defensa de Solaris, que realmente en {\tt /etc/shadow} podemos especificar 
d\'{\i}as en lugar de semanas, pero eso implicar\'{\i}a modificar el archivo
a mano para cada usuario, algo que no suele ser recomendable en ning\'un
sistema Unix, o bien ejecutar {\tt /usr/bin/passwd} con las opciones
apropiadas, de nuevo para todos los usuarios en cuesti\'on. Contra el segundo
tambi\'en se podr\'{\i}a argumentar que existen utilidades de terceros para 
reforzar las contrase\~nas que eligen los usuarios, o bien que no es 
dif\'{\i}cil escribir un m\'odulo de {\sc pam} para evitar que esos usuarios
elijan claves triviales, pero el hecho es que Sun Microsystems por defecto no 
incorpora ninguno de estos mecanismos en Solaris.
\section{El sistema de parcheado}
Como en el resto de Unices, en Solaris un parche se define como un grupo de
ficheros y directorios que reemplaza o actualiza ficheros y directorios 
existentes en el sistema para tratar de garantizar la ejecuci\'on correcta del
{\it software} (\cite{kn:sun98}); con la instalaci\'on de parches aumentamos -- 
al menos te\'oricamente -- la seguridad y la disponibilidad de un sistema, y 
es {\bf muy recomendable} seguir una pol\'{\i}tica de parcheado estricta, al 
menos en cuanto a parches de seguridad se refiere.\\
\\Sun Microsystems distribuye entre sus clientes con contrato de mantenimiento 
los parches para Solaris y el resto de sus productos v\'{\i}a CD-ROM cada pocas 
semanas, pero -- mucho m\'as r\'apido --, tambi\'en 
los ofrece a trav\'es de Internet, desde {\tt http://sunsolve.sun.com/}; aunque 
el acceso a ciertos parches est\'a restringido a clientes con contrato, los 
relativos a la seguridad de los sistemas y los recomendados son completamente 
p\'ublicos.\\
\\Desde Sun Microsystems, cada parche es referenciado mediante un dos n\'umeros:
un {\it `patch id'}, que es el realmente el identificador del parche, y un 
n\'umero de revisi\'on del parche, separados ambos por un gui\'on; de esta 
forma cuando descargamos un parche desde {\it SunSolve} y lo descomprimimos, o 
cuando lo recibimos en un CD-ROM, dicho parche estar\'a contenido en un 
directorio cuyo nombre es justamente esa referencia:
\begin{quote}
\begin{verbatim}
anita:/var/tmp# ls 110899-01/
README.110899-01  SUNWcsu
anita:/var/tmp# 
\end{verbatim}
\end{quote}
Dentro del directorio anterior encontraremos generalmente un fichero donde se
nos explica la u\-ti\-li\-dad del parche, los problemas que soluciona y la 
forma de
aplicarlo; adem\'as, existir\'an una serie de subdirectorios cuyos nombres son
los paquetes de {\it software} a los que ese parche afecta directamente (es
decir, de los que sustituye o actualiza directorios o archivos). Como podemos
ver, en el ejemplo anterior s\'olo encontramos uno de estos subdirectorios, {\tt
SUNWcsu}, lo que indica que el parche s\'olo afectar\'a a ficheros de ese
paquete. A su vez, dentro de cada uno de los directorios que diferencian 
paquetes {\it software} encontramos m\'as archivos y subdirectorios que
contienen realmente las versiones actualizadas de programas, as\'{\i} como 
\'ordenes post--instalaci\'on, descripci\'on del {\it software} actualizado, 
informaci\'on sobre archivos y directorios modificados, etc.\\
\\Desde Sun Microsystems se definen cinco modelos b\'asicos de parches; los {\it
standard} son parches que solucionan un problema {\it software} o {\it hardware}
espec\'{\i}fico, por lo que si ese problema no afecta a nuestros sistemas 
no tenemos por qu\'e instalarlos. Los parches {\it recommended} son aquellos que
Sun recomienda sea cual sea nuestro entorno para prevenir problemas en el 
futuro, y los {\it security} son los que resuelven problemas de seguridad; 
evidentemente ambos son de instalaci\'on casi obligatoria. Un cuarto tipo son 
los parches {\it Y2K}, que como su nombre indica son los que aseguran el
cumplimiento con el a\~no 2000 en todos los productos de Sun; a no ser que 
trabajemos con versiones de {\it software} o {\it hardware} antiguo, rara vez
tendremos que instalar uno de estos parches, ya que los productos m\'as o menos 
nuevos no han de tener problemas con el a\~no 2000. Finalmente, el quinto tipo
de parches son los {\it patch clusters}; no son realmente otro modelo, sino que
se trata de agrupaciones de los anteriores que se distribuyen en un \'unico 
archivo para descargarlos e instalarlos m\'as c\'omodamente: incluyen un {\it
script} denominado {\tt `install$\_$cluster'} que instala en el orden adecuado
todos los parches del grupo, lo que evita al administrador tener que hacerlo
uno a uno.\\
\\Para instalar un parche podemos utilizar la orden {\tt `patchadd'} en Solaris
7 o superior, o {\tt \\`installpatch'} en la versi\'on 2.6 o anteriores, en 
ambos 
casos evidentemente como {\tt root} del sistema; suele ser recomendable, en 
funci\'on del tipo de parche y su criticidad, situar a la m\'aquina en modo
monousuario antes de aplicarlo, para evitar que actividades de los usuarios
puedan interferir con el proceso de parcheado. De esta forma, si queremos
aplicar el parche anterior ({\tt 110899-01}), los pasos a seguir ser\'{\i}an los
siguientes:
\begin{quote}
\begin{verbatim}
anita:/var/tmp# who -r
   .       run-level S  Jun  8 06:37     S      0  ?
anita:/var/tmp# unzip 110899-01.zip
anita:/var/tmp# patchadd 110899-01/

Checking installed patches...
Verifying sufficient filesystem capacity (dry run method)...
Installing patch packages...

Patch number 110899-01 has been successfully installed.
See /var/sadm/patch/110899-01/log for details

Patch packages installed:
  SUNWcsu

anita:/var/tmp# 
\end{verbatim}
\end{quote}
Muchos parches necesitan un reinicio del sistema para aplicarse correctamente,
en especial aquellos que modifican alg\'un par\'ametro del n\'ucleo de Solaris;
si instalamos bloques de parches m\'as o menos grandes, como los {\it 
Maintenance Updates} o los {\it Recommended and Security}, el reinicio es casi
seguro.\\
\\Para comprobar qu\'e parches para el operativo tenemos instalados en una 
m\'aquina podemos utilizar las \'ordenes {\tt `showrev -p'} o {\tt 
`patchadd -p'}: 
\begin{quote}
\begin{verbatim}
anita:/# showrev -p |grep 110899-01
Patch: 110899-01 Obsoletes:  Requires:  Incompatibles:  Packages: SUNWcsu
anita:/# 
\end{verbatim}
\end{quote}
Es importante resaltar lo de `para el operativo', ya que estas \'ordenes no 
muestran en ning\'un caso los parches aplicados a la {\sc obp}; adem\'as, hemos
de tener presente que si un parche necesita que se reinicie el
sistema, {\tt `showrev'} nos dir\'a que est\'a instalado, pero aunque la
orden no muestre ning\'un mensaje de error, el parche no tendr\'a efecto hasta 
el siguiente reinicio de la m\'aquina. Siguiendo con nuestro ejemplo para
ver la informaci\'on que se nos muestra de cada parche, podemos ver que el 
parche que hemos instalado afecta al paquete {\tt SUNWcsu} (algo que ya 
sab\'{\i}amos), no deja obsoletas a versiones anteriores, no
necesita que est\'e aplicado otro parche para poder instalarse, y tampoco tiene
incompatibilidades.\\
\\Si por cualquier motivo deseamos eliminar del sistema un parche que hemos
instalado con an\-te\-rio\-ri\-dad podemos usar la orden {\tt `patchrm'} en 
Solaris 7 o superior, o {\tt `backoutpatch'} si utilizamos versiones m\'as 
antiguas. Esto restaurar\'a el estado que pose\'{\i}a el sistema -- en cuanto a 
ficheros y directorios -- antes de aplicar el parche:
\begin{quote}
\begin{verbatim}
anita:/# who -r
   .       run-level S  Jun  8 06:37     S      0  ?
anita:/# patchadd -p|grep 110899-01
Patch: 110899-01 Obsoletes: Requires: Incompatibles: Packages: SUNWcsu
anita:/# patchrm 110899-01

Checking installed patches...

Backing out patch 110899-01...

Patch 110899-01 has been backed out.

anita:/# patchadd -p|grep 110899-01
anita:/# 
\end{verbatim}
\end{quote}
El hecho de poder desinstalar un parche con tanta facilidad es debido a que,
si no indicamos lo contrario, cuando utilizamos {\tt `patchadd'} para a\~nadirlo
esta orden hace una copia de seguridad de los ficheros y directorios
que van a modificar o actualizar, y la guarda en {\tt /var/}; podemos utilizar
la opci\'on {\tt `-d'} del comando si no queremos esta copia se genere, pero si
lo hacemos hemos de tener presente que {\bf no} podremos desinstalar el parche
aplicado: por tanto esto s\'olo es recomendable en los casos en los que el
espacio libre en {\tt /var/} sea muy limitado y no tengamos opci\'on de 
aumentarlo (por ejemplo, ampliando el {\it filesystem} o simplemente borrando o
comprimiendo archivos).\\
\\Sun Microsystems distribuye entre sus clientes con contrato la utilidad {\it 
PatchDiag}, una herramienta realmente \'util para mantener al d\'{\i}a nuestro
nivel de parcheado (y con \'el, nuestra seguridad); la principal funci\'on de
este {\it software} es determinar el nivel de parcheado de una m\'aquina y
compararlo con la lista de parches {\it Recommended and Security} de Sun. Esta
lista contiene los parches cuya instalaci\'on es b\'asica de cara a garantizar
la seguridad o el correcto funcionamiento de los sistemas Solaris, y 
representa los parches que {\bf obligatoriamente} deben estar instalados en 
sistemas cr\'{\i}ticos, como los cortafuegos, si queremos que sean seguros.
{\it PatchDiag} {\bf no} aplica estos parches en ning\'un momento, sino que se
limita \'unicamente a indicar cu\'ales son necesarios en la m\'aquina donde se
ejecuta.
%\section{Auditor\'{\i}a BSM}
%Sun Microsystems ofrece un sistema de auditor\'{\i}a de nivel C2 
%(\cite{kn:ora}) tanto en SunOS ({\it Sunshield}) como en Solaris ({\it 
%Sunshield BSM, Basic Security Module}); b\'asicamente, este sistema permite 
%guardar un registro con
%mayor o menor nivel de detalle de las acciones de cada usuario. Esto tiene
%diferentes implicaciones con respecto al funcionamiento de la m\'aquina: por
%un lado, conseguimos una auditor\'{\i}a completa de cualquier acci\'on que se
%haya llevado a cabo en el sistema, lo que evidentemente nos puede ser muy \'util
%para incrementar nuestra seguridad, pero este incremento suele ser a costa de
%una degradaci\'on de las prestaciones de la m\'aquina; adem\'as, si queremos
%auditar con un alto nivel de detalle, los ficheros de {\it log} que se 
%generar\'an tendr\'an un tama\~no m\'as que respetable, con lo que necesitaremos
%discos lo suficientemente grandes para albergarlos.\\
%\\Para inicializar el sistema de auditor\'{\i}a {\sc bsm} en una m\'aquina 
%Solaris hemos de ejecutar el {\it shellscript} {\tt /etc/security/bsmconv}:
%\begin{quote}
%\begin{verbatim}
%proves:/# /etc/security/bsmconv
%This script is used to enable the Basic Security Module (BSM).
%Shall we continue with the conversion now? [y/n] y
%bsmconv: INFO: checking startup file.
%bsmconv: INFO: move aside /etc/rc2.d/S92volmgt.
%bsmconv: INFO: turning on audit module.
%bsmconv: INFO: initializing device allocation files.
%
%The Basic Security Module is ready.
%If there were any errors, please fix them now.
%Configure BSM by editing files located in /etc/security.
%Reboot this system now to come up with BSM enabled.
%proves:/# 
%\end{verbatim}
%\end{quote}
%Como el mensaje indica, es necesario reiniciar el sistema para que el {\sc bsm}
%comience a funcionar de forma correcta; esto es debido b\'asicamente a que el
%{\it shellscript} anterior modifica el fichero {\tt /etc/system}, que se lee
%en el arranque de la m\'aquina. Una de las l\'{\i}neas que se a\~naden en este
%archivo es la siguiente:
%\begin{quote}
%\begin{verbatim}
%set abort_enable = 0
%\end{verbatim}
%\end{quote}
%Esta entrada en {\tt /etc/system} tiene como funci\'on deshabilitar el acceso
%a la memoria {\sc eeprom} de las m\'aquinas {\sc sparc} mediante la 
%combinaci\'on de teclas {\it `Stop--A'}; aunque en algunas situaciones nos 
%puede ser \'util, por norma general -- especialmente en los sistemas ubicados
%en salas acondicionadas, de acceso restringido -- suele ser recomendable 
%permitir interactuar con la {\sc nvram} a los operadores que est\'en 
%autorizados a acceder f\'{\i}sicamente a la m\'aquina. Por tanto, una opci\'on
%que muchos administradores de sistemas eligen es eliminar esa entrada del
%fichero, o simplemente comentarla escribiendo un signo {\tt `$\ast$'} al 
%principio de la l\'{\i}nea (ojo, en {\tt /etc/system} un comentario se indica 
%mediante un {\bf asterisco}, no mediante una almohadilla como en otros muchos 
%ficheros del sistema operativo).\\
%\\Como hemos dicho, al reiniciar el sistema ya estar\'a activo el {\it BSM
%Auditing} de Solaris.
%\section{\it Accounting}
%Como en el resto de Unices, el sistema de contabilidad o {\it accounting} de
%Solaris permite obtener informaci\'on sobre el uso -- tanto individual como por
%grupos -- de los recursos de un sistema inform\'atico; esto puede ser \'util 
%para cobrar por la utilizaci\'on de dichos recursos, pero tambi\'en es muy 
%interesante su funcionalidad para incrementar la seguridad de nuestras 
%m\'aquinas detectando abusos por parte de usuarios autorizados o actividades
%sospechosas en un sistema, por poner s\'olo un par de ejemplos; conviene 
%recordar que uno de los episodios m\'as populares en el mundo de la seguridad
%fu\'e detectado por un peque\~no desajuste en el sistema de contabilidad de una 
%m\'aquina y acab\'o descubriendo una trama de {\it hacking} militar 
%impresionante (\cite{kn:sto89}).\\
%\\Para activar el {\it accounting} en una m\'aquina Solaris necesitamos en 
%primer lugar tener instalados los paquetes {\tt SUNWaccu} y {\tt SUNWaccr}:
%\begin{quote}
%\begin{verbatim}
%anita:/# pkginfo SUNWaccu SUNWaccr 
%system      SUNWaccu       System Accounting, (Usr)
%system      SUNWaccr       System Accounting, (Root)
%anita:/# 
%\end{verbatim}
%\end{quote}
%El segundo de estos paquetes de {\it software} habr\'a instalado, entre otros 
%ficheros, un archivo de\-no\-mi\-na\-do {\tt /etc/init.d/acct}, que ser\'a el 
%{\it script} que
%inicializar\'a el sistema de contabilidad en cada arranque de la m\'aquina y lo
%detendr\'a en cada parada; para conseguir esto, debemos enlazarlo con el nombre 
%adecuado para que se ejecute al entrar en el {\it runlevel} correspondiente:
%\begin{quote}
%\begin{verbatim}
%anita:/# pkgchk -l -p /etc/init.d/acct 
%Pathname: /etc/init.d/acct
%Type: editted file
%Expected mode: 0744
%Expected owner: root
%Expected group: sys
%Referenced by the following packages:
%        SUNWaccr       
%Current status: installed
%
%anita:/# ln /etc/init.d/acct /etc/rc2.d/S22acct
%anita:/# ln /etc/init.d/acct /etc/rc0.d/K22acct
%anita:/# 
%\end{verbatim}
%\end{quote}
%Las herramientas de contabilidad en Solaris se ubican en {\tt /usr/lib/acct/}; 
%en este directorio vamos a encontrar los ejecutables que nos permiten controlar
%a todo el subsistema de {\it accounting} en una m\'aquina. De todos ellos, 
%quiz\'as el principal programa sea {\tt runacct}, el procedimiento de 
%contabilidad diario que se ha de invocar generalmente desde el {\tt cron} del
%usuario {\tt adm}, por supuesto s\'olo una vez al d\'{\i}a\footnote{El propio 
%{\tt runacct} controla que no se ejecute m\'as de una vez por d\'{\i}a, 
%mediante archivos de bloqueo.}; por ejemplo, podemos invocar a esta herramienta
%cada noche a las tres de la madrugada:
%\begin{quote}
%\begin{verbatim}
%anita:/# crontab -l adm|grep runacct
%0 3 * * * /usr/lib/acct/runacct 2> /var/tmp/runacct.log
%anita:/# 
%\end{verbatim}
%\end{quote}
\section{Extensiones de la seguridad}
\subsection{\sc aset}
{\sc aset} ({\it Automated Security Enhancement Tool}) es un conjunto de 
herramientas integradas dentro de Solaris que permiten monitorizar ciertos 
valores de par\'ametros de los ficheros del sistema, desde atributos ubicados en
los inodos (permisos, propietario\ldots) hasta el contenido de cada archivo. 
Estas herramientas se encuentran en el directorio {\tt /usr/aset/}, y su
utilidad es evidente: permite detectar cualquier cambio en uno de nuestros 
ficheros, cambio que si no ha sido realizado por un usuario debidamente 
autorizado puede esconder desde un troyano hasta una puerta trasera de entrada 
al sistema.\\
\\De todas las utilidades de que dispone {\sc aset}, la m\'as importante es
sin duda {\tt /usr/aset/aset}, un {\it shellscript} encargado de invocar al
resto de herramientas. Desde l\'{\i}nea de comandos, este programa puede recibir
como par\'ametro el nivel de seguridad deseado en la comprobaci\'on: {\tt 
`low'}, que se limita a informar de las vulnerabilidades potenciales, {\tt 
`mid'}, que modifica ciertos par\'ametros que considera incorrectos, y {\tt 
`high'}, el m\'as restrictivo, que modifica m\'as a\'un dichos par\'ametros, y
que es recomendable en sistemas en los que la seguridad de Solaris sea un 
elemento por encima de cualquier otro, como el funcionamiento; incluso en la
p\'agina {\tt man} de {\tt aset} se advierte que algunas aplicaciones pueden
dejar de funcionar si utilizamos este nivel de seguridad.\\
\\Podemos invocar a {\tt /usr/aset/aset} indic\'andole mediante el par\'ametro
{\tt `-l'} el nivel de seguridad deseado:
\begin{quote}
\begin{verbatim}
anita:/# /usr/aset/aset -l low
======= ASET Execution Log =======

ASET running at security level low

Machine = anita; Current time = 0628_03:11

aset: Using /usr/aset as working directory

Executing task list ...
        firewall
        env
        sysconf
        usrgrp
        tune
        cklist
        eeprom

All tasks executed. Some background tasks may still be running.

Run /usr/aset/util/taskstat to check their status:
     /usr/aset/util/taskstat     [aset_dir]

where aset_dir is ASET's operating directory,currently=/usr/aset.

When the tasks complete, the reports can be found in:
     /usr/aset/reports/latest/*.rpt
You can view them by:
     more /usr/aset/reports/latest/*.rpt
anita:/# 
\end{verbatim}
\end{quote}
La orden anterior habr\'a generado un directorio de informes cuyo nombre hace 
referencia a la fecha y hora de ejecuci\'on, y que al ser el \'ultimo se enlaza 
tambi\'en con el nombre {\tt latest}; todos los {\it reports} generados por 
{\tt aset} tienen extensi\'on {\tt `.rpt'} (son simples ficheros {\sc ascii}), 
y se guardan en {\tt /usr/aset/reports/}. Cada uno de ellos contiene el informe 
de las potenciales 
vulnerabilidades que {\tt aset} ha encontrado durante su ejecuci\'on, as\'{\i}
como de los cambios que haya realizado en funci\'on del nivel de seguridad
especificado. Como {\tt aset} indica, el hecho de que la ejecuci\'on del comando
haya finalizado no implica que los informes se hayan realizado completamente;
podemos ejecutar {\tt /usr/aset/util/taskstat} para ver que tareas no han
finalizado a\'un.\\
\\Adem\'as de los informes de los que acabamos de hablar, la primera 
ejecuci\'on de {\tt aset} genera una serie de archivos en el directorio {\tt 
/usr/aset/master/}: en ellos se guarda una imagen del estado que la herramienta
ha encontrado en el sistema, de forma que una ejecuci\'on posterior del 
programa -- dentro del mismo nivel de seguridad -- puede comprobar qu\'e 
par\'ametros han cambiado en cada uno de los ficheros analizados; evidentemente,
es vital para nuestra seguridad evitar que un atacante pueda modificar esta
imagen, ya que de lo contrario podr\'{\i}a `enga\~nar' sin problemas a {\tt 
`aset'}. Por ejemplo,
al ejecutar {\tt `/usr/aset/aset'} con un nivel de seguridad {\tt `low'} se ha 
guardado en esa i\-ma\-gen cierta informaci\'on sobre un fichero importante 
como {\tt /etc/inittab} (en {\tt /usr/aset/asetenv} se define la lista de 
directorios de los que se guarda una imagen en cada nivel de seguridad); parte 
de esta informaci\'on se encuentra en {\tt /usr/aset/masters/cklist.low}:
\begin{quote}
\begin{verbatim}
anita:/usr/aset/masters# grep inittab cklist.low 
-rw-r--r-- 1 root sys 1087 Jan 5 23:38 2000 /etc/inittab  26732 3
anita:/usr/aset/masters# 
\end{verbatim}
\end{quote}
Podemos ver que los par\'ametros registrados de este archivo: propietario y
grupo, permisos, n\'umero de enlaces, tama\~no, fecha y hora de la \'ultima
modificaci\'on y un {\it checksum}. Si ahora un atacante decidiera modificar 
ese fichero (por ejemplo para situar un troyano en \'el) casi con total 
seguridad modificar\'{\i}a alguno de esos par\'ametros, por lo que la siguiente
ejecuci\'on de la herramienta reportar\'{\i}a este hecho:
\begin{quote}
\begin{verbatim}
anita:/# grep inittab /usr/aset/reports/latest/cklist.rpt 
< -rw-r--r-- 1 root sys 1087 Jan 5 23:38 2000 /etc/inittab  26732 3
> -rw-r--r-- 1 root sys 1237 Jun 28 19:58 2001 /etc/inittab  37235 3
anita:/# 
\end{verbatim}
\end{quote}
Quiz\'as una pr\'actica recomendable para incrementar nuestra seguridad pueda
ser planificar la ejecuci\'on de {\tt `aset'} para que se ejecute a 
intervalos peri\'odicos desde {\tt `crond'} y para que nos avise (por ejemplo,
mediante correo electr\'onico) de cualquier anomal\'{\i}a detectada en la 
m\'aquina. Si lo hacemos as\'{\i}, hemos de tener siempre presente que el nivel
{\tt `high'} prima la seguridad por encima de cualquier otra cosa, por lo que
tras una ejecuci\'on planificada de {\tt `aset'} es posible que alguna 
aplicaci\'on puntual deje de funcionar.
\subsection{\sc jass}
{\sc jass} ({\it JumpStart Architecture and Security Scripts}, tambi\'en 
conocido como {\it Solaris Security Toolkit}) es un paquete {\it software} 
formado por diferentes herramientas cuyo objetivo es facilitar y automatizar la 
creaci\'on y el mantenimiento de entornos Solaris seguros; ha sido desarrollado
por Alex Noordergraaf y Glenn Brunette, dos expertos en seguridad de Sun 
Microsystems conocidos -- especialmente el primero de ellos -- por los {\it 
BluePrints} que peri\'odicamente publican. Se puede ejecutar sobre
una m\'aquina donde previamente hemos instalado Solaris ({\it Standalone 
Mode}), o bien durante la propia instalaci\'on del operativo ({\it JumpStart
Technology Mode}): conseguimos as\'{\i} una instalaci\'on por defecto segura, 
algo que se echa de menos en casi cualquier Unix.\\
\\Probablemente la parte m\'as importante de {\sc jass} son los denominados {\it
drivers}, ficheros \'on que especifican diferentes niveles de ejecuci\'on de la 
herramienta, definiendo qu\'e {\it scripts} se han de ejecutar en cada uno 
de esos niveles y qu\'e archivos se instalar\'an como resultado de la 
ejecuci\'on. Cada uno de estos {\it drivers} est\'a ubicado en el subdirectorio
{\tt Drivers/} del programa, y tiene tres partes bien diferenciadas 
(\cite{kn:noo01}): la primera
se encarga de inicializar ciertas variables de entorno necesarias para una 
correcta ejecuci\'on del {\it driver}, la segunda de definir qu\'e ficheros se
han de modificar y qu\'e {\it scripts} se han de ejecutar, y una tercera parte
es la encargada final de llevar a cabo los cambios correspondientes.\\
\\En un sistema Solaris ya instalado podemos invocar desde l\'{\i}nea de 
\'ordenes a {\sc jass} pas\'andole como par\'ametro el {\it driver} que deseemos
ejecutar, por ejemplo {\tt secure.driver} (un {\it driver} que implementa por
s\'{\i} s\'olo todas las funcionalidades de {\sc jass}):
\begin{quote}
\begin{verbatim}
anita:/var/tmp/jass-0.3# ./jass-execute -d secure.driver -o jass.log
./jass-execute: NOTICE: Executing driver, secure.driver
./jass-execute: NOTICE: Recording output to jass.log
anita:/var/tmp/jass-0.3# 
\end{verbatim}
\end{quote}
Todos los cambios que la ejecuci\'on anterior provoca (en el ejemplo anterior
podemos verlos en el archivo {\tt `jass.log'}, o en salida est\'andar si no
utilizamos la opci\'on {\tt `-o'}) quiz\'as convierten a
nuestro sistema en uno `demasiado seguro': es posible que perdamos parte de la
funcionalidad de la que dispon\'{\i}amos, debido al elevado n\'umero de 
restricciones llevadas a cabo en el sistema; es necesario que cada administrador
revise sus necesidades y los {\it scripts} a los que va a invocar antes de
ejecutar {\sc jass}. Afortunadamente, una de las caracter\'{\i}sticas m\'as
importantes de esta herramienta es su capacidad para deshacer los cambios que
cualquiera de sus ejecuciones haya llevado a cabo:
\begin{quote}
\begin{verbatim}
anita:/var/tmp/jass-0.3# ./jass-execute -u -o jass-undo.log
./jass-execute: NOTICE: Executing driver, undo.driver
Please select a JASS run to restore through:
1.  July 06, 2001 at 03:59:40 (//var/opt/SUNWjass/run/20010706035940)
Choice?  1
./jass-execute: NOTICE: Restoring to previous run //var/opt/SUNWjass/run/\
                20010706035940
./jass-execute: NOTICE: Recording output to jass-undo.log
anita:/var/tmp/jass-0.3# 
\end{verbatim}
\end{quote}
Podemos ver que la desinstalaci\'on de los cambios llevados a cabo previamente,
mediante la opci\'on {\tt `-u'} del programa, nos pregunta qu\'e ejecuci\'on
de {\sc jass} queremos desinstalar; como s\'olo lo hab\'{\i}amos lanzado una
vez, hemos elegido {\tt `1'}, pero si ya hubi\'eramos ejecutado la herramienta
en diferentes ocasiones se nos mostrar\'{\i}an todas ellas, con lo cual siempre
podemos devolver a la m\'aquina a un estado previo a cualquier ejecuci\'on de
{\sc jass}. Esta caracter\'{\i}stica es bastante importante, ya que volvemos a
insistir en que, en funci\'on del {\it driver} al que invoquemos, el sistema
puede quedar incluso demasiado `securizado': por poner un ejemplo, la 
ejecuci\'on de {\tt secure.driver} eliminar\'{\i}a cualquier acceso est\'andar
al sistema ({\tt telnet}, {\sc ftp}, {\tt rsh}\ldots), con lo que ser\'{\i}a
necesario de disponer de una consola o de {\sc ssh} para acceder remotamente a
la m\'aquina tras la ejecuci\'on de {\sc jass}.\\
\\Como hemos dicho antes, tambi\'en es posible integrar {\sc jass} en la propia
instalaci\'on del sistema operativo Solaris; para ello hemos de basarnos en la 
arquitectura {\it JumpStart} de Sun Microsystems (\cite{kn:noo01e}), copiando 
el paquete de {\it software} en el directorio ra\'{\i}z del servidor {\it 
JumpStart} y siguiendo unos pasos simples explicados con detalle en 
\cite{kn:noo01c}. Con unas sencillas modificaciones de algunos ficheros, 
conseguiremos una instalaci\'on por defecto segura, lo que evitar\'a que el 
administrador de los sistemas tenga que ir m\'aquina a m\'aquina para realizar
el t\'{\i}pico {\it hardening} postinstalaci\'on (cerrar puertos, configurar
accesos\ldots).\\
\\La que acabamos de ver es una herramienta {\bf muy recomendable} en cualquier
sistema Solaris, ya que consigue automatizar muchas tareas que de otra forma
el administrador deber\'{\i}a realizar manualmente. Su potencia, unida a su
sencillez de uso (y `desuso'), la convierten en algo si no imprescindible 
s\'{\i} muy importante en nuestros sistemas; incomprensiblemente no se utiliza
de forma extendida, aunque es previsible que con sus nuevas versiones 
(actualmente est\'a disponible la 0.3) esto comience a cambiar pronto. Podemos
obtener informaci\'on adicional de esta herramienta en los BluePrints publicados
por Sun Microsystems y que se distribuyen, aparte de v\'{\i}a {\it web}, en el 
directorio {\tt Documentation/} de la misma: \cite{kn:noo01}, \cite{kn:noo01b},
\cite{kn:noo01c}, \cite{kn:noo01d}\ldots
\subsection{sfp{\sc db}}
La base de datos sfp{\sc db} ({\it Solaris Fingerprint Database}) es un 
servicio gratuito de Sun Microsystems que permite a los usuarios verificar la 
integridad de los archivos distribuidos con Solaris, tanto con la base del 
operativo como con productos concretos de Sun o parches; esto permite por una
parte verificar que lo que acabamos de instalar en una m\'aquina es realmente
una distribuci\'on de Solaris oficial de Sun, y por otra detectar si un 
pirata ha logrado modificar alguno de los ficheros del sistema (como {\tt
/bin/login}), t\'{\i}picamente para situar troyanos o puertas traseras en una
m\'aquina atacada: se trata de un sistema de detecci\'on de intrusos basado en
{\it host}, como veremos a la hora de hablar de IDSes.\\
\\Para lograr su objetivo, desde {\tt http://sunsolve.sun.com/} se puede 
comparar la funci\'on resumen {\sc md5} de determinados archivos que tenemos
en nuestra m\'aquina con el resumen almacenado por Sun Microsystems. Para ello
en primer lugar hemos de generar el resumen de los ficheros que deseemos 
verificar, mediante la orden {\tt md5} (instalada como parte del paquete {\tt
SUNWkeymg} o de forma independiente):
\begin{quote}
\begin{verbatim}
anita:/# pkgchk -l -p /usr/sbin/md5
Pathname: /usr/sbin/md5
Type: regular file
Expected mode: 0755
Expected owner: root
Expected group: sys
Expected file size (bytes): 24384
Expected sum(1) of contents: 12899
Expected last modification: Nov 11 20:19:48 1999
Referenced by the following packages:
        SUNWkeymg      
Current status: installed

anita:/# md5 /bin/su
MD5 (/bin/su) = 79982b7b2c7576113fa5dfe316fdbeae
anita:/# 
\end{verbatim}
\end{quote}
Una vez hecho esto, introduciremos este resumen en un formulario {\it web}, y 
se nos proporcionar\'a informaci\'on sobre el mismo; si no hay problemas, el
resultado ser\'a similar al siguiente:
\begin{quote}
\begin{verbatim}
Results of Last Search

79982b7b2c7576113fa5dfe316fdbeae - (/bin/su) - 1 match(es) 
           canonical-path: /usr/bin/su 
           package: SUNWcsu 
           version: 11.8.0,REV=2000.01.08.18.17 
           architecture: i386 
           source: Solaris 8/Intel 
\end{verbatim}
\end{quote}
Mientras que si el resumen que hemos obtenido no se corresponde con el de
ning\'un fichero de las diferentes versiones de Solaris u otro {\it software} de
Sun, se nos dar\'a el error {\it Not found in this database}. Este error de
entrada implica que en nuestra m\'aquina tenemos algo cuanto menos `extra\~no',
ya que es extremadamente raro que un archivo del sistema como {\tt /bin/su},
{\tt /bin/ps} o {\tt /bin/ls} sea modificado en un sistema. Si fuera este el
caso, y como administradores desconocemos a qu\'e puede ser debida esa 
modificaci\'on, con una alta probabilidad nos han instalado un {\it rootkit}, un
conjunto de herramientas utilizadas por los piratas principalmente para ocultar 
su presencia y garantizarse el acceso en una m\'aquina donde han conseguido 
privilegios de {\tt root}; un {\it rootkit} instala versiones troyanizadas de 
casi todos los programas que pueden ayudar en la detecci\'on del pirata, como 
{\tt `ls'} o {\tt `netstat'}, lo que provoca que si no ponemos un m\'{\i}nimo
de inter\'es sea muy dif\'{\i}cil detectar la intrusi\'on.\\
\\Existen adem\'as ciertas extensiones a la sfp{\sc db} cuyo objetivo es 
facilitar el uso de la base de datos \cite{kn:vas01}; una de ellas es sfp{\sc 
c} ({\it Solaris Fingerprint Database Companion}), que automatiza el proceso de 
generar y verificar los res\'umenes {\sc md5} de un n\'umero considerable de 
archivos mediante un {\it script} en {\sc perl} (recordemos que un simple 
interfaz {\it
web} que invoca a un {\sc cgi} no es apropiado para todas las aplicaciones, por
lo que Sun Microsystems est\'a estudiando la posibilidad de publicar de otra
forma el contenido completo de la base de datos). Para conseguirlo, sfp{\sc c} 
acepta como entrada un fichero que contiene una lista de res\'umenes, 
dividi\'endola en diferentes partes para enviarlas por separado a la sfp{\sc 
db}, y generando resultados globales en funci\'on de cada uno de los resultados
individuales obtenidos.\\
\\Otra de estas herramientas es sfp{\sc s} ({\it Solaris Fingerprint Database
Sidekick}), un sencillo {\it shellscript} que funciona en conjunci\'on con la
propia sfp{\sc db} y con sfp{\sc c} y cuyo objetivo es simplificar la 
detecci\'on de troyanos; para ello, almacena una lista de ejecutables 
com\'unmente troyanizados por cualquier {\it rootkit}, y es el contenido de 
dicha lista el que se compara contra la base de datos mediante el {\it script}
en {\sc perl} de sfp{\sc c}.\\
\\Evidentemente esta base de datos de Sun Microsystems y sus utilidades 
asociadas (que podemos descargar libremente desde las p\'aginas {\it web} de
esta compa\~n\'{\i}a), como cualquier otro producto a la hora
de hablar de seguridad, no es la panacea, sino s\'olo una herramienta m\'as que
nos puede ayudar a detectar intrusiones en una m\'aquina. Tambi\'en tiene
puntos d\'ebiles, ya que por ejemplo un atacante que sea capaz de modificar
ciertas utilidades del sistema podr\'a hacer lo mismo con el ejecutable {\tt
`md5'}, de forma que simule generar resultados similares a los originales 
cuando verificamos la integridad de utilidades troyanizadas; contra esto, una
soluci\'on efectiva puede ser utilizar un {\tt `md5'} est\'atico y guardado en
una unidad de s\'olo lectura, y por supuesto generado a partir de fuentes
confiables. Sin ser una herramienta excluyente, mediantes consultas 
automatizadas a la base de datos proporcionada por Sun Microsystems tenemos la
posibilidad de descubrir intrusiones graves en nuestros sistemas en un tiempo
m\'{\i}nimo, y de forma sencilla.
\section{El subsistema de red}
Antes de hablar de la seguridad del subsistema de red en Solaris quiz\'as sea
necesario introducir el comando {\tt `ndd'}; esta orden permite tanto consultar
(mediante el s\'{\i}mbolo {\tt `?'}) como modificar la configuraci\'on de 
ciertos {\it drivers} del sistema, en concreto los que soportan la pila de 
protocolos {\sc tcp/ip}:
\begin{quote}
\begin{verbatim}
anita:/# ndd -get /dev/tcp tcp_strong_iss 
1
anita:/# ndd -set /dev/tcp tcp_strong_iss 2
anita:/# ndd -get /dev/tcp tcp_strong_iss 
2
anita:/#
\end{verbatim}
\end{quote}
Si quisi\'eramos comprobar qu\'e par\'ametros ofrece un determinado {\it 
driver} (por ejemplo {\tt /dev/tcp}), lo har\'{\i}amos con la orden siguiente:
\begin{quote}
\begin{verbatim}
anita:/# ndd -get /dev/tcp \?
\end{verbatim}
\end{quote}
El uso del car\'acter {\tt `$\backslash$'} no es m\'as que un escape del {\it
shell} para el s\'{\i}mbolo {\tt `?'}. es importante conocer qu\'e par\'ametros
ofrece cada {\it driver} de nuestro sistema antes de planificar una 
modificaci\'on de sus valores, especialmente en Solaris 8, versi\'on en la que
ha cambiado ligeramente el nombre de alguno de ellos y adem\'as se han incluido
algunos nuevos relativos a IPv6 (que no mostramos aqu\'{\i}).\\
\\Los primeros par\'ametros que nos interesar\'a modificar para incrementar
la seguridad de nuestro sistema pueden ser los relacionados con el {\it 
forwarding}, el reenv\'{\i}o de paquetes de cierto tipo que llegan a la 
m\'aquina. En primer lugar, es importante evitar que nuestro equipo se convierta
en un enrutador; aunque en algunas versiones de Solaris es suficiente con 
crear el fichero {\tt /etc/notrouter}, lo m\'as recomendable es deshabilitar por
completo el {\it IP Forwarding} a nivel del subsistema de red, lo cual se 
consigue mediante la siguiente orden:
\begin{quote}
\begin{verbatim}
anita:/# ndd -set /dev/ip ip_forwarding 0
anita:/# 
\end{verbatim}
\end{quote}
Tambi\'en es importante evitar que en {\it hosts} con m\'ultiples tarjetas se
reenv\'{\i}en tramas entre ellas; con esto conseguimos hacer m\'as dif\'{\i}cil 
un ataque de {\it IP Spoofing}, ya que el sistema conoce en todo momento a 
trav\'es de que interfaz le llega un paquete, y si lo hace por una que no le
corresponde, la trama se ignora. Para lograr este objetivo podemos modificar el
valor del par\'ametro {\tt ip$\_$strict$\_$dst$\_$multihoming}:
\begin{quote}
\begin{verbatim}
anita:/# ndd -set /dev/ip ip_strict_dst_multihoming 1
anita:/#
\end{verbatim}
\end{quote}
Los \'ultimos par\'ametros relacionados con el reenv\'{\i}o de tramas en la
m\'aquina afectan a los {\it broadcasts} y a los paquetes {\it source routed}
(aquellos que contienen en su interior el camino a seguir, total o 
parcialmente, hasta su destino). Por supuesto, no es recomendable el {\it 
forwarding} de {\it broadcasts} dirigidos desde una estaci\'on fuera de una red
hacia todos los equipos de esa red, algo que una m\'aquina Solaris con el {\it
IP Forwarding} activado hace por defecto; de la misma forma, no se deben 
reenviar tramas que marquen el camino a su destino, ya que en la mayor parte de
redes no existen motivos v\'alidos para la emisi\'on de este tipo de paquetes,
y muchos de ellos son denotativos de actividades sospechosas. Podemos evitar
ambos reenv\'{\i}os mediante las siguientes \'ordenes respectivamente:
\begin{quote}
\begin{verbatim}
anita:/# ndd -set /dev/ip ip_forward_directed_broadcasts 0
anita:/# ndd -set /dev/ip ip_forward_src_routed 0
anita:/#
\end{verbatim}
\end{quote}
Otros par\'ametros a tener en cuenta para incrementar nuestro nivel de 
seguridad son algunos relativos a ataques contra el protocolo {\sc arp}; para
prevenir el {\it ARP Spoofing} es recomendable reducir el {\it timeout} que 
Solaris presenta por defecto y que marca la frecuencia de borrado de las 
entradas de la tabla {\sc arp} y de la tabla de rutado, fijando ambas en un 
minuto. Esto lo conseguimos mediante las \'ordenes siguientes (en las que 
especificamos el tiempo en milisegundos):
\begin{quote}
\begin{verbatim}
anita:/# ndd -get /dev/arp arp_cleanup_interval 60000
anita:/# ndd -get /dev/ip ip_ire_flush_interval 60000
anita:/# 
\end{verbatim}
\end{quote}
Dentro del protocolo {\sc icmp} tambi\'en existen par\'ametros del subsistema de
red interesantes para nuestra seguridad; un grupo de ellos son los relacionados
con los diferentes tipos de tramas {\sc icmp} que pueden implicar un {\it 
broadcast}: {\sc icmp$\_$echo$\_$request}, {\sc icmp$\_$timestamp} e {\sc 
icmp$\_$address$\_$mask}. Todos ellos pueden ser utilizados para causar 
negaciones de servicio, por lo que una buena idea en la mayor parte de 
situaciones es simplemente ignorarlos; incluso en el segundo caso ({\sc 
icmp$\_$timestamp}) Solaris ofrece la posibilidad de ignorar las tramas de este
tipo aunque no sean {\it broadcasts}, simplemente paquetes dirigidos a un {\it
host} deterinado, ya que pueden proporcionar informaci\'on del sistema \'util
de cara a un ataque. Para conseguir ignorar todas estas tramas podemos ejecutar 
estas \'ordenes:
\begin{quote}
\begin{verbatim}
anita:/# ndd -get /dev/ip ip_respond_to_echo_broadcast 0
anita:/# ndd -get /dev/ip ip_respond_to_timestamp_broadcast 0
anita:/# ndd -get /dev/ip ip_respond_to_address_mask_broadcast 0
anita:/# ndd -get /dev/ip ip_respond_to_timestamp 0
anita:/#
\end{verbatim}
\end{quote}
Todav\'{\i}a dentro del protocolo {\sc icmp}, otro tipo de mensajes que nos
pueden causar problemas son los {\sc icmp$\_$redirect}; es conveniente 
deshabilitar tanto su emisi\'on ({\bf s\'olo} un {\it router} tiene la necesidad
de enviar este tipo de tramas) como su recepci\'on, ya que pueden ser 
utilizados para generar rutas falsas en el subsistema de red de una m\'aquina.
Para lograr ambas cosas podemos ejecutar las siguientes \'ordenes:
\begin{quote}
\begin{verbatim}
anita:/# ndd -get /dev/ip ip_ignore_redirects 1
anita:/# ndd -get /dev/ip ip_send_redirects 0
anita:/#
\end{verbatim}
\end{quote}
La generaci\'on de los n\'umeros iniciales de secuencia {\sc tcp} es otro
par\'ametro que seguramente nos interesar\'a modificar en un sistema
Solaris; por defecto esta generaci\'on se basa en incrementos pseudoaleatorios,
lo que puede facilitar ataques de {\it IP Spoofing} contra el sistema. Podemos
aumentar nuestro nivel de seguridad utilizando un esquema de generaci\'on m\'as
robusto, basado en \cite{kn:rfc1498}, simplemente modificando el fichero {\tt
/etc/default/inetinit} para asignarle al par\'ametro {\sc tcp$\_$strong$\_$iss}
un valor de 2:
\begin{quote}
\begin{verbatim}
anita:/# cat /etc/default/inetinit
# @(#)inetinit.dfl 1.2 97/05/08
#
# TCP_STRONG_ISS sets the TCP initial sequence number generation parameters.
# Set TCP_STRONG_ISS to be:
#     0 = Old-fashioned sequential initial sequence number generation.
#     1 = Improved sequential generation, with random variance in increment.
#     2 = RFC 1948 sequence number generation, unique-per-connection-ID.
#
TCP_STRONG_ISS=2
anita:/#
\end{verbatim}
\end{quote}
Al contrario de lo que sucede con {\tt ndd}, cuyos cambios se pierden al 
reiniciar el sistema y hay que planificar en el arranque si necesitamos hacerlos
permanentes, la modificaci\'on del fichero anterior no tendr\'a efecto hasta 
que el sistema vuelva a arrancar; si no queremos detener la m\'aquina, podemos 
conseguir lo mismo mediante la orden {\tt `ndd'} sobre el n\'ucleo en 
ejecuci\'on:
\begin{quote}
\begin{verbatim}
anita:/# ndd -set /dev/tcp tcp_strong_iss 2
anita:/# 
\end{verbatim}
\end{quote}
Tambi\'en mediante {\tt ndd} podemos modificar en Solaris las restricciones 
relativas a los puertos reservados (aquellos que s\'olo el {\tt root} puede 
utilizar, por defecto los que est\'an por debajo del 1024). En primer lugar,
podemos definir el m\'{\i}nimo puerto no reservado, para que las conexiones al
sistema o los procesos de usuario puedan utilizar s\'olo los que est\'an por
encima de \'el; si por ejemplo queremos que el rango de puertos reservados 
comprenda a todos los que est\'an por debajo del 5000 podemos ejecutar la orden
siguiente:
\begin{quote}
\begin{verbatim}
anita:/# ndd -set /dev/tcp tcp_smallest_nonpriv_port 5000
anita:/#
\end{verbatim}
\end{quote}
Adem\'as, desde su versi\'on 2.6 Solaris permite marcar puertos individuales
como reservados, tanto {\sc udp} como {\sc tcp}, y tambi\'en eliminar esta 
restricci\'on de puertos que previamente hayamos reservado; por defecto, aparte
de los primeros 1024 puertos, Solaris define como reservados -- en {\sc tcp} y
{\sc udp} -- los puertos 2049 ({\tt nfsd}) y 4045 ({\tt lockd}). En el siguiente
ejemplo se muestra c\'omo consultar los puertos marcados de esta forma, c\'omo 
a\~nadir un alguno a la lista, y c\'omo eliminarlo de la misma; aunque el 
ejemplo se aplica a {\sc tcp}, el caso de {\sc udp} es completamente an\'alogo 
pero sustituyendo el nombre del dispositivo contra el que ejecutamos la orden 
(que ser\'{\i}a {\tt /dev/udp}) y la cadena {\tt `tcp'} del nombre de cada 
par\'ametro por {\tt `udp'}:
\begin{quote}
\begin{verbatim}
anita:/# ndd /dev/tcp tcp_extra_priv_ports
2049
4045
anita:/# ndd -set /dev/tcp tcp_extra_priv_ports_add 5000
anita:/# ndd /dev/tcp tcp_extra_priv_ports
2049
4045
5000
anita:/# ndd -set /dev/tcp tcp_extra_priv_ports_del 5000
anita:/# ndd /dev/tcp tcp_extra_priv_ports
2049
4045
anita:/#
\end{verbatim}
\end{quote}
Antes de finalizar este punto es importante insistir en que los cambios 
producidos 
por {\tt `ndd'} s\'olo se mantienen hasta el siguiente reinicio del sistema; 
de esta forma, las modificaciones que hemos visto aqu\'{\i} se mantendr\'an 
s\'olo mientras la m\'aquina no se pare, pero si esto sucede en el arranque 
todos los par\'ametros del subsistema de red tomar\'an sus valores por defecto.
Por tanto, lo m\'as probable es que nos interese planificar en el inicio del
sistema las modificaciones estudiadas en este punto para que se ejecuten de
forma autom\'atica; para conseguirlo, no tenemos m\'as que crear el {\it 
script} correspondiente y ubicarlo en el directorio {\tt /etc/rc2.d/} con un
nombre que comience por {\tt `S'}, con lo que hacemos que se ejecute siempre que
la m\'aquina entre en un {\it runlevel} 2:
\begin{quote}
\begin{verbatim}
anita:~# cat /etc/init.d/nddconf
#!/sbin/sh
#
# Configuracion segura del subsistema de red de Solaris
#
ndd -set /dev/ip ip_forwarding 0
ndd -set /dev/ip ip_strict_dst_multihoming 1
ndd -set /dev/ip ip_forward_directed_broadcasts 0
ndd -set /dev/ip ip_forward_src_routed 0
ndd -get /dev/arp arp_cleanup_interval 60000
ndd -get /dev/ip ip_ire_flush_interval 60000
ndd -get /dev/ip ip_respond_to_echo_broadcast 0
ndd -get /dev/ip ip_respond_to_timestamp_broadcast 0
ndd -get /dev/ip ip_respond_to_address_mask_broadcast 0
ndd -get /dev/ip ip_respond_to_timestamp 0
ndd -get /dev/ip ip_ignore_redirects 1
ndd -get /dev/ip ip_send_redirects 0
ndd -set /dev/tcp tcp_strong_iss 2
#
anita:~# chmod 744 /etc/init.d/nddconf
anita:~# chown root:sys /etc/init.d/nddconf
anita:~# ln /etc/init.d/nddconf /etc/rc2.d/S70nddconf
anita:~# 
\end{verbatim}
\end{quote}
Si queremos conocer mejor la configuraci\'on de seguridad del subsistema de
red de Solaris una {\bf excelente} obra que no deber\'{\i}a faltar en la mesa
de ning\'un administrador de sistemas es \cite{kn:noo99}; todo este punto est\'a
basado ampliamente en ella. Incluye, adem\'as de explicaciones claras sobre 
el porqu\'e del valor de cada par\'ametro para prevenir posibles ataques, un
{\it shellscript} para planificar en el inicio del sistema, much\'{\i}simo m\'as
completo que el presentado aqu\'{\i}, y aplicable a varias versiones de Solaris
(incluyendo la 8); en sistemas en los que la seguridad es un factor a tener en
cuenta (>todos?) es casi obligatorio utilizar esta planificaci\'on.
%\\Otro uso interesante de {\tt `ndd'} es evitar la identificaci\'on remota del
%sistema operativo (lo que se conoce como {\it OS Fingerprinting}) que se 
%ejecuta en nuestras m\'aquinas: al contrario de lo que
%mucha gente cree, es posible -- y sencillo -- `enga\~nar' a una herramienta de
%detecci\'on remota (por ejemplo, {\tt `nmap'}) para que a un atacante le sea
%m\'as dif\'{\i}cil obtener el sistema operativo instalado en una m\'aquina. Para
%ello no tenemos m\'as que mo\-di\-fi\-car ciertos par\'ametros de nuestro 
%subsistema de red, de forma que la herramienta que utilice el pirata para 
%detectar nuestro sistema no sepa discernir de cual se trata; por ejemplo
\section{Par\'ametros del n\'ucleo}
En el archivo {\tt /etc/system} el administrador de un equipo Solaris puede 
definir variables
para el n\'ucleo del sistema operativo, como el n\'umero m\'aximo de ficheros
abiertos por un proceso o el uso de memoria compartida, sem\'aforos y mensajes
para intercomunicaci\'on entre procesos. En este apartado vamos a comentar 
algunos de estos par\'ametros que pueden afectar a la seguridad; hablaremos 
especialmente de aquellos que pueden y deben ser limitados para evitar diversos 
tipos de negaciones de servicio, ataques que recordemos afectan a la 
disponibilidad de nuestros recursos.\\ 
\\Si deseamos ver el valor de alguno de los par\'ametros en el {\it kernel} que 
se est\'a ejecutando en este momento, lo podemos hacer con la orden {\tt adb} 
(n\'otese que no ofrece ning\'un {\it prompt}, hemos de escribir directamente 
el par\'ametro a visualizar, con un {\tt `/D'} al final para que nos muestre el
valor en decimal):
\tt 
\begin{quote}
\begin{verbatim}
anita:~# adb -k /dev/ksyms /dev/mem
physmem 38da
maxusers/D
maxusers:
maxusers:       56
maxuprc/D
maxuprc:
maxuprc:        901
^d
anita:~# 
\end{verbatim}
\end{quote}
\rm
Una negaci\'on de servicio muy t\'{\i}pica en Unix es el consumo excesivo de
recursos por parte de usuarios que lanzan -- voluntaria o involuntariamente --
demasiados procesos; esto es especialmente com\'un en sistemas de I+D, donde
muchos usuarios se dedican a programar, y un peque\~no error en el c\'odigo 
(a veces denominado {\it `runaway fork'}) puede hacer que el sistema se vea 
parado por un exceso de procesos activos en
la tabla. La gravedad del problema aumenta si pensamos que tambi\'en es muy
habitual que los usuarios lancen simulaciones que tardan en ejecutarse varios 
d\'{\i}as (o varias semanas), de forma que una parada inesperada puede causar
la p\'erdida de muchas horas de trabajo. Por tanto, parece obvio que es 
recomendable limitar el n\'umero de procesos simult\'aneos por usuario; en 
Solaris este n\'umero est\'a ilimitado por defecto, por lo que si deseamos 
asignar un valor m\'aximo hemos de editar el fichero {\tt /etc/system} e 
incluir una l\'{\i}nea como la siguiente:
\tt
\begin{quote}
\begin{verbatim}
set maxuprc=60
\end{verbatim}
\end{quote}
\rm
De esta forma limitamos el n\'umero de procesos por usuario a 60 (un n\'umero
aceptable en la mayor\'{\i}a de sistemas\footnote{Aunque en algunos documentos
se recomienda, para otros Unices, un n\'umero m\'aximo de 200 procesos 
(\cite{kn:ciu99}).}), consiguiendo as\'{\i} que un error
en un programa no sea capaz de detener la m\'aquina.\\ 
\\Un par\'ametro del sistema operativo especialmente importante, y que quiz\'as
nos interese modificar (sobre todo en m\'aquinas con pocos recursos) es {\tt 
maxusers}. Al contrario de lo que mucha gente cree, {\tt maxusers} no hace 
referencia al n\'umero m\'aximo de usuarios que pueden conectar 
simult\'aneamente al sistema, sino que es un valor que escala a otros 
par\'ametros del 
n\'ucleo (como {\tt max$\_$nproc}, n\'umero m\'aximo de procesos en la tabla) o 
{\tt maxuprc}. Para modificarlo, podemos incluir en {\tt /etc/system} una 
l\'{\i}nea con el valor deseado, generalmente el tama\~no en MB de la memoria
f\'{\i}sica de nuestra m\'aquina (\cite{kn:dik99}):
\tt
\begin{quote}
\begin{verbatim}
set maxusers=128
\end{verbatim}
\end{quote}
\rm
Tambi\'en puede ser conveniente limitar par\'ametros del sistema operativo 
relativos al sistema de ficheros, ya que tambi\'en se pueden producir 
negaciones de servicio relacionadas con ellos. Por ejemplo, es interesante
poder limitar el n\'umero m\'aximo de ficheros abiertos mediante los 
par\'ametros {\tt rlim$\_$fd$\_$max} (l\'{\i}mite {\it hard}) y {\tt 
rlim$\_$fd$\_$cur} (l\'{\i}mite {\it soft}) o evitar que los usuarios puedan
utilizar {\tt chown()} en sus ficheros, especificando un valor 1 para la 
variable {\tt rstchown} (este es el comportamiento por defecto; si no lo 
seguimos, aparte de comprometer la seguridad los usuarios sin privilegios 
podr\'{\i}an ignorar el sistema de {\it quotas}).\\
\\Dejando ya de lado los l\'{\i}mites que se pueden imponer a los recursos
consumidos por los usuarios del sistema, existe otra serie de par\'ametros del
n\'ucleo interesantes para aumentar la seguridad de un sistema Solaris. Por 
ejemplo, en algunas arquitecturas SPARC (concretamente en {\tt sun4u}, {\tt 
sun4d} y {\tt sun4m}) es posible, desde Solaris 2.6, establecer una 
protecci\'on {\it hardware} para prevenir ataques de {\it buffer overflow}.
Esta protecci\'on consiste en impedir que los programas puedan ejecutar 
c\'odigo en su pila, recibiendo la se\~nal {\sc sigsegv} si tratan de hacerlo:
para ello, en {\tt /etc/system} hemos de incluir una l\'{\i}nea como
\begin{quote}
\begin{verbatim}
set noexec_user_stack=1 
\end{verbatim}
\end{quote}
Y si adem\'as queremos monitorizar los intentos de ataque de este tipo (como
mensajes del n\'ucleo de Solaris, con {\it priority} {\tt `kern'} y nivel {\tt
`notice'}, por defecto en {\tt /var/adm/messages}), podemos incluir en el 
archivo la l\'{\i}nea 
\begin{quote}
\begin{verbatim}
set noexec_user_stack_log=1
\end{verbatim}
\end{quote}
Si administramos un servidor {\sc nfs} y deseamos que ignore las peticiones de 
clientes que no 
provengan de puertos privilegiados (es decir, que no hayan sido solicitadas por
un usuario privilegiado de la m\'aquina cliente) podemos definir la variable
{\sc nfs$\_$portmon} en {\tt /etc/system}; si usamos versiones de Solaris 
anteriores a la 2.5, debemos incluir una l\'{\i}nea como
\begin{quote}
\begin{verbatim}
set nfs:nfs_portmon = 1
\end{verbatim}
\end{quote}
mientras que en Solaris 2.5 y posteriores utilizaremos
\begin{quote}
\begin{verbatim}
set nfssrv:nfs_portmon = 1
\end{verbatim}
\end{quote}
Por \'ultimo, como ya comentamos en el punto dedicado a la seguridad {\sc 
eeprom}, podemos
deshabilitar el acceso que se consigue a la misma al pulsar la combinaci\'on
de teclas {\it `Stop--A'} en un teclado Sun; para ello es necesario a\~nadir
en el fichero {\tt /etc/system} una entrada como
\begin{quote}
\begin{verbatim}
set abort_enable=0
\end{verbatim}
\end{quote}
Antes de finalizar este punto, es necesario tener en
cuenta que los cambios que se realicen en {\tt /etc/system} no tendr\'an efecto
hasta que la m\'aquina se reinicie, y que un peque\~no error en los contenidos
de este archivo puede provocar que un sistema no arranque, por lo que es
siempre recomendable guardar una copia antes de realizar cualquier
modificaci\'on del fichero.
