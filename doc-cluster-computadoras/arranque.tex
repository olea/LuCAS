\chapter{ARRANQUE SIN DISCO O DISKLESS.}
\minitoc
\section{Introducción.}

Uno de los cambios más destacables del uso de la computadoras en los últimos años ha sido la expansión
de la conectividad de red con TCP/IP desde la mesa del despacho a toda la organización. La infraestructura
necesaria para soportar el crecimiento de la red, encaminadores, puentes, conmutadores y concentradores, ha
crecido a una velocidad similar.

El personal técnico lucha por mantenerse con las demandas de conectividad y los cambios, movimientos y
reconfiguraciones de red frecuentes, que caracterizan el entorno actual. Estas circunstancias han generado una necesidad
de mecanismos  que permitan automatizar la configuración de nodos y la distribución del sistema operativo y
del software en la red. La forma más efectiva de conseguirlo es almacenar los parámetros de configuración e
imágenes del software en una o más estaciones de \emph{arranque} de red. Al arrancar, los sistemas interactúan con
un servidor de arranque, recogen los parámetros de arranque y, opcionalmente, descargan el software apropiado.

\section{Requisitos del protocolo de arranque.}

Algunas computadoras sólo necesitan unas cuentas variables de configuración antes de arrancar. Otras,
puede que deban disponer de una lista detallada, más larga, de valores de parámetros. A veces, las estaciones de
trabajo, los host con Unix y otros sistemas operativos necesitan descargar completamente los sistemas operativos.
Otros sistemas, como los encaminadores, puentes, conmutadores o incluso los concentradores puede que necesiten
información de configuración de arranque y descargar software.

La inicialización debe ser robusta y flexible. Dependiendo del tamaño de la red, su topología y requisitos
de disponibilidad, podría ser más conveniente centralizar la información de arranque en un único servidor, distribuirla
por la red en varios servidores o replicarla.

Cada computador conectado a una red TCP/IP debe conocer la siguiente información:
\begin{itemize}
\item Su dirección IP.
\item Su máscara de red.
\item La dirección IP de un router.
\item La dirección IP de un servidor de nombres.
\end{itemize}
Esta información se guarda normalmente en ficheros de configuración, a los que accede el SO en el
arranque.
	
¿Qué ocurre con los computadores sin disco?
	
Podría guardarse el S.O y el software de red en la ROM de la ethernet, pero esa información no es conocida
de antemano por el fabricante ya que define la red a la que se va a conectar el computador.

Disponemos de tres protocolos que nos permitirán transferir esta información por la red:
\begin{itemize}
\item\textbf{RARP} (Reverse Address Resolution Protocol) sólo proporciona la dirección IP al computador
sin disco. Debido a esto RARP no está implementado en la mayoría de los sistemas y se ha eliminado totalmente
de TCP/IP v6.
\item\textbf{BOOTP} (Bootstrap Protocol) es un protocolo cliente/servidor diseñado para proporcionar los
cuatro tipos de información mencionados anteriormente, a un computador sin disco.
\item\textbf{DHCP} (Dinamic Host Configuration Protocol) es una extensión de BOOTP, es decir, lo mejora.
\end{itemize}

\section{Objetivos del arranque por red.}
\begin{itemize}
\item Reducir los costes de mantenimiento del software en gran cantidad de máquinas. Con el
arranque por red los ficheros son mantenidos en un servidor central, esto conlleva a la ventaja de poder ser
actualizados en una sola máquina.
\item La posibilidad de conmutar entre sistemas operativos sin tener que cargar el software cada
vez que se cambie de un sistema a otro.
\item Usar ordenadores en lugares donde los discos duros no son suficientemente resistentes, como
podría ser en la planta de una factoría, en la que éstos pueden ser relativamente frágiles.
\item Facilita el traspaso de equipos de una persona a otra. Por ejemplo, si en una empresa un
equipo pasa de una persona a otra, ésta no tendrá que hacer un traspaso de información sino que, como todo se
encuentra en el mismo servidor, bastará con entrar con el nuevo usuario.
\item Reducir el coste económico. El tener equipos sin disco duros reduce en gran medida el coste
de un equipo.
\end{itemize}
	
\section{Introducción DHCP.}

Las siglas DHCP significan Dinamic Host Configuration Protocol. Es utilizado para grandes redes. El
daemon actúa dándole información de la red a las estaciones de trabajo, tales como IP Address, Subnet Mask,
DNS Server, Gateway, etc.

DHCP ha sido creado por el Grupo de Trabajo Dynamic Host Configuration del IETF (Internet Engineering
Task Force, organización de voluntarios que define protocolos para su uso en Internet). Su definición se
encuentra en los RFC's 2131, el protocolo DHCP, y el 2132, opciones de DHCP.

Al igual que otros protocolos similares, utiliza el paradigma cliente-servidor, para que los nodos
clientes obtengan su configuración del nodo servidor.
	
El protocolo de Configuración Dinámica de Hosts (DHCP) permite la transmisión de la configuración de
los hosts sobre una red TCP/IP. Este protocolo se encarga de la configuración automática de los parámetros de
red, utilizando direcciones.

DHCP es una extensión de BOOTP, es decir, mejora BOOTP, y es compatible con él (un cliente puede realizar
una petición estática BOOTP a un servidor DHCP)

DHCP es un protocolo que permite asignar direcciones IP dinámicas, de forma totalmente automática. Por
ello no pierde las prestaciones de BOOTP, su predecesor, sino que las amplía permitiendo nuevas formas de
asignación de direcciones y nuevas opciones para poder pasar a los clientes toda la información necesaria.
DHCP es un protocolo implementado en los principales sistemas operativos así como otros dispositivos.

DHCP puede usarse cuando el número de IPs es menor que el número de computadores y todos no están
conectados a la vez, como en un proveedor de servicio de Internet (ISP).

DHCP está formado por dos partes: un protocolo para el intercambio de los parámetros de red específicos
de cada host y un mecanismo para la asignación de direcciones de red.

Un servidor DHCP tiene dos bases de datos. La primera es estática, al igual que BOOTP y la segunda
contiene una pila de direcciones IP disponibles. Esta segunda base de datos hace a DHCP dinámico. Cuando un
cliente DHCP pide una dirección IP temporal, DHCP la coge de la pila de direcciones IP disponibles y se la
asigna durante un periodo de tiempo negociado.

El servidor admite tres tipos de configuración de direcciones IP:
\begin{enumerate}
\item Estática. Se configura en el servidor la dirección de red que se corresponde con la
dirección LAN del cliente (equivalente a BOOTP).
\item Dinámica, por tiempo ilimitado. Se indica un rango de direcciones que se asignan a cada
cliente de carácter permanente, hasta que el cliente la libera.
\item Dinámica, arrendada. Las direcciones se otorgan por un tiempo ilimitado. Un cliente
debe renovar su dirección para poder seguir utilizándola.
\end{enumerate}

Cuando el servidor DHCP recibe una petición, primero chequea su base de datos estática. Si existe una
entrada para esa dirección física, se devuelve la dirección IP estática correspondiente. Si no se encuentra
la entrada, el servidor selecciona una IP disponible de la base de datos dinámica y añade la nueva asociación
a la base de datos.

\begin{itemize}\item\textbf{Alquiler}:
\begin{itemize}\item La dirección asignada desde la pila es temporal. El servidor DHCP emite un alquiler
por un periodo determinado de tiempo. Cuando el alquiler termina, el cliente debe, dejar de usar la IP o renovar
el alquiler. El servidor tiene la opción de aceptar o denegar la renovación.
\end{itemize}\end{itemize}
\begin{itemize}\item\textbf{Operación}:
El cliente realiza los siguientes pasos:
\begin{itemize}\item Envía un mensaje \emph{DHCPDISCOVER} broadcast usando el puerto destino 67.
\item Aquellos servidores que puedan dar este tipo de servicio responden con un mensaje DHCPOFFER,
donde se ofrece una IP que será bloqueada. En estos mensajes también puede ofrecer la duración del alquiler que
por defecto es de una hora. Si los clientes no reciben dicho mensaje, intenta establecer conexión cuatro veces
más, cada dos segundos, si aún así no hay respuesta, el cliente espera cinco minutos antes de intentarlo de nuevo.
\item El cliente elige una de las IPs ofertadas y envía un mensaje DHCPREQUEST al servidor
seleccionado.
\item El servidor responde con un mensaje DHCPACK y crea la asociación entre la dirección física
del cliente y su IP. Ahora el cliente usa la IP hasta que el alquiler expire.
\item Antes de alcanzar el 50\% del tiempo del alquiler, el cliente envía otro mensaje
DHCPREQUEST para renovar el alquiler.
\item Si el servidor responde con DHCPACK, el cliente puede seguir usando la IP durante otro
periodo de tiempo. Si se recibe un DHCPNACK, el cliente debe de dejar de usar esa IP y empezar de nuevo el
proceso de obtención de una IP.
\item Si después de transcurrir el 87.5\% del alquiler no se recibe respuesta, se manda otro
DHCPREQUEST. Si se recibe un DHCPACK antes de que expire el tiempo de alquiler, se obtiene más tiempo de
alquiler. En caso contrario, se debe comenzar de nuevo el proceso de obtención de una IP. El cliente puede
terminar el alquiler antes de que expire el tiempo. En este caso, el cliente envía un mensaje DHCPRELEASE al
servidor.

\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/dhcp/operaciondhcp.eps, width=3.25in}
\epsfig{file=imagenes/dhcp/operaciondhcp1.eps, width=3.25in}
\caption{Funcionamiento DHCP}
\end{center}
\end{figure}
\end{itemize}\end{itemize}	

\begin{itemize}\item\textbf{Formato del paquete}:
	
Para hacer DHCP compatible con BOOTP, los diseñadores de DHCP han usado casi el mismo formato
de paquete. Solo se ha añadido un bit de control al paquete. Sin embargo, se han añadido opciones extra para
permitir las diferentes interacciones con el servidor. Los campos diferentes de DHCP son los siguientes:
\begin{itemize}
\item Flag: 1 bit. El primero del campo sin uso, que permite al cliente el forzar que
la respuesta del servidor sea broadcast en vez de unicast. Si la respuesta es unicast, la dirección destino
sera la del cliente y este no la conoce, por lo que puede descartar el mensaje. Al ser broadcast, todos los
computadores reciben y procesan el mensaje.

\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/dhcp/formatodhcp.eps, width=3.25in}
\caption{Formato opciones}
\end{center}
\end{figure}
\end{itemize}

\item\textbf{Opciones}: Se han añadido varias posibiliades a la lista de opciones. La opción con
etiqueta 53 es la que define el tipo de interacción entre el cliente y el servidor. Otras opciones definen
parámetros con el tiempo de alquiler, etc. El campo de opción en DHCP puede tener hasta 312 bytes.
		
\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/dhcp/formatodhcp1.eps, width=3.25in}
\caption{Opciones}
\end{center}
\end{figure}
\end{itemize}
		
La asignación de direcciones IP se configurará de un modo u otro, dependiendo de cada situación. Puede
interesar un direccionamiento estático para clientes sin disco o por facilidades administrativas, pero
controlando la asignación de cada dirección a cada cliente (es mas cómodo para el administrador configurar
un servidor, que cada cliente; interesa el direccionamiento estático para evitar que se conecten clientes no
identificados o por otras razones, como la configuración DNS).

El direccionamiento dinámico por tiempo ilimitado se utiliza cuando el número de clientes no varía
demasiado, facilitando mucho la tarea del administrador.

El arrendamiento de direcciones se emplea para racionar las direcciones IP, minimizando el coste
administrativo. En función de la frecuencia de inserciones/eliminaciones de clientes y de la cantidad
de direcciones disponibles se concederá un mayor o menor tiempo de arrendamiento. El tiempo sera bajo (ej.
15 minutos); si se conectan/desconectan los clientes con mucha frecuencia e interesa que este disponible
el máximo número de direcciones. Por el contrario se utilizará un tiempo largo para que cada cliente mantenga
su dirección IP (ej. en una universidad un tiempo de 4 meses, tiempo máximo que esta desconectado en vacaciones
para asumir que el cliente ya no esta en la red). Un portátil puede tener una dirección permanente o de larga
duración en su red habitual de trabajo y tiempos cortos en otras redes.


\section{Características de DHCP.}

El protocolo de configuración dinámico de host extiende significativamente las posibilidades de BOOTP.
Las mejoras mas importantes son:
        \begin{itemize}
		\item Administración más sencilla.
		\item Configuración automatizada.
		\item Permite cambios y traslados.
		\item Posibilidad de que el cliente solicite los valores de ciertos parámetros.
		\item Nuevos tipos de mensajes de DHCP que soportan interacciones cliente/servidor robustas.
	\end{itemize}

\section{¿Qué ventajas me da el DHCPd?}

El instalar un sistema DHCP en su red, le ahorra un trabajo de configuración para su red. Todas las
computadoras piden información de la red y se configuran automáticamente, muy recomendable para un administración
fácil.

\section{Ejemplo teórico del funcionamiento del arranque por red a través del protocolo DHCP.}

Para que un ordenador, que actúa como cliente, pueda arrancar por red, el servidor deberá pasarle
la siguiente información:
\begin{itemize}
\item Información de red. Que podría estar formada por lo siguiente: dirección IP, servidor
de arranque y el fichero del que debe arrancar. Estos datos pueden varias dependiendo de las necesidades de cada
uno.
\item Un sistema de ficheros con el que trabajar.
\item La imagen (núcleo del sistema operativo) para realizar el arranque.
\end{itemize}
	
Si tenemos una red formada por ordenadores sin disco (DC-Diskeless Computer) teniendo estos una ROM
para arrancar por red, se diferenciarán unos de otros gracias a la dirección Ethernet.

Un ejemplo de intercambio sería el siguiente:
\begin{quote}
DC:Hola, mi dirección hardware es 00:60:08:C7:A3:D8, por favor, dame mi dirección IP.
		
Servidor DHCP: (busca la dirección en su base de datos) Tu nombre es host1, tu dirección
IP es 192.168.1.2, tu servidor es 192.168.1.1. En el caso que necesite un fichero del que se supone que debe
arrancar se alojará en /tftpboot/.

La petición de DHCP se realiza en forma de broadcast dentro de la red local, de forma que cualquier
servidor de DHCP que pudiera responder a la petición, lo haría.

Después de obtener la dirección IP, el DC debe conseguir la imagen del sistema operativo y lanzarlo
a ejecución. En esta fase, se usa otro protocolo TCP/IP, TFTP (Trivial File Transfer Protocol).Éste es una
versión reducida del FTP (File Transfer Protocol). El TFTP no contempla autentificación, trabaja a través
de UDP (User Datagram Protocol) en vez de TCP (Transmisión Control Protocol).

La implementación de UDP en un ordenador de arranque sin disco puede ser suficientemente reducida como
para caber en una ROM. Existe la posibilidad de simular esta ROM a través de un disquete. Debido a que UDP es un
protocolo orientado a la transmisión por bloques la transferencia se realiza bloque a bloque, de la siguiente forma:

DC: Dame el bloque 1 de /tftpboot/maquina1
	
TFTP servidor: Aquí lo tienes
	
DC: Dame el bloque 2, y así en adelante, hasta que se transfiere el fichero completo para almacenarlo
en RAM.
\end{quote}
El funcionamiento consiste, básicamente, en el reconocimiento de cada bloque, y la pérdida de paquetes
se soluciona mediante su retransmisión al cabo de un tiempo establecido. Cuando todos los bloques han sido
recibidos, la ROM de arranque de la red pasa el control a la imagen del sistema operativo.

Finalmente, para poner en funcionamiento un sistema operativo, se le debe proporcionar un sistema de
ficheros raíz. El protocolo utilizado por Linux y otros sistemas UNIX es normalmente NFS (Network File System),
 aunque no es el único.

En este caso el código no necesita estar grabado en la ROM, sino que forma parte del sistema operativo
que acabamos de cargar. El sistema operativo debe ser capaz de ejecutarse con un sistema de ficheros raíz NFS,
 en vez de un disco real.

\section{Preparación de la máquina servidora para atender peticiones por la red.}
\subsection{Creación del sistema de ficheros para los PC clientes o nodos del cluster.}
	
Los directorios de cada uno de los posibles clientes de nuestro servidor se van a encontrar dentro del
directorio \textbf{/tftpboot}. La estructura de este directorio tendrá la siguiente forma:
\begin{quote}
\begin{em}
/tftpboot/nombre\_máquina\_cliente1\newline
/tftpboot/nombre\_máquina\_cliente2
\end{em}
\end{quote}
Dentro de los directorios clientes debemos crear la jerarquía de directorios necesaria para el sistema
de ficheros, es decir, tendrá la propia estructura del sistema de ficheros de Linux:
\begin{quote}
\begin{verbatim}
/tftpboot/nombre_máquina_cliente/bin
/		"		  /dev
/		"		  /etc
/		"		  /lib
/		"		  /sbin
/		"		  /var
/		"		  /home
/		"		  /mnt
/		"		  /proc
/		"		  /root
/		"		  /tmp
/		"		  /usr
\end{verbatim}
\end{quote}
Para crear esta estructura interna a cada directorio cliente tenemos que ejecutar las siguientes órdenes
de comandos en el front-end:
\begin{quote}
\begin{em}
\$$>$cd /tftpboot/nombre\_máquina\_cliente\newline
\$$>$cp -r /bin .\newline
\$$>$cp -ra /dev .\newline	
\$$>$cp -ra /etc .\newline
\$$>$cp -r /lib .\newline	
\$$>$cp -r /sbin .\newline
\$$>$cp -r /var .\newline
\$$>$mkdir home\newline		
\$$>$mkdir mnt\newline			
\$$>$mkdir proc\newline		
\$$>$mkdir root\newline		
\$$>$mkdir tmp; tendrá permiso temporal $\Rightarrow$ chmod 0177\newline		
\$$>$mkdir usr
\end{em}
\end{quote}
Los directorios home, mnt, proc, root, tmp, es decir, los que solo creamos, serán montados desde el frontend
a través del protocolo NFS, mientras que los directorios que copiamos son ``locales'' a cada uno de los clientes.
El proceso de montaje lo realiza el fichero \emph{/etc/fstab} local de cada cliente, que posteriormente será
explicado.
\subsection{Instalación del dhcpd en el servidor.}
Para disponer del servidor DHCPD se tendrá que instalar el paquete \textbf{dhcpcd-1.3.18pl3-1.i386.rpm}
disponible en el CD-ROM de Red Hat Linux de la siguiente forma:
\begin{quote}
\emph{rpm -ivh dhcpcd-1.3.18pl3-1.i386.rpm}
\end{quote}
A continuación se editará el fichero \emph{/etc/rc.d/init.d/dhcpd}. En dicho fichero se tendrá que
indicar cual es el dispositivo de red para la red interna, para ello se tendrá que modificar la siguiente linea:
\begin{quote}
\emph{daemon /usr/sbin/dhcpd eth0}
\end{quote}
Sustituyendo eth0 por eth1 ya que es la ethernet para la red interna en nuestro caso concreto. Se guardará
los cambios realizado a dicho fichero y se reiniciará del daemon como se muestra a continuación:
\begin{quote}
\emph{/etc/rc.d/init.d/dhcpd restart}	
\end{quote}
Una vez finalizada la tarea anterior, el siguiente paso a realizar será la activación del servicio
 TFTP (Trivial File TransFer Protocol), debido que el posteriormente será utilizado por el paquete
Etherboot\footnote{Etherboot es un paquete software, cuya función es la creación de imagenes ROM que puede ser
descargables a través de una red Ethernet para ser ejecutadas en computadores x86.} para transferir el núcleo
por la red y otro ficheros necesario para el arranque sin disco. La ejecución del demonio tftpd se realiza a
través del superdemonio inetd. La configuración de este superdemonio se encuentra en el archivo \emph{/etc/inted.conf}.
Este demonio es el encargado de arrancar automáticamente el servidor correspondiente a un servicio solicitado,
este servidor particular termina una vez que el servicio se ha proporcionado. Por lo tanto, el proceso inetd
está a la escucha en los diferentes puertos correspondientes a los servicios disponibles.

El archivo \emph{/etc/inetd.conf} es utilizado por el proceso inetd cuando se lanza para conocer el
conjunto de puertos sobre los que se tiene que poner a la escucha. Este archivo contiene una línea por servicio,
cada línea suministra la siguiente información:
\begin{itemize}
\item El nombre del servicio.
\item El tipo de socket.
\item Una opción wait/nowait que se utiliza para las comunicaciones en modo no orientado a conexión
(dgram), las otras se utilizan siempre con la opción nowait. La opción wait evita, en el modo orientado a conexión,
la ejecución de varios servidores a la escucha sobre un mismo puerto.
\item Un nombre de usuario que será propietario del proceso demonio asociado al servicio cuando se cree.
\item La referencia absoluta del archivo que contiene el programa que proporciona el servicio.
\item Una lista de parámetros para el programa.
\end{itemize}
	
Asi pues, se tendrá que activar la línea correspondiente al tftp eliminando la marca de comentario (\#)
para poder ejecutar el demonio tftpd:
\begin{quote}
\emph{tftp dgram udp wait root /usr/sbin/tcpd in.tftpd /tftpboot}
\end{quote}
El archivo \emph{/etc/services} contiene la lista de servicios de Internet conocidos. Un servicio se
caracteriza por su nombre, un número de puerto, un protocolo y una lista de alias. El servicio anterior
describe un servicio estándar en Internet basados en el protocolo UDP.

Se deberá modificar el archivo \emph{etc/services} descomentando las siguientes dos líneas:
\begin{quote}
\emph{tftp 69/udp \#TFTP server}
\end{quote}
Una vez que se han modificado los dos archivos anteriores debemos de reiniciar el superdemonio inetd
mediante la orden:
\begin{quote}
\emph{kill -HUP PID\_de\_inetd}
\end{quote}
	
\subsection{Configuración del dhcpd en el servidor.}	

El demonio dhcpd tiene un archivo de configuración llamado \emph{/etc/dhcpd.conf}. Finalizada la
realización de los pasos anteriores se procederá a configurar las opciones DHCP creando o editando el fichero
anterior. Para este caso concreto dicho fichero presentará la siguiente configuración:
\begin{em}
\begin{quote}
\#red interna\newline
subnet 192.168.1.0 netmask 255.255.255.0 \{ \newline
option broadcast-address 192.168.1.255;
\begin{quote}
host pc1\{
\begin{quote}
hardware ethernet 00:50:04:09:DA:EB;\newline
fixed-address 192.168.1.2; \newline
option host-name "pc1";\newline
filename "/tftpboot/pc1/vmlinuz.nodos";
\end{quote}	
\}\newline
host pc2\{
\begin{quote}
hardware ethernet 00:50:DA:3D:2F:1C;\newline
fixed-address 192.168.1.3;\newline
option host-name "pc2";\newline
filename "/tftpboot/pc2/vmlinuz.nodos";
\end{quote}	
\}
\end{quote}
\end{quote}
\end{em}
A continuación se realiza una aclaración de la configuración anterior:
\begin{quote}
\textbf{subnet 192.168.1.0 netmask 255.255.255.0}: Declaración de la subred interna.\newline
\textbf{option broadcast-address}: Dirección de broadcast.\newline
\textbf{hosts pc1 }: Indica que la configuración corresponde a la máquina cliente pc1.\newline
\textbf{hardware ethernet}: Especifica el tipo de hardware y la dirección de la tarjeta de red de
la máquina cliente.\newline
\textbf{fixed-address}: Dirección IP que se asigna a la máquina cliente con la dirección de red arriba
indicada.\newline
\textbf{option host-name "pc1.cluster.psa.es"}: Indica el nombre que se le asigna a la máquina cliente.
\end{quote}
Terminada la configuración del servidor DHCP se reiniciaría el demonio DHCP como anteriormente se ha
comentado.

\subsection{Configuración del fichero /etc/hosts.}	
	
	Este fichero contiene las informaciones relativas a las diferentes máquinas de la red local a la que
pertenece el sistema. Contiene la tabla de correspondencias entre la dirección Internet y un nombre simbólico.
Dentro de una red este nombre simbólico contiene una componente única. A cada máquina de la red le corresponde
una línea de dicho archivo quedando la siguiente tabla:
\begin{quote}
\begin{em}
127.0.0.1	localhost.localdomain	localhost\newline
192.168.1.1 	pc0.cluster.psa.es	pc0\newline
192.168.1.2	pc1.cluster.psa.es	pc1\newline
192.168.1.3	pc2.cluster.psa.es	pc2
\end{em}
\end{quote}

\subsection{Configuración del fichero /etc/exports.}

Este archivo sirve como la lista de control de acceso para sistemas de ficheros que pueden ser exportados
a clientes NFS. Cada línea contiene un punto de montaje y una lista de máquinas o nombres de grupo de red a las
que se les permite montar el sistema de ficheros en ese punto. Su estructura se muestra a continuación:
\begin{quote}
\begin{em}
/tftpboot	*.cluster.psa.es(rw,no\_root\_squash)\newline
/bin		*.cluster.psa.es(rw,no\_root\_squash)\newline
/usr		*.cluster.psa.es(rw,no\_root\_squash)\newline
/sbin		*.cluster.psa.es(rw,no\_root\_squash)\newline
/home		*.cluster.psa.es(rw,no\_root\_squash)\newline
/lib		*.cluster.psa.es(rw,no\_root\_squash)\newline
/boot		*.cluster.psa.es(rw,no\_root\_squash)\newline
/root		*.cluster.psa.es(rw,no\_root\_squash)\newline
/etc/passwd	*.cluster.psa.es(rw,no\_root\_squash)\newline
/etc/group	*.cluster.psa.es(rw,no\_root\_squash)
\end{em}
\end{quote}
	
donde:
\begin{quote}
\textbf{rw}: Permitir pedidos de lectura/escritura.\newline
\textbf{no\_root\_squash}: Deshabilita la opción de root squashing, permitiendo conexión en modo root. Esta
opción es particularmente útil para clientes sin disco.
\end{quote}

\subsection{Preparación de la configuración del cliente.}
Como ya se ha creado una estructura de directorios donde alojar el sistema de ficheros de las máquinas
clientes en los apartados anteriores, y se han copiado los directorios que contienen la configuración de Linux
de la máquina servidora, ahora se tiene que adaptar para cada máquina los ficheros de configuración.\newline
\textbf{Nota:} Todos los cambios que se van a realizar a continuación se harán sobre los archivos de configuración
que están en la ruta \emph{/tftpboot/pc1}, es decir que cuando se diga que se modifica el \emph{etc/hosts} se
esta haciendo referencia al archivo que existe en la ruta \emph{/tftpboot/pc1/etc/hosts}.

\subsection{Configuración del ficheros /etc/HOSTNAME.}
No se dará ningun nombres, es decir, se deberá dejar el archivo vacío.
	
\subsection{Configuración del fichero /etc/hosts.}
En este constará unicamente las direcciones IP de los clientes que van a formar la red interna:
\begin{quote}
\begin{em}
127.0.0.1	localhost.localdomain	localhost\newline
192.168.1.1 	pc0.cluster.psa.es	pc0\newline
192.168.1.2	pc1.cluster.psa.es	pc1\newline
192.168.1.3	pc2.cluster.psa.es	pc2
\end{em}
\end{quote}

\subsection{Configuración del fichero /etc/fstab.}
Este archivo contiene la tabla del sistema de ficheros utilizado por el cliente pc1. Hay que indicar
los directorios que se van a montar vía NFS. El contenido debe quedar de la siguiente forma:
\begin{quote}
\begin{em}
pc0:/tftpboot/pc1 /	nfs	defaults	1	1\newline
pc0:/bin		/bin	nfs	defaults	1	1\newline
pc0:/usr		/usr	nfs	defaults	1	1\newline
pc0:/sbin		/sbin	nfs	defaults	1	1\newline
pc0:/home		/home	nfs	defaults	1	1\newline
pc0:/lib		/lib	nfs	defaults	1	1\newline
pc0:/boot		/boot	nfs	defaults	1	1\newline
none              /proc     proc    defaults        0 0\newline
none              /dev/pts  devpts  gid=5,mode=620  0 0
\end{em}
\end{quote}
Así pues el directorio raíz de la máquina pc1 va a ser el directorio /tftpboot/pc1 de la máquina pc0
siendo este el servidor o front-end.

\subsection{Configuración del fichero /etc/sysconfig/network.}
Este archivo presenta información de red relativa a la máquina necesaria para la red, para nuestro
caso del cliente pc1 queda de la siguiente forma:
\begin{quote}
\begin{em}
NETWORKING=yes\newline
HOSTNAME=\newline
FORWARD\_IP=no
\end{em}
\end{quote}

\subsection{Configuración del fichero /etc/sysconfig/network-scripts/ifcfg-eth0.}
Este archivo especifica el nombre del dispositivo de la interfaz de red, la dirección IP, la máscara
de red, la dirección de red, la dirección de broadcast e información sobre el modo de arranque. Los datos para
la máquina pc1 son los siguientes:
\begin{quote}
\begin{em}
DEVICE="eth0"\newline
BOOTPROTO="dhcp"\newline
BROADCAST=\newline
IPADDR=\newline
NETMASK=\newline
NETWORK=\newline
ONBOOT="yes"
\end{em}	
\end{quote}
En este momento la máquina cliente quedaría bien configurada para que hiciese el arranque, lo que pasa
es que cuando el proceso de arranque intenta chequear los discos duros, el sistema se queda bloqueado ya que
esta trabajando NFS. Para solucionar este problema se presenta el siguiente apartado.

\subsection{Configuración del fichero /etc/rc.d/rc.sysinit.}
En este archivo tenemos que comentar o eliminar las líneas que hacen referencia al chequeo de las
unidades. Estas líneas son las siguientes:
\begin{quote}
\begin{em}
if [ -f /fsckoptions ]; then
\begin{quote}fsckoptions=`cat /fsckoptions'\end{quote}
else                 f
\begin{quote}fsckoptions=\end{quote}
fi\newline
if [ -f /forcefsck ]; then
\begin{quote}fsckoptions=``-f \$fsckoptions''\end{quote}
fi\newline
if [ ``\$BOOTUP'' != ``serial'' ]; then
\begin{quote}fsckoptions='' -C \$fsckoptions"\end{quote}
else
\begin{quote}fsckoptions=`` -V \$fsckoptions''\end{quote}
fi\newline
\_RUN\_QUOTACHECK=0\newline
if [ ! -f /fastboot ]; then
\begin{quote}
STRING=``Checking root filesystem''\newline
echo \$STRING\newline
initlog -c ``fsck -T -a \$fsckoptions /''\newline
rc=\$?
\end{quote}
if [ "\$rc" = "0" ]; then
\begin{quote}
success "\$STRING"
echo
\end{quote}
elif [ "\$rc" = "1" ]; then
\begin{quote}
passed "\$STRING"
echo
\end{quote}
fi\newline
\# A return of 2 or higher means there were serious problems.\newline
if [ \$rc -gt 1 ]; then
\begin{quote}
failure "\$STRING"\newline
echo\newline
echo\newline
echo "*** An error occurred during the file system check."\newline
echo "*** Dropping you to a shell; the system will reboot"\newline
echo "*** when you leave the shell."\newline
PS1=``(Repair filesystem) \# \# ''; export PS1\newline
sulogin\newline
echo ``Unmounting file systems''\newline
umount -a\newline
mount -n -o remount,ro /\newline
echo ``Automatic reboot in progress.''\newline
reboot -f\newline
elif [ ``\$rc'' = ``1'' ]; then\newline
\begin{quote}\_RUN\_QUOTACHECK=1\end{quote}
fi
\end{quote}
fi\newline
\_RUN\_QUOTACHECK=0\newline
\# Check filesystems\newline
if [ ! -f /fastboot ]; then\newline
STRING="Checking filesystems"\newline
echo \$STRING\newline
initlog -c ``fsck -T -R -A -a \$fsckoptions''\newline
rc=\$?\newline
if [ "\$rc" = "0" ]; then
\begin{quote}
success "\$STRING"\newline
echo
\end{quote}
elif [ "\$rc" = "1" ]; then
\begin{quote}
passed "\$STRING"\newline
echo
\end{quote}
fi\newline
\# A return of 2 or higher means there were serious problems.\newline
if [ \$rc -gt 1 ]; then
\begin{quote}
failure "\$STRING"\newline
echo\newline
echo\newline
echo ``*** An error occurred during the file system check.''\newline
echo ``*** Dropping you to a shell; the system will reboot''\newline
echo ``*** when you leave the shell."\newline
PS1=``(Repair filesystem) \# \# ''; export PS1\newline
sulogin\newline
echo ``Unmounting file systems''\newline
umount -a\newline
mount -n -o remount,ro /\newline
echo ``Automatic reboot in progress.''\newline
reboot -f\newline
elif [ ``\$rc'' = ``1'' -a -x /sbin/quotacheck ]; then\newline
\_RUN\_QUOTACHECK=1
\end{quote}
fi\newline
fi
\end{em}	
\end{quote}

\subsection{Comprobación del arranque vía NFS.}
Una vez acabada la configuración de los clientes debemos comprobar que podemos montar la estructura de
directorios creada para los clientes vía NFS realizando los siguientes pasos:

Exportar los directorios:
\begin{quote}
\emph{exportfs -av}
\end{quote}

Montar los directorios en el cliente:
\begin{quote}
\emph{mount -t nfs nb\_servidor:/tftpboot/directorio\_cliente /directorio\_destino}
\end{quote}

En este caso quedaría:
\begin{quote}
\emph{mount -t nfs pc0:/tftpboot/pc1 /mnt}
\end{quote}

Si no lo monta correctamente se revisará todos los pasos realizados.

\section{Configuración del núcleo.}\label{sec:OK}

El usuario root es el único que tiene permisos para poder compilar el kernel.
	
A continuación se va ha indicar los módulos que debe tener el kernel para poder realizar la petición de
dirección IP y poder montar su sistema de ficheros a través de la red. La opciones que se tendrá que activar son:
\begin{itemize}
\item En el apartado LOADABLE MODULE SUPPORT.
\begin{quote}
\emph{Enable loadable module support: Desactivado}		
\end{quote}
\item En el apartado NETWORKING OPTIONS.
\begin{quote}
\emph{IP kernel level autoconfiguration: Activado}\newline
\emph{BOOTP support: Activado}\newline
\emph{RARP support: Activado}\								
\end{quote}
\item En el apartado NETWORK FILE SYSTEM.
\begin{quote}
\begin{em}
NFS Filesystem support: Activado\newline
Root Filesystem on NFS: Activado\newline
NFS server support: Desactivado						
\end{em}
\end{quote}
\end{itemize}
	
Para poder compilar el kernel con las opciones anteriormente indicadas vamos a utilizar una herramienta
que nos mostrará un menú en TCL/TK:
\begin{quote}
\emph{\$$>$cd /usr/src/linux}\newline		
\emph{\$$>$make xconfig}
\end{quote}
Una vez ejecutada esta herramienta se realizará los pasos que muestran las siguientes figuras:

\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/2.eps, width=3.25in}
\caption{Paso 1. Cargar preconfiguración del núcleo}
\end{center}
\end{figure}

\clearpage
\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/1.eps, width=3.75in}
\caption{Paso 2. Cargar fichero}
\end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/3.eps, width=3.75in}
\caption{Paso 3. Loadable module support}
\end{center}
\end{figure}

\clearpage	
\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/4.eps, width=3.25in}
\caption{Paso 4. Desactivar loadable module support}
\end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/5.eps, width=3.25in}
\caption{Paso 5. Networkin options}
\end{center}
\end{figure}


\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/6.eps, width=3.25in}
\caption{Paso 6. Activación del protocolo BOOTP}
\end{center}
\end{figure}

\clearpage
\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/7.eps, width=3.25in}
\caption{Paso 7. Networking File System}
\end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/8.eps, width=3.25in}
\caption{Paso 8. Activar NFS}
\end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/9.eps, width=3.25in}
\caption{Paso 9. Guardar configuración}
\end{center}
\end{figure}

\clearpage	
\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/10.eps, width=3.25in}
\caption{Paso 10. Guardar configuración a un archivo}
\end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/11.eps, width=3.25in}
\caption{Paso 11. Salir}
\end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}
\epsfig{file=imagenes/nucleo_diskeles/12.eps, width=3.25in}
\caption{Paso 12. Configuración finalizada}
\end{center}
\end{figure}

\section{Etherboot.}
\subsection{Introducción}
Etherboot es un paquete software, cuya función es la creación de imagenes ROM que puede ser
descargables a través de una red Ethernet para ser ejecutadas en computadores x86.
Algunos adaptadores de red tienen un enchufe donde puede ser instalado o conectado un chip ROM.
Etherboot es código que puede ser grabado en una ROM. Etherboot es usado normalmente para realizar
arranque sin disco o diskeless. Esto es beneficioso en varias situaciones, por ejemplo:
\begin{itemize}
\item Un X-Terminal.
\item Cluster de computadoras.
\item Routers.
\item Varias clases de servidores remotos, por ejemplo, un servidor de cinta que solo puede ser
accedido a través del protocolo RMT.
\item Maquinas trabajando en entornos desfavorables para los discos duros.
\item Plataformas de usuario donde las particiones remotas son montadas a través de la red y
se obtiene bajas velocidades en comparación con los discos.
\item Mantenimiento software para cluster de igual configuración a la estación de trabajo central.
\end{itemize}
		
Etherboot inicia computadores mas rápidamente que un disquete ya que no hay retardos en los giros
del disco, etc. Realizando un pequeño calculo se observará que con una Ethernet de 10Mbit/s se enviará
un kenel de 500kB en un par de segundos. Con una Ethernet de 100Mbit se obtendrá mejores resultados aún.

En comparación con el arranque desde dispositivos como puede ser un disco Flash, Etherboot posee
la ventaja de la administración del software centralizado.

Etherboot trabaja con discos RAM, sistemas de ficheros NFS, o discos locales. Es un componente
tecnologico que puede ser combinado con otras tecnologías para actuar como deseamos.

Etherboot se utiliza generalmente para cargar Linux, FreeBSD o el DOS. No obstante los
formatos del fichero del protocolo y del cargador del programa inicial son generales.

Etherboot es Open Source bajo la GNU GPL2 (General Public Licence Version 2).
	
Los componentes necesitados por Etherboot son:
\begin{itemize}
\item Un cargador de carga inicial, usualmente una EEPROM de una tarjeta de red o instalado
en la flash BIOS.
\item Un servidor DHCP o BOOTP, que asigne una dirección IP cuando reciba una dirección MAC.
\item Un servidor TFTP, encargado de transmitir la imagen del kernel y otros ficheros requeridos
durante el proceso de arranque.
\end{itemize}
	
\subsection{Funcionamiento.}
A continuación se describirá el funcionamiento del software Etherboot.
\begin{itemize}
\item Busca un servidor DHCP que en función de su dirección MAC le asignará una dirección IP.
\item Una vez asignada la dirección IP, solicitará la transmisión del archivo con la imagen del núcleo. Esta
transmisión la realizará el TFTP.
\item Recibido el archivo con la imagen del núcleo, será el núcleo el encargado de seguir con el proceso de
arranque, es decir, solicitará una IP a través de DHCP y un servidor se le asignará en función de su dirección
MAC y solicitará la transmisión del sistema archivos vía NFS.
\end{itemize}

\subsection{Instalación.}
Los fuentes del paquete Etherboot esta disponible en la web \url{http://etherboot.sourceforge.net/distribution.html}.
	
Una vez descargados dichos fuentes deberá ser compilados, a continuación se muestran los pasos a
seguir para la instalación de Etherboot:
\begin{enumerate}
\item Descargar de la web los paquetes etherboot-5.0.2.tar.gz y mknbi-1.2.tar.gz.
\item Descomprimir los paquetes utilizando tar xvfz nombre\_paquete.
\item Recompilar el núcleo con las opciones seguidas en el punto \ref{sec:OK}, con los siguientes comandos:
\begin{quote}
\emph{\$$>$make dep;make clean;make bzImage}
\end{quote}
\item Copiar la imagen del núcleo generada al directorio donde se haya descomprimido el paquete
mknbi-1.2.tar.gz. La imagen del núcleo se encuentra en el directorio \emph{/usr/src/linux/arch\newline/i386/boot}
\item En el arranque no se puede usar el fichero \emph{bzImage}, generada en la compilación del
núcleo. Esta imagen debe ser convertida en una \emph{tagged image} (imagen etiquetada). Esta es una imagen normal
con una cabecera especial que le dice al cargador de arranque en red dónde han de almacenarse los bytes en memoria
y en qué dirección empieza el programa. Para crear esta imagen se usa el programa llamado \emph{mknbi-linux},
que nos proveé el paquete mknbi-1.2.tar.gz.

Posicionarse en el directorio donde se hay descomprimido el paquete mknbi-1.2.tar.gz (por
ejemplo \emph{/home/usuario/mknbi-1.2}), transformar la imagen del núcleo, es decir, hacer una tagged imagen con
el siguiente comando:
\begin{quote}
\emph{./mknbi -format=elf -target=linux bzImage -output=vmlinuz.nodos}
\end{quote}
\item Copiar el archivo generado vmlinuz.nodos al directorio /tftpboot
\item Posicionarse sobre el directorio src dentro del directorio en el cual se haya descomprimido
el paquete etherboot-5.0.2.tar.gz, como por ejemplo \emph{/home/usuario/etherboot-5.0.2/src}	
\item Introducción de un disquete en la unidad de disco y escribir los siguiente comandos:
\begin{quote}
\emph{\$$>$make}\newline
\emph{\$$>$make bin/boot1a.bin $\Rightarrow$ se genera la imagen de los drivers de la
tarjeta de red} \newline
\emph{\$$>$make bin32/3c90x.rom $\Rightarrow$ esta línea variará en función de la tarjeta
de red, en este caso concreto una 3COM 3c905}\newline
\emph{\$$>$cat bin/boot1a.bin bin32/3c90x.rom $>$ /dev/fd0}\newline
\end{quote}
\end{enumerate}
	
Una vez finalizados los pasos anteriores ya estaría preparado el disquete de arranque, solamente
quedaría irse a un cliente y comprobar que el proceso de arranque vía nfs funciona correctamente.
				
Los servicios mínimos que deben estar corriendo en el cliente una vez que ha arrancado correctamente
son: \emph{identd, inet,netfs, network, portmap}. Si eliminamos algunos de estos servicios el cliente no funcionará
correctamente.
	
