\chapter{Aspectos básicos del software}
\label{sw-basics-chapter}
\ChapterDescription{
Un programa es un conjunto de instrucciones de computadora que realizan
una tarea particular. Puede estar escrito en ensamblador, 
un lenguaje de muy bajo nivel, o en un lenguaje de alto nivel, independiente
de la máquina, como el lenguaje de programación C.
Un sistema operativo es un programa especial que permite al usuario ejecutar
aplicaciones como hojas de cálculo y procesadores de texto.
Este capítulo introduce los principios básicos de la programación y da
una idea general de los objetivos y funciones de un sistema operativo.
}

\section{Lenguajes de computadora}
\subsection{Lenguajes ensambladores}
\index{Ensamblador, Lenguaje}
\index{Lenguaje Ensamblador}
Las instrucciones que una CPU lee desde la memoria y después ejecuta no
son comprensibles para los seres humanos; son códigos de máquina que dicen 
al ordenador qué hacer precisamente.
El número hexadecimal \hex{89E5} es una instrucción de Intel 80486 que copia el contenido
del registro ESP al registro EBP.
Una de las primeras herramientas de software inventadas para los primeros 
ordenadores fue un ensamblador, un programa que toma un fichero fuente leíble
por los humanos y lo ensambla en código máquina.
Los lenguajes ensambladores se ocupan explícitamente de los registros y las
operaciones sobre los datos y son específicos de un microprocesador particular.
El lenguaje ensamblador para un microprocesador X86 es muy diferente del
ensamblador de un microprocesador \axp.
El código ensamblador siguiente, para \axp, muestra el tipo de operaciones
que un programa puede realizar:
\begin{verbatim}
    ldr r16, (r15)    ; Línea 1
    ldr r17, 4(r15)   ; Línea 2
    beq r16,r17,100   ; Línea 3
    str r17, (r15)    ; Línea 4
100:                  ; Línea 5

\end{verbatim}
La primera sentencia (en la línea 1) carga el valor del registro 16
de la dirección guardada en el registro 15.
La siguiente instrucción carga el valor del registro 17 desde
la siguiente posición en la memoria.
La línea 3 compara el contenido del registro 16 con el del 17 y,
si son iguales, salta a la etiqueta {\em 100}.
Si los registros no contienen el mismo valor, el programa sigue por
la línea 4 donde el contenido de r17 es salvado en la memoria.
Si los registros contienen el mismo valor entonces ningún dato 
necesita ser salvado.
Los programas en ensamblador son muy tediosos y difíciles de escribir, 
y sujetos a errores. Muy poco en el núcleo de Linux está escrito en
lenguaje ensamblador, y aquellas partes que lo están han sido escritas
sólo por eficiencia y son específicas de un procesador particular.

\subsection{El Lenguaje de Programación C y su Compilador}
\index{C, Lenguaje de Programación}
\index{Lenguaje de Programación C}
Escribir programas grandes en lenguaje ensamblador es una tarea difícil
y larga.
Es propensa a errores y el programa resultante no es portable, al estar 
atado a una familia de procesadores particular.
Es mucho mejor usar un lenguaje independiente de la máquina, como
C\cite[The C Programming Language]{bib-k-and-r}.
C le permite describir los programas en términos de sus algoritmos lógicos y 
de los datos con los que operan.
Unos programas especiales llamados compiladores leen el programa en C y lo
traducen a lenguaje ensamblador, generando el código específico de la
máquina a partir de éste.
Un buen compilador puede generar instrucciones en ensamblador 
casi tan eficientes como la escritas por un buen
programador de ensamblador.
La mayor parte del núcleo de Linux está escrita en lenguaje C.
El fragmento de C siguiente
\begin{verbatim}
        if (x != y)
                x = y ;
\end{verbatim}
hace exactamente las mismas operaciones que el ejemplo anterior de
código ensamblador. 
Si el contenido de la variable \texttt{x} no es el mismo que el de
la variable \texttt{y} el contenido de \texttt{y} es copiado a \texttt{x}.
El código en C está organizado en rutinas, de las cuales cada una cumple
una función.
Las rutinas pueden devolver cualquier valor o tipo de dato soportado por C.
Los programas grandes, como el núcleo de Linux, contienen muchos módulos
separados de código C, cada uno con sus propias rutinas y estructuras de datos.
Estos módulos de código fuente en C se agrupan en funciones lógicas, como
el código para el manejo del sistemas de ficheros.

C soporta muchos tipos de variables; una variable es una posición en
la memoria que puede ser referenciada por un nombre simbólico.
En el fragmento anterior de C, \texttt{x} e \texttt{y} hacen referencia a las
posiciones en la memoria.
El programador no se preocupa de dónde son guardadas las variables, es el
enlazador (véase abajo) quién se preocupa de ésto.
Las variables contienen diferentes tipos de datos; enteros o números de
coma flotante, así como punteros.

Los punteros son variables que contienen la dirección, es decir la posición en
memoria, de otro dato.
Considere una variable llamada {\em x} que reside en la memoria en la dirección \hex{80010000}.
Podría tener un puntero, llamado {\em px}, que apunta a {\em x}.
{\em px} podia residir en la dirección \hex{80010030}.
El valor de {\em px} sería \hex{80010000}: la dirección de la variable {\em x}.

C le permite unir variables relacionadas en estructuras de datos.
Por ejemplo,
\begin{verbatim}
        struct {
                int i ;
                char b ;
        } mi_estruc ;
\end{verbatim}
es una estructura llamada \texttt{mi\-estruc} que contiene dos elementos,
un entero (32 bits de almacenamiento de datos) llamado \texttt{i} y un caracter
(8 bits de datos) llamado \texttt{b}.

\subsection{Enlazadores}
\index{Enlazadores}
Los enlazadores son programas que enlazan varios módulos objeto y las bibliotecas para formar un único programa coherente.
Los módulos objeto son la sálida en código máquina del ensamblador o del compilador y contienen código máquina ejecutable y datos junto a información que permite al enlazador combinar los módulos para formar un programa.
Por ejemplo, un módulo puede contener todas las funciones de base de datos de un programa, y otro las funciones de manejo de los argumentos de la línea de comandos. Los enlazadores arreglan las referencias entre esto módulos objeto, donde una rutina o estructura de datos referenciados por un módulo está realmente en otro.
El núcleo de Linux es un programa único y grande, enlazado a partir de sus numerosos módulos objeto constituyentes. 

\section{¿Qué es un sistema operativo?}
\index{Sistema Operativo}
Sin el software la computadora es sólo una montaña de componentes electrónicos
que disipa calor.
Si el hardware es el corazón de una computadora, el software es su alma.
Un sistema operativo es una colección de programas del sistema que permiten al
usuario ejecutar aplicaciones.
El sistema operativo hace abstracción del hardware del sistema y presenta
a los usuarios del sistema y a sus aplicaciones una máquina virtual.
En un sentido muy auténtico, el software da el carácter del sistema.
La mayor parte de los PCs pueden ejecutar uno o varios sistemas operativos y cada uno puede tener una apariencia y comportamiento muy diferentes.
Linux está hecho de varias piezas funcionales diferentes que, combinadas, forman el sistema operativo. Una parte obvia del Linux es el núcleo en sí; pero incluso éste sería inútil sin bibliotecas o intérpretes de comandos.

Para empezar a entender qué es un sistema operativo, considere lo que ocurre cuando teclea el comando aparentemente simple:
\begin{verbatim}

$ ls
Mail            c               images          perl
docs            tcl
$ 

\end{verbatim}
El \$ es un inductor puesto por el shell (en este caso \texttt{bash}).
Esto significa que está esperando que usted, el usuario, teclee algún comando.
Escribir \eg{ls} hace que el controlador del teclado reconozca qué teclas han sido pulsadas. El controlador de teclado las pasa al shell que procesa el comando, buscando un ejecutable del mismo nombre. Lo encuentra en \fn{/bin/ls}. Los servicios del núcleo son usados para cargar la imagen ejecutable de \eg{ls} en memoria y empezar a ejecutarla. Ésta realiza llamadas al subsistema de ficheros del kernel para ver qué ficheros están disponibles. El sistema de ficheros puede hacer uso de la información retenida en la cache, o usar el controlador de la unidad de disco para leer esta información desde disco. Puede incluso hacer que un controlador de red intercambie información con una máquina remota a la que tiene acceso (los sistemas de ficheros pueden ser montados remotamente con el {\em Networked File System} o NFS (Sistema de Ficheros en Red)). Independientemente de dónde esté la información, \eg{ls} la escribe y el controlador de vídeo la visualiza en la pantalla.

Todo lo anterior parece bastante complicado, pero muestra que incluso los comandos más sencillos revelan que un sistema operativo está de hecho cooperando con un conjunto de funciones que juntas le dan a usted, el usuario, una visión coherente del sistema.

\subsection{Gestión de memoria}
\index{Gestión de Memoria}
\index{Memoria, Gestión de}
Si los recursos fuesen infinitos, como por ejemplo la memoria, muchas de las cosas que hace un sistema operativo serían redundantes. Uno de los trucos básicos de un sistema operativo es la capacidad de hacer que una memoria física limitada se comporte como más memoria. Esta memoria aparentemente amplia es conocida como memoria virtual. La idea es que el software ejecutándose en el sistema sea inducido a creer que está ejecutándose en un montón de memoria. El sistema divide la memoria en páginas fácilmente gestionadas e intercambia estas páginas con el disco mientras el sistema funciona. El software no lo nota gracias a otro truco, el multi-proceso.

\subsection{Procesos}

\index{Procesos}
\index{Multiproceso}
Se puede pensar en un proceso como en un programa en acción; cada proceso es una entidad separada que está ejecutando un programa en particular. Si se fija en los procesos de su sistema Linux, verá que son bastantes.
Por ejemplo, escribir \eg{ps} muestra los procesos siguientes en mi sistema:
\begin{verbatim}
$ ps
  PID TTY STAT  TIME COMMAND
  158 pRe 1     0:00 -bash
  174 pRe 1     0:00 sh /usr/X11R6/bin/startx
  175 pRe 1     0:00 xinit /usr/X11R6/lib/X11/xinit/xinitrc --
  178 pRe 1 N   0:00 bowman
  182 pRe 1 N   0:01 rxvt -geometry 120x35 -fg white -bg black
  184 pRe 1 <   0:00 xclock -bg grey -geometry -1500-1500 -padding 0
  185 pRe 1 <   0:00 xload -bg grey -geometry -0-0 -label xload
  187 pp6 1     9:26 /bin/bash
  202 pRe 1 N   0:00 rxvt -geometry 120x35 -fg white -bg black
  203 ppc 2     0:00 /bin/bash
 1796 pRe 1 N   0:00 rxvt -geometry 120x35 -fg white -bg black
 1797 v06 1     0:00 /bin/bash
 3056 pp6 3 <   0:02 emacs intro/introduction.tex
 3270 pp6 3     0:00 ps
$     
\end{verbatim}
Si mi equipo tuviera varias CPUs, cada proceso podría (al menos teóricamente) ejecutarse en una CPU distinta. Desafortunadamente, sólo hay una, así que el sistema operativo usa el truco de ejecutar cada proceso en orden durante un corto período de tiempo. Este periodo de tiempo es conocido como fracción de tiempo. Este truco es conocido como multiproceso o planificación y engaña a cada proceso, haciéndole creer que es el único. Los procesos son protegidos el uno del otro para que si uno se cuelga o funciona  incorrectamente no afecte a los demás. El sistema operativo consigue esto dando a cada proceso un espacio de direccionamiento único, al que sólo él tiene acceso.

\subsection{Controladores de unidad}

\index{Unidad, Controladores de}
\index{Controladores de Unidad}
Los controladores de unidad forman la mayor parte del núcleo de Linux. Como otras partes del sistema operativo, operan en un entorno muy privilegiado y pueden causar desastres si hacen las cosas mal. El controlador de la unidad supervisa la interacción entre el sistema operativo y la unidad de hardware que controla. Por ejemplo, el sistema de ficheros usa la interfaz general de unidades por bloques cuando escribe datos a un disco IDE. El controlador se ocupa de los detalles y hace que las cosas específicas de la unidad ocurran. Los controladores de unidad son específicos del chip controlador que están usando; por eso necesita, por ejemplo, un controlador NCR810 SCSI cuando su sistema tiene una controladora NCR810 SCSI.

\subsection{El Sistema de Ficheros}
\index{Ficheros, Sistema de}
\index{Sistema de Ficheros}
En Linux, al igual que en Unix\tm\ , no se accede a los diferentes sistemas de ficheros que el sistema puede usar mediante indentificadores de unidad (como el número de la unidad o su nombre), sino que son combinados en un único árbol jerárquico que representa el sistema de ficheros como una entidad individual.
Linux añade cada sistema de ficheros en su árbol único cuando es montado en un directorio, como por ejemplo \fn{/mnt/cdrom}. Una de las características más importante de Linux es su soporte para muchos sistemas de ficheros diferentes. Ésto lo hace muiy flexible y capaz de coexistir con otros sistemas operativos. El sistema de ficheros más popular de Linux es el \texttt{EXT2}, y éste es el soportado por la mayor parte de las distribuciones de Linux.

Un sistema de ficheros da al usuario una visión ordenada de los ficheros y directorios guardados en los discos duros del sistema, independientemente del tipo de su sistema y de las características de la unidad física subyacente. Linux soporta transparentemente muchos sistemas diferentes (por ejemplo \texttt{MS-DOS} y \texttt{EXT2}) y presenta todos los ficheros y sistemas de ficheros montados como un único árbol virtual.
Por esto, los usuarios y los procesos no necesitan generalmente saber en qué tipo de sistema de ficheros está algún fichero, tan sólo lo usan. 

Los controladores de unidades por bloques diferencian entre los tipos de unidad física (por ejemplo, \texttt{IDE} y \texttt{SCSI}) y, al menos en lo que concierne al sistema de ficheros, las unidades físicas son sólo colecciones lineales de bloques de datos. El tamaño de bloque varía entre las unidades; por ejemplo, 512 bytes es una medida común en los ``floppy disc'', mientras que 1024 son más corrientes en las unidades IDE, y, en general, esto es ocultado a los usuarios del sistema. Un sistema de ficheros \texttt{EXT2} tiene el mismo aspecto, independientemente de la unidad que lo contenga.

\section{Estructuras de datos del núcleo}
El sistema operativo debe guardar mucha información referente al estado actual del sistema. A medida que las cosas van pasando dentro del sistema, estas estructuras de datos deben ser modificadas para ajustarse a la realidad. Por ejemplo, un proceso puede ser creado cuando el usuario entra en el sistema. El núcleo debe crear una estructura de datos que represente al nuevo proceso y enlazarlo a las estructuras de datos que representan a los otro procesos del sistema.

Estas estructuras se guardan sobre todo en la memoria física y son accesibles sólo por el núcleo y sus subsistemas. Las estructuras de datos contienen datos y punteros, es decir la dirección de otras estructuras de datos o de rutinas. Tomadas en su conjunto, las estructuras de datos usadas por el núcleo de Linux pueden parecer muy confusas.Cada estructura de datos tiene su interés y a pesar de que algunas son usadas por varios subsistemas del núcleo, son más sencillas de lo que parecen a primera vista.

Comprender el núcleo de Linux se basa en la comprensión de las estructuras de datos y del uso que las distintas funciones del núcleo hacen de ellos. Este libro basa su descripción del núcleo de Linux en sus estructuras de datos. Habla de cada subsistema del núcleo en términos de sus algoritmos, sus métodos, y su uso de las estructuras de datos del núcleo.

\subsection{Lista Enlazadas}
Linux usa cierto número de técnicas de ingeniería de software para enlazar entre sí las estructuras de datos. Si cada estructura describe una única instancia u ocurrencia de algo, por ejemplo un proceso o una unidad de red, el núcleo debe ser capaz de encontrar el resto. En una lista enlazada un puntero raiz contiene la dirección de la primera estructura de datos, o {\em elemento} de la lista, y cada estructura de datos contiene un puntero al siguiente elemento de la lista. El puntero del último elemento contiene 0 o NULL para mostrar que es el final de la lista. En una lista {\em doblemente enlazada}, cada elemento contiene a la vez un puntero al siguiente elemento y al anterior de la lista. El uso de listas doblemente enlazadas facilita la adición o el borrado de elementos en el medio de la lista, aunque necesita más accesos a memoria. Ésta es una elección a la que se enfrenta a menudo un sistema operativo: accesos a memoria frente a ciclos de CPU.

\subsection{Tablas Hash}
Las listas enlazadas son una manera útil de unir estructuras de datos entre sí, pero recorrerlas puede ser ineficiente. Si estuviese buscando un elemento en particular, podría fácilmente tener que buscar por toda la lista antes de encontrar el que necesita. Linux usa otras técnicas, llamadas {\em técnicas hash}, para evitar estos problemas. Una {\em tabla hash} es un {\em array} o {\em vector} de punteros. Un array es simplemente un conjunto de cosas que vienen una detrás de otra en la memoria. Se podría decir que una estantería es un array de libros. Se accede a los arrays por un {\em índice}; éste es el desplazamiento (offset) dentro del array. Llevando la analogía de la estantería de biblioteca más lejos, podríamos describir cada libro por su posición en la estantería; se puede pedir el quinto libro.

Una tabla hash es una array de punteros a estructuras de datos cuyo índice deriva de la información contenida en éstas. Si tuviese estructuras de datos sobre la población de un pueblo, podría usar la edad de cada persona como índice. Para encontrar los datos de una persona en particular, podría usar su edad como índice de la tabla hash, para seguir a continuación el puntero a la estructura de datos con los detalles de la persona. Desafortunadamente, mucha gente puede tener la misma edad en un pueblo, y el puntero de la tabla hash se puede transformar en un puntero a una lista de estructuras con los datos de personas de la misma edad. Sin embargo, la búsqueda sigue siendo más rápida en estas listas cortas que mirar por todas las estructuras de datos en orden secuencial.

Una tabla hash acelera el acceso a estructuras accedidas con frecuencia; Linux usa frecuentemente las tablas hash para implementar {\em caches}. Los caches son información útil a la que necesita tener un acceso rápido, y son habitualmente una pequeña parte de toda la información disponible. Los datos son almacenados en el cache porque el núcleo accede a ellos con frecuencia. Un inconveniente de los caches es que son más difíciles de usar y de mantener que las listas enlazadas o las tablas hash. Si una estructura de datos puede ser encontrada en el cache (esto es conocido como un {\em acierto de cache}), todo va bien. Si no, debe buscarse por todas las estructuras, y si existe, debe ser añadida al cache. Al añadir nuevos datos al cache, otros datos del cache pueden ser descartados. Linux debe decidir cuáles; el peligro es que el descartado sea el siguiente en ser necesitado.


\subsection{Interfaces Abstractos}
El núcleo de Linux hace a menudo abstracción de sus interfaces. Una interfaz es una colección de rutinas y estructuras de datos que operan de una forma determinada. Por ejemplo, todos los controladores de unidades de red deben proporcionar ciertas rutinas que operan sobre las estructuras de datos.
De esta forma las partes genéricas del código pueden usar los servicios (interfaces) de las partes espécificas. La parte de red, por ejemplo,  es genérica y la soporta el código específico de la unidad conforme a la interfaz estandar.

A menudo estos niveles inferiores se {\em registran} en los superiores durante el arranque. Este registro normalmente consiste en añadir una estructura de datos a una lista enlazada. Por ejemplo cada sistema de ficheros del núcleo se registra durante el arranque, o, si usa módulos, cuando es usado por primera vez. Puede ver qué sistemas de ficheros se han registrado viendo el fichero \fn{/proc/filesystems}. El registro de estructuras de datos incluye a menudo punteros a funciones. Éstos representan las direcciones de las funciones que hacen tareas específicas. Tomando de nuevo el sistema de ficheros como ejemplo, la estructura de datos que cada sistema de ficheros pasa al núcleo de Linux cuando se registra incluye la dirección de una rutina específica que debe ser llamada cada vez que este sistema de ficheros es montado.



