<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<article lang="es">

<articleinfo>

<title>CODA COMO</title>

<authorgroup>
	<author>
		<firstname>Iñaki</firstname>
		<surname>Fernández Villanueva</surname>
		<affiliation><address><email>iniaki@mail.com</email></address></affiliation>
	</author>
	<author>
		<firstname>Javier</firstname>
		<surname>Ruiz González</surname>
		<affiliation><address><email>javierrg77@yahoo.es</email></address></affiliation>
	</author>
	<author>
		<firstname>Josu</firstname>
		<surname>Abajo Marón</surname>
		<affiliation><address><email>jabajo00@yahoo.es</email></address></affiliation>
	</author>
</authorgroup>

<pubdate>v1.0, Mayo 2000</pubdate>

<abstract>

<para>
El objetivo de este documento es mostrar las características básicas
del Sistema de Ficheros Distribuido Coda. También trata su instalación y configuración en un PC con Linux (Debian y Red Hat). No es una traducción
de <emphasis remap="it">The Coda Howto</emphasis> <literal remap="tt">(<ulink
url="http://coda.cs.cmu.edu/doc/html/coda-howto.html"
>http://coda.cs.cmu.edu/doc/html/coda-howto.html</ulink
>)</literal>, sino de un COMO redactado por sus autores que también incluye traducciones de otros documentos citados en la bibliografía.
</para>

</abstract>

</articleinfo>

<sect1>
<title>Copyright y propiedad intelectual</title>

<para>
Este COMO es Copyright &copy; 2000 Iñaki Fernández Villanueva &amp;
Javier Ruíz Martínez &amp; Josu Abajo Marón. Todos los derechos reservados.
</para>

<para>
Este trabajo puede ser reproducido en su totalidad o en parte, tanto de
forma impresa como electrónica, sujeto a las siguientes condiciones:
</para>

<para>

<orderedlist>
<listitem>

<para>
La notificación del copyright y esta licencia debe preservarse
completa en todas las copias, tanto completas como parciales.

</para>
</listitem>
<listitem>

<para>
Cualquier traducción o trabajo derivado debe de ser
aprobado por los autores por escrito antes de su distribución.

</para>
</listitem>
<listitem>

<para>
Si se distribuye el Trabajo parcialmente, deben de incluirse
instrucciones de dónde obtener la versión completa original (en forma
impresa o electrónica), así como los medios para conseguirla. 

</para>
</listitem>
<listitem>

<para>
Pueden ser reproducidas pequeñas porciones como ilustraciones para
revistas o citas para otros trabajos sin esta notificación de permiso si
se cita apropiadamente su procedencia. 
</para>
</listitem>

</orderedlist>

</para>

</sect1>

<sect1>
<title>Renuncia de responsabilidad</title>

<para>
Este documento intenta ser una introducción a la instalación y 
configuración de Coda así como de su funcionamiento. Los autores de este 
documento NO SE HACEN RESPONSABLES DE NINGÚN DAÑO PRODUCIDO POR ACCIONES 
CON BASE EN ESTE DOCUMENTO, el cual puede contener erratas y/o fallos. 
</para>

</sect1>

<sect1>
<title>Dónde obtener este COMO</title>

<para>
Puede obtener la última versión de este documento en el sitio web del
proyecto Insflug <literal remap="tt"><ulink
url="http://www.insflug.org"
>http://www.insflug.org</ulink
></literal>
</para>

</sect1>

<sect1>
<title>Introducción</title>

<para>
Un sistema de ficheros distribuido almacena ficheros en uno o más
ordenadores sincronizados entre sí llamados servidores, y los hace
accesibles a otros ordenadores llamados clientes, para quienes el acceso a
estos ficheros es transparente. La principal ventaja es la compartición de
ficheros y su gestión centralizada desde los servidores (como por ejemplo
el control de acceso y la gestión de copias de seguridad). Esta
compartición de ficheros es especialmente útil para grupos de trabajo que
comparten documentos, aunque también es posible compartir software, como
por ejemplo, un procesador de textos. 
</para>

<para>
Un buen sistema de ficheros distribuido debe tener en cuenta cosas tan
importantes como la latencia de la red, los posibles cuellos de botella y
sobresaturación del servidor, la seguridad de datos comprometidos y los
posibles fallos de red y servidores. Evidentemente todo esto toma especial
importancia en el caso de que el sistema funcione bajo una <emphasis remap="it">WAN</emphasis>.
</para>

<para>
El Sistema de Ficheros Distribuido Coda es el sucesor de <emphasis remap="it">Andrew File
System</emphasis> (<emphasis remap="bf">AFS</emphasis>) y es un desarrollo de la Universidad de
Carnegie-Mellon como ejemplo de entorno de trabajo distribuido. Coda
destaca sobre AFS por permitir la Computación Móvil (trabajar en modo
desconectado), soportar mejor la tolerancia a fallos del sistema (por
ejemplo caída de los servidores o fallos de la red) y por disponer de
técnicas de replicación de los servidores. Al ser gratuito, su código
fuente está disponible (la licencia de Coda se puede encontrar en 
<literal remap="tt"><ulink
url="ftp://ftp.coda.cs.cmu.edu/pub/coda/LICENSE"
>ftp://ftp.coda.cs.cmu.edu/pub/coda/LICENSE</ulink
></literal>) y está 
diseñado para trabajar tanto en <emphasis remap="it">LAN</emphasis> como en <emphasis remap="it">WAN</emphasis>. 
</para>

<para>
Coda se implementó originalmente en <emphasis remap="bf">Mach 2.6</emphasis> y ha sido portado
recientemente a <emphasis remap="bf">Linux</emphasis>, <emphasis remap="bf">NetBSD</emphasis> y <emphasis remap="bf">FreeBSD</emphasis>.
También se está portando a Windows95/NT, pero el estado de desarrollo es
menor.
</para>

<para>
La Computación Móvil &lsqb;MAR99] permite por ejemplo que un usuario pueda 
trabajar con su portátil enganchado a la red Coda, llevárselo a su casa
para trabajar con él, y cuando vuelva a conectarse a la red los datos se
reintegrarán automáticamente, sin que el usuario se percate de ello
(entendiendo por reintegrar el proceso en el que tras una reconexión se
ponen al día en los servidores los cambios realizados por el cliente
durante la desconexión).
</para>

<sect2>
<title>El cliente Coda </title>

<para>
&lsqb;BRA98] Bajo el directorio <literal remap="tt">/coda</literal> el cliente monta un sistema 
de ficheros de tipo «Coda», desde donde se accederán a todos los
ficheros del Sistema Coda. Un cliente se conecta a todo el sistema Coda y
no a un servidor individual como ocurre en NFS, donde existe un único
directorio o punto de montaje por servidor. La ventaja de un sólo punto
de montaje reside en que todos los clientes pueden ser configurados de
forma idéntica, y en que los usuarios siempre verán el mismo árbol de
ficheros. Con NFS los clientes necesitan actualizar la lista de
servidores y la ruta de directorios que exportan en <literal remap="tt">/etc/fstab</literal>,
mientras que en Coda los clientes sólo deben acceder al directorio
<literal remap="tt">/coda</literal> para ver los cambios incluso cuando se añaden nuevos
servidores. En las dos siguientes figuras se aprecia la diferencia
funcional entre un sistema NFS y un sistema Coda &lsqb;MAR99]:
</para>

<para>

<screen>
Sistema de Ficheros Distribuido, entorno Cliente-Servidor NFS:

	                        RED
	      +---------+     +-----+
	      |         |     |     |
	      |Servidor |&#60;----|-----|-------&#62;Cliente 1
	      |  NFS 1  |&#60;----|-----|--+    
	      |         |     |     |  |
	      +---------+     |     |  +----&#62;Cliente 2
	                      |     |  |
                              |     |  |
              +---------+     |     |  |
	      |         |     |     |  |
	      |Servidor |&#60;----|-----|--+
	      |  NFS 2  |&#60;----|-----|-------&#62;Cliente 3
	      |         |     |     |
	      +---------+     +-----+

Sistema de Ficheros Distribuido, entorno Coda:

	      Sistema Coda
	    +-------------+       RED
	    | +---------+ |     +-----+
	    | |         | |     |     |
	    | |Servidor | |&#60;----|-----|-------&#62;Cliente 1
	    | | Coda 1  | |     |     |
	    | |         | |     |     |  
	    | +----+----+ |&#60;----|-----|-------&#62;Cliente 2
	    |      |      |     |     |  
	    |      |      |     |     |  
	    | +----+----+ |     |     |  
	    | |         | |     |     |  
	    | |Servidor | |     |     |
	    | | Coda 2  | |&#60;----|-----|-------&#62;Cliente 3
	    | |         | |     |     |
	    | +---------+ |     +-----+
	    +-------------+
</screen>

</para>

<para>
La implementación de Coda en Linux está constituida por un conjunto de
demonios que se ejecutan en los servidores, normalmente llamados
<emphasis>Vice</emphasis>, y un demonio (<emphasis><emphasis remap="bf">Venus</emphasis></emphasis>) más un módulo del
<emphasis remap="it">Núcleo</emphasis> en la parte del cliente. La comunicación se establece
entre los demonios, siendo el módulo del <emphasis remap="it">núcleo</emphasis> la interfaz
entre el Sistema Coda y el <emphasis remap="bf">VFS</emphasis> (<emphasis remap="it">Virtual File System</emphasis>)
de Linux. 
</para>

<para>
Cuando un usuario intenta leer un fichero del Sistema Coda (por ejemplo
con <literal remap="tt">cat /coda/users/user15/doc.txt</literal>) el programa cat realizará
unas llamadas al sistema relacionadas con el fichero, que se comunicarán
con el VFS del <emphasis remap="it">núcleo</emphasis>. El VFS comprueba entonces que la petición
se refiere a un fichero Coda, y encamina la petición al módulo del sistema
de ficheros Coda en el <emphasis remap="it">Núcleo</emphasis> (<emphasis remap="it">Coda FS</emphasis>). Este módulo
mantiene una caché de peticiones recientes resueltas, y si la respuesta no
se encuentra en esta caché, se encamina de nuevo la petición al gestor de
caché Coda Venus (a través del dispositivo de caracter
<literal remap="tt">/dev/cfs0</literal>). Venus comprobará si el fichero
<literal remap="tt">user15/doc.txt</literal> se encuentra en una segunda caché, almacenada en
disco, y en caso contrario contactará con los servidores (<literal remap="tt">Vice</literal>)
para obtenerlo. Una vez conseguido el fichero, Venus responderá al
<emphasis remap="it">núcleo</emphasis>, quien devolverá la respuesta al programa <literal remap="tt">cat</literal>. 
</para>

<para>
Cuando el <emphasis remap="it">núcleo</emphasis> solicita a Venus la apertura de un fichero
por primera vez, éste obtiene el fichero completo de los servidores
utilizando las llamadas a procedimientos remotos (RPC) para comunicarse
con los ellos. Después almacena el fichero en el área de caché (en el
directorio <literal remap="tt">/usr/coda/venus.cache/</literal>), desde donde será controlado
por el sistema de ficheros <literal remap="tt">ext2</literal> de Linux. Si un fichero ya se
encuentra en la caché del cliente, Venus permitirá trabajar con él sin
contactar con los servidores, de modo que si el fichero se abre una
segunda vez, no se obtendrá del almacén remoto (trabajo en modo
desconectado) sino de la caché.
</para>

<para>
Así pues, Venus sólo almacena aquella información que necesita el
cliente, como ficheros o directorios (los directorios en Linux son
ficheros) y sus atributos (propietario, permisos y tamaño). Si el fichero
ha sido modificado y cerrado, entonces Venus actualiza los servidores
enviándoles el nuevo fichero. Cualquier otra operación que modifique el
sistema de ficheros (como la creación o eliminación de directorios y
enlaces -<emphasis remap="it">links</emphasis>-) se propagará también a los servidores. 
</para>

<para>
Coda ofrece distintos niveles de seguridad mediante <emphasis remap="bf">Kerberos</emphasis>: no
cifrar; cifrar sólo los paquetes de protocolo interno; cifrar además las
cabeceras de los mensajes; y cifrado completo.
</para>

</sect2>

<sect2>
<title>Las operaciones desconectadas </title>

<para>
Si el cliente está desconectado e intenta actualizar un fichero que tiene
en la caché, Venus se da cuenta que los servidores no están
disponibles, se declara en modo desconectado y registra los cambios
realizados en el <emphasis remap="bf">CML</emphasis> (<emphasis remap="it">Client Modification Log</emphasis> o Registro
de Modificación del Cliente) sobre el sistema de ficheros para
actualizarlos en los servidores durante la
siguiente conexión. Este proceso es transparente para el usuario, quien no
se percata que ha cambiado a modo desconectado. Asimismo el CML está
optimizado (por ejemplo, si un fichero es creado y luego borrado, se
eliminan estos pasos del CML). 
</para>

<para>
En ocasiones un cliente intenta acceder a un fichero que no tiene en su
caché. Si está conectado lo consigue de los servidores, pero si no lo
está, no hay nada que hacer y se devuelve un error al programa que haya
hecho la petición. Para evitarlo existen los <emphasis remap="bf">ficheros HOARD</emphasis>, que son
un conjunto de ficheros relativamente importantes establecidos por el
usuario que se mantienen en la caché. El usuario define la base de datos
de ficheros HOARD, y puede solicitar a los servidores las últimas
actualizaciones antes de desconectarse. Esta base de datos la puede
construir automáticamente el sistema haciendo un seguimiento de los
accesos que hace el usuario. Los ficheros Hoard permiten, por ejemplo, que
un cliente forzar la carga del caché local antes de entrar en modo
desconectado, y tener la garantía de que todo lo que necesita estará en
su portátil tras la desconexión.
</para>

<para>
Puede ocurrir que dos o más clientes hayan actualizado el mismo fichero
cuando estaban en modo desconectado. Cuando los clientes se conecten se
producirá un <emphasis remap="bf">conflicto LOCAL/GLOBAL</emphasis> entre cliente y servidor y
se debe decidir por una de las actualizaciones. Para «reparar» este
conflicto, el usuario dispone de la orden <literal remap="tt">repair</literal>. La reparación
la puede realizar a veces automáticamente «reparadores» específicos de la
aplicación (por ejemplo, si dos usuarios modifican registros distintos de
una misma base de datos, la propia base de datos los actualizaría sin que
existiera un posible conflicto).
</para>

</sect2>

<sect2>
<title>Volúmenes, servidores y replicaciones.</title>

<para>
Los servidores Coda no almacenan los ficheros en un sistema de ficheros
tradicional. En lugar de disco, partición o directorio, se utiliza el
concepto de <emphasis><emphasis remap="bf">volumen</emphasis></emphasis>. Físicamente &lsqb;MAR99] representa un 
grupo de ficheros 
mapeados
en memoria por el demonio servidor <literal remap="tt">codasrv</literal>, que contienen la
información almacenada en dicho volumen. Los volúmenes proporcionan mayor
flexibilidad al administrador, y su tamaño medio aproximado es de 10 MB,
llegando a existir cientos de volúmenes por servidor.
</para>

<para>
<emphasis remap="bf">RVM</emphasis> (<emphasis remap="it">Recoverable Virtual Memory</emphasis> o Memoria Virtual Persistente)
registra la información de
volúmenes y directorios, listas de control de accesos y atributos de los
ficheros en particiones «crudas»
<footnote>

<para>
<emphasis remap="it">raw</emphasis> en inglés, 
aquellas que tienen escrituras síncronas
</para>

</footnote>
(<emphasis remap="it"> raw</emphasis> en inglés, aquellas que tienen escrituras síncronas).
En caso de una caída del host repara el sistema accediendo a
la información de estas particiones, consiguiendo velocidad y
consistencia. Hay dos particiones crudas: <emphasis remap="it">Log Partition</emphasis> y
<emphasis remap="it">Data Partition</emphasis>.
</para>

<para>
Existe un volumen raíz que se monta bajo <literal remap="tt">/coda</literal>, desde donde se
montan el resto de los volúmenes. Obviamente este volumen es propiedad del
administrador Coda. Un volumen tiene un nombre y un identificador <emphasis>Id</emphasis>,
y se monta en cualquier subdirectorio de <literal remap="tt">/coda</literal> (por ejemplo el
volumen de un usuario <literal remap="tt">users.user15</literal> se puede montar bajo
<literal remap="tt">/coda/users/user15</literal>). Cada fichero se identifica con un
identificador <literal remap="tt">Fid</literal> único en un sistema Coda y está compuesto 
por tres enteros de 32 bits:
</para>

<para>
<variablelist>

<varlistentry>
<term>VolumeId:</term>
<listitem>
<para>
identifica el volumen en el que reside el fichero.  
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>VnodeId:</term>
<listitem>
<para>
número de inodo del fichero. 
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Uniquifier:</term>
<listitem>
<para>
identificador necesario para la resolución de conflictos. 
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Un volumen replicado es aquél que está almacenado en un grupo de
servidores que pertenecen al mismo <emphasis remap="bf">VSG</emphasis> (<emphasis remap="it">Volume Storage
Group</emphasis>), de modo que cualquier operación sobre los ficheros de ese volumen
afectará a todo el VSG al que pertenece (lo cual no supone mucho
coste, ya que Coda implementa difusión
<footnote>

<para>
<emphasis remap="it">multicast</emphasis> en inglés
</para>

</footnote>
-<emphasis remap="it">multicast</emphasis> en 
inglés-).El objetivo de esto es la alta
disponibilidad del volumen. Asimismo existe el subgrupo <emphasis remap="bf">AVSG</emphasis>
(<emphasis remap="it">Available VSG</emphasis>), que son aquellos servidores accesibles y
pertenecientes a un mismo VSG (puede ocurrir por ejemplo que uno de
los servidores del VSG se averíe, con lo cual deja de ser accesible y
deja de pertenecer al AVSG). Otros tipos de volúmenes son los locales
(no replicados) y volúmenes <emphasis remap="it">backup</emphasis>. Los volúmenes <emphasis remap="it">backup</emphasis> permiten
realizar copias de seguridad del Sistema de Ficheros Coda; sin embargo no se 
tratará en este documento. 
</para>

<para>
La replicación de servidores puede provocar <emphasis remap="bf">conflictos globales</emphasis> cuando 
el número de servidores que forman parte de un mismo AVSG es inferior al
VSG (por ejemplo si las máquinas de un VSG son separados de los
demás por una caída de la red). En este caso las actualizaciones de los
ficheros no pueden propagarse a todos los miembros del VSG y es
necesario resolver el conflicto con la orden <literal remap="tt">repair</literal> (muchas
veces sólo hay que decirle a Coda que lo repare como cuando hay que
sustituir un disco duro y el sistema se encarga de actualizarlo).
</para>

</sect2>

<sect2>
<title>Aplicaciones de Coda</title>

<para>
En Internet, las réplicas de <emphasis remap="bf">servidores FTP</emphasis> podrían ser clientes Coda
que se actualizarían cada vez que los servidores Coda sufrieran cualquier
modificación. Lo mismo pasaría con la réplica de <emphasis remap="bf">servidores WWW</emphasis>, 
los cuales también pueden ser clientes Coda (los cuales pueden ser
optimizados guardando en su caché local todos los datos a replicar). En
ambos casos NFS es inadecuado ya que está diseñado para un entorno
<emphasis remap="it">LAN</emphasis>, y hasta la aparición de Coda eran necesarias herramientas de
sincronización entre servidores como <literal remap="tt">rsync</literal>, que periódicamente
contrastan las diferencias entre nodos y actualizan las diferencias. La
computación móvil de Coda también puede ser aprovechada para aquellos
clientes de proveedores de Internet que actualizan su página Web tras
diseñarla en modo desconectado.
</para>

<para>
En las redes locales un usuario podría, por ejemplo, conectarse al sistema
Coda cargando en su caché local los datos que vaya a utilizar ese día
(promoviendo el acceso a servicios locales frente a remotos, lo cual
incrementa el rendimiento disminuyendo los costes de comunicación),
desconectarse <literal remap="tt">*</literal>
<footnote>

<para>
Sin desconectarse también se consigue aumentar el rendimiento, ya que
siempre es más eficiente trabajar sobre una caché local que sobre un
fichero remoto (tal y como ocurre en NFS)
</para>

</footnote>
y, cuando
acabe el día, volver a conectarse para reintegrar los cambios efectuados.
</para>

<para>
 <literal remap="tt">*</literal>: sin desconectarse también se consigue aumentar
el rendimiento, ya que siempre es más eficiente trabajar sobre una caché
local que sobre un fichero remoto (tal y como ocurre en NFS).
</para>

</sect2>

<sect2>
<title>Desventajas </title>

<para>
&lsqb;MAR99] Debido a sus características Coda tiene una serie de desventajas
(algunas ya mencionadas):
</para>

<para>

<itemizedlist>
<listitem>

<para>
Las operaciones de bloqueo de ficheros no están implementadas debido
a que no es posible un algoritmo de bloqueo que tenga en cuenta un
funcionamiento en modo desconectado.
</para>
</listitem>
<listitem>

<para>
Existe un problema de sincronización intrínseco al modo
desconectado: cuando al reconectar un cliente, un fichero ha cambiado
tanto en el cliente como en el servidor, ¿cúal es la versión que se debe
sincronizar con el resto del sistema?. Existen diversos algoritmos, pero
frecuentemente se requiere la mano del operador.
</para>
</listitem>
<listitem>

<para>
La implementación de cuotas es limitada y sólo existe para los
directorios (no existen cuotas para usuarios). Para solucionarlo se puede
asignar un volumen por usuario, pero cambiar la cuota a un usuario es
complicado porque los volúmenes Coda no son redimensionables. 
</para>
</listitem>
<listitem>

<para>
Coda no es estable y actualmente no se soportan bien volúmenes de
más de 100 usuarios, ni mezcla de servidores Coda que no estén replicados 
(cada servidor Coda sirviendo un volumen independiente). 
</para>
</listitem>
<listitem>

<para>
Todas las operaciones de administración deben hacerse desde un
cliente Coda sin que se pueda trabajar directamente con los volúmenes.
Esto dificulta enormemente las tareas de mantenimiento y administración.
</para>
</listitem>
<listitem>

<para>
Una máquina no puede ser a la vez cliente y servidor Coda.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

</sect1>

<sect1>
<title>Instalación y configuración</title>

<sect2>
<title>Dónde obtener los binarios de Coda</title>

<para>
Todos los servidores deben tener la misma versión Coda para evitar
problemas. La versión de los clientes puede ser anterior a la de los
servidores pero mayor que una dada (dependiendo de la versión del
servidor, aunque es conveniente que todas las versiones coincidan).
</para>

<para>
También es aconsejable instalar Coda a partir de los paquetes binarios
para evitar compilar el código fuente. Existen binarios para las dos
distribuciones Linux más utilizadas, Debian <literal remap="tt"><ulink
url="http://www.debian.org"
>http://www.debian.org</ulink
></literal> y Red Hat
<literal remap="tt"><ulink
url="http://www.redhat.com"
>http://www.redhat.com</ulink
></literal>. El código fuente se puede obtener
junto a los binarios de Red Hat en <literal remap="tt"><ulink
url="ftp://ftp.coda.cs.cmu.edu/pub/coda"
>ftp://ftp.coda.cs.cmu.edu/pub/coda</ulink
></literal>, y los binarios de Debian
de <literal remap="tt"><ulink
url="ftp://ftp.debian.org/debian/project/experimental"
>ftp://ftp.debian.org/debian/project/experimental</ulink
></literal>. Estos
paquetes binarios tienen unas dependencias o requisitos y deben ser 
compatibles con la versión de Linux en la que queremos
instalar Coda. Por ejemplo en Debian se puede conocer las
dependencias de un paquete binario con 

<screen>
dpkg --info nombrePaquete.deb
</screen>
,
y si nuestro sistema Linux lo cumple lo podremos instalar sin problemas. 
</para>

<para>
En este informe se ha utilizado la versión 5.2.0-1 de Coda bajo Debian 2.1
<emphasis remap="it">slink</emphasis>. Existe en binario la versión 5.3.1-1 para Debian 2.2, pero
hemos optado por la primera para evitar actualizar Linux. Aún así
suponemos que entre ambas versiones no existen cambios importantes en la
instalación y administración. 
</para>

<para>
También hemos trabajado con la versión Coda de Red Hat, aunque
recomendamos la de Debian por ser más fácil su instalación y
administración. Por ejemplo, en Debian el programa de instalación pasa
automáticamente a su configuración y el servidor Coda se lanza con el
script <literal remap="tt">/etc/init.d/coda-server</literal>, mientras que en Red Hat son
varios los scripts.
</para>

</sect2>

<sect2>
<title>Sincronización de los servidores</title>

<para>
Los servidores deben estar sincronizados en fecha y hora. Para lograrlo
hemos optado por <literal remap="tt">XNTP</literal>, basado en sincronización externa <literal remap="tt">UTC</literal>
(Tiempo Universal Coordinado). En el caso de dos servidores Coda hay que
añadir las siguientes líneas en sus ficheros de configuración
<literal remap="tt">ntp.conf</literal> del programa <literal remap="tt">xntp</literal> (en Debian este fichero se
encuentra en el directorio <literal remap="tt">/etc/</literal>):
</para>

<para>
<variablelist>

<varlistentry>
<term>Servidor Coda 1:</term>
<listitem>
<para>

<screen>
server máquinaServidorXntp1		
server máquinaServidorXntp2		
peer  servidorCoda2		        
</screen>

</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Servidor Coda 2:</term>
<listitem>
<para>

<screen>
server máquinaServidorXntp1
server máquinaServidorXntp2
peer servidorCoda1
</screen>

</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Las dos primeras líneas de cada configuración especifican con qué servidor
o servidores xntp se sincronizan. Si por redundancia se sincronizan con
más de un servidor xntp como en el ejemplo, estos servidores deben tener
el mismo nivel xntp garantizando la sincronización entre sí. La tercera
línea 

<screen>
peer servidorCodax
</screen>
 asegura la
sincronización entre los dos servidores Coda en el caso de que se pierda
la comunicación con los servidores xntp (es importante mantener bien
sincronizados los relojes locales del sistema distribuido). 
</para>

</sect2>

<sect2>
<title>Instalación de los Servidores</title>

<para>
De todos los servidores Coda sólo uno puede ser el servidor 
<emphasis remap="bf"><literal remap="tt">SCM</literal></emphasis>, desde donde se administra el sistema de volúmenes y las
cuentas de usuario. 
</para>

<para>
Se explicarán los procesos de instalación y configuración de las versiones
5.2.0-1 para Red Hat y Debian. Nótese que para la instalación y
configuración de los servidores es necesario ser el superusuario del
sistema Linux.
</para>

<sect3>
<title>Servidor SCM en Red Hat</title>

<para>
Se procederá a instalar el paquete, para lo que introduciremos por la
línea de órdenes:
</para>

<para>

<screen>
# rpm -i coda-debug-server-5.2.0-1.i386.rpm
</screen>

</para>

<para>
Una vez instalado el servidor, iniciaremos su configuración, la cual
difiere entre el servidor maestro SCM y el resto de servidores.
</para>

<para>

<screen>
# vice-setup
</screen>

</para>

<para>
A continuación se detalla el proceso de configuración con
<literal remap="tt">vice-setup</literal>. Introducimos una cadena de 8 caracteres (debe ser
exactamente de 8 caracteres para evitar problemas causados por un posible
<emphasis remap="it">bug</emphasis> de Coda). Un ejemplo puede ser <literal remap="tt">elephant</literal>:
</para>

<para>

<screen>
Setting up config files (under /vice).
Directories under /vice are set up.

Setting up tokens for authentication.
The following tokens must be identical on all servers.
Enter a random token for auth2 authentication : elephant
</screen>

</para>

<para>
Introducimos, al igual que antes, una cadena de exactamente 8 caracteres. 
Debe ser distinta a la anterior (otro <emphasis remap="it">bug</emphasis>), por ejemplo,
<literal remap="tt">elephann</literal>:
</para>

<para>

<screen>
The following tokens must be identical on all servers.
Enter a random token for volutil authentication : elephann
</screen>

</para>

<para>
A partir de aquí empiezan las diferencias entre la configuración del
servidor maestro y del resto de servidores. Contestar «y» si se trata del
maestro y «n» en el caso de un servidor normal. Continuaremos como si
hubiéramos contestado «y» a esta pregunta , y posteriormente comentaremos
las diferencias que habría si se tratase de un servidor no SCM:
</para>

<para>

<screen>
tokens done!

Setting up the file list for update
filelist for update ready.

Populating /vice/vol...
lockfiles created.
/etc/services ready for Coda
Is this the master server, aka the SCM machine? (y/n) y
</screen>

</para>

<para>
Introduciremos un identificador para el servidor, por ejemplo el '1'. Esta
pregunta se hará solamente al configurar el SCM, por lo que el resto
de servidores habrá que añadirlos directamente en el fichero
<literal remap="tt">/vice/db/servers</literal> del SCM:
</para>

<para>

<screen>
Now installing files specific to the SCM...

Setting up servers file.
Enter an id for this server (a number &#62; 0 &#60; 255) : 1
</screen>

</para>

<para>
Aquí se establece el VSG (<emphasis remap="it">Volume Storage Group</emphasis>) del servidor
que se está configurando, asignándosele un identificador (el valor por
defecto es el <literal remap="tt">E0000100</literal>). Toda la información correspondiente a
los grupos de servidores se guarda en el fichero <literal remap="tt">/vice/db/VSGDB</literal>.
Si se quiere añadir un nuevo servidor a un grupo de servidores, o se
quiere incluir un nuevo grupo, habrá que hacerlo editando directamente
este archivo del SCM:
</para>

<para>

<screen>
done!
Initializing the VSGDB to contain the SCM as E0000100
/vice/db/VSGDB set up
</screen>

</para>

<para>
Se pide el nombre del <emphasis remap="it">rootvolume</emphasis>, que es el volumen que se
montará como raíz en los clientes. Un posible valor es
<literal remap="tt">coda:root</literal>.
</para>

<para>

<screen>
Setting up ROOTVOLUME file
Enter the name of the rootvolume (&#60; 32 chars) : coda:root
</screen>

</para>

<para>
En este paso se debe introducir un identificador de usuario que será el
administrador del sistema. Este identificador deberá ser obligatoriamente
<literal remap="tt">500</literal>.
</para>

<para>

<screen>
Setting up users and groups for Coda

You need to give me a uid (not 0) and username (not root)
for a Coda System:Administrator member on this server,
(sort of a Coda super user)

Enter the uid of this user:500
</screen>

</para>

<para>
Ahora hay que darle un nombre a la cuenta del administrador Coda (el
nombre con que trabajaremos será <literal remap="tt">admin</literal>). 
</para>

<para>

<screen>
Enter the username of this user: admin
</screen>

</para>

<para>
Se ha creado el nuevo usuario (nombre de usuario <literal remap="tt">admin</literal> e 
identificador <literal remap="tt">500</literal>), que tendrá su contraseña inicializada a
<literal remap="tt">changeme</literal>. Si se quiere cambiar habrá que utilizar o bien
<literal remap="tt">cpasswd</literal> o la utilidad de administración de usuarios
<literal remap="tt">au</literal>.
</para>

<para>

<screen>
An initial administrative user admin (id 500)
with Coda password changeme now exists.
</screen>

</para>

<para>
Aquí se pregunta si se quieren configurar las particiones RVM del
servidor. Durante la instalación de cada servidor Coda es aconsejable
dedicar 2 particiones tipo ext2 por razones de eficiencia (en otro caso se
tratará como ficheros). Ambos ficheros forman la RVM usada para lograr una
persistencia de la memoria virtual del host en caso de una caída:
</para>

<para>

<screen>
You need a small log disk partition, preferrably on a disk by itself.
You need a metadata partition of approx 4% of you filespace.

For trial purposes you may give oridnary files instead of raw
partitions. Keep all size small if you do this.
Production servers will want partitions for speed.

-------------------------------------------------------
WARNING: you are going to play with your partitions now.
verify all answers you give.
-------------------------------------------------------

WARNING: these choices are not easy to change once you are up and
running.
Are you ready to set up RVM? [yes/no] yes
</screen>

</para>

<para>
Hay que indicar cual es la partición o fichero que se va a utilizar como
<emphasis remap="it">log</emphasis> (por ejemplo <literal remap="tt">/dev/hda4</literal> para una partición o
<literal remap="tt">/codap/logpartition</literal> en el caso de un fichero):
</para>

<para>

<screen>
What is your log partition? /dev/hda4
</screen>

</para>

<para>
En la partición de <emphasis remap="it">log</emphasis> (<emphasis remap="it">log partition</emphasis>) se registran las
transacciones de volúmenes coda que quizás no hayan sido aún actualizadas
en la partición de datos coda. No debe sobrepasar los 30MB (el sistema
coda no ha sido puesto a prueba con tamaños mayores a éste) y es
aconsejable tener una partición de 2MB (lo merjo es ceñirse a lo que se
indica en la instalación). Nunca se debe tener una partición menor que el
tamaño indicado en la instalación (por ejemplo si la partición es de
11.6MB y en la instalación se indica que tiene 12MB, puede fallar la
instalación): 
</para>

<para>

<screen>
The log size must be smaller than you log partition. 
We recommend not more than 30M log size, and 2M is a good choice.
What is your log size? (enter as e.g. '12M') 2M
</screen>

</para>

<para>
Elección de la partición de datos RVM (<emphasis remap="it">data partition</emphasis>). Indicar una
partición (<literal remap="tt">/dev/hdxx</literal>) o el nombre de un archivo:
</para>

<para>

<screen>
What is your data partition (or file)? /dev/hda5
</screen>

</para>

<para>
Se indicará el tamaño de la partición de datos. Recomendamos
encarecidamente que se utilice uno de los valores dados por el
<emphasis remap="it">script</emphasis>, ya que únicamente así se hará una configuración válida de las
particiones (si se opta por poner otro tamaño de partición se deberá
inicializar la partición de datos mediante el programa <literal remap="tt">rdsinit</literal>.
Este programa es difícil de manejar, siendo aconsejable poner el tamaño
de la partición que viene por defecto en la instalación). Si se pone una
partición menor que 22MB puede fallar la instalación. El script es muy
sensible a las mayúsculas y minúsculas, por lo que es importante poner
<literal remap="tt">22M</literal> y no <literal remap="tt">22m</literal> al indicar el tamaño de la partición:
</para>

<para>

<screen>
The data size must be approx 4% of you server file space.
We have templates for servers of approx: 500M, 1G, 2.2G, 3.3G,8G
(you can store less, but not more on such servers).
The corresponding data sizes are  22M, 44M, 90M, 130M, 315M.
(use 330M only on very fast machines)
Pick one of the defaults, otherwise I will bail out

What is the size of you data partition (or file) [22M,44M, 90M,130M, 315M]: 
22M
</screen>

</para>

<para>
Aquí se pide confirmación para inicializar las particiones. Si se ha
configurado bien saldrá lo siguiente:
</para>

<para>

<screen>
--------------------------------------------------------
WARNING: DATA and LOG partitions are about to be wiped.
--------------------------------------------------------

  --- log area: /dev/hda4, size 2M.
  --- data area: /dev/hda5, size 22M.

Proceed, and wipe out old data? [y/n]  y
</screen>

</para>

<para>
Se pregunta por el nombre del directorio en el que se guardarán los datos
de los volúmenes coda. Pulse «intro» para que el directorio por defecto
sea <literal remap="tt">/vicepa</literal>:
</para>

<para>

<screen>
LOG file has been initialized!

Rdsinit will initialize data and log.
This takes a while.

Your server directories will hold the files (not directories).
You can currently only have one directory per disk partition.

Where shall we store your data [/vicepa]? 
</screen>

</para>

<para>
Pregunta por el número aproximado de entradas de fichero que se van a
tener:
</para>

<para>

<screen>
Shall I set up a vicetab entry for approx 256000 files for y (y/n)  y
</screen>

</para>

<para>
Una vez termine la ejecución de <literal remap="tt">vice-setup</literal> habrá que levantar
los servicios Coda ejecutando los correspondientes demonios: 
</para>

<para>

<screen>
Read vicetab(5) and makeftree(8) for set up info.
Server directory is set up!

Congratulations: your configuration is ready...and now
to get going do the following:
 - start the auth2 server as: auth2
 - start rpc2portmap as: rpc2portmap
 - start updateclnt as:  updateclnt -h ha0 -q coda_udpsrv
 - start updatesrv as: updatesrv -p /vice/db
 - start the fileserver: startserver &#38;
 - wait until the server is up: tail -f /vice/srv/SrvLog
 - create your root volume: createvol_rep coda:root E0000100 /vicepa
 - setup a client: venus-setup ha0 20000
 - start venus: venus
 - enjoy Coda.
</screen>

</para>

<para>
Los demonios están disponibles en el directorio
<literal remap="tt">/etc/rc.d/init.d/</literal>, y son los siguientes:
</para>

<para>

<screen>
update.init
auth2.init,
codasrv.init 
</screen>

</para>

<para>
Para lanzarlos bastará con pasarles como parámetro la cláusula «start»: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">/etc/rc.d/init.d/update.init start</literal>, ejecuta
<literal remap="tt">rpc2portmap</literal>, <literal remap="tt">updateclnt</literal> y <literal remap="tt">updatesrv</literal>. Este script no ejecuta
bien el demonio <literal remap="tt">updatesrv</literal>, hay que hacer una pequeña modificación
añadiendo <prompt>/dev/null</prompt> al final de la 
línea en la que se le ejecuta. 
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/etc/rc.d/init.d/auth2.init start</literal>, ejecuta <literal remap="tt">auth2</literal>.  
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/etc/rc.d/init.d/codasrv.init start</literal>, ejecuta
<literal remap="tt">startserver</literal>, quien a su vez ejecuta el <literal remap="tt">codasrv</literal>.
</para>
</listitem>

</itemizedlist>

</para>

<para>
Se puede comprobar que el servidor ha empezado a funcionar mirando el
siguiente <emphasis remap="it">log</emphasis>:
</para>

<para>

<screen>
$ tail -f /vice/srv/SrvLog &amp;
</screen>

</para>

<para>
El siguiente paso es instalar el resto de los servidores no-SCM y
configurarlos.
</para>

</sect3>

<sect3>
<title>Servidor no SCM en Red Hat</title>

<para>
La configuración de un servidor no SCM es prácticamente idéntica a la
del servidor maestro, aunque se omiten una serie de pasos (los de la
creación de usuarios y especificación del volumen root).
</para>

<para>
Es importante indicar que por razones de seguridad todos los servidores de
un mismo VSG deberán tener los mismos <emphasis remap="it">tokens</emphasis> de autentificación.
</para>

<para>
En esta ocasión no se pedirá un número de identificación del servidor
(tenemos que introducirlo antes o después en <literal remap="tt">/vice/db/servers</literal> de
la máquina SCM), pero sí se nos preguntará la ruta a la máquina
maestra (dirección IP ó nombre de la máquina).
</para>

<para>
Tenemos que configurar, de igual manera, los RVM's (particiones log y de
datos). Tras terminar con la configuración lanzaremos los demonios del 
servidor no-SCM:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">/etc/rc.d/init.d/update.init</literal>
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/etc/rc.d/init.d/auth2.init</literal> 
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/etc/rc.d/init.d/codasrv.init</literal>
</para>
</listitem>

</itemizedlist>

</para>

</sect3>

<sect3>
<title>Debian</title>

<para>
La instalación en Debian es bastante similar a la de Red Hat, por lo que
solamente contaremos las diferencias entre una y otra. Comenzaremos por
instalar el paquete binario, para ello teclearemos:
</para>

<para>

<screen>
# dpkg -i coda-server_5.2.0-1.i386.deb
</screen>

</para>

<para>
La propia instalación del paquete lanza el programa de configuración
<literal remap="tt">vice-setup</literal>, que es idéntico al de la distribución Red Hat
(la única diferencia es que éste lanza los demonios directamente).
</para>

<para>
Una vez hecha la configuración (siguiendo los mismos pasos que hemos
descrito en el apartado anterior para Red Hat) estarán lanzados todos los
demonios a excepción de <literal remap="tt">startserver</literal> y <literal remap="tt">codasrv</literal> (los
cuales habrá que lanzar a mano con <literal remap="tt"> startserver &amp;</literal>).
</para>

<para>
Para que estos dos demonios se ejecuten automáticamente tenemos que crear el
siguiente fichero <literal remap="tt">/vice/srv/STARTFROMBOOT</literal>. Una forma de hacerlo
es con:
</para>

<para>

<screen>
# echo &#62;/vice/srv/STARTFROMBOOT
</screen>

</para>

<para>
o
</para>

<para>

<screen>
# touch /vice/srv/STARTFROMBOOT
</screen>

</para>

<para>
En Debian existe un único script encargado de lanzar o matar todos los
demonios de un servidor Coda (nótese que la ruta del script cambia con
respecto a la ruta de Red Hat):
</para>

<para>
<variablelist>

<varlistentry>
<term><literal remap="tt">/etc/init.d/coda-server stop</literal></term>
<listitem>
<para>
para parar el servidor Coda.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal remap="tt">/etc/init.d/coda-server start</literal></term>
<listitem>
<para>
para iniciarlo.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Tras todo esto ya sólo nos queda configurar los servidores desde el
SCM para que Coda empiece a funcionar correctamente. 
</para>

</sect3>

</sect2>

<sect2>
<title>Configuración de los servidores Coda</title>

<para>
Los volúmenes son unidades de información que permiten gestionar
conjuntamente los datos que contienen. Es posible que un volumen
pertenezca sólo a un servidor (<emphasis remap="bf">volumen no replicado</emphasis>) y que sólo 
unos pocos usuarios puedan leer y escribir sobre él. También es posible
que un volumen pertenezca a más de un servidor (<emphasis remap="bf">volumen replicado</emphasis>)
y que todos los usuarios coda puedan leer y escribir sobre él.
</para>

<sect3>
<title>Creación de volúmenes</title>

<para>
El primer paso para configurar los servidores es crear el volumen
<emphasis remap="it">root</emphasis> desde el SCM (el único que puede crear y borrar volúmenes)
con una de las siguientes órdenes:
</para>

<para>

<screen>
# createvol_rep coda:root E0000100 /vicepa

# createvol coda:root sipt30 /vicepa
</screen>

</para>

<para>
En ambos casos el volumen <emphasis remap="it">root</emphasis> se llama <literal remap="tt">coda:root</literal>, pero con
la diferencia que en el primero creamos el volumen replicado y en el
segundo no (donde <literal remap="tt">sipt30</literal> es el servidor Coda que contiene el
volumen <emphasis remap="it">root</emphasis>).
</para>

<para>
En el ejemplo del volumen root replicado <literal remap="tt">E0000100</literal> es el
identificador del VSG al que pertenece el servidor SCM (por defecto el
SCM pertenece a este VSG) y el resto de servidores Coda donde queremos
replicar el volumen. Para añadir nuevos servidores a este VSG (al que
inicialmente sólo pertenece el SCM) el administrador debe modificar
los siguientes ficheros del SCM:
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">/vice/db/VSGDB</literal>, para indicar a qué servidores 
corresponde el identificador de grupo E0000100. Por ejemplo: 


<screen>
E0000100 sipt30 sipt31
  
</screen>


</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/vice/db/servers</literal>, para indicar cuáles son los 
identificadores de cada servidor (el del SCM ya ha sido escogido durante 
el proceso de instalación). En el siguiente ejemplo el identificador del 
servidor coda y SCM <literal remap="tt">sipt30</literal> es <literal remap="tt">1</literal> y el del servidor 
<literal remap="tt">sipt31</literal> es <literal remap="tt">2</literal> 


<screen>
sipt30  1
sipt31  2
  
</screen>

</para>
</listitem>

</itemizedlist>
 
</para>

<para>
Dichos ficheros habrá que modificarlos en el SCM cada vez que se
quiera añadir o eliminar un nodo del grupo de servidores.
</para>

<para>
Cuando se conecten los servidores No-SCM, se actualizarán por la red
sus ficheros del directorio <literal remap="tt">/vice</literal> (los ficheros de configuración
del servidor) incluyendo los dos anteriores.
</para>

<para>
Al igual que el <emphasis remap="it">root volume</emphasis>, el servidor SCM puede crear
otros volúmenes necesarios con <literal remap="tt">createvol_rep</literal> (volúmenes
replicados) o con <literal remap="tt">createvol</literal> (volúmenes locales al servidor sin
replicar). De este modo podemos encontrarnos con la siguiente
configuración del fichero <literal remap="tt">/vice/db/VSGDB</literal>:
</para>

<para>

<screen>
E0000100 ha0 ha1 
E0000200 ha1
  
</screen>

</para>

<para>
donde los servidores <literal remap="tt">ha0</literal> y <literal remap="tt">ha1</literal> pertenecen al grupo 
<literal remap="tt">E0000100</literal> y sólo <literal remap="tt">ha1</literal> pertenece al grupo <literal remap="tt">E0000200</literal>
(aunque el identificador pertenezca a un volumen replicado).
</para>

</sect3>

<sect3>
<title>Eliminación de volúmenes</title>

<para>
Para eliminar un volumen se utiliza la orden <literal remap="tt">purgevol</literal> (para
volúmenes no replicados) o <literal remap="tt">purgevol_rep</literal> (para volumenes replicados),
que sólo puede ser ejecutada desde el servidor SCM: 
</para>

<para>
<literal remap="tt"># purgevol_rep NombreVolumen</literal>
</para>

</sect3>

<sect3>
<title>Ficheros de configuración del servidor</title>

<para>
La información almacenada en los servidores Coda está organizada en varios
directorios, que están descritos a continuación: 
</para>

<para>

<itemizedlist>
<listitem>

<para>
<literal remap="tt">/vice/auth2</literal> Este directorio contiene información
relacionada con el proceso de autenticación, incluyendo sus ficheros
<emphasis remap="it">log</emphasis>.  
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/vice/bin</literal> Contiene los binarios del sistema de ficheros
Coda para los servidores y el SCM. 
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/vice/db</literal> Contiene las bases de datos con información
importante para los servidores y los ficheros <emphasis remap="it">log</emphasis> de las
actualizaciones. 
</para>
</listitem>
<listitem>

<para>
/vice/srv Contiene información relacionada con los demonios del
servidor, incluyendo sus ficheros <emphasis remap="it">log</emphasis>.  
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/vice/vol</literal> Contiene información de los volúmenes Coda. 
</para>
</listitem>
<listitem>

<para>
<literal remap="tt">/vice/vol/remote</literal> Existe sólo en el SCM y contiene
información de todos los servidores remotos.  
</para>
</listitem>
<listitem>

<para>
En <literal remap="tt">/vicepa</literal> (si no se ha cambiado por otro directorio
durante la instalación) se guardan los datos de los volúmenes Coda que
tiene el servidor. La información se guarda en forma de ficheros que se
distribuyen a lo largo de un árbol de directorios codificado
numéricamente. Consideramos interesante reseñar que en nuestro caso los
ficheros comenzaban a guardarse ordenadamente en el directorio
<literal remap="tt">/vicepa/0/0/</literal>, aunque desconocemos el sistema de codificación.
</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<sect2>
<title>Instalación de los clientes Coda</title>

<para>
El cliente debe instalar dos cosas: un módulo del núcleo para reconocer el
sistema de ficheros Coda, y el propio programa cliente Coda. Se recuerda
que un cliente y un servidor Coda no funcionan bajo una misma máquina, por
lo que debemos evitar que ocurra. 
</para>

<sect3>
<title>Módulo del núcleo Coda</title>

<para>
Para que el cliente tenga acceso al sistema de ficheros distribuido Coda
es necesario que el Núcleo lo reconozca. Esto se puede conseguir de varias
formas:
</para>

<para>

<orderedlist>
<listitem>

<para>
Compilando uno de los <emphasis remap="it">núcleo</emphasis>s 2.2.x que ya
disponen de soporte Coda y habilitándolo dentro del Núcleo (parte del
proceso de compilación de un <emphasis remap="it">núcleo</emphasis> en Linux). 

</para>
</listitem>
<listitem>

<para>
Compilando uno de los <emphasis remap="it">núcleos</emphasis> 2.2.x para
que soporte Coda, pero esta vez obteniendo un módulo <literal remap="tt">coda.o</literal> que
podremos cargar y descargar del <emphasis remap="it">Núcleo</emphasis> cuando queramos.

</para>
</listitem>
<listitem>

<para>
Si nuestro <emphasis remap="it">Núcleo</emphasis> tiene una versión anterior al 2.2.x, podemos
obtener el módulo <literal remap="tt">coda.o</literal> mencionado antes compilando el código fuente
de Coda (normalmente se encuentra en el fichero
<literal remap="tt">linux-coda-(versión).tgz</literal>)  
</para>
</listitem>

</orderedlist>

</para>

<para>
Si nos hemos decidido por trabajar con el módulo coda, dicho módulo no
se cargará en memoria una vez arrancado Linux. Para cargarlo en memoria
existen varios métodos, por ejemplo:
</para>

<para>

<itemizedlist>
<listitem>

<para>
Mediante la línea de órdenes del <emphasis remap="it">root</emphasis> con:
		

<screen>
# insmod coda
</screen>


</para>
</listitem>
<listitem>

<para>
Cargando obligatoriamente el módulo cuando se arranque Linux
(introduciendo en el fichero <literal remap="tt">/etc/modules</literal> la línea
<literal remap="tt">coda</literal>).

</para>
</listitem>
<listitem>

<para>
Cargando automáticamente el módulo sólo cuando sea necesario
(introduciendo en el fichero <literal remap="tt">/etc/modules</literal> la línea
<literal remap="tt">auto</literal>).
</para>
</listitem>

</itemizedlist>

</para>

<para>
<emphasis remap="bf">Nota</emphasis>: el módulo <literal remap="tt">coda.o</literal> debe encontrarse en
<literal remap="tt">/lib/modules/versionNúcleo/fs</literal>, donde «versionNúcleo» es la
versión del <emphasis remap="it">núcleo</emphasis> de Linux (para consultar la versión del
<emphasis remap="it">núcleo</emphasis> desde la línea de órdenes probar con <literal remap="tt">uname -r</literal>).
</para>

</sect3>

<sect3>
<title>Instalación de los binarios</title>

<para>
La instalación del cliente a partir de un paquete binario Linux se realiza
de distinta forma dependiendo de la distribución a la que pertenece:
</para>

<sect4>
<title>Red Hat</title>

<para>
El primer paso es instalar el paquete binario: 
</para>

<para>

<screen>
# rpm -i coda-debug-client-5.2.0-1.i386.rpm
</screen>

</para>

<para>
Venus es el gestor de la caché del cliente. Para configurarlo tenemos el
<emphasis remap="it">script</emphasis> <literal remap="tt">venus-setup</literal>: 
</para>

<para>

<screen>
# /usr/bin/venus-setup &lt;lista_de_hosts_separados_por_comas&gt; 
&lt;tamaño_de_caché_en_kb&gt;
</screen>

</para>

<para>
con lo que decimos a Venus cuál es su lista de servidores Coda a los
que debe conectarse. También inicializa un directorio para utilizarlo como
caché de disco del cliente Coda, con el tamaño indicado en el <emphasis remap="it">script</emphasis>
<literal remap="tt">venus-setup</literal> (para empezar se recomienda un a pequeña caché de 20 MB,
aunque funciona bien hasta 300 MB). Asimismo <literal remap="tt">venus-setup</literal> creará el
dispositivo <literal remap="tt">/dev/cfs0</literal> para comunicarse con el <emphasis remap="it">Núcleo</emphasis> y
dejará todos los ficheros del cliente Coda en el directorio
<literal remap="tt">/usr/coda</literal>.
</para>

<para>
También sería recomendable probar nuestro cliente Coda con el servidor
Coda <literal remap="tt"><ulink
url="http://testserver.coda.cs.cmu.edu"
>testserver.coda.cs.cmu.edu</ulink
></literal>, aunque deberá asegurarse que no
tiene ningún <emphasis remap="it">firewall</emphasis> que le impida comunicarse con él. Una caché de
20000 es aconsejable para probar este servidor.
</para>

<para>
Tras la instalación del paquete binario se puede lanzar Venus en
<emphasis remap="it">background</emphasis> con la orden: 
</para>

<para>

<screen>
# venus &amp;
</screen>

</para>

<para>
y se puede parar con 
</para>

<para>

<screen>
# kill -9 venus
</screen>
 o con
</para>

<para>

<screen>
vutil shutdown
umount /coda
</screen>

</para>

<para>
Aunque una manera más limpia de lanzar y parar Venus es desde su
<emphasis remap="it">script</emphasis> de inicio <literal remap="tt">/etc/rc.d/init.d/venus</literal>.
</para>

<para>
<emphasis remap="bf">Nota</emphasis>: Antes de volver a lanzar Venus el directorio <literal remap="tt">/coda</literal>
debe ser desmontado. Si esto diera problemas asegúrese de matar todos los
procesos que cuelgan de Coda, por ejemplo cuando tenemos ficheros de Coda
abiertos por una aplicación o porque estamos dentro del directorio
<literal remap="tt">/coda</literal>. Las utilidades <literal remap="tt">lsof</literal> y <literal remap="tt">fuser</literal> pueden
ayudarnos para solucionar estas cosas.
</para>

</sect4>

<sect4>
<title>Debian</title>

<para>
Instalamos el binario del cliente Coda: 
</para>

<para>

<screen>
# dpkg -i coda-client_5.2.0-1_i386.deb
</screen>
 
</para>

<para>
El proceso es similar al de Red Hat, aunque en Debian
<literal remap="tt">venus-setup</literal> se ejecuta en la propia instalación. Aún así siempre
se puede utilizar <literal remap="tt">venus-setup</literal> y <literal remap="tt">venus &amp;</literal> para una posterior 
configuración.
</para>

<para>
<literal remap="tt">/etc/init.d/coda-client</literal> es el script que lanza y para el demonio
<literal remap="tt">Venus</literal>.
</para>

</sect4>

</sect3>

<sect3>
<title>Desinstalación</title>

<para>
A continuación se describe el proceso de desinstalación de un servidor
Coda, útil cuando nos hemos equivocado en el proceso de instalación o
configuración y queremos volver a empezar.
</para>

<sect4>
<title>Servidor Red Hat</title>

<para>
Comenzaremos por parar a todos los demonios utilizando los lanzadores de
los que disponemos en <literal remap="tt">etc/rc.d/init.d/</literal>:
</para>

<para>

<screen>
# /etc/rc.d/init.d/auth2.init stop
# /etc/rc.d/init.d/update.init stop
# /etc/rc.d/init.d/codasrv.init stop
</screen>

</para>

<para>
Tras esto verificaremos que ninguno de los siguientes procesos esté
cargado en memoria con <literal remap="tt">ps uax | less</literal>: 
</para>

<para>

<screen>
 auth2
 rpc2portmap
 update
 updateclnt
 updatesrv
 startserver
 codasrv
</screen>

</para>

<para>
Si alguno de estos procesos está en ejecución lo podemos parar con:

<screen>
kill -9 pid
</screen>

donde <literal remap="tt">pid</literal> es el identificador del proceso que aparece indicado al 
ejecutar <literal remap="tt">ps</literal>.
</para>

<para>
Ahora ya nos hemos asegurado de que no hay ningún proceso del servidor
coda en funcionamiento, por lo que podemos proceder a la desinstalación
del paquete.
</para>

<para>

<screen>
# rpm -e coda-debug-server-5.2.0-1
</screen>

</para>

<para>
Por último, sólo nos queda borrar los directorios de Coda: 
</para>

<para>

<screen>
# rm -rf /vicepa
# rm -rf /vice
# rm -f /var/lock/subsys/auth2.init
# rm -f /var/lock/subsys/update.init
# rm -f /var/lock/subsys/codasrv.init
</screen>

<emphasis remap="bf">Nota</emphasis>: Se pueden producir fallos en la configuración de Coda si se 
intenta
instalar de nuevo sin borrar antes los directorios <literal remap="tt">/vicepa</literal> y
<literal remap="tt">/vice</literal>.
</para>

</sect4>

<sect4>
<title>Servidor Debian</title>

<para>
Comenzaremos por dar de baja a todos los demonios: 
</para>

<para>

<screen>
# /etc/init.d/coda-server stop
</screen>

</para>

<para>
El resto del proceso es idéntico al de Red Hat, salvo que el paquete
binario de Coda de desinstala con:
</para>

<para>

<screen>
# dpkg -r coda-debut-server_5.2.0-1
</screen>
 
</para>

<para>
o con la herramienta <literal remap="tt">dselect</literal> de Debian. 
</para>

</sect4>

<sect4>
<title>Cliente (Red Hat y Debian)</title>

<para>
El cliente es mucho más sencillo y es suficiente con desinstalar el
paquete binario de la distribución (orden <literal remap="tt">rpm</literal> en Red Hat y
<literal remap="tt">dpkg</literal> en Debian). Asimismo la desinstalación del módulo Coda del
<emphasis remap="it">núcleo</emphasis> dependerá del proceso escogido para su instalación. 
</para>

</sect4>

</sect3>

</sect2>

</sect1>

<sect1>
<title>Administración</title>

<sect2>
<title>Creación de cuentas de usuario </title>

<para>
&lsqb;HAR98] Una vez instalados y configurados correctamente los servidores 
Coda debemos crear las <emphasis remap="bf">cuentas de los usuarios Coda</emphasis>. 
Para ello emplearemos la orden interactiva <literal remap="tt">pdbtool</literal>. Las órdenes más
utilizadas en <literal remap="tt">pdbtool</literal> son:
</para>

<para>
<variablelist>

<varlistentry>
<term><literal remap="tt">nu nombreusuario</literal></term>
<listitem>
<para>
crea un nuevo usuario (el sistema le asigna 
un identificador).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal remap="tt">nui nombreusuario idusuario</literal></term>
<listitem>
<para>
crea un nuevo usuario con el 
identificador especificado. 
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal remap="tt">ng nombregrupo idpropietario</literal></term>
<listitem>
<para>
crea un nuevo grupo con el 
propietario especificado. 
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal remap="tt">ci usuario/nombregrupo nuevoid</literal></term>
<listitem>
<para>
cambia el identificador 
de un usuario o grupo existente. 
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal remap="tt">ag id-grupo usuario/idgrupo</literal></term>
<listitem>
<para>
añade un usuario o grupo a 
un grupo. 
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal remap="tt">n usuario/nombregrupo</literal></term>
<listitem>
<para>
lista toda la información del 
usuario o del grupo especificado. 
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
donde los identificadores de usuario son enteros positivos y los
identificadores de grupo son enteros negativos. Como ejemplo se creará una 
cuenta Coda con la herramienta <literal remap="tt">pdbtool</literal>. Esta operación debemos 
realizarla sobre el servidor SCM, ya que es el único que puede 
realizarla.
</para>

<para>

<screen>
root@scm# pdbtool
pdbtool&#62; nu tux
pdbtool&#62; n tux
USER tux
     *    id: 779
     *    belongs to no groups
     *    cps:  [  779  ]
     *    owns no groups
pdbtool&#62; ng users 779
pdbtool&#62; n users
GROUP users OWNED BY tux
     *    id: -205
     *    owner id:  779
     *    belongs to no groups
     *    cps:  [  -205  ]
     *    has members: [ 779 ]
pdbtool&#62; n System:AnyUser
GROUP System:AnyUser OWNED BY System
     *    id: -101
     *    owner id:  777
     *    belongs to no groups
     *    cps:  [  -101  ]
     *    has members: [ 777 ]
pdbtool&#62; ag -101 779
pdbtool&#62; ag -205 779
pdbtool&#62; n tux
USER tux
     *    id: 779
     *    belongs to groups:  [ -101   -205]
     *    cps:  [ -101   -205   779 ]
     *    owns: [ -205 ]
pdbtool&#62; q
</screen>

</para>

<para>
La anterior secuencia ha creado una nueva cuenta de usuario llamada
<literal remap="tt">tux</literal> y se ha hecho que forme parte del también creado grupo
<literal remap="tt">users</literal>. Igualmente se ha introducido esta nueva cuenta en el grupo
<literal remap="tt">System:AnyUser</literal>, el cual contiene a todas las cuentas del Sistema
Coda. Para activar la cuenta es necesario asignarle una contraseña desde
cualquier servidor, autenticándose antes como el administrador de Coda
(durante la instalación del SCM se ha solicitado el nombre y la
contraseña de la cuenta de administración, que en nuestro caso son
<literal remap="tt">admin</literal> y <literal remap="tt">changeme</literal> respectivamente):

<screen>
            
admin@cualquiermáquina$ au -h scm nu
Your Vice Name: admin
Your Vice Password: ********
New User Name: tux
New User Password: nuevaContraseña
</screen>

</para>

<para>
A continuación creamos un <emphasis remap="it">home volume</emphasis> replicado llamado
<literal remap="tt">users:tux</literal> con VSG E0000100, lo montamos, le asignamos todos
los permisos de usuario posibles sobre ese volumen (ver siguiente sección, donde en el apartado 3 se explican
los permisos de Coda), y lo desmontamos. Nótese que la orden
<literal remap="tt">cfs mkm</literal> crea y monta a la vez el directorio del volumen asociado.
</para>

<para>

<programlisting>
root@scm# createvol_rep users:tux E0000100 /vicepa
admin@cualquiermáquina$ cfs mkm /coda/usr/tux users:tux
admin@cualquiermáquina$ cfs sa /coda/usr/tux tux all
admin@cualquiermáquina$ cfs rmm /coda/usr/tux
</programlisting>

</para>

<para>
Finalmente el usuario <literal remap="tt">tux</literal> podrá cambiar su contraseña desde
cualquier máquina cliente Coda con:
</para>

<para>

<screen>
tux@cualquiermáquina$ cpasswd -h scm
</screen>

</para>

<para>
siendo SCM la máquina SCM del sistema Coda. 
</para>

</sect2>

<sect2>
<title>Acceso a las cuentas y órdenes</title>

<para>
Si todo va bien el cliente debería ser capaz de montar el sistema de
ficheros Coda bajo el directorio <literal remap="tt">/coda</literal> (donde se monta el volumen
<emphasis remap="it">root</emphasis>).  Si existe el fichero <literal remap="tt">/coda/NOT_REALLY_CODA</literal> entonces
aún no se ha montado Coda y debemos comprobar que el demonio <literal remap="tt">Venus</literal>
está lanzado. 
</para>

<para>
Para acceder a una cuenta Coda existe la orden <literal remap="tt">clog user</literal>, 
donde <emphasis remap="it">user</emphasis> es el nombre de usuario o <emphasis remap="it">login</emphasis>. Desde 
cualquier máquina con cliente Coda:
</para>

<para>

<screen>
$ clog tux
username: tux
password: ********
</screen>

</para>

<para>
A partir de entonces el usuario autenticado puede montar los volúmenes a
los que tiene acceso (nuestro usuario <literal remap="tt">tux</literal> tiene acceso al volumen
<literal remap="tt">users:tux</literal> y lo monta bajo <literal remap="tt">/coda/usr/tux</literal>):
</para>

<para>

<screen>
tux@cualquiermáquina$ cfs mkm /coda/usr/tux users:tux
</screen>

</para>

<para>
El usuario ya puede trabajar con el directorio <literal remap="tt">/coda/usr/tux</literal> como
si se tratara de uno tradicional. Después siempre podrá desmontar el
volumen con la orden: 

<screen>
cfs rmm /coda/directoriomontaje
</screen>
 
</para>

<para>
<emphasis remap="bf">Nota</emphasis>: la versión Coda 5.2.0 tiene problemas si en <literal remap="tt">cfs mkm</literal>
se indica el <emphasis remap="it">path</emphasis> de montaje acabado en '/'. Al parecer 
se ha conseguido arreglar este <emphasis remap="it">bug</emphasis> en versiones posteriores.
Asimismo hemos tenido problemas al intentar editar un fichero Coda
con el editor <literal remap="tt">emacs</literal> (lo hemos «solucionado» trabajando con
<literal remap="tt">vi</literal> en las pruebas). 
</para>

<sect3>
<title>Comando cfs </title>

<para>
&lsqb;SAT97-1] La orden <literal remap="tt">cfs</literal> (<emphasis remap="it">Coda File System Interface Program</emphasis>) 
permite a los usuarios ejecutar operaciones específicas del Sistema de
Ficheros Coda. A menudo se utiliza para ver el espacio de almacenamiento
utilizado y para cambiar los permisos de protección de un directorio. A
continuación se detallan los opciones de <literal remap="tt">cfs</literal> más importantes:
</para>

<para>

<orderedlist>
<listitem>
<para>
<literal remap="tt">cfs mkmount &lt;directorio&gt; &lt;nombre-volumen&gt; [-rw]</literal>
</para>
<para>
Crea un directorio de montaje especificado en <literal remap="tt">&lt;directorio&gt;</literal>
y monta un volumen especificado en <literal remap="tt">&lt;nombre-volumen&gt;</literal>. Si se
utiliza el <emphasis remap="it">flag</emphasis> <emphasis>-rw</emphasis> el volumen se monta con permisos de lectura
y escritura, ya que de otro modo los permisos serían de sólo lectura si su
volumen padre también lo es. Nótese que en ambos casos el usuario debe
tener los privilegios necesarios.
</para>

<para>
Abreviatura: mkm
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs rmmount &lt;dir&gt; [&lt;dir&gt; &lt;dir&gt; ...]</literal>
</para>
<para>
Elimina uno o más directorios de montaje (especificados por &lt;dir&gt;)
del sistema de ficheros. En sí mismo el volumen no cambia. 
</para>

<para>
Abreviatura: rmm
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs setacl [-clear]
[-negative] &lt;dir&gt; &lt;id&gt; &lt;perm&gt; [&lt;id&gt; &lt;perm&gt; ....] </literal> 
</para>
<para>
En Coda
el concepto tradicional de permisos de usuario, grupo y otros desaparece.
En su lugar CODA utiliza las denominadas Listas de Control de Acceso
(ACL's), las cuales consisten en una serie de datos que definen qué
usuarios o grupos pueden hacer qué cosas con cada elemento de un espacio
de direccionamiento Coda. Estos permisos &lsqb;MAR99] constituyen un modelo 
mucho más elaborado que los tradicionales permisos de
ejecución/lectura/escritura de Unix. Los permisos no son establecidos para
cada fichero, sino para todos los ficheros de un directorio (aunque en la
documentación de la orden <literal remap="tt">cfs</literal> se aconseja el uso de la orden Unix
<literal remap="tt">chmod</literal> para cambiar los permisos de los ficheros): 
</para>

<para>
r	Read, permiso de lectura.
l	Lookup, permiso para obtener el status de un fichero.
i	Insert, permiso de creación de ficheros o directorios.
d	Delete, permiso de borrado.
w	Write, permiso de modificación.
a	Administer, permiso de control de los permiso de acceso.
</para>

<para>
Con la orden <literal remap="tt">cfs setacl</literal> (<literal remap="tt">cfs sa</literal> abreviado) se
configura la ACL del directorio &lt;dir&gt; para cada usuario identificado
por &lt;id&gt; con los permisos &lt;perm&gt; <emphasis remap="it">rlidwa</emphasis> explicados
anteriormente (<emphasis remap="it">read, lookup, insert, delete, write</emphasis> y
<emphasis remap="it">administer</emphasis>). El <emphasis remap="it">flag</emphasis> <emphasis>-clear</emphasis> borra toda la lista de control
de accesos a excepción de lo especificado en la propia orden <literal remap="tt">cfs</literal>.
El <emphasis remap="it">flag</emphasis> <emphasis>-negative</emphasis> niega los permisos especificados en
la orden en lugar de concederlos.
</para>

<para>
Abreviatura: sa 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs listacl &lt;dir&gt; [&lt;dir&gt; &lt;dir&gt; ...]</literal>
</para>
<para>
Muestra la lista de control de accesos para los directorios dados. 
</para>

<para>
Abreviatura: la 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs whereis &lt;dir&gt; [&lt;dir&gt; &lt;dir&gt; ...]</literal>
</para>
<para>
Lista los servidores donde residen los ficheros especificados. 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs disconnect</literal> 
</para>
<para>
Desconecta el cliente Coda de los servidores Coda. Útil por ejemplo cuando
queramos trabajar localmente desde nuestra caché Coda en modo desconectado
y aumentar así el rendimiento en los tiempos de acceso.
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs reconnect</literal>
</para>
<para>
 Reconecta el cliente a
los servidores Coda, deshaciendo los efectos de <literal remap="tt">cfs disconnect.</literal>
</para>

<para>
<emphasis remap="bf">Nota</emphasis>:Hasta la versión 5.2.2 de Coda esta orden tenía un <emphasis remap="it">bug</emphasis>
conocido que impedía la reconexión (<literal remap="tt">cfs disconnect</literal> pone un
software de filtrado en los niveles de rpc2 pero <literal remap="tt">reconnect</literal> falla
al borrarlo). Para solucionarlo ejecutar desde el servidor SCM:

<screen>
# filcon clear -c hostcliente
</screen>
 consiguiendo el rid del filtro sin arrancar Venus.
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs writedisconnect [-age &lt;secs&gt; -time &lt;secs&gt; &lt;dir&gt;]</literal>
</para>
<para>
Indica a Venus que va a escribir en modo
desconectado en los volúmenes/directorios dados o en todos los volúmenes
si no se especifica ninguno, para lo cual se cargará en la caché los
ficheros correspondientes de los servidores (no propagará los cambios
inmediatamente). El argumento <emphasis>-age</emphasis> especifica el tiempo de
<emphasis remap="it">caching</emphasis> en la caché del cliente antes de reintegrar los datos. El
argumento <emphasis>-time</emphasis> proporciona el número de segundos que debería
tardar el envío de un fragmento de reintegración.
</para>

<para>
 
Abreviatura : wd 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs writereconnect [&lt;dir&gt; &lt;dir&gt; ...]</literal>
</para> 
<para>
Conexión estricta de los directorios Coda a los servidores.
</para>

<para>
 
Abreviatura : wr 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs examineclosure </literal>
</para>
<para>
Examina el cierre de reintegración, mostrando la localización de los 
ficheros no reintegrados y modificados durante la desconexión. 
</para>

<para>
Abreviatura: ec 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs replayclosure</literal>
</para>
<para>
 Repite el cierre de reintegración 
(útil por ejemplo si falta algún fichero con conflictos por reintegrar).
</para>

<para>
Abreviatura: rc 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs listcache [&lt;dir&gt; &lt;dir&gt; ...]</literal>
</para>
<para>
Muestra los contenidos de la caché de los directorios/volúmenes dados (si
no se especifican por defecto se muestra toda la caché).
</para>

<para>
Abreviatura: lc 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs listvol &lt;dir&gt; [&lt;dir&gt; &lt;dir&gt; ...] </literal>
</para>
<para>
Muestra el estado actual del volumen en el que el directorio especificado
se almacena.
</para>

<para>
Abreviatura: lv 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">cfs lsmount &lt;dir&gt; [&lt;dir&gt; &lt;dir&gt; ...] </literal>
</para>
<para>
Lista los contenidos de un directorio de montaje. Esta orden se puede
utilizar para conocer a qué volumen se asocia un directorio de montaje
dado.
</para>
</listitem>

</orderedlist>

</para>

<para>
Para más información consultar las <literal remap="tt">man</literal> de la orden <literal remap="tt">cfs</literal>.
</para>

</sect3>

<sect3>
<title>Reparación de conflictos </title>

<para>
&lsqb;SAT97-2] Como se ha explicado en la introducción, sucede ocasionalmente
que un directorio se vuelve inconsistente debido a un conflicto global, es
decir, cuando Coda no puede resolver automáticamente una replicación entre
servidores de un mismo VSG (por ejemplo cuando un mismo grupo de
servidores VSG se particiona y un mismo fichero se modifica en más de una
de las particiones). También es posible una inconsistencia local de algún
cliente con respecto al estado global (conflicto local/global que se
produce en los fallos de reintegración), normalmente porque un cliente
desconectado actualiza un fichero que también ha sido actualizado en los
servidores por otro cliente. Cuando ocurre algún conflicto de éstos, el
directorio que contiene el conflicto se convertirá en un enlace simbólico
que apunta a su <literal remap="tt">fid</literal>. Por ejemplo, si el directorio
<literal remap="tt">conflicto</literal> es inconsistente aparecerá así: 
</para>

<para>

<screen>
$ ls -l conflicto
lr--r--r-- 1 root     27 Mar 23 14:52 conflicto -&#62;
@@7f0000b3.00000005.0000011a
</screen>

</para>

<para>
La mayoría de las aplicaciones devolverán un error de
«<literal remap="tt">Fichero no encontrado</literal>» cuando intenten
abrir un fichero inconsistente. Para resolver este conflicto existe la
herramienta <literal remap="tt">repair</literal>.
</para>

<sect4>
<title>Conflictos servidor-servidor</title>

<para>
Tras ejecutar <literal remap="tt">repair</literal> desde un cliente
Coda, es necesario hacer <literal remap="tt">begin</literal> del objeto
inconsistente, tras lo cual el directorio inconsistente tendrá una entrada
por cada uno de los volúmenes replicados. Con una observación a estos
subdirectorios el usuario podrá elegir qué copia quiere, y con la orden
<literal remap="tt">repair</literal> podrá copiar la versión correcta y eliminar la
inconsistencia. En el siguiente ejemplo el fichero
<literal remap="tt">conflicto/ejemplo.txt</literal> está replicado en tres servidores y
queremos resolver la inconsistencia entre servidores: 
</para>

<para>

<screen>
 
$ ls -lL conflicto 
lr--r--r-- 1 root     27 Dec 20 13:12 conflicto -&#62; 
@@7f0002ec.000000e3.000005d1
$ repair 
The repair tool can be used to manually repair files and directories
that have diverging replicas.  You will first need to do a "beginRepair"
which will expose the replicas of the inconsistent object as its
children. 

If you are repairing a directory, you will probably use the "compareDir" 
and "doRepair" commands. 

For inconsistent files you will only need to use the "doRepair" command. 
If you want to REMOVE an inconsistent object, use the "removeInc" command.

Help on individual commands can also be obtained using the "help" 
facility. 

repair&#62; begin conflicto
a server-server-conflict repair session started
use the following commands to repair the conflict:
        comparedirs
        removeinc
        dorepair
repair&#62; ^Z
Stopped
$ ls conflicto
gershwin.coda.cs.cmu.edu        schumann.coda.cs.cmu.edu
$ ls conflicto/*
conflicto/gershwin.coda.cs.cmu.edu:
ejemplo.txt

conflicto/schumann.coda.cs.cmu.edu:
ejemplo.txt
$ fg
repair
compare
Pathname of Object in conflict?  [conflicto]  
Pathname of repair file produced?  []  /tmp/fix
   
NAME/NAME CONFLICT EXISTS FOR ejemplo.txt

-rw-r--r-- 1 tux 0 Dec 20 13:10 gershwin.coda.cs.cmu.edu/ejemplo.txt
-rw-r--r-- 1 -101 0 Dec 20 13:11 schumann.coda.cs.cmu.edu/ejemplo.txt


/coda/project/conflicto/gershwin.coda.cs.cmu.edu/ejemplo.txt
        Fid: (0xb0.612) VV:(0 2 0 0 0 0 0 0)(0x8002f23e.30c6e9aa) 
/coda/project/conflicto/schumann.coda.cs.cmu.edu/ejemplo.txt
        Fid: (0x9e.5ea) VV:(2 0 0 0 0 0 0 0)(0x8002ce17.30d56fb9) 

Should /coda/project/conflicto/gershwin.coda.cs.cmu.edu/ejemplo.txt be
removed?  [no] yes

Should /coda/project/conflicto/schumann.coda.cs.cmu.edu/ejemplo.txt be
removed?  [no]

Do you want to repair the name/name conflicts [yes]
Operations to resolve conflicts are in /tmp/fix
repair&#62; do
Pathname of object in conflict?  [conflicto]  
Pathname of fix file?  [/tmp/fix]  
OK to repair "conflicto" by fixfile "/tmp/fix"?  [no]  yes
SCHUMANN.CODA.CS.CMU.EDU  succeeded
GERSHWIN.CODA.CS.CMU.EDU  succeeded
repair&#62; quit
$ ls conflicto
ejemplo.txt
$ exit
</screen>

</para>

</sect4>

<sect4>
<title>Conflicto local-global</title>

<para>
El uso de la orden <literal remap="tt">repair</literal> es similar al caso anterior. Después de
empezar la sesión de reparación con <literal remap="tt">begin</literal> e indicar el <emphasis remap="it">path</emphasis>
del objeto en conflicto, las réplicas local y global serán visibles en
<literal remap="tt">pathObjetoEnConflicto/local</literal> (sólo lectura) y en
<literal remap="tt">pathObjetoEnConflicto/global</literal> (modificable). Con la orden
<literal remap="tt">listlocal</literal> se muestra la lista de todas las modificaciones locales
sobre el objeto inconsistente o sobre sus descendientes, siendo necesario
reparar de uno en uno y en el orden de la lista los posibles conflictos de
estas modificaciones. <literal remap="tt">checklocal</literal> nos dice si el primer elemento
de la lista a tratar tiene algún conflicto o no. El siguiente algoritmo
muestra el proceso principal de reparación:
</para>

<para>

<programlisting>
listlocal (para visualizar la lista)
para cada elemento de la lista «listlocal» hacer	
    checklocal(se refiere al primer elemento de la lista de modificaciones 
               locales)
    si el elemento a tratar tiene conflicto:
	resolver conflicto
    sino 
	decidir si queremos preservar la copia local en el servidor 
    finsi
</programlisting>

</para>

<para>
Con <literal remap="tt">discardlocal</literal> se descarta la copia local preservando la del
servidor, y con <literal remap="tt">preservelocal</literal> la copia que se preserva es la
local. Ambas opciones se pueden utilizar tanto si se trata de un conflicto
como si no (ambos casos del <emphasis>if</emphasis> del algoritmo). Para acelerar el
proceso existen las órdenes <literal remap="tt">preservealllocal</literal> (preserva todos los
elementos del objeto en conflicto)  y <literal remap="tt">discardalllocal</literal> (todos los
elementos modificados localmente se desechan para preservar el estado
global del servidor). 
</para>

<para>
Se pueden utilizar herramientas o editores como <literal remap="tt">vi</literal> para
actualizar convenientemente la réplica global del objeto en conflicto, ya
que como se ha dicho antes, la réplica global es la única modificable. La
orden <literal remap="tt">quit</literal> se utiliza para comprometer o abortar la sesión de
reparación. Las páginas <literal remap="tt">man</literal> ofrecen información más detallada 
acerca
de estas órdenes de reparación. En el siguiente ejemplo se ilustra el
proceso de reparación de un conflicto local/global, en el cual se supone
que durante la desconexión un usuario crea un nuevo directorio
<literal remap="tt">/coda/usr/tux/doc</literal> y actualiza el fichero
<literal remap="tt">/coda/usr/tux/fichero.txt</literal>. Simultáneamente otro usuario con
permisos también crea un directorio <literal remap="tt">/coda/usr/tux/doc</literal> y almacena
varios ficheros en él, produciéndose el conflicto local/global del objeto
<literal remap="tt">/coda/usr/tux</literal> durante la reintegración:

<screen>
	
tux@clientecoda$ ls -l /coda/usr/tux/doc 
lr--r--r-- 1 root 27 Dec 20 00:36 doc -&#62; @@7f000279.00000df3.0001f027
  
tux@clientecoda$ repair
repair&#62; begin
Pathname of object in conflict?  []  /coda/usr/tux
a local-global-conflict repair session started
the conflict is caused by a reintegration failure
use the following commands to repair the conflict:
        checklocal
        listlocal
        preservelocal
        preservealllocal
        discardlocal
        discardalllocal
        setglobalview
        setmixedview
        setlocalview
a list of local mutations is available in the .cml file in the coda
spool directory

repair&#62; !ls -l /coda/usr/tux/
total 4
drwxr-xr-x  3 tux         2048 Dec 20 00:51 global
drwxr-xr-x  3 tux         2048 Dec 20 00:51 local
  

repair&#62; listlocal
local mutations are:

Mkdir   /coda/usr/tux/local/doc
Store   /coda/usr/tux/local/fichero.txt (length = 19603)

repair&#62; checklocal
local mutation: mkdir /coda/usr/tux/local/doc
conflict: target /coda/usr/tux/global/doc exist on servers

repair&#62; discardlocal
discard local mutation mkdir /coda/usr/tux/local/doc

repair&#62; checklocal
local mutation: store /coda/usr/tux/local/fichero.txt
no conflict

repair&#62; preservelocal
store /coda/usr/tux/global/fichero.txt succeeded

repair&#62; checklocal
all local mutations processed

repair&#62; quit
commit the local/global repair session?  [yes]  
reintegrate
</screen>

</para>

</sect4>

</sect3>

<sect3>
<title>Otras órdenes</title>

<para>
Otras órdenes importantes a tener en cuenta son:
</para>

<para>

<itemizedlist>
<listitem>

<para>
cliente:  

<itemizedlist>
<listitem>

<para>
<literal remap="tt">hoard</literal>: hoard database front-end. <emphasis remap="it">Front-end</emphasis> de la
base de datos Hoard (HDB), con el cual es posible añadir un fichero a la
base de datos Hoard, borrar un fichero, listar el contenido del HDB, o
modificar los atributos de un fichero hoard.

</para>
</listitem>
<listitem>

<para>
<literal remap="tt">ctokens</literal>: lista los tokens del usuario con la fecha de
expiración, la identificación del usuario y si está o no autenticado.
</para>
</listitem>

</itemizedlist>


</para>
</listitem>
<listitem>

<para>
Servidor:

<itemizedlist>
<listitem>

<para>
<literal remap="tt">filcon</literal>: utilidad de control de filtrado RPC2. Por ejemplo
se puede aislar un servidor con: 

<screen>
filcon isolate -s nombre-servidor
</screen>
 
y deshacer esta operación con:

<screen>
filcon clear nombre-servidor.
</screen>

</para>
</listitem>

</itemizedlist>

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<sect2>
<title>Herramientas de monitorización</title>

<para>
Existen herramientas de monitorización del sistema Coda que ayudan a
comprobar su correcto funcionamiento. Las siguientes herramientas se
utilizan desde el cliente Coda:
</para>

<para>

<itemizedlist>
<listitem>
<para>
<literal remap="tt">cmon</literal>
</para>
<para>
 
para monitorizar desde un cliente el estado de los servidores Coda, útil
entre otras cosas para comprobar la conexión entre un cliente y sus
servidores. Por ejemplo, con 
<screen>
cmon -t 1 sipt30 sipt31
</screen>
 se comprueba y se visualiza cada segundo el estado
de los servidores <literal remap="tt">sipt30</literal> y <literal remap="tt">sipt31</literal>. Si un servidor no es
accesible se visualizará una interrogación en los resultados estadísticos
referentes al diagnóstico de un mismo servidor. 
</para>
</listitem>
<listitem>
<para>
<literal remap="tt">codacon</literal> 
</para>
<para>
para visualizar las acciones del cliente.
</para>
</listitem>
<listitem>

<para>
Ficheros <emphasis remap="it">log</emphasis> del cliente: 

<screen>
$ tail -f /usr/coda/venus.cache/venus.log
$ tail -f  /usr/coda/etc/console
</screen>

</para>
</listitem>

</itemizedlist>

</para>

<para>
Como ya se ha mencionado anteriormente, los servidores Coda guardan
sus ficheros <emphasis remap="it">log</emphasis> en <literal remap="tt">/vice/srv/</literal>.  
</para>

</sect2>

</sect1>

<sect1>
<title>Pruebas realizadas y resultados</title>

<para>
Para nuestras pruebas con el Sistema Coda hemos dispuesto de dos
servidores Coda y un cliente Coda. Los dos servidores forman parte de un
mismo VSG replicado con identificador E0000100 y coinciden con la
configuración del ejemplo de configuración utilizado en este documento. 
</para>

<para>
El cliente Coda funciona perfectamente en modo conectado actualizando
inmediatamente los cambios del cliente en los servidores. Sin embargo tras
una desconexión la reintegración no se produce inmediatamente y puede
llegar a tardar un tiempo variable (este proceso sigue siendo transparente
para el usuario).
</para>

<para>
Cuando uno de los servidores cae o resulta inaccesible durante un periodo
de tiempo en el que el otro servidor se ha modificado, el primero también
tarda un tiempo variable en actualizarse tras su reconexión e igualmente
resulta transparente para el usuario. 
</para>

<para>
Hemos probado todas las configuraciones expuestas en este documento. Sin
embargo Coda es un sistema relativamente complejo y no hemos trabajado con
la base de datos Hoard ni con el sistema de copias de seguridad de Coda. 
Existen múltiples configuraciones y pruebas a realizar pero hemos
preferido centrarnos en sus características más relevantes: la replicación
y la computación móvil. 
</para>

</sect1>

<sect1>
<title>Bibliografía</title>

<para>
<emphasis remap="bf">&lsqb;BRA98] Peter J. Braam: <emphasis remap="it">The Coda Distributed File System</emphasis>.</emphasis>

<literal remap="tt"><ulink
url="http://coda.cs.cmu.edu/ljpaper/lj.html"
>http://coda.cs.cmu.edu/ljpaper/lj.html</ulink
></literal>.School of Computer 
Science, Carnegie Mellon University, february 1998.
</para>

<para>
<emphasis remap="bf">&lsqb;HAR98] Jan Harkes: <emphasis remap="it">User Administration in Coda 5.2.x</emphasis>.</emphasis>

<literal remap="tt"><ulink
url="http://coda.cs.cmu.edu/doc/html/pdbtool-mini-howto.html"
>http://coda.cs.cmu.edu/doc/html/pdbtool-mini-howto.html</ulink
></literal>.
School of Computer Science, Carnegie Mellon University, 1998.
</para>

<para>
<emphasis remap="bf">&lsqb;MAR99] Juan Antonio Martínez: <emphasis remap="it">El sistema de ficheros Coda</emphasis>.</emphasis>

Revista <emphasis remap="it">Linux Actual</emphasis> nº 9, páginas 20-22, diciembre 1999.
</para>

<para>
<emphasis remap="bf">&lsqb;SAT97-1] M. Satyanarayanan, Maria R. Ebling, Joshua Raiff, Peter J. Braam:
<emphasis remap="it">Coda File System. User and System Administrators Manual (E. Unix Manual 
Pages)</emphasis>.</emphasis>

<literal remap="tt"><ulink
url="http://coda.cs.cmu.edu/doc/html/manual-19.html"
>http://coda.cs.cmu.edu/doc/html/manual-19.html</ulink
></literal>.
School of Computer Science, Carnegie Mellon University, august 1997.
</para>

<para>
<emphasis remap="bf">&lsqb;SAT97-2] M. Satyanarayanan, Maria R. Ebling, Joshua Raiff, Peter J. Braam:
Coda File System. User and System Administrators Manual (3.6 Repairing an 
Inconsistent Directory).</emphasis>

<literal remap="tt"><ulink
url="http://coda.cs.cmu.edu/doc/html/manual-3.html"
>http://coda.cs.cmu.edu/doc/html/manual-3.html</ulink
></literal>.
School of Computer Science, Carnegie Mellon University, august 1997.
</para>

</sect1>

<sect1>
<title>Agradecimientos</title>

<para>
A Alberto Lafuente y a Igor Armendariz, profesores de la Facultad de 
Informática 
de San Sebastián de la Universidad Pública del País Vasco. Gracias a 
ellos hemos dispuesto de los mejores recursos en el Laboratorio E04 
de la facultad para Instalar Debian en tres equipos y probar Coda.También
queremos agradecer la importante valoración de este documento dentro de 
la asignatura 
<literal remap="tt">Sistemas Distribuidos</literal> (¡gracias Alberto!). Sin la ayuda de ambos 
este <emphasis remap="it">COMO</emphasis> nunca hubiera existido. 
</para>

<para>
A Francisco José Montilla Blanco del Insflug, por ayudarme con el sgml y con 
mis múltiples preguntas sobre los <emphasis remap="it">COMOs</emphasis>.
</para>

<para>
A Juan Antonio Martínez, por permitirme refundir algunos 
párrafos de su artículo <emphasis remap="it">El sistema de ficheros CODA</emphasis>.
</para>

<para>
Y en general a todos aquellos que creen en mi.
</para>

</sect1>

<sect1 id="Grupos">
<title>Anexo: El INSFLUG </title>

<para>
El <emphasis remap="it">INSFLUG</emphasis> forma parte del grupo internacional <emphasis remap="it">Linux Documentation
Project</emphasis>, encargándose de las traducciones al castellano de los Howtos,
así como de la producción de documentos originales en aquellos casos en los
que no existe análogo en inglés, centrándose, preferentemente, en documentos
breves, como los <emphasis>COMOs</emphasis> y <emphasis>PUFs</emphasis> (<emphasis remap="bf">P</emphasis>reguntas de <emphasis remap="bf">U</emphasis>so
<emphasis remap="bf">F</emphasis>recuente, las <emphasis remap="it">FAQs</emphasis>. <literal remap="tt">:)</literal> ), etc.
</para>

<para>
Diríjase a la sede del Insflug para más información al respecto.
</para>

<para>
En élla encontrará siempre las <emphasis remap="bf">últimas</emphasis> versiones de las traducciones
«oficiales»:  <literal remap="tt"><ulink
url="http://www.insflug.org"
>www.insflug.org</ulink
></literal>. Asegúrese de comprobar cuál es la última
versión disponible en el Insflug antes de bajar un documento de un
servidor réplica. 
</para>

<para>
Además, cuenta con un sistema interactivo de gestión de fe de erratas y
sugerencias en línea, motor de búsqueda específico, y más servicios en los
que estamos trabajando incesantemente.
</para>

<para>
Se proporciona también una lista de los servidores réplica (<emphasis remap="it">mirror</emphasis>)
del Insflug más cercanos a Vd., e información relativa a otros recursos en
castellano.
</para>

<para>
En <literal remap="tt"><ulink
url="http://www.insflug.org/insflug/creditos.php3"
>http://www.insflug.org/insflug/creditos.php3</ulink
></literal> cuenta con una
detallada relación de las personas que hacen posible tanto esto como las
traducciones.
</para>

<para>
¡Diríjase a <literal remap="tt"><ulink
url="http://www.insflug.org/colaboracion/index.php3"
>http://www.insflug.org/colaboracion/index.php3</ulink
></literal> si desea
unirse a nosotros!.
</para>

<para>
Francisco José Montilla, <literal remap="tt"><ulink
url="mailto: pacopepe@insflug.org"
>pacopepe@insflug.org</ulink
></literal>. 
</para>

</sect1>

</article>
