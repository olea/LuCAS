		       Linux Joystick driver v1.2.15
	       (c) 1996-1999 Vojtech Pavlik <vojtech@suse.cz>
			     Sponsored by SuSE
-----------------------------------------------------------------------------
Traducción para NuLies (Núcleo de Linux en español) por Rubén Gómez Antolí.
<mixtolobo@mixmail.com> - 10 de Noviembre de 2000
-----------------------------------------------------------------------------

0. Declaración
~~~~~~~~~~~~~~
   Este programa es software libre; se puede redistribuir y/o modificarlo bajo 
los términos de la licencia pública y general GNU tal como se publicó por la 
Free Software Foundation; o bien en la versión 2 de la licencia, o (a su 
elección) cualquier versión posterior.

   Este programa está distribuido con la esperanza de que pueda ser útil, pero 
SIN NINGUNA GARANTÍA; sin implicar, tampoco, la garantía de MERCADO o DE AJUSTE
A UN DETERMINADO PROPÓSITO. Vea la licencia pública general GNU para más
detalles.

   Se debe haber recibido una copia de la licencia pública general GNU con este
programa; si no, escriba a la Free Software Foundation, Inc. 59 Temple Place, 
Suite 330, Boston, MA 02111-1307 USA.

   Si necesita contactar conmigo, el autor, puede hacerlo por correo electróni-
co a la dirección <vojtech@suse.cz>, o por correo normal:

	Vojtech Pavlik, Ucitelska 1576, Praga 8, 182 00 República Checa.

   Para su conveniencia, la licencia pública general GNU versión 2 está inclui-
da en el paquete: Vea el fichero COPYING.

1. Introducción
~~~~~~~~~~~~~~~
   El controlador de joystick para Linux proporciona soporte para varios joys- 
ticks y dispositivos similares.

   Este normalmente incluye varios joysticks analógicos y gamepad (ambos basados
en resistencias variables y microinterruptores+resistencias), siguiendo con 
joysticks estándar para IBM PC, con extensiones como "sombreros" (del inglés
"hat") y botones adicionales compatibles con CH Flightstick Pro, 
ThrusMaster FCS	o gamepads con 6 y 8 botones.

   En suma a estos también se soportan algunos de los nuevos joysticks de PC que
usan protocolos digitales propietarios para comunicarse por encima del puerto 
de juegos, normalmente para FPGaming, Gravis, Logitech, MadCatz, Microsoft, 
Creative y ThrusMaster. El soporte para el protocolo de Saitek está todavía por
hacer.

   El controlador también da soporte para muchos gamepads y joystick que son 
usados por varios computadores no-PC y consolas de juego. Aquí se incluyen joy-
sticks de múltiples sistemas (Atari,Amiga, Commodore, Amstrad), gamepads de Sega
(Master System, Genesis, Saturn),gamepads de Nintendo (NES,SNES,N64), gamepads 
de Sony (PSX). El soporte para Atari Jaguar, Atari 2000, Nes FourScore, SNES 
Multitap y otras podría añadirse después.

   Por último, pero no por ser menos, está también el soporte de joystick de 
Amiga para el puerto Linux de Amiga.

   Usted puede encontrar errores mientras usa este controlador, o que este no 
puede hacer un uso completo de su joystick, estoy interesado en oír cosas de
este tipo. Informes sobre errores e historias de sucesos son siempre bien reci-
bidos.

	El paquete de joystick esta disponible en los siguientes sitios FTP:

		ftp://ftp.suse.cz/pub/development/joystick/
		ftp://atrey.karlin.mff.cuni.cz/pub/linux/joystick/
		ftp://ftp.gts.cz/pub/linux/joystick/

	y la página madre de este controlador puede encontrarse en:

		http://www.suse.cz/development/joystick/
		http://atrey.karlin.mff.cuni.cz/~vojtech/joystick/
		http://www.trylinux.com/projects/joystick/
		http://www.linuxgames.com/joystick/

	Hay también una lista de correo para el controlador en:
		
		listproc@atrey.karlin.mff.cuni.cz

envíe "subscribe linux-joystick Su nombre" para suscribirse.

2. Uso
~~~~~~
   Usted puede obtener este controlador de dos formas diferentes- en el paquete
de joystick o en el Núcleo. Porque, para un uso satisfactorio del joystick, las
utilidades del paquete son útiles, ademas pueden ser necesarias, y definiti-
vamente recomendables, le sugiero que obtenga el paquete de alguna de las 
localizaciones antes mencionadas. El resto de este fichero asume que lo tiene.

2.1 Compilando el paquete del controlador
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Para compilar las utilidades del paquete de joystick, y el controlador 
mismo, como un modulo normal, primero debe desempaquetar el paquete, y entonces
editar el Makefile para reunir sus necesidades (podría estar usando módulos
versionados). Usted necesitara también desempaquetar y configurar

	make config

el núcleo en

	/usr/src/linux

Además, si usted esta usando módulos versionados, usted necesitara hacer

	make dep

en el núcleo, para crear algunos ficheros necesarios. Después de esto,
compile el controlador de joystick

	make

Y después instálelo

	make install

   En el caso de que no haya utilizado el controlador antes, necesitara crear 
los dispositivos de joystick en /dev para que las aplicaciones puedan usarlo:
	
	make devs

   Para la creación manual de los dispositivos de joystick, compruebe el archi-
vo Documentation/devices.txt en el árbol fuente de Linux.

   Si usted no quiere enredarse con el núcleo, y utilizar el controlador 
sólamente, como módulo, salte las dos secciones siguientes, procediendo a 
partir de 2.4, porque todo lo que necesita está ya hecho.

2.2 Parcheando el núcleo
~~~~~~~~~~~~~~~~~~~~~~~~
   Si usted ya tiene el controlador más reciente de joystick en el núcleo, 
salte esta sección. Si no, necesita parchear el núcleo, para que contenga
la versión actual del controlador. Usted lo haría con un comando:

	patch -Esp1 < /usr/src/joystick-1.2.x/kernel-2.x.y.diff

en 
	
	/usr/src/linux

2.3 Compilando el núcleo
~~~~~~~~~~~~~~~~~~~~~~~~
   Para compilar el soporte de joystick en el núcleo, use los guiones (scripts)
de configuración del núcleo, y conteste "Y" al soporte de joystick y también 
por lo menos una de las opciones de hardware específico. Después de hacer algo
como 

	make bzlilo

habrá hecho la instalación del controlador. Sólo reinicie y el controlador 
debería encontrar todos los joystick conectados. De todas formas, lea las 
notas sobre los controladores de hardware específico más adelante en este 
archivo.

   Usted puede también compilar el controlador como módulo, respondiendo "M"
a todos los soportes de joystick que quiera tener como módulos. Es posible 
tener el controlador principal de joystick compilado en el núcleo y los con- 
troladores de hardware dependientes como módulos. Después compile los módulos

	make modules

  E instálelos

	make modules_install

  ahora está listo, y puede proceder al siguiente paso.

2.4 Insertando los módulos en el núcleo
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Después de instalar los módulos usted lo primero que necesitara es insertar
el modulo del controlador genérico de joystick en el núcleo

	insmod joystick

   y entonces uno o mas de los módulos de hardware especifico

	insmod joy-alguno

   donde "alguno" es el tipo de su joystick. Mire más abajo para una explicación
mas precisa. Alternativamente usted puede añadir las líneas
	
	alias char-major-15 joy-alguno
	options joy-alguno js_xx=x,x,x,x,...

   al fichero /etc/conf.modules, de manera que el módulo de joystick se cargue 
automáticamente cuando los dispositivos /dev/js estén accesibles.

2.5 Verificando que funciona
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Para comprobar la funcionalidad del controlador de joystick, tenemos el 
programa jstest. Puede ejecutarlo tecleando:

	jstest /dev/js0
   
   Y debería mostrarse una línea con los valores de joystick, los cuales se 
actualizan al mover la palanca, y presionar sus botones. Los ejes deben estar 
todos en cero cuando el joystick esté en el centro. No deberían descontrolarse 
hacia valores cercanos, y deberían mantenerse estables para cualquier otra 
posición de la palanca. Debe tener el rango completo desde -32767 hasta 32767. 
Si reunimos todo esto, entonces todo está perfecto, y usted puede comenzar a
jugar. :)

   Si esto no es así, entonces podría haber un problema. Pruebe a calibrar
el joystick, y si todavía no funciona, lea la sección de controladores de este 
fichero, la sección de localización de problemas, y las PUF.

N.d.T.: (PUF: Preguntas de Uso Frecuente)


2.6. Calibración
~~~~~~~~~~~~~~~~
   Para muchos joystick usted no necesitara una calibración manual, ya que el 
joystick debería ser autocalibrado por el controlador "automagicamente". Sin
embargo, con algunos joystick analógicos, que no usan resistencias lineales, o 
si quiere tener mejor precisión, puede usar el programa jscal

	jscal -c /dev/js0

   incluido en el paquete de joystick para mejorar los coeficientes de corre- 
ción que el controlador haya podido elegir.

   Después de la calibración puede verificar si quiere la nueva calibración 
usando el comando jstest, y si lo hace, puede guardar los coeficientes de 
corrección en un fichero

	jscal -p /dev/js0 > /etc/joystick.cal

   Y añadir una linea a su guión rc ejecutando el fichero

	source /etc/joystick.cal

   De esta forma, después del siguiente reinicio su joystick continuara cali-
brado. También puede añadir la linea jscal -p a su guión de apagado.

3. Información del controlador de HW especifico
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   En esta sección se describe cada uno de los controladores específicos de 
hardware.

3.1 Joystick analógicos
~~~~~~~~~~~~~~~~~~~~~~~
   El joy-analog.c usa la entrada analógica estándar del puerto de juegos, y 
por lo tanto soporta todos los joystick y gamepads estándar. También soporta 
extensiones como sombreros adicionales y botones compatibles con CH Flightstick
Pro, ThrustMaster FCS o gamepads de 6 y 8 botones.
	
   Sin embargo, los únicos tipos que se pueden autodetectar son:

* Joystick de 2 ejes, 4 botones.
* Joystick de 3 ejes, 4 botones.
* Joystick de 4 ejes, 4 botones.

   Para el soporte de otros tipos de joystick (con mas/menos ejes,sombreros y 
botones) necesitara especificar el tipo o en la linea de comando del núcleo o 
en la linea de comando del modulo, cuando inserte joy-analog.o en el núcleo. 
Los parámetros son:

	js_an=p0,m0,n0,p1,m1,n1 ...

   Donde "p" es el numero de puerto, p.ej. 0x201, que es la dirección estándar.
"m" y "n" son los bit de mascara del joystick 0 y joystick 1 para el puerto 
especifico de joystick. Los bit en el bit de mascara significan:

	Bit |   2^n | Significado
	----------------------------------
	 0  |     1 | Eje X1
	 1  |     2 | Eje Y1
	 2  |     4 | Eje X2
	 3  |     8 | Eje Y2
	 4  |    16 | Botón A
	 5  |    32 | Botón B
	 6  |    64 | Botón C
	 7  |   128 | Botón D
	 8  |   256 | CHF, Botones X e Y
	 9  |   512 | CHF, Sombrero 1
	10  |  1024 | CHF, Sombrero 2
	11  |  2048 | FCS, Sombrero
	12  |  4096 | Pad, Botón X
	13  |  8192 | Pad, Botón Y
	14  | 16384 | Pad, Botón U
	15  | 32768 | Pad, Botón V

(CHF = CH Flightstick Pro, FCS = ThrustMaster FCS)

   A continuación se muestra una tabla con los joystick para los cuales se
conocen los valores de "m". Si tiene algo que añadir o corregir, puede mandarme
un correo electrónico.

	Joystick				| Valor de 'm'
	-------------------------------------------------------
	Joystick simple de 2-botones, 2 -ejes	| 0x0033
	Segundo joystick simple en cable-Y	| 0x00cc
	Genius Flight2000 F-12			| 0x00f3
	Genius Flight2000 F-21			| 0x08f7
	Genius Flight2000 F-22			| 0x02ff
	Genius GameHunter G-06			| 0xf0f3
	Genius MaxFire G-07			| 0xf0f3
	Genius PowerStation			| 0xf0f3
	Laing #1 PC SuperPad			| 0xf0f3
	Logitech Wingman			| 0x003b
	Microsoft SideWinder Standard		| 0x003b
	QuickShot QS-201 SuperWarrior		| 0x00fb
	Saitek Megapad XII			| 0x30f3
	PC Powerpad Pro				| 0x30f3

  En el caso de que tenga alguno de los joystick de la tabla de abajo, y no
trabaje con el controlador especifico en modo digital por alguna razón, puede 
usarlos en modo analógico con el controlador joy-analog. De todas formas, la
operación digital es siempre mejor.

	Joystick				| Valor de 'm'
	-------------------------------------------------------
	Gravis GamePad Pro - Modo analógico	| 0x00f3
	Genius Flight2000 F-23			| 0x02ff
	Microsoft SideWinder 3D Pro - Modo CHF 	| 0x02ff
	Microsoft SideWinder 3D Pro - Modo FCS 	| 0x08f7

   Un ejemplo que configuraría el controlador para usar dos joystick de dos 
ejes, dos botones conectado al puerto 0x201, un joystick de cuatro botones y 
cuatro ejes conectado al puerto 0x202, un joystick compatible CHF de cuatro 
ejes, seis botones y dos sombreros en 0x203, y un joystick compatible FCS con 
dos ejes y cuatro botones con un solo sombrero en 0x207:

	js_an=0x201,0x33,0xcc,0x202,0xff,0,0x203,0x7ff,0,0x207,0x8f3,0

   Si no puede convertir bits en números hexadecimales fácilmente a cabeza, 
puede, simplemente, sumar los valores de la columna 2^n decimalmente y usar 
estos números en su lugar. Usando este método usted obtendría una linea de 
comando como esta:

	js_an=0x201,51,204,0x202,255,0,0x203,2047,0,0x207,2291,0

   Y haría lo mismo que la linea explicada arriba. Use la forma que mas le 
guste.

3.2 Microsoft SideWinder joysticks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo Microsoft "Digital Overdrive" esta soportado por el modulo 
joy-sidewinder.c. Todos los joystick actualmente soportados son:

* SideWinder 3D Pro
* SideWinder Force Feedback Pro
* SideWinder Force Feedback Wheel
* SideWinder FreeStyle Pro
* SideWinder GamePad (hasta 4, unidos juntos)
* SideWinder Precision Pro

   y se autodetectan, así que no se necesitan los parámetros del modulo.

   Hay un problema con el 3D Pro. Informan de 9 botones, aunque el joystick
solo tenga 8. El noveno botón es un interruptor de modo en la parte trasera del
joystick. Sin embargo, si lo mueve, reseteara el joystick, y hará que no res- 
ponda durante un tercio de segundo. Además, el joystick también se recentrara, 
adoptando la posición en que estuviera durante ese tiempo como centro. Uselo, 
si quiere, pero pienselo primero.

   El estándar SideWinder no es un joystick digital, así que esta soportado por
el controlador analógico descrito anteriormente.

3.3 Dispositivos Logitech ADI
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo ADI de Logitech esta soportado por el modulo joy-logitech.c. 
Debe soportar cualquier dispositivo Logitech usando este protocolo. Esto in- 
cluye, aunque no esta limitado:
	
* Logitech CyberMan 2
* Logitech ThunderPad Digital
* Logitech WingMan Extreme Digital
* Logitech WingMan Formula
* Logitech WingMan Interceptor
* Logitech WingMan GamePad
* Logitech WingMan GamePad USB
* Logitech WingMan GamePad Extreme
* Logitech WingMan Extreme Digital 3D

   Los dispositivos ADI se autodetectan, y el controlador soporta hasta dos (en
cualquier combinación) dispositivos en un solo puerto de juegos, usando un 
cable Y o encadenándolos juntos.

   El joystick Logitech WingMan, Logitech WingMan Attack, Logitech WingMan 
Extreme y Logitech WingMan ThunderPad no son joystick digitales y se pueden 
controlar por el controlador analógico descrito anteriormente. El Logitech 
WingMan Warrior y Logitech Magellan están soportados por los controladores 
serie descritos después. El Logitech CyberMan, Logitech WingMan Force y 
Logitech WingMan Formula Force no están soportados todavía.

3.4 Gravis GrIP
~~~~~~~~~~~~~~~
   El protocolo Gravis GrIP esta soportado por el modulo joy-gravis.c. Actual- 
mente soporta:

* Gravis GamePad Pro
* Gravis Xterminator
* Gravis BlackHawk Digital

   Todos estos dispositivos son autodetectables, y puede usar cualquier combi- 
nación de hasta dos de esos pads enchufándolos juntos o usando un cable Y en un
solo puerto de juegos.

   El GrIP MultiPort y el Gravis Xterminator DualControl no están soportados 
todavía.
   El Gravis Stinger es un dispositivo serie y esperanzadoramente será sopor- 
tado en el futuro.
   Otros joystick Gravis están soportados por el controlador joy-analog.

3.5 FPGaming A3D y MadCatz A3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo Assassin 3D creado por FPGaming, se usa en ambos, para si mismo
por FPGaming y en licencia por MadCatz. Los dispositivos A3D están soportados
por el modulo joy-assassin. Actualmente soporta:

* FPGaming Assassin 3D
* MadCatz Panther
* MadCatz Panther XL

   Todos estos dispositivos son autodetectables. Debido a que el Assassin 3D
y el Panther permiten conectar joystick analógicos a ellos, estos también están
soportados en el controlador. El controlador usa el parámetro js_as para los
joystick analógicos, el cual tiene la misma sintaxis que para el controlador 
analógico js_an.

   El soporte de trackball esta lejos de la perfección en esta etapa del desa- 
rrollo, pero permite su uso.

3.6 ThrustMaster DirectConnect (BSP)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo TM DirectConnect (BSP) esta soportado por el modulo 
joy-thrustmaster.c. Este incluye, aunque no esta limitado:

* ThrustMaster Millenium 3D Inceptor
* ThrustMaster 3D Rage Pad
* ThrustMaster Fusion Digital Game Pad

   El controlador no soporta directamente, aunque funciona prometedoramente:

* ThrustMaster FragMaster
* ThrustMaster Attack Throttle

   Si tiene uno de estos, contacte conmigo.

   Los dispositivos BSP son autodetectables, así que no es necesario darle
parámetros al modulo.

3.7 Creative Labs Blaster
~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo Blaster esta soportado por el modulo joy-creative.c.
Actualmente, este soporta solamente:

* Creative Blaster GamePad Cobra

   Se pueden usar dos joystick en un solo puerto de juegos,usando un cable Y.

3.8 Tarjetas de juegos PDPI Lightning 4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Las tarjetas de juegos PDPI Lightning 4 están soportadas por el modulo
joy-lightning.c. Este controlador es solo para joystick analógicos conectados
a la tarjeta - si quiere usar algún dispositivo digital, necesita usar su
controlador especifico. La tarjeta trabajara en el modo herencia (d.ing. 
legacy) con él, pienso.

   Dado que todas las características de los joystick analógicos no pueden ser
detectadas, este controlador necesita una linea de comando:

	js_l4=p0,m0,n0,p1,m1,n1,.....

   Como puede ver, es muy similar a la linea de comando del controlador
analógico. Realmente es igual excepto para el significado de p0. p0 es, en este
caso, el puerto donde el joystick esta enchufado:

	  p  | Port
	----------------------------
	  0  | Tarjeta principal, puerto 1
	  1  | Tarjeta principal, puerto 2
	  2  | Tarjeta principal, puerto 3
	  3  | Tarjeta principal, puerto 4
	  4  | Tarjeta secundaria, puerto 1
	  5  | Tarjeta secundaria, puerto 2
	  6  | Tarjeta secundaria, puerto 3
	  7  | Tarjeta secundaria, puerto 4

   Se permite como máximo dos tarjetas en un sistema, debido al diseño de la 
misma.

   Vea la descripción del controlador de joystick analógico para la explicación
de los valores de m0 y n0.

3.9 Trident 4DWave / Aureal Vortex
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Las tarjetas de sonido con un chipset Trident 4DWave DX/NX o Aureal Vortex
proporcionan un modo de "Puerto de juegos avanzado" donde la tarjeta de sonido
maneja el polling del joystick. Este modo se soporta mediante el modulo joy-pci.

   Si no se le dan parámetros al modulo, el modulo joy-pci pone todas las tar- 
jetas que encuentre en modo "avanzado", e intentara autodetectar el tipo de 
joystick enchufado. Solo puede detectar el mismo tipo de joystick que pueda 
detectar el modulo joy-analog.

   Este modulo acepta parámetros de la forma:

	js_pci=t0,i0,m0,n0,t1,i1,m1,n1,....

   El valor "t" especifica el tipo de tarjeta, tal y como sigue:

	  t  | Tipo de Tarjeta
	----------------------------
	  0  | Trident 4DWave DX
	  1  | Trident 4DWave NX
	  2  | Aureal Vortex1 (Au8820 chipset)
	  3  | Aureal Vortex2 (Au8830 chipset)

   Si tiene mas de una tarjeta del mismo tipo, el parámetro "i" le permitirá 
escoger a que tarjeta aplicar los valores "m" y "n". La cuenta es desde "0". 
(El controlador detecta las tarjetas en el orden listado en la tabla de arriba.)

   Los valores "m" y "n" tienen el mismo significado que para el modulo
analógico, con la excepción de que el valor m=0, n=0 indican que joy-pci
debe ignorar completamente ese puerto. Esto se puede usar para reservar
cierto puerto solamente para operaciones MIDI.

   Por ejemplo, vamos a decir que tiene 3 tarjetas de sonido - una 4DWave
DX, una 4DWave NX, y una Vortex 2. Usted tiene un joystick compatible de tres 
ejes, cuatro botones,y un sombrero CHF en la DX. Usted usa la NX como 
interfaz para un dispositivo MIDI externo. Finalmente, tiene dos joysticks de 
dos ejes y dos botones en la Vortex. Su linea de comando debe parecerse a esta:

	js_pci=0,0,0x207,0,1,1,0,0,3,0,0x33,0xcc

3.10 Amiga.
~~~~~~~~~~~
  Los joysticks Amiga, conectados a un Amiga, están soportados por el contro-
lador joy-amiga.c. Dado que no son autodetectables, el controlador tiene una
linea de comando.

	js_am=a,b

   a y b definen los joysticks conectados a los puertos JOY0DAT y JOY1DAT
del Amiga.

	Valor | Tipo de Joystick
	------------------------
	  0   | Ninguno
	  1   | Joystick digital de 1 botón

   Por ahora no se soportan mas tipos de joystick, pero esto podría cambiar en
el futuro si tuviera un Amiga al alcance de mis dedos.

3.11 Consolas de juegos, pads de 8-bit y joysticks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Vea joystick-parport.txt para mas información.

3.12 Dispositivos SpaceTec/LabTec.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Los dispositivos serie SpaceTec se comunican usando el protocolo SpaceWare.
Este se soporta mediante los controladores joy-spaceorb y joy-spaceball. Los 
dispositivos actualmente soportados por joy-spaceorb son:

* SpaceTec SpaceBall Avenger
* SpaceTec SpaceOrb 360

   Los dispositivos actualmente soportados por joy-spaceball son:

* SpaceTec SpaceBall 4000 FLX

   En suma para tener el modulo joy-spaceorb/spaceball en el núcleo, necesita
añadir un puerto serie a él. Para hacerlo, ejecute el programa jsattach:

	jsattach --spaceorb /dev/ttySx &

o 

	jsattach --sball4 /dev/ttySx &

donde /dev/ttySx es el puerto serie al que el dispositivo esta conectado. 
Después de hacer esto, el dispositivo será presentado y empezará a trabajar.

@@@ REVISAR @@@@

   Hay un problema con el SpaceOrb. El botón #6, en el lado del fondo de la 
esfera, aunque parece un botón ordinario, provoca un recentrado interno del
spaceorb, moviendo el punto cero a la posición en la que estuviera la bola
en el momento de presionar el botón. Así, pienselo antes de unirlo a cualquier
otra función.

@@@ FIN_REVISAR @@@

Todavía no están soportados SpaceTec SpaceBall 2003 FLX y 3003 FLX.

3.13 Dispositivos Logitech SWIFT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo serie SWIFT esta soportado por el modulo joy-warrior. Actual-
mente soporta solamente:

* Logitech WingMan Warrior

pero en el futuro, podrá soportar también el Logitech CyberMan (el original,
no el CM2). Para usar el modulo, necesitara ejecutar jsattach después de
insertar/compilar el modulo en el núcleo:

	jsattach --warrior /dev/ttySx &

ttySx es el puerto serie donde su Warrior este conectado.

3.14 Magellan / Space Mouse
~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El Magellan (o Space Mouse), manufacturado por LogiCad3d (formalmente
Space Systems), para muchas otras compañías (Logitech, HP, ...) esta soportado
por el modulo joy-magellan. Actualmente soporta solamente los siguientes 
modelos:

* Magellan 3D
* Space Mouse

   Los botones adicionales en las versiones "Plus" no están soportados todavía.

   Para usarlos deberá conectar el puerto serie al controlador mediante el 
comando

	jsattach --magellan /dev/ttySx &

Después de esto, el magellan se detectara, inicializara, pitara y el disposi-
tivo /dev/jsX se podra emplear.

4. Localización de Problemas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Hay una probabilidad alta de que tenga algunos problemas. Para comprobar
que el controlador funciona, si esta en duda, use la utilidad jstest en 
alguno de sus modos. Los modos mas usados son "normal" - para la interfaz 1.x,
y "old" para la interfaz "0.x". Puede ejecutarlo tecleando:

	jstest --normal /dev/js0
	jstest --old    /dev/js0

   Si su problema proviene del hecho de que los controladores no pueden detec-
tar el joystick conectado a su puerto de juegos, y usted decide que necesita
mi ayuda (la cual proporcionare de buena gana), por favor use la utilidad
joydump primero. Se creara con solo teclear

	make joydump.o

   en el directorio donde desempaqueto el paquete de joystick. Puede ejecutarla
mediante

	insmod joydump.o

   en el mismo directorio. Devolverá un "device busy" (dispositivo ocupado) o
el error "initialization failed" (fallo de inicialización). Eso es que todo va
perfectamente, y ya ha realizado su trabajo. Los resultados los puede encontrar
en el diario del sistema (del ingles: system log) o en la salida del comando

	dmesg

   Por favor mandeme los resultados junto con el relato de su problema.

   ¡ Ah, y lea los PUF ! :) 

5· Preguntas de Uso Frecuente (PUF)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Pregunta: El controlador no encuentra ningún joystick conectado a mi tarjeta
          de sonido y responde con los mensajes "joy-something: no joystick
          found" (joy-algo: joystick no encontrado) y "joy-something.o: 
	  init_module: Device or resource busy." (joy-algo.o: inicialización de
	  de modulo: Dispositivo o recurso ocupado) o "Initialization of joy-
	  something failed" (Inicialización de joy-algo fallida). ¿Cual puede
	  ser la causa?
Respuesta: La causa mas común es que el puerto joystick de su tarjeta de sonido
	  no este habilitado. Si tiene una tarjeta ISA PnP, necesitara las
	  isapnptools para configurar el puerto de juegos. Las tarjetas No-PnP
	  normalmente facilitan alguna opción en el controlador de sonido - vea
	  los documentos del controlador de sonido y las fuentes para habili-
	  tar el puerto. Dese cuenta que en el caso de una tarjeta PnP tiene
	  que cargar el controlador del joystick como modulo después de ejecu-
	  tar el comando isapnp, si no, no trabajara en el orden correcto.

P: Cualquier acceso al dispositivo de joystick me da "Operation not supported
   by device" (Operación no soportada por el dispositivo). ¿ Que estoy haciendo
   mal?

R: Esta utilizando un núcleo 2.0 y olvido hacer insmod al modulo del hardware
   especifico. Usted no necesita solamente el modulo joystick.o, necesita además
   uno de los otros ficheros joy-*.o (el más normal joy-analog.o), como se 
   ha descrito en este documento en la sección 2. Si no esta usando módulos,
   entonces no responda "Y" a ninguna de las preguntas de hardware específico.
   Vea, de nuevo, la sección 2. Si ha seleccionado el hardware específico, y 
   todavía le sigue apareciendo el mismo mensaje, compruebe que ha seleccionado
   el correcto, y si todavía no funciona, dirijase a la PUF previa.

P: Todo esta bien, excepto que obtengo el error "No such device" (No hay tal
   dispositivo) cuando intento hacer algo con /dev/js0. ¿Cual es la causa?

R: Esta usted ejecutando un núcleo 2.1 o 2.2 y necesita leer la PUF previa. 

@@@ REVISAR @@@

P: Al hacer "insmod joystick.o" obtengo un MONTÓN de símbolos irresolutos,
   incluso "printk" y otros. ¿Porque?

R: Puede ser que tenga su núcleo compilado sin soporte de módulos. Si esa es
   la causa, recompile su núcleo con el soporte de modulo activado. O, usted
   usa símbolos versionados, y no tiene -DMODVERSIONS en el Makefile del 
   controlador de joystick, o viceversa. Corrija la situación o bien eliminan-
   do o añadiendo -DMODVERSIONS al Makefile.

P: Al hacer "insmod joy-something" obtengo un grupo de símbolos irresolutos, 
   tal como "js_register_port, js_unregister device" y otros. ¿Cual es el
   error?

@@@ FIN_REVISAR @@@

R: Necesita hacer primero "insmod joystick.o".

P: "jstest 1" o "jscal 1" no se ejecutan, y devuelven el error "File not 
   found" (Fichero no encontrado). ¿ Cual es el problema ?

R: El interfaz de la linea de comandos para esas herramientas es diferente
   de la versión 0.8.0. Tiene que especificar el nombre de dispositivo comple-
   to, p. ej. "jstest /dev/js0".

P: Al ejecutar "jstest /dev/js0" da el error "File not found". ¿Cual es la
   causa?

R: El fichero de dispositivo no existe. Ejecute "make devs".

P: ¿Es posible conectar mi viejo joystick o pad de Atari/Commodore/Amiga
   /consola que usa un conector de 9 pines de tipo D al puerto serie de mi Pc? 

R: Si, es posible, pero quemaría el puerto serie o el pad. Y por supuesto, no
   funcionaria.

P: Mi joystick no funciona con Quake / Quake 2. ¿Cual es la causa? 

R: Quake / Quake 2 no tiene soporte de joystick. Use joy2key para simular la
   presión de las teclas para ellos.

@@@ REVISAR @@@

6. Interfaz de programación
~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El controlador 1.0 usa una nueva rutina basada en la aproximación al con-
trolador del joystick. El programa de usuario no hace polling para obtener los 
valores del joystick, es el controlador del joystick el que informa cuando
hay algún cambio en dichos valores. Para mas información puede ver joystick-
api.txt, joystick.h y jstest.c incluidos en el paquete de joystick. El dispo-
sitivo de joystick puede ser usado en cualquier modo de blocking o nonblocking
y soporta llamadas seleccionadas ().

  Para mantener la compatibilidad la interfaz antigua (v 0.x),esta está todavía
incluida. Cualquier llamada al controlador de joystick que usa la interfaz
antigua devolverá valores que son compatibles con la misma. Esta interfaz está
todavía a 2 ejes, y las aplicaciones que la usan normalmente decodifican 
solamente 2 botones, aunque el controlador proporciona hasta 32.
 
@@@ FIN_REVISAR @@@

7. Créditos
~~~~~~~~~~~
   Gracias a las siguientes personas que contribuyeron al desarrollo 
del controlador de joystick con código, ideas o especificaciones:

	Arthur C. Smith		<asmith@cbnewsd.att.com>
	Eyal Lebedinsky		<eyal@eyal.emu.id.au>
	Jeff Tranter		<tranter@software.mitel.com>
	Carlos Puchol		<cpg@cs.utexas.edu>
	Matt Rhoten		<mrhoten@oz.net>
	Dan Fandrich		<dan@fch.wimsey.bc.ca>
	Sverker Wilberg		<sverkerw@manila.docs.uu.se>
	Hal Maney		<maney@norden.com>
	Bernd Schmidt		<crux@pool.informatik.rwth-aachen.de>
	Alan Cox		<alan@lxorguk.ukuu.org.uk>
	John Markus Bjorndalen	<johnm@cs.uit.no>
	Boris Muehmer		<mhs@cybernet-ag.de>
	Robert W. Grubbs	<rwgrubbs@vt.edu>
	Pete Chown		<pete.chown@skygate.co.uk>
	Benji York		<benji@cookeville.com>
	Leslie F. Donaldson	<donaldlf@cs.rose-hulman.edu>
	Eng-Jon Ong		<ongej@dcs.qmw.ac.uk>
	Ragnar Hojland Espinosa	<ragnar@lightside.ddns.org>
	Brian Gerst		<bgerst@quark.vpplus.com>
	Andree Borrmann		<a.borrmann@tu-bs.de>
	Martin Giguere		<zefrench@hotmail.com>
	David Thompson		<dcthomp@mail.utexas.edu>
	Justin Wake		<spectre@telefragged.com>
	Benoit Triquet		<benoit@adsl-216-100-248-201.dsl.pacbell.net>
	John Dahlstrom		<jodaman@bradley.edu>
	Dan Gohman		<gohmandj@mrs.umn.edu>
	Joe Krahn		<krahn@niehs.nih.gov>
	David Kuder		<alphagod@penguinpowered.com>
	Raymond Ingles		<sorceror@tir.com>

   Si piensa que debe estar en esta lista y no es así, es posible que haya 
olvidado incluirle -contacte conmigo y corregiré el error. :)

   Gracias a KYE Systems Europe, quienes me proporcionaron las fuentes del 
controlador para el Genius Flight2000 Digital F-23, el cual resulta ser
idéntico (en software) al Microsoft SideWinder 3D Pro.

   Gracias a ThrustMaster Inc. quienes me proporcionaron documentos para las
especificaciones de su protocolo digital, y a Trystan A Larey-Williams 
<axe@mail.wsu.edu>, quien escribió un attempt del controlador para ellos.

   Gracias a Creative Labs Europe, e Ifor Powell <ipowell@cle.creaf.com>,
quien me proporcionaron los documentos de su primera generación de Blaster GamePad.

@@@ REVISAR @@@

   Gracias especialmente para FP-Gaming, Inc. y James C Barnes
<james@fpgaming.com>, quien me ayudo con ayuda y información detallada sobre
el protocolo y los dispositivos Assassin 3D, e incluso me envío un Panther y
un Panther XL para probarlos junto con camisetas interiores.


@@@ FIN_REVISAR @@@

   Gracias especialmente a PDPI, Mike Pelkey <pdpi@email.msn.com> y Brand
kvavle <BrandK@blackdiamond.com>, por su ayuda mediante documentación y un
código de ejemplo para las tarjetas de juegos L4, y además enviarme una tarjeta
para probar mi controlador con ella.

   Gracias a LogiCad3D por su servicio, por tener las especificaciones en linea
y por la bonita música de su teléfono.

   Gracias especialmente a Logitech,Jerry de Raad <Jerry_de_Raad@logitech.com>,
Thomas Burgel <Thomas_Burgel@logitech.com>, Avinash Shinde 
<Avinash_Shinde@logitech.com> por proporcionarme un montón de información sobre
dispositivos, así como una gran caja que contenía un CyberMan2, un Wingman 
Extreme, un Magellan, un Wingman Warrior, dos MouseMan mice, y un teclado 
NewTouch.

   ¡ Gracias a todos los que me han ayudado a desarrollar este paquete de 
controladores !

   No doy las gracias ni a Microsoft ni a Gravis, quienes no soltaron una
palabra sobre su hardware... :(

8. Registro de Cambios
~~~~~~~~~~~~~~~~~~~~~~
   Vea el archivo ChangeLog para el registro de cambios.

9. Por Hacer
~~~~~~~~~~~~
