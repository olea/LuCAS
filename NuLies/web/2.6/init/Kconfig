
menu "Opciones del nivel de madurez del código"

config EXPERIMENTAL
	bool "Preguntar por controladores/código incompleto o en desarrollo"
	---help---
	  Algunas de las cosas que Linux soporta (como controladores de red,
	  sistemas de ficheros, protocolos de red, etc.) pueden estar en
	  un estado de desarrollo donde la funcionalidad, estabilidad o
	  el nivel de prueba no es todavía suficientemente bueno para uso
	  general. Esto se conoce habitualmente como la fase de «pruebas alfa»
	  en el lenguaje de los desarrolladores. Cuando una funcionalidad
	  está en fase alfa, estos desarrolladores normalmente no recomiendan
	  el uso generalizado de esta funcionalidad por parte del público en
	  general para evitar los mensajes de correo del estilo «¿Por qué
	  esto no funciona?». De todas formas, la prueba de estas
	  funcionalidades y su uso activo es bienvenido. Simplemente debe
	  conocer que tal vez el controlador o funcionalidad no alcance el
	  nivel normal de fiabilidad o puede fallar en algunas ocasiones
	  especiales. Los informes de errores correctamente documentados
	  por parte de gente familiarizada con el funcionamiento interno
	  del núcleo son normalmente bienvenidos por los desarrolladores
	  (antes de enviar informes de fallos, por favor lea los ficheros
	  <file:README>, <file:MAINTAINERS>, <file:REPORTING-BUGS,
	  <file:Documentation/BUG-HUNTING>, y
	  <file:Documentation/oops-tracing.txt> en las fuentes del núcleo).

	  Esta opción también hace que estén disponibles controladores
	  obsoletos. Estos son controladores que han sido reemplazados por
	  algo más, o marcados para su eliminación en una versión posterior
	  del núcleo.

	  A menos que intente ayudar a probar y desarrollar una nueva
	  funcionalidad o controlador que esté dentro de esta categoría, o
	  que necesite utilizar dicha funcionalidad obligatoriamente,
	  probablemente debería contestar N aquí, lo cual hará que el
	  configurador le presente menos opciones. Si dice aquí S, se le
	  ofrecerá la posibilidad de usar capacidades o controladores que
	  se consideran en fase alfa.

config CLEAN_COMPILE
	bool "Seleccionar sólo controladores que se espera que compilen sin errores" if EXPERIMENTAL
	default y
	help
	  Seleccione esta opción si ni siquiera quiere tener la opción de
	  configuración para controladores que se sabe que están rotos.

	  Si no está seguro, responda S.

config STANDALONE
	bool "Seleccionar sólo controladores que no necesiten firmware externo al compilar" if EXPERIMENTAL
	default y
	help
	  Seleccione esta opción si no tiene firmware para controladores que
	  lo requieran.

	  Si no está seguro, responda S.

config BROKEN
	bool
	depends on !CLEAN_COMPILE
	default y

config BROKEN_ON_SMP
	bool
	depends on BROKEN || !SMP
	default y

endmenu


menu "Configuración general"

config SWAP
	bool "Soporte para paginación de memoria anónima («swap»)"
	depends on MMU
	default y
	help
	  Esta opción le permite escoger si quiere tener soporte para los
	  llamados dispositivos o ficheros de intercambio (o de «swap») en
	  su núcleo, que se usan para tener más memoria virtual que la memoria
	  RAM actual que hay presente en su computadora. Si no está seguro,
	  responda S.

config SYSVIPC
	bool "IPCs de System V"
	---help---
	  Comunicación Entre Procesos (IPC) es un paquete de funciones de
	  biblioteca y llamadas al sistema que permite a los procesos
	  (programas en ejecución) sincronizarse e intercambiar información.
	  Esto se considera, generalmente, como algo bueno, y algunos programas
	  no funcionarán a menos que usted responda aquí S. En particular, si
	  desea ejecutar el emulador de DOS dosemu bajo Linux (lea el
	  DOSEMU-HOWTO, disponible en <http://tldp.org/docs.html#howto>), debe
	  responder aquí S.

	  Puede encontrar documentación acerca de IPC con «info ipc» y también
	  en la sección 6.4 de la Guía del Programador bajo Linux, disponible
	  en <ftp://lucas.hispalinux.es/pub/LuCAS/Manuales-LuCAS/GULP/> o en
	  version original inglesa en <http://www.tldp.org/docs.html#guide>.

config BSD_PROCESS_ACCT
	bool "Contabilidad de procesos BSD"
	help
	  Si responde S aquí, un programa de espacio de usuario podrá hacer
	  que el núcleo (mediante una llamada especial al sistema) escriba la
	  información de contabilidad de proceso a un fichero: siempre que un
	  proceso termine, el núcleo añadirá a ese fichero información
	  acerca del proceso. Esta informacion incluye cosas como la fecha de
	  creación, el usuario propietario, el nombre de la orden, el uso de
	  memoria, el terminal que lo creó...(la lista completa está en la
	  estructura acct del fichero de código <file:include/linux/acct.h>).
	  Es tarea del programa de espacio de usuario el hacer algo útil con
	  esta información. Esto es, normalmente, una buena idea, así que
	  responda S.

config SYSCTL
	bool "Soporte para sysctl's"
	---help---
	  El interfaz sysctl proporciona un método para cambiar dinámicamente
	  ciertos parámetros y variables del núcleo durante la ejecución del
	  mismo sin necesidad de recompilar el núcleo o de reiniciar el
	  sistema. El interfaz primario consiste en una llamada al sistema,
	  pero si responde S a "Soporte de sistema de ficheros /proc", se
	  generará un árbol con entradas sysctl modificables a partir del
	  directorio /proc/sys. Esto se explica en los ficheros de
	  <file:Documentation/sysctl/>. Dése cuenta de que habilitar esta
	  opción aumentará el tamaño del núcleo en, al menos, 8 KB.

	  Como generalmente es algo bueno, debería responder S aquí a menos
	  que esté construyendo un núcleo para discos de instalación/rescate o
	  si su sistema está muy limitado en cuanto a memoria.

config LOG_BUF_SHIFT
	int "Tamaño del búfer de mensajes del núcleo (16 => 64 KB, 17 => 128 KB)" if DEBUG_KERNEL
	range 12 20
	default 17 if ARCH_S390
	default 16 if X86_NUMAQ || IA64
	default 15 if SMP
	default 14
	help
	  Seleccione el tamaño del búfer de mensajes del núcleo como una
	  potencia de 2.
	  Valores predeterminados y ejemplos:
	  	     17 => 128 KB en S/390
		     16 => 64 KB en x86 NUMAQ ó IA-64
	             15 => 32 KB con SMP
	             14 => 16 KB con un solo procesador
		     13 =>  8 KB
		     12 =>  4 KB

config HOTPLUG
	bool "Support for hot-pluggable devices" if !ARCH_S390
	default ARCH_S390
	help
	  Say Y here if you want to plug devices into your computer while
	  the system is running, and be able to use them quickly.  In many
	  cases, the devices can likewise be unplugged at any time too.

	  One well known example of this is PCMCIA- or PC-cards, credit-card
	  size devices such as network cards, modems or hard drives which are
	  plugged into slots found on all modern laptop computers.  Another
	  example, used on modern desktops as well as laptops, is USB.

	  Enable HOTPLUG and KMOD, and build a modular kernel.  Get agent
	  software (at <http://linux-hotplug.sourceforge.net/>) and install it.
	  Then your kernel will automatically call out to a user mode "policy
	  agent" (/sbin/hotplug) to load modules and set up software needed
	  to use devices as you hotplug them.

config IKCONFIG
	bool "Soporte para .config dentro del núcleo"
	---help---
	  Esta opción incluye el contenido completo del fichero «.config» de
	  configuración del núcleo Linux, información del compilador que se
	  ha usado para construir el núcleo, el núcleo que se estaba
	  ejecutando cuando se construyó este núcleo y la versión del núcleo
	  del Makefile, directamente grabada en el núcleo. Permite saber qué
	  opciones del núcleo se están usando en un núcleo que esté
	  funcionando o que esté simplemente en disco. Esta información
	  puede extraerse con el script scripts/extract-ikconfig y ser así
	  usada como entrada para reconstruir un núcleo idéntico o para
	  compilar otro. También se puede extraer de un núcleo en operación
	  leyendo /proc/config.gz y /proc/config_built_with, si están
	  activados (ver más abajo). /proc/config.gz mostrará la configuración
	  que se usó para compilar el núcleo y /proc/config_built_with dará
	  información del compilador y máquina usados para construir tal
	  núcleo.

config IKCONFIG_PROC
	bool "Acceso a .config mediante /proc/config.gz"
	depends on IKCONFIG && PROC_FS
	---help---
	  Esta opción permite el acceso al fichero de configuración del
	  núcleo y a la información de compilación a partir de
	  /proc/config.gz.

menuconfig EMBEDDED
	bool "Desactivar características del núcleo (para sistemas incrustados)"
	help
	  Esta opción permite retirar varias características básicas del núcleo
	  en la compilación. Se usa principalmente en entornos especializados
	  toleran o necesitan un núcleo «no estándar». Úselo sólo si realmente
	  sabe lo que está haciendo.

config KALLSYMS
	 bool "Load all symbols for debugging/kksymoops" if EMBEDDED
	 default y
	 help
	   Say Y here to let the kernel print out symbolic crash information and
	   symbolic stack backtraces. This increases the size of the kernel
	   somewhat, as all symbols have to be loaded into the kernel image.

config FUTEX
	bool "Enable futex support" if EMBEDDED
	default y
	help
	  Disabling this option will cause the kernel to be built without
	  support for "fast userspace mutexes".  The resulting kernel may not
	  run glibc-based applications correctly.

config EPOLL
	bool "Enable eventpoll support" if EMBEDDED
	default y
	help
	  Disabling this option will cause the kernel to be built without
	  support for epoll family of system calls.

source "drivers/block/Kconfig.iosched"

config CC_OPTIMIZE_FOR_SIZE
	bool "Optimize for size" if EMBEDDED
	default y if ARM || H8300
	default n
	help
	  Enabling this option will pass "-Os" instead of "-O2" to gcc
	  resulting in a smaller kernel.

	  WARNING: some versions of gcc may generate incorrect code with this
	  option.  If problems are observed, a gcc upgrade may be needed.

	  If unsure, say N.

endmenu		# General setup


menu "Soporte para módulos cargables"

config MODULES
	bool "Habilitar soporte para módulos cargables"
        help
	  Los módulos del núcleo son pequeñas piezas de código compilado
	  que pueden insertarse en el núcleo en ejecución, en vez de estar
	  permanentemente integrados dentro del núcleo. Puede usar la
	  herramienta «modprobe» para insertarlos (y a veces retirarlos).
	  Si responde aquí S, podrá construir muchas partes del núcleo
	  como módulos (respondiendo M en vez de S cuando se le pida):
	  esto es realmente útil para opciones que no se usan normalmente
	  y que no sean necesarias para arrancar el sistema. Para más
	  información, vea las páginas de manual de modprobe, lsmod,
	  modinfo, insmod y rmmod.
	 
	  Si responde aquí S, necesitará ejecutar la orden «make
	  modules_install» para poner los módulos dentro de /lib/modules/
	  donde modprobe podrá encontrarlos (puede que necesite ser root
	  para hacer este último paso).

	  Si no está seguro, responda S.

config MODULE_UNLOAD
	bool "Descarga de módulos"
	depends on MODULES
	help
	  Con esta opción será capaz de descargar un módulo del núcleo
	  (sepa que algunos módulos pueden no ser descargables de ninguna
	  manera), lo cual hará que su núcleo sea ligeramente más pequeño
	  y simple. Si no está seguro, diga S.

config MODULE_FORCE_UNLOAD
	bool "Forced module unloading"
	depends on MODULE_UNLOAD && EXPERIMENTAL
	help
	  This option allows you to force a module to unload, even if the
	  kernel believes it is unsafe: the kernel will remove the module
	  without waiting for anyone to stop using it (using the -f option to
	  rmmod).  This is mainly for kernel developers and desperate users.
	  If unsure, say N.

config OBSOLETE_MODPARM
	bool
	default y
	depends on MODULES
	help
	  You need this option to use module parameters on modules which
	  have not been converted to the new module parameter system yet.
	  If unsure, say Y.

config MODVERSIONS
	bool "Module versioning support (EXPERIMENTAL)"
	depends on MODULES && EXPERIMENTAL
	help
	  Usually, you have to use modules compiled with your kernel.
	  Saying Y here makes it sometimes possible to use modules
	  compiled for different kernels, by adding enough information
	  to the modules to (hopefully) spot any changes which would
	  make them incompatible with the kernel you are running.  If
	  unsure, say N.

config KMOD
	bool "Automatic kernel module loading"
	depends on MODULES
	help
	  Normally when you have selected some parts of the kernel to
	  be created as kernel modules, you must load them (using the
	  "modprobe" command) before you can use them. If you say Y
	  here, some parts of the kernel will be able to load modules
	  automatically: when a part of the kernel needs a module, it
	  runs modprobe with the appropriate arguments, thereby
	  loading the module if it is available.  If unsure, say Y.

config STOP_MACHINE
	bool
	default y
	depends on (SMP && MODULE_UNLOAD) || HOTPLUG_CPU
	help
	  Need stop_machine() primitive.
endmenu
