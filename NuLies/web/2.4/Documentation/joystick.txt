		       Linux Joystick driver v2.0.0
	       (c) 1996-2000 Vojtech Pavlik <vojtech@suse.cz>
			     Sponsored by SuSE
-----------------------------------------------------------------------------
Traducción para Nulies (Núcleo de Linux en español) por Rubén Gómez Antolí.
<mixtolobo@jazzfree.com> Marzo de 2001
-----------------------------------------------------------------------------

0. Declaración
~~~~~~~~~~~~~~
   Este programa es software libre; se puede redistribuir y/o modificarlo bajo
los términos de la licencia pública y general GNU tal como se publicó por la
Free Software Foundation; o bien la versión 2 de la licencia, o (a su elección)
cualquier versión posterior.

   Este programa está distribuido con la esperanza de que pueda ser útil, pero
SIN NINGUNA GARANTÍA; sin implicar, tampoco, la garantía de MERCHANTABILITY o
PROPIEDAD PARA UN USO PARTICULAR. Ver la licencia pública general GNU para más
detalles.

   Se debe haber recibido una copia de la licencia pública general GNU con este
programa; si no, escriba a la Free Software Foundation, Inc. 59 Temple Place,
Suite 330, Boston, MA 02111-1307 USA.

   Si necesita contactar conmigo, el autor, puede hacerlo por correo electróni-
co a la dirección <vojtech@suse.cz>, o por correo normal:

	Vojtech Pavlik, Ucitelska 1576, Praga 8, 182 00 República Checa.

   Para su conveniencia, la licencia pública general GNU version 2 está inclui-
da en el paquete: Vea el fichero COPYING.

1. Introducción
~~~~~~~~~~~~~~~

   El controlador de joystick para Linux proporciona soporte para varios joys-
ticks y dispositivos similares. Está basado en un gran proyecto cuya finalidad es
dar soporte a todos los dispositivos de entrada en Linux.

   Puede encontrar errores mientras usa este controlador, o que éste no
pueda hacer un uso completo de su joystick; estoy interesado en oir cosas de
este tipo. Informes sobre errores e historias de sucesos son siempre bien recibidos.

   El sitio web del proyecto de entrada está en:

		http://www.suse.cz/development/input/
		http://atrey.karlin.mff.cuni.cz/~vojtech/input/


	Hay también una lista de correo para el controlador en:
		
		listproc@atrey.karlin.mff.cuni.cz

envíe "subscribe linux-joystick Su nombre" para suscribirse.

2. Uso
~~~~~~
   Para un uso básico, sólo tiene que elegir las opciones correctas en la
configuración del núcleo y activarlas.

2.1 Utilidades de entrada
~~~~~~~~~~~~~~~~~~~~~~~~~
   Para pruebas u otros propositos (por ejemplo dispositivos serie), está
disponible un juego de utilidades en el sitio web mencionado anteriormente.
Le sugiero que lo descargue y lo instale antes de nada.

2.2 Ficheros de dispositivos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Para aplicaciones que necesiten el uso de un joystick, si no usa devfs, ten-
dra que crear manualmente los nodos en /dev:

cd /dev
rm js*
mkdir input
mknod input/js0 c 13 0
mknod input/js1 c 13 1
mknod input/js2 c 13 2
mknod input/js3 c 13 3
ln -s input/js0 js0
ln -s input/js1 js1
ln -s input/js2 js2
ln -s input/js3 js3

   Para probarlos con utilidades de entrada, es conveniente crear esto:

mknod input/event0 c 13 64
mknod input/event1 c 13 65
mknod input/event2 c 13 66
mknod input/event3 c 13 67

2.4 Modulos necesarios
~~~~~~~~~~~~~~~~~~~~~~
   Para que todos los controladores de joystick hagan su función, necesitará
el módulo de la interfaz de la capa de usuario, a veces cargado o compilado en:

	modprobe joydev

   Para los puertos de joysticks, necesitará también cargar el controlador del
puerto:

	modprobe ns558

   Y para los joysticks de puerto serie, necesitará el módulo de disciplina de
línea de entrada serie y la utilidad inputattach activa:

	modprobe serport
	inputattach -xxx /dev/tts/X &

   Como suma a esto, necesitará el módulo del controlador de joystick en sí
mismo, lo mas probable es que tenga un joystick análogico:

	modprobe analog

   Para cargar el módulo automáticamente, algo como esto podría servir:

	alias tty-ldisc-2 serport
	alias char-major-13 joydev ns558 analog

2.5 Verificando que funciona
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Para comprobar la funcionalidad del controlador de joystick, tenemos el
programa jstest en el paquete de utilidades. Puede ejecutarlo tecleando:

	jstest /dev/js0

   Y debe mostrar una línea con los valores de joystick, los cuales se actua-
lizan al mover la palanca, y presionar sus botones. Los ejes deben estar todos
en cero cuando el joystick está en el centro. No deberían descontrolarse hacia
valores cercanos, y deberían mantenerse estables para cualquier otra posición
de la palanca. Debe tener el rango completo desde -32767 hasta 32767. Si
reunimos todo esto, entonces todo está perfecto, y usted puede comenzar con los
juegos. :)

	Si esto no es así, entonces podría haber un problema. Pruebe a calibrar
el joystick, y si todavía no funciona, lea la sección de controladores de este
fichero, la seccion de localización de averias, y las PUF (FAQ).

2.6. Calibración
~~~~~~~~~~~~~~~~
   Para muchos joysticks usted no necesitará una calibración manual, ya que el
joystick debería ser autocalibrado por el controlador automágicamente. Sin
embargo, con algunos joystick analógicos, que no usan resistencias lineales, o
si quiere tener mejor precisión, puede usar el programa jscal:

	jscal -c /dev/js0

   incluido en el paquete de joystick para mejorar los coeficientes de correc-
ción que el controlador haya podido elegir.

   Despues de la calibración puede verificar si quiere la nueva calibración
usando el comando jstest, y si lo hace, puede guardar los coeficientes de
correción en un fichero:

	jscal -p /dev/js0 > /etc/joystick.cal

   Y añadir una linea a su guión rc ejecutando el fichero

	source /etc/joystick.cal

   De esta forma, despues del siguiente reinicio su joystick continuará cali-
brado. Tambien puede añadir la linea jscal -p a su guión de apagado.

3. Información del controlador de HW específico
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   En esta sección se describe cada uno de los controladores especifícos de
hardware.

3.1 Joystick analógicos
~~~~~~~~~~~~~~~~~~~~~~~
   El analog.c usa la entrada analógica estándar del puerto de juegos, y
por lo tanto soporta todos los joystick y gamepads estándar. Usa una rutina muy
avanzada para esto, permitiendo una precisión de datos que no se puede en-
contrar en ningun otro sistema.

	También soporta extensiones adicionales como setas (hats) adicionales y
botones compatibles con CH Flightstick Pro, ThrustMaster FCS o gamepads de 6
y 8 botones. Los joystick "digitales" Saitek Cyborg están también soportados 
por este controlador, ya que son basicamente palancas CHF "recocinadas".

   Sin embargo, los únicos tipos que se pueden autodetectar son:

* Joystick de 2 ejes, 4 botones.
* Joystick de 3 ejes, 4 botones.
* Joystick de 4 ejes, 4 botones.
* Joystick "digital" Saitek Cyborg.


   Para el soporte de otros tipos de joystick (con más/menos ejes, setas y
botones) necesitará especificar el tipo ya sea en la línea de comando del núcleo o
en la linea de comandos del modulo, si inserta analog.o como módulo .
Los parámetros son:

	js=tipo,tipo,tipo,....

	"tipo" es el tipo de joystick de la siguiente tabla, definiendo los 
joysticks presentes en el puerto de juegos del sistema, empezando con el puerto
de juegos 0, la segunda entrada "tipo" definiría el puerto de juegos 1 y así
sucesivamente.

	Tipo     | Significado
	-----------------------------------
	none     | No hay joystick analógico en ese puerto
	auto     | Autodetección del joystick
	2btn     | Joystick de 2-botones n-ejes
	y-joy    | Dos joysticks de 2-botones 2-ejes en un cable en Y
	y-pad    | Dos gamepads de 2-botones 2-ejes en un cable en Y
	fcs      | Joystick compatible Thrustmaster FCS
	chf      | Joystick con una seta, compatible CH Flightstick
	fullchf  | CH Flightstick compatible con dos setas y 6 botones
	gamepad  | Gamepad 4/6-botones n-ejes
	gamepad8 | Gamepad 8-botones 2-ejes

	En el caso de que su joystick no figure en la tabla anterior, puede
especificarlo como un número combinando los bits de la tabla de abajo. Esto no
es recomendable a no ser que sepa realmente que esta haciendo. No es peligroso,
pero no es simple.

	Bit | Significado
	--------------------------
	 0  | Eje X1
	 1  | Eje Y1
	 2  | Eje X2
	 3  | Eje Y2
	 4  | Botón A
	 5  | Botón B
	 6  | Botón C
	 7  | Botón D
	 8  | Botones X e Y CHF
	 9  | Seta 1 CHF
	10  | Seta 2 CHF
	11  | Seta FCS
	12  | Botón X Pad
	13  | Botón Y Pad
	14  | Botón U Pad
	15  | Pad Boton V
	16  | Saitek Botones F1-F4
	17  | Saitek Modo Digital
	19  | GamePad
	20  | Joy2 Eje X1
	21  | Joy2 Eje Y1
	22  | Joy2 Eje X2
	23  | Joy2 Eje Y2
	24  | Joy2 Botón A
	25  | Joy2 Botón B
	26  | Joy2 Botón C
	27  | Joy2 Botón D
	31  | Joy2 GamePad

3.2 Joysticks Microsoft SideWinder
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo Microsoft "Digital Overdrive" está soportado por el módulo 
sidewinder.c. Todos los joysticks actualmente soportados son:

* Microsoft SideWinder 3D Pro
* Microsoft SideWinder Force Feedback Pro
* Microsoft SideWinder Force Feedback Wheel
* Microsoft SideWinder FreeStyle Pro
* Microsoft SideWinder GamePad (hasta 4, unidos)
* Microsoft SideWinder Precision Pro
* Microsoft SideWinder Precision Pro USB

   y se autodetectan, así que no se necesitan los parámetros del modulo.

   Hay un problema con el 3D Pro. Informan de 9 botones, aunque el joystick
solo tenga 8. El noveno botón es un interruptor de modo en la parte trasera del
joystick. Sin embargo, si lo mueve, reseteará el joystick, y hará que no res-
ponda durante un tercio de segundo. Además, el joystick también se recentrará,
adoptando la posición en que estuviera durante ese tiempo como centro. Úselo,
si quiere, pero piénselo primero.

   El SideWinder estándar no es un joystick digital, así que está soportado por
el controlador analógico descrito anteriormente.

3.3 Dispositivos Logitech ADI
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo ADI de Logitech está soportado por el módulo adi.c. Debe sopor-
tar cualquier dispositivo Logitech usando este protocolo. Esto incluye, aunque 
no esta limitado, a:
	
* Logitech CyberMan 2
* Logitech ThunderPad Digital
* Logitech WingMan Extreme Digital
* Logitech WingMan Formula
* Logitech WingMan Interceptor
* Logitech WingMan GamePad
* Logitech WingMan GamePad USB
* Logitech WingMan GamePad Extreme
* Logitech WingMan Extreme Digital 3D

   Los dispositivos ADI se autodetectan, y el controlador soporta hasta dos (en
cualquier combinación) dispositivos en un solo puerto de juegos, usando un
cable en Y o encadenándolos juntos.

   El joystick Logitech WingMan, Logitech WingMan Attack, Logitech WingMan
Extreme y Logitech WingMan ThunderPad no son joystick digitales y se pueden
controlar por el controlador analógico descrito anteriormente. El Logitech
WingMan Warrior y Logitech Magellan están soportados por los controladores
serie descritos después. El Logitech WingMan Force y el Logitech WingMan Formu-
la Force están soportados por el controlador I-Force descrito después. El Logi-
tech CyberMan no está soportado todavía.

3.4 Gravis GrIP
~~~~~~~~~~~~~~~
   El protocolo Gravis GrIP está soportado por el módulo grip.c. Actualmente 
soporta:

* Gravis GamePad Pro
* Gravis BlackHawk Digital
* Gravis Xterminator
* Gravis Xterminator DualControl

   Todos estos dispositivos son autodetectables, y puede usar cualquier combi-
nación de hasta dos de esos pads enchufándolos juntos o usando un cable Y en un
sólo puerto de juegos.

   El GrIP MultiPort no está soportado todavía. El Gravis Stinger es un dispo- 
sitivo serie y esperanzadoramente será soportado pronto. Otros joystick Gravis 
están soportados por el controlador analog.

3.5 FPGaming A3D y MadCatz A3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo Assassin 3D creado por FPGaming, se usa en ambos, para sí mismo
por el FPGaming y con licencia por el MadCatz. Los dispositivos A3D están
soportados por el módulo a3d.c. Actualmente soporta:

* FPGaming Assassin 3D
* MadCatz Panther
* MadCatz Panther XL

   Todos estos dispositivos son autodetectables. Debido a que el Assassin 3D
y el Panther permiten conectar joysticks analógicos a ellos, necesitará cargar 
el controlador analog para poder manejar los joysticks enchufados.

   El trackball debería trabajar con el módulo USB mousedev como un ratón nor-
mal. Vea la documentación de USB sobre cómo configurar un ratón USB.

3.6 ThrustMaster DirectConnect (BSP)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo TM DirectConnect (BSP) está soportado por el módulo tmdc.c. 
Éste incluye, aunque no está limitado:

* ThrustMaster Millenium 3D Inceptor
* ThrustMaster 3D Rage Pad
* ThrustMaster Fusion Digital Game Pad

   El controlador no soporta directamente, aunque funciona prometedoramente:

* ThrustMaster FragMaster
* ThrustMaster Attack Throttle

   Si tiene uno de estos, contacte conmigo.

   Los dispositivos BSP son autodetectables, así que no es necesario darle
parámetros al módulo . Hasta dos dispositivos TMDC se pueden conectar al mismo
puerto de juegos, usando un cable Y.

3.7 Creative Labs Blaster
~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo Blaster está soportado por el módulo cobra.c. Éste soporta só- 
lamente:

* Creative Blaster GamePad Cobra

   Se pueden usar dos joysticks en un sólo puerto de juegos, usando un cable Y.

3.8 Joysticks digitales Genius
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Los joysticks de comunicación digital Genius están soportados por el módulo 
gf2k.c. Éste incluye:

* Genius Flight2000 F-23 joystick
* Genius Flight2000 F-31 joystick
* Genius G-09D gamepad

   Otros joystick digitales Genius no están soportados todavía, pero el sopor-
te se puede añadir fácil y rápidamente.

3.9 Joysticks digitales InterAct
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Los joysticks de comunicación digital InterAct están soportados por el mo-
dulo interact.c. Éste incluye:

* InterAct HammerHead/FX gamepad
* InterAct ProPad8 gamepad

   Otros joysticks digitales InterAct no están soportados todavia, pero el so-
porte se puede añadir fácil y rápidamente.

3.10 Tarjetas de juegos PDPI Lightning 4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Las tarjetas de juegos PDPI Lightning 4 están soportadas por el módulo 
lightning.c. Una vez que el módulo está cargado, puede usar el controlador
analógico para manejar los joysticks. Los joysticks de comunicación digital
podrían trabajar sólo en el puerto 0, mientras que si usa cable en Y, puede co-
nectar hasta 8 joysticks analógicos en una sóla tarjeta L4, 16 en el caso de
que disponga de dos en su sistema.

3.11 Trident 4DWave / Aureal Vortex
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Las tarjetas de sonido con un chipset Trident 4DWave DX/NX o Aureal Vortex/
Vortex2 proporcionan un modo de "Puerto de juegos avanzado" donde la tarjeta de
sonido maneja el polling del joystick. Este modo está soportado por el módulo 
pcigame.c. Una vez cargado el controlador analógico puede usar las caracterís-
ticas avanzadas de dichos puertos de juego.

3.12 Amiga.
~~~~~~~~~~~
  Los joysticks Amiga, conectados a un Amiga, están soportados por el contro-
lador amijoy.c. Dado que no son autodetectables, el controlador tiene una
linea de comando.

	amijoy=a,b

   a y b definen los joysticks conectados a los puertos JOY0DAT y JOY1DAT
del Amiga.

	Valor | Tipo de Joystick
	------------------------
	  0   | Ninguno
	  1   | Joystick digital de 1 botón

   Por ahora no se soportan más tipos de joystick, pero esto podría cambiar en
el futuro si tuviera un Amiga al alcance de mis dedos.

3.13 Consolas de juegos, pads de 8-bit y joysticks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Vea joystick-parport.txt para más información.

3.14 Dispositivos SpaceTec/LabTec.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Los dispositivos serie SpaceTec se comunican usando el protocolo SpaceWare.
Éste se soporta mediante los controladores spaceorb.c y spaceball.c. Los
dispositivos actualmente soportados por spaceorb.c son:

* SpaceTec SpaceBall Avenger
* SpaceTec SpaceOrb 360

   Los dispositivos actualmente soportados por spaceball.c son:

* SpaceTec SpaceBall 4000 FLX

   En suma, para tener los modulos spaceorb/spaceball y serport en el núcleo,
necesita añadir un puerto serie a él. Para hacerlo, ejecute el programa
jsattach:
	
	inputattach --spaceorb /dev/tts/x &

o

	jsattach --spaceball /dev/tts/x &

donde /dev/tts/x es el puerto serie al que el dispositivo está conectado.
Después de hacer esto, el dispositivo será presentado y empezará a trabajar.

   Hay un problema con el SpaceOrb. El botón #6, en el lado del fondo de la
esfera, aunque parece un botón ordinario, provoca un recentrado interno del
spaceorb, moviendo el punto cero a la posición en la que estuviera la bola
en el momento de presionar el botón. Así que piénselo antes de enlazarlo a
cualquier otra función.

   Todavía no están soportados SpaceTec SpaceBall 2003 FLX y 3003 FLX.

3.15 Dispositivos Logitech SWIFT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El protocolo serie SWIFT está soportado por el módulo warrior.c. Actual-
mente soporta sólamente:

* Logitech WingMan Warrior

pero en el futuro, podrá soportar también el Logitech CyberMan (el original,
no el CM2). Para usar el módulo, necesitara ejecutar jsattach después de
insertar/compilar el módulo en el núcleo:

	inputattach --warrior /dev/tts/x &

/dev/tts/x es el puerto serie donde su Warrior esté conectado.

3.16 Magellan / Space Mouse
~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El Magellan (o Space Mouse), manufacturado por LogiCad3d (formalmente
Space Systems) para muchas otras compañías (Logitech, HP, ...), está soportado
por el módulo joy-magellan. Actualmente soporta sólamente los siguientes
modelos:

* Magellan 3D
* Space Mouse

   Los botones adicionales en las versiones "Plus" no están soportados todavía.

   Para usarlos deberá conectar el puerto serie al controlador mediante el
comando

	inputattach --magellan /dev/tts/x &

   Después de esto, el magellan se detectará, inicializará, pitará y el dispo-
sitivo /dev/input/jsX se podrá emplear.

3.17 Dispositivos I-Force
~~~~~~~~~~~~~~~~~~~~~~~~~
   Todos los dispositivos I-Force están soportados por el módulo
iforce.c. Esto incluye, aunque no se encuentre limitado:

* Logitech WingMan Force
* Logitech WingMan Force Wheel
* Guillemot Race Leader wheel

   Para usarlos, necesitará conectar el puerto serie al controlador usando el
comando

	inputattach --iforce /dev/tts/x &

   Despues el dispositivo I-Force se detectará, y el dispositivo /dev/input/jsX
podrá ser usado.

   En el caso de que esté usando el dispositivo mediante el puerto USB, el
comando inputattach no será necesario.
   
4. Localización de Problemas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Hay una probabilidad alta de que tenga algunos problemas. Para comprobar
que el controlador funciona, si tiene duda, use la utilidad jstest en
alguno de sus modos. Los modos más usados son "normal" - para la interfaz 1.x,
y "old" para la interfaz "0.x". Puede ejecutarlo tecleando:

	jstest --normal /dev/input/js0
	jstest --old    /dev/input/js0

   Adicionalmente, puede hacer una prueba con la utilidad evtests:

	evtest /dev/input/event0

   ¡ Ah, y lea las PUF (FAQ) ! :)

5· Preguntas de Uso Frecuente (PUF)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Pregunta: Al ejecutar "jstest /dev/js0" da el error "File not found". ¿Cuál es 
	  la causa?

Respuesta: El fichero de dispositivo no existe. Créelo (vea la sección 2.2).

P: ¿Es posible conectar mi viejo joystick o pad de Atari/Commodore/Amiga
   /consola que usa un conector de 9 pines de tipo D al puerto serie de mi Pc?

R: Sí, es posible, pero quemaría el puerto serie o el pad. Y por supuesto, no
   funcionaría.

P: Mi joystick no funciona con Quake / Quake 2. ¿Cuál es la causa?

R: Quake / Quake 2 no tiene soporte de joystick. Use joy2key para simular la
   presión de las teclas para ellos.

6. Interfaz de programación
~~~~~~~~~~~~~~~~~~~~~~~~~~~
   El controlador 1.0 usa una nueva rutina basada en la aproximación al con-
trolador del joystick. El programa de usuario no hace polling para obtener los
valores del joystick, es el controlador del joystick el que informa cuando
hay algún cambio en dichos valores. Para más información puede ver
joystick-api.txt, joystick.h y jstest.c incluidos en el paquete de joystick. El
dispositivo de joystick puede ser usado en cualquier modo de blocking o
nonblocking y soporta llamadas select().

  Para mantener la compatibilidad, la interfaz antigua (v 0.x) está todavía
incluída. Cualquier llamada al controlador de joystick que use la interfaz
antigua devolverá valores que son compatibles con la misma. Esta interfaz está
todavía a 2 ejes, y las aplicaciones que la usan normalmente decodifican
solamente 2 botones, aunque el controlador proporciona hasta 32.

7. Créditos
~~~~~~~~~~~
   Gracias a las siguientes personas que contribuyeron al desarrollo
del controlador de joystick con código, ideas o especificaciones:

	Arthur C. Smith		<asmith@cbnewsd.att.com>
	Eyal Lebedinsky		<eyal@eyal.emu.id.au>
	Jeff Tranter		<tranter@software.mitel.com>
	Carlos Puchol		<cpg@cs.utexas.edu>
	Matt Rhoten		<mrhoten@oz.net>
	Dan Fandrich		<dan@fch.wimsey.bc.ca>
	Sverker Wilberg		<sverkerw@manila.docs.uu.se>
	Hal Maney		<maney@norden.com>
	Bernd Schmidt		<crux@pool.informatik.rwth-aachen.de>
	Alan Cox		<alan@lxorguk.ukuu.org.uk>
	John Markus Bjorndalen	<johnm@cs.uit.no>
	Boris Muehmer		<mhs@cybernet-ag.de>
	Robert W. Grubbs	<rwgrubbs@vt.edu>
	Pete Chown		<pete.chown@skygate.co.uk>
	Benji York		<benji@cookeville.com>
	Leslie F. Donaldson	<donaldlf@cs.rose-hulman.edu>
	Eng-Jon Ong		<ongej@dcs.qmw.ac.uk>
	Ragnar Hojland Espinosa	<ragnar@macula.net>
	Brian Gerst		<bgerst@quark.vpplus.com>
	Andree Borrmann		<a.borrmann@tu-bs.de>
	Martin Giguere		<zefrench@hotmail.com>
	David Thompson		<dcthomp@mail.utexas.edu>
	Justin Wake		<spectre@telefragged.com>
	Benoit Triquet		<benoit@adsl-216-100-248-201.dsl.pacbell.net>
	John Dahlstrom		<jodaman@bradley.edu>
	Dan Gohman		<gohmandj@mrs.umn.edu>
	Joe Krahn		<krahn@niehs.nih.gov>
	David Kuder		<alphagod@penguinpowered.com>
	Raymond Ingles		<sorceror@tir.com>

   Si piensa que debe estar en esta lista y no es así, es posible que haya
olvidado incluirle -contacte conmigo y corregiré el error. :)
