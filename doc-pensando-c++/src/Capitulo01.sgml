<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML  
  Traducción original: 
  Formateado DocBook:  
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C1">
  
  <title>Introduction a los Objetos (INCOMPLETO)</title>

  <blockquote>
    <para>
      La génesis de los lenguajes de la revolución informática ocurrió
      dentro de una máquina. Por tanto, la génesis de nuestros lenguajes
      de programación tiende a parecerse a esa máquina.
    </para>
  </blockquote>

  <para>
    Pero los ordenadores no son tanto máquinas como herramientas de
    amplificación de la mente (<quote>bicicletas para la mente</quote>,
    como es aficionado a decir Steve Jobs) y una manera diferente de
    medio de expresión.  Como resultado, las herramientas empiezan a
    parecerse menos a las máquinas y más a partes de nuestra mente, y
    también a otras medios de expresión como la escritura, la pintura,
    la escultura, la animación y la cinematografía. La programación
    orientada a objetos es parte de este movimiento hacia un uso del
    ordenador como medio de expresión.</para>

  <para>
    Este capítulo le servirá de introducción a los conceptos básicos de
    la programación orientada a objetos (POO), incluyendo un resumen de
    los métodos de desarrollo de la POO. Este capítulo, y este libro,
    suponen que usted tiene ya experiencia con un lenguaje de
    programación procedural, aunque no sea necesariamente C. Si cree que
    necesita más preparación en programación y en la sintaxis de C antes
    de abordar este libro, debería mirarse el CD-ROM de entrenamiento
    <citetitle>Thinking in C: Foundations for C++ and Java</citetitle>,
    que viene junto con este libro, y también está disponible en <ulink
    url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
  </para>

  <para>
    Este capítulo es material básico y suplementario. Mucha gente no se
    siente cómoda adentrándose en la programación orientada a objetos
    sin tener antes una visión global. Por tanto, aquí se introducen
    muchos conceptos para darle una visión sólida de la POO. Sin
    embargo, mucha otra gente no capta los conceptos globales hasta que
    no han visto parte de la mecánica primero; esta gente puede
    atrancarse y perderse sin algún trozo de código al que ponerle las
    manos encima. Si usted es parte de este último grupo, y está ansioso
    por llegar a las especificaciones del lenguaje, siéntase libre de
    saltarse este capítulo; esto no le impedirá escribir programas o
    aprender el lenguaje. Sin embargo, eventualmente querrá volver atrás
    hasta aquí para rellenar su conocimiento y poder comprender por qué
    son importantes los objetos y cómo diseñar con ellos.
  </para>

  <sect1>
    <title>El progreso de abstracción</title>

    <para>
      Todos los lenguajes de programación proporcionan abstracciones. Se
      puede afirmar que la complejidad de los problemas que se pueden
      resolver está relacionada directamente con el tipo y calidad de la
      abstracción. Por <quote>tipo</quote> me refiero a <quote>¿Qué es
      lo que está abstrayendo?</quote>. El lenguaje ensamblador es una
      pequeña abstracción de la máquina subyaciente. Muchos lenguajes
      llamados <quote>imperativos</quote> que siguieron (como Fortran,
      BASIC y C) eran abstracciones del lenguaje ensamblador. Estos
      lenguajes son grandes mejoras con respecto al lenguaje
      ensamblador, pero su abstracción primaria todavía requiere que
      usted piense en términos de la estructura de la computadora, en
      lugar de la estructura del problema que intenta resolver. El
      programador debe establecer la asociación entre el modelo de la
      máquina (en el <quote>espacio de soluciones</quote>, que es el
      lugar donde está modelando ese problema, como un ordenador) y el
      modelo del problema que se está resolviendo (en el <quote>espacio
      de problemas</quote>, que es el lugar donde existe el
      problema). El esfuerzo requerido para realizar esta
      correspondencia, y el hecho de que sea extrínseco al lenguaje de
      programación, produce programas que son difíciles de escribir y
      caros de mantener, y, como efecto secundario, creó toda la
      industria de <quote>métodos de programación</quote>.
    </para>

    <para>
      La alternativa a modelar la máquina es modelar el problema que
      está intentando resolver. Los primeros lenguajes como el LISP y el
      APL eligieron concepciones del mundo particulares (<quote>Todos
      los problemas son listas en última instancia</quote>, o
      <quote>Todos los problemas son algorítmicos</quote>). El PROLOG
      reduce todos los problemas a cadenas de decisiones. Se han creado
      lenguajes para programación basada en restricciones y para
      programar manipulando exclusivamente símbolos gráficos (el último
      demostró ser demasiado restrictivo). Cada uno de estos métodos es
      una buena solución para el tipo particular de problema para el que
      fueron diseñados, pero cuando uno se sale de ese dominio, se hacen
      difíciles de usar.
    </para>

    <para>
      El método orientado a objetos va un paso más allá, proporcionando
      herramientas para que el programador represente los elementos en
      el espacio de problemas. Esta representación es lo suficientemente
      general para que el programador no esté limitado a ningún tipo
      particular de problema. Nos referimos a los elementos en el
      espacio de problemas, y a sus representaciones en el espacio de
      soluciones, como <quote>objetos</quote>.
    </para>

  </sect1>

  <sect1>
    <title>Un objeto tiene una interfaz</title>
    <para></para>
  </sect1>

  <sect1>
    <title>La implementación oculta</title>
    <para></para>
  </sect1>

  <sect1>
    <title>Reutilizando la implementación</title>
    <para></para>
  </sect1>

  <sect1>
    <title>Herencia: reutilización de interfaces</title>
    <para></para>
  </sect1>
  
  <sect1>
    <title>Objetos intercambiables gracias al polimorfismo</title>
    <para></para>    
  </sect1>
  
  <sect1>
    <title>Creación y destrucción de objetos</title>
    <para></para>    
  </sect1> 

  <sect1>
    <title>Gestión de excepciones: tratamiento de errores</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Análisis y diseño</title>
    <para></para>   
  </sect1>
    
  <sect1>
    <title>Métodos ágiles</title>
    <para></para>    
  </sect1>

  <sect1>
    <title>Por qué triunfa C++</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Estrategias para la transición</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Resumen</title>
    <para></para>  
  </sect1>

</chapter>

<!-- Local Variables: -->
<!-- sgml-parent-document:"PensarEnC++.sgml" -->
<!-- End: -->
  