<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE article PUBLIC "-//laespiral.org//DTD LE-document 1.0//EN"
   "LE-document.dtd">
<!-- $Id: guiadebian.xml,v 1.5 2003/10/31 22:06:42 pakojavi2000 Exp $ -->
 
<article>
  <artheader>
    <title>
      Guía Práctica de Debian GNU/Linux 3.0 (Woody)
    </title>
    <author> 
       <firstname> Francisco J.</firstname>
       <surname>  F. Serrador  </surname>
       <affiliation>
         <address><email>franciscojavier.fernandez.serrador@hispalinux.es</email><address>
       </affiliation>
    </author>
    <author>
      <firstname>A. Gustavo</firstname>
      <surname>González</surname>
      <affiliation>
	<address><email>agonzale@cica.es</email></address>
      </affiliation>
    </author>
    <revhistory>
      <revision>
	<revnumber>0.1</revnumber>
	<date>11/10/2003</date>
	<authorinitials>FRJMS</authorinitials>
      </revision>
    </revhistory>
    <date>Madrid, 11 de octubre de 2003</date>
    <abstract>
      <para>
	Este documento se basa en una guía anterior de A. Gustavo sobre 
	Debian 2.2 (potato). En esta guía, se encontrará información 
	actualizada concerniente a la versión 3.0r1 (Woody), relativa a la
        instalación y post-instalación de la distribución.
      </para>
    </abstract>
    <legalnotice>
      <para>Este documento es libre. Puede copiarlo,
	distribuirlo y/o modificarlo bajo los términos de la Licencia
	GNU Para Documentación Libre, versión 1.1 o cualquier versión
	posterior publicada por la Free Software Foundation.
      </para>
    </legalnotice>
  </artheader>

  <sect1 id="intro">
    <title>
      Introducción
    </title>
    <para>
      Esto pretende ser, como el título indica, una guía práctica de la
      instalación y post-instalación del sistema operativo  Debian GNU sobre núcleo
      Linux, versión 3.0 r1 (Woody), o Debian GNU/Linux 3.0r1 para
      nuevos usuarios de Debian (aunque ya conozcan otras distribuciones
      GNU/Linux). Este documento puede ser copiado, modificado y distribuido sin
      ninguna restricción.
    </para>
    <para>
       La distribución binaria de Debian GNU/Linux 3.0r1 ocupa 7 CD's, etiquetados 
       del 1 al 7, y se pueden obtener desde diversos servidores FTP. Desde España, 
       existen varios servidores de réplicas localizados principalmente en RedIris, la Universidad
       Autónoma de Madrid, la Universidad Carlos III y la Universidad de Vigo.
    </para>
    <para>
     Como tradicionalmente Debian es una distribución que evoluciona
     más lentamente que otras, daré información acerca de cómo
     instalar Debian en hardware que aun no está soportado por la
     distribución oficial. Para ello, es necesario crear un sistema
     mínimo desde el cual poder ejecutar ciertas operaciones. Esta
     información se encontrará publicada en cuanto tenga algo de
     tiempo en el Proyecto de Documentación Libre (TLDP) y en el
     servidor de la EUI-UPM.
    <para>
      Espero que lo que sigue sirva de ayuda a los nuevos usuarios de Debian GNU/Linux.
    </para>
  </sect1>
 <sect1>
    <title>
      Preparativos
    </title>
    <para>
        Lo que aquí se indica es de sobra conocido por los usuarios de GNU/Linux, pero de
	todos modos lo pongo: Debéis tomar nota de las características de vuestro hardware: 
	Ratón (tipo, puerto, 2 o 3 botones...), módem (tipo, puerto, velocidad ¡cuidado con 
	los WINMODEMS!), monitor (tasa de frecuencia horizontal y refresco vertical, si es 
	multifrecuencia), tarjeta gráfica (tipo, chipset, memoria), tarjeta de red (clase, 
	denominación, dirección E/S...), etc.
    </para>
    <para>
      Al menos es necesario hacer dos particiones del disco duro,  (mediante FIPS + fdisk o parted): 
      una de intercambio (swap) (64 Mb de swap será más que suficiente) y otra de al menos 1 Gb. 
      Debian Woody 3.0 de forma predeterminada instala un núcleo de la serie 2.2, aunque viene preparado
      con otro núcleo alternativo de la serie 2.4, que será el que usaremos.
    </para>
    <para>
        Otra cosa: si disponéis de conexión no intermitente (por red, no ppp), debéis anotar la 
	dirección IP de vuestra máquina, máscara de subred (subnet mask), dirección de difusión 
	(broadcast), puerta de enlace (default gateway), host name, domain name y las IP de los 
	DNS que os ha proporcionado el administrador de vuestro ISP. Tened formateados 2 disquetes 
        de 1.4Mb si vuestra BIOS no permite CDs autoarrancables. 
    </para>
    <sect2> <title> Particionado del disco </title>
    <para>
      En el caso de que tengamos otro SO instalado en el disco duro,
      es necesario abrir un hueco para poder alojar a Debian
      GNU/Linux.
    </para>
    <para>
       Si usa Windows, es muy probable que su disco duro tenga una
       sola partición enorme con formato FAT16, FAT32 o NTFS. Para
       redimensionar estas particiones, puede recurrir a FIPS para
       las particiones FAT. Si tiene una partición NTFS, tendrá que
       usar otra herramienta. Sé que el sistema de instalación de la 
       distribución Mandrake puede redimensionar las particiones NTFS,
       sin perder datos, así que puede intentar bajándose el primer CD
       de esa distribución.
    </para>
    <para> 
    Para usar FIPS deberás desfragmentar antes el disco duro
    con el desfragmentador de windows. Una vez hecho esto, es
    necesario iniciar el equipo en modo DOS con un disco de inicio de
    windows y ejecutar FIPS para dividir la partición. 
    Deberás organizar las particiones de manera que sea posible tener 
    al menos una partición de unos 20 Mib. totalmente dentro de los
    primeros 8 Gib. del disco duro.
    </para>
    <para>
    Existe un software de pago llamado PartitionMagic que permite
    reorganizar las particiones de manera simple a través de un
    interfaz gráfico. 
    </para>
    <para>
     Una vez terminado el proceso, las particiones deberán quedar más
     o menos de esta manera:
    </para>
    <programlisting>
     +--Windows----+---Resto del disco duro----------------------+
     +-----8Gb-------------+-------------------------------------+
     +-------------+ boot  +-------------------------------------+
    <programlisting>
    <para>
     Cuando configuremos las particiones, borraremos la partición
     marcada como "Resto del disco duro" en el gráfico y crearemos
     varias particiones. Nótese que boot debe estar comprendida entre
     los primeros 8Gb del disco duro, esto es MUY importante.
    </para>
   </sect2> 
  </sect1>

  <sect1 id="installation"> <title> La instalación </title>
    <para>
      Como ya he dicho disponemos de los 7 CDs binarios para i386. EL CD1 contiene imágenes múltiples  
      para comenzar la instalación que pueden seleccionarse al principio de la instalación.
      Los CDs 2 a 5 contienen cada uno una de las imágenes del CD1, y podrán usarse en caso de que
      tu BIOS no pueda arrancar con el CD multiimagen. La imagen que usaremos será la etiquetada
      como bf24.
      En caso de que nuestro equipo no pueda arrancar desde el CDROM, tendremos que crear 
      dos disquetes (floppies) de instalación haciendo una copia binaria de dos ficheros que 
      encontraremos en el directorio install del CD1: rescue.bin y root.bin. Rescue.bin es el 
      disco de inicio de la instalación que también sirve como disco de rescate para recuperar 
      una instalación dañada. Root.bin contiene el sistema GNU/Linux mínimo
      para llevar a cabo la instalación. Podemos crear estos discos desde Windows o desde otro Unix. 
      Desde Windows, explorando el CD, en la carpeta install encontraremos junto con los dos 
      archivos binarios, la utilidad rawrite2, un ejecutable para copiar estas imágenes. Si por 
      ejemplo la unidad del lector de CD en Windows es e:, al pulsar
      dos veces sobre rawrite2(.exe), aparecerá la ventana de MSDOS :
    </para>
    <programlisting>
      Enter source file name: e:\install\rescue.bin
      Enter destination drive: a:
    </programlisting>
    <para>
      Luego te pide que introduzcas un disquete formateado en la
      unidad A: y pulses ENTER. Rotula el disco como RESCUE DISK.
      Repite el mismo proceso para root.bin y rotula el disco como ROOT DISK.
    </para>
    <para>
      Para el caso de unix, los discos pueden crearse usando el
      comando dd. Si el CD1 está montado en /cdrom, el proceso para el
      RESCUE DISK (puesto en la disquetera A: = /dev/fd0) sería:
    </para>
    <programlisting>
      dd if=/cdrom/install/rescue.bin of=/dev/fd0 bs=1k count=1440
    </programlisting>
    <para>
      Repite el proceso para ROOT DISK con if=/cdrom/install/root.bin, y ya tendrás los dos disquetes necesarios.
    </para>
    <para>
     Voy a suponer el caso más normal que es arrancar desde el CD1 con la imagen bf24.
     Si os véis obligados a arrancar desde los disquetes, el proceso de instalación se realizará
     en inglés, y es parecido al proceso de instalación de Debian 2.2 Potato. 
     Poned el CD1 en vuestro lector de cdrom y reiniciar el ordenador. 
    </para>
    <para>
     Durante la fase de POST de la BIOS, durante el proceso de conteo de memoria, aparecerá un mensaje diciendo
     "Press Del to enter setup" o algo parecido. Pulsamos la tecla apropiada y nos aparece el menú principal de 
     la BIOS. Localizamos la opción de inicio del equipo y le indicamos que arranque desde el CDROM.
    </para>
    <para>
      Una vez guardados los cambios, reiniciamos con el CD1 de la distribución en la unidad lectora y ahora
      aparecerá un mensaje de bienvenida. Tecleamos bf24 y pulsamos ENTER. Debería arrancar el proceso de 
      instalación con el núcleo 2.4. 
    </para>

    <sect2 id="infraestructure"> <title>Indicaciones acerca de la infraestructura </title>
    <para>
       La instalación de Debian consta de dos fases. Durante la
       primera fase se configurarán las particiones y se instalarán
       los paquetes mínimos necesarios para arrancar el equipo y
       tener un soporte mínimo para instalar el resto de paquetes
       en la fase de instalación siguiente.
    </para>
    <para>
       Durante la fase 1 de la instalación, el programa le guiará a
       través de los pasos necesarios para crear la infraestructura
       básica necesaria. Puede que si ya ha instalado un sistema
       operativo anterior, desee conservar los directorios de usuario
       bajo /home. En ese caso no inicialice la partición donde se
       encuentre dicho directorio. Si es la primera vez que instala
       Debian, le recomiendo que use una partición dedicada a los
       datos de usuario, normalmente con 500Mib será suficiente
    </para>
    <para>
       Muchos usuarios inician la instalación cuando ya tienen otro
       sistema operativo funcionando. El 90% de las veces, este SO es
       Windows. Windows 95, 98 y Millenium tienen la desagradable
       costumbre de sobreescribir el MBR, así que si instala uno de
       estos SO después de Debian, el menú de inicio desaparecerá y no
       podrá arrancar Debian. La solución pasa por tener a mano los
       disquetes de rescate de Debian para restaurar el MBR
       ejecutando:
    </para>
    <programlisting>
    lilo
    </programlisting>
    <para>
       Otro fallo común entre los usuarios de windows que instalan
       Debian por primera vez consiste en instalar el núcleo en una 
       partición que se encuentra en todo o en parte por encima de los 
       8 primeros Gib.
    </para>
       Para asegurarnos de que el proceso de arranque no falla,
       usaremos una partición pequeña de unos 20 Mib. que se
       encontrará dentro de los primeros 8 Gib de espacio en el disco
       duro. Así evitaremos ese tipo de errores.
    </para>
    </sect2>

    <sect2 id="language"> <title>Seleccionar el idioma</title>
      <para>
	Aparece una ventana con varios idiomas para efectuar la instalación. Entre ellos, 
        escogemos la línea con el idioma español.
      </para>
      <para>
	es: Instalación en Español
      </para>
    </sect2>
    
    <sect2 id="partitioning"> <title>Particionar el disco duro</title>
      <para>
         En caso de que el programa de instalación no encuentre ninguna
         partición apropiada, ésta será la primera opción que aparecerá en
         el menú.
      </para>
      <para>
         Se pueden usar varios programas para particionar el disco. Yo
         prefiero fdisk, pero quizá cfdisk sea más amigable para los que
         empiezan en esto. Usando cfdisk, aparece un menú con las
         particiones existentes. Si es la primera vez que instalas Debian,
         y seguiste los consejos anteriores, aparecerán dos particiones, 
         la primera, /dev/hda1 será la partición de Windows que dividimos
         antes y la segunda, /dev/hda2 será la partición que resultó de la
         división anterior que aplicamos.
         Borraremos /dev/hda2 y crearemos lo siguiente:
     <itemizedlist>
         <item> Una partición de 20 Mib primaria (/dev/hda2)</item>
         <item> Una partición extendida         (/dev/hda3)</item>
         <item> Una partición lógica de al menos 64 Mb para swap y
         como máximo la cantidad de memoria instalada (/dev/hda5)</item>
         <item> Una partición lógica para el sistema operativo (/dev/hda6)</item>
         <item> Una partición lógica para el directorio /home de al menos
                500Mib (/dev/hda7)</item>
     </itemizedlist>
       El tipo de las particiones creadas dependerá del núcleo con que
       hayamos arrancado. En nuestro caso, dado que hemos usado la
       imagen bf24, podremos elegir ext2, ext3 o ReiserFS para las
       particiones de datos y Linux swap para la partición swap.
       Por ahora seleccionaremos como tipo de partición ext2 para todas
       las particiones de datos y Linux swap para la partición de
       intercambio (swap).
     </para>
   </sect2>

    <sect2 id="swap"><title>Inicializar y montar partición de intercambio</title>
      <para>
	A continuación, se nos pedirá que inicialicemos la partición de intercambio 
      </para>
      <para>
	/dev/hda5 : Linux swap
      </para>
      <para>
	(scan for bad blocks?) y hacéis lo que corresponda
      </para>
    </sect2>
    <sect2>
      <title>
	Inicializar una partición de linux 
      </title>
      <para>
	Nosotros usaremos tres particiones de datos. La primera
	partición, la dedicaremos guardar los archivos del sistema de
	arranque, la segunda, la usaremos para el SO y la tercera para
	nuestros datos personales (p.ej., /dev/hda2 /dev/hda6, /dev/hda7):
      </para>
      <para>
	A continuación se muestran las siguientes particiones:
       <itemizedlist>
         <item>/dev/hda2</item>
         <item>/dev/hda6</item>
         <item>/dev/hda7</item>
       </itemizedlist>
       Elegiremos en primer lugar inicializar y montar la partición /dev/hda6
      </para>
      <programlisting>
	¿Montar como sistema de archivos raíz?
        Montaremos la partición del sistema operativo como raíz
	/dev/hda6 se montará como  / (Aceptar)
      </programlisting>
       Después el menú de instalación indica que el siguiente paso es
       instalar el núcleo y los controladores. Nosotros aún no haremos
       eso, por lo que bajamos hasta la opción de menú alternativa que
       indica «Inicializar y montar otra partición».
       Una vez seleccionada, aparece una pantalla similar a la
       anterior con las siguientes particiones:
       <itemizedlist>
          <item>/dev/hda2</item>
          <item>/dev/hda7</item>
       </itemizedlist>
       Elegimos ahora la partición /dev/hda2 y aparece una pantalla
       nueva preguntando dónde desea montar la partición.
       De las opciones que aparezcan, seleccionamos /boot y
       confirmamos.
      </para>
    </sect2>
    <sect2 id="home"> <title>Montar o inicializar la partición de datos de usuario</title>
      <para>
       Si es nuestra primera experiencia con GNU/Linux, tendremos que
       inicializar la otra partición y montarla bajo /home.
       Si ya tenemos datos que queremos conservar de instalaciones
       anteriores, tan sólo hay que montar la partición bajo el
       directorio /home.
      </para>
      <para>
        Si esta es tu primera vez, a continuación selecciona la opción
        «Inicializar y montar otra partición».
        Si ya instalaste Debian y deseas conservar tus datos de
        usuario, selecciona «Montar partición ya inicializada».
      </para>
      <para>A continuación aparece por tercera vez el menú de
      seleccion de particiones, pero ya con sólo una entrada.
      Selecciona la partición (/dev/hda7) y a continuación aparece 
      otro menú preguntándote donde quieres montarla. Entre todas las
      opciones, selecciona /home.
      <para>
      <para> Si ha elegido «Inicializar y montar», se volverá a pedir
      confirmación antes de formatear la partición y perder todos los
      datos de una posible instalación anterior. Si es su primera
      instalación de Debian, pulse en «sí» sin más. Si NO es su
      primera instalación de Debian, y quiere borrar todos los
      ficheros personales que tenía pulse «sí». En cualquier otro caso
      pulse «No» y seleccione «Montar una partición ya inicializada».
    </sect2>
<!-- Esto creo que ha cambiado -->
    <sect2 id="kernel and modules"> <title>Instalar núcleo del SO y módulos </title>
      <programlisting>
	Seleccione el  medio de instalación
	  CDROM (si hay mas de uno --lectora, grabadora-- debéis escoger)
      </programlisting>
      <para>
	Es recomendable aceptar con ENTER lo siguiente
      </para>
      <programlisting>
	Choose Debian archive path
	/instmnt
	Select Debian archive path
	default: The default stable archive
      </programlisting>
    </sect2>
<!-- END CoMMENT -->
    <sect2> <title>Configurar módulos de dispositivos  </title>
  <para>
	Si estás usando instalación con los 7 CDs no hay que hacer
        nada aquí, excepto si tienes una conexión directa a la red y
        quieres cargar el controlador de tu tarjeta ethernet; pero eso 
        siempre puedes hacerlo luego con la instrucción modconf, asi que acepta.
  </para>
      <programlisting>
	Salir
	Finalizar con estos módules 
	Volver al menú anterior
      </programlisting>
    </sect2>


    <sect2 id="hostname"> <title>Configurar el nombre del host</title>
    <para>
       Preguntarán por el nombre de la máquina. Escoge el que más te
       guste. Si das a ENTER por omisión será «debian». Luego preguntarán
       si estás conectado a la red. Si la conexión se va a establecer
       via PPP, (por módem y teléfono) entonces hay que responder
       &lt;No&gt;. Si estamos conectados mediante una red eth0 nos
       pedirán también el nombre de dominio y nuestra IP, la IP de la 
       puerta de enlace, y los DNS. Si se mete la pata no importa
       porque al final podemos editar /etc/init.d/network y cambiar lo
       que queramos. Si la respuesta fue &lt;Sí&gt;, seguiremos con:
      </para>
    </sect2> 
<!--Esta seccion ha cambiado-->
      <sect2> <title>Configurar la red</title>
      <para>
	Configuración para eth0
      </para>
      <para>
	¿Quiere usar DHCP o BOOTP para configurar automáticamente... (¡No! Mejor a mano)
      </para>
  <para>
	&lt;No&gt;
      </para>
      <para>
	Do you want to manually configure this interface?
      </para>
      <para>
	&lt;Yes&gt; (Es lo mejor, saber lo que uno se hace)
      </para>
      <para>
	Y ahora viene una serie de preguntas para configurar la red:
      </para>
      <para>
	
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Choose the IP address (introducimos la IP de nuestra máquina y &lt;OK&gt;)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Choose the network mask (generalmente si es de una red C será 255.255.255.0 &lt;OK&gt;)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    What is your Gateway address (ponéis la IP de vuestra pasarela, generalmente si la IP de vuestra máquina es W.X.Y.Z, la pasarela será W.X.Y.1)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Choose the domain name (lo ponéis, p.ej. en mi caso es us.es, &quot;Universidad de Sevilla, España&quot;) 
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	y ya está.
      </para>
    </sect2>
<!--FIN DE CAMBIO-->
    <sect2 id="basesystem">  <title>Instalar el sistema base </title>
      <para>
	Seleccione el medio de instalación:
      </para>
      <para>
	CDROM , etc igualito que antes en <xref>.
      </para>
  </sect2>
    <sect2>
      <title>
	Configurar el sistema base
      </title>
      <itemizedlist>
	<listitem>
	  <para>
	    Seleccione zona horaria
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	(Busca en el panel izquierdo Europe (ENTER). Luego con la tecla  pásate al panel de la derecha y escoge Madrid (ENTER))
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Timezone configuration
	  </para>
	</listitem>
      </itemizedlist>
      <para>
   (Si tienes otro sistema operativo a parte de GNU/Linux no configures el reloj a GMT, sino a hora local: es decir escoge &lt;No&gt;)
      </para>
    </sect2>
  <sect2>
      <title>
	Make GNU/Linux bootable directly from hard disk
      </title>
      <para>
	Where should the LILO boot loader be installed?
      </para>
      <para>
	/dev/hda : Install LILO in the MBR 
      </para>
      <para>
	/dev/hda4 : Install LILO in the target boot sector (Ideal cuando disponemos de un bootloader, como el bootmagic o el OS2 boot loader para arrancar diversos sistemas operativos)
      </para>
      <para>
	Puede ocurrir que debido a la configuracion del disco duro, la BIOS no permita instalar LILO en la partición raíz de GNU/Linux. Esto puede ocurrir fundamentalmente si hemos sobrepasado el limite de los 1024 cilindros o a veces si está en una partición lógica. Si ocurre algún problema como este no importa, arrancaremos con loadlin o con un disquete (desaconsejable porque tarda mucho en cargar). De todos modos responde &lt;No&gt; a la pregunta 
      </para>
      <para>
	Do you want to install the MBR anyway?
      </para>
      <para>
	Y a continuación pararemos a instalar LILO en un disquete formateado (es bueno tenerlo a mano por si acaso).
      </para>
    </sect2>
    <sect2>
      <title>
   Alternate: Make a boot floppy
      </title>
      <para>
	Change disk
      </para>
      <para>
	Place a blank floppy disk in the floppy disk driver and press ENTER (Lo hacemos)
      </para>
      <para>
	Formatting the floppy...
      </para>
      <para>
	Creating a filesystem on the floppy...
      </para>
      <para>
	Copying the operating system kernel
      </para>
    </sect2>
    <sect2>
      <title>
	Reboot the system
      </title>
      <para>
	Reboot the system?
      </para>
      <para>
	&lt;Yes&gt; Pero antes de que lo hagáis considerad:
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    si arrancáis mediante LILO en el MBR o en la partición raíz, quitad el floppy de la disquetera 
	  </para>
	</listitem>
	<listitem>
	  <para>
	    si lo hacéis desde el floppy, dejadlo dentro
	  </para>
	</listitem>
	<listitem>
	  <para>
	    si lo vais a hacer con loadlin, primero arranca con el floppy para terminar la instalación y luego ya lo acabaremos.
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Reiniciad la maquina... y continuamos con la instalación.
      </para>
    </sect2>
    <sect2>
   <title>
	Debian System configuration
      </title>
      <itemizedlist>
	<listitem>
	  <para>
	    Shall I enable md5 passwd? (a gusto del consumidor...puede dar problemas si usamos NIS)
   </para>
	</listitem>
      </itemizedlist>
      <para>
   si decimos que no, entonces
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Shall I enable shadow passwd?
	  </para>
	</listitem>
      </itemizedlist>
      <para>
   Y entonces les diremos que sí (hay que encriptar los passwd de alguna de las dos manera. Si no lo hacéis y administráis una red, tarde o temprano llegara el intruso para birlar el /etc/passwd)
      </para>
      <para>
	
      </para>
      <para>
	Ahora hay que establecer el password del root y re-escribirlo para confirmar
      </para>
      <para>
	Shall I create a user account?
      </para>
      <para>
	&lt;Yes&gt; (Por supuesto. Aunque estemos solos en casa no debemos nunca andar por ahí como root si no es para hacer las labores propias del administrador, pues cualquier equivocación podría provocar un desastre. Máxime si tenemos varios usuarios)
      </para>
      <para>
	Tenéis que introducir el nombre de la cuenta de usuario y la contraseña (dos veces).
      </para>
      <para>
	Shall I remove pcmcia packages?
      </para>
      <para>
	&lt;Yes&gt; (Evidentemente, si no usáis pcmcia, mejor es borrarlos)
      </para>
      <para>
	Do you want to use a ppp connection to install the system?
      </para>
      <para>
	&lt;No&gt; porque estamos instalando desde CDs.
      </para>
      <para>
	
      </para>
      <para>
	Ahora se producirá un barrido del CD1 en el lector de CD-ROM y a continuación comenzará la configuración del apt (Apt configuration). Esto es muy importante para evitar quebraderos de cabeza: Si disponemos de varios CDs (3 oficiales y 1 no oficial) conviene que apt los escanee uno a uno. Ya lo ha hecho con el primero; así que cuando pregunte
      </para>
      <para>
	Scan another CD?
      </para>
      <para>
	Debéis expulsar el CD1 del lector y sustituirlo por el siguiente (CD2)
      </para>
      <para>
	Luego respondéis que &lt;Yes&gt; (atención que por defecto es &lt;No&gt; y vuelve a serlo así después de cada escaneo)
      </para>
      <para>
	
      </para>
      <para>
	....Se produce el escaneo....
      </para>
      <para>
	
      </para>
      <para>
	Y después repetís los mismos pasos hasta que hayáis escaneado todos los CDs (si tenéis algún otro como el de Helix-Gnome + KDE de opencd, pues, también). Cuando acabéis, aparecerá:
      </para>
      <para>
	
      </para>
      <para>
	Apt is now configured and should be able to install Debian packages
      </para>
      <para>
	Add another Apt source
      </para>
      <para>
	&lt;No&gt; (Por ahora. Luego ya descomentaremos cosas del archivo /etc/apt/sources.list para bajarnos nuevos paquetes via ftp)
      </para>
      <para>
	ATENCIÓN Llegamos a la instalación de paquetes de software en el sistema Debian. Hay dos formas de hacer la selección: La avanzada (Advanced), que no la vamos a considerar para un novicio (pues además de tener las ideas muy claras y usar el programa dselect es bastante lenta) y la simple que consiste en escoger colecciones de aplicaciones preestablecidas. Convendría que os leyerais en el CD1 los documentos en español que están en /install/doc/es/  con un interesante manual de dselect para principiantes.
      </para>
      <para>
   De este modo, seleccionamos la opción simple y aparecerá un menú con las colecciones a instalar:
      </para>
      <para>
	
      </para>
      <para>
	Select task package install (pongo unas cuantas e incluso intercaladas subrayando las que pienso son mas importantes para el recién llegado...pero hay alrededor de 40)
      </para>
      <para>
	
      </para>
      <para>
	-------------------------------------------------------------------
      </para>
      <para>
	[ ] C ++ Dev  ( C++ development)
      </para>
      <para>
	[ ] C  Dev (C development)
      </para>
      <para>
	[ ] Database Pg (Postgre SQL database)
      </para>
      <para>
	[ ] Debian Devel (Debian package development)
      </para>
      <para>
	[ ] Debug (Debugging of C++, C,..)
      </para>
      <para>
	[ ] Devel common (Development in various languages)
      </para>
      <para>
	[ ] Dialup (Dialup utilities)
      </para>
      <para>
	[ ] Dialup isdn (queda claro)
      </para>
      <para>
	[ ] Dns Server 
      </para>
      <para>
	[ ] Fortran
      </para>
      <para>
	[ ] Gnome App (GNOME applications and utilities)
      </para>
      <para>
	[ ] Gnome desktop
      </para>
      <para>
	[ ] Gnome net
      </para>
      <para>
	[ ] Imap (imap server)
      </para>
      <para>
	[ ] Laptop
      </para>
      <para>
	[ ] Newbie help (;-D)
      </para>
      <para>
	[ ] News server
      </para>
      <para>
	[ ] Object Dev (Object C development)
      </para>
      <para>
	[ ] Python  (Python scripts)
      </para>
      <para>
	[ ] Samba
      </para>
      <para>
	[ ] Science (science basic tools)
      </para>
      <para>
	[ ] Sgml (Sgml &amp; XML authoring and editing)
      </para>
      <para>
	[ ] Sgml Dev 
      </para>
      <para>
	[ ] Spanish (8-&gt;)
      </para>
      <para>
	[ ] TclTk
      </para>
      <para>
	[ ] TclTk Dev 
      </para>
      <para>
	[ ] Tex (Tex/LaTeX environment)
      </para>
      <para>
	[ ] X window system (Complete)
      </para>
      <para>
	[ ] X window system core (core components)
      </para>
      <para>
	----------------------------------------------------------------
      </para>
      <para>
	
      </para>
      <para>
	Se seleccionan con la barra espaciadora. Cada uno que escoja lo que quiera y pueda. Yo escogí Desarrollo C y C++, Debug, Dialup, Fortran, Gnome (Apps, desktop y net), Python, Science, Sgml y Sgml Dev, Spanish, TclTk y TclTk Dev, TeX y X windows (por razones de mi trabajo y para disfrute personal)
      </para>
      <para>
	Una vez hecha la selección damos a Finish (las otras teclas dan información sobre las aplicaciones señaladas y ayuda).
      </para>
      <para>
	
      </para>
      <para>
	Aparecerá entonces la pregunta ...
      </para>
      <para>
	If you have a PCI video card...(es el momento de gestionar su configuración)
      </para>
      <para>
   Si la tienes responde &lt;Yes&gt; y al asunto.
      </para>
  <para>
	
      </para>
      <para>
	Ahora apt buscará en la base de datos que ha elaborado en los barridos de los CDs y empezará a instalar los paquetes correspondientes a las colecciones que hemos seleccionado. De vez en cuando pedirá que cambies el CD del lector (algo semejante al yast de SuSE) e irá desenpaquetándolos. Sírvete un refresco y espera un ratito...pero atento que hay que responder algunas preguntas. 
  </para>
      <para>
	
      </para>
      <para>
	...setting libpaperg
      </para>
      <para>
	Default paper name? (estará en letter, así que poned a4)
      </para>
      <para>
	
      </para>
      <para>
	...setting up exim (/usr/sbin/eximconfig) (Exim es el MTA usado por Debian ¡mucho mas sencillo que sendmail y qmail)
      </para>
      <para>
	Automatic configuration of your mail system by asking a number of questions. (Podéis consultar luego eximdoc y /usr/doc/exim/spec.txt)
      </para>
      <para>
	Ahora te suelta una serie de opciones. Si te conectas via PPP como la mayoría de los usuarios domésticos escoge la opción (2):
      </para>
      <para>
	Internet site using smarthost: You receive internet mail on this machine (either directly by SMTP or by running a utility such as fetchmail). Outgoing mail is sent using a smarthost. Optionally with address rewritten. (Esta claro, eh?)
      </para>
      <para>
	Enter value:2
      </para>
      <para>
	...Y empiezan las preguntas...
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    What is the 'visible' mail name of your system? This will appear in 'From:'
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Enter value (default 'el nombre de la maquina'):
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Does this system have any other names which appears on incoming mail messages apart from the 'visible' name above (el nombre de la maquina) and localhost?
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Enter value (default'none'):transmetita.com (por ejemplo XDDDDD)
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Are there any domains you want to rely mail for? (mejor ninguno)
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Enter value (default 'none'):
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Are there any networks or local machines  you want to relay mail for? (que no, que no)
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Enter value (default 'none'):
      </para>
      <itemizedlist>
	<listitem>
	  <para>
   Would you like to use RBL (Real Time Blackhole) to spam filter. (No vale si no recibes directamente el correo. De todos modos con fetchmail+procmail puedes filtrarte lo que quieras)
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Enter value (default 'n'):
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Which machine will act as the smarthost and handle outgoing mail (El smpt server de nuestro ISP, p. ej., en mi caso pbox.cica.es)
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Enter value (no hay default):
      </para>
      <itemizedlist>
	<listitem>
	  <para>
   Which user accounts should system administrator mail to go? (Redireccionamos a ese usuario, p.ej. strogoff, el correo de root y de postmaster)
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Enter value ('none' si no se redirige):
      </para>
      <para>
	
      </para>
      <para>
	...Se acabo la configuración del exim
      </para>
      <para>
	NOTA: Luego hay que leerse un poco la documentación de exim y retocar el fichero de configuración /etc/exim.conf para que funcione adecuadamente...y aquí cada maestrillo tiene su librillo. Si uno es novato y quiere empezar a utilizar el correo electrónico pronto y sin problemas así como leer grupos de news sin configurar casi nada...mejor es que instale primero Netscape 4.73 (Communicator, Messenger y Navigator) para mantenimiento y ya aprenderá más tranquilamente a configurar su MTA (exim, sendmail, qmail) para enviar el correo, su MDA (fetchmail+procmail) para recibirlo y su MUA (pine, mutt) para leerlo y componerlo. Las news las almacenará con el proxy-caché leafnode de su servidor de news y las leerá con slrn o gnus. O montará un verdadero servidor de news como inn y las procesará con sucks... Primero lo fácil para poder aprender lo que aparentemente se nos antoja difícil.
      </para>
      <para>
	
      </para>
      <para>
   Do you want configure wvdial now?
      </para>
      <para>
   Como queráis, pero quizás sea mejor usar luego pppconfig, o usar el pppdialer de GNOME.
      </para>
      <para>
	
      </para>
      <para>
	Atención que llegan las X window:
      </para>
      <para>
    
      </para>
      <para>
	No default X server previously set
      </para>
      <para>
	Do you want to make the VGA16 Xserver the default? &lt;n&gt; (No!!. Ahora no porque no se como se las ingenia que todavía no funciona el ratón con XF86Setup y además no hemos seleccionado el servidor que corresponda mejor a nuestra tarjeta gráfica. En mi caso será el SVGA pues tengo una tarjeta S3 Virge GX2 (algo carrozona pero que me va muy bien).
      </para>
      <para>
	
      </para>
      <para>
	NOTA:
      </para>
      <para>
   ...Si te aparece 'Packages failed to install. Retry?' di que &lt;Yes&gt; sin miedo y no te acongojes si todo acaba aquí y te aparece el login del sistema. Esto puede ocurrir cuando se instalan al principio un montón de paquetes. Voy a suponer lo peor.
      </para>
      <para>
	Tranquilamente entra como root (sí ahora sí) y luego haz dselect (deberás haberte leído un poco como funciona esta gran utilidad pero poco intuitiva al comienzo)
      </para>
      <para>
   Después de pasar por Access vas directamente a Install (te saltas el Update y Select) y entonces continuará instalando lo que quedó por hacer...te volverá a pedir que le cambies de CDs y seguirá preguntando ¡Animo!.
      </para>
      <para>
    
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Configurar gpm 
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	(Ya va a funcionar el ratón)
      </para>
      <para>
	Mira la configuración que tiene y si es la correcta la aceptas. A partir de ahora, el ratón funcionará en la consola. En mi caso el protocolo era:
      </para>
      <para>
    
      </para>
      <para>
	gpm -m /dev/psaux -t ps2 -Rms3
      </para>
      <para>
	
      </para>
      <para>
	NOTA: En el proceso de instalación del ratón, si alguno de los ítems no lo sabes escribe help en lugar de ninguna opción y presentará una lista de la misma. Creo que durante la instalación no hace ninguna prueba para caracterizar el ratón. Si después de la configuración, no funciona el ratón porque nos hemos equivocado, no importa. Después de la instalación y en modo consola como root, hacemos
      </para>
      <programlisting>
	/usr/sbin/gpm-mouse-test
      </programlisting>
      <para>
	para caracterizarlo. Y cuando lo tengas claro (que deberías saberlo
	antes de la instalación) lo re-configuras con 
      </para>
      <programlisting>
	/usr/sbin/gpmconfig
      </programlisting>
      <para>
	Luego, automáticamente se reiniciará el servidor gpm.
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Select the number of the default dictionary
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	A gusto del debian user.
      </para>
      <para>
	
      </para>
      <para>
	Por fin termina la instalación...
      </para>
      <para>
	
      </para>
      <para>
	luego Config para configurar los paquetes,
      </para>
      <para>
	luego Remove para eliminar software no deseado y 
      </para>
      <para>
	luego Quit para salir.
      </para>
      <para>
    
      </para>
      <para>
	
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>
      La Post-instalación
 </title>
    <sect2>
      <title>
	Configuración de las X-Window
      </title>
      <para>
	Woody viene con el sistema de ventanas X-Window 4.1.0 que
	difiere bastante de las versiones anteriores. Si vuestra
	tarjeta es muy antigua, seguramente estará soportada por el
	servidor SVGA. Si este no es el caso, quizá debas probar con
	el framebuffer.
      </para>
      <para>
	Para instalar el sistema de ventanas hacemos como root:
      <programlisting>
       [root@doomslayer]# apt-get update && apt-get install x-window-system
      </programlisting>
      y se seleccionarán varios paquetes. Confirmamos la instalación y
      a continuación aparecerá un menú en la pantalla preguntando por 
      los datos del sistema gráfico de nuestro equipo.
      </para>
      <para>
	
      </para>
      <para>
	Pasamos por Access, Update y al llegar a Select buscamos la cadena SVGA (invocamos la búsqueda tecleando / (que nos presenta en la barra inferior el carácter ?) Y a continuación escribimos 'svga' y vamos viendo en que paquete aparece la cadena. La búsqueda se continúa con \, hasta que encontremos el paquete buscado (si está, claro ;-/). En mi caso lo encuentro, lo señalo (con +, leeros el manualito de dselect) y luego como siempre, Install, Config, Remove y Quit.
      </para>
      <para>
   Ahora es el momento de hacer la instalación gráfica de las X con la herramienta XF86Setup. Hacemos, pues
      </para>
      <para>
	
      </para>
      <para>
	XF86Setup
      </para>
      <para>
    
      </para>
      <para>
	Y a partir de ahora vamos configurando paso a paso cada ítem gráficamente mediante clicks y arrastres con el ratón.
      </para>
      <para>
	El procedimiento es muy intuitivo porque en la barra superior de la ventana aparecen botones correspondientes a los elementos que hemos de configurar: Mouse, Keyboard, Card, Monitor, Mode Selection y Other. Empezamos con el ratón mismo (mouse): ya estará bien configurado y simplemente si es un ratón de dos botones conviene activar la emulación con tres botones.
      </para>
      <para>
   NOTA: Puede ocurrir en el caso de que nuestro ratón sea ps2 y haya sido configurado previamente y lanzado como demonio (gpm -m /dev/psaux -t ps2 -Rms3, que al configurar las X aparezca no como /dev/psaux, sino como Microsoft  gpmdata (pseudodevice, repeater data for gpm mouse daemon). No os preocupéis y p'alante. (apply)
      </para>
      <para>
	
      </para>
      <para>
	En el teclado (keyboard) debéis seleccionar el de 102 teclas internacional y el idioma Spanish (apply)
      </para>
      <para>
	
      </para>
      <para>
	En el apartado de la tarjeta gráfica (Card) debéis seleccionarla de la lista. En mi caso se trata de una S3 Virge GX2 (generic). Podemos pasar al detailed setup y veremos arriba seleccionado el servidor X correspondiente a la tarjeta en cuestión, en mi caso, de nuevo es el SVGA. Podemos indicar la cantidad de memoria de la misma (la mía tiene 4Mb de video RAM) y si lo sabemos, mas opciones (chipset, ramdac, Clockchip) pero NO ES NECESARIO; basta con escoger la tarjeta y con mucho indicar la memoria.
      </para>
      <para>
	
      </para>
      <para>
	Para configurar el Monitor debemos escribir en los dos panelitos superiores bajo la denominación de Monitor sync rates los intervalos de frecuencias horizontales y verticales del mismo que las debéis saber (mirad la documentación). El mío tiene de frecuencia horizontal el intervalo 30-69 (kHz) y de vertical el rango de 50-120 (Hz).
      </para>
      <para>
	
      </para>
      <para>
	Los modos gráficos (Mode selection) permiten elegir la resolución de los gráficos así como la profundidad de color expresada en bits por pixel (bpp). El número de colores se puede calcular como 2 **profundidad (2 elevado al valor de profundidad de bpp). Así, 8 bpp corresponden a 256 colores, 16bpp a 65536, 24bpp a casi 17 millones y 32 bpp (true color) a más de cuatro mil millones. Las tarjetas gráficas almacenan el contenido de los píxeles en memoria de acceso aleatorio, conocida como vídeo RAM. El número de colores y la resolución de pantalla admitido por una tarjeta gráfica depende de su video RAM. Por ejemplo: Si quiero una resolución de 1024 x 768 pixels y una profundidad de color de 16 bpp, la cantidad de memoria necesaria será: 1024 x 768 pixel x 16 bits/pixel = 12582912 bits = 1572864 bytes (8 bits = 1byte) = 1.6 Mbytes (aprox.). Si tengo una tarjeta de 4 Mbytes puedo mantener esa resolución a 24 bpp (necesita unos 2.4 Mbytes) y a 32 bpp (alrededor de 3.2 Mbytes). Con una tarjeta de 1 Mbyte no puedo conseguir resolución de 1024x768 ni siquiera con el mínimo de profundidad ( 8bpp). Hacemos las cuentas y seleccionamos la resolución y la profundidad que queremos. En mi caso escogí 1024x768pixel y 16bpp.
      </para>
      <para>
	
      </para>
      <para>
	Ya solo queda hacer click en el siguiente y último botón de la barra superior (Other) y comprobar que tiene activada la secuencia de escape de las X, con las teclas Alt+Ctrl+Backspace y hacemos click en Done, con lo cual después de unos momentos nos saldrá el panel donde nos dice la ruta en que se almacenará la configuración (/etc/X11/XF86Config) y si todo ha ido bien seleccionaremos Save the configuration and exit y ¡se acabó la configuración de las X! La próxima vez que inicies tu Debian se activará el login gráfico (seguramente) mediante el xdm (X desktop manager) que se ejecutará en el arranque y se continuará (respawn) aunque quieras escapar de él. Ahora simplemente para pasar ya a modo gráfico puedes hacer como usuario
      </para>
      <para>
	
      </para>
      <para>
	startx
      </para>
      <para>
    
      </para>
      <para>
	y seguramente se cargará el gestor de ventanas WindowMaker. Si deseas vislumbrar en seguida tu flamante GNOME podemos hacer la chapuza siguiente: Sal de las X, crea en tu /home/usuario el fichero .xinitrc y escribe dentro con tu editor favorito (los mios son vim o emacs) la línea 
      </para>
      <para>
	
      </para>
      <para>
	exec gnome-session
      </para>
      <para>
	
      </para>
      <para>
	y sálvalo. Vuelve a hacer startx y ya lo verás. De todos modos seguramente de ahora en adelante a partir del próximo inicio el login será gráfico y entrarás directamente en las X. Si quieres pasar a una consola lo puedes hacer con Alt+Ctrl+Fx (x de 1 a 6) y vuelves a la pantalla gráfica con Alt+Ctrl+F7.
      </para>
    </sect2>
    <sect2>
   <title>
	Loadlin
  </title>
      <para>
	Antes que se me olvide, si resulta que quieres usar loadlin desde tu windows ahora es el momento de prepararlo todo. Sigue como root y monta en /mnt la partición de tu Windows 98 (que sera p. ej. /dev/hda1) mediante
      </para>
      <para>
	
      </para>
      <programlisting>
	debian:~# mount -t vfat /dev/hda1 /mnt
	debian:~# cd /mnt
	debian:/mnt# mkdir loadlin
	debian:/mnt# cd /boot
	debian:/boot# ls
      </programlisting>
      <para>
	y verás que entre los archivos se encuentra vmlinuz-2.2.17 que es nuestro kernel de arranque. Vamos a copiarlo al directorio loadlin que hemos hecho en la partición de windows 98 (que coincidirá con la unidad C:\ en DOS/WINDOWS) con el nombre de 'vmlinuz'
      </para>
      <para>
	
      </para>
      <para>
	debian:/boot# cp vmlinuz-2.2.17 /mnt/loadlin/vmlinuz
      </para>
      <para>
	
      </para>
      <para>
	Pon ahora el CD1 en el lector de cdrom y móntalo
      </para>
      <para>
	
      </para>
      <programlisting>
	debian:/# mount -t iso9660 /dev/hdb /cdrom
	debian:/# cd /cdrom/tools/
	debian:/cdrom/tools# ls
	

      </programlisting>
      <para>
	y verás entre otros archivos a lodlin16.zip.
      </para>
      <para>
	
      </para>
      <para>
	Cópialo y descomprímelo en /tmp:
      </para>
      <para>
	
      </para>
      <programlisting>
	debian:/cdrom/tools# cp lodlin16.zip /tmp
	debian:/cdrom/tools# cd /tmp
	debian:/tmp# unzip lodlin16.zip
	
	
      </programlisting>
  <para>
	Unzip debe estar instalado (si no hacerlo mediante dselect).Al descomprimir se producirá el directorio lodlin16 que contiene dos ficheros fundamentales: loadlin.exe y linux.bat
  </para>
      <para>
	
  </para>
      <programlisting>
	debian:/tmp# cd lodlin16
	debian:/tmp/lodlin16#
      </programlisting>
      <para>
	Edita ahora con tu editor favorito el fichero linux.bat y verás su contenido:
      </para>
      <para>
	
      </para>
      <programlisting>
	rem
	Sample DOS batch file to boot GNU/Linux.
	rem
	First, ensure any unwritten disk buffers are flushed:
	smartdrv /C
	rem
	Start the LOADLIN process:
	c:\loadlin\loadlin
	c:\loadlin\zimage
	root=/dev/hdb2
	ro
	vga=3	
      </programlisting>
      <para>
	debemos cambiar /dev/hdb2 por nuestra partición GNU/Linux: /dev/hda4 (en nuestro ejemplo)
      </para>
      <para>
	
      </para>
      <para>
	y luego lo salvamos.
      </para>
      <para>
	
      </para>
      <para>
	Ahora, después de esto, copiamos estos dos ficheros en el directorio loadlin que habíamos creado en la partición de Windows:
      </para>
      <para>
	
      </para>
      <para>
	debian:/tmp/lodlin16# cp loadlin.exe  linux.bat  /mnt/loadlin/
      </para>
      <para>
	
      </para>
      <para>
	y ya está todo listo
      </para>
      <para>
    
      </para>
      <para>
	Si estás escribiendo desde una xterm en las X, sal de ahí y desde la consola haz un reboot (o directamente Alt+Ctrl+Del). Inicia Windows 98 con el bootmanager que tengas y una vez allí: ve con el explorador de Windows a la carpeta c:\loadlin. Marca el fichero linux.bat con el ratón y selecciona en el menú de edición 'Copiar'. Vamos al escritorio, pulsamos el botón derecho del ratón y seleccionamos 'Pegar Acceso Directo'. Marcamos el acceso directo recién hecho con un click del ratón y pulsando su botón derecho seleccionamos 'Propiedades'. Escogemos la solapa 'Programa' y pulsamos en 'Avanzado...', luego marcamos la casilla 'Modo MS-DOS' y confirmamos con 'Aceptar'. Después pulsamos en 'Cambiar Icono...' y escogemos el que mas nos guste (El del capirote de mago con varita mágica por ejemplo &lt;(8^) ). Podemos cambiar la leyenda del icono (linux.bat) por otra mas adecuada como 'Acceso Debian 2.2'. Al hacer doble click sobre el icono, saldrá primero una advertencia de que vamos a entrar en modo MS-DOS y luego ...accederemos a Debian. (Esto lo he sacado de mi manual de SuSE 6.4)
      </para>
      <para>
	NOTA: Es posible pasar parámetros con loadlin como se hace con lilo, pero no lo comentaré. Leeros el manual de loadlin que viene en lodlin16.zip y mirad el ejemplo test.par.
      </para>
    </sect2>
    <sect2>
      <title>
	Configuración de la tarjeta de red
      </title>
      <para>
	Si estando directamente conectados a la red mediante tarjeta ethernet y no cargamos en el núcleo los controladores como módulos, ahora es el momento de hacerlo. Tenemos evidentemente que tener los datos de nuestra tarjeta. En mi caso de trata de una típica SMC Ether EZ con io = 0x2a0. El correspondiente driver es el smc-ultra. Hacemos como root modconf y seleccionamos net. Allí se encuentran los controladores correspondientes a tarjetas de red como módulos cargables. Buscamos el módulo smc-ultra (SMC Ultra support) y lo instalamos. En este caso nos aparecerá en la pantalla:
      </para>
      <para>
	----------------------------------------------
      </para>
      <para>
	smc-ultra
      </para>
      <para>
	
      </para>
      <para>
	io=0 (It will complaint if you don't supply an &quot;io=0xNNN&quot;)
      </para>
      <para>
	irq=0 (IRQ val. read from EEPROM)
      </para>
      <para>
	(Probeports: 0x200, 0x220, 0x240, 0x280, 0x300, 0x340, 0x380)
      </para>
      <para>
	Depends on 8390.o
      </para>
      <para>
	-----------------------------------------------
      </para>
      <para>
	Lo que significa que yo tengo que escribir como parámetro io=0x2a0 (que ya sabía), mientras la irq se va a leer automáticamente. También dice que depende del módulo 8390.o, que también habrá de ser cargado. Pues bien introducimos el valor anterior como parámetro e instalamos el módulo. Luego al volver al menú net vemos que automáticamente se ha cargado también el 8390 (¡lógico!)
      </para>
      <para>
	Ahora hacemos
      </para>
      <para>
	Exit Finished with these modules y salimos de ahí. Si todo ha ido bien y hacemos ifconfig, aparecerá además del bloque de loopback (lo) el de la interfaz ethernet (eth0).
      </para>
    </sect2>
    <sect2>
      <title>
	Configuración de la impresora
      </title>
      <para>
	Antes de nada miraremos con lsmod y comprobaremos que no están instalados por defecto los módulos parport ni parport_pc, que son necesarios para el funcionamiento de una impresora en paralelo. Debemos de cargar los módulos con la herramienta modconf ejecutada como root. Seleccionamos la opción misc e instalamos parport y parport_pc para que se carguen en el núcleo sin opciones ni parámetros. Si hacemos de nuevo lsmod, veremos que ya están.
      </para>
      <para>
	Usemos ahora dselect para cargar el paquete magicfilter con todas sus dependencias:
      </para>
      <para>
	Ejecutamos dselect y como siempre pasamos secuencialmente por Access, Upgrade y Select...Entonces buscamos la cadena magicfilter ( tecleando / ). Seleccionamos dicho paquete y todos los que recomienda o sugiere: enscript, libjpeg-gif, libtiff-tools, psptools, recode y djtools. Pasamos a Install, luego a Config, Remove y Quit. Ya están todos instalados. Ahora ejecutamos
      </para>
      <para>
	magicfilterconfig --force (--force para ya existe un fichero /etc/printcap original que sera sobreescrito)
      </para>
      <para>
	y seguimos sus indicaciones. En mi caso tengo una Epson Stylus Color 600:
      </para>
      <para>
    
      </para>
      <programlisting>
	#Printer 1
	Full name: Epsilon Stylus Color 600
	Short name: stc600
	Full device path: /dev/lp0
	Input Filter (Aparecen en pantalla): StylusColor-600@720dpi
      </programlisting>
      <para>
	cuando acabemos de rellenar el último printer, y salga la cabecera del siguiente, finalizamos poniendo 'done' en el Full name. En nuestro caso acabamos así:
      </para>
      <programlisting>
	#Printer 2
	Full name: done
      </programlisting>
      <para>
	.... Te hace un resumen ...
      </para>
      <para>
	
      </para>
      <para>
	Is this OK? (y/n)
      </para>
      <para>
	
      </para>
      <para>
	Luego para comprobar hacemos
      </para>
      <para>
	
      </para>
      <para>
	lpr /etc/printcap y aparecerá nuestro fichero de cola de impresión. En mi caso es:
      </para>
      <para>
	
      </para>
      <programlisting>
	#
	# Copyright (c) 1983 Regents of the University of California.
	# All rights reserved.
	#
	# Redistribution and use in source and binary forms are permitted
	# provided that this notice is preserved and that due credit is given
	# to the University of California at Berkeley. The name of the University
	# may not be used to endorse or promote products derived from this
	# software without specific prior written permission. This software
	# is provided ``as is'' without express or implied warranty.
	#
	#       @(#)etc.printcap        5.2 (Berkeley) 5/5/88
	#
	# This file was generated by /usr/sbin/magicfilterconfig.
	#
	lp|stc600|Epson Stylus Color 600:\
	         :lp=/dev/lp0:sd=/var/spool/lpd/stc600:\
                 :sh:pw#80:pl#72:px#1440:mx#0:\
                 :if=/etc/magicfilter/StylusColor-600@720dpi-filter:\
                 :af=/var/log/lp-acct:lf=/var/log/lp-errs:
  </programlisting>
      <para>No comento las entradas del fichero porque eso es algo que encontraréis en cualquier manual de Unix y son muy intuitivas.</para>
    </sect2>
    <sect2>
      <title>
	Escuchar música
      </title>
      <para>
	Ahora es muy fácil conseguir configurar nuestra tarjeta de sonido si no es muy peregrina porque ya existe apoyo para sonido en el kernel en forma modular. El ejemplo lo voy a poner con mi tarjeta de sonido, una clásica entre las clásicas: una SoundBlaster 16. (Todavía me acuerdo cuando tenía la Debian 2.0 (Hamm) que tuve que recompilar el kernel monolíticamente para que funcionara). Es muy importante recopilar toda la información acerca de la tarjeta de sonido a partir de la documentación o del Panel de Control de Windows viendo las propiedades de los dispositivos, para saber las direcciones de entrada/salida (io), las solicitudes de interrupción (irq), el acceso directo a memoria (dma, dma16), etc. 
      </para>
      <para>
	
      </para>
      <para>
	En mi caso:
      </para>
      <para>
	Creative SoundBlaster 16
      </para>
      <para>
	irq=5
      </para>
      <para>
	dma=1
      </para>
      <para>
	dma16=5
      </para>
      <para>
	sb io = 0x220-0x22f
      </para>
      <para>
	mpu_io = 0x330-0x331
      </para>
      <para>
	adlib_card io = 0x388-0x38b
      </para>
      <para>
	
      </para>
      <para>
	Tenemos que instalar los módulos necesarios para sonido con modconf; que son:
      </para>
      <para>
	
      </para>
      <para>
	sound (OSS sound modules)
      </para>
      <para>
	soundcore (sound card support)
      </para>
      <para>
	soundlow (OSS sound modules)
      </para>
      <para>
	
      </para>
      <para>
	La verdad es que instalando el primero se cargan los otros dos. Comprobadlo con lsmod.
      </para>
      <para>
	Luego hay que instalar también los siguientes módulos:
      </para>
      <para>
    
      </para>
      <para>
	uart401 (Yamaha OPL3-SA1 audio controller)
      </para>
      <para>
	sb (SoundBlaster) con las opciones io=0x220  irq=5  dma=1  dma16=5  mpu_io=0x330
      </para>
      <para>
	adlib_card (FM synthetizer for YM3812/OPL-3 support) con la opción io=0x388
      </para>
      <para>
	
      </para>
      <para>
	A continuación hacemos cat /dev/sndstat y aparece:
      </para>
      <para>
    
      </para>
      <para>
	------------------------------------------------------------------
      </para>
      <para>
	OSS/Free:3.8s2++-971130
      </para>
      <para>
	Load type: Driver loaded as a module
      </para>
      <para>
	Kernel: GNU/Linux darkstar 2.2.13 #22 Wed Oct 20 17:32:52 CDT 1999 i686
      </para>
      <para>
	Config options: 0
      </para>
      <para>
	
      </para>
      <para>
	Installed drivers:
      </para>
      <para>
	
      </para>
      <para>
	Card config:
      </para>
      <para>
	
      </para>
      <para>
	Audio devices:
      </para>
      <para>
	0: Sound Blaster 16 (4.13) (DUPLEX)
      </para>
      <para>
	
      </para>
      <para>
	Synth devices:
      </para>
      <para>
	0: Yamaha OPL3
      </para>
      <para>
	
      </para>
      <para>
	Midi devices:
      </para>
      <para>
	0: Sound Blaster 16
      </para>
      <para>
	
      </para>
      <para>
	Timers:
      </para>
      <para>
	0: System clock
      </para>
      <para>
	
      </para>
      <para>
	Mixers:
      </para>
      <para>
	0: Sound Blaster
      </para>
      <para>
	-------------------------------------------------------------------
      </para>
      <para>
	
      </para>
      <para>
	OK! Si metemos un CD de música en nuestro lector y manualmente lo accionamos, lo escucharemos. Pero hacerlo así (aunque yo es lo que prefiero por sencillez) puede a otro parecer cutre y preferir por ejemplo hacerlo con el CD player del GNOME. En tal caso no le funcionará...todavía. Supongamos el caso de tener dos dispositivos de lectura de cdrom: un lector típico, /dev/hdd y un lector/grabador, /dev/hdb. Admitamos que en la instalación se usó el dispositivo /dev/hdb, con lo cual será el que apunta a /dev/cdrom. Si nos vamos al escritorio GNOME seleccionamos CD-player y en la configuración cambiamos /dev/cdrom por /dev/hdd. Pero aun no funciona después de esto...porque no tenemos permiso de acceso a una serie de dispositivos. Para que todos los usuarios de la máquina puedan escuchar música sin tener que pulsar manualmente la tecla del lector hay que dar los permisos adecuados:
      </para>
      <para>
    
      </para>
      <para>
	chmod 666 /dev/dsp  /dev/audio  /dev/hdd
      </para>
      <para>
    
      </para>
      <para>
	La próxima vez que ingresemos en el escritorio GNOME ya se producirán los eventos de sonido (si están funcionales). Y al activar el CD-player funcionará y escucharemos música <quote>con magno artificio</quote>.
      </para>
      <para>
	
      </para>
      <para>
	Antes de terminar voy también a decir como configurar tarjetas PCI como la Creative SoundBlaster PCI 64 o128. Estas tarjetas vienen provistas de chips del tipo Ensonic ES1370 ó ES1371. Para instalar el controlador correspondiente hacemos modconf, nos vamos a misc y allí cargamos el módulo es1370 ó es1371 (miramos antes el chip de la tarjeta). Cualquiera de ellos necesita también el módulo soundcore, pero se carga automáticamente al hacerlo con uno de los primeros. Solo con esto ya se puede escuchar música con el lector de CDs. 
      </para>
      <para>
	NOTA: Estas tarjetas no soportan el dispositivo /dev/sndstat ni permiten la reproducción directa con cat y /dev/audio. No tienen soporte MIDI por hardware, pero podemos parchearlo descargando el paquete timidity.
      </para>
    </sect2>
    <sect2>
      <title>
	Conexión PPP
      </title>
      <para>
	En principio utilizaremos la herramienta pppconfig, que es la genuina de Debian (no el vwdial). Para ello haremos como root
      </para>
      <para>
	
      </para>
      <para>
	pppconfig
      </para>
      <para>
	
      </para>
      <para>
	y seleccionamos
      </para>
      <para>
	
      </para>
      <para>
	Create a connection  &lt;OK&gt;
      </para>
      <para>
	
      </para>
      <para>
	(Voy a crear una conexión llamada alehop usando los datos de la conexión gratis que ofrecía alehop.com --hoy llamado eresmas.com-- pero que me funciona perfectamente)
      </para>
      <para>
	
      </para>
      <para>
	---Provider Name---
      </para>
      <para>
	Borramos la palabra 'provider' y escribimos 'alehop' &lt;OK&gt;
      </para>
      <para>
	
      </para>
      <para>
	---Configure Nameservers (DNS)---
      </para>
      <para>
	Escogemos 'Static' porque alehop.com tiene unas IP fijas para tales DNS
      </para>
      <para>
    
      </para>
      <para>
	(*) Static   Use Static DNS  &lt;OK&gt;
      </para>
      <para>
	
      </para>
      <para>
	---IP number---
      </para>
      <para>
	Introducimos la dirección IP del DNS principal
      </para>
      <para>
	
      </para>
      <para>
	62.81.16.197 &lt;OK&gt;
      </para>
      <para>
	
      </para>
      <para>
	Luego nos pedirá la del secundario
      </para>
      <para>
	
      </para>
      <para>
	62.81.0.1       &lt;OK&gt;
      </para>
      <para>
    
      </para>
      <para>
	---Authentication method for alehop---
      </para>
      <para>
	
      </para>
      <para>
	Escogemos PAP
      </para>
      <para>
    
      </para>
      <para>
	PAP         Peer Authentication Protocol   &lt;OK&gt;
      </para>
      <para>
    
      </para>
      <para>
	---User name---
      </para>
      <para>
	Sustituimos lo que hay por
      </para>
      <para>
	
      </para>
      <para>
	050@alehop  &lt;OK&gt;
      </para>
      <para>
	
      </para>
      <para>
	---Password---
      </para>
      <para>
	Sustituimos lo que hay por
      </para>
      <para>
	
      </para>
      <para>
	gratis   &lt;OK&gt;
      </para>
      <para>
	
      </para>
      <para>
	(¡que barbaridad, poniendo el password de mi ISP, para que lo vea cualquiera XDDDD!)
      </para>
      <para>
    
      </para>
      <para>
	---Speed---
      </para>
      <para>
	Velocidad del módem. Se recomienda dejar el valor
      </para>
      <para>
	
      </para>
      <para>
	115200   &lt;OK&gt;
      </para>
      <para>
    
      </para>
      <para>
	---Pulse or Tone---
      </para>
      <para>
	Seleccionamos
      </para>
      <para>
	
      </para>
      <para>
	(*) Pulse   &lt;OK&gt;
      </para>
      <para>
	
      </para>
      <para>
	---Phone number---
      </para>
      <para>
	Escribimos
      </para>
      <para>
	
      </para>
      <para>
	955000123
      </para>
      <para>
	
      </para>
      <para>
	---Choose modem config method---
      </para>
      <para>
	
      </para>
      <para>
	En lugar de escoger &lt;Yes&gt; con lo cual se hace una configuración automática, como sabemos el puerto serie de nuestro modem, decimos que &lt;No&gt;
      </para>
      <para>
	y lo escribimos nosotros a continuación:
      </para>
      <para>
    
      </para>
      <para>
	----Manually Select Modem Port---
      </para>
      <para>
	(en mi caso está en com2, es decir /dev/ttyS1)
      </para>
      <para>
	
      </para>
      <para>
	/dev/ttyS1   &lt;OK&gt;
      </para>
      <para>
    
      </para>
      <para>
	Ahora te da un resumen
      </para>
      <para>
    
      </para>
      <para>
	---Properties of alehop---
      </para>
      <para>
	Number    955000123    Telephone number
      </para>
      <para>
	User         050@alehop   ISP user name 
      </para>
      <para>
	Password  gratis             ISP password
      </para>
      <para>
	Speed       115200          Port speed
      </para>
      <para>
	Com         /dev/ttyS1      Modem com port
      </para>
      <para>
	Method     PAP              Authentication method
      </para>
      <para>
	
      </para>
      <para>
	Escojamos a continuación
      </para>
      <para>
	
      </para>
      <para>
	Finished     Write files and return to main menu   &lt;OK&gt;
      </para>
      <para>
    
      </para>
      <para>
	y después
      </para>
      <para>
	
      </para>
      <para>
	Quit     Exit this utility   &lt;OK&gt;
      </para>
      <para>
    
      </para>
      <para>
	¡Se acabó!
      </para>
      <para>
    
      </para>
      <para>
	De todos modos creo conveniente incluir en nuestro archivo /etc/resolv.conf los DNS del proveedor:
      </para>
      <para>
	---------------------------
      </para>
      <para>
	search alehop.com
      </para>
      <para>
	nameserver 62.81.16.197
      </para>
      <para>
   nameserver 62.81.0.1
      </para>
      <para>
	---------------------------
      </para>
      <para>
    
      </para>
      <para>
	Para la conexión (como root) usaremos la herramienta pon &lt;nombre preoveedor&gt;, monitorizaremos lo que pasa con plog y cerraremos la conexion con poff
      </para>
      <para>
    
      </para>
      <para>
   &gt;pon alehop
      </para>
      <para>
	
      </para>
      <para>
	(escucharemos el click del modem si es interno)
      </para>
      <para>
    
      </para>
      <para>
	esperamos un poco y saldrá algo como
      </para>
      <para>
	
      </para>
      <para>
	&gt;Local: 62.82.85.62 --&gt; Remote: 62.81.56.40 ppp0
      </para>
      <para>
    
      </para>
      <para>
	para ver todos los mensajes haremos
      </para>
      <para>
	
      </para>
      <para>
	&gt;plog (y vereis todo)
      </para>
      <para>
	
      </para>
      <para>
	Podemos comprobar nuestra conexión haciendo
      </para>
      <para>
	
      </para>
      <para>
	&gt;ifconfig
      </para>
      <para>
	
      </para>
      <para>
	y veremos que además del bloque de loopback (lo) está el de PPP (ppp0). Podemos probar a hacer ping, traceroute, telnet...y cuando queramos cerrar la conexión, escribimos
      </para>
      <para>
	
      </para>
      <para>
   &gt;poff (oiremos de nuevo el click)
      </para>
      <para>
    
      </para>
      <para>
	Bueno, el que lo desee puede configurar su conexión gráficamente usando el GNOME pppdialer que se parece mucho al kppp del KDE.
  </para>
      <para>
	
      </para>
    </sect2>
    
<sect2 id="Spanish"> 
   <title>
      Hispanizando Debian 
   </title>
      <para>
	Después de la instalación, aparte de la localización de las letras del teclado, que corresponden al español, no hallamos nada que nos lo recuerde porque no podemos escribir la eñe ni acentuar las vocales y todos los mensajes aparecen en inglés. Al que le guste hispanizar su Debian, no pierda tiempo y siga estas sencillas instrucciones.
      </para>
      <sect3>
	<title>
	  La consola
	</title>
	<para>
	  Si hemos realizado correctamente la instalación, habremos cargado el
	  juego de caracteres del teclado español que se encuentra en
	  /usr/share/keymaps/i386/qwerty/es.map.gz que se habrá almacenado
	  como /etc/console-tools/default.kmap.gz, para que en el arranque el
	  script /etc/init.d/ keymaps-lct.sh nos lo instale adecuadamente. Sin
	  embargo veremos que aunque cada letra está en su sitio del teclado,
	  no visualizamos ni la ñ ni las vocales acentuadas. Para conseguir
	  esto para todos los usuarios de la máquina editamos el fichero
	  /etc/inputrc y descomentamos la línea set convert-meta off, de
	  manera que quede así:
	</para>
	<para>
	  
	</para>
	<para>
	  -----------------------------------------------------------
	</para>
	<para>
	  # /etc/inputrc - global inputrc for libreadline
	</para>
	<para>
	  # See readline(3readline) and `info readline' for more information.
	</para>
	<para>
	  
	</para>
	<para>
	  #Be 8 bit clean.
	</para>
	<para>
	  set input-meta on
	</para>
	<para>
	  set output-meta on
	</para>
	<para>
	  
	</para>
	<para>
	  # To allow the use of 8bit-characters like the german umlauts, comment out
	</para>
	<para>
	  # the line below. However this makes the meta key not work as a meta key,
	</para>
	<para>
	  # which is annoying to those which don't need to type in 8-bit characters.
	</para>
	<para>
	  
	</para>
	<para>
	  set convert-meta off
	</para>
	<para>
	  -----------------------------------------------------------
	</para>
	<para>
	  Cuando iniciemos una nueva shell, veremos que ya aparecen las vocales acentuadas y la ñ.
	</para>
	<para>
	  La primera línea sin comentar del archivo, permite trabajar con 8 bits; la segunda que se conserve también a la salida del terminal (es decir, que cuando pulsamos &lt;ñ&gt; salga la ñ y no su valor numérico, y la tercera que no se conviertan como secuencias de escape.
	</para>
	<para>
     
	</para>
	<para>
	  Pero no todo funciona como debiera. Si hacéis por ejemplo (no necesariamente como root)
	</para>
	<para>
	  
	</para>
	<para>
	  mkdir cañón
	</para>
	<para>
	  
	</para>
	<para>
	  y hacéis luego
	</para>
	<para>
	  
	</para>
	<para>
	  ls -l 
	</para>
	<para>
	  vereis una línea
	</para>
	<para>
	  
	</para>
	<para>
	  drwxr-xr-x   2 gustavo  users        4096 Sep  5 15:16 ca??n
	</para>
	<para>
	  
	</para>
	<para>
	  Esto se debe a que el comando ls no trabaja con caracteres de 8 bits. Podemos parchearlo, pero la solución integral la veremos luego en el apartado Locales.
	</para>
	<para>
     
	</para>
	<para>
	  Otro problema aparece con vi y con less. Si montáis (como root) el CD1 de Debian 2.2 en /cdrom 
	</para>
	<para>
	  y hacéis
	</para>
	<para>
	  
	</para>
	<para>
	  vi /cdrom/install/dos/es/install.es.txt    (el documento de instalación en español)
	</para>
	<para>
	  
	</para>
	<para>
	  observareis que el título es:
	</para>
	<para>
	  
	</para>
	<para>
	  Instalación de Debian...
	</para>
	<para>
	  
	</para>
	<para>
	  en lugar de 
	</para>
	<para>
	  
	</para>
	<para>
	  Instalación de Debian...
	</para>
	<para>
	  
	</para>
	<para>
	  Si lo leéis usando el comando
	</para>
	<para>
	  
	</para>
	<para>
	  less   /cdrom/install/dos/es/install.es.txt
	</para>
	<para>
	  
	</para>
	<para>
	  aparecerá
	</para>
	<para>
     
	</para>
	<para>
	  Instalaci&lt;F3&gt;n de Debian...
	</para>
	<para>
	  
	</para>
	<para>
	  Esto también puede parchearse poniendo
	</para>
	<para>
	  
	</para>
	<para>
	  export LESSCHARSET=latin1 en /etc/profile, pero la solución la veremos en el epígrafe Locales.
	</para>
	<para>
	  
	</para>
	<para>
	  
	</para>
      </sect3>
      <sect3>
	<title>
	  X Window
	</title>
	<para>
     
	</para>
	<para>
	  Para asegurarnos de que se ha cargado el teclado español en las X miraremos en el fichero /etc/X11/XF86Config la sección Keyboard y nos aseguraremos que existen las líneas
	</para>
	<para>
	  
	</para>
	<para>
	  XkbModel        &quot;pc102&quot; y   
	</para>
	<para>
	  XkbLayout       &quot;es&quot;
	</para>
	<para>
	  
	</para>
	<para>
	  Si miramos en nuestro fichero de configuración
	</para>
	<para>
	  encontramos la sección :
	</para>
	<para>
	  Section &quot;Keyboard&quot;
	</para>
	<para>
	  Protocol        &quot;Standard&quot;
	</para>
	<para>
	  XkbRules        &quot;xfree86&quot;
	</para>
	<para>
	  XkbModel        &quot;pc102&quot;
	</para>
	<para>
	  XkbLayout       &quot;es&quot;
	</para>
	<para>
	  EndSection    
	</para>
	<para>
	  
	</para>
	<para>
	  y efectivamente, deben poder verse las vocales acentuadas y la  ñ. De todos modos, este método no es perfecto porque muchas aplicaciones bajo X Window  tienen su propia configuración o carecen de soporte para caracteres extendidos.
	</para>
	<para>
	  
	</para>
      </sect3>
      <sect3>
    <title>
	  Locales
	</title>
	<para>
	  Se conoce por 'Locales' a los rasgos culturales característicos de un país, como los caracteres especiales, la forma de representar la fecha, etc...En GNU/Linux cada proceso funciona en un determinado entorno que llamaremos LOCALE donde se establece como ha de comportarse cada proceso según las peculiaridades del idioma y país. 
	</para>
	<para>
	  
	</para>
	<para>
	  Si por ejemplo hacemos date, obtenemos
	</para>
	<para>
	  
	</para>
	<para>
	  date
	</para>
	<para>
	  Tue   Sep   5   15:07:31   CEST   2000
	</para>
	<para>
     
	</para>
	<para>
	  Luego el entorno LOCALE no es el nuestro, sino el americano (por defecto). Para poder usar nuestro entorno LOCALE, definiremos la variable de entorno LANG como:
	</para>
	<para>
	  
	</para>
	<para>
	  export LANG=es_XX 
	</para>
	<para>
	  
	</para>
	<para>
	  siendo XX=ES (español de España), MX (de México), CO (de Colombia) o AR (de Argentina). (En mi caso particular puse export LANG=es_ES)
	</para>
	<para>
	  
	</para>
	<para>
	  ahora obtenemos
	</para>
	<para>
	  
	</para>
	<para>
	  date
	</para>
	<para>
	  mar  sep  5  15:07:31   CEST   2000
	</para>
	<para>
	  
	</para>
	<para>
	  De repente, además ahora funciona adecuadamente el ls -l:
	</para>
	<para>
	  
	</para>
	<para>
	  drwxr-xr-x   2 gustavo  users        4096 Sep  5 15:16 cañón
	</para>
	<para>
	  
	</para>
	<para>
	  y también leemos correctamente los acentos y eñes con vi y less 
	</para>
	<para>
	  
	</para>
	<para>
	  por lo tanto, editaremos (como root) el fichero /etc/profile y haremos permanente la definición de la variable LANG. He ahí como queda.
	</para>
	<para>
     
	</para>
	<programlisting>
	  # /etc/profile: system-wide .profile file for the Bourne shell (sh(1))
	  # and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).
	  PATH="/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games"
	  if [ "$BASH" ]; then
	    PS1='\u@\h:\w\$ '
	  else
	    if [ "`id -u`" -eq 0 ]; then	  
	      PS1='# '
	    else
              PS1='$ '
	    fi
	  fi
	  export PATH PS1
	  #Españolización de Debian
	  export LANG=es_ES
	  umask 022
	</programlisting>
	<para>
	  De este modo, los mensajes de diversas aplicaciones (Lyx, Netscape...) las veremos en español. Para terminar, si vamos a usar Tex/Latex/LyX y queremos que las palabras se corten de acuerdo con nuestras reglas, no basta con tener el diccionario, sino que hemos de hacer como root
	</para>
	<para>
	  
	</para>
	<para>
	  texconfig
	</para>
	<para>
	  
	</para>
	<para>
	  luego escogemos HYPHEN y después latex (o pdflatex, etc; pues al hacerlo con uno, lo hacemos con todos ;-))
	</para>
	<para>
	  
	</para>
	<para>
	  entonces entramos en modo de edición vi y debemos descomentar 
	</para>
	<para>
     
	</para>
	<para>
	  % spanish
	</para>
	<para>
	  luego salimos del editor guardando (:wq) y ya está. Podemos hacer también un REHASH y largarnos.
	</para>
      </sect3>
    </sect2>
  </sect1>



  <sect1>
    <title>
      Personalización de nuestra Debian
    </title>
    <sect2>
      <title>
	Navegación, correo y noticias
      </title>
      <para>
	En Debian se incluyen varios navegadores. Uno de los más
	usados es Mozilla, que además incluye un programa para leer
	correo, un lector de noticias y un programa de charla. Otras
	opciones disponibles son Konqueror y Galeon.
      	Pero si ya tenemos algo de solera en linux, quizás optemos por
	procedimientos más genuinos. Para la navegación en consola el paquete
	lynx y su homófono <quote>links</quote> (algo mejor) son una
	delicia.
      </para>
      <para>
        Para la gestión del correo electrónico, recomiendo Evolution,
	muy en la línea de Outlook, pero sin agujeros de seguridad, Kmail o el
	gestor de correo de Mozilla.
        Para leer el correo desde la consola, mutt es la opción
	preferida, junto con el todopoderoso Emacs.
       </para>
       <para>
        Para las noticias, se puede usar Mozilla o emacs, aunque
	existen diversos programas excelentes como Knode o Pan. 
        Emacs es un <quote>entorno de trabajo</quote> que tiene
	integradas multitud de funcionalidades. Es conveniente pensar en
	instalar GPG y darle apoyo con mutt/slrn o emacs/gnus.
      </para>
    </sect2>
    <sect2 id="Gestores_Ventanas">
      <title>
	Gestores de ventana y Escritorios
      </title>
      <para>
	Quienes tengan una máquina potente, podrán ejecutar sin
	problemas los Escritorios Gnome 1.4+sawfish o KDE. Si tu
	equipo no tiene suficiente potencia, quizá debas prescindir
	del entorno de escritorio y ejecutar sólo un gestor de
	ventanas. Yo suelo usar GNUStep que es una implementación 
        libre del estándar OpenStep. Para los que tengan máquinas muy
        antiguas, FVWM o cualquiera de sus derivados puede ser una
	buena elección.
      </para>
      <para>
	Si alguno no quiere que arranque el xdm (X desktop manager) o 
        gdm (GNOME desktop manager) en el login puede desinstalarlo 
        con apt-get remove o simplemente quitarlo de los scripts de inicio.
      </para>
    </sect2>
    <sect2> 
      <title>
	Editores y entornos de desarrollo
      </title>
      <para>
	Existen multitud de editores, pero yo me quedo con aquellos 
        dos que más solera tienen en el mundo unix: vi (vim,
        elvis,...) y emacs (20). 
        Verdaderas torturas para los neófitos,  llegan a hacerse
        excelentes herramientas para las cuestiones fundamentales de 
        la edición. Vi es más ligero y menos complejo que emacs, pero 
        como ya he dicho emacs es en esencia un entorno de trabajo y
        desarrollo:podemos usarlo como editor de sgml/xml, como IDE 
        para diversos lenguajes, incluyendo emacs-lisp, etc..Con estos 
        editores podemos escribir documentos en LaTeX, xml, sgml...
      </para>
      <para>
        Para proyectos de programación más grandes, recomiendo
        eclipse, glade, kdevelop, etc...
      </para>
      <para>
	Disponemos de algunos front-ends como LyX que es un editor
        WYSIWYM (Lo que ves es lo que significa) fundamentalmente para 
        LateX y SGML. Exporta ficheros .tex que tratados luego
        adecuadamente y procesados con pdflatex genera documentación 
        en formato pdf. Los ficheros .sgml pueden convertirse en
        LateX, postscript, html...
      </para>
    </sect2>
    <sect2>
      <title>
	Ofimática
      </title>
      <para>
	Openoffice es una suite ofimática al nivel de otras
	comerciales.
        Otras opciones son Koffice, o Abiword,
      </para>
    </sect2>
    <sect2>
       <title>
	Visualizadores y procesadores de imágenes
      </title>
      <para>
	Para leer los archivos postscript necesitais gv (una mejora de
	ghostview) o ggv  que seguramente ya estará instalado. Para
	los ficheros pdf, debeis instalar el programa xpdf, o gpdf y 
        para el procesamiento de imágenes el excelente GIMP.
      </para>
    </sect2>
    
    <sect2 id="Seguridad">
      <title>
	Seguridad
      </title>
      <para>
	Cuando uno se conecta a internet en casa con una conexión
        INTERMITENTE (módem vía PPP) con asignación dinámica de IP no es 
        necesario llevar a cabo mucha labor de seguridad. Lo que debemos 
        hacer es deshabilitar todo servicio que con seguridad no vayamos 
        a dar. Por un lado eliminar los servicios de arranque directo que 
        se inician al arrancar el sistema excepto quizá postfix (no los 
        usareis jamás con conexión intermitente) y por otro los de arranque 
        bajo demanda en /etc/inet.conf (quitadlos todos, menos auth si
        disfrutais con el IRC). Si teneis una conexión permanente y un 
        número fijo de IP de máquina, entonces estais en la red y tendreis 
        que hacer un balance entre los servicios que pretendeis proporcionar 
        y la seguridad que deseais. Los servicios proporcionados en el 
        arranque debeis asociarlos con reglas de cortafuegos (tipo 
        filtrado de paquetes con iptables) y los de demanda los gestionareis 
        con tcp-wrapper (poniendo cuidado en los ficheros /etc/hosts.allow y 
        /etc/hosts.deny). Pero esto es otra historia que merece una atención 
        especial que no puedo dar aquí. Para ver los servicios que ofrece 
        vuestra máquina podeis hacer:
      </para>
      <programlisting>
	netstat -atu | grep '*:*' | more
      </programlisting>
      <para>
	y así os hareis una idea de ello.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>
      Apt-get para instalar y eliminar paquetes
    </title>
    <para>
      Aunque personalmente me gusta dselect, para la instalación y
desinstalación de paquetes, ya que usamos apt, podemos utilizar 
la utilidad apt-get: 
    </para>
    <programlisting>
      apt-get install paquete
    </programlisting>
    <para>
      que instala 'paqueteXXX.deb' como se encuentra en la base de
datos que ha hecho de los CDs. (o si se han descomentado algunas 
entradas en /etc/apt/sources.list, usando el sitio http o ftp de 
debian.org o una de sus réplicas, lo buscará en línea)
    </para>
    <programlisting>
      apt-get remove paquete
    </programlisting>
    <para>
      desinstala 'paqueteXXX.deb' del sistema. 
    </para>
    <para>
      Pero además podeis hacer 
    </para>
    <programlisting>
      apt-get upgrade
    </programlisting>
    <para>
      Para instalar las últimas versiones de los paquetes accesibles en /etc/apt/sources.list (cuya entrada debe contener un servidor ftp de debian.org)...Vamos, vamos, leeros el man apt-get.
    </para>
    Para buscar un paquete, se puede usar apt-cache, y pasarle como
    argumento, el nombre del paquete o la capacidad que necesitemos. 
    A continuación saldrá un listado con todos los paquetes
    relacionados.
    </para>
    <programlisting>
    apt-cache search  nombre_paquete
    </programlisting>
    <para>
     Podemos filtrar la lista de paquetes mediante grep si queremos
     reducir la lista a un paquete determinado o su descripción:
    </para>
  </sect1>

  <sect1 id="init">
    <title>
      Modificación de los scripts de inicio
    </title>
    <para>
      La orden update-rc.d actualiza automáticamente los enlaces de 
      los scripts de inicio (estilo System V) /etc/rcrunlevel.d/NNname
      a scripts /etc/init.d/name. Podemos utilizar dicho mandato para 
      instalar nuestros propios scripts de modo que se arranquen al 
      inicio o podemos usarlo para eliminar scripts que no queremos 
      que se ejecuten en el inicio.
    </para>
    <para>
      Para instalar scripts haremos:
    </para>
    <programlisting>
      update-rc.d nombre_del_script defaults 
    </programlisting>
    <para>
      Si usamos el modificador defaults, update-rc.d establecerá los 
      enlaces simbólicos para que se arranquen los servicios en los
      niveles de ejecución 2,3,4,5 y se paren en los niveles de
      ejecución 0,1,6. El script /etc/init.d/nombre_del_script tiene 
      que existir antes de que usemos el comando.
    </para>
    <para>
      Para eliminar scripts haremos
    </para>
    <programlisting>
      update-rc.d nombre_del_script -f remove
    </programlisting>
    <para>
     De este modo se rompen los enlaces simbólicos con el archivo 
     /etc/init.d/nombre_del_script. En teoría, el script
     nombre_del_script debe haber sido ya eliminado antes de ejecutar 
     el comando, pero con la opción -f, no es necesario haberlo
     quitado previamente. 
    </para>
  </sect1>

  <sect1 id="kernel">
    <title>
      Recompilar el núcleo
    </title>
    <para>
      Después de la instalación de Debian 3.0, disponemos de un núcleo 
      altamente modular que permite muchísimas posibilidades para 
      configurar el sistema a nuestro gusto (ya hemos visto la
      impresora y la tarjeta de sonido), pero hay algunas cosas que 
      implicarán recompilar el núcleo, como por ejemplo, usar una
      tarjeta IDE Raid, o actualizar a una versión posterior. En
      Debian existe un modo particular para la recompilación del
      núcleo, pero prefiero la forma tradicional que por supuesto 
      también funciona y es universal.
    </para>
    <para>
      Lo primero será conseguir las fuentes del nuevo kernel que queremos
      instalar. Si se trata de uno nuevo, que no está en los CDs habrá que
      buscar las fuentes en debian.org mediante apt-get install (con el sitio
      http o ftp de debian.org incluído en el archivo
      /etc/apt.sources.list). Si nos dice que <quote>Sorry,
      kernel-source-2.X.X is already the newest version</quote>, pues habrá
      que buscar con nuestro navegador habitual (lynx, links, Netscape) en
      www.kernel.org. Voy a considerar como ejemplo la recompilación de un
      kernel genérico 2.X.X para tenerlo a nuestra medida.
    </para>
    <programlisting>
      uname -a
      GNU/Linux debian 2.4.18 # Sun Jun 25 09:24:41 EST 2003 i686 unknown
    </programlisting>
    <para>
      Así corroboramos el núcleo que tenemos instalado es el 2.4.18. El lugar 
      predeterminiado para albergar al núcleo es en /usr/src/ (ó /usr/local/src/) 
      pero observamos que está vacío. Luego aunque lo tenemos compilado como 
      /boot/vmlinuz o /vmlinuz, no tenemos las fuentes en el sistema. Para ello habremos 
      de instalarlas mediante el archivo fuente kernel-source-2.X.X.tar.bz2 que 
      lo habremos conseguido en la red.
    </para>
    <programlisting>
      cp kernel-source-2.X.X.tar.bz2 /usr/src/
    </programlisting>
    <para>
      De este modo, nos aparecerán las fuentes del núcleo en /usr/src/kernel-source.2.2.17.tar.bz2. 
      Lo primero es descomprimir el núcleo, para ello, cambiamos al directorio donde hayamos guardado el 
      archivo de fuentes y haremos lo siguiente:
    </para>
    <programlisting>
      tar -jxf kernel-source-2.X.X.tar.bz2
    </programlisting>
    <para>
      (La opción -j es para descomprimir bz2 como la -z es para descomprimir gz)
    </para>
    <para>
      Luego hacemos cd kernel-source-2.X.X y comenzamos la compilación:
    </para>
    <programlisting>
      debian:/usr/src/kernel-source-2.2.17# make menuconfig
    </programlisting>
    <para>
      De este modo nos aparecerá en consola un panel en ncurses que debemos
      seleccionar adecuadamente. Hay que hacer notar que el núcleo que hemos
      descomprimido sólo tiene unas cuantas opciones auxiliares activadas por
      omisión, así que ¡cuidadín que no se olvide nada!. Podéis desactivar las
      que ya están (n), activarlas dentro del propio núcleo (y) ó bien
      como módulo (m), que os dará un núcleo compilado más ligero, pudiendo
      instalar los diferentes módulos cuando queramos (con modprobe, mejor que
      insmod) o con modconf, haciéndo que se carguen al arrancar. Sólamente
      algunas puntualizaciones referentes a los soportes que hay que activar
      (aparte de los que hay predeterminados) en los distintos apartados.
    </para>
    <sect2>
      <title>
	Loadable module support
      </title>
      <para>
	Enable loadable module support
      </para>
      <para>
	Kernel module loader (para que puedan cargarse automáticamente)
      </para>
    </sect2>
    <sect2>
      <title>
	General setup
      </title>
      <para>
	Parallel port support
      </para>
      <para>
	PC-style hardware
      </para>
    </sect2>
    <sect2>
      <title>
	Block devices
      </title>
      <para>
	Déjalos tal cual excepto si vas a recompilar el kernel para hacer funcionar tugrabadora IDE con emulación SCSI. Para ello, desactiva
      </para>
      <para>
	Include IDE/ATAPI CDROM support
      </para>
      <para>
	y activa:
      </para>
      <para>
	SCSI Emulation support
      </para>
      <para>
	loopback device support
      </para>
    </sect2>
    <sect2>
      <title>
	Network options
      </title>
      <para>
	Aparte de las predeterminadas, y si quieres utilizar filtros de paquetes para aumentar la seguridad de tu sistema, activa:
      </para>
      <para>
	Network firewalls
      </para>
      <para>
	IP firewalling
      </para>
    </sect2>
    <sect2>
      <title>
	SCSI support
      </title>
      <para>
	En el caso de que tengas algún dispositico scsi o si has hecho emulación para una grabadora ide, debes activar
      </para>
      <para>
	SCSI support
      </para>
      <para>
	SCSI CDROM support
      </para>
      <para>
	SCSI generic support
      </para>
    </sect2>
    <sect2>
      <title>
	Network device support
      </title>
      <para>
	Si la conexión es intermitente via módem, activa
      </para>
      <para>
	PPP support
      </para>
      <para>
	y si estás conectado a la red directamente mediante una tarjeta, busca los controladores para ella. Seguramente será una ethernet, así que estará en el menú Ethernet (10 o 100 MB)
      </para>
    </sect2>
    <sect2>
      <title>
	Character devices
      </title>
      <para>
	Parallel print support
      </para>
      <para>
	Support IEEE 1284 status readback 
      </para>
      <para>
	(con ello podremos volcar archivos a la impresora cat archivo &gt; /dev/lp0). Luego buscar en Mouse support para seleccionar el tipo de ratón si no está por defecto.
      </para>
    </sect2>
    <sect2>
      <title>
	Filesystem
      </title>
      <para>
	activa las opciones auxiliares siguientes:
      </para>
      <para>
	DOS FAT fs support
      </para>
      <para>
	VFAT (Windows 95) fs support
      </para>
      <para>
	y si vas a usar una grabadora para CD, sería conveniente
      </para>
      <para>
	Microsoft Joliet CDROM extension
      </para>
      <para>
	Luego, dentro del submenú Network filesystem, activar NFS y SMB (Samba si los vais a utilizar), y dentro del submenú Native language support, hay una serie de opciones que habrá que activar:
      </para>
      <para>
	Codepage 437 (United States, Canadá)
      </para>
      <para>
	Codepage 850 (Europe)
      </para>
      <para>
	NLS ISO 8859-1 (latin1)
      </para>
    </sect2>
    <sect2>
      <title>
	Sound card support
      </title>
      <para>
	Ante la variedad de tarjetas, aquí no hay regla fija. Para mi SoundBlaster16, tengo que activar
      </para>
      <para>
	Sound Card Support
      </para>
      <para>
	Persistent DMA Buffer
      </para>
      <para>
	OSS sound modules
      </para>
      <para>
	100% SB Compatibility
      </para>
      <para>
	Yamaha OPL3 audio controller
      </para>
      <para>
	FM Synthesizer (YM3812/OPL-3) support
      </para>
      <para>
	Hay otros botones que se pueden seleccionar, cada uno tiene un equipo particular y puede usar dispositivod por rayos infrarrojos, ISDN, ver la tele con linux, tener un scanner (compatible),...
      </para>
      <para>
	Ahora nos vamos al menú principal y allí hacemos seleccionamos el botón Save and Exit, con lo cual volveremos a nuestra terminal y allí haremos:
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    debian:/usr/src/kernel-source-2.X.X# make dep
	  </para>
	</listitem>
	<listitem>
	  <para>
	    debian:/usr/src/kernel-source-2.X.X# make clean
	  </para>
	</listitem>
	<listitem>
	  <para>
	    debian:/usr/src/kernel-source-2.X.X# make bzImage
	  </para>
	</listitem>
	<listitem>
	  <para>
	    debian:/usr/src/kernel-source-2.X.X# make modules
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Ahora se habrán creado los diversos módulos cargables para el núcleo bzImage que acabamos de recompilar. Cuando hagamos make modules_install, éstos se instalarán en el directorio /lib/modules/2.X,X pero en el caso de que estuvieramos recompilando la misma versión del núcleo, los módulos del núcleo actual y los del acabado de recompilar irían aparar al mismo directorio, /lib/modules/2.X.X, produciéndose una mezcla de los módulos de ambos núcleos (que compilados tendrán soportes diferentes) y que producirán problemas tipo ...unresolver symbol... en el arranque. Por lo tanto, en tal caso, antes de instalarlos, debemos renombrar el directorio que contendrá los módulos de la siguiente manera:
      </para>
      <para>
	mv /lib/modules/2.X.X /lib/modules/2.X.X-old
      </para>
      <para>
	y entonces podremos hacer tranquilos 
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    debian:/usr/src/kernel-source-2.X.X# make modules_install
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	con lo cual se creará el directorio nuevo /lib/modules/2.X.X con los módulos correspondientes a nuestra selección.
      </para>
      <para>
	Ahora algunos hacen make bzlilo para actualizar, pero yo prefiero ser cauteloso, guardar las opciones antiguas por prudencia y además hacerlo todo a mano. Vamos a sustituir la imagen actual del núcleo que estamos usando por el recién compilado. La imagen nueva se llama bzImage y es el archivo (con todo el path): /usr/src/arch/i386/boot/bzImage. La actual es /vmlinuz. Vamos a renombrarlos:
      </para>
      <para>
	mv /vmlinuz /vmlinuz-old
      </para>
      <para>
	cp /usr/src/arch/i386/boot/bzImage /vmlinuz
      </para>
      <para>
	Ahora cuidadín: Si nuestro archivo /etc/lilo.conf contenía:
      </para>
      <programlisting>
	# Generated by liloconfig
	# Specifies the boot device
	boot=/dev/hdc3
	# Specifies the device that should be mounted as root.
	root=/dev/hdc3
	# Install the specified file as the new boot sector.
	# If INSTALL is omitted, /boot/boot.b is used as the default.
	install=/boot/boot.b
	# Specifies the number of _tenths_ of a second LILO should
	# wait before booting the first image. LILO
	# doesn't wait if DELAY is omitted or if DELAY is set to zero.
	delay=20
	# Specifies the location of the map file. If MAP is
	# omitted, a file /boot/map is used.
	        map=/boot/map
	# Specifies the VGA text mode that should be selected when
	# booting. 
	vga=normal	
	#Imagen del núcleo
	image=/vmlinuz
	        label=GNU/Linux
	        read-only
      </programlisting>
      <para>
	Nosotros debemos transformarlo como sigue:
      </para>
      <programlisting>
	# Generated by liloconfig
	# Specifies the boot device
	boot=/dev/hdc3
	# Specifies the device that should be mounted as root.
	root=/dev/hdc3
	# Install the specified file as the new boot sector.
	# If INSTALL is omitted, /boot/boot.b is used as the default.
	install=/boot/boot.b
	prompt
	timeout=200
	# Specifies the location of the map file. If MAP is
	# omitted, a file /boot/map is used.
	map=/boot/map
	# Specifies the VGA text mode that should be selected when
	# booting. 
	vga=normal
	#imagen del kernel nuevo
	image=/vmlinuz
	        label=GNU/Linux
	        read-only
	#imagen del kernel anterior 
	image=/vmlinuz-old
	        label=old
	        read-only
      </programlisting>
      <para>
	Hay algunos cambios: En lugar de delay tenemos la instrucción prompt, para que podamos seleccionar la etiqueta de la imagen que queramos cargar: GNU/Linux o old. El mandato timeout=200 mantiene el prompt 20 segundos (200 décimas) y si no se introduce nada, acabado el tiempo se cargará la primera imagen listada (Label: GNU/Linux). A continuación se ponen las líneas correspondientes a la carga de las dos imágenes.
      </para>
      <para>
	De este modo si al cargar el nuevo núcleo ocurriera algo desastroso, siempre podríamos volver a cargar el antiguo y resolver el problema. Pero ¡Todavía no está todo acabado!: Hay que ejecutar 
      </para>
      <para>
	/sbin/lilo -v
      </para>
      <para>
	para reinstalar el cargador de arranque y remapee la posición del
	disco duro en la que se sitúa el nuevo núcleo. Si no, el sistema no
	podría reiniciarse: nos aparecería en el arranque el temido
	<quote>LI</quote> y lo tendríamos que resolver iniciando mediante un
	disco de arranque y luego ejecutando /sbin/lilo (-v es solo para que
	nos de información de lo que está haciendo). Una vez que todo ha sido
	hecho según los cánones, reiniciaremos el ordenador.
      </para>
      <para>
	Los ficheros objeto que se generan durante la compilación del kernel se pueden borrar haciendo
      </para>
      <para>
	debian:/usr/src/kernel-source-2.X.X# make clean
      </para>
      <para>
	pero no es aconsejable, porque si queremos cambiar algo en el futuro de la configuración del kernel es conveniente partir de las opciones actuales. Así al hacer en otra ocasión
      </para>
      <para>
	debian:/usr/src/kernel-source-2.X.X# make xconfig
      </para>
      <para>
	después de realizar los cambios de configuración y salir con Save and Exit, no es necesario hacer make dep; make clean, sino empezar directamente por make bzImage.
      </para>
    </sect2>
  </sect1>


  <sect1 id="Grabadoras">
    <title>
      Grabación de CDs con grabadoras IDE
    </title>
    <para>
      Si tenemos una grabadora de CD IDE/ATAPI los programas para grabar como cdrecord no la reconocerán como unidad normal de cdrom, pues sólo reconocen las grabadoras tipo SCSI. Por lo tanto hemos de llevar a cabo una emulación IDE-SCSI en nuestra grabadora. Antaño, para conseguir nuestro objetivo había que recompilar el núcleo (véase <xref linkend="kernel"/>) del siguiente modo:
    </para>
    <orderedlist>
      <listitem>
	<para>
	  Quitar el soporte para IDE-ATAPI CDROM (Block devices)
	</para>
      </listitem>
      <listitem>
	<para>
	  Activar la emulación SCSI (Block devices)
	</para>
      </listitem>
      <listitem>
	<para>
	  Incluir SCSI support, generic support y CDROM support (SCSI support) 
	</para>
      </listitem>
      <listitem>
	<para>
	  Activar Loopback device support (Block devices)
	</para>
      </listitem>
      <listitem>
	<para>
	  Si se tiene pensado hacer imágenes Joliet, habrá que activar
	  el soporte para Microsoft Joliet CDROM extension
	  (Filesystems) y dentro del submenú Native language support, 
          activar Codepage 437, Codepage 850 y NLS ISO 8859-1
	</para>
      </listitem>
    </orderedlist>
    <para>
      Debian 3.0 cuenta con soporte para emulación SCSI con sólo
      cargar el módulo ide-scsi, pero antes hay que especificar en el
      arranque en qué interfaz IDE se debe cargar posteriormente la 
      emulación SCSI.
      La manera más sencilla es incluir en el fichero /etc/lilo.conf
      una línea después de las especificaciones de la imagen del núcleo a cargar que sea:
    </para>
    <programlisting>
      append="/dev/hda-d=ide-scsi"
    </programlisting>
    <para>
      En mi caso dispongo de un lector CDROM en /dev/hdd (esclavo del
      segundo canal IDE) y una grabadora CDROM en /dev/hdb (esclava
      del primer canal IDE), con lo cual el fichero /etc/lilo.conf adecuado para la emulación será:
    </para>
    <programlisting>
      boot=/dev/hdc3
      root=/dev/hdc3
      install=/boot/boot.b
      delay=20
      map=/boot/map
      vga=normal
      image=/vmlinuz
              label=GNU/Linux
              read-only
              append="hdb=ide-scsi"
    </programlisting>
    <para>
      Una vez arrancado el núcleo con esta opción pasada en el
      arranque podremos usar como root la utilidad modconf para
      seleccionar el módulo ide-scsi y cargarlo. 
    </para>
    <para>
      Inmediatamente se crea una serie de dispositivos
      <quote>virtuales</quote> para usar la grabadora como lector de CDROM: Si
      hacemos ls /dev/sr* vemos que se han creado desde /dev/sr0 hasta
      /dev/sr7. Nos harán falta también los dispositivos genéricos SCSI
      /dev/sgX que son los que utiliza el programa cdrecord y también
      necesitamos los ficheros especiales /dev/loopX para poder montar
      imágenes iso en un directorio. Al comprobarlo mediante ls /dev/loop*
      veremos que se han creado desde /dev/loop0 a /dev/loop7. De este modo
      podemos montar imágenes para revisarlas en un directorio (p.ej.)
      /mnt/imagenesCD:
    </para>
    <para>
      mount -o loop -t iso9660 imagenCD.iso /mnt/imagenCD
    </para>
    <para>
      Podemos comprobar que nuestra grabadora está reconocida como SCSI viendo el resultado de cat /proc/scsi/scsi
    </para>
    <sect2>
      <title>
	Configuración de Xcdroast 0.96e
      </title>
      <para>
	Hay dos programas esenciales para grabar CDs: mkisofs (permite hacer imágenes
	de CD en iso9660 raw) y cdrecord (para efectuar la grabación
	de CD) ambas funcionan desde la línea de órdenes. Xcdroast es
	una interfaz gráfica para la grabación de CDs que seguro
	resulta más fácil de usar.
      </para>
      <para>
	Lo instalaremos mediante
      </para>
      <para>
	apt-get install xcdroast
      </para>
      <para>
	y veremos que además de dicho paquete se instalan además:
        cdparanoia, libcdparanoia0, tix41, cdrecord y mkisofs.
        Para configurar xcdroast, iniciamos las X, abrimos una xterm e
        invocamos:
        <programlisting>
        [root@doomslayer]# xcdroast &
        </programlisting>
        Ahora sale una ventana indicando que no existe el fichero de
        configuración  (xcdroast.conf), por lo que es necesario hacer
        la configuración pertinente. Pulsamos Aceptar y aparece la
        tradicional renuncia de responsabilidades etc...
        Después de aceptar, pulsamos sobre el botón «configurar». 
        Aparece entonces el panel de configuración con 4 solapas: CDSETUP, HDSETUP, MISC y DEFAULTS.
      </para>
      <para>
	CDSETUP: Hay que configurar los dispositivos de lectura y escritura, que en nuestro caso, tal como hemos realizado la simulación SCSI, corresponderán al mismo elemento: la grabadora de CD. En mi caso tengo una antigua Memorex CRW-1622 que funciona de maravilla. Por lo tanto, en el bloque CD-WRITER seleccionamos: 
      </para>
      <variablelist>
	<varlistentry>
	  <term>
	    CDWriterDevice:
	  </term><listitem><para>Memorex CRW-1622
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>
	    CDWriterMode:
	  </term><listitem><para>Autodetected
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>
	    CDWriterSpeed:
	  </term><listitem><para>2x
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
      <para>
	y en el bloque CD-READER, escogemos:
      </para>
      <variablelist>
	<varlistentry>
	  <term>
	    CDReadDevice:
	  </term><listitem><para>Memorex CDW-1622
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>
	    AudioReadDevice:
	  </term><listitem><para>Memorex CDW-1622
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>
	    AudioReadMode:
	  </term><listitem><para>ATAPI
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>
	    AudioReadSpeed:
	  </term><listitem><para>Default
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
      <para>
	
      </para>
      <para>
	HDSETUP: Lo mejor a mi modo de ver es no configurar ni Image
        Partition 1 ni Image Partition 2, sino seleccionar el último 
        bloque como predeterminado e indicar en Image-Data-Path la 
        ruta del fichero donde se guardará la imagen del CD que 
        generemos en el proceso de creación o copia de CD. Yo 
        uso el directorio /usr/cdrecord. 
        NOTA: Debéis tener al menos unos 650 MB libres para almacenar la imagen. 
      </para>
      <para>
	MISC: Dejar las opciones por omisión excepto DPS-Device for audio, que seleccionaremos a /dev/dsp
      </para>
      <para>
	DEFAULTS: En principio lo podemos dejar así.
      </para>
      <para>
	Por último accionamos el botón save para guardar la
        configuración y luego pulsamos done, con lo cual volvemos 
        al panel de presentación pero ahora tiene activos los botones 
        CopyDataCD, CopyAudioCD y MasterCD.
      </para>
      
      <para>
	Si hacemos ahora lsmod veremos que además de haberse cargado el módulo ide-scsi, también se ha cargado automáticamente el módulo sg (dispositivo genérico SCSI) cuando ha hecho falta. Si hacemos ls /dev/sg* nos aparecen 8 dispositivos genéricos desde /dev/sg0 a /dev/sg7, y si hacemos ls /dev/loop* también nos aparecen 8 dispositivos desde /dev/loop0 a /dev/loop7.
      </para>
    </sect2>
    <sect2>
      <title>
	Copiando CDs con Xcdroast 0.96e
      </title>
      <para>
	Basta con activar el botón CopyDataCD o CopyAudioCD para poder realizar la copia. Metemos el CD que queremos copiar en la grabadora y activamos el botón correspondiente. Aparece un menú muy intuitivo que permitirá copiar la imagen del CD de datos o los tracks seleccionados del CD de audio en el directorio de almacenamiento (en mi caso /usr/cdrecord). La verificamos si queremos y luego expulsamos el CD y lo sustituimos por uno virgen. Entonces grabamos la imágen o los tracks de audio en él, lo verificamos si nos apetece y si está bien, borramos la imagen ó los tracks del directorio para liberar disco.
      </para>
    </sect2>
    <sect2>
      <title>
	Compilando CDs con Xcdroast 0.96e
      </title>
      <para>
	La compilación de CDs es sencilla. Previamente debemos tener un directorio en donde se encuentre ya dispuesta la estructura de directorios y ficheros que queremos grabar. Introducimos el CD virgen en la grabadora y accionamos el botón MasterCD. Aparece un menú también muy intuitivo que iremos explicando: En Master From/To hay que poner el directorio donde tenemos la estructura de archivos a compilar. Puede estar incluso en otra partición montada (p.ej. /mnt/win98/mastercd). En Set Image Type, es bueno seleccionar el tipo de imagen a Unix Rock Ridge + Win95/NT, pues así crearemos un CD que puede leerse bien en GNU/Linux y Windows. En Set ISO header, rellenamos los datos que queremos que aparezcan en la etiqueta del CD (volume-CD), y en los otros registros (opcional). Después pasamos a crear la imagen y luego grabarla en el CD, accionando los botones correspondientes. Con Xcdroast, tanto la compilación como la grabación se realizan perfectamente, no teniendo que envidiar en eficacia al EasyCD Creator o al Nero Burning para Windows.
      </para>
      <para>
	NOTA: Cuando no nos interese la emulación SCSI, comentamos la línea
	'append=&quot;hdb=ide-scsi&quot; ' en /etc/lilo.conf y al arrancar de
	nuevo, nuestra grabadora volverá a ser IDE. Por esta razón no se hace
	cargar el módulo ide-scsi automáticamente en el núcleo con modconf,
	sino que lo hacemos manualmente con modprobe cuando hayamos pasado a
	LILO el parámetro de emulación.
      </para>
    </sect2>
  </sect1>
  
  
</article>
