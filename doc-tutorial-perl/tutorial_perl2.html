<HEAD>
<TITLE>Tutorial de Perl, Capitulo Segundo</TITLE>
<Tutorial escrito por Daniel Sol Llaven :) >
</HEAD>
<BODY>
<center><H1>Proyecto de Tutorial de Perl </H1>

<H2><a href="http://lince.dgsca.unam.mx:8080/zgate/lacertus/hola">
Daniel Sol Llaven. 
</a></H2>

<H2>Viernes 18 de Abril de 1997</H2>
<HR>

<H1>Tabla de contenidos del segundo capitulo:</H1><P></center>
<HR>


<BLOCKQUOTE>
<H1><A HREF="#2">2- Programaci&oacute;n B&aacute;sica</A></H1>
<BLOCKQUOTE><A HREF="#2.1"><A HREF="#2.1">2.1- Estructura B&aacute;sica de un programa, programa Hola Mundo</A>
</A><P>
<H2><A HREF="#2.2">2.2- Estructuras de datos b&aacute;sicas</A></H2><BR>
<BLOCKQUOTE><H3><A HREF="#2.2.1">2.2.1- Clases de Datos</A></H3><BR>
<BLOCKQUOTE><H4><A HREF="#2.2.1.1">2.2.1.1- Escalares</A></H4><BR>
<A HREF="#2.2.1.2">2.2.1.2- Arreglos</A><BR>
<H4><A HREF="#2.2.1.3">2.2.1.3- Hash o Arreglos asociativos</A></H4><BR>
<H4><A HREF="#2.2.1.4">2.2.1.4- Equivalencias de Clases</A></H4><BR></BLOCKQUOTE>
<H3><A HREF="#2.2.3">2.2.3- Tipos especiales de Datos</A></H3><BR>
<BLOCKQUOTE><H4><A HREF="#2.2.3.1">2.2.3.1- Referencias</A></H4><BR>
<BLOCKQUOTE><H5><A HREF="#2.2.3.1.1">2.2.3.1.1- Creaci&oacute;n</A></H5><BR>
<H5><A HREF="#2.2.3.1.2">2.2.3.1.2- Uso</A></H5><BR></BLOCKQUOTE>
<H4><A HREF="#2.2.3.2">2.2.3.2- Archivos</A></H4><BR>
<BLOCKQUOTE><H5><A HREF="#2.2.3.2.1">2.2.3.2.1- Apertura</A></H5><BR>
<H5><A HREF="#2.2.3.2.2">2.2.3.2.2- Uso y Cerrado</A></H5><BR></BLOCKQUOTE>
</BLOCKQUOTE></BLOCKQUOTE>
<H2><A HREF="#2.3">2.3- Operaciones B&aacute;sicas</A></H2><BR>
<BLOCKQUOTE><H3><A HREF="#2.3.1">2.3.1- Aritm&eacute;ticas</A></H3><BR>
<H3><A HREF="#2.3.2">2.3.2- L&oacute;gicas</A></H3><BR>
<H3><A HREF="#2.3.3>2.3.3- Con Cadenas</A></H3><BR>
<H3><A HREF="#2.3.4">2.3.4- Con Expresiones Regulares</A></H3><BR>
<H3><A HREF="#2.3.5">2.3.5- Miscel&aacute;neas</A></H3><BR></BLOCKQUOTE>
<H2><A HREF="#2.4">2.4- Estructuras de Control</A></H2><BR>
<BLOCKQUOTE><H3><A HREF="#2.4.1">2.4.1- Manejo de Subrutinas</A></H3><BR></BLOCKQUOTE>
<H2><A HREF="#2.5">2.5- Operaciones con Archivos</A></H2><BR>
<BLOCKQUOTE><H3><A HREF="#2.5.1">2.5.1- Apertura y Cerrado</A></H3><BR>
<H3><A HREF="#2.5.2">2.5.2- Lectura de Datos</A></H3><BR>
<H3><A HREF="#2.5.3">2.5.3- Escritura</A></H3><BR>
<H3><A HREF="#2.5.4">2.5.4- Saltos y Proceso binario</A></H3><BR></BLOCKQUOTE>
<H2><A HREF="#2.6">2.6- Operaciones con Recursos del sistema</A></H2><BR>
<BLOCKQUOTE><H3><A HREF="#2.6.1">2.6.1- Como expresiones</A></H3><BR>
<H3><A HREF="#2.6.2">2.6.2- Sin interrelaciones</A></H3><BR>
<H3><A HREF="#2.6.3">2.6.3- Entubados</A></H3><P>
</BLOCKQUOTE></BLOCKQUOTE></BLOCKQUOTE>
<HR>
<blockquote>
<A NAME="2"><H1>2- Programaci&oacute;n b&aacute;sica</H1></A>
</blockquote>
<P>

En este capitulo daremos una r&aacute;pida revisi&oacute;n a los
conceptos mas usuales que se encuentran en un programa en Perl,
trataremos de ver la implementaci&oacute;n para ambas versiones
4 y 5 cuando sea posible, especificando siempre en que versi&oacute;n
esta el ejemplo original (dando preferencia a la versi&oacute;n
5) y al menos las alternativas para implementarlo en la otra versi&oacute;n.
<P>
Los ejemplo requerir&aacute;n para funcionar, que se tenga Perl
instalado en la maquina en que se practique y deber&aacute; conocerse
la ruta completa al binario de Perl.
<P>
Mas que sentirse en libertad de experimentar con los diversos
ejemplos, deben sentirse obligados a experimentar, modificar y
explorar por su cuenta cada que sea posible, tomando los ejemplo
solo como un punto seguro de partida. Para este fin, recomiendo
que se tenga acceso desde el inicio a alguna referencia del lenguaje
(ya sea el libro Programming Perl (del Camello) de la Nutshell
o alguna referencia disponible por WWW), este documento pretende
explicar lo b&aacute;sico de un modo accesible para que despu&eacute;s
pueda el nuevo programador de Perl abordar sin temor los materiales
mas detallados.
<blockquote><blockquote>
<A NAME="2.1">
<H2>2.1- Estructura B&aacute;sica de un programa, programa Holamundo.</H2>
</A>
</blockquote></blockquote>
<P>
Como se menciona en la introducci&oacute;n, Perl no obliga a casi
nada, as&iacute; pues, lo que planteo como estructura b&aacute;sica
es mas bien una convenci&oacute;n que un requisito del lenguaje,
a diferencia de Pascal (por ejemplo) Perl no tiene una plantilla
para sus programas y si se adoptan algunos protocolos es solo
por comodidad.
<P>
Los programas de Perl, por lo regular, inician con la l&iacute;nea:
<PRE>
<B>#!/usr/bin/perl</B>
</PRE>

<P>
Esta l&iacute;nea, indica al SO que lo que sigue es un script
de Perl, y que &quot;Perl&quot; (el programa con el cual debe
ejecutarse) esta en el directorio &quot;/usr/bin&quot;, la secuencia
&quot;#!&quot; es una secuencia que UNIX reconoce, no Perl.
<P>
Un m&eacute;todo alterno, que funciona para otras plataformas,
es: en lugar de colocar esa primera l&iacute;nea ejecutamos:
<PRE>
<B>Perl nombre_del_script.pl </B>
</PRE>

<P>
de modo que directamente se ejecuta el interprete de Perl pas&aacute;ndole
como primer par&aacute;metro el script a ejecutar (los dem&aacute;s
par&aacute;metros se tomaran como par&aacute;metros al programa).
Si se requiere deber&aacute; sustituirse &quot;Perl&quot; por
la ruta completa del programa y el nombre que el programa tenga.
<P>
Para los ejemplos sucesivos, tomare la suposici&oacute;n de que
se trabaja en un sistema UNIX con el interprete de Perl en el
directorio &quot;/usr/bin&quot;.
<P>
Y eso es toda la estructura b&aacute;sica!.
<P>
Programa Hola mundo:
<PRE>
<B>#!/usr/bin/perl
print &quot;Hola Mundo\n&quot;; #Saluda
#Programa Hola Mundo, Daniel Sol Llaven, 1996, como parte del tutorial de Perl</B>
</PRE>

<P>
Este programa, se escribe como un archivo de texto com&uacute;n,
(al que recomiendo se le ponga extensi&oacute;n &quot;.pl&quot;)
y se cambian sus permisos para que pueda ser ejecutado (por lo
regular con un &quot;chmod 700 nombre_programa.pl&quot; en sistemas
UNIX), para ejecutarlo simplemente se invoca el nuevo script &quot;nombre_programa.pl&quot;,
hay que recordar que para el sistema particular en que se este
trabajando es muy probable que deba modificarse &quot;/usr/bin/&quot;
por otra ruta.
<P>
As&iacute;, la ejecuci&oacute;n en un sistema UNIX podr&iacute;a
verse como:
<PRE>
<I>&gt;chmod 700 Hola.pl
&gt;Hola.pl
Hola Mundo
&gt;Hola.pl
Hola Mundo
&gt;</I>
</PRE>

<P>
Ejecutando dos veces el script pretendo mostrar que no es necesario
cambiar el modo de ejecuci&oacute;n del script sino solo una vez.
<P>
Expliquemos las tres l&iacute;neas que constituyen nuestro primer
script:
<PRE>
<B>#!/usr/bin/perl</B>
</PRE>

<P>
Esta l&iacute;nea, propiamente dicho, no es parte del script de
Perl, sino una instrucci&oacute;n al SO para indicar que las siguientes
l&iacute;neas deber&aacute;n interpretarse por el programa &quot;/usr/bin/Perl&quot;,
si se omite, o no funciona en el sistema operativo, podemos ejecutar
el programa de la siguiente forma:
<PRE>
<I>&gt;/usr/bin/Perl Hola.pl
Hola Mundo
&gt;</I><B>print &quot;Hola Mundo\n&quot;; #Saluda</B>
</PRE>

<P>
Esta es la &uacute;nica instrucci&oacute;n del programa y esta
acompa&ntilde;ada por un comentario, la instrucci&oacute;n es:
<PRE>
<B>print &quot;Hola Mundo\n&quot;;</B>
</PRE>

<P>
que pudo ser escrita como:
<PRE>
<B>print(&quot;Hola Mundo\n&quot;);</B>
</PRE>

<P>
sin que esto implicara el m&iacute;nimo cambio en funcionalidad.
<P>
a continuaci&oacute;n tiene el comentario:
<PRE>
<B>#Saluda</B>
</PRE>

<P>
La sintaxis de C para comentarios no funciona en Perl, pues se
usa a &quot;/&quot; para expresiones regulares.
<PRE>
<B>#Programa Hola Mundo, Daniel Sol Llaven, 1996, como parte del tutorial de Perl</B>
</PRE>

<P>
Esta l&iacute;nea es otro comentario, el SO y Perl consideran
todo lo que este en una l&iacute;nea que inicie con &quot;#&quot;
como comentario. (excepto en el caso de que sea una primera l&iacute;nea,
el SO lo interpreta como la indicaci&oacute;n del interprete,
pero Perl lo ignora como a cualquier otro comentario).
<blockquote><blockquote>
<A NAME="2.2"><H2>2.2- Estructuras de Datos B&aacute;sicas</H2></A>
</blockquote></blockquote>
<P>
En nuestro programa Hola.pl no utilizamos ninguna variable, por
lo que para explicar estos conceptos necesitaremos un nuevo programa,
HolaP.pl que es una versi&oacute;n personalizada de Hola.pl.
<PRE>
<B>#!/usr/bin/perl
#Programa Hola Mundo personalizado, Daniel Sol Llaven 1996, Tutorial Perl.
print &quot;Hola ?como te llamas?:&quot;;
$nombre=&lt;STDIN&gt;;
chop($nombre);
print &quot;$nombre!, bonito nombre, cuantos a&ntilde;os tienes?:&quot;;
$edad=&lt;STDIN&gt;;
print &quot;sabias que te faltan &quot;.(100-$edad).&quot; para tener 100?\nAdios!\n&quot;;</B>
</PRE>

<P>
Su ejecuci&oacute;n genera resultados similares a los siguientes:
<PRE>
<I>&gt;HolaP.pl
Hola ?como te llamas?:Daniel
Daniel!, bonito nombre, cuantos a&ntilde;os tienes?:22
sabias que te faltan 78 para tener 100?
Adi&oacute;s!
&gt;</I>
</PRE>

<P>
En este programa, aparecen muchos elementos novedosos que iremos
revisando poco a poco a lo largo de este documento, por el momento,
revisemos que hace l&iacute;nea por l&iacute;nea:
<PRE>
<B>#!/usr/bin/perl
#Programa Hola Mundo personalizado, Daniel Sol Llaven 1996, Tutorial Perl.</B>
</PRE>

<P>
Cabecera normal del programa, incluido comentario indispensable.
<PRE>
<B>print &quot;Hola ?como te llamas?:&quot;;</B>
</PRE>

<P>
Esta l&iacute;nea escribe &quot;Hola ?como te llamas?:&quot; pero
n&oacute;tese que no escribe una vuelta de carro al final (omite
el <TT><B>&quot;\n&quot;</B></TT>).
<PRE>
<B>$nombre=&lt;STDIN&gt;;</B>
</PRE>

<P>
Aqu&iacute; asignamos a <TT><B>$nombre</B></TT> un rengl&oacute;n
escrito por la entrada est&aacute;ndar del programa.
<P>
Perl define al &quot;archivo&quot; <TT><B>STDIN</B></TT> como
su entrada est&aacute;ndar, y el operador <TT><B>&lt;&gt;</B></TT>
que indica la lectura de una l&iacute;nea de un archivo de texto,
de modo que <TT><B>&lt;STDIN&gt;</B></TT> indica la lectura de
un rengl&oacute;n de la entrada est&aacute;ndar (al menos para
el ejemplo!), este tema se tratara con cuidado en la secci&oacute;n
2.5 y 3.3 de este documento que tratan de operaciones con archivos.
<P>
Para fines pr&aacute;cticos, usaremos <TT><B>&lt;STDIN&gt;</B></TT>
como la expresi&oacute;n que lee una l&iacute;nea de entrada del
usuario desde teclado.
<PRE>
<B>chop($nombre);</B>
</PRE>

<P>
Perl, al leer la l&iacute;nea escrita por el usuario, tambi&eacute;n
toma el enter que el usuario da, de modo que en el ejemplo, la
entrada que di en vez de ser <TT><B>&quot;Daniel&quot;</B></TT>
se puede escribir como <TT><B>&quot;Daniel\n&quot;</B></TT>, (siendo
&quot;<TT><B>\n</B></TT>&quot; el car&aacute;cter de vuelta de
carro), la funci&oacute;n &quot;<TT><B>chop()</B></TT>&quot; tiene
la funci&oacute;n de eliminar el ultimo car&aacute;cter a nuestra
cadena, de modo que despu&eacute;s de esta instrucci&oacute;n
<TT><B>$nombre</B></TT> solo tiene <TT><B>&quot;Daniel&quot;</B></TT>.
Por las caracter&iacute;sticas de la lectura de renglones de archivos,
<TT><B>chop()</B></TT> es un elemento casi constante en programas
de Perl.
<P>
(Pru&eacute;balo!, revisa que sucede si comentas esta l&iacute;nea,
veras que al imprimir el nombre imprime tambi&eacute;n el retorno
de carro avanzando una l&iacute;nea hacia abajo).
<PRE>
<B>print &quot;$nombre!, bonito nombre, cuantos a&ntilde;os tienes?:&quot;;</B>
</PRE>

<P>
Esta l&iacute;nea nos muestra como se imprime el contenido de
nuestras variables de forma sencilla; notamos que en la cadena
a imprimir se encuentra <TT><B>$nombre</B></TT>, el compilador
lo interpreta y reemplaza por su valor, (para imprimir &quot;$&quot;
se pone <TT><B>&quot;\$&quot;</B></TT>), el resto de la cadena
es completamente convencional.
<PRE>
<B>$edad=&lt;STDIN&gt;;</B>
</PRE>

<P>
Esta l&iacute;nea, lee otra l&iacute;nea de TEXTO y la coloca
en la variable <TT><B>$edad</B></TT> (con todo y retorno de carro).
<PRE>
<B>print &quot;sabias que te faltan &quot;.(100-$edad).&quot; para tener 100?\nAdios!\n&quot;;</B>
</PRE>

<P>
Esta l&iacute;nea imprime un mensaje que esta dividido en tres
partes, la primera y la ultima son cadenas convencionales, que
est&aacute;n concatenadas (operador .) con una operaci&oacute;n
aritm&eacute;tica. Hay que notar que edad era un rengl&oacute;n
de la entrada est&aacute;ndar, y no un numero, sin embargo no
hay conflicto de tipo al operarlo con un entero, &#191;porque?
porque los dos, para Perl, son del mismo tipo, son escalares,
despu&eacute;s discutiremos que son los escalares y que mecanismo
de conversi&oacute;n se utiliza para extraer el entero del texto
contenido en $edad.
<P>
(Experimenta!, prueba que pasa si los valores que se dan a edad
no son enteros, que pasa si son reales o cadenas!)
<P>
Despu&eacute;s de nuestro primer encuentro con las variables de
Perl, el sentimiento mas probable es el de perplejidad, &#191;como
maneja sus variables?, &#191;a que me refer&iacute;a conque enteros,
reales y cadenas son del mismo tipo?, y si es as&iacute;, &#191;como
ser&aacute;n los dem&aacute;s tipos?.
<P>
En realidad, las variables de Perl pretenden simplificarnos la
vida, pero debemos comprender como pretenden facilitar las cosas
para no terminar peleando contra ellas.
<blockquote><blockquote><blockquote>
<A NAME="2.2.1"><H3>2.2.1- Clases de Datos</H3></A>
</blockquote></blockquote></blockquote>
<P>
Perl reconoce tres clasificaciones b&aacute;sicas de datos, y
dos especiales, por claridad, llamaremos clases a estas diversas
clasificaciones, y tipos a las formas usuales de datos.
<P>
Las diversas clases se distinguen entre si por el s&iacute;mbolo
que antecede al nombre de la variable (por ejemplo $nombre es
una variable de tipo escalar que se llama &quot;nombre&quot;),
debe notarse que no hay relaci&oacute;n entre variables del mismo
nombre si son de clases distintas.
<P>
A continuaci&oacute;n, pongo una tabla de las clases de datos
y los tipos que contienen:
<PRE WIDTH=132>
Clase         S&iacute;mbolo         Tipos                                        

Escalar       $               Entero, Real, Cadena, Referencia*            

Arreglo       @               Arreglo de escalares                         

Hash          %               Arreglo Asociativo de escalares              

Archivo       (ninguno)       Identificador de Archivo                     

Type Glob     *               Cualquiera**                                 


</PRE>

<P>
* Las referencias son exclusivas de Perl 5, son el equivalente
a apuntadores.
<P>
** Las variables tipo Glob se usaban como sustituto de las referencias
en Perl 4, son obsoletas para Perl 5 y en lo personal no recomiendo
su uso sino en casos muy particulares.
<blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.1.1"><H4>2.2.1.1- Escalares</H4></A>
</blockquote></blockquote></blockquote></blockquote>
<P>
Nota: Algunas caracter&iacute;sticas de las conversiones entre
tipos son exclusivas de Perl 5, pero la sintaxis y caracter&iacute;sticas
generales son las mismas para ambas versiones. Por lo que en general,
el tratamiento expuesto es valido para las dos.
<P>
El escalar, es la clase de datos que engloba los tipos convencionales
de datos, de modo que podemos decir:
<PRE>
<B>$v1=&quot;Daniel Sol Llaven&quot;;
$v1=100;
$v1=89.12;</B>
</PRE>

<P>
Sin que esto implique ning&uacute;n cambio en la naturaleza de
$v1, en todo momento es un escalar.
<P>
Aun cuando la compatibilidad de datos enteros y reales es f&aacute;cil
de imaginar, la conversi&oacute;n impl&iacute;cita en el caso
de las cadenas no lo es, sin embargo la regla es bastante simple.
<P>
por ejemplo:
<PRE>
<B>$v1=&quot;123y321&quot;;</B>
</PRE>

<P>
crea un escalar <TT><B>$v1</B></TT>, que contiene la cadena <TT>&quot;<B>123y312</B>&quot;</TT>,
&#191;pero que pasa si le deseamos sumar 4?. Perl, interpreta
<TT><B>$v1</B></TT> como entero (o punto flotante) para esto,
toma todos los caracteres del inicio que forman un numero correcto
y ese numero es el que interpreta; de modo que:
<PRE>
<B>print $v1+1;</B>
</PRE>

<P>
imprimir&aacute;:
<PRE>
<I>124</I>
</PRE>

<P>
Del mismo modo, como ejemplo:
<PRE>
<B>$v2=&quot;123.123.123&quot;+1</B>
</PRE>

<P>
da el valor 124.123 a la variable $v1 (punto flotante).
<P>
Otro punto importante de las variables en general es que, aunque
en ning&uacute;n momento se declaran como de un tipo o de otro,
si se pueden &quot;destruir&quot;, o revisar que hayan recibido
alg&uacute;n valor en la ejecuci&oacute;n del programa, esto se
logra mediante las funciones <B>defined()</B> y <B>undef().</B>
<B>defined</B> nos indica si la variable que le pasamos como argumento
ha sido definida (es decir, existe en el programa) o no. <B>undef</B>
toma una variable y la &quot;elimina&quot; de modo que ya no tiene
valor y <TT><B>defined</B></TT> la reporta como no utilizada.
<P>
Los valores l&oacute;gicos de verdadero y falso se manejan de
modo similar al de C, cualquier valor escalar no nulo o cero se
considera verdadero. Debe tenerse cuidado con las cadenas &quot;0&quot;
pues si se eval&uacute;an como n&uacute;mero resultaran en falso
aun cuando no son cadenas nulas.
<P>Los escalares son los constituyentes de las dem&aacute;s estructuras
de datos, por lo que al explicar los arreglos, hashes, referencias
y archivos haremos muchas referencias a ellos.
<blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.1.2"><H4>2.2.1.2- Arreglos</H4></A>
</blockquote></blockquote></blockquote></blockquote>
<P>
Los arreglos en Perl son simplemente, arreglos din&aacute;micos
de escalares, es decir, se pueden usar cualesquiera elementos
en el arreglo y Perl se encargar&aacute; de hacer al arreglo de
la dimensi&oacute;n adecuada.
<P>
La definici&oacute;n de un arreglo con valores constantes es:
<PRE>
<B>@a1=(&quot;hola&quot;,123,43.2,&quot;adios&quot;);</B>
</PRE>

<P>
Esta definici&oacute;n, crea el arreglo @a1 con cuatro elementos,
dos cadenas, un entero y un real, en realidad, cuatro escalares,
para hacer referencia a los elementos escalares de un arreglo
se usan los corchetes [] indicando el &iacute;ndice del elemento
(de cero al numero de elementos menos uno) de modo que:
<PRE>
<B>print &quot;$a1[0]\n$a1[1]\n$a1[2]\n$a3[3]\n&quot;;</B>
</PRE>

<P>
resulta para el arreglo anterior:
<PRE>
<I>hola
123
43.2
adi&oacute;s</I>
</PRE>

<P>
N&oacute;tese que el elemento de un arreglo ya no es un arreglo,
sino un escalar, y debe especificarse como tal, con $ en vez de
@. No es lo mismo el escalar <TT><B>a1</B></TT> que un elemento
del arreglo <TT><B>a1</B></TT>.
<P>
<TT><B>$a1</B></TT> Es un elemento distinto que <TT><B>$a1[]</B></TT>

<P>
Por claridad, recomiendo que no se dupliquen nombres de arreglos
(o cualquier otra cosa) con escalares, aunque Perl da un manejo
independiente a las diversas entidades, de modo que si se hace
no habr&aacute; quejas de parte de Perl.
<P>
Es importante se&ntilde;alar que los arreglos y hashes no pueden
ser elementos de un arreglo, si se intenta esto, los arreglos
o hashes ser&aacute;n &quot;aplanados&quot; a elementos que se
agregan al arreglo. Por ejemplo:
<PRE>
<B>(a,b,(c,d),e)==(a,b,c,d,e)</B>
</PRE>

<P>
Es decir, el arreglo constante a,b, arregl&oacute; con c,d , e
es equivalente al arreglo que contiene a,b,c,d,e. Pues al formar
el primer arreglo, el sub-arreglo c,d es &quot;aplanado&quot;
a elementos que se agregan al arreglo principal. Algo similar
sucede a los hashes.
<P>
Para hacer arreglos de arreglos o arreglos como elementos de hashes,
se utilizan las referencias.
<blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.1.3"><H4>2.2.1.3- Hash o Arreglos Asociativos</H4></A>
</blockquote></blockquote></blockquote></blockquote>
<P>
El Hash, o arreglo asociativo es una ampliaci&oacute;n del arreglo,
en la que en vez de ubicar los elementos por posici&oacute;n se
les ubica por una &quot;llave&quot; es pues un arreglo de parejas
ordenadas que se accesa por el primer elemento, el s&iacute;mbolo
de los hashes es %, y la forma de declarar un hash con constantes
es muy similar a la forma para declarar un arreglo:
<PRE>
<B>%h1=(&quot;ll1&quot;,1,&quot;ll2&quot;,2,&quot;ll3&quot;,3);</B>
</PRE>

<P>
Esta declaraci&oacute;n crea un hash con tres parejas ordenadas,
las llaves son <TT><B>&quot;ll1&quot;</B></TT>, <TT><B>&quot;ll2&quot;</B></TT>,
<TT><B>&quot;ll3&quot;</B></TT>, para usarlo se pueden usar expresiones
del tipo:
<PRE>
<B>$ndx=&quot;ll3&quot;;
print &quot;$h1{ll1}\n$h1{&quot;ll2&quot;}\n$h1{$ndx}\n&quot;;</B>
</PRE>

<P>
resultando:
<PRE>
<I>1
2
3</I>
</PRE>

<P>
Al igual que en los arreglos, cada elemento de un hash es un escalar,
de modo que debe anteponerse $ en vez de % (pues no estamos haciendo
referencia a todo el hash, sino a un elemento escalar del hash),
pero a diferencia del los arreglos, en vez de usar [] para indicar
el &iacute;ndice se usan las llaves {}.
<P>
Dentro de las llaves, en el ejemplo, usamos las tres formas principales
de dar el &iacute;ndice:
<P>
<TT><B>ll1</B></TT> - En esta forma Perl adivina correctamente
que ll1 es una cadena y que esta es la llave.
<P>
<TT><B>&quot;ll2&quot;</B></TT> - En esta forma decimos expl&iacute;citamente
el valor de la llave deseada.
<P>
<TT><B>$ndx</B></TT>- como <TT><B>$ndx=&quot;ll3&quot;</B></TT>
Perl puede determinar el valor de la llave correcta.
<P>
Para &iacute;ndices, al igual que para hashes, tambi&eacute;n
puede usarse el valor de variables o de expresiones para especificar
el &iacute;ndice.
<blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.1.4"><H4>2.2.1.4- Equivalencias de Clases</H4></A>
</blockquote></blockquote></blockquote></blockquote>
<P>
Como ya revisamos, al hacer referencia a un elemento particular
de un arreglo o hash obtenemos un escalar (en ves de todo el arreglo
o hash). Este tipo de &quot;cambios&quot; de clase son el prop&oacute;sito
de esta secci&oacute;n, pues pueden resultar algo confusos aunque,
una vez comprendidos, dan una buena parte del sabor peculiar de
Perl.
<P>
B&aacute;sicamente, Perl distingue dos tipos de contextos para
evaluar una expresi&oacute;n: como escalar y como arreglo. El
primero se refiere a las expresiones que han de regresar un escalar
(del tipo que sea) como resultado, y el segundo a aquellas expresiones
que han de regresar un arreglo o conjunto de escalares como resultado.
Muchas expresiones pueden ser evaluadas en ambos contextos y obtener,
seg&uacute;n el contexto, un resultado distinto, esto lo revisaremos
con cuidado conforme vayamos revisando estas expresiones.
<P>
Revisemos los cambios que ocurren a los datos de una cierta clase
cuando los evaluamos en otro contexto:<HR>

<PRE WIDTH=132>
Contexto            escalar         arreglo                                  

           Clase    escalar         arreglo           hash                   

escalar    escalar  El valor        Se convierte en   Vac&iacute;o, no definido     
                    original        el &uacute;nico                                 
                                    elemento del                             
                                    arreglo                                  

arreglo    arreglo  Numero de       El arreglo de     Los elementos pares    
                    elementos       valores           (0,2,4,...) forman     
                    (usualmente)    originales        las llaves y los       
                                                      nones los datos del    
                                                      nuevo hash.            

           hash     cociente que    arreglo con las   El hash original       
                    representa la   parejas                                  
                    eficiencia del  llave1,valor1,lla                        
                    hash            ve2,valor2,...                           


</PRE>
<HR>

<P>
Las transiciones mas utilizadas son las de arreglo a escalar,
las de arreglo a hash y de hash a arreglo, la primera porque permite
conocer el tama&ntilde;o de los arreglos y las segundas porque
proveen los mecanismos para inicializar los hashes con arreglos
constantes y para &quot;aplanarlos&quot; con fines de almacenamiento
e impresi&oacute;n.
<P>
A menudo, se representa un arreglo con una sola cadena que contiene
separadores para los diversos elementos, Perl implementa la funci&oacute;n
&quot;split&quot; que divide estas cadenas en arreglos, su sintaxis
b&aacute;sica es:
<PRE>
<B>split($delim,$cadena)</B>
</PRE>

<P>
donde
<P>
<TT><B>$delim</B></TT> es la expresi&oacute;n que representa los
delimitadores de elementos y
<P>
<TT><B>$cadena</B></TT> es la cadena a dividir.
<P>
Como ya se mencion&oacute;, generar&aacute; un arreglo de cadenas
donde los elementos son las subcadenas de <TT><B>$cadena</B></TT>
que est&eacute;n separadas por cadenas <TT><B>$delim</B></TT>.
<P>
por ejemplo, una cadena como:
<PRE>
<B>$registro=&quot;Daniel:22:daniel@simba&quot;;
@reg=split(&quot;:&quot;,$registro);
print &quot;Nombre:$reg[0]\nEdad:$reg[1]\nEmail:$reg[2]\n&quot;;</B>
</PRE>

<P>
genera un resultado similar a:
<PRE>
<I>Nombre:Daniel
Edad:22
Email:daniel@simba</I>
</PRE>

<P>
Cuidado! no todas las funciones de Perl convierten de igual forma
los arreglos en escalares, por lo que debe provarse o investigar
primero que efectivamente en el contexto en que hagamos la conversi&oacute;n
el resultado sea el deseado.
<P>
Ejemplos:
<P>
Arreglo constante
<PRE>
<B>@arreglo=(1,2,&quot;hola&quot;,3,&quot;adios&quot;);</B>
</PRE>

<P>
inicializa el arreglo <TT><B>@arreglo</B></TT> con los elementos
<TT><B>1,2,&quot;hola&quot;,3,&quot;adios&quot;</B></TT>, (todos
escalares). la notaci&oacute;n de los elementos entre par&eacute;ntesis
define un arreglo constante, el equivalente a un numero o cadena
constante cuyo valor asign&aacute;ramos a una variable pero en
el contexto de los arreglos.
<P>
&quot;Hash&quot; constante
<PRE>
<B>%hash=(&quot;llave1&quot;,&quot;dato1&quot;,&quot;llave2&quot;,&quot;dato2);  #arreglo constante a hash</B>
</PRE>

<P>
Inicializa el <TT><B>%hash</B></TT> con las llaves <TT><B>&quot;llave1&quot;
y &quot;llave2&quot;</B></TT> poni&eacute;ndole como contenidos
<TT><B>&quot;dato1&quot;</B></TT><B> </B>y <TT><B>&quot;dato2&quot;</B></TT>
respectivamente. De hecho, no especificamos un &quot;hash constante&quot;
como en el caso del arreglo, sino que especificamos un arreglo
constante el cual pasa por una transformaci&oacute;n de clase
para asignarse a un hash, de modo que la expresi&oacute;n es equivalente
a:
<PRE>
<B>@arreglo=(&quot;llave1&quot;,&quot;dato1&quot;,&quot;llave2&quot;,&quot;dato2); #arreglo constante a arreglo
%hash=@arreglo;	#arreglo a hash</B>
</PRE>

<P>
Cardinalidad de un arreglo
<PRE>
<B>@arreglo=(1,2,3,4);
$elementos=@arreglo;</B>
</PRE>

<P>
En este caso <TT><B>$elemento</B></TT> recibe el valor 4, pues
son 4 los elementos del arreglo, n&oacute;tese que el &iacute;ndice
m&aacute;ximo en el arreglo es de solo tres, pues el primer elemento
es el elemento 0 y Perl 4 regresa, con esta misma expresi&oacute;n
el &iacute;ndice m&aacute;ximo en lugar del n&uacute;mero de elementos
como Perl 5.
<P>
Asignaci&oacute;n a arreglo constante
<PRE>
<B>($a,$b,$c)=(1,2,3);</B>
</PRE>

<P>
Esta expresi&oacute;n es equivalente a:
<PRE>
<B>$a=1;
$b=2;
$c=3;</B>
</PRE>

<P>
Pero debe tenerse cuidado, el siguiente c&oacute;digo:
<PRE>
<B>($a,$b,$c)=(1,2,3);
@a=($a,$b,$c);
$a=7;
$b=8;
$c=9;</B>
</PRE>

<P>
Da al arreglo <TT><B>@a</B></TT> el valor del arreglo constante
<B>(1,2,3)</B>, y no, como podr&iacute;a pensarse. <B>(7,8,9).</B>
Cuando se genera un arreglo constante se eval&uacute;an los elementos
que lo forman como constantes escalares y se le asigna despu&eacute;s,
para obtener resultados diferentes se deber&aacute; usar un arreglo
de referencias.
<P>
Arreglos con arreglos
<PRE>
<B>@a=(1,2,3);
@b=(5,6,7);
@c=(@a,4,@b,8);</B>
</PRE>

<P>
Estas expresiones generan tres arreglos<B>, </B><TT><B>(1,2,3),
(5,6,7) y (1,2,3,4,5,6,7,8)</B></TT>, y no, como podr&iacute;a
pensarse un arreglo de arreglos, cuando incluimos un arreglo dentro
de otro, Perl &quot;aplana&quot; el arreglo insertado como
si insertara uno a uno todos sus elementos en la posici&oacute;n
indicada del arreglo que ha de contenerlos, para hacer arreglos
de arreglos deberemos usar referencias a estos.<P>

<blockquote><blockquote><blockquote>
<A NAME="2.2.3"><H3>2.2.3- Tipos Especiales de Datos</H3></A>
</blockquote></blockquote></blockquote>
<P>
Llamo a estos &quot;tipos especiales&quot; porque nos permiten
hacer cosas inposibles con otros tipos, por ejemplo, el evitar
ser &quot;aplanado&quot; en los arreglos. Adem&aacute;s, incluyo
en esta secci&oacute;n a los Archivos, pues aunque su sintaxis
se parece a las de las variables, su funcionalidad es bien distinta.
Sin embargo, por tratarse de solo una introducci&oacute;n omito
discutir sobre los &quot;type globs&quot; que son la aproximaci&oacute;n
a las referencias que perl 4 implementa.
<blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.3.1"><H4>2.2.3.1- Referencias</H4></A>
</blockquote></blockquote></blockquote></blockquote>
<P>
Nota: Este tipo de datos es exclusivo de Perl 5, Perl 4 usaba
los type globs para realizar algunas de estas funciones, pero
el proceso es mucho mas complicado y obscuro.
<P>
Las referencias son el equivalente l&oacute;gico de los apuntadores,
son un tipo de dato que no contiene informaci&oacute;n en si misma,
sino que permite manejar indirectamente los datos contenidos en
otra entidad.
<P>
Las referencias, sin embargo, no forman una clase nueva de datos,
sino que son tratados como un tipo mas de escalar.
<P>
La definici&oacute;n de referencias se realiza por el operador
referencia &quot;<TT><B>\</B></TT>&quot; (backslash) , funciona
de modo similar a &quot;&amp;&quot; en C, y aunque a diferencia
de C no hay un operador de derreferencia la sintaxis para acceder
al dato original es muy sencilla.
<P>
A diferencia de C, los objetos que creemos mediante referencias
no quedan como cad&aacute;veres en memoria, Perl lleva un registro
de las diversas referencias a cada elemento en memoria y autom&aacute;ticamente
lo destruye cuando descubre que nadie hace ya referencia a &eacute;l,
de modo que pueden usarse las referencias sin miedo, aunque con
la precauci&oacute;n necesaria para no perder los datos que almacenamos
en ellas.
<blockquote><blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.3.1.1"><H5>2.2.3.1.1- Creaci&oacute;n</H5></A>
</blockquote></blockquote></blockquote></blockquote></blockquote>
<P>
Podemos crear referencias de varias formas, las que considero
mas sencillas y &uacute;tiles son:
<P>
Usando el operador de referenciaci&oacute;n en una variable, o
valor, en el caso de una variable, es crear un medio alterno de
acceder al valor de la variable.
<PRE>
<B>$rescalar=\$escalar;
$rarreglo=\@arreglo;
$rhash=\%hash;
$rrutina=\&amp;subrutina; #la programaci&oacute;n de subrutinas la revisaremos mas adelante.
$globref=\*ARCHIVO; #solo revisaremos los type globs para usarlos como referencias a archivos.</B>
</PRE>

<P>
Creando objetos &quot;an&oacute;nimos&quot; que solo pueden ser
accesados por medio de la referencia.
<P>
Escalares
<PRE>
<B>$rescalar=\&quot;hola&quot;;	#referencia a la cadena an&oacute;nima &quot;hola&quot;</B>
</PRE>

<P>
Arreglos:
<PRE>
<B>$rarreglo=[1,2,3];	# referencia al arreglo an&oacute;nimo (1,2,3)</B>
</PRE>

<P>
Hashes
<PRE>
<B>$rhash={&quot;llave1&quot; =&gt; &quot;dato1&quot;,&quot;llave2&quot; =&gt; &quot;dato2&quot;};</B>
</PRE>

<P>
N&oacute;tese que en esta representaci&oacute;n usamos adem&aacute;s
el operador &quot;=&gt;&quot; que indica una pareja de llave y
dato, las que se separan por comas; esta notaci&oacute;n tambi&eacute;n
es valida para hashes convencionales, pero la claridad que agrega
es mejor utilizada al declarar hashes an&oacute;nimos.
<P>
Como elementos de arreglos y/o hashes para formar estructuras
de datos complejas, al ser escalares, son elementos del arreglo sin mas 
complicaci&oacute;n, de modo que los arreglos a los que hacen referencia
se mantienen int&aacute;ctos.
<P>
Por ejemplo, para formar un hash que contenga arreglos de nombres
de letras:
<PRE>
<B>%rhletras={
&quot;latinas&quot; =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],
&quot;gregas&quot; =&gt; [&quot;alfa&quot;,&quot;beta&quot;,&quot;gamma&quot;]};</B>
</PRE>

<P>
Esta sentencia forma un hash donde las llaves son cadenas y los
datos son referencia a arreglos.
<P>
Pueden convinarse las referencias a arreglos y a hashes an&oacute;nimos
a voluntad para formar una estructura de datos tan compleja como
se desee.
<blockquote><blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.3.1.2"><H5>2.2.3.1.2- Uso</H5></A>
</blockquote></blockquote></blockquote></blockquote></blockquote>
<P>
De nada sirven las referencias si no podemos extraer y modificar
los datos contenidos en los elementos se&ntilde;alados por la
referencia, en Perl la forma para obtener el valor y para
modificarlo es casi la misma, solo las abreviaturas de las referencias
para obtener el valor funcionaran de modo distinto cuando tratemos
de asignarles valor.
<P>
Aun cuando Perl tiene varias formas de &quot;derreferenciar&quot;
la informaci&oacute;n, solo discutir&eacute; dos por considerarlas
las mas sencillas, sin embargo, recomiendo una revisi&oacute;n
al capitulo PERLREF de la referencia de Perl 5.X para una explicaci&oacute;n
mas detallada y a consciencia del manejo de las referencias.
<P>
Uso &quot;simb&oacute;lico&quot; de las referencias.
<P>
Por regla general, podemos usar las referencias como si se sustituyeran
antes de ejecutar el c&oacute;digo (aunque en realidad, no sea
as&iacute;), de modo que el c&oacute;digo:
<PRE>
<B>$nombre=&quot;entero&quot;;
$entero=5;
$rentero=\$entero;
$$nombre=6;
$$rentero=7;</B>
</PRE>

<P>
efectivamente cambia el valor de <TT><B>$entero</B></TT> de 5
a 6 y despues de 6 a 7, del mismo modo podemos usar las referencias
refiri&eacute;ndonos a cualquier otro tipo.
<P>
por ejemplo, para arreglos:
<PRE>
<B>$rarreglo=[1,2,3,4]	#crea arreglo an&oacute;nimo (1,2,3,4)
$$rarreglo[2]=&quot;tres&quot;;	#modifica el arreglo an&oacute;nimo a (1,2,&quot;tres&quot;,4)
@$rarreglo=();		#limpia el arreglo an&oacute;nimo</B>
</PRE>

<P>
Uso con el operador de derreferencia.
<P>
Como una forma de abreviar el proceso para referencias a arreglos
y hashes, se a&ntilde;adi&oacute; el operador -&gt; que indica
que el escalar es una referencia a hash o arreglo y espera el
&iacute;ndice despu&eacute;s.
<P>
por ejemplo:
<PRE>
<B>$rarreglo-&gt;[5]=&quot;algo&quot;;</B>
</PRE>

<P>
coloca <TT><B>&quot;algo&quot;</B></TT> como el 6o elemento del
arreglo al que hace referencia <B>$rarreglo</B>.
<PRE>
<B>$rhash-&gt;{&quot;alfa&quot;}=&quot;uno&quot;;</B>
</PRE>

<P>
coloca la pareja (<TT><B>&quot;alfa&quot; =&gt; &quot;uno&quot;</B></TT>)
en el hash al que hace referencia <B>$rhash</B>.
<P>
Uso abreviado del operador de derreferencia.
<P>
Se pueden obtener referencias a referencias, y se pueden hacer
arreglos de referencias, de modo que los arreglos multidimencionales
se pueden elaborar con la misma mec&aacute;nica que en C.
<PRE>
<B>$ra3d-&gt;[0]-&gt;[0]-&gt;[0]=1; #pone un &quot;0&quot; en la primera celda de un arreglo tridimencional</B>
</PRE>

<P>
N&oacute;tese que al crear perl los arreglos de las dimensiones
adecuadas autom&aacute;ticamente no hay problemas de invasi&oacute;n
de memoria no reservada (aunque un uso descuidado puede ocupar
cantidades demasiado grandes de memoria). Y esta aplicaci&oacute;n
se considero lo bastante frecuente para implementar una abreviatura,
de modo que la expresi&oacute;n anterior es equivalente a:
<PRE>
<B>$ra3d[0][0][0]=1;</B>
</PRE>

<P>
Lo cual le da mas claridad de lectura al c&oacute;digo (pero debe
tenerse cuidado de no confundirlo con un elemento
de un arreglo, $ra3d es una referencia a un arreglo de referencias
y no un arreglo normal. Por claridad podr&iacute;amos usar:
<PRE>
<B>$ra3d-&gt;[0][0][0]=1;</B>
</PRE>

<P>
Ejemplo: A continuaci&oacute;n, coloco el listado de un programa
que usa las estructuras de datos que mencionamos anteriormente
usando su potencia lo mas posible sin que pierdan claridad, recomiendo
que no solo se pruebe el programa, sino que se elabore una versi&oacute;n
en la que se exploren los puntos que particularmente les resulten
mas interesantes.
<blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.3.2"><H4>2.2.3.2- Archivos</H4></A>
</blockquote></blockquote></blockquote></blockquote>
<P>
Uno de los usos mas probados y comunes de Perl es el procesamiento
de archivos de texto para generar otros archivos (por lo regular
de texto) que implican cierto proceso de los datos le&iacute;dos
originalmente. Adem&aacute;s, Perl no conoce mas entrada que la
proveniente de archivos (asociando la entrada, salida y salida
de errores a archivos &quot;de ambiente&quot;) por lo que en cierta
medida ya hemos revisado el uso b&aacute;sico de archivos, solo
que ahora le daremos la explicaci&oacute;n correspondiente a las
entidades que vimos antes.
<P>
Como en cualquier otro lenguaje, el ciclo de uso normal de un
archivo es:
<PRE WIDTH=132>
Apertura       Mediante &quot;open&quot; inicializa una variable de archivo         

Uso            Lectura secuencial por l&iacute;neas                              

Cerrado        Mediante close                                             


</PRE>

<P>
Perl tiene implementaci&oacute;nes para manejar archivos binarios
y archivos aleatorios, pero el uso de archivos de texto secuenciales
es lo mas com&uacute;n en UNIX, por lo que considero a este manejo
como b&aacute;sico y le explico aqu&iacute;.
<P>
B&aacute;sicamente, se puede decir que hay tres tipos de archivos
que se manejan de modo muy similar:
<UL>
<LI>Archivos comunes
<LI>Programas de los que capturamos la entrada o la salida
<LI>La entrada, salida o salida est&aacute;ndar de errores.
</UL>

<P>
Estos tres tipos de archivos se manejan igual (con la limitaci&oacute;n
de que algunos solo reciben lectura o escritura) y el momento
en que se determina el tipo verdadero del archivo, es en el momento
de la apertura, por lo que ha dedicado una secci&oacute;n exclusivamente
a la apertura mientras que al uso y cierre los he concentrado
en la secci&oacute;n que siguiente a esta.

<blockquote><blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.3.2.1"><H5>2.2.3.2.1- Apertura</H5></A>
</blockquote></blockquote></blockquote></blockquote></blockquote>
<P>
La entrada, salida y salida de errores est&aacute;ndar, est&aacute;n
abiertas por default, pero en cualquier otro sentido se utilizan
igual que cualquier otro archivo, debe tenerse cuidado al planear
los entubamientos de informaci&oacute;n para evitar que nuestro
programa espere por siempre una entrada que no le ha de llegar,
sin embargo no es necesario ser paranoico al respecto. Si tratamos
de usarlas despu&eacute;s de cerrarlas el resultado de las lecturas
ser&aacute; nulo y los intentos de salida no tendr&aacute;n efecto.
<P>
Los archivos convencionales se abren con la instrucci&oacute;n
&quot;open&quot;, la cual es, por decir poco, muy interesante,
en esta secci&oacute;n solo revisaremos su uso b&aacute;sico.
<PRE>
<B>open VARCHIVO,EXPRESION</B>
</PRE>

<P>
<TT><B>VARCHIVO</B></TT> es la variable mediante la que usaremos
el archivo, no tiene indicador de clase y por convenci&oacute;n
la manejamos en may&uacute;sculas.
<P>
<TT><B>EXPRESI&Oacute;N</B></TT> es, digamos, el nombre y modo
en que habr&aacute; de abrirse el archivo.
<P>
Los archivos, se dar&aacute;n con los nombres nativos del S.O.,
y los modos se especifican con las siguientes cadenas al inicio
del nombre (que imitan al shell).
<PRE WIDTH=132>
&lt;archivo    abre &quot;archivo&quot; para lectura                                   

&gt;archivo    abre &quot;archivo&quot; para escritura, borr&aacute;ndolo si existe.          

&gt;&gt;archivo   abre &quot;archivo&quot; para escritura, agregando la nueva             
            informaci&oacute;n al final                                          

+&lt;archivo   abre &quot;archivo&quot; para lectura y escritura                       

+&gt;archivo   abre &quot;archivo&quot; para lectura y escritura borrando &quot;archivo&quot; al abrirlo.   

|programa   ejecuta &quot;programa&quot; y reasigna su entrada est&aacute;ndar a lo que    
            escribamos en el                                              

programa|   ejecuta &quot;programa&quot; y reasigna su salida est&aacute;ndar para         
            lectura de nuestro programa                                   


</PRE>

<P>
Debe notarse que a diferencia de los archivos no se puede ejecutar
programas para lectura Y escritura.
<P>
Es importante notar que esta forma de ejecutar programas desde
perl es muy poderosa, pero no es la &uacute;nica, por lo regular
se usa &quot;<TT><B>system</B></TT>&quot; para ejecutar programas
si la salida no nos importa o encerrando con las comillas <B>`</B>
al comando si la salida es sencilla (un rengl&oacute;n) lo que
eval&uacute;a al comando como si fuese una expresi&oacute;n resultando
en la salida del programa (las comillas ' funcionan de distinta forma entre 
Perl 4 y 5 al ejecutar el programa).
<P>
Tambi&eacute;n se pueden abrir la salida y entrada est&aacute;ndar
mediante open, pero estas funciones as&iacute; como la de cerrarlas
puede tener consecuencias en la ejecuci&oacute;n del programa
que son algo complicadas de explicar, por lo que recomiendo que
de desear manejar estas operaciones se use la referencia de Perl.
<blockquote><blockquote><blockquote><blockquote><blockquote>
<A NAME="2.2.3.2.2"><H5>2.2.3.2.2- Uso y Cerrado</H5></A>
</blockquote></blockquote></blockquote></blockquote></blockquote>
<P>
B&aacute;sicamente, se puede usar un archivo de dos formas, por
renglones, (terminados por el car&aacute;cter de vuelta de carro)
o por car&aacute;cter (byte). Revisare solo la primera opci&oacute;n,
porque el manejo por car&aacute;cter tiene implicaciones sobre
la naturaleza del sistema de explicaci&oacute;n muy larga y porque
son mas usuales los archivos de texto en las aplicaciones de Perl.
<P>
El operador que nos permite leer de un archivo es &quot;<TT><B>&lt;&gt;</B></TT>&quot;
teniendo la variable de archivo dentro de el, as&iacute; por ejemplo:
<PRE>
<B>$reng=&lt;STDIN&gt;;</B>
</PRE>

<P>
Que, como ya hemos mencionado; lee un rengl&oacute;n de la entrada
est&aacute;ndar y lo coloca en la variable <B>$reng</B>, incluida
la vuelta de carro que termine el rengl&oacute;n.
<P>
Si el rengl&oacute;n termina con car&aacute;cter de fin de archivo,
este no se incluye en el rengl&oacute;n, y lecturas sucesivas
de <TT><B>STDIN</B></TT> esperaran indefinidamente por una nueva
entrada (as&iacute; que debe tenerse cuidado al usar la entrada
est&aacute;ndar o confiar en el usuario).
<P>
<TT><B>STDIN</B></TT> es la variable de archivo que identifica
la entrada est&aacute;ndar, as&iacute; como
<P>
<TT><B>STDOUT</B></TT> es la variable que identifica la salida
est&aacute;ndar y
<P>
<TT><B>STDERR</B></TT> es la que identifica la salida est&aacute;ndar
de errores.
<PRE>
<B>@contenidos=&lt;STDIN&gt;;</B>
</PRE>

<P>
Esta vez, estamos evaluando al operador <B>&lt;&gt;</B> en un
contexto de arreglo, y su comportamiento varia, como arreglo <B>&lt;&gt;</B>
regresa un arreglo de cadenas, donde cada cadena es un rengl&oacute;n
del archivo, de modo que la expresi&oacute;n anterior leer&aacute;
todo lo que se introduzca en la entrada est&aacute;ndar y lo coloca
en el arreglo <TT><B>@contenido</B></TT>. Esta es una forma mas
segura de usar la entrada est&aacute;ndar, pues ahora cada elemento
del arreglo equivale a una lectura sucesiva de <TT><B>STDIN</B></TT>
en contexto escalar.
<P>
Si sustituimos <B>STDIN</B> por cualquier otra variable de archivo
(o valor de variable de referencia a una variable de archivo)
estaremos cargando el archivo ya sea rengl&oacute;n por rengl&oacute;n
o todo completo a variables de memoria.
<P>
Como caso especial, si evaluamos la expresi&oacute;n:
<PRE>
<B>&lt;ARCHIVO&gt;;</B>
</PRE>

<P>
cargaremos un rengl&oacute;n del archivo al que <TT><B>ARCHIVO</B></TT>
hace referencia y lo coloca en la variable <B>$_</B> de la cual
hablaremos mas adelante.
<P>
A continuaci&oacute;n, esta el listado de un programa sencillo
realizado en perl que demuestra la potencialidad de las estructuras
de datos y lo b&aacute;sico del manejo de archivos, este programa
esta hecho para perl 4, pero no creo que tenga problemas para
correr bajo perl 5, sin embargo, debe recordarse que la ruta hacia
perl muy probablemente deber&aacute; cambiarse o deber&aacute;
ejecutarse perl d&aacute;ndole el programa como par&aacute;metro.
<PRE>
<B>#!/usr/bin/perl
# Programa hecho en perl4 que crea un archivo de parejas de nombre y 
# direcci&oacute;n IP tomando las direcciones de un archivo de la forma:
#
#131.178.80.32
#206.103.64.98
#ppp16-07.rns.tamu.edu
#130.178.80.20
#
# Etc, entiendase que los &quot;#&quot; no est&aacute;n en el archivo de entrada que 
# tiene el nombre &quot;salida&quot; y que esta en el directorio activo.
open(DIR,&quot;&lt;salida&quot;);		# Abre el archivo de entrada
while($dir=&lt;DIR&gt;)		# Lee todas sus l&iacute;neas una a una
{
  chop $dir;			# les corta el fin de l&iacute;nea
  open(NS,&quot;nslookup $dir|&quot;);	# Invoca nslookup y recibe el resultado
  undef(@inf,$nombre,$inf);	# Destruye datos viejos
  while($reng=&lt;NS&gt;)		# revisa el resultado del nslookup
  {
    chop $reng;			# quita fin de l&iacute;nea
    $reng=~s/ //g;		# quita espacios
    @inf=split(&quot;:&quot;,$reng);	# Hace un arreglo con los resultados				
# que vienen como &quot;Name:  servidor.unam.mx&quot;
                                # &quot;Address:  132.248.100.100&quot; por ejemplo.
    if($inf[0] eq &quot;Name&quot;) {$nombre=$inf[1]};	#Toma el nombre del servidor
    if($inf[0] eq &quot;Address&quot;) {$dir=$inf[1]};	#Toma su direcci&oacute;n IP
  }
  close NS;			# Cierra los resultados y termina la ejecuci&oacute;n de nslookup
  if(defined($nombre))		# Si asigno valor a $nombre...
  {
    $hres{$dir}=$nombre;	# Llena un Hash de la direcci&oacute;n y el nombre
    print &quot;%\n&quot;;		# Indica el &eacute;xito de la resoluci&oacute;n
  }
  else
  {
    print &quot;#\n&quot;;		#Indica el fracaso de la resoluci&oacute;n
  }
}
close(DIR);			#Cierra su archivo de entrada
open(DIRS,&quot;&gt;direcciones&quot;);	# Abre archivo de salida de resultados
print &quot;\nimprimiendo resutlados...\n&quot;;
foreach $dir (keys %hres)	# Para todas las llaves de %hres
{
  print DIRS &quot;$dir $hres{$dir}\n&quot;;	#imprime la pareja llave-valor
}
close(DIRS);			# cierra su archivo de salida.</B>
</PRE>
<blockquote><blockquote>
<A NAME="2.3"><H2>2.3- Operaciones B&aacute;sicas</H2></A>
</blockquote></blockquote>
<P>
Como se habr&aacute; podido distinguir en los ejemplos vistos
hasta ahora, Perl cuenta con una amplia y muy interesante gama
de operadores, en esta secci&oacute;n daremos una r&aacute;pida
revisi&oacute;n a los mas importantes, confiando en que el uso
de la mayor&iacute;a de los operadores ser&aacute; casi intuitivo.
<P>
Para obtener mayor informaci&oacute;n sobre los operadores, la
secci&oacute;n PERLOP de la referencia es la mejor fuente de informaci&oacute;n
detallada.
<P>
Las variables, comillas, par&eacute;ntesis y funciones con par&eacute;ntesis
tienen la precedencia mas alta en perl, de hecho, Perl los interpreta
mas como operadores unarios que se comportan como funciones por
la agrupaci&oacute;n de los par&aacute;metros sobre los que act&uacute;an.
Despu&eacute;s de estos, la precedencia de los operadores mas
usuales es:
<P>
<U>Mas alta:</U>
<PRE WIDTH=132>
Posici&oacute;n       Operador                                                   

no asocia      <B>++</B> y <B>--</B>                                                    

derecha        <B>! ~ \</B> y la versi&oacute;n unaria de <B>+</B> y <B>-</B>                         

izquierda      =~ <B>!~</B>                                                      

izquierda      <B>* / % x</B>                                                    

izquierda      <B>+ - .</B>                                                      

no asocia      <B>&lt; &gt; &lt;= &gt;= lt gt le ge</B>                                      

no asocia      <B>== != &lt;=&gt; eq ne cmp</B>                                        

izquierda      <B>&amp;</B>                                                          

izquierda      <B>| ^</B>                                                        

izquierda      <B>&amp;&amp;</B>                                                         

izquierda      <B>||</B>                                                         

no asocia      <B>..</B>                                                         

derecha        <B>?:</B>                                                         

derecha        <B>= += -= *=</B> etc.                                            

izquierda      <B>, =&gt;</B>                                                       

izquierda      <B>not</B>                                                        

izquierda      <B>and</B>                                                        

izquierda      <B>or xor</B>                                                     


</PRE>

<P>
<U>Mas baja.</U>
<blockquote><blockquote><blockquote>
<A NAME="2.3.1"><H3>2.3.1- Operaciones Aritm&eacute;ticas</H3></A>
</blockquote></blockquote></blockquote>
<P>
Estas operaciones interpretaran al escalar como un numero (ya
sea entero o real) y operaran aritm&eacute;ticamente sobre el,
toda cadena que no inicie con una cifra ser&aacute; interpretada
como un cero por estos operadores.
<P>
En orden de Precedencia tenemos:
<P>
<TT><B>++</B></TT> y <TT><B>--</B></TT> Son los operadores de
auto incremento y auto decremento tan conocidos para los programadores
de C. Su uso se puede resumir en la siguiente tabla:<HR>

<PRE WIDTH=132>
Posici&oacute;n     <B>++</B>                             --                             

Antepuesto   Incrementa 1 antes de evaluar  Decrementa 1 Antes de evaluar  

Pospuesto    Incrementa 1 despu&eacute;s de        Decrementa 1 despu&eacute;s de        
             evaluar                        evaluar                        


</PRE>
<HR>

<P>
As&iacute; pues de las expresiones:
<PRE>
<B>$var=5;
print $var++;
print &quot;\n$var\n&quot;;</B>
</PRE>

<P>
obtenemos impresos los n&uacute;meros:
<PRE>
<I>5
6</I>
</PRE>

<P>
Debido a que en el primer print, incrementamos $var, pero al evaluar
antes del incremento obtenemos su valor original, sin embargo,
para evaluaciones posteriores su valor ha sido incrementado.
<P>
<TT><B>**</B></TT> Es el operador de Exponenciacion, as&iacute;
5**2 resulta en 25 (5 al cuadrado)
<P>
<TT><B>*</B></TT> Es el operador de Multiplicaci&oacute;n
<P>
<TT><B>/</B></TT> Es el operador de Divisi&oacute;n
<P>
<TT><B>%</B></TT> Es el operador de Modulo
<P>
<TT><B>+</B></TT> Es el operador de Suma
<P>
<TT><B>-</B></TT> Es el operador de Resta
<P>
A estos no les dedicare mayores explicaciones por ser t&iacute;picos
en todos los lenguajes de programaci&oacute;n y comunes a la matem&aacute;tica
cotidiana.
<P>
Sin embargo, hay interesantes derivados de estos que vale la pena
revisar. Estos son los operadores de automodificaci&oacute;n,
estos se implementan al observar que en muchos programas se requiere
asignar a una variable el resultado de una operaci&oacute;n que
involucra el antiguo valor de la misma variable. Estos operadores
proporcionan una forma resumida de operar una variable con otra
y asignar a la primera el resultado, por ejemplo:
<P>
Si queremos hacer un <TT><B>$total</B></TT>, que sea el <TT><B>$total</B></TT>
mas un <TT><B>$cargo</B></TT> particular podr&iacute;amos escribir:
<PRE>
<B>$total=$total+$cargo;</B>
</PRE>

<P>
Y en Perl (al igual que en C) tenemos la opci&oacute;n de resumirlo
como:
<PRE>
<B>$total+=$cargo;</B>
</PRE>

<P>
N&oacute;tese que el operador empleado fue &quot;<TT><B>+=</B></TT>&quot;
que indica que al valor actual de la variable, se le asignara
su propio valor mas el resultado de la evaluaci&oacute;n de la
expresi&oacute;n a al derecha del operador.
<P>
As&iacute; como se puede formar el operador de asignaci&oacute;n
con incremento, se pueden utilizar la mayor&iacute;a de los otros
operadores susceptibles a actuar sobre una variable, la &uacute;nica
excepci&oacute;n no intuitiva es el de sustituci&oacute;n de patrones
en la variable, que usa una sintaxis distinta &quot;<TT><B>=~</B></TT>&quot;
que revisaremos al final de esta secci&oacute;n.
<blockquote><blockquote><blockquote>
<A NAME="2.3.2"><H3>2.3.2- Operaciones L&oacute;gicas</H3></A>
</blockquote></blockquote></blockquote>
<P>
Indispensables para las condiciones de todo ciclo de control son
las operaciones l&oacute;gicas en los lenguajes de programaci&oacute;n,
y en este contexto me permitir&eacute; incluir las funciones de
comparaci&oacute;n.
<P>
Las operaciones de comparaci&oacute;n entre valores se dividen
en aritm&eacute;ticas y de cadenas, y hay que tener especial cuidado
en utilizar la familia correcta so pena de obtener resultados
no deseados. <HR>

<PRE WIDTH=132>
Operaci&oacute;n       Aritm&eacute;tica      Cadena         

Mayor que       <B>&gt;</B>               gt             

Menor que       <B>&lt;</B>               lt             

Mayor o igual   <B>&gt;=</B>              ge             

Menor o igual   <B>&lt;=</B>              le             

Igual           <B>==</B>              eq             

Diferente       <B>!=</B>              ne             

Compara         <B>&lt;=&gt;</B>             cmp            


</PRE>
<HR>

<P>
La operaci&oacute;n &quot;Compara&quot; regresa un valor de -1,0
o 1 dependiendo si el valor a la izquierda es menor, igual o mayor
(respectivamente) que el de la derecha del operador, n&oacute;tese
que si dese&aacute;ramos evaluar esto de forma l&oacute;gica seria
equivalente al operador &quot;Diferente&quot;.
<P>
Debemos recordar que Perl considera como verdaderos los valores
no nulos (cadenas) y diferentes de cero.
<P>
Adem&aacute;s, tenemos los operadores l&oacute;gicos que permiten
cambiar el valor de verdad de una expresi&oacute;n: <HR>

<PRE WIDTH=132>Operador   Funci&oacute;n                                                        

<B>!</B>          Negaci&oacute;n L&oacute;gica                                                

<B>-</B>          Inverso aditivo (cambia el signo de un numero)                 

<B>~</B>          Negaci&oacute;n Bit a bit de un valor                                 

<B>&amp;&amp;</B>         Conjunci&oacute;n l&oacute;gica de los operandos                             

<B>||</B>         Disyunci&oacute;n l&oacute;gica de los operandos                             

<B>&amp;</B>          Conjunci&oacute;n bit a bit de los operandos                          

<B>|</B>          Disyunci&oacute;n bit a bit de los operandos                          

<B>^</B>          Or exclusiva bit a bit                                         

<B>..</B>         Si evaluado como escalar regresa alternativamente verdadero y  
           falso. Como arreglo genera un arreglo a partir de los limites  
           de un rango.                                                   

<B>not</B>        Negaci&oacute;n l&oacute;gica de la expresi&oacute;n a su izquierda (muy baja       
           precedencia)                                                   

<B>and</B>        Conjunci&oacute;n l&oacute;gica de baja precedencia                          

<B>or </B>        Disyunci&oacute;n l&oacute;gica de baja precedencia                          

<B>xor</B>        Disyunci&oacute;n exclusiva l&oacute;gica (precedencia m&iacute;nima)                       


</PRE>
<HR>
<blockquote><blockquote><blockquote>
<A NAME="2.3.3"><H3>2.3.3- Operaciones con Cadenas</H3></A>
</blockquote></blockquote></blockquote>
<P>
As&iacute; como los operadores aritm&eacute;ticos forzan a la
variable a comportarse como de tipo entero o real, as&iacute;
los operadores de cadena forzan a los escalares a comportarse
como cadenas, de modo que los n&uacute;meros son autom&aacute;ticamente
convertido en cadenas (son su precisi&oacute;n completa) al aplicarles
estos operadores.
<P>
Las operaciones a realizar con cadenas, por lo regular se manejan
como funciones en vez de como operadores, con la excepci&oacute;n
de las siguientes: <HR>

<PRE WIDTH=132>
Operador   Funci&oacute;n                                                        

<B>=~</B>         Especifica la expresi&oacute;n a afectar por b&uacute;squeda de patrones     
           regulares (ver secci&oacute;n siguiente).                             

<B>!~</B>         Especifica la expresi&oacute;n a afectar por b&uacute;squeda de patrones     
           regulares, pero eval&uacute;a negando el resultado l&oacute;gico de la       
           operaci&oacute;n.                                                     

<B>.</B>          Concatenaci&oacute;n, todas las cadenas operadas por &quot;<B>.</B>&quot; forman una   
           sola cadena.                                                   

<B>x</B>          Es el operador de repetici&oacute;n, en contexto escalar toma la      
           cadena de la izquierda y la repite el numero de veces que el   
           numero de la derecha indica. En contexto de lista, toma la     
           lista a su izquierda y la repite las veces que indica el       
           operador a su derecha en una nueva lista.                      

<B>++</B>         Autoincremento, modifica el valor de los elementos de una      
           cadena de modo que se incrementen sin cambiar su naturaleza,   
           por ejemplo <B>++&quot;zzz&quot;</B> -&gt; <B>&quot;aaaa&quot;</B>; <B>++&quot;99&quot;</B> -&gt; <B>&quot;100&quot;</B> , <B>++&quot;a9&quot;</B> -&gt;     
<B>&quot;b0&quot;</B>, etc.                                                     


</PRE>
<HR>
<blockquote><blockquote><blockquote>
<A NAME="2.3.4"><H3>2.3.4- Operaciones Regulares</H3></A>
</blockquote></blockquote></blockquote>
<P>
Este secci&oacute;n se dedica a dar una r&aacute;pida revisi&oacute;n
a las operaciones de sustituci&oacute;n y reconocimiento de patrones
(definidos por lenguajes regulares) que son de las caracter&iacute;sticas
mas utilizadas y &uacute;tiles de Perl, aun cuando no sean tan
sencillos de comprender en un primer acercamiento, recomiendo
al lector que dedique alg&uacute;n tiempo extra al estudio de
la construcci&oacute;n de las expresiones para describir los patrones
a buscar por su cuenta, pues puede obtener grandes beneficios
de este esfuerzo, la referencia es hasta donde se, la mejor fuente
de informaci&oacute;n a este respecto, en las secciones de operadores
PERLOP y de expresiones regulares PERLRE.
<P>
Los operandos para utilizar las expresiones regulares son: <HR>

<PRE WIDTH=132>
Operado Funci&oacute;n                                                           
r                                                                         

<B>=~</B>      Especifica que la cadena a la izquierda del operando es la que    
        pasara por el proceso ya sea de sustituci&oacute;n, o de b&uacute;squeda.       

<B>!~</B>      Especifica que la cadena a la izquierda del operando ser&aacute; la      
        afectada, y hace que la expresi&oacute;n en su conjunto regrese el       
        negado del valor l&oacute;gico resultante.                               

<B>//</B>      Delimita un patr&oacute;n regular.                               

</PRE>
<HR>

<P>
Por defecto, las operaciones de b&uacute;squeda de patrones y
sustituci&oacute;n act&uacute;an sobre el par&aacute;metro default
$_ , y al evaluarlas modifican su valor y regresan el numero de
sustituciones u ocurrencias encontradas.
<P>
La formaci&oacute;n y manejo de las expresiones regulares escapa
a los alcances de este documento, as&iacute; que solo mencionare
como utilizar estos operadores para realizar substituciones y
su derivaci&oacute;n para buscar alg&uacute;n patr&oacute;n.
<P>
Para realizar b&uacute;squedas, la sintaxis b&aacute;sica es:
<PRE>
<B>s/PATR&Oacute;N/CADENA/g</B>
</PRE>

<P>
Que hace la substituci&oacute;n de todas las ocurrencias de <TT><B>PATR&Oacute;N</B></TT>
en <TT><B>CADENA</B></TT>. En esta forma, actuara sobre el par&aacute;metro
default <TT><B>$_</B></TT> y regresara el numero de substituciones
que haga o cero si no encuentra el patr&oacute;n.
<P>
As&iacute;, para cambiar todas la ocurrencias de <TT><B>&quot;Hola&quot;</B></TT>
por <TT><B>&quot;Saludos&quot;</B></TT> en una cadena llamada
<TT><B>$cadena</B></TT> (en vez de en <TT><B>$_</B></TT>) deberemos
escribir:
<PRE>
<B>$cadena=~s/Hola/Saludos/g;</B>
</PRE>

<P>
Por el contrario, si deseamos saber cuantas veces aparece <TT><B>&quot;Hola&quot;</B></TT>
en cadena y colocar este valor en <TT><B>$cuenta</B></TT> deberemos
escribir:
<PRE>
<B>$cuenta=( $cadena=~s/Hola/Hola/g );</B>
</PRE>

<P>
N&oacute;tese que en realidad no realizo la operaci&oacute;n de
b&uacute;squeda (que si existe) sino la substituci&oacute;n por
la misma cadena, para evitar introducir nuevas operaciones.
<P>
Por ultimo, si deseamos determinar si no se encuentra la cadena,
(pues para determinar si se encuentra bastar&iacute;a usar el
valor de veces que se encontr&oacute; la cadena como condici&oacute;n
l&oacute;gica, pues evaluara como verdadero si es distinto de
cero y falso si es cero) usaremos el operador<TT><B> !~</B></TT>

<PRE>
<B>if($cadena!~s/Hola/Hola/g)
{
  print &quot;No se encontraron \&quot;Hola\&quot;s\n&quot;;
}</B>
</PRE>

<P>
Como ya se menciono, para un tratamiento serio de las cadenas
regulares y los operadores para utilizarlas hay que consultar
la referencia de perl en las secciones de PERLOP y PERLRE.
<blockquote><blockquote><blockquote>
<A NAME="2.3.5"><H3>2.3.5- Operaciones Miscel&aacute;neas</H3></A>
</blockquote></blockquote></blockquote>
<P>
A continuaci&oacute;n describo brevemente la funci&oacute;n de
otros operadores que resultan &uacute;tiles en condiciones particulares.
<HR>

<PRE WIDTH=132>
Operador Funci&oacute;n                                                          

<B>?:</B>       El operador condicional, es una forma de if resumida en una      
         sola expresi&oacute;n, tiene tres operandos, <B>op1?op2:op3</B> donde <B>op1</B> es   
         una expresi&oacute;n que eval&uacute;a falsa o verdadera, Si eval&uacute;a            
         verdadera, se evaluara y la expresi&oacute;n regresara el valor de      
<B>op2</B>, si por el contrario, <B>op1</B> eval&uacute;a falso, es <B>op3</B> la que        
         determina el valor final de toda la expresi&oacute;n.                   

<B>,</B>        Como el operador , de C, si se usa entre dos expresiones,        
         eval&uacute;a la de la izquierda, desecha el valor obtenido y eval&uacute;a    
         la expresi&oacute;n de la derecha regresando el valor as&iacute; obtenido.     

<B>=&gt;</B>       Este operador funciona primordialmente igual que la coma, pero   
         es exclusivo de Perl 5, forzando en algunas versiones que el     
         operando de la izquierda sea una cadena (recu&eacute;rdese su uso para  
         declarar arreglos asociativos).                                  


</PRE>
<HR>

<P>
Adem&aacute;s, tenemos los signos de puntuaci&oacute;n, que a
diferencia de otros lenguajes son considerados operadores de Perl.
<P>
B&aacute;sicamente, tenemos 4 tipos de s&iacute;mbolos que nos
sirven para agrupar otros s&iacute;mbolos para darles una interpretaci&oacute;n
especial, son:<HR>

<PRE WIDTH=132>
S&iacute;mbolo Funci&oacute;n                                                           

<B>''</B>      Especifica valores literales (cadenas), no hace substituciones.   

<B>&quot;&quot;</B>      Especifica valores literales, haciendo substituciones.            

<B>``</B>      Ejecuci&oacute;n, ejecuta el comando contenido entre ` despu&eacute;s de hacer  
        las substituciones indicadas.                                     

<B>//</B>      Suelen usarse para delimitar expresiones regulares, hace          
        substituciones con la operaci&oacute;n s//.                              


</PRE>
<HR>

<P>
Entiendase por substituci&oacute;n el reemplazar el nombre de
variables por los valores de estas, as&iacute; como los caracteres
de escape; por ejemplo:
<PRE>
<B>$saludo=&quot;echo hola&quot;;
print '$saludo'.&quot;\n&quot;;
print &quot;$saludo&quot;.&quot;\n&quot;;
print `$saludo`.&quot;\n&quot;;
print &quot;adios\n&quot;;</B>
</PRE>

<P>
Genera como resultados algo similar a:
<PRE>
<I>$saludo
echo hola
hola
adi&oacute;s</I>
</PRE>

<P>
Como se puede ver , en todos los casos imprime un fin de l&iacute;nea
&quot;<TT><B>\n</B></TT>&quot; despu&eacute;s de cada cadena (o
expresi&oacute;n), la primera, es, literalmente la cadena dada;
la segunda, es la cadena donde se ha substituido el nombre de
la variable <TT><B>$saludo</B></TT> por su valor; la tercera,
es el resultado de la ejecuci&oacute;n del comando especificado
en la cadena, donde se substituy&oacute; el nombre de una variable
por su valor.<P>
Perl 4 no regresa valor cuando utilizamos las comillas para ejecutar un programa o comando, es decir, lo ejecuta sin capturar su salida, de modo que esta ir&aacute; a la misma salida estandar del script que lo invoc&oacute;.
<P>
Alguna experimentaci&oacute;n con el uso de estos operadores es
altamente recomendable, pues las convenciones de cada programa
para entregar sus resultados a alg&uacute;n dispositivo o a alguna
salida distinta de la standard pueden ocasionar resultados poco
previsibles.
<blockquote><blockquote>
<A NAME="2.4"><H2>2.4- Estructuras de Control</H2></A>
</blockquote></blockquote>
<P>
Las estructuras de control b&aacute;sicas de Perl y su sintaxis
son:
<PRE>
<B>IF:
if (EXPRESI&Oacute;N) BLOQUE
if (EXPRESI&Oacute;N) BLOQUE else BLOQUE
if (EXPRESI&Oacute;N) BLOQUE elseif (EXPRESI&Oacute;N) BLOQUE ... else BLOQUE
WHILE:
WHILE (EXPRESI&Oacute;N) BLOQUE
ETIQUETA WHILE (EXPRESI&Oacute;N) BLOQUE
FOR
for (EXPRESION;EXPRESION;EXPRESION) BLOQUE
ETIQUETA for (EXPRESION;EXPRESION;EXPRESION) BLOQUE
FOREACH
foreach VARIABLE (LISTA) BLOQUE</B>
</PRE>

<P>
<TT><B>EXPRESI&Oacute;N</B></TT> es toda instrucci&oacute;n de
PERL que eval&uacute;a en un solo valor, b&aacute;sicamente se
emplean como inicializaciones y condiciones de las estructuras.
<P>
<TT><B>BLOQUE</B></TT> es un conjunto de expresiones encerradas
en <TT><B>{}</B></TT>, n&oacute;tese que todos los bloques, sin
excepci&oacute;n inician con <TT><B>{</B></TT> y terminan con
<TT><B>}</B></TT>.
<P>
<TT><B>ETIQUETA</B></TT> se refiere a etiquetas en el c&oacute;digo,
estas son nombres seguidos de &quot;<TT><B>:</B></TT>&quot;, que
permiten identificar a alg&uacute;n bloque en particular.
<P>
Para modificar la ejecuci&oacute;n de los ciclos tenemos las siguientes
instrucciones:
<PRE WIDTH=132>
<B>next</B>          Esta interrumpe el flujo del ciclo iniciando de inmediato   
<B>ETIQUETA</B>      la siguiente iteraci&oacute;n. Si no se especifica la <B>ETIQUETA</B>     
              afecta al ciclo mas interno.                                

<B>last</B>          Esta interrumpe el flujo del ciclo y pasa el control a la   
<B>ETIQUETA</B>      primera instrucci&oacute;n despu&eacute;s del bloque del ciclo.           

<B>redo</B>          Esta reinicia la ejecuci&oacute;n del ciclo, sin reevaluar la      
              condici&oacute;n.                                                  


</PRE>

<P>
Los programas a lo largo de este documento son ejemplos del uso
de estas estructuras de control, por lo que no pongo ning&uacute;n
ejemplo especifico en esta secci&oacute;n.
<blockquote><blockquote><blockquote>
<A NAME="2.4.1"><H3>2.4.1- Manejo de subrutinas</H3></A>
</blockquote></blockquote></blockquote>

<P>
Como en cualquier lenguaje estructurado, Perl tiene la capacidad
de generar nuevas funciones o procedimientos, pero perl tiene
varias peculiaridades en la forma de definir sus funciones,Ademas
de ser estas las que sufrieron mas cambios entre la versi&oacute;n 4
y 5.
<P>
Caracter&iacute;sticas de las funciones en la versi&oacute;n 4
de Perl
<P>
Para su ejecuci&oacute;n, se les tiene que se&ntilde;alar
expl&iacute;citamente, anteponiendo el s&iacute;mbolo de 
<TT><B>&amp;</B></TT>
al nombre de la funci&oacute;n (algo similar a la clase de una
variable), las referencias a una funci&oacute;n eran siempre a
trav&eacute;s de typeglobs por lo que es incomodo e inusual usarlas.
Reciben siempre un &uacute;nico par&aacute;metro, el arreglo default 
<TT><B>@_</B></TT> en el cual deb&iacute;an
ir todos los par&aacute;metros que de desearan, sin posibilidad
forzar el paso de ciertos par&aacute;metros a la funci&oacute;n,
para obtener los valores se suele hacer un<TT><B> $parametro=shift
@_;</B></TT> por par&aacute;metro.
<P>
Caracter&iacute;sticas de las funciones en la versi&oacute;n 5.002
y superiores
<P>
Debe notarse que en versiones anteriores de perl no todas est&aacute;n
implementadas, en particular, los prototipos de funci&oacute;n
no est&aacute;n implementadas sino hasta la versi&oacute;n 5.002.
<P>
Si un procedimiento o funci&oacute;n ya ha sido declarado y se
ejecuta como instrucci&oacute;n en una l&iacute;nea puede omitirse
el s&iacute;mbolo <TT><B>&amp;</B></TT> al inicio de su nombre.
Es mas, siendo que perl no requiere el uso de par&eacute;ntesis
al inicio y final de una funci&oacute;n, los par&aacute;metros
pueden seguir al nombre de la funci&oacute;n como para cualquier
otra funci&oacute;n nativa de Perl.
<P>
La verdadera utilidad de declarar nuestras funciones es el reducir
la cantidad y complejidad de la revisi&oacute;n debe hacer de
los valores que recibe como par&aacute;metros (dejando a Perl
una mayor parte del trabajo), por ejemplo, si construimos una
funci&oacute;n que forzosamente requiera una clase de valor como
par&aacute;metro (por ejemplo, una referencia) podemos definirla
de modo que solo acepte par&aacute;metros que cumplan con esta
caracter&iacute;stica, de modo que perl genere un error en caso
de que traten de pasarle un dato de tipo distinto, en vez de que
nosotros tengamos que verificar si el escalar recibido corresponde
o no a una referencia.
<P>
A continuaci&oacute;n revisaremos la definici&oacute;n de las
subrutinas y funciones, Perl no hace mayor diferencia entre estas,
de hecho se manejan igual y usaremos los t&eacute;rminos indistintamente
a lo lago de esta secci&oacute;n.
<P>
Sintaxis b&aacute;sica:
<P>
Declaraciones; especifican que habr&aacute; una funci&oacute;n
de este nombre pero no especifican su c&oacute;digo, requieren
que posteriormente se haga la definici&oacute;n.
<PRE WIDTH=132>
<B>sub NOMBRE;</B>             Con par&aacute;metros indeterminados (estilo Perl4)      

<B>sub NOMBRE(PROTOTIPO);</B>              Especificando clase de par&aacute;metros, Perl5.002 o    

</PRE>

<P>
Definiciones Se especifica el c&oacute;digo de una funci&oacute;n,
y si se desea, tambi&eacute;n su nombre y prototipo (tipo y numero
de par&aacute;metros).
<PRE WIDTH=132>
<B>sub NOMBRE BLOQUE;</B>           Definici&oacute;n de la funci&oacute;n, par&aacute;metros         
                             indeterminados                               

<B>sub NOMBRE (PROTOTIPO)</B>       Definici&oacute;n con par&aacute;metros                    
<B>BLOQUE</B>                                                                    

<B>$subref=sub BLOQUE</B>           Especifica c&oacute;digo y regresa una referencia   
                             a el, en este caso $subref es una            
                             referencia a una funci&oacute;n de par&aacute;metros       
                             indeterminados cuyo c&oacute;digo esta contenido    
                             en <B>BLOQUE</B>. No lo discutiremos a detalle por  
                             considerarlo una aplicaci&oacute;n especial de      
                             referencias y subrutinas.                    


</PRE>

<P>
Los elementos que empleo en esta definici&oacute;n son:
<PRE WIDTH=132>
<B>NOMBRE</B>      Es un identificador valido para perl (palabra formada de      
            n&uacute;meros, letras y bajo-guion con las mismas reglas que C,     
            Pascal y dem&aacute;s. Es el nombre con el que se podr&aacute; invocar la   
            funci&oacute;n, si se omite, en vez de definir o declarar la         
            funci&oacute;n se generara una referencia a una funci&oacute;n an&oacute;nima.     

<B>BLOQUE</B>      Es un bloque de c&oacute;digo, al igual que en los ciclos de         
            control, siempre inician con &quot;<B>{</B>&quot; y terminan con &quot;<B>}</B>&quot;, dentro,  
            puede haber cualquier serie de sentencias de perl, y          
            determina un espectro de validez para las variables que se    
            declaren locales con <B>my</B>.                                             

<B>PROTOTIPO</B>   Es una cadena que indica la clase y una caracter&iacute;stica de     
            cada par&aacute;metro que la funci&oacute;n recibir&aacute;.                       


</PRE>

<P>
Comencemos revisando como crear un procedimiento que no tome par&aacute;metros.
<PRE>
<B>sub sencillito
{
  print &quot;Yo soy un procedimiento sencillito\n&quot;;
}</B>
</PRE>

<P>
Este procedimiento se invocara con el identificador &quot;<TT><B>sencillito</B></TT>&quot;
o &quot;<TT><B>&amp;sencillito</B></TT>&quot; , ejecutara su c&oacute;digo
y terminara sin regresar un valor. Una versi&oacute;n de este
que ahora es funci&oacute;n (pues regresa un escalar) ser&aacute;:
<PRE>
<B>sub sencillo
{
  print &quot;Yo soy una funci&oacute;n sencilla\n&quot;;
  return &quot;sencilla&quot;;
  die(&quot;no me muero\n&quot;);
}</B>
</PRE>

<P>
Este procedimiento, regresa la cadena &quot;<TT><B>sencillo</B></TT>&quot;
despu&eacute;s de imprimir el mensaje especificado en el print,
n&oacute;tese que despues del return no continua su ejecuci&oacute;n
y que al igual que &quot;<TT><B>sencillito</B></TT>&quot; no pone
atenci&oacute;n a los par&aacute;metros, que podr&iacute;an de
hecho, pas&aacute;rsele o no.
<P>
return es la palabra reservada que hace que un procedimiento o
funci&oacute;n termine y regrese un valor, si se usa el return
sin especificar valor o si se llega al final del c&oacute;digo
sin encontrar return regresa un nulo.
<P>
Si deseamos tomar par&aacute;metros, pero no aun hacer uso de
los prototipos, debemos tomar en cuenta que todos los par&aacute;metros
vienen empacados en <TT><B>@_</B></TT> el arreglo default, y que
para obtenerlos podemos usar las siguientes expresiones:
<PRE>
<B>($primero,$segundo,$tercero)=@_;	#Obtiene tres escalares del arreglo (n&oacute;tese que si tercero fuese arreglo, absorber&iacute;a el resto de los escalares en @_)
$primero=shift @_;
$segundo=shift @_;
$tercero=shift @_;	#Tambi&eacute;n obtiene tres par&aacute;metros de @_, pero este tambi&eacute;n los retira de @_, pues el operador shift toma el primer elemento de una lista y lo elimina, regres&aacute;ndolo como resultado de la expresi&oacute;n.</B>
</PRE>

<P>
La ventaja del segundo m&eacute;todo es que se retiran de <TT><B>@_</B></TT>
los elementos que eran par&aacute;metros para la funci&oacute;n
que hacemos, de modo que <TT><B>@_</B></TT> puede contener mas
informaci&oacute;n &uacute;til para alg&uacute;n otro prop&oacute;sito.
<P>
Las referencias son de gran utilidad para manejar todo tipo de
datos como par&aacute;metros a una funci&oacute;n, de hecho, la
&uacute;nica posibilidad de pasar un arreglo a un procedimiento
sin que el arreglo pierda su identidad requiere el uso de referencias,
aunque como veremos, este requisito puede esconderse al invocar
la funci&oacute;n (no as&iacute; al implementarla).
<P>
De cualquier modo, si recibimos referencias como par&aacute;metros
solo deberemos darles el manejo de escalares para extraerlas de
<TT><B>@_</B></TT> y usarlas como siempre.
<P>
La manera de &quot;ocultar&quot; la necesidad de referencias en
el momento de invocar la funci&oacute;n implica el uso de prototipos.
<P>
Los prototipos pueden ser de gran utilidad para evitar errores
de programaci&oacute;n al invocar funciones con los par&aacute;metros
equivocados, por lo que a pesar de no ser un tema b&aacute;sico
lo incluyo en este documento.
<P>
Las cadenas del prototipo se componen de los siguientes s&iacute;mbolos:
<HR>

<PRE WIDTH=132>
<B>$</B>    Escalar                                                              

<B>@</B>    Arreglo (toma todos los par&aacute;metros siguientes en el arreglo)         

<B>%</B>    Arreglo Asociativo (tambi&eacute;n absorbe todos los par&aacute;metros)            

<B>\</B>    El identificador del siguiente par&aacute;metro deber&aacute; iniciar c&oacute;n ($,@ o %).                                              

<B>;</B>    Los siguientes par&aacute;metros son opcionales                             


</PRE>
<HR>

<P>
As&iacute; por ejemplo, las siguientes definiciones especifican:
<PRE>
<B>sub biescalar ($$);	#recive dos escalares
sub escarreglo ($@);	# toma el primer par&aacute;metro individual y todos los dem&aacute;s en un arreglo.
sub tomahash (%);	#los par&aacute;metros recibidos forman un hash
sub dosotresesc ($$;$);	#dos escalares obligatorios y un tercero opcional.
sub arreglos (\@$\@);   #un arreglo, un escalar y despu&eacute;s otro arreglo, sin que se mezclen.</B>
</PRE>

<P>
Debe notarse que si se utilizan los par&aacute;metros de clase
arreglo y hash sin &quot;\&quot; estos ser&aacute;n el ultimo par&aacute;metro
a recibir, pues tomaran el resto de los par&aacute;metros dentro
de si, de modo que si se desea tomar mas de un arreglo o hash
como par&aacute;metro se deber&aacute; especificar la clase con
&quot;\&quot;. N&oacute;tese que el uso de &quot;\&quot; tiene
como efecto colateral que se recibe una referencia al arreglo,
hash o escalar, la que esta garantizada a ser una referencia al
tipo especificado; n&oacute;tese que no por eso el par&aacute;metro
que acepta la funci&oacute;n es una referencia, por el contrario,
debe ser una variable de la clase especificada.
<P>
Este mecanismo, nos permite controlar la clase de la variable
que nos d&aacute; el velor que recibimos como par&aacute;metro.
<P>
A continuaci&oacute;n, veremos un ejemplo sencillo del uso de
prototipos y funciones en un programa que especifica una funci&oacute;n
que debe recibir dos escalares e imprime un saludo con ellos.
<PRE>
<B>#!/usr/bin/perl
print &quot;hola\!\n&quot;;
sub rutina ($$)
{  $nombre=shift @_;
  $direccion=shift @_;
  print &quot;Hola $nombre\nVivies en $direccion\n&quot;;
  return 345;
}

print &quot;Dame tu nombre\n&quot;;
$res[0]=&lt;STDIN&gt;;chop $res[0];
print &quot;Dame tu direccion\n&quot;;
$res[1]=&lt;STDIN&gt;;
chop $res[1];
print rutina $res[0],$res[1] .&quot;\n&quot;;</B>
</PRE>

<P>
Rev&iacute;sese con cuidado este programa y experim&eacute;ntese
con el, de modo que el siguiente programa (una modificaci&oacute;n
del anterior que explota las caracter&iacute;sticas de prototipos
y de referencias para recibir dos arreglos y un escalar como par&aacute;metro)
pueda comprenderse con facilidad.
<PRE>
<B>#!/usr/bin/perl
# Definici&oacute;n de la subrutina &quot;rutina&quot;
sub rutina(\@\$\@)
{
  ($runo,$rsaluda,$rdos)=@_;
  #(@uno+0&gt;@dos+0)?print &quot;uno mayor que dos\n&quot;:print &quot;dos mayor o igual a uno\n&quot;;
  print &quot;$$runo[0],\n&quot;;
  print &quot;$$rsaluda\n&quot;;
  print &quot;$$rdos[0],$$rdos[1],\n&quot;;
  return 345;
}

#Programa principal
#Primer nombre
@res=(&quot;Daniel&quot;,&quot;Sol&quot;,&quot;Llaven&quot;);
#Segundo nombre
@re=(&quot;David&quot;,&quot;Jonathan&quot;,&quot;Sol&quot;,&quot;Llaven&quot;);
$algo=&quot;hola&quot;;
print rutina(@res,$algo,@re) .&quot;***\n&quot;;</B>
</PRE>

<P>
Este segundo programa define una funci&oacute;n con prototipos
que utilizan extensivamente &quot;<TT><B>\</B></TT>&quot;, de
modo que no solo requiere que sus par&aacute;metros sean un arreglo,
un escalar y un segundo arreglo, sino que estos deben ser variables
de las clases <TT><B>@</B></TT>, <TT><B>$</B></TT> y <TT><B>@</B></TT>
respectivamente (por ejemplo, no aceptara una cadena constante
en vez de <TT><B>$algo</B></TT> en la ultima l&iacute;nea).
<P>
Observando el c&oacute;digo, vemos que los par&aacute;metros se
reciben como referencias y se usan como tales, pero que en el
programa principal se pasan los par&aacute;metros como variables
de los tipos especificados en el prototipo (de hecho, &quot;<TT><B>rutina</B></TT>&quot;
no aceptar&aacute; ninguna otra cosa).
<P>
Espero que este ejemplo ayude a entender los conceptos de prototipos
y de subrutinas, en realidad, no suele hacerse hincapi&eacute;
en estos temas por no ser necesarios, dada la libertad que perl
nos da, pero en el contexto de desarrollos medianos a grandes
pueden ser muy valiosos para evitar errores de dif&iacute;cil
detecci&oacute;n.
<P>
En este capitulo, como en todos los dem&aacute;s, es indispensable
que el lector haga programas de ejercicio de su propia inspiraci&oacute;n
con el tiempo y la libertad de probar y experimentar los temas
que revisamos aqu&iacute;.
<blockquote><blockquote>
<A NAME="2.5"><H2>2.5- Operaciones con archivos</H2></A>
</blockquote></blockquote>
<P>
Al menos en la UNAM, Perl se utiliza principalmente con dos prop&oacute;sitos,
el primordial es para implementar interfaces para servicios de
red, y el segundo, es el proceso sistem&aacute;tico de grandes
archivos de texto (bit&aacute;coras de operaci&oacute;n, control
de usuarios, etc.) debido a su facilidad para el manejo de archivos
y si flexibilidad en el manejo de datos capturados de textos (formato
muy com&uacute;n de la informaci&oacute;n en UNIX, que tiene la
&uacute;nica desventaja de hacer crecer un poco mas los archivos,
con las ventajas de ser interpretables con herramientas mas variadas,
e incluso a simple vista, con la posibilidad de comprimirse con
gran eficiencia).
<P>
Debo aclarar desde ahora, que el manejo de archivos binarios,
no es uno de los puntos fuertes de perl, y que aunque puede hacerlo,
no solo no es com&uacute;n, sino que resulta mejor utilizar programas
hechos en C para proveer la manipulaci&oacute;n de este tipo de
archivos, es por esto, que este tema solo lo tocaremos brevemente,
y nos enfocaremos al uso de archivos de texto.
<P>
Las operaciones b&aacute;sicas para trabajar con archivos son:
<PRE>
<B>open(VARCH,ARCHIVO);
&lt;VARCH&gt;;
close(VARCH);</B>
</PRE>

<P>
Que respectivamente abren, leen, y cierran el archivo. Donde:
<PRE WIDTH=132><B>VARCH</B>      Es la variable que identificara al archivo, no se le pone      
           identificador de clase y por convenci&oacute;n, se utiliza con        
           may&uacute;sculas.                                                    

<B>ARCHIVO</B>    Es el nombre del archivo a utilizar, precedido de s&iacute;mbolos     
           que indican el modo de uso del archivo.                        


</PRE>
<blockquote><blockquote><blockquote>
<A NAME="2.5.1"><H3>2.5.1- Apertura y cerrado</H3></A>
</blockquote></blockquote></blockquote>
<P>
Los s&iacute;mbolos con los que especificamos el modo de operaci&oacute;n
de un archivo son:<HR>

<PRE WIDTH=132>
S&iacute;mbolo Significado                                                       

<B>&gt;</B>       El archivo se abrir&aacute; para escritura (borr&aacute;ndolo si existe)        

<B>&lt;</B>       El archivo se abre para lectura                                   

<B>&gt;&gt;</B>      El archivo se abrir&aacute; para escritura agregando al final            

<B>+&lt;</B>      El archivo se abrir&aacute; de lectura escritura                         

<B>+&gt;</B>      El archivo se abre para lectura y escritura vaciandolo primero    


</PRE>
<HR>

<P>
El uso de archivos de lectura y escritura lo revisaremos mas adelante,
pues involucra algunos procesos adicionales al manejo convencional.
<P>
Los &quot;archivos&quot; que no requieren ni abrirse (ni cerrarse)
son, como es de esperarse, la entrada est&aacute;ndar, la salida
est&aacute;ndar y la salida de errores, sin embargo, si pueden
ser cerrados y abiertos con open y close, para esto se utilizan
como nombre de los archivos (sin mas s&iacute;mbolos): <HR>

<PRE WIDTH=132>
<B>&gt;-</B>    Abre la salida          
      est&aacute;ndar                

<B>-</B>     Abre la entrada         
      est&aacute;ndar.               


</PRE>
<HR>

<P>
Si no se utiliza ning&uacute;n s&iacute;mbolo sino solo el nombre
del archivo a utilizar, este archivo se abre para lectura.
<P>
La funci&oacute;n open regresa al evaluarse el valor de la variable
de archivo, o nulo si no se puede abrir el archivo en el modo deseado,
de modo que si se utiliza como condici&oacute;n l&oacute;gica
resultara verdadera en caso de lograr abrir el archivo.
<P>
Algunos ejemplos de apertura de archivos son:
<PRE>
<B>open(ETCP,&quot;&lt;/etc/passwd&quot;);</B>
</PRE>

<P>
Apertura de lectura &uacute;nicamente del /etc/passwd asociado a la variable de archivo ETCP
<PRE>
<B>open(SAL,&quot;&gt;salida.txt&quot;);</B>
</PRE>

<P>
Creaci&oacute;n del archivo &quot;salida.txt&quot; en el directorio
desde donde se invoque el programa, solo de escritura y asociado
a la variable <TT><B>SAL</B></TT>.
<P>
El cerrado de los archivos en una operaci&oacute;n recomendable,
pero no necesaria, en el caso de los archivos, garantiza que todos
los buffers han sido vaciados (o regresa falso en caso de que
haya alg&uacute;n error).
<blockquote><blockquote><blockquote>
<A NAME="2.5.2"><H3>2.5.2- Lectura de datos</H3></A>
</blockquote></blockquote></blockquote>
<P>
La lectura de la informaci&oacute;n contenida en los archivos,
como ya hab&iacute;amos mencionado antes, se realiza con la operaci&oacute;n
<TT><B>&lt;&gt;</B></TT>, en esta ocasi&oacute;n la veremos mas
a detalle.
<P>
El operador <TT><B>&lt;&gt;</B></TT> realiza la lectura de texto
de el archivo, cuya variable se coloca entre <TT><B>&lt;</B></TT>
y <TT><B>&gt;</B></TT>. Ah&iacute; es evaluado en un contexto
de escalar, regresa un rengl&oacute;n, incluyendo el car&aacute;cter
de fin de l&iacute;nea. Si se eval&uacute;a en contexto de lista,
regresa un arreglo de todos los renglones del archivo incluyendo
sus terminadores de l&iacute;nea.
<P>
A manera de ejemplos:
<PRE>
<B>$reng=&lt;ENTRADA&gt;;</B>
</PRE>

<P>
Carga una l&iacute;nea del archivo asociado a ENTRADA (que debe
ser de lectura).
<PRE>
<B>@contenido=&lt;ENTRADA&gt;;</B>
</PRE>

<P>
Toma todas las l&iacute;neas del archivo y las coloca como elementos
consecutivos del arreglo <TT><B>@contenido</B></TT>.
<P>
Debe mencionarse, que cuando se eval&uacute;a el operador <TT><B>&lt;&gt;</B></TT>
para un archivo, el puntero de posici&oacute;n en el archivo va
avanzando, de modo que en aplicaciones sucesivas (de contexto
escalar) recibiremos renglones sucesivos. Y si se aplica en contexto
de arreglo, una evaluaci&oacute;n sucesiva no regresara mas renglones.
<P>
Adem&aacute;s, el operador <TT><B>&lt;&gt; </B></TT>tiene la propiedad
de tomar valor por defecto cuando no se especifica que archivo
debe usar, esta caracter&iacute;stica tiene dos modalidades:
<P>
Usar el ultimo archivo abierto:
<P>
El operador <TT><B>&lt;&gt;</B></TT> continua trabajando con el
ultimo archivo al que reavisamos, por ejemplo:
<PRE>
<B>open(ENT,&quot;&lt;entrada.txt&quot;);	#trabaja con el archivo entrada.txt
while(&lt;&gt;)			#para toda l&iacute;nea del ultimo archivo abierto
{
  print;			# se imprime.
}</B>
</PRE>

<P>
En este programa utilizamos varios par&aacute;metros default de
las funciones:
<P>
en el <TT><B>while(&lt;&gt;)</B></TT> vemos que el operador <TT><B>&lt;&gt;</B></TT>
no tiene ning&uacute;n identificador de archivo, y sin embargo
funciona como si se hubiese puesto <TT><B>&lt;ENT&gt;</B></TT>
en vez de <TT><B>&lt;&gt;</B></TT>, esto es debido a que <TT><B>&lt;&gt;</B></TT>
toma por default al ultimo archivo abierto como archivo default.
<P>
En segundo lugar, vemos que ni asignamos el valor que regrese
<TT><B>&lt;&gt;</B></TT> a ninguna variable ni especificamos que
variable debemos imprimir en el print. En ambos casos se esta
utilizando el par&aacute;metro default <TT><B>$_</B></TT>, &lt;&gt;
por defecto asigna el valor que resulte a <TT><B>$_</B></TT> y
<TT><B>print</B></TT> por defecto imprime a la salida est&aacute;ndar
el valor de <TT><B>$_</B></TT>.
<P>
El otro modo de obtener los valores de archivos por defecto a
trabajar con <TT><B>&lt;&gt;;</B></TT> supongamos un programa
de nombre imprime.pl con el siguiente c&oacute;digo:
<PRE>
<B>while(&lt;&gt;)	#para toda l&iacute;nea del archivo default
{
  print;	#imprimirla
}</B>
</PRE>

<P>
Aparentemente este programa carece de funci&oacute;n pues no especifica
ni abre ning&uacute;n archivo para leer, el modo de especificar
que archivo debe usarse es por medio de par&aacute;metros, de
modo que el programa debe ejecutarse como:
<PRE>
<I><B>imprime.pl entrada.txt</B></I>
</PRE>

<P>
Para que imprima todas las l&iacute;neas del archivo entrada.txt.
<P>
En resumen, si no se especifica cual archivo deber&aacute; de
usarse para leer informaci&oacute;n con la operaci&oacute;n <TT><B>&lt;&gt;</B></TT>
Perl tratara de utilizar:
<OL>
<LI>El ultimo archivo abierto por open
<LI>El siguiente par&aacute;metro como nombre de archivo a abrir
y procesar como de lectura.
</OL>

<P>
N&oacute;tese que si al segundo programa, imprime.pl, se le da
mas de un par&aacute;metro, recorrer&aacute; todos los par&aacute;metros
como nombres de archivos a abrir para usar con <TT><B>&lt;&gt;</B></TT>.
Esto provee un m&eacute;todo muy breve para hacer programas
que procesen los archivos cuyos nombres se pasen como par&aacute;metros.
<P>
Deba tenerse cuidado al emplear las variables de default en un
programa, y no recomiendo que se usen en programas grandes o de
l&oacute;gica compleja, pues estos valores son f&aacute;cilmente
afectables por otras operaciones y se requiere un conocimiento
muy profundo de perl para conocer todas las peculiaridades del
lenguaje en cuanto a estas variables especiales. As&iacute; pues,
recomiendo usarlas solo para hacer mas simples los programas que
ya sean sencillos por si mismos.
<blockquote><blockquote><blockquote>
<A NAME="2.5.3"><H3>2.5.3- Escritura</H3></A>
</blockquote></blockquote></blockquote>
<P>
Una vez que hemos abierto un archivo para escritura, la forma
mas com&uacute;n de escribir en el, es mediante la funci&oacute;n
print, de hecho, print esta dise&ntilde;ada para escribir a archivos,
pero el archivo que utiliza por defecto para escribir es el de
la salida est&aacute;ndar STDOUT, la sintaxis para especificar
que archivo debe utilizarse es:
<PRE>
<B>print ARCHIVO LISTA</B>
</PRE>

<P>
donde:
<P>
<TT><B>ARCHIVO</B></TT> es la variable de tipo archivo donde se
dirigir&aacute; la salida
<P>
<TT><B>LISTA</B></TT> es una lista con los valores a imprimir,
(si solo es un escalar se interpreta como una lista de un solo
elemento, pero evita que al imprimir listas se obtengan los n&uacute;meros
de su cardinalidad en Perl 5).
<P>
Si se desea emplear las variables de archivo guardadas en arreglos,
hashes o como resultado de expresiones se les deber&aacute; poner
en un bloque de c&oacute;digo (entre <TT><B>{}</B></TT>) para
mas informaci&oacute;n consultar la funci&oacute;n print en la
referencia de Perl (secci&oacute;n PERLFUNC).
<P>
As&iacute; pues, para crear y llenar un archivo con los primeros
100 n&uacute;meros enteros:
<PRE>
<B>open(AS,&quot;&gt;enteros.100&quot;);
for($c1=0;$c1&lt;100;$c1++)	# de 0 a 99 (perd&oacute;n si 0 no es entero)
{
  print AS &quot;$c1\n&quot;;		#escribe al archivo de AS el numero.<BR>
  #contenido en $c1 y fin de l&iacute;nea.
}</B>
</PRE>

<P>
N&oacute;tese que si se usan par&eacute;ntesis alrededor de los
par&aacute;metros del print muy probablemente Perl pensara que
toda la expresi&oacute;n entre par&eacute;ntesis especifica el
valor a imprimir resultando en un error, por lo que recomiendo
se evite el uso de par&eacute;ntesis cuando se usa print para
escribir a archivos.
<blockquote><blockquote><blockquote>
<A NAME="2.5.4"><H3>2.5.4- Saltos y proceso binario</H3></A>
</blockquote></blockquote></blockquote>
<P>
Antes que nada debo indicar que las funciones que revisaremos
aqu&iacute; las incluyo, no por considerarlas b&aacute;sicas para
la programaci&oacute;n, sino por su gran utilidad, y para que
se conozca el modo en que perl puede lidiar con archivos binarios.
<P>
Sin embargo, si se pretende desarrollar algo usando estas herramientas
recomiendo ampliamente una saludable dosis de experimentaci&oacute;n
y prototipaje para evitar demoras posteriores, adem&aacute;s,
ser&aacute; indispensable tener la referencia a su lado.
<P>
As&iacute; que si&eacute;ntase el lector con la libertad de saltar
esta secci&oacute;n y continuar con la 2.6, que le resultar&aacute;
mas &uacute;til al corto y mediano plazo.
<P>
Comencemos por la forma en que perl 5 (todo lo que tratare en
esta secci&oacute;n no funciona o funciona de modo muy distinto
en perl 4) puede leer, escribir y manejar informaci&oacute;n binaria,
que llamaremos empaquetada:
<P>
Perl maneja la informaci&oacute;n en tipos abstractos, que nos
ahorran gran trabajo de programaci&oacute;n al momento de usarlos,
desafortunadamente, esto no ayuda en el momento de querer leer
tipos de datos que vienen como una serie de bits dentro de bytes. La
soluci&oacute;n que perl da a este problema es mas o menos sencilla,
pero requiere alg&uacute;n entendimiento de ,que es una cadena.
<P>
Una cadena es una serie de caracteres, como el lector debe ya
saberlo, pero cada car&aacute;cter es en s&iacute; mismo representado
por un byte; as&iacute; que si no somos muy exigentes con los
caracteres que pueden o no ser incluidos en una cadena, podr&iacute;amos
decir que cualquier serie de valores representados en bytes pueden
interpretarse como una cadena. Pues bien, este es el concepto
que Perl explota.
<P>
Un empacado de informaci&oacute;n lo manejaremos como un escalar
que para fines pr&aacute;cticos es de tipo cadena. Pero que en
vez de generar con el operador &quot;<TT><B>.</B></TT>&quot; y
contener texto com&uacute;n y corriente, contiene una serie de
caracteres (que no necesariamente producir&aacute;n resutlados
coherentes si tratamos de imprimirlos) que en si mismos contienen
informaci&oacute;n que nos interesa recuperar.
<P>
El proceso de desempacado de la informaci&oacute;n consiste en
indicar a perl que a partir de una cierta cadena empacada debemos
extraer un arreglo de valores a partir de un formato que deberemos
especificar. La contraparte de este proceso es el generar nuestra
cadena empacada a partir de un arreglo de valores y la misma informaci&oacute;n
de formato que pretendemos leer despu&eacute;s.
<P>
Bajo este enfoque, Perl puede manejar perfectamente bien un archivo
basado en registros, pero tendr&iacute;a serias dificultades para
manejar un archivo que no codifique toda su informaci&oacute;n
en un patr&oacute;n fijo, para esto ser&aacute;
muy importante la capacidad de brincar en la posici&oacute;n del
archivo.
<P>
La sintaxis de las funciones que empaquetan y desempaquetan la
informaci&oacute;n son las siguientes:
<PRE>
<B>pack($FORMATO,@VALORES);</B>
</PRE>

<P>
Esta funci&oacute;n regresa la cadena empacada con el formato
descrito por la cadena <TT><B>$FORMATO</B></TT> que contiene los
valores presentes en el arreglo <TT><B>@VALORES</B></TT>.
<PRE>
<B>unpack($FORMATO,EXPRESION);</B>
</PRE>

<P>
Esta es la contraparte de pack, usando el formato especificado
por <TT><B>$FORMATO</B></TT> extrae los valores de la cadena que
resulte de <TT><B>EXPRESI&Oacute;N</B></TT> (probablemente la
variable que contiene la variable) y regresa al evaluarse un arreglo
de valores de los tipos especificados.
<P>
Para especificar el formato en el que se empaquetara o con el
cual desempaquetar la informaci&oacute;n se usa la siguiente sintaxis:
<HR>

<PRE WIDTH=132>
Simbolo  Significado                                                      

<B>A</B>        Cadena ASCII rellenada con espacios a la derecha.                

<B>a</B>        Cadena ASCII rellenada de nulos a la derecha.                    

<B>b</B>        Cadena de bits (Orden ascendente de bits)                        

<B>B</B>        Cadena de bits (Orden descendente de bits)                       

<B>h</B>        Cadena de nibbles (en hexadecimal con el nibble bajo primero)    

<B>H</B>        Cadena de nibbles (en hexadecimal con el nibble alto primero)    

<B>c</B>        Un valor de car&aacute;cter con signo                                   

<B>C</B>        Un valor de car&aacute;cter sin signo                                   

<B>s</B>        Un entero corto con signo                                        

<B>S</B>        Un entero corto sin signo                                        

<B>i</B>        Un entero con signo                                              

<B>I</B>        Un entero sin signo                                              

<B>l</B>        Un entero largo con signo                                        

<B>L</B>        Un entero largo sin signo                                        

<B>f</B>        Un punto flotante en formato nativo de Perl                      

<B>d</B>        Un doble en formato nativo de Perl                               

<B>x</B>        Un byte nulo                                                     

<B>X</B>        Regresar un byte                                                 

<B>@</B>        Llenar de nulos hasta la posici&oacute;n absoluta                       


</PRE>
<HR>

<P>
Despu&eacute;s de cada uno de estos se puede colocar un numero
que indicara cuantos elementos de este tipo esperamos, a excepci&oacute;n
de los del primer bloque (cadenas) donde el numero indicara la
longitud de la cadena a interpretar como un solo elemento.
<P>
Todos estos especificadores funcionan tanto a la entrada como
a la salida (e idealmente usamos la misma cadena de formato en
el empaquetado y en el desempaquetado.
<P>
As&iacute; por ejemplo, para leer de una cadena empaquetada los
bits, suponiendo que estos estar ordenados del menos significativo
(al principio) al mas significativo (al final), y que buscamos
leer 32 bits ser&aacute;:
<PRE>
<B>($cadbit)=unpack(&quot;b32&quot;,$paquete);</B>
</PRE>

<P>
N&oacute;tese que al escribir <TT><B>($cadbit)</B></TT> estamos
asignando al escalar <TT><B>$cadbit</B></TT> el primer elemento
del arreglo generado por <TT><B>unpack</B></TT>, es decir, el primer 
elemento generado.
<P>
Por otro lado, para empaquetar y desempaquetar en una cadena 4
enteros podemos escribir:
<PRE>
<B>$paquete=pack(&quot;i4&quot;,(34,-43,127,512));
@enteros=unpack(&quot;i4&quot;,$paquete);</B>
</PRE>

<P>
Debe recordarse que con las cadenas el numero que se pone a continuaci&oacute;n
del car&aacute;cter (aAbBhH) indica la longitud de las cadenas,
pero con los dem&aacute;s tipos indica cuantos elementos de ese
tipo esperamos.
<P>
Ahora, para leer byte por byte un archivo (los cuales podemos
concatenar con los el acostumbrado operador &quot;<TT><B>.</B></TT>&quot;)
utilizamos la funci&oacute;n <TT><B>getc</B></TT> 
<PRE>
<B>getc ARCHIVO;</B>
</PRE>

<P>
Esta funci&oacute;n regresa el siguiente car&aacute;cter del archivo
al que <TT><B>ARCHIVO</B></TT> hace referencia, o una cadena vac&iacute;a
(falso l&oacute;gico) si llegamos al fin de archivo.
<P>
Por ejemplo, hagamos un diminuto programa que nos muestre los
valores hexadecimales y binarios de todos los bytes de un archivo:
<PRE>
<B>#!/usr/bin/perl
#programa de prueba de las capacidades de desempaquetado 
#y proceso binario de archivos en Perl5
open(AE,&quot;&lt;$ARGV[0]&quot;);
$contador=0;
print &quot;offset\thexa\tbinario\t\tcaracter\n&quot;;
while($ch=getc(AE))
{
  $binario=unpack(&quot;B8&quot;,$ch); #deseamos el bit mas significativo a la izquierda
  $hexa=unpack(&quot;H2&quot;,$ch); #nibble mas significativo primero
  print &quot;$contador\t$hexa\t$binario\t\&quot;$ch\&quot;\n&quot;; #$ch es el car&aacute;cter original
  $contador++;
}
close(AE);</B>
</PRE>

<P>
Este programa tambi&eacute;n intenta imprimir el car&aacute;cter
le&iacute;do con fines did&aacute;cticos, si se emplea con archivos
aut&eacute;nticamente binarios recomiendo que se elimine <TT><B>$ch</B></TT>
de las variables a imprimir.
<P>
La caracter&iacute;stica com&uacute;nmente utilizada del proceso
de archivos binarios que resta por revisar es la lectura aleatoria
de archivos; esto se logra cambiando arbitrariamente la posici&oacute;n
del apuntador de archivo mediante la funci&oacute;n <TT><B>search</B></TT>.
Esta funci&oacute;n trabaja por bytes, de modo que es de muy
poca utilidad cuando trabajamos con archivos de texto. La sintaxis

de la funci&oacute;n es:
<PRE>
<B>search ARCHIVO,POSICION,MODO</B>
</PRE>


<P>
donde:
<PRE WIDTH=132>
<B>ARCHIVO</B>     es la variable con la que hacemos referencia a un archivo     

<B>POSICI&Oacute;N</B>    Especifica el avance desde la posici&oacute;n que indique el modo    


<B>MODO</B>        <B>1</B>-Desde el inicio, <B>2</B>-Desde la posici&oacute;n actual, <B>3</B>-Desde el     
            final.                                                     
</PRE>
<blockquote><blockquote>
<A NAME="2.6"><H2>2.6- Operaciones con recursos del sistema</H2></A>
</blockquote></blockquote>

<P>
Una de las grandes ventajas de Perl sobre otros lenguajes es la
facilidad con la que interact&uacute;a con otros programas y con
el sistema (UNIX en particular pero cualquiera en lo general).
De hecho, una de las grandes mejoras del Perl5 sobre el Perl4
es que tiene un proceso mucho mejor coordinado de programas concurrentes
invocados desde Perl, por lo que recomiendo ampliamente se considere
el desarrollar programas que usen intensivamente el sistema con
Perl5 (o superior).
<P>
Por considerar esta solo una introducci&oacute;n planteare solo
las formas mas b&aacute;sicas de interacci&oacute;n con el sistema,
recomiendo ampliamente, que para las tareas especificas para las
que se suelen usar llamadas al sistema se consulte la referencia
de Perl en la secci&oacute;n PERLFUNC para averiguar si est&aacute;n
presentes y cual es la manera de usarlas.
<P>
En esta secci&oacute;n revisaremos tan solo los m&eacute;todos
de ejecuci&oacute;n de programas comandos del sistema operativo
que dividiremos en tres categor&iacute;as:
<UL>
<LI>Como expresiones a evaluar: Ya lo hamos revisado en la secci&oacute;n
de operadores, pero conviene repetirlo en este contexto.
<LI>Sin interrelaci&oacute;n: Invocaci&oacute;n de comandos y
programas esperando su culminaci&oacute;n antes de terminar, o
de modo que sean la ultima acci&oacute;n de nuestro programa.
<LI>Entubados: Principalmente mediante el uso de open y close,
nos permiten alimentar de informaci&oacute;n otros procesos o
alimentar nuestro programa del resultado de ellos.
</UL>
<blockquote><blockquote><blockquote>
<A NAME="2.6.1"><H3>2.6.1 Como expresiones</H3></A>
</blockquote></blockquote></blockquote>
<P>
Como ya vimos, con el uso de las comillas <TT><B>``</B></TT> podemos
tratar un comando del S.O. como si fuese una expresi&oacute;n
la cual nos regresa los resultados que dicho comando entrega a
su salida est&aacute;ndar.
<P>
algunos ejemplos de esto son:
<PRE>
<B>`date`</B>
</PRE>

<P>
evalua como &quot;Thu Sep 12 18:49:47 CST 1996\n&quot; suponiendo
que esa fuese la fecha
<PRE>
<B>`wc -l Hola.pl`</B>
</PRE>

<P>
evalua como &quot; 3 Hola.pl&quot; suponiendo que Hola.pl tuviese
tres l&iacute;neas.
<P>
Es la forma mas sencilla de ejecutar comandos desde nuestro programa en Perl.<BR>
Debe aclararse que Perl 4 solo ejecuta el comando dejando la salida estandar de este 
a la salida del script de Perl; de modo que no regresa ningun valor a nuestro script de Perl 4.<P>

<A NAME="2.6.2"><H3>2.6.2 Sin interrelaci&oacute;n</H3></A>

<P>
Por interrelaci&oacute;n entiendase que: Ya sea que la entrada
est&aacute;ndar del proceso ejecutado sea tomada desde nuestro
programa. O que nuestro programa tome la salida del comando, de
modo que en estos m&eacute;todos la salida est&aacute;ndar del
programa ejecutado ser&aacute; la salida est&aacute;ndar que nuestro
propio programa tiene (consola por lo regular) y lo mismo para
la entrada est&aacute;ndar.
<P>
Hay dos m&eacute;todos para invocar programas con estas caracter&iacute;sticas
&quot;<TT><B>system</B></TT>&quot; y &quot;<TT><B>exec</B></TT>&quot;,
y la diferencia entre estos radica en el ambiente que el programa
invocado ocupara. La sintaxis de estas es:
<PRE>
<B>system(PROGRAMA);</B>
</PRE>

<P>
Ejecuta PROGRAMA como un nuevo proceso, espera a que acabe y continua
<PRE>
<B>exec(PROGRAMA);</B>
</PRE>

<P>
Ejecuta PROGRAMA, y termina nuestro script siendo reemplazado por el PROGRAMA que ejecutamos.
<P>
donde <TT><B>PROGRAMA</B></TT> es una cadena conde esta el comando
(como lo dar&iacute;amos en S.O.) a ejecutar, puede ser un comando
compuesto, por ejemplo:
<PRE>
<B>$comando=&quot;cat Hola.pl |grep daniel&quot;;
system($comando);#equivalente a system(&quot;cat Hola.pl |grep daniel&quot;);</B>
</PRE>

<P>
efectivamente escribir&aacute; en la salida est&aacute;ndar las
l&iacute;neas del script Hola.pl en las que aparezca la palabra
<TT><B>&quot;daniel&quot;</B></TT>.
<P>
Cuando un programa se ejecuta, las variables de ambiente, el camino
actual y otras condiciones del sistema operativo suelen ser determinantes
para su desempe&ntilde;o, cuando utilizamos system, el programa
a ser ejecutado se ejecuta en un nuevo ambiente (que no tiene
mas relaci&oacute;n con el nuestro que gozar de los mismos privilegios),
mientras que cuando lo ejecutamos con exec el programa de hecho
substituye a nuestro script de perl en el ambiente, de modo que
hereda todas las caracter&iacute;sticas que nuestro script haya
determinado del ambiente.
<P>
De este modo, una posible aplicaci&oacute;n de exec es cuando
debemos forzar que el programa que ejecutamos tome variables de
ambiente que colocamos con el script de perl, en cambio system
es necesario cuando debemos ejecutar mas de un programa, o cuando
debemos realizar mas acciones con nuestro script una vez que el
programa invocado termine.
<blockquote><blockquote><blockquote>
<A NAME="2.6.3"><H3>2.6.3 Entubados </H3></A>
</blockquote></blockquote></blockquote>
<P>
En esta secci&oacute;n, veremos como podemos capturar la salida
que los programas que ejecutemos generan y procesar esta como
si fuese un archivo y por otra parte, como podemos asignar una
variable de archivo a la entrada est&aacute;ndar de un programa
que ejecutemos para que procese lo que le alimentemos.
<P>
Una nota importante: Cuando ejecutamos programas de este modo
Perl no espera a que el programa termine para continuar, si deseamos
que lo haga debemos usar close con la variable de archivo que
les asociemos para indicar que el programa debe terminar (y perl
efectivamente esperara a que lo haga).
<P>
La ejecuci&oacute;n de comandos o programas asoci&aacute;ndolos
a archivos se hace a&ntilde;adiendo el car&aacute;cter &quot;<TT><B>|</B></TT>&quot;
al comando a ejecutar y utilizando el comando <TT><B>open</B></TT>.
<P>
Por ejemplo, supongamos que deseamos procesar el resultado de
un programa llamado &quot;fuente&quot;. Si el comando para su
ejecuci&oacute;n desde sistema operativo fuese:
<P>
<B><TT>fuente saluda 3</TT></B>
<P>
deberemos &quot;Abrirlo&quot; de la siguiente forma:
<PRE>
<B>open(RESF,&quot;fuente saluda 3|&quot;);
while(&lt;RESF&gt;)
{
  #procesar los renglones que va poniendo en $_
}
close(RESF);	#espera a que termine y cierra el flujo de datos</B>
</PRE>

<P>
N&oacute;tese como se coloco el car&aacute;cter &quot;<TT><B>|</B></TT>&quot;
al final del comando usual. Y que <TT><B>RESF</B></TT> funciona
como un archivo abierto para lectura. Tambi&eacute;n es conveniente
recalcar que si deseamos ejecutar un comando que per se utilice
entubamientos se puede hacer, por ejemplo:
<PRE>
<B>open(ALGO,&quot;fuente hola 3|prcesa_hola |&quot;);</B>
</PRE>

<P>
Asociara a <TT><B>ALGO</B></TT> lo que el programa procesa_hola
genere en su salida est&aacute;ndar, mientras que el S.O. ha entubado
la salida de &quot;<I><B>fuente</B></I>&quot; a la entrada de
&quot;<I><B>procesa_hola</B></I>&quot;.
<P>
Del mismo modo, si deseamos poner informaci&oacute;n a la entrada
est&aacute;ndar de un comando deberemos abrirlo colocando el s&iacute;mbolo
&quot;<TT><B>|</B></TT>&quot; como primer car&aacute;cter del
comando. Y el archivo que asociemos se deber&aacute; usar como
una archivo abierto para escritura.
<P>
De nuevo, cuando indiquemos el close, Perl enviara un EOF al archivo
al que estamos ejecutando y esperara a que este le indique el
termino de su proceso.<P>
