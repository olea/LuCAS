<html>

<head>
<title>stdio.html</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">


<meta name="Microsoft Theme" content="none, default"><meta name="Microsoft Border" content="tl, default"></head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td>

<p align="center">&nbsp;</p>
</td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%">

<p>&nbsp;</p>
</td><td valign="top" width="24"></td><!--msnavigation--><td valign="top">

<p>Este es el fichero <strong>stdio.h </strong>de Linux. Está localizable en <font face="Courier"><strong>/usr/include/stdio.h</strong></font> </p>

<p>&nbsp;</p>

<p>&nbsp;</p>
<font size="2">

<p></font><font size="3"><code>/* This is part of the iostream/stdio library, providing
-*- C -*- I/O.<br>
Define ANSI C stdio on top of C++ iostreams.<br>
Copyright (C) 1991, 94, 95, 96, 97, 98 Free Software Foundation, Inc.<br>
This library is free software; you can redistribute it and/or<br>
modify it under the terms of the GNU Library General Public<br>
License as published by the Free Software Foundation; either<br>
version 2 of the License, or (at your option) any later version.</code></font></p>

<p><font size="3"><code>This library is distributed in the hope that it will be useful,<br>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU<br>
Library General Public License for more details.<br>
You should have received a copy of the GNU Library General Public<br>
License along with this library; if not, write to the Free Software<br>
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</code></font></p>

<p><font size="3"><code>*/</code></font></p>

<p><font size="3"><code>/*</code></font></p>

<p><font size="3"><code>* ISO C Standard: 4.9 INPUT/OUTPUT &lt;stdio.h&gt;</code></font></p>

<p><font size="3"><code>*/</code></font></p>

<p><font size="3"><code>#ifndef _STDIO_H<br>
#define _STDIO_H<br>
#define _STDIO_USES_IOSTREAM<br>
#include &lt;libio.h&gt;<br>
#ifndef NULL<br>
#ifdef __cplusplus<br>
#define NULL 0<br>
#else<br>
#define NULL (void*)0<br>
#endif</code></font></p>

<p><font size="3"><code>#endif<br>
#ifndef EOF<br>
#define EOF (-1)<br>
#endif</code></font></p>

<p><font size="3"><code>#ifndef BUFSIZ<br>
#define BUFSIZ _IO_BUFSIZ<br>
#endif</code></font></p>

<p><font size="3"><code>#define _IOFBF 0 /* Fully buffered. */<br>
#define _IOLBF 1 /* Line buffered. */<br>
#define _IONBF 2 /* No buffering. */<br>
#define SEEK_SET 0<br>
#define SEEK_CUR 1<br>
#define SEEK_END 2</code></font></p>

<p><font size="3"><code>/* define size_t. Crud in case &lt;sys/types.h&gt; has defined it.
*/<br>
#if !defined(_SIZE_T) &amp;&amp; !defined(_T_SIZE_) &amp;&amp; !defined(_T_SIZE)<br>
#if !defined(__SIZE_T) &amp;&amp; !defined(_SIZE_T_) &amp;&amp; !defined(___int_size_t_h)<br>
if !defined(_GCC_SIZE_T) &amp;&amp; !defined(_SIZET_)<br>
#define _SIZE_T<br>
#define _T_SIZE_<br>
#define _T_SIZE<br>
#define __SIZE_T<br>
#define _SIZE_T_<br>
#define ___int_size_t_h<br>
#define _GCC_SIZE_T<br>
#define _SIZET_typedef _IO_size_t size_t;<br>
#endif<br>
#endif<br>
#endif</code></font></p>

<p><font size="3"><code>typedef struct _IO_FILE FILE;<br>
typedef _IO_fpos_t fpos_t;</code></font></p>

<p><font size="3"><code>#include &lt;stdio_lim.h&gt;</code></font></p>

<p><font size="3"><code>#ifdef __USE_SVID</code></font></p>

<p><font size="3"><code>/* Default path prefix for `tempnam' and `tmpnam'. */<br>
#define P_tmpdir &quot;/tmp&quot;<br>
#endif</code></font></p>

<p><font size="3"><code>/* For use by debuggers. These are linked in if printf or fprintf
are used. */</code></font></p>

<p><font size="3"><code>extern FILE *stdin, *stdout, *stderr; /* TODO */</code></font></p>

<p><font size="3"><code>#define stdin _IO_stdin<br>
#define stdout _IO_stdout<br>
#define stderr _IO_stderr<br>
#ifdef __cplusplus</code></font></p>

<p><font size="3"><code>extern &quot;C&quot; {</code></font></p>

<p><font size="3"><code>#endif</code></font></p>

<p><font size="3"><code>#ifndef __P<br>
#if defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus)<br>
#define __P(args) args<br>
#else<br>
#define __P(args) ()<br>
#endif<br>
#endif /*!__P*/</code></font></p>

<p><font size="3"><code>extern void clearerr __P ((FILE*));<br>
extern int fclose __P ((FILE*));<br>
extern int feof __P ((FILE*));<br>
extern int ferror __P ((FILE*));<br>
extern int fflush __P ((FILE*));<br>
extern int fgetc __P ((FILE *));<br>
extern int fgetpos __P ((FILE* fp, fpos_t *__pos));<br>
extern char* fgets __P ((char*, int, FILE*));<br>
extern FILE* fopen __P ((__const char*, __const char*));<br>
extern FILE* fopencookie __P ((void *__cookie, __const char
*__mode,_IO_cookie_io_functions_t __io_functions));<br>
extern int fprintf __P ((FILE*, __const char* __format, ...));<br>
extern int fputc __P ((int, FILE*));<br>
extern int fputs __P ((__const char *__str, FILE *__fp));<br>
extern size_t fread __P ((void*, size_t, size_t, FILE*));<br>
extern FILE* freopen __P ((__const char*, __const char*, FILE*));<br>
extern int fscanf __P ((FILE *__fp, __const char* __format, ...));<br>
extern int fseek __P ((FILE* __fp, long int __offset, int __whence));<br>
extern int fsetpos __P ((FILE* __fp, __const fpos_t *__pos));<br>
extern long int ftell __P ((FILE* __fp));<br>
extern size_t fwrite __P ((__const void*, size_t, size_t, FILE*));<br>
extern int getc __P ((FILE *));<br>
extern int getchar __P ((void));<br>
extern char* gets __P ((char*));<br>
extern void perror __P ((__const char *));<br>
extern int printf __P ((__const char* __format, ...));<br>
extern int putc __P ((int, FILE *));<br>
extern int putchar __P ((int));<br>
extern int puts __P ((__const char *__str));<br>
extern int remove __P ((__const char*));<br>
extern int rename __P ((__const char* __old, __const char* __new));<br>
extern void rewind __P ((FILE*));<br>
extern int scanf __P ((__const char* format, ...));<br>
extern void setbuf __P ((FILE*, char*));<br>
extern void setlinebuf __P ((FILE*));<br>
extern void setbuffer __P ((FILE*, char*, int));<br>
extern int setvbuf __P ((FILE*, char*, int __mode, size_t __size));<br>
extern int sprintf __P ((char*, __const char* __format, ...));<br>
extern int sscanf __P ((__const char* string, __const char* __format, ...));<br>
extern FILE* tmpfile __P ((void));<br>
extern char* tmpnam __P ((char*));<br>
#ifdef __USE_MISC<br>
extern char* tmpnam_r __P ((char*));<br>
#endif</code></font></p>

<p><font size="3"><code>#if defined(__USE_SVID) || defined(__USE_XOPEN)<br>
extern char *tempnam __P ((__const char *__dir, __const char *__pfx));<br>
#endif</code></font></p>

<p><font size="3"><code>extern char *__stdio_gen_tempname __P ((char *__buf, size_t
bufsize,__const char *dir, __const char *pfx,int dir_search, size_t *lenptr,FILE
**streamptr));<br>
extern int ungetc __P ((int c, FILE* fp));<br>
extern int vfprintf __P ((FILE *fp, char __const *fmt0, _G_va_list));<br>
extern int vprintf __P ((char __const *fmt, _G_va_list));<br>
extern int vsprintf __P ((char* string, __const char* format, _G_va_list));<br>
extern void __libc_fatal __P ((__const char *__message))__attribute__ ((__noreturn__));</code></font></p>

<p><font size="3"><code>#ifndef __STRICT_ANSI__extern int dprintf __P ((int, __const char
*, ...));<br>
extern int vdprintf __P ((int, __const char *, _G_va_list));<br>
extern int vfscanf __P ((FILE*, __const char *, _G_va_list));<br>
extern int __vfscanf __P ((FILE*, __const char *, _G_va_list));<br>
extern int vscanf __P ((__const char *, _G_va_list));<br>
extern int vsscanf __P ((__const char *, __const char *, _G_va_list));<br>
extern int __vsscanf __P ((__const char *, __const char *, _G_va_list));<br>
#endif</code></font></p>

<p><font size="3"><code>#ifdef __USE_GNU<br>
extern int __fcloseall __P ((void));<br>
extern int fcloseall __P ((void));<br>
struct obstack;<br>
extern int obstack_vprintf __P ((struct obstack *__obstack,__const char *__fmt,
_G_va_list));<br>
extern int obstack_printf __P ((struct obstack *__obstack, __const char *__fmt,...));<br>
#endif</code></font></p>

<p><font size="3"><code>#if !defined(__STRICT_ANSI__) || defined(__USE_POSIX)<br>
extern FILE *fdopen __P ((int, __const char *));<br>
extern int fileno __P ((FILE*));<br>
extern FILE* popen __P ((__const char*, __const char*));<br>
extern int pclose __P ((FILE*));<br>
#define L_ctermid 9<br>
#define L_cuserid 9</code></font></p>

<p><font size="3"><code>/* Return the name of the controlling terminal. */<br>
extern char *ctermid __P ((char *__buf));<br>
</code></font></p>

<p><font size="3"><code>/* Get character login name of the user. */<br>
extern char *cuserid __P ((char * __buf));<br>
#endif</code></font></p>

<p><font size="3"><code>#if defined __USE_BSD<br>
extern int snprintf __P ((char *, size_t, __const char *, ...));<br>
extern int __snprintf __P ((char *, size_t, __const char *, ...));<br>
extern int vsnprintf __P ((char *, size_t, __const char *, _G_va_list));<br>
extern int __vsnprintf __P ((char *, size_t, __const char *, _G_va_list));<br>
#endif</code></font></p>

<p><font size="3"><code>#ifdef __USE_GNU<br>
extern _IO_ssize_t getdelim __P ((char **, size_t *, int, FILE*));<br>
extern _IO_ssize_t getline __P ((char **, size_t *, FILE *));<br>
extern _IO_ssize_t __getline __P ((char **, size_t *, FILE *));<br>
extern int asprintf __P ((char **, const char *, ...));<br>
extern int vasprintf __P ((char **, const char *, _G_va_list));<br>
<br>
/* Open a stream that writes into a malloc'd buffer that is expanded asnecessary. *BUFLOC
and *SIZELOC are updated with the buffer's locationand the numberof characters written on
fflush or fclose. */<br>
extern FILE *open_memstream __P ((char **__bufloc, size_t *__sizeloc));<br>
#endif<br>
extern int __underflow __P ((struct _IO_FILE*));<br>
extern int __overflow __P ((struct _IO_FILE*, int));<br>
#ifdef __USE_BSD<br>
extern int sys_nerr;<br>
extern const char *const sys_errlist[];<br>
#endif</code></font></p>

<p><font size="3"><code>#ifdef __USE_GNU<br>
extern int _sys_nerr;<br>
extern const char *const _sys_errlist[];<br>
#endif</code></font></p>

<p><font size="3"><code>/* Handle locking of streams. */<br>
#ifdef __USE_MISC<br>
extern void clearerr_locked __P ((FILE *));<br>
extern void clearerr_unlocked __P ((FILE *));<br>
extern int feof_locked __P ((FILE *));<br>
extern int feof_unlocked __P ((FILE *));<br>
extern int ferror_locked __P ((FILE*));<br>
extern int ferror_unlocked __P ((FILE*));<br>
extern int fileno_locked __P ((FILE *));<br>
extern int fileno_unlocked __P ((FILE *));<br>
extern int fclose_unlocked __P ((FILE *));<br>
extern int fflush_locked __P ((FILE *));<br>
extern int fflush_unlocked __P ((FILE *));<br>
extern size_t fread_unlocked __P ((void *, size_t, size_t, FILE *));<br>
extern size_t fwrite_unlocked __P ((const void *, size_t, size_t, FILE *));<br>
extern int fputc_locked __P ((int, FILE*));<br>
extern int fputc_unlocked __P ((int, FILE*));<br>
extern int getc_locked __P ((FILE *));<br>
extern int getchar_locked __P ((void));<br>
extern int putc_locked __P ((int, FILE *));<br>
extern int putchar_locked __P ((int));<br>
# ifndef _LIBC<br>
# define getc_locked(fp) _IO_getc (fp)<br>
# define getchar_locked() _IO_getc (stdin)<br>
# define putchar_locked(c) _IO_putc (c, stdout)<br>
# endif<br>
#endif<br>
#if defined __USE_POSIX || defined __USE_MISC<br>
<br>
/* These are defined in POSIX.1:1996. */<br>
extern void flockfile __P ((FILE *));<br>
extern void funlockfile __P ((FILE *));<br>
extern int ftrylockfile __P ((FILE *));<br>
extern int getc_unlocked __P ((FILE *));<br>
extern int getchar_unlocked __P ((void));<br>
extern int putc_unlocked __P ((int, FILE *));<br>
extern int putchar_unlocked __P ((int));<br>
# ifndef _LIBC<br>
# define getc_unlocked(fp) _IO_getc_unlocked (fp)<br>
# define getchar_unlocked() _IO_getc_unlocked (stdin)<br>
# define putc_unlocked(c, fp) _IO_putc_unlocked ((c), (fp))<br>
# define putchar_unlocked(c) _IO_putc_unlocked ((c), stdout)<br>
# endif<br>
#endif /* POSIX || misc */<br>
#define getc(_fp) _IO_getc (_fp)<br>
#define putc(_ch, _fp) _IO_putc (_ch, _fp)<br>
#define putchar(_ch) _IO_putc (_ch, stdout)<br>
#define getchar() _IO_getc (stdin)<br>
#ifdef __cplusplus<br>
}<br>
#endif<br>
#endif /* !_STDIO_H */</code></font><font SIZE="2"></font>
<!--msnavigation--></td></tr><!--msnavigation--></table></body>
</html>
